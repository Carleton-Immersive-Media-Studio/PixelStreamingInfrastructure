(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["epicgames-frontend"] = factory();
	else
		root["epicgames-frontend"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../../../Common/dist/esm/Event/EventEmitter.js":
/*!******************************************************!*\
  !*** ../../../Common/dist/esm/Event/EventEmitter.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
// To match NodeJS' EventEmitter syntax without downstream code changes we need to use `any`.
// This means we need to disable linting `any` checks on this file.
//
/* eslint-disable @typescript-eslint/no-unsafe-argument */
class PixelStreamingEventListener {
    constructor(callback) {
        this._args = [];
        this._callback = callback;
    }
    handleEvent(_evt) {
        this._callback(...this._args);
        // Reset storage of args.
        this._args = [];
    }
    setArgs(...args) {
        this._args = args;
    }
}
/**
 * A feature-limited, but _mostly_ drop-in replacement for Node's EventEmitter type that is implemented using EventTarget.
 *
 * For those unfamiliar with Node's EventEmitter, here is some info from the official docs:
 *
 * [In NodeJS] all objects that emit events are instances of the `EventEmitter` class. These
 * objects expose an `eventEmitter.on()` function that allows one or more
 * functions to be attached to named events emitted by the object. Typically,
 * event names are camel-cased strings but any valid JavaScript property key
 * can be used.
 *
 * When the `EventEmitter` object emits an event, all of the functions attached
 * to that specific event are called _synchronously_. Any values returned by the
 * called listeners are _ignored_ and discarded.
 *
 * The following example shows a simple `EventEmitter` instance with a single
 * listener. The `eventEmitter.on()` method is used to register listeners, while
 * the `eventEmitter.emit()` method is used to trigger the event.
 *
 * ```js
 * import { EventEmitter } from 'node:events';
 *
 * class MyEmitter extends EventEmitter {}
 *
 * const myEmitter = new MyEmitter();
 * myEmitter.on('event', () => {
 *   console.log('an event occurred!');
 * });
 * myEmitter.emit('event');
 * ```
 */
class EventEmitter extends EventTarget {
    constructor() {
        super();
        this._eventListeners = new Map();
    }
    removeListenerInternal(eventName, listener) {
        if (this._eventListeners.has(eventName)) {
            const listeners = this._eventListeners.get(eventName);
            if (listeners === undefined) {
                return this;
            }
            for (let i = 0; i < listeners.length; ++i) {
                const eventPair = listeners[i];
                if (eventPair.callback === listener) {
                    // Remove from event target
                    super.removeEventListener(eventName, eventPair.eventListenerWrapper);
                    // Remove from our internal map
                    listeners.splice(i, 1);
                    break;
                }
            }
        }
        return this;
    }
    /**
     * Alias for `emitter.on(eventName, listener)`.
     */
    addListener(eventName, listener) {
        return this.on(eventName, listener);
    }
    /**
     * Adds the `listener` function to the end of the listeners array for the event
     * named `eventName`.
     *
     * ```js
     * server.on('connection', (stream) => {
     *   console.log('someone connected!');
     * });
     * ```
     *
     * Returns a reference to the `EventEmitter`, so that calls can be chained.
     *
     * @param eventName - The name of the event.
     * @param listener - The callback function
     */
    on(eventName, listener) {
        var _a;
        // Wrap our normal JS function in a event listener interface
        // so we can use it with event target.
        const eventListenerWrapper = new PixelStreamingEventListener(listener);
        super.addEventListener(eventName, eventListenerWrapper);
        // Store the event listener/function pair for later removal.
        if (!this._eventListeners.has(eventName)) {
            this._eventListeners.set(eventName, new Array());
        }
        (_a = this._eventListeners
            .get(eventName)) === null || _a === void 0 ? void 0 : _a.push({ callback: listener, eventListenerWrapper: eventListenerWrapper });
        return this;
    }
    /**
     * Adds a **one-time** `listener` function for the event named `eventName`. The
     * next time `eventName` is triggered, this listener is removed and then invoked.
     *
     * ```js
     * server.once('connection', (stream) => {
     *   console.log('Ah, we have our first user!');
     * });
     * ```
     *
     * Returns a reference to the `EventEmitter`, so that calls can be chained.
     * @param eventName - The name of the event.
     * @param listener - The callback function
     */
    once(eventName, listener) {
        var _a;
        // Pass options so this event callback is only called once
        const eventListenerOpts = { once: true };
        // Wrap our normal JS function in a event listener interface
        // so we can use it with event target and remove it from event target when this function completes.
        const eventListenerWrapper = new PixelStreamingEventListener((...args) => {
            listener(args);
            this.removeListenerInternal(eventName, listener);
        });
        super.addEventListener(eventName, eventListenerWrapper, eventListenerOpts);
        // Store the event listener/function pair for later removal.
        if (!this._eventListeners.has(eventName)) {
            this._eventListeners.set(eventName, new Array());
        }
        (_a = this._eventListeners
            .get(eventName)) === null || _a === void 0 ? void 0 : _a.push({ callback: listener, eventListenerWrapper: eventListenerWrapper });
        return this;
    }
    /**
     * Removes the specified `listener` from this EventEmitter.
     *
     * ```js
     * const callback = (stream) => {
     *   console.log('someone connected!');
     * };
     * server.on('connection', callback);
     * // ...
     * server.removeListener('connection', callback);
     * ```
     * Returns a reference to the `EventEmitter`, so that calls can be chained.
     */
    removeListener(eventName, listener) {
        this.removeListenerInternal(eventName, listener);
        return this;
    }
    /**
     * Alias for `emitter.removeListener()`.
     */
    off(eventName, listener) {
        return this.removeListener(eventName, listener);
    }
    /**
     * Removes all listeners, or those of the specified `eventName`.
     * Returns a reference to the `EventEmitter`, so that calls can be chained.
     */
    removeAllListeners(eventName) {
        if (this._eventListeners.has(eventName)) {
            const listeners = this._eventListeners.get(eventName);
            if (listeners === undefined) {
                return this;
            }
            // Remove each event listener from the event target
            for (const listenerPair of listeners) {
                this.removeEventListener(eventName, listenerPair.eventListenerWrapper);
            }
            // Remove all event listeners mapped to this event from our internal map
            this._eventListeners.delete(eventName);
        }
        return this;
    }
    /**
     * Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments
     * to each.
     *
     * Returns `true` if the event had listeners, `false` otherwise.
     *
     * ```js
     * import { EventEmitter } from 'node:events';
     * const myEmitter = new EventEmitter();
     *
     * // First listener
     * myEmitter.on('event', function firstListener() {
     *   console.log('Helloooo! first listener');
     * });
     * // Second listener
     * myEmitter.on('event', function secondListener(arg1, arg2) {
     *   console.log(`event with parameters ${arg1}, ${arg2} in second listener`);
     * });
     * // Third listener
     * myEmitter.on('event', function thirdListener(...args) {
     *   const parameters = args.join(', ');
     *   console.log(`event with parameters ${parameters} in third listener`);
     * });
     *
     * console.log(myEmitter.listeners('event'));
     *
     * myEmitter.emit('event', 1, 2, 3, 4, 5);
     *
     * // Prints:
     * // [
     * //   [Function: firstListener],
     * //   [Function: secondListener],
     * //   [Function: thirdListener]
     * // ]
     * // Helloooo! first listener
     * // event with parameters 1, 2 in second listener
     * // event with parameters 1, 2, 3, 4, 5 in third listener
     * ```
     */
    emit(eventName, ...args) {
        if (this._eventListeners.has(eventName)) {
            const listeners = this._eventListeners.get(eventName);
            if (listeners === undefined) {
                return false;
            }
            // Ensure each of our listeners have the args the callback injected
            for (const listenerPair of listeners) {
                listenerPair.eventListenerWrapper.setArgs(...args);
            }
            // Fire off the actual event
            super.dispatchEvent(new Event(eventName));
            return true;
        }
        return false;
    }
}
//# sourceMappingURL=EventEmitter.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Logger/Logger.js":
/*!*************************************************!*\
  !*** ../../../Common/dist/esm/Logger/Logger.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LogLevel: () => (/* binding */ LogLevel),
/* harmony export */   Logger: () => (/* binding */ Logger),
/* harmony export */   LoggerContext: () => (/* binding */ LoggerContext),
/* harmony export */   LoggerType: () => (/* binding */ LoggerType),
/* harmony export */   overrideLogger: () => (/* binding */ overrideLogger)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Disabled"] = 0] = "Disabled";
    LogLevel[LogLevel["Error"] = 1] = "Error";
    LogLevel[LogLevel["Warning"] = 2] = "Warning";
    LogLevel[LogLevel["Info"] = 3] = "Info";
    LogLevel[LogLevel["Debug"] = 4] = "Debug";
})(LogLevel || (LogLevel = {}));
/**
 * The global context for the logger configuration.
 * This cannot be stored statically in the Logger class because we sometimes have multiple execution
 * contexts, such as stats reporting. Instead we store the logger config context on the window object
 * to be shared with any Logger instances.
 */
class LoggerContext {
    constructor() {
        this.logLevel = LogLevel.Debug;
        this.includeStack = true;
    }
}
function overrideLogger(logger) {
    Logger = logger;
}
/**
 * A basic console logger utilized by the Pixel Streaming frontend to allow
 * logging to the browser console.
 */
class LoggerType {
    /**
     * Set the log verbosity level
     */
    InitLogging(logLevel, includeStack) {
        this.ValidateContext();
        this.context.logLevel = logLevel;
        this.context.includeStack = includeStack;
    }
    /**
     * Logging output for debugging
     * @param message - the message to be logged
     */
    Debug(message) {
        this.ValidateContext();
        if (this.context.logLevel >= LogLevel.Debug) {
            this.CommonLog('Debug', message);
        }
    }
    /**
     * Basic logging output for standard messages
     * @param message - the message to be logged
     */
    Info(message) {
        this.ValidateContext();
        if (this.context.logLevel >= LogLevel.Info) {
            this.CommonLog('Info', message);
        }
    }
    /**
     * Logging for warnings
     * @param message - the message to be logged
     */
    Warning(message) {
        this.ValidateContext();
        if (this.context.logLevel >= LogLevel.Warning) {
            this.CommonLog('Warning', message);
        }
    }
    /**
     * Error logging
     * @param message - the message to be logged
     */
    Error(message) {
        this.ValidateContext();
        if (this.context.logLevel >= LogLevel.Error) {
            this.CommonLog('Error', message);
        }
    }
    /**
     * The common log function that all other log functions call to.
     * @param level - the level of this log message.
     * @param stack - an optional stack trace string from where the log message was called.
     * @param message - the message to be logged.
     */
    CommonLog(level, message) {
        let logMessage = `[${level}] - ${message}`;
        if (this.context.includeStack) {
            logMessage += `\nStack: ${this.GetStackTrace()}`;
        }
        if (level === 'Error') {
            console.error(logMessage);
        }
        else if (level === 'Warning') {
            console.warn(logMessage);
        }
        else {
            console.log(logMessage);
        }
    }
    /**
     * Captures the stack and returns it
     * @returns the current stack
     */
    GetStackTrace() {
        const error = new Error();
        let formattedStack = 'No Stack Available for this browser';
        // format the error
        if (error.stack) {
            formattedStack = error.stack.toString().replace(/Error/g, '');
        }
        return formattedStack;
    }
    /**
     * Since there can be multiple execution contexts, (stats reporting and some webxr logging comes from
     * different execution contexts we can end up with multiple static Logger instances. Here we try to
     * work around it by storing the context on the window object.
     */
    ValidateContext() {
        if (!this.context) {
            if (typeof window == 'undefined' || !window) {
                // no window object so we can only store a local context.
                this.context = new LoggerContext();
            }
            else if (!window.loggerContext) {
                this.context = new LoggerContext();
                window.loggerContext = this.context;
            }
            else {
                this.context = window.loggerContext;
            }
        }
    }
}
let Logger = new LoggerType();
//# sourceMappingURL=Logger.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Messages/message_helpers.js":
/*!************************************************************!*\
  !*** ../../../Common/dist/esm/Messages/message_helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createMessage: () => (/* binding */ createMessage),
/* harmony export */   validateMessage: () => (/* binding */ validateMessage)
/* harmony export */ });
/* harmony import */ var _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Logger/Logger */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _message_registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./message_registry */ "../../../Common/dist/esm/Messages/message_registry.js");


/**
 * A helper for creating signalling messages. Takes in optional given parameters and
 * includes them in a message object with the 'type' field set properly for the message
 * type supplied.
 * @param messageType - A message type from MessageRegistry that indicates the type of message to create.
 * @param params - An optional object whose fields are added to the newly created message.
 * @returns The resulting message object.
 */
function createMessage(messageType, params) {
    const message = messageType.create();
    message.type = messageType.typeName;
    if (params) {
        messageType.mergePartial(message, params);
    }
    return message;
}
/**
 * Tests that the supplied message is valid. That is contains all expected fields and
 * doesn't contain any unknown fields.
 * @param msg - The message object to test.
 * @returns The message type from MessageRegistry of the supplied message object if it's valid, or null if invalid.
 */
function validateMessage(msg) {
    let valid = true;
    if (!msg.type) {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Parsed message has no type. Rejected. ${JSON.stringify(msg)}`);
        return null;
    }
    const messageType = _message_registry__WEBPACK_IMPORTED_MODULE_1__.MessageRegistry[msg.type];
    if (!messageType) {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Message is of an unknown type: "${msg.type}". Rejected.`);
        return null;
    }
    if (messageType.fields) {
        for (const field of messageType.fields) {
            if (!field.opt) {
                if (!Object.prototype.hasOwnProperty.call(msg, field.name)) {
                    _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Message "${msg.type}"" is missing required field "${field.name}". Rejected.`);
                    valid = false;
                }
            }
        }
    }
    for (const fieldName in msg) {
        const found = messageType.fields.find((field) => field.name === fieldName);
        if (!found) {
            _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Message "${msg.type}" contains unknown field "${fieldName}". Rejected.`);
            valid = false;
        }
    }
    return valid ? messageType : null;
}
//# sourceMappingURL=message_helpers.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Messages/message_registry.js":
/*!*************************************************************!*\
  !*** ../../../Common/dist/esm/Messages/message_registry.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MessageRegistry: () => (/* binding */ MessageRegistry)
/* harmony export */ });
/* harmony import */ var _signalling_messages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signalling_messages */ "../../../Common/dist/esm/Messages/signalling_messages.js");

/**
 * A map of all the supported signalling messages in the Pixel Streaming
 * signalling protocol. This allows mapping of signalling message names
 * to actual message types.
 */
const MessageRegistry = {
    answer: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.answer,
    config: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.config,
    disconnectPlayer: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.disconnectPlayer,
    endpointId: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.endpointId,
    endpointIdConfirm: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.endpointIdConfirm,
    iceCandidate: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.iceCandidate,
    identify: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.identify,
    listStreamers: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.listStreamers,
    offer: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.offer,
    ping: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.ping,
    playerConnected: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.playerConnected,
    playerCount: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.playerCount,
    playerDisconnected: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.playerDisconnected,
    pong: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.pong,
    stats: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.stats,
    streamerDisconnected: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.streamerDisconnected,
    streamerList: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.streamerList,
    subscribe: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.subscribe,
    unsubscribe: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.unsubscribe,
    layerPreference: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.layerPreference,
    dataChannelRequest: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.dataChannelRequest,
    peerDataChannels: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.peerDataChannels,
    peerDataChannelsReady: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.peerDataChannelsReady,
    streamerDataChannels: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.streamerDataChannels,
    startStreaming: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.startStreaming,
    stopStreaming: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.stopStreaming
};
//# sourceMappingURL=message_registry.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Messages/signalling_messages.js":
/*!****************************************************************!*\
  !*** ../../../Common/dist/esm/Messages/signalling_messages.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   answer: () => (/* binding */ answer),
/* harmony export */   base_message: () => (/* binding */ base_message),
/* harmony export */   config: () => (/* binding */ config),
/* harmony export */   dataChannelRequest: () => (/* binding */ dataChannelRequest),
/* harmony export */   disconnectPlayer: () => (/* binding */ disconnectPlayer),
/* harmony export */   endpointId: () => (/* binding */ endpointId),
/* harmony export */   endpointIdConfirm: () => (/* binding */ endpointIdConfirm),
/* harmony export */   iceCandidate: () => (/* binding */ iceCandidate),
/* harmony export */   iceCandidateData: () => (/* binding */ iceCandidateData),
/* harmony export */   identify: () => (/* binding */ identify),
/* harmony export */   layerPreference: () => (/* binding */ layerPreference),
/* harmony export */   listStreamers: () => (/* binding */ listStreamers),
/* harmony export */   offer: () => (/* binding */ offer),
/* harmony export */   peerConnectionOptions: () => (/* binding */ peerConnectionOptions),
/* harmony export */   peerDataChannels: () => (/* binding */ peerDataChannels),
/* harmony export */   peerDataChannelsReady: () => (/* binding */ peerDataChannelsReady),
/* harmony export */   ping: () => (/* binding */ ping),
/* harmony export */   playerConnected: () => (/* binding */ playerConnected),
/* harmony export */   playerCount: () => (/* binding */ playerCount),
/* harmony export */   playerDisconnected: () => (/* binding */ playerDisconnected),
/* harmony export */   pong: () => (/* binding */ pong),
/* harmony export */   startStreaming: () => (/* binding */ startStreaming),
/* harmony export */   stats: () => (/* binding */ stats),
/* harmony export */   stopStreaming: () => (/* binding */ stopStreaming),
/* harmony export */   streamerDataChannels: () => (/* binding */ streamerDataChannels),
/* harmony export */   streamerDisconnected: () => (/* binding */ streamerDisconnected),
/* harmony export */   streamerIdChanged: () => (/* binding */ streamerIdChanged),
/* harmony export */   streamerList: () => (/* binding */ streamerList),
/* harmony export */   subscribe: () => (/* binding */ subscribe),
/* harmony export */   subscribeFailed: () => (/* binding */ subscribeFailed),
/* harmony export */   unsubscribe: () => (/* binding */ unsubscribe)
/* harmony export */ });
/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @protobuf-ts/runtime */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js");
/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @protobuf-ts/runtime */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js");
/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @protobuf-ts/runtime */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type.js");




// @generated message type with reflection information, may provide speed optimized methods
class base_message$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("base_message", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base_message
 */
const base_message = new base_message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class peerConnectionOptions$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("peerConnectionOptions", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message peerConnectionOptions
 */
const peerConnectionOptions = new peerConnectionOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class config$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("config", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "peerConnectionOptions", kind: "message", T: () => peerConnectionOptions },
            { no: 3, name: "protocolVersion", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* peerConnectionOptions peerConnectionOptions */ 2:
                    message.peerConnectionOptions = peerConnectionOptions.internalBinaryRead(reader, reader.uint32(), options, message.peerConnectionOptions);
                    break;
                case /* optional string protocolVersion */ 3:
                    message.protocolVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* peerConnectionOptions peerConnectionOptions = 2; */
        if (message.peerConnectionOptions)
            peerConnectionOptions.internalBinaryWrite(message.peerConnectionOptions, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).fork(), options).join();
        /* optional string protocolVersion = 3; */
        if (message.protocolVersion !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.protocolVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message config
 */
const config = new config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class identify$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("identify", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message identify
 */
const identify = new identify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class endpointId$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("endpointId", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "protocolVersion", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.id = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* optional string protocolVersion */ 3:
                    message.protocolVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.id);
        /* optional string protocolVersion = 3; */
        if (message.protocolVersion !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.protocolVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message endpointId
 */
const endpointId = new endpointId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class endpointIdConfirm$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("endpointIdConfirm", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "committedId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.committedId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string committedId */ 2:
                    message.committedId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string committedId = 2; */
        if (message.committedId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.committedId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message endpointIdConfirm
 */
const endpointIdConfirm = new endpointIdConfirm$Type();
// @generated message type with reflection information, may provide speed optimized methods
class streamerIdChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("streamerIdChanged", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "newID", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.newID = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string newID */ 2:
                    message.newID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string newID = 2; */
        if (message.newID !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.newID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message streamerIdChanged
 */
const streamerIdChanged = new streamerIdChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class listStreamers$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("listStreamers", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message listStreamers
 */
const listStreamers = new listStreamers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class streamerList$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("streamerList", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.ids = [];
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* repeated string ids */ 2:
                    message.ids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* repeated string ids = 2; */
        for (let i = 0; i < message.ids.length; i++)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message streamerList
 */
const streamerList = new streamerList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class subscribe$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("subscribe", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "streamerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.streamerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string streamerId */ 2:
                    message.streamerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string streamerId = 2; */
        if (message.streamerId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.streamerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message subscribe
 */
const subscribe = new subscribe$Type();
// @generated message type with reflection information, may provide speed optimized methods
class unsubscribe$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("unsubscribe", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message unsubscribe
 */
const unsubscribe = new unsubscribe$Type();
// @generated message type with reflection information, may provide speed optimized methods
class subscribeFailed$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("subscribeFailed", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.message = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message subscribeFailed
 */
const subscribeFailed = new subscribeFailed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class playerConnected$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("playerConnected", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dataChannel", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "sfu", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.dataChannel = false;
        message.sfu = false;
        message.playerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* bool dataChannel */ 2:
                    message.dataChannel = reader.bool();
                    break;
                case /* bool sfu */ 3:
                    message.sfu = reader.bool();
                    break;
                case /* string playerId */ 5:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* bool dataChannel = 2; */
        if (message.dataChannel !== false)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).bool(message.dataChannel);
        /* bool sfu = 3; */
        if (message.sfu !== false)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).bool(message.sfu);
        /* string playerId = 5; */
        if (message.playerId !== "")
            writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message playerConnected
 */
const playerConnected = new playerConnected$Type();
// @generated message type with reflection information, may provide speed optimized methods
class playerDisconnected$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("playerDisconnected", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.playerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string playerId */ 2:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string playerId = 2; */
        if (message.playerId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message playerDisconnected
 */
const playerDisconnected = new playerDisconnected$Type();
// @generated message type with reflection information, may provide speed optimized methods
class offer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("offer", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sdp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "playerId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "sfu", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "multiplex", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "scalabilityMode", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.sdp = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string sdp */ 2:
                    message.sdp = reader.string();
                    break;
                case /* optional string playerId */ 3:
                    message.playerId = reader.string();
                    break;
                case /* optional bool sfu */ 4:
                    message.sfu = reader.bool();
                    break;
                case /* optional bool multiplex */ 5:
                    message.multiplex = reader.bool();
                    break;
                case /* optional string scalabilityMode */ 6:
                    message.scalabilityMode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string sdp = 2; */
        if (message.sdp !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.sdp);
        /* optional string playerId = 3; */
        if (message.playerId !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        /* optional bool sfu = 4; */
        if (message.sfu !== undefined)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).bool(message.sfu);
        /* optional bool multiplex = 5; */
        if (message.multiplex !== undefined)
            writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).bool(message.multiplex);
        /* optional string scalabilityMode = 6; */
        if (message.scalabilityMode !== undefined)
            writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.scalabilityMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offer
 */
const offer = new offer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class answer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("answer", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sdp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "playerId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "minBitrateBps", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "maxBitrateBps", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.sdp = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string sdp */ 2:
                    message.sdp = reader.string();
                    break;
                case /* optional string playerId */ 3:
                    message.playerId = reader.string();
                    break;
                case /* optional int32 minBitrateBps */ 4:
                    message.minBitrateBps = reader.int32();
                    break;
                case /* optional int32 maxBitrateBps */ 5:
                    message.maxBitrateBps = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string sdp = 2; */
        if (message.sdp !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.sdp);
        /* optional string playerId = 3; */
        if (message.playerId !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        /* optional int32 minBitrateBps = 4; */
        if (message.minBitrateBps !== undefined)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.minBitrateBps);
        /* optional int32 maxBitrateBps = 5; */
        if (message.maxBitrateBps !== undefined)
            writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.maxBitrateBps);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message answer
 */
const answer = new answer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class iceCandidateData$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("iceCandidateData", [
            { no: 1, name: "candidate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sdpMid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sdpMLineIndex", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "usernameFragment", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.candidate = "";
        message.sdpMid = "";
        message.sdpMLineIndex = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string candidate */ 1:
                    message.candidate = reader.string();
                    break;
                case /* string sdpMid */ 2:
                    message.sdpMid = reader.string();
                    break;
                case /* int32 sdpMLineIndex */ 3:
                    message.sdpMLineIndex = reader.int32();
                    break;
                case /* optional string usernameFragment */ 4:
                    message.usernameFragment = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string candidate = 1; */
        if (message.candidate !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.candidate);
        /* string sdpMid = 2; */
        if (message.sdpMid !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.sdpMid);
        /* int32 sdpMLineIndex = 3; */
        if (message.sdpMLineIndex !== 0)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.sdpMLineIndex);
        /* optional string usernameFragment = 4; */
        if (message.usernameFragment !== undefined)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.usernameFragment);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message iceCandidateData
 */
const iceCandidateData = new iceCandidateData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class iceCandidate$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("iceCandidate", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "candidate", kind: "message", T: () => iceCandidateData },
            { no: 3, name: "playerId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* iceCandidateData candidate */ 2:
                    message.candidate = iceCandidateData.internalBinaryRead(reader, reader.uint32(), options, message.candidate);
                    break;
                case /* optional string playerId */ 3:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* iceCandidateData candidate = 2; */
        if (message.candidate)
            iceCandidateData.internalBinaryWrite(message.candidate, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).fork(), options).join();
        /* optional string playerId = 3; */
        if (message.playerId !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message iceCandidate
 */
const iceCandidate = new iceCandidate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class disconnectPlayer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("disconnectPlayer", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reason", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.playerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string playerId */ 2:
                    message.playerId = reader.string();
                    break;
                case /* optional string reason */ 3:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string playerId = 2; */
        if (message.playerId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        /* optional string reason = 3; */
        if (message.reason !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message disconnectPlayer
 */
const disconnectPlayer = new disconnectPlayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ping$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("ping", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "time", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.time = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 time */ 2:
                    message.time = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* int32 time = 2; */
        if (message.time !== 0)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.time);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ping
 */
const ping = new ping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class pong$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("pong", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "time", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.time = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 time */ 2:
                    message.time = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* int32 time = 2; */
        if (message.time !== 0)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.time);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pong
 */
const pong = new pong$Type();
// @generated message type with reflection information, may provide speed optimized methods
class streamerDisconnected$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("streamerDisconnected", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message streamerDisconnected
 */
const streamerDisconnected = new streamerDisconnected$Type();
// @generated message type with reflection information, may provide speed optimized methods
class layerPreference$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("layerPreference", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "spatialLayer", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "temporalLayer", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.spatialLayer = 0;
        message.temporalLayer = 0;
        message.playerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 spatialLayer */ 2:
                    message.spatialLayer = reader.int32();
                    break;
                case /* int32 temporalLayer */ 3:
                    message.temporalLayer = reader.int32();
                    break;
                case /* string playerId */ 4:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* int32 spatialLayer = 2; */
        if (message.spatialLayer !== 0)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.spatialLayer);
        /* int32 temporalLayer = 3; */
        if (message.temporalLayer !== 0)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.temporalLayer);
        /* string playerId = 4; */
        if (message.playerId !== "")
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message layerPreference
 */
const layerPreference = new layerPreference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class dataChannelRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("dataChannelRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message dataChannelRequest
 */
const dataChannelRequest = new dataChannelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class peerDataChannels$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("peerDataChannels", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sendStreamId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "recvStreamId", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.playerId = "";
        message.sendStreamId = 0;
        message.recvStreamId = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string playerId */ 2:
                    message.playerId = reader.string();
                    break;
                case /* int32 sendStreamId */ 3:
                    message.sendStreamId = reader.int32();
                    break;
                case /* int32 recvStreamId */ 4:
                    message.recvStreamId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string playerId = 2; */
        if (message.playerId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        /* int32 sendStreamId = 3; */
        if (message.sendStreamId !== 0)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.sendStreamId);
        /* int32 recvStreamId = 4; */
        if (message.recvStreamId !== 0)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.recvStreamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message peerDataChannels
 */
const peerDataChannels = new peerDataChannels$Type();
// @generated message type with reflection information, may provide speed optimized methods
class peerDataChannelsReady$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("peerDataChannelsReady", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message peerDataChannelsReady
 */
const peerDataChannelsReady = new peerDataChannelsReady$Type();
// @generated message type with reflection information, may provide speed optimized methods
class streamerDataChannels$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("streamerDataChannels", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sfuId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sendStreamId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "recvStreamId", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.sfuId = "";
        message.sendStreamId = 0;
        message.recvStreamId = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string sfuId */ 2:
                    message.sfuId = reader.string();
                    break;
                case /* int32 sendStreamId */ 3:
                    message.sendStreamId = reader.int32();
                    break;
                case /* int32 recvStreamId */ 4:
                    message.recvStreamId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string sfuId = 2; */
        if (message.sfuId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.sfuId);
        /* int32 sendStreamId = 3; */
        if (message.sendStreamId !== 0)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.sendStreamId);
        /* int32 recvStreamId = 4; */
        if (message.recvStreamId !== 0)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.recvStreamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message streamerDataChannels
 */
const streamerDataChannels = new streamerDataChannels$Type();
// @generated message type with reflection information, may provide speed optimized methods
class startStreaming$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("startStreaming", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message startStreaming
 */
const startStreaming = new startStreaming$Type();
// @generated message type with reflection information, may provide speed optimized methods
class stopStreaming$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("stopStreaming", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stopStreaming
 */
const stopStreaming = new stopStreaming$Type();
// @generated message type with reflection information, may provide speed optimized methods
class playerCount$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("playerCount", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.count = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 count */ 2:
                    message.count = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* int32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message playerCount
 */
const playerCount = new playerCount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class stats$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("stats", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.data = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string data */ 2:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string data = 2; */
        if (message.data !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stats
 */
const stats = new stats$Type();
//# sourceMappingURL=signalling_messages.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Protocol/KeepaliveMonitor.js":
/*!*************************************************************!*\
  !*** ../../../Common/dist/esm/Protocol/KeepaliveMonitor.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeepaliveMonitor: () => (/* binding */ KeepaliveMonitor)
/* harmony export */ });
/* harmony import */ var _Messages_signalling_messages__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Messages/signalling_messages */ "../../../Common/dist/esm/Messages/signalling_messages.js");
/* harmony import */ var _Messages_message_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Messages/message_helpers */ "../../../Common/dist/esm/Messages/message_helpers.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * Used to regularly ping a protocol connection to make sure the connection is still good and open.
 * When the pong doesn't come in response to a ping in time a callback is fired that can be handed
 * by the owner.
 */
class KeepaliveMonitor {
    /**
     * Gets the Round Trip Time of the current connection in milliseconds.
     */
    get RTT() {
        return this.rtt;
    }
    /**
     * Creates a new monitor and starts the ping timer. If a pong does not come back by the time we want
     * to send a second ping then the connection is considered dead and the onTimeout callback is fired.
     * @param protocol - The connection that we want to monitor.
     * @param timeout - The time in milliseconds between ping messages.
     */
    constructor(protocol, timeout) {
        this.alive = false;
        this.rtt = 0;
        this.protocol = protocol;
        this.timeout = timeout;
        this.onResponse = this.onHeartbeatResponse.bind(this);
        this.protocol.transport.on('close', this.stop.bind(this));
        this.start();
    }
    start() {
        this.alive = true;
        this.protocol.on('pong', this.onResponse);
        this.keepalive = setInterval(this.sendHeartbeat.bind(this), this.timeout);
    }
    stop() {
        clearInterval(this.keepalive);
        this.protocol.off('pong', this.onResponse);
    }
    sendHeartbeat() {
        var _a;
        // if we never got a response from the last heartbeat, assume the connection is dead and timeout
        if (this.alive === false) {
            (_a = this.onTimeout) === null || _a === void 0 ? void 0 : _a.call(this);
            return;
        }
        // mark the connection as temporarily dead until we get a response from the ping
        this.alive = false;
        this.protocol.sendMessage(_Messages_message_helpers__WEBPACK_IMPORTED_MODULE_0__.createMessage(_Messages_signalling_messages__WEBPACK_IMPORTED_MODULE_1__.ping, { time: new Date().getTime() }));
    }
    onHeartbeatResponse(pongMsg) {
        // we got a pong response from the other side, the connection is good.
        // we also store the round trip time if anyone is curious
        this.rtt = new Date().getTime() - pongMsg.time;
        this.alive = true;
    }
}
//# sourceMappingURL=KeepaliveMonitor.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Protocol/SignallingProtocol.js":
/*!***************************************************************!*\
  !*** ../../../Common/dist/esm/Protocol/SignallingProtocol.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SignallingProtocol: () => (/* binding */ SignallingProtocol)
/* harmony export */ });
/* harmony import */ var _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Event/EventEmitter */ "../../../Common/dist/esm/Event/EventEmitter.js");
/* harmony import */ var _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Logger/Logger */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * Signalling protocol for handling messages from the signalling server.
 *
 * Listen on this emitter for messages. Message type is the name of the event to listen for.
 * Example:
 *      signallingProtocol.on('config', (message: Messages.config) =\> console.log(`Got a config message: ${message}`)));
 *
 * The transport in this class will also emit on message events.
 *
 * Events emitted on transport:
 *   message:
 *      Emitted any time a message is received by the transport. Listen on this if
 *      you wish to capture all messages, rather than specific messages on
 *      'messageHandlers'.
 *
 *   out:
 *      Emitted when sending a message out on the transport. Similar to 'message' but
 *      only for when messages are sent from this endpoint. Useful for debugging.
 */
class SignallingProtocol extends _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    static get SIGNALLING_VERSION() {
        return '1.3.0';
    }
    constructor(transport) {
        super();
        this.transport = transport;
        transport.onMessage = (msg) => {
            let parsedMessage;
            try {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                const parsedData = JSON.parse(msg);
                _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Debug('Protocol received => \n' + JSON.stringify(parsedData, undefined, 4));
                parsedMessage = parsedData;
            }
            catch (e) {
                if (e instanceof Error) {
                    _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`Error parsing message string ${msg}.\n${e.message}`);
                }
                else {
                    _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`Unknown error while parsing message data in handleOnMessage`);
                }
                return;
            }
            // call the handlers
            transport.emit('message', parsedMessage); // emit this for listeners listening to any message
            if (!this.emit(parsedMessage.type, parsedMessage)) {
                // emit this for listeners listening for specific messages
                // no listeners
                this.emit('unhandled', parsedMessage);
            }
        };
    }
    /**
     * Asks the transport to connect to the given URL.
     * @param url - The url to connect to.
     * @returns True if the connection call succeeded.
     */
    connect(url) {
        return this.transport.connect(url);
    }
    /**
     * Asks the transport to disconnect from any connection it might have.
     * @param code - An optional disconnection code.
     * @param reason - An optional descriptive string for the disconnect reason.
     */
    disconnect(code, reason) {
        this.transport.disconnect(code, reason);
    }
    /**
     * Returns true if the transport is connected and ready to send/receive messages.
     * @returns True if the protocol is connected.
     */
    isConnected() {
        return this.transport.isConnected();
    }
    /**
     * Passes a message to the transport to send to the other end.
     * @param msg - The message to send.
     */
    sendMessage(msg) {
        this.transport.sendMessage(JSON.stringify(msg));
        this.transport.emit('out', msg); // emit this for listeners listening to outgoing messages
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Debug('Protocol sent => \n' + JSON.stringify(msg, undefined, 4));
    }
}
//# sourceMappingURL=SignallingProtocol.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Transport/WebSocketTransport.js":
/*!****************************************************************!*\
  !*** ../../../Common/dist/esm/Transport/WebSocketTransport.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebSocketTransport: () => (/* binding */ WebSocketTransport)
/* harmony export */ });
/* harmony import */ var _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Logger/Logger */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Event/EventEmitter */ "../../../Common/dist/esm/Event/EventEmitter.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * The controller for the WebSocket and all associated methods
 */
class WebSocketTransport extends _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    /**
     * Constructs a new WebSocketTransport for browser contexts.
     * @param protocols - An optional string or list of strings to pass to the new websocket protocols param
     */
    constructor(protocols) {
        super();
        this.WS_OPEN_STATE = 1;
        this.protocols = protocols;
    }
    /**
     * Sends a message over the websocket.
     * @param msg - The message to send.
     */
    sendMessage(msg) {
        if (this.webSocket) {
            this.webSocket.send(msg);
        }
    }
    /**
     * Connect to the signaling server
     * @param connectionURL - The Address of the signaling server
     * @returns If there is a connection
     */
    connect(connectionURL) {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(connectionURL);
        try {
            this.webSocket = new WebSocket(connectionURL, this.protocols);
            this.webSocket.onopen = (_) => this.handleOnOpen();
            this.webSocket.onerror = (_) => this.handleOnError();
            this.webSocket.onclose = (event) => this.handleOnClose(event);
            this.webSocket.onmessage = (event) => this.handleOnMessage(event);
            this.webSocket.onmessagebinary = (event) => this.handleOnMessageBinary(event);
            return true;
        }
        catch (error) {
            _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(error);
            return false;
        }
    }
    /**
     * Disconnect this transport.
     * @param code - An optional disconnect code.
     * @param reason - A descriptive string for the disconnect reason.
     */
    disconnect(code, reason) {
        if (this.webSocket) {
            this.webSocket.close(code, reason);
        }
    }
    /**
     * Should return true when the transport is connected and ready to send/receive messages.
     * @returns True if the transport is connected.
     */
    isConnected() {
        return !!this.webSocket && this.webSocket.readyState != WebSocket.CLOSED;
    }
    /**
     * Handles what happens when a message is received in binary form
     * @param event - Message Received
     */
    handleOnMessageBinary(event) {
        // if the event is empty return
        if (!event || !event.data) {
            return;
        }
        // handle the binary and then handle the message
        event.data
            .text()
            .then((messageString) => {
            // build a new message
            const constructedMessage = new MessageEvent('messageFromBinary', {
                data: messageString
            });
            // send the new stringified event back into `onmessage`
            this.handleOnMessage(constructedMessage);
        })
            .catch((error) => {
            _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`Failed to parse binary blob from websocket, reason: ${error.message}`);
        });
    }
    /**
     * Handles what happens when a message is received
     * @param event - Message Received
     */
    handleOnMessage(event) {
        // Check if websocket message is binary, if so, stringify it.
        if (event.data && event.data instanceof Blob) {
            this.handleOnMessageBinary(event);
            return;
        }
        if (this.onMessage) {
            this.onMessage(event.data);
        }
    }
    /**
     * Handles when the Websocket is opened
     */
    handleOnOpen() {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Connected to the signalling server via WebSocket');
        this.emit('open');
    }
    /**
     * Handles when there is an error on the websocket
     */
    handleOnError() {
        //Logger.Error(Logger.GetStackTrace(), 'WebSocket error');
        this.emit('error');
    }
    /**
     * Handles when the Websocket is closed
     * @param event - Close Event
     */
    handleOnClose(event) {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Disconnected to the signalling server via WebSocket: ' +
            JSON.stringify(event.code) +
            ' - ' +
            event.reason);
        this.emit('close', event);
    }
}
//# sourceMappingURL=WebSocketTransport.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Util/SdpUtils.js":
/*!*************************************************!*\
  !*** ../../../Common/dist/esm/Util/SdpUtils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SDPUtils: () => (/* binding */ SDPUtils)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class SDPUtils {
    static addVideoHeaderExtensionToSdp(sdp, uri) {
        // Find the highest used header extension id by sorting the extension ids used,
        // eliminating duplicates and adding one.
        // Todo: Update this when WebRTC in Chrome supports the header extension API.
        const usedIds = sdp
            .split('\n')
            .filter((line) => line.startsWith('a=extmap:'))
            .map((line) => parseInt(line.split(' ')[0].substring(9), 10))
            .sort((a, b) => a - b)
            .filter((item, index, array) => array.indexOf(item) === index);
        const nextId = usedIds[usedIds.length - 1] + 1;
        const extmapLine = 'a=extmap:' + nextId + ' ' + uri + '\r\n';
        const sections = sdp.split('\nm=').map((part, index) => {
            return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
        });
        const sessionPart = sections.shift();
        // Only add extension to m=video media section
        return (sessionPart +
            sections
                .map((mediaSection) => mediaSection.startsWith('m=video') ? mediaSection + extmapLine : mediaSection)
                .join(''));
    }
}
//# sourceMappingURL=SdpUtils.js.map

/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assert: () => (/* binding */ assert),
/* harmony export */   assertFloat32: () => (/* binding */ assertFloat32),
/* harmony export */   assertInt32: () => (/* binding */ assertInt32),
/* harmony export */   assertNever: () => (/* binding */ assertNever),
/* harmony export */   assertUInt32: () => (/* binding */ assertUInt32)
/* harmony export */ });
/**
 * assert that condition is true or throw error (with message)
 */
function assert(condition, msg) {
    if (!condition) {
        throw new Error(msg);
    }
}
/**
 * assert that value cannot exist = type `never`. throw runtime error if it does.
 */
function assertNever(value, msg) {
    throw new Error(msg !== null && msg !== void 0 ? msg : 'Unexpected object: ' + value);
}
const FLOAT32_MAX = 3.4028234663852886e+38, FLOAT32_MIN = -3.4028234663852886e+38, UINT32_MAX = 0xFFFFFFFF, INT32_MAX = 0X7FFFFFFF, INT32_MIN = -0X80000000;
function assertInt32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid int 32: ' + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
        throw new Error('invalid int 32: ' + arg);
}
function assertUInt32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid uint 32: ' + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
        throw new Error('invalid uint 32: ' + arg);
}
function assertFloat32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid float 32: ' + typeof arg);
    if (!Number.isFinite(arg))
        return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
        throw new Error('invalid float 32: ' + arg);
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/base64.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/base64.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base64decode: () => (/* binding */ base64decode),
/* harmony export */   base64encode: () => (/* binding */ base64encode)
/* harmony export */ });
// lookup table from base64 character to byte
let encTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
// lookup table from base64 character *code* to byte because lookup by number is fast
let decTable = [];
for (let i = 0; i < encTable.length; i++)
    decTable[encTable[i].charCodeAt(0)] = i;
// support base64url variants
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
/**
 * Decodes a base64 string to a byte array.
 *
 * - ignores white-space, including line breaks and tabs
 * - allows inner padding (can decode concatenated base64 strings)
 * - does not require padding
 * - understands base64url encoding:
 *   "-" instead of "+",
 *   "_" instead of "/",
 *   no padding
 */
function base64decode(base64Str) {
    // estimate byte size, not accounting for inner padding and whitespace
    let es = base64Str.length * 3 / 4;
    // if (es % 3 !== 0)
    // throw new Error('invalid base64 string');
    if (base64Str[base64Str.length - 2] == '=')
        es -= 2;
    else if (base64Str[base64Str.length - 1] == '=')
        es -= 1;
    let bytes = new Uint8Array(es), bytePos = 0, // position in byte array
    groupPos = 0, // position in base64 group
    b, // current byte
    p = 0 // previous byte
    ;
    for (let i = 0; i < base64Str.length; i++) {
        b = decTable[base64Str.charCodeAt(i)];
        if (b === undefined) {
            // noinspection FallThroughInSwitchStatementJS
            switch (base64Str[i]) {
                case '=':
                    groupPos = 0; // reset state when padding found
                case '\n':
                case '\r':
                case '\t':
                case ' ':
                    continue; // skip white-space, and padding
                default:
                    throw Error(`invalid base64 string.`);
            }
        }
        switch (groupPos) {
            case 0:
                p = b;
                groupPos = 1;
                break;
            case 1:
                bytes[bytePos++] = p << 2 | (b & 48) >> 4;
                p = b;
                groupPos = 2;
                break;
            case 2:
                bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
                p = b;
                groupPos = 3;
                break;
            case 3:
                bytes[bytePos++] = (p & 3) << 6 | b;
                groupPos = 0;
                break;
        }
    }
    if (groupPos == 1)
        throw Error(`invalid base64 string.`);
    return bytes.subarray(0, bytePos);
}
/**
 * Encodes a byte array to a base64 string.
 * Adds padding at the end.
 * Does not insert newlines.
 */
function base64encode(bytes) {
    let base64 = '', groupPos = 0, // position in base64 group
    b, // current byte
    p = 0; // carry over from previous byte
    for (let i = 0; i < bytes.length; i++) {
        b = bytes[i];
        switch (groupPos) {
            case 0:
                base64 += encTable[b >> 2];
                p = (b & 3) << 4;
                groupPos = 1;
                break;
            case 1:
                base64 += encTable[p | b >> 4];
                p = (b & 15) << 2;
                groupPos = 2;
                break;
            case 2:
                base64 += encTable[p | b >> 6];
                base64 += encTable[b & 63];
                groupPos = 0;
                break;
        }
    }
    // padding required?
    if (groupPos) {
        base64 += encTable[p];
        base64 += '=';
        if (groupPos == 1)
            base64 += '=';
    }
    return base64;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnknownFieldHandler: () => (/* binding */ UnknownFieldHandler),
/* harmony export */   WireType: () => (/* binding */ WireType),
/* harmony export */   mergeBinaryOptions: () => (/* binding */ mergeBinaryOptions)
/* harmony export */ });
/**
 * This handler implements the default behaviour for unknown fields.
 * When reading data, unknown fields are stored on the message, in a
 * symbol property.
 * When writing data, the symbol property is queried and unknown fields
 * are serialized into the output again.
 */
var UnknownFieldHandler;
(function (UnknownFieldHandler) {
    /**
     * The symbol used to store unknown fields for a message.
     * The property must conform to `UnknownFieldContainer`.
     */
    UnknownFieldHandler.symbol = Symbol.for("protobuf-ts/unknown");
    /**
     * Store an unknown field during binary read directly on the message.
     * This method is compatible with `BinaryReadOptions.readUnknownField`.
     */
    UnknownFieldHandler.onRead = (typeName, message, fieldNo, wireType, data) => {
        let container = is(message) ? message[UnknownFieldHandler.symbol] : message[UnknownFieldHandler.symbol] = [];
        container.push({ no: fieldNo, wireType, data });
    };
    /**
     * Write unknown fields stored for the message to the writer.
     * This method is compatible with `BinaryWriteOptions.writeUnknownFields`.
     */
    UnknownFieldHandler.onWrite = (typeName, message, writer) => {
        for (let { no, wireType, data } of UnknownFieldHandler.list(message))
            writer.tag(no, wireType).raw(data);
    };
    /**
     * List unknown fields stored for the message.
     * Note that there may be multiples fields with the same number.
     */
    UnknownFieldHandler.list = (message, fieldNo) => {
        if (is(message)) {
            let all = message[UnknownFieldHandler.symbol];
            return fieldNo ? all.filter(uf => uf.no == fieldNo) : all;
        }
        return [];
    };
    /**
     * Returns the last unknown field by field number.
     */
    UnknownFieldHandler.last = (message, fieldNo) => UnknownFieldHandler.list(message, fieldNo).slice(-1)[0];
    const is = (message) => message && Array.isArray(message[UnknownFieldHandler.symbol]);
})(UnknownFieldHandler || (UnknownFieldHandler = {}));
/**
 * Merges binary write or read options. Later values override earlier values.
 */
function mergeBinaryOptions(a, b) {
    return Object.assign(Object.assign({}, a), b);
}
/**
 * Protobuf binary format wire types.
 *
 * A wire type provides just enough information to find the length of the
 * following value.
 *
 * See https://developers.google.com/protocol-buffers/docs/encoding#structure
 */
var WireType;
(function (WireType) {
    /**
     * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum
     */
    WireType[WireType["Varint"] = 0] = "Varint";
    /**
     * Used for fixed64, sfixed64, double.
     * Always 8 bytes with little-endian byte order.
     */
    WireType[WireType["Bit64"] = 1] = "Bit64";
    /**
     * Used for string, bytes, embedded messages, packed repeated fields
     *
     * Only repeated numeric types (types which use the varint, 32-bit,
     * or 64-bit wire types) can be packed. In proto3, such fields are
     * packed by default.
     */
    WireType[WireType["LengthDelimited"] = 2] = "LengthDelimited";
    /**
     * Used for groups
     * @deprecated
     */
    WireType[WireType["StartGroup"] = 3] = "StartGroup";
    /**
     * Used for groups
     * @deprecated
     */
    WireType[WireType["EndGroup"] = 4] = "EndGroup";
    /**
     * Used for fixed32, sfixed32, float.
     * Always 4 bytes with little-endian byte order.
     */
    WireType[WireType["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js":
/*!********************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BinaryReader: () => (/* binding */ BinaryReader),
/* harmony export */   binaryReadOptions: () => (/* binding */ binaryReadOptions)
/* harmony export */ });
/* harmony import */ var _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binary-format-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js");
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");
/* harmony import */ var _goog_varint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./goog-varint */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js");



const defaultsRead = {
    readUnknownField: true,
    readerFactory: bytes => new BinaryReader(bytes),
};
/**
 * Make options for reading binary data form partial options.
 */
function binaryReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
class BinaryReader {
    constructor(buf, textDecoder) {
        this.varint64 = _goog_varint__WEBPACK_IMPORTED_MODULE_0__.varint64read; // dirty cast for `this`
        /**
         * Read a `uint32` field, an unsigned 32 bit varint.
         */
        this.uint32 = _goog_varint__WEBPACK_IMPORTED_MODULE_0__.varint32read; // dirty cast for `this` and access to protected `buf`
        this.buf = buf;
        this.len = buf.length;
        this.pos = 0;
        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
            fatal: true,
            ignoreBOM: true,
        });
    }
    /**
     * Reads a tag - field number and wire type.
     */
    tag() {
        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5)
            throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [fieldNo, wireType];
    }
    /**
     * Skip one element on the wire and return the skipped data.
     * Supports WireType.StartGroup since v2.0.0-alpha.23.
     */
    skip(wireType) {
        let start = this.pos;
        // noinspection FallThroughInSwitchStatementJS
        switch (wireType) {
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.Varint:
                while (this.buf[this.pos++] & 0x80) {
                    // ignore
                }
                break;
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.Bit64:
                this.pos += 4;
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.Bit32:
                this.pos += 4;
                break;
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.LengthDelimited:
                let len = this.uint32();
                this.pos += len;
                break;
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.StartGroup:
                // From descriptor.proto: Group type is deprecated, not supported in proto3.
                // But we must still be able to parse and treat as unknown.
                let t;
                while ((t = this.tag()[1]) !== _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.EndGroup) {
                    this.skip(t);
                }
                break;
            default:
                throw new Error("cant skip wire type " + wireType);
        }
        this.assertBounds();
        return this.buf.subarray(start, this.pos);
    }
    /**
     * Throws error if position in byte array is out of range.
     */
    assertBounds() {
        if (this.pos > this.len)
            throw new RangeError("premature EOF");
    }
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */
    int32() {
        return this.uint32() | 0;
    }
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
    sint32() {
        let zze = this.uint32();
        // decode zigzag
        return (zze >>> 1) ^ -(zze & 1);
    }
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */
    int64() {
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong(...this.varint64());
    }
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */
    uint64() {
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong(...this.varint64());
    }
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64() {
        let [lo, hi] = this.varint64();
        // decode zig zag
        let s = -(lo & 1);
        lo = ((lo >>> 1 | (hi & 1) << 31) ^ s);
        hi = (hi >>> 1 ^ s);
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong(lo, hi);
    }
    /**
     * Read a `bool` field, a variant.
     */
    bool() {
        let [lo, hi] = this.varint64();
        return lo !== 0 || hi !== 0;
    }
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */
    fixed32() {
        return this.view.getUint32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */
    sfixed32() {
        return this.view.getInt32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */
    fixed64() {
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */
    sfixed64() {
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `float` field, 32-bit floating point number.
     */
    float() {
        return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `double` field, a 64-bit floating point number.
     */
    double() {
        return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */
    bytes() {
        let len = this.uint32();
        let start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
    }
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */
    string() {
        return this.textDecoder.decode(this.bytes());
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js":
/*!********************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BinaryWriter: () => (/* binding */ BinaryWriter),
/* harmony export */   binaryWriteOptions: () => (/* binding */ binaryWriteOptions)
/* harmony export */ });
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");
/* harmony import */ var _goog_varint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./goog-varint */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js");



const defaultsWrite = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter(),
};
/**
 * Make options for writing binary data form partial options.
 */
function binaryWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
class BinaryWriter {
    constructor(textEncoder) {
        /**
         * Previous fork states.
         */
        this.stack = [];
        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
        this.chunks = [];
        this.buf = [];
    }
    /**
     * Return all bytes written and reset this writer.
     */
    finish() {
        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer
        let len = 0;
        for (let i = 0; i < this.chunks.length; i++)
            len += this.chunks[i].length;
        let bytes = new Uint8Array(len);
        let offset = 0;
        for (let i = 0; i < this.chunks.length; i++) {
            bytes.set(this.chunks[i], offset);
            offset += this.chunks[i].length;
        }
        this.chunks = [];
        return bytes;
    }
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */
    fork() {
        this.stack.push({ chunks: this.chunks, buf: this.buf });
        this.chunks = [];
        this.buf = [];
        return this;
    }
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */
    join() {
        // get chunk of fork
        let chunk = this.finish();
        // restore previous state
        let prev = this.stack.pop();
        if (!prev)
            throw new Error('invalid state, fork stack empty');
        this.chunks = prev.chunks;
        this.buf = prev.buf;
        // write length of chunk as varint
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
    }
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */
    tag(fieldNo, type) {
        return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    /**
     * Write a chunk of raw bytes.
     */
    raw(chunk) {
        if (this.buf.length) {
            this.chunks.push(new Uint8Array(this.buf));
            this.buf = [];
        }
        this.chunks.push(chunk);
        return this;
    }
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */
    uint32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertUInt32)(value);
        // write value as varint 32, inlined for speed
        while (value > 0x7f) {
            this.buf.push((value & 0x7f) | 0x80);
            value = value >>> 7;
        }
        this.buf.push(value);
        return this;
    }
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */
    int32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertInt32)(value);
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint32write)(value, this.buf);
        return this;
    }
    /**
     * Write a `bool` value, a variant.
     */
    bool(value) {
        this.buf.push(value ? 1 : 0);
        return this;
    }
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */
    bytes(value) {
        this.uint32(value.byteLength); // write length of chunk as varint
        return this.raw(value);
    }
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */
    string(value) {
        let chunk = this.textEncoder.encode(value);
        this.uint32(chunk.byteLength); // write length of chunk as varint
        return this.raw(chunk);
    }
    /**
     * Write a `float` value, 32-bit floating point number.
     */
    float(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertFloat32)(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setFloat32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `double` value, a 64-bit floating point number.
     */
    double(value) {
        let chunk = new Uint8Array(8);
        new DataView(chunk.buffer).setFloat64(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */
    fixed32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertUInt32)(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setUint32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */
    sfixed32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertInt32)(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setInt32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */
    sint32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertInt32)(value);
        // zigzag encode
        value = ((value << 1) ^ (value >> 31)) >>> 0;
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint32write)(value, this.buf);
        return this;
    }
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */
    sfixed64(value) {
        let chunk = new Uint8Array(8);
        let view = new DataView(chunk.buffer);
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk);
    }
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */
    fixed64(value) {
        let chunk = new Uint8Array(8);
        let view = new DataView(chunk.buffer);
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong.from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk);
    }
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */
    int64(value) {
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.from(value);
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint64write)(long.lo, long.hi, this.buf);
        return this;
    }
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64(value) {
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.from(value), 
        // zigzag encode
        sign = long.hi >> 31, lo = (long.lo << 1) ^ sign, hi = ((long.hi << 1) | (long.lo >>> 31)) ^ sign;
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint64write)(lo, hi, this.buf);
        return this;
    }
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */
    uint64(value) {
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong.from(value);
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint64write)(long.lo, long.hi, this.buf);
        return this;
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   int64fromString: () => (/* binding */ int64fromString),
/* harmony export */   int64toString: () => (/* binding */ int64toString),
/* harmony export */   varint32read: () => (/* binding */ varint32read),
/* harmony export */   varint32write: () => (/* binding */ varint32write),
/* harmony export */   varint64read: () => (/* binding */ varint64read),
/* harmony export */   varint64write: () => (/* binding */ varint64write)
/* harmony export */ });
// Copyright 2008 Google Inc.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Code generated by the Protocol Buffer compiler is owned by the owner
// of the input file used when generating it.  This code is not
// standalone and requires a support library to be linked with it.  This
// support library is itself covered by the above license.
/**
 * Read a 64 bit varint as two JS numbers.
 *
 * Returns tuple:
 * [0]: low bits
 * [0]: high bits
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175
 */
function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
        let b = this.buf[this.pos++];
        lowBits |= (b & 0x7F) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [lowBits, highBits];
        }
    }
    let middleByte = this.buf[this.pos++];
    // last four bits of the first 32 bit number
    lowBits |= (middleByte & 0x0F) << 28;
    // 3 upper bits are part of the next 32 bit number
    highBits = (middleByte & 0x70) >> 4;
    if ((middleByte & 0x80) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
        let b = this.buf[this.pos++];
        highBits |= (b & 0x7F) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [lowBits, highBits];
        }
    }
    throw new Error('invalid varint');
}
/**
 * Write a 64 bit varint, given as two JS numbers, to the given bytes array.
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344
 */
function varint64write(lo, hi, bytes) {
    for (let i = 0; i < 28; i = i + 7) {
        const shift = lo >>> i;
        const hasNext = !((shift >>> 7) == 0 && hi == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    const splitBits = ((lo >>> 28) & 0x0F) | ((hi & 0x07) << 4);
    const hasMoreBits = !((hi >> 3) == 0);
    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xFF);
    if (!hasMoreBits) {
        return;
    }
    for (let i = 3; i < 31; i = i + 7) {
        const shift = hi >>> i;
        const hasNext = !((shift >>> 7) == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    bytes.push((hi >>> 31) & 0x01);
}
// constants for binary math
const TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
/**
 * Parse decimal string of 64 bit integer value as two JS numbers.
 *
 * Returns tuple:
 * [0]: minus sign?
 * [1]: low bits
 * [2]: high bits
 *
 * Copyright 2008 Google Inc.
 */
function int64fromString(dec) {
    // Check for minus sign.
    let minus = dec[0] == '-';
    if (minus)
        dec = dec.slice(1);
    // Work 6 decimal digits at a time, acting like we're converting base 1e6
    // digits to binary. This is safe to do with floating point math because
    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
        // Note: Number('') is 0.
        const digit1e6 = Number(dec.slice(begin, end));
        highBits *= base;
        lowBits = lowBits * base + digit1e6;
        // Carry bits from lowBits to highBits
        if (lowBits >= TWO_PWR_32_DBL) {
            highBits = highBits + ((lowBits / TWO_PWR_32_DBL) | 0);
            lowBits = lowBits % TWO_PWR_32_DBL;
        }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return [minus, lowBits, highBits];
}
/**
 * Format 64 bit integer value (as two JS numbers) to decimal string.
 *
 * Copyright 2008 Google Inc.
 */
function int64toString(bitsLow, bitsHigh) {
    // Skip the expensive conversion if the number is small enough to use the
    // built-in conversions.
    if ((bitsHigh >>> 0) <= 0x1FFFFF) {
        return '' + (TWO_PWR_32_DBL * bitsHigh + (bitsLow >>> 0));
    }
    // What this code is doing is essentially converting the input number from
    // base-2 to base-1e7, which allows us to represent the 64-bit range with
    // only 3 (very large) digits. Those digits are then trivial to convert to
    // a base-10 string.
    // The magic numbers used here are -
    // 2^24 = 16777216 = (1,6777216) in base-1e7.
    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.
    // Split 32:32 representation into 16:24:24 representation so our
    // intermediate digits don't overflow.
    let low = bitsLow & 0xFFFFFF;
    let mid = (((bitsLow >>> 24) | (bitsHigh << 8)) >>> 0) & 0xFFFFFF;
    let high = (bitsHigh >> 16) & 0xFFFF;
    // Assemble our three base-1e7 digits, ignoring carries. The maximum
    // value in a digit at this step is representable as a 48-bit integer, which
    // can be stored in a 64-bit floating point number.
    let digitA = low + (mid * 6777216) + (high * 6710656);
    let digitB = mid + (high * 8147497);
    let digitC = (high * 2);
    // Apply carries from A to B and from B to C.
    let base = 10000000;
    if (digitA >= base) {
        digitB += Math.floor(digitA / base);
        digitA %= base;
    }
    if (digitB >= base) {
        digitC += Math.floor(digitB / base);
        digitB %= base;
    }
    // Convert base-1e7 digits to base-10, with optional leading zeroes.
    function decimalFrom1e7(digit1e7, needLeadingZeros) {
        let partial = digit1e7 ? String(digit1e7) : '';
        if (needLeadingZeros) {
            return '0000000'.slice(partial.length) + partial;
        }
        return partial;
    }
    return decimalFrom1e7(digitC, /*needLeadingZeros=*/ 0) +
        decimalFrom1e7(digitB, /*needLeadingZeros=*/ digitC) +
        // If the final 1e7 digit didn't need leading zeros, we would have
        // returned via the trivial code path at the top.
        decimalFrom1e7(digitA, /*needLeadingZeros=*/ 1);
}
/**
 * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144
 */
function varint32write(value, bytes) {
    if (value >= 0) {
        // write value as varint 32
        while (value > 0x7f) {
            bytes.push((value & 0x7f) | 0x80);
            value = value >>> 7;
        }
        bytes.push(value);
    }
    else {
        for (let i = 0; i < 9; i++) {
            bytes.push(value & 127 | 128);
            value = value >> 7;
        }
        bytes.push(1);
    }
}
/**
 * Read an unsigned 32 bit varint.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220
 */
function varint32read() {
    let b = this.buf[this.pos++];
    let result = b & 0x7F;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 7;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 14;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 21;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    // Extract only last 4 bits
    b = this.buf[this.pos++];
    result |= (b & 0x0F) << 28;
    for (let readBytes = 5; ((b & 0x80) !== 0) && readBytes < 10; readBytes++)
        b = this.buf[this.pos++];
    if ((b & 0x80) != 0)
        throw new Error('invalid varint');
    this.assertBounds();
    // Result can have 32 bits, convert it to unsigned
    return result >>> 0;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js":
/*!***************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   jsonReadOptions: () => (/* binding */ jsonReadOptions),
/* harmony export */   jsonWriteOptions: () => (/* binding */ jsonWriteOptions),
/* harmony export */   mergeJsonOptions: () => (/* binding */ mergeJsonOptions)
/* harmony export */ });
const defaultsWrite = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0,
}, defaultsRead = {
    ignoreUnknownFields: false,
};
/**
 * Make options for reading JSON data from partial options.
 */
function jsonReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
/**
 * Make options for writing JSON data from partial options.
 */
function jsonWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
/**
 * Merges JSON write or read options. Later values override earlier values. Type registries are merged.
 */
function mergeJsonOptions(a, b) {
    var _a, _b;
    let c = Object.assign(Object.assign({}, a), b);
    c.typeRegistry = [...((_a = a === null || a === void 0 ? void 0 : a.typeRegistry) !== null && _a !== void 0 ? _a : []), ...((_b = b === null || b === void 0 ? void 0 : b.typeRegistry) !== null && _b !== void 0 ? _b : [])];
    return c;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js":
/*!*******************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),
/* harmony export */   typeofJsonValue: () => (/* binding */ typeofJsonValue)
/* harmony export */ });
/**
 * Get the type of a JSON value.
 * Distinguishes between array, null and object.
 */
function typeofJsonValue(value) {
    let t = typeof value;
    if (t == "object") {
        if (Array.isArray(value))
            return "array";
        if (value === null)
            return "null";
    }
    return t;
}
/**
 * Is this a JSON object (instead of an array or null)?
 */
function isJsonObject(value) {
    return value !== null && typeof value == "object" && !Array.isArray(value);
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lowerCamelCase: () => (/* binding */ lowerCamelCase)
/* harmony export */ });
/**
 * Converts snake_case to lowerCamelCase.
 *
 * Should behave like protoc:
 * https://github.com/protocolbuffers/protobuf/blob/e8ae137c96444ea313485ed1118c5e43b2099cf1/src/google/protobuf/compiler/java/java_helpers.cc#L118
 */
function lowerCamelCase(snakeCase) {
    let capNext = false;
    const sb = [];
    for (let i = 0; i < snakeCase.length; i++) {
        let next = snakeCase.charAt(i);
        if (next == '_') {
            capNext = true;
        }
        else if (/\d/.test(next)) {
            sb.push(next);
            capNext = true;
        }
        else if (capNext) {
            sb.push(next.toUpperCase());
            capNext = false;
        }
        else if (i == 0) {
            sb.push(next.toLowerCase());
        }
        else {
            sb.push(next);
        }
    }
    return sb.join('');
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js":
/*!****************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MESSAGE_TYPE: () => (/* binding */ MESSAGE_TYPE)
/* harmony export */ });
/**
 * The symbol used as a key on message objects to store the message type.
 *
 * Note that this is an experimental feature - it is here to stay, but
 * implementation details may change without notice.
 */
const MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type.js":
/*!*******************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MessageType: () => (/* binding */ MessageType)
/* harmony export */ });
/* harmony import */ var _message_type_contract__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./message-type-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js");
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _reflection_type_check__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reflection-type-check */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js");
/* harmony import */ var _reflection_json_reader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reflection-json-reader */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js");
/* harmony import */ var _reflection_json_writer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reflection-json-writer */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js");
/* harmony import */ var _reflection_binary_reader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./reflection-binary-reader */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js");
/* harmony import */ var _reflection_binary_writer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./reflection-binary-writer */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js");
/* harmony import */ var _reflection_create__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./reflection-create */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js");
/* harmony import */ var _reflection_merge_partial__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./reflection-merge-partial */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js");
/* harmony import */ var _json_typings__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./json-typings */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js");
/* harmony import */ var _json_format_contract__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./json-format-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js");
/* harmony import */ var _reflection_equals__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./reflection-equals */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js");
/* harmony import */ var _binary_writer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./binary-writer */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js");
/* harmony import */ var _binary_reader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./binary-reader */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js");














const baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
/**
 * This standard message type provides reflection-based
 * operations to work with a message.
 */
class MessageType {
    constructor(name, fields, options) {
        this.defaultCheckDepth = 16;
        this.typeName = name;
        this.fields = fields.map(_reflection_info__WEBPACK_IMPORTED_MODULE_0__.normalizeFieldInfo);
        this.options = options !== null && options !== void 0 ? options : {};
        this.messagePrototype = Object.create(null, Object.assign(Object.assign({}, baseDescriptors), { [_message_type_contract__WEBPACK_IMPORTED_MODULE_1__.MESSAGE_TYPE]: { value: this } }));
        this.refTypeCheck = new _reflection_type_check__WEBPACK_IMPORTED_MODULE_2__.ReflectionTypeCheck(this);
        this.refJsonReader = new _reflection_json_reader__WEBPACK_IMPORTED_MODULE_3__.ReflectionJsonReader(this);
        this.refJsonWriter = new _reflection_json_writer__WEBPACK_IMPORTED_MODULE_4__.ReflectionJsonWriter(this);
        this.refBinReader = new _reflection_binary_reader__WEBPACK_IMPORTED_MODULE_5__.ReflectionBinaryReader(this);
        this.refBinWriter = new _reflection_binary_writer__WEBPACK_IMPORTED_MODULE_6__.ReflectionBinaryWriter(this);
    }
    create(value) {
        let message = (0,_reflection_create__WEBPACK_IMPORTED_MODULE_7__.reflectionCreate)(this);
        if (value !== undefined) {
            (0,_reflection_merge_partial__WEBPACK_IMPORTED_MODULE_8__.reflectionMergePartial)(this, message, value);
        }
        return message;
    }
    /**
     * Clone the message.
     *
     * Unknown fields are discarded.
     */
    clone(message) {
        let copy = this.create();
        (0,_reflection_merge_partial__WEBPACK_IMPORTED_MODULE_8__.reflectionMergePartial)(this, copy, message);
        return copy;
    }
    /**
     * Determines whether two message of the same type have the same field values.
     * Checks for deep equality, traversing repeated fields, oneof groups, maps
     * and messages recursively.
     * Will also return true if both messages are `undefined`.
     */
    equals(a, b) {
        return (0,_reflection_equals__WEBPACK_IMPORTED_MODULE_9__.reflectionEquals)(this, a, b);
    }
    /**
     * Is the given value assignable to our message type
     * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */
    is(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, false);
    }
    /**
     * Is the given value assignable to our message type,
     * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */
    isAssignable(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, true);
    }
    /**
     * Copy partial data into the target message.
     */
    mergePartial(target, source) {
        (0,_reflection_merge_partial__WEBPACK_IMPORTED_MODULE_8__.reflectionMergePartial)(this, target, source);
    }
    /**
     * Create a new message from binary format.
     */
    fromBinary(data, options) {
        let opt = (0,_binary_reader__WEBPACK_IMPORTED_MODULE_10__.binaryReadOptions)(options);
        return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
    }
    /**
     * Read a new message from a JSON value.
     */
    fromJson(json, options) {
        return this.internalJsonRead(json, (0,_json_format_contract__WEBPACK_IMPORTED_MODULE_11__.jsonReadOptions)(options));
    }
    /**
     * Read a new message from a JSON string.
     * This is equivalent to `T.fromJson(JSON.parse(json))`.
     */
    fromJsonString(json, options) {
        let value = JSON.parse(json);
        return this.fromJson(value, options);
    }
    /**
     * Write the message to canonical JSON value.
     */
    toJson(message, options) {
        return this.internalJsonWrite(message, (0,_json_format_contract__WEBPACK_IMPORTED_MODULE_11__.jsonWriteOptions)(options));
    }
    /**
     * Convert the message to canonical JSON string.
     * This is equivalent to `JSON.stringify(T.toJson(t))`
     */
    toJsonString(message, options) {
        var _a;
        let value = this.toJson(message, options);
        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
    }
    /**
     * Write the message to binary format.
     */
    toBinary(message, options) {
        let opt = (0,_binary_writer__WEBPACK_IMPORTED_MODULE_12__.binaryWriteOptions)(options);
        return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
    }
    /**
     * This is an internal method. If you just want to read a message from
     * JSON, use `fromJson()` or `fromJsonString()`.
     *
     * Reads JSON value and merges the fields into the target
     * according to protobuf rules. If the target is omitted,
     * a new instance is created first.
     */
    internalJsonRead(json, options, target) {
        if (json !== null && typeof json == "object" && !Array.isArray(json)) {
            let message = target !== null && target !== void 0 ? target : this.create();
            this.refJsonReader.read(json, message, options);
            return message;
        }
        throw new Error(`Unable to parse message ${this.typeName} from JSON ${(0,_json_typings__WEBPACK_IMPORTED_MODULE_13__.typeofJsonValue)(json)}.`);
    }
    /**
     * This is an internal method. If you just want to write a message
     * to JSON, use `toJson()` or `toJsonString().
     *
     * Writes JSON value and returns it.
     */
    internalJsonWrite(message, options) {
        return this.refJsonWriter.write(message, options);
    }
    /**
     * This is an internal method. If you just want to write a message
     * in binary format, use `toBinary()`.
     *
     * Serializes the message in binary format and appends it to the given
     * writer. Returns passed writer.
     */
    internalBinaryWrite(message, writer, options) {
        this.refBinWriter.write(message, writer, options);
        return writer;
    }
    /**
     * This is an internal method. If you just want to read a message from
     * binary data, use `fromBinary()`.
     *
     * Reads data from binary format and merges the fields into
     * the target according to protobuf rules. If the target is
     * omitted, a new instance is created first.
     */
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create();
        this.refBinReader.read(reader, message, options, length);
        return message;
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/oneof.js":
/*!************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/oneof.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clearOneofValue: () => (/* binding */ clearOneofValue),
/* harmony export */   getOneofValue: () => (/* binding */ getOneofValue),
/* harmony export */   getSelectedOneofValue: () => (/* binding */ getSelectedOneofValue),
/* harmony export */   isOneofGroup: () => (/* binding */ isOneofGroup),
/* harmony export */   setOneofValue: () => (/* binding */ setOneofValue),
/* harmony export */   setUnknownOneofValue: () => (/* binding */ setUnknownOneofValue)
/* harmony export */ });
/**
 * Is the given value a valid oneof group?
 *
 * We represent protobuf `oneof` as algebraic data types (ADT) in generated
 * code. But when working with messages of unknown type, the ADT does not
 * help us.
 *
 * This type guard checks if the given object adheres to the ADT rules, which
 * are as follows:
 *
 * 1) Must be an object.
 *
 * 2) Must have a "oneofKind" discriminator property.
 *
 * 3) If "oneofKind" is `undefined`, no member field is selected. The object
 * must not have any other properties.
 *
 * 4) If "oneofKind" is a `string`, the member field with this name is
 * selected.
 *
 * 5) If a member field is selected, the object must have a second property
 * with this name. The property must not be `undefined`.
 *
 * 6) No extra properties are allowed. The object has either one property
 * (no selection) or two properties (selection).
 *
 */
function isOneofGroup(any) {
    if (typeof any != 'object' || any === null || !any.hasOwnProperty('oneofKind')) {
        return false;
    }
    switch (typeof any.oneofKind) {
        case "string":
            if (any[any.oneofKind] === undefined)
                return false;
            return Object.keys(any).length == 2;
        case "undefined":
            return Object.keys(any).length == 1;
        default:
            return false;
    }
}
/**
 * Returns the value of the given field in a oneof group.
 */
function getOneofValue(oneof, kind) {
    return oneof[kind];
}
function setOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== undefined) {
        delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = kind;
    if (value !== undefined) {
        oneof[kind] = value;
    }
}
function setUnknownOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== undefined) {
        delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = kind;
    if (value !== undefined && kind !== undefined) {
        oneof[kind] = value;
    }
}
/**
 * Removes the selected field in a oneof group.
 *
 * Note that the recommended way to modify a oneof group is to set
 * a new object:
 *
 * ```ts
 * message.result = { oneofKind: undefined };
 * ```
 */
function clearOneofValue(oneof) {
    if (oneof.oneofKind !== undefined) {
        delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = undefined;
}
/**
 * Returns the selected value of the given oneof group.
 *
 * Not that the recommended way to access a oneof group is to check
 * the "oneofKind" property and let TypeScript narrow down the union
 * type for you:
 *
 * ```ts
 * if (message.result.oneofKind === "error") {
 *   message.result.error; // string
 * }
 * ```
 *
 * In the rare case you just need the value, and do not care about
 * which protobuf field is selected, you can use this function
 * for convenience.
 */
function getSelectedOneofValue(oneof) {
    if (oneof.oneofKind === undefined) {
        return undefined;
    }
    return oneof[oneof.oneofKind];
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PbLong: () => (/* binding */ PbLong),
/* harmony export */   PbULong: () => (/* binding */ PbULong),
/* harmony export */   detectBi: () => (/* binding */ detectBi)
/* harmony export */ });
/* harmony import */ var _goog_varint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./goog-varint */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js");

let BI;
function detectBi() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = globalThis.BigInt !== undefined
        && typeof dv.getBigInt64 === "function"
        && typeof dv.getBigUint64 === "function"
        && typeof dv.setBigInt64 === "function"
        && typeof dv.setBigUint64 === "function";
    BI = ok ? {
        MIN: BigInt("-9223372036854775808"),
        MAX: BigInt("9223372036854775807"),
        UMIN: BigInt("0"),
        UMAX: BigInt("18446744073709551615"),
        C: BigInt,
        V: dv,
    } : undefined;
}
detectBi();
function assertBi(bi) {
    if (!bi)
        throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
// used to validate from(string) input (when bigint is unavailable)
const RE_DECIMAL_STR = /^-?[0-9]+$/;
// constants for binary math
const TWO_PWR_32_DBL = 0x100000000;
const HALF_2_PWR_32 = 0x080000000;
// base class for PbLong and PbULong provides shared code
class SharedPbLong {
    /**
     * Create a new instance with the given bits.
     */
    constructor(lo, hi) {
        this.lo = lo | 0;
        this.hi = hi | 0;
    }
    /**
     * Is this instance equal to 0?
     */
    isZero() {
        return this.lo == 0 && this.hi == 0;
    }
    /**
     * Convert to a native number.
     */
    toNumber() {
        let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);
        if (!Number.isSafeInteger(result))
            throw new Error("cannot convert to safe number");
        return result;
    }
}
/**
 * 64-bit unsigned integer as two 32-bit values.
 * Converts between `string`, `number` and `bigint` representations.
 */
class PbULong extends SharedPbLong {
    /**
     * Create instance from a `string`, `number` or `bigint`.
     */
    static from(value) {
        if (BI)
            // noinspection FallThroughInSwitchStatementJS
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    if (value == "")
                        throw new Error('string is no integer');
                    value = BI.C(value);
                case "number":
                    if (value === 0)
                        return this.ZERO;
                    value = BI.C(value);
                case "bigint":
                    if (!value)
                        return this.ZERO;
                    if (value < BI.UMIN)
                        throw new Error('signed value for ulong');
                    if (value > BI.UMAX)
                        throw new Error('ulong too large');
                    BI.V.setBigUint64(0, value, true);
                    return new PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
            }
        else
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    value = value.trim();
                    if (!RE_DECIMAL_STR.test(value))
                        throw new Error('string is no integer');
                    let [minus, lo, hi] = (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64fromString)(value);
                    if (minus)
                        throw new Error('signed value for ulong');
                    return new PbULong(lo, hi);
                case "number":
                    if (value == 0)
                        return this.ZERO;
                    if (!Number.isSafeInteger(value))
                        throw new Error('number is no integer');
                    if (value < 0)
                        throw new Error('signed value for ulong');
                    return new PbULong(value, value / TWO_PWR_32_DBL);
            }
        throw new Error('unknown value ' + typeof value);
    }
    /**
     * Convert to decimal string.
     */
    toString() {
        return BI ? this.toBigInt().toString() : (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64toString)(this.lo, this.hi);
    }
    /**
     * Convert to native bigint.
     */
    toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigUint64(0, true);
    }
}
/**
 * ulong 0 singleton.
 */
PbULong.ZERO = new PbULong(0, 0);
/**
 * 64-bit signed integer as two 32-bit values.
 * Converts between `string`, `number` and `bigint` representations.
 */
class PbLong extends SharedPbLong {
    /**
     * Create instance from a `string`, `number` or `bigint`.
     */
    static from(value) {
        if (BI)
            // noinspection FallThroughInSwitchStatementJS
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    if (value == "")
                        throw new Error('string is no integer');
                    value = BI.C(value);
                case "number":
                    if (value === 0)
                        return this.ZERO;
                    value = BI.C(value);
                case "bigint":
                    if (!value)
                        return this.ZERO;
                    if (value < BI.MIN)
                        throw new Error('signed long too small');
                    if (value > BI.MAX)
                        throw new Error('signed long too large');
                    BI.V.setBigInt64(0, value, true);
                    return new PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
            }
        else
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    value = value.trim();
                    if (!RE_DECIMAL_STR.test(value))
                        throw new Error('string is no integer');
                    let [minus, lo, hi] = (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64fromString)(value);
                    if (minus) {
                        if (hi > HALF_2_PWR_32 || (hi == HALF_2_PWR_32 && lo != 0))
                            throw new Error('signed long too small');
                    }
                    else if (hi >= HALF_2_PWR_32)
                        throw new Error('signed long too large');
                    let pbl = new PbLong(lo, hi);
                    return minus ? pbl.negate() : pbl;
                case "number":
                    if (value == 0)
                        return this.ZERO;
                    if (!Number.isSafeInteger(value))
                        throw new Error('number is no integer');
                    return value > 0
                        ? new PbLong(value, value / TWO_PWR_32_DBL)
                        : new PbLong(-value, -value / TWO_PWR_32_DBL).negate();
            }
        throw new Error('unknown value ' + typeof value);
    }
    /**
     * Do we have a minus sign?
     */
    isNegative() {
        return (this.hi & HALF_2_PWR_32) !== 0;
    }
    /**
     * Negate two's complement.
     * Invert all the bits and add one to the result.
     */
    negate() {
        let hi = ~this.hi, lo = this.lo;
        if (lo)
            lo = ~lo + 1;
        else
            hi += 1;
        return new PbLong(lo, hi);
    }
    /**
     * Convert to decimal string.
     */
    toString() {
        if (BI)
            return this.toBigInt().toString();
        if (this.isNegative()) {
            let n = this.negate();
            return '-' + (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64toString)(n.lo, n.hi);
        }
        return (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64toString)(this.lo, this.hi);
    }
    /**
     * Convert to native bigint.
     */
    toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigInt64(0, true);
    }
}
/**
 * long 0 singleton.
 */
PbLong.ZERO = new PbLong(0, 0);


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReflectionBinaryReader: () => (/* binding */ ReflectionBinaryReader)
/* harmony export */ });
/* harmony import */ var _binary_format_contract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binary-format-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js");
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reflection-long-convert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js");
/* harmony import */ var _reflection_scalar_default__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reflection-scalar-default */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js");




/**
 * Reads proto3 messages in binary format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/encoding
 */
class ReflectionBinaryReader {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        var _a;
        if (!this.fieldNoToField) {
            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
            this.fieldNoToField = new Map(fieldsInput.map(field => [field.no, field]));
        }
    }
    /**
     * Reads a message from binary format into the target message.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    read(reader, message, options, length) {
        this.prepare();
        const end = length === undefined ? reader.len : reader.pos + length;
        while (reader.pos < end) {
            // read the tag and find the field
            const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
            if (!field) {
                let u = options.readUnknownField;
                if (u == "throw")
                    throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
                let d = reader.skip(wireType);
                if (u !== false)
                    (u === true ? _binary_format_contract__WEBPACK_IMPORTED_MODULE_0__.UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);
                continue;
            }
            // target object for the field we are reading
            let target = message, repeated = field.repeat, localName = field.localName;
            // if field is member of oneof ADT, use ADT as target
            if (field.oneof) {
                target = target[field.oneof];
                // if other oneof member selected, set new ADT
                if (target.oneofKind !== localName)
                    target = message[field.oneof] = {
                        oneofKind: localName
                    };
            }
            // we have handled oneof above, we just have read the value into `target[localName]`
            switch (field.kind) {
                case "scalar":
                case "enum":
                    let T = field.kind == "enum" ? _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32 : field.T;
                    let L = field.kind == "scalar" ? field.L : undefined;
                    if (repeated) {
                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                        if (wireType == _binary_format_contract__WEBPACK_IMPORTED_MODULE_0__.WireType.LengthDelimited && T != _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING && T != _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES) {
                            let e = reader.uint32() + reader.pos;
                            while (reader.pos < e)
                                arr.push(this.scalar(reader, T, L));
                        }
                        else
                            arr.push(this.scalar(reader, T, L));
                    }
                    else
                        target[localName] = this.scalar(reader, T, L);
                    break;
                case "message":
                    if (repeated) {
                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                        let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
                        arr.push(msg);
                    }
                    else
                        target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
                    break;
                case "map":
                    let [mapKey, mapVal] = this.mapEntry(field, reader, options);
                    // safe to assume presence of map object, oneof cannot contain repeated values
                    target[localName][mapKey] = mapVal;
                    break;
            }
        }
    }
    /**
     * Read a map field, expecting key field = 1, value field = 2
     */
    mapEntry(field, reader, options) {
        let length = reader.uint32();
        let end = reader.pos + length;
        let key = undefined; // javascript only allows number or string for object properties
        let val = undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    if (field.K == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL)
                        key = reader.bool().toString();
                    else
                        // long types are read as string, number types are okay as number
                        key = this.scalar(reader, field.K, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.STRING);
                    break;
                case 2:
                    switch (field.V.kind) {
                        case "scalar":
                            val = this.scalar(reader, field.V.T, field.V.L);
                            break;
                        case "enum":
                            val = reader.int32();
                            break;
                        case "message":
                            val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
                            break;
                    }
                    break;
                default:
                    throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
            }
        }
        if (key === undefined) {
            let keyRaw = (0,_reflection_scalar_default__WEBPACK_IMPORTED_MODULE_2__.reflectionScalarDefault)(field.K);
            key = field.K == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL ? keyRaw.toString() : keyRaw;
        }
        if (val === undefined)
            switch (field.V.kind) {
                case "scalar":
                    val = (0,_reflection_scalar_default__WEBPACK_IMPORTED_MODULE_2__.reflectionScalarDefault)(field.V.T, field.V.L);
                    break;
                case "enum":
                    val = 0;
                    break;
                case "message":
                    val = field.V.T().create();
                    break;
            }
        return [key, val];
    }
    scalar(reader, type, longType) {
        switch (type) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32:
                return reader.int32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING:
                return reader.string();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                return reader.bool();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.DOUBLE:
                return reader.double();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT:
                return reader.float();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.int64(), longType);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.uint64(), longType);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.fixed64(), longType);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED32:
                return reader.fixed32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES:
                return reader.bytes();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32:
                return reader.uint32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED32:
                return reader.sfixed32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.sfixed64(), longType);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT32:
                return reader.sint32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.sint64(), longType);
        }
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReflectionBinaryWriter: () => (/* binding */ ReflectionBinaryWriter)
/* harmony export */ });
/* harmony import */ var _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./binary-format-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js");
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js");
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");




/**
 * Writes proto3 messages in binary format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/encoding
 */
class ReflectionBinaryWriter {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        if (!this.fields) {
            const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
            this.fields = fieldsInput.sort((a, b) => a.no - b.no);
        }
    }
    /**
     * Writes the message to binary format.
     */
    write(message, writer, options) {
        this.prepare();
        for (const field of this.fields) {
            let value, // this will be our field value, whether it is member of a oneof or not
            emitDefault, // whether we emit the default value (only true for oneof members)
            repeated = field.repeat, localName = field.localName;
            // handle oneof ADT
            if (field.oneof) {
                const group = message[field.oneof];
                if (group.oneofKind !== localName)
                    continue; // if field is not selected, skip
                value = group[localName];
                emitDefault = true;
            }
            else {
                value = message[localName];
                emitDefault = false;
            }
            // we have handled oneof above. we just have to honor `emitDefault`.
            switch (field.kind) {
                case "scalar":
                case "enum":
                    let T = field.kind == "enum" ? _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32 : field.T;
                    if (repeated) {
                        (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(Array.isArray(value));
                        if (repeated == _reflection_info__WEBPACK_IMPORTED_MODULE_0__.RepeatType.PACKED)
                            this.packed(writer, T, field.no, value);
                        else
                            for (const item of value)
                                this.scalar(writer, T, field.no, item, true);
                    }
                    else if (value === undefined)
                        (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(field.opt);
                    else
                        this.scalar(writer, T, field.no, value, emitDefault || field.opt);
                    break;
                case "message":
                    if (repeated) {
                        (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(Array.isArray(value));
                        for (const item of value)
                            this.message(writer, options, field.T(), field.no, item);
                    }
                    else {
                        this.message(writer, options, field.T(), field.no, value);
                    }
                    break;
                case "map":
                    (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof value == 'object' && value !== null);
                    for (const [key, val] of Object.entries(value))
                        this.mapEntry(writer, options, field, key, val);
                    break;
            }
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);
    }
    mapEntry(writer, options, field, key, value) {
        writer.tag(field.no, _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited);
        writer.fork();
        // javascript only allows number or string for object properties
        // we convert from our representation to the protobuf type
        let keyValue = key;
        switch (field.K) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.UINT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SFIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SINT32:
                keyValue = Number.parseInt(key);
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BOOL:
                (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(key == 'true' || key == 'false');
                keyValue = key == 'true';
                break;
        }
        // write key, expecting key field number = 1
        this.scalar(writer, field.K, 1, keyValue, true);
        // write value, expecting value field number = 2
        switch (field.V.kind) {
            case 'scalar':
                this.scalar(writer, field.V.T, 2, value, true);
                break;
            case 'enum':
                this.scalar(writer, _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32, 2, value, true);
                break;
            case 'message':
                this.message(writer, options, field.V.T(), 2, value);
                break;
        }
        writer.join();
    }
    message(writer, options, handler, fieldNo, value) {
        if (value === undefined)
            return;
        handler.internalBinaryWrite(value, writer.tag(fieldNo, _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).fork(), options);
        writer.join();
    }
    /**
     * Write a single scalar value.
     */
    scalar(writer, type, fieldNo, value, emitDefault) {
        let [wireType, method, isDefault] = this.scalarInfo(type, value);
        if (!isDefault || emitDefault) {
            writer.tag(fieldNo, wireType);
            writer[method](value);
        }
    }
    /**
     * Write an array of scalar values in packed format.
     */
    packed(writer, type, fieldNo, value) {
        if (!value.length)
            return;
        (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(type !== _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BYTES && type !== _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.STRING);
        // write tag
        writer.tag(fieldNo, _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited);
        // begin length-delimited
        writer.fork();
        // write values without tags
        let [, method,] = this.scalarInfo(type);
        for (let i = 0; i < value.length; i++)
            writer[method](value[i]);
        // end length delimited
        writer.join();
    }
    /**
     * Get information for writing a scalar value.
     *
     * Returns tuple:
     * [0]: appropriate WireType
     * [1]: name of the appropriate method of IBinaryWriter
     * [2]: whether the given value is a default value
     *
     * If argument `value` is omitted, [2] is always false.
     */
    scalarInfo(type, value) {
        let t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint;
        let m;
        let i = value === undefined;
        let d = value === 0;
        switch (type) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32:
                m = "int32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.STRING:
                d = i || !value.length;
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited;
                m = "string";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BOOL:
                d = value === false;
                m = "bool";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.UINT32:
                m = "uint32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.DOUBLE:
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit64;
                m = "double";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FLOAT:
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit32;
                m = "float";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbLong.from(value).isZero();
                m = "int64";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.UINT64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbULong.from(value).isZero();
                m = "uint64";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FIXED64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbULong.from(value).isZero();
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit64;
                m = "fixed64";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BYTES:
                d = i || !value.byteLength;
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited;
                m = "bytes";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FIXED32:
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit32;
                m = "fixed32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SFIXED32:
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit32;
                m = "sfixed32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SFIXED64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbLong.from(value).isZero();
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit64;
                m = "sfixed64";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SINT32:
                m = "sint32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SINT64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbLong.from(value).isZero();
                m = "sint64";
                break;
        }
        return [t, m, i || d];
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reflectionCreate: () => (/* binding */ reflectionCreate)
/* harmony export */ });
/* harmony import */ var _reflection_scalar_default__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-scalar-default */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js");
/* harmony import */ var _message_type_contract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./message-type-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js");


/**
 * Creates an instance of the generic message, using the field
 * information.
 */
function reflectionCreate(type) {
    /**
     * This ternary can be removed in the next major version.
     * The `Object.create()` code path utilizes a new `messagePrototype`
     * property on the `IMessageType` which has this same `MESSAGE_TYPE`
     * non-enumerable property on it. Doing it this way means that we only
     * pay the cost of `Object.defineProperty()` once per `IMessageType`
     * class of once per "instance". The falsy code path is only provided
     * for backwards compatibility in cases where the runtime library is
     * updated without also updating the generated code.
     */
    const msg = type.messagePrototype
        ? Object.create(type.messagePrototype)
        : Object.defineProperty({}, _message_type_contract__WEBPACK_IMPORTED_MODULE_0__.MESSAGE_TYPE, { value: type });
    for (let field of type.fields) {
        let name = field.localName;
        if (field.opt)
            continue;
        if (field.oneof)
            msg[field.oneof] = { oneofKind: undefined };
        else if (field.repeat)
            msg[name] = [];
        else
            switch (field.kind) {
                case "scalar":
                    msg[name] = (0,_reflection_scalar_default__WEBPACK_IMPORTED_MODULE_1__.reflectionScalarDefault)(field.T, field.L);
                    break;
                case "enum":
                    // we require 0 to be default value for all enums
                    msg[name] = 0;
                    break;
                case "map":
                    msg[name] = {};
                    break;
            }
    }
    return msg;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reflectionEquals: () => (/* binding */ reflectionEquals)
/* harmony export */ });
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");

/**
 * Determines whether two message of the same type have the same field values.
 * Checks for deep equality, traversing repeated fields, oneof groups, maps
 * and messages recursively.
 * Will also return true if both messages are `undefined`.
 */
function reflectionEquals(info, a, b) {
    if (a === b)
        return true;
    if (!a || !b)
        return false;
    for (let field of info.fields) {
        let localName = field.localName;
        let val_a = field.oneof ? a[field.oneof][localName] : a[localName];
        let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
        switch (field.kind) {
            case "enum":
            case "scalar":
                let t = field.kind == "enum" ? _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32 : field.T;
                if (!(field.repeat
                    ? repeatedPrimitiveEq(t, val_a, val_b)
                    : primitiveEq(t, val_a, val_b)))
                    return false;
                break;
            case "map":
                if (!(field.V.kind == "message"
                    ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b))
                    : repeatedPrimitiveEq(field.V.kind == "enum" ? _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
                    return false;
                break;
            case "message":
                let T = field.T();
                if (!(field.repeat
                    ? repeatedMsgEq(T, val_a, val_b)
                    : T.equals(val_a, val_b)))
                    return false;
                break;
        }
    }
    return true;
}
const objectValues = Object.values;
function primitiveEq(type, a, b) {
    if (a === b)
        return true;
    if (type !== _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BYTES)
        return false;
    let ba = a;
    let bb = b;
    if (ba.length !== bb.length)
        return false;
    for (let i = 0; i < ba.length; i++)
        if (ba[i] != bb[i])
            return false;
    return true;
}
function repeatedPrimitiveEq(type, a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!primitiveEq(type, a[i], b[i]))
            return false;
    return true;
}
function repeatedMsgEq(type, a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!type.equals(a[i], b[i]))
            return false;
    return true;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LongType: () => (/* binding */ LongType),
/* harmony export */   RepeatType: () => (/* binding */ RepeatType),
/* harmony export */   ScalarType: () => (/* binding */ ScalarType),
/* harmony export */   normalizeFieldInfo: () => (/* binding */ normalizeFieldInfo),
/* harmony export */   readFieldOption: () => (/* binding */ readFieldOption),
/* harmony export */   readFieldOptions: () => (/* binding */ readFieldOptions),
/* harmony export */   readMessageOption: () => (/* binding */ readMessageOption)
/* harmony export */ });
/* harmony import */ var _lower_camel_case__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lower-camel-case */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js");

/**
 * Scalar value types. This is a subset of field types declared by protobuf
 * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE
 * are omitted, but the numerical values are identical.
 */
var ScalarType;
(function (ScalarType) {
    // 0 is reserved for errors.
    // Order is weird for historical reasons.
    ScalarType[ScalarType["DOUBLE"] = 1] = "DOUBLE";
    ScalarType[ScalarType["FLOAT"] = 2] = "FLOAT";
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
    // negative values are likely.
    ScalarType[ScalarType["INT64"] = 3] = "INT64";
    ScalarType[ScalarType["UINT64"] = 4] = "UINT64";
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
    // negative values are likely.
    ScalarType[ScalarType["INT32"] = 5] = "INT32";
    ScalarType[ScalarType["FIXED64"] = 6] = "FIXED64";
    ScalarType[ScalarType["FIXED32"] = 7] = "FIXED32";
    ScalarType[ScalarType["BOOL"] = 8] = "BOOL";
    ScalarType[ScalarType["STRING"] = 9] = "STRING";
    // Tag-delimited aggregate.
    // Group type is deprecated and not supported in proto3. However, Proto3
    // implementations should still be able to parse the group wire format and
    // treat group fields as unknown fields.
    // TYPE_GROUP = 10,
    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.
    // New in version 2.
    ScalarType[ScalarType["BYTES"] = 12] = "BYTES";
    ScalarType[ScalarType["UINT32"] = 13] = "UINT32";
    // TYPE_ENUM = 14,
    ScalarType[ScalarType["SFIXED32"] = 15] = "SFIXED32";
    ScalarType[ScalarType["SFIXED64"] = 16] = "SFIXED64";
    ScalarType[ScalarType["SINT32"] = 17] = "SINT32";
    ScalarType[ScalarType["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
/**
 * JavaScript representation of 64 bit integral types. Equivalent to the
 * field option "jstype".
 *
 * By default, protobuf-ts represents 64 bit types as `bigint`.
 *
 * You can change the default behaviour by enabling the plugin parameter
 * `long_type_string`, which will represent 64 bit types as `string`.
 *
 * Alternatively, you can change the behaviour for individual fields
 * with the field option "jstype":
 *
 * ```protobuf
 * uint64 my_field = 1 [jstype = JS_STRING];
 * uint64 other_field = 2 [jstype = JS_NUMBER];
 * ```
 */
var LongType;
(function (LongType) {
    /**
     * Use JavaScript `bigint`.
     *
     * Field option `[jstype = JS_NORMAL]`.
     */
    LongType[LongType["BIGINT"] = 0] = "BIGINT";
    /**
     * Use JavaScript `string`.
     *
     * Field option `[jstype = JS_STRING]`.
     */
    LongType[LongType["STRING"] = 1] = "STRING";
    /**
     * Use JavaScript `number`.
     *
     * Large values will loose precision.
     *
     * Field option `[jstype = JS_NUMBER]`.
     */
    LongType[LongType["NUMBER"] = 2] = "NUMBER";
})(LongType || (LongType = {}));
/**
 * Protobuf 2.1.0 introduced packed repeated fields.
 * Setting the field option `[packed = true]` enables packing.
 *
 * In proto3, all repeated fields are packed by default.
 * Setting the field option `[packed = false]` disables packing.
 *
 * Packed repeated fields are encoded with a single tag,
 * then a length-delimiter, then the element values.
 *
 * Unpacked repeated fields are encoded with a tag and
 * value for each element.
 *
 * `bytes` and `string` cannot be packed.
 */
var RepeatType;
(function (RepeatType) {
    /**
     * The field is not repeated.
     */
    RepeatType[RepeatType["NO"] = 0] = "NO";
    /**
     * The field is repeated and should be packed.
     * Invalid for `bytes` and `string`, they cannot be packed.
     */
    RepeatType[RepeatType["PACKED"] = 1] = "PACKED";
    /**
     * The field is repeated but should not be packed.
     * The only valid repeat type for repeated `bytes` and `string`.
     */
    RepeatType[RepeatType["UNPACKED"] = 2] = "UNPACKED";
})(RepeatType || (RepeatType = {}));
/**
 * Turns PartialFieldInfo into FieldInfo.
 */
function normalizeFieldInfo(field) {
    var _a, _b, _c, _d;
    field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : (0,_lower_camel_case__WEBPACK_IMPORTED_MODULE_0__.lowerCamelCase)(field.name);
    field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : (0,_lower_camel_case__WEBPACK_IMPORTED_MODULE_0__.lowerCamelCase)(field.name);
    field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;
    field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : (field.repeat ? false : field.oneof ? false : field.kind == "message");
    return field;
}
/**
 * Read custom field options from a generated message type.
 *
 * @deprecated use readFieldOption()
 */
function readFieldOptions(messageType, fieldName, extensionName, extensionType) {
    var _a;
    const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
    return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : undefined;
}
function readFieldOption(messageType, fieldName, extensionName, extensionType) {
    var _a;
    const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
    if (!options) {
        return undefined;
    }
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
        return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
function readMessageOption(messageType, extensionName, extensionType) {
    const options = messageType.options;
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
        return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReflectionJsonReader: () => (/* binding */ ReflectionJsonReader)
/* harmony export */ });
/* harmony import */ var _json_typings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./json-typings */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js");
/* harmony import */ var _base64__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base64 */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/base64.js");
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js");
/* harmony import */ var _reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reflection-long-convert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js");






/**
 * Reads proto3 messages in canonical JSON format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/proto3#json
 */
class ReflectionJsonReader {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        var _a;
        if (this.fMap === undefined) {
            this.fMap = {};
            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
            for (const field of fieldsInput) {
                this.fMap[field.name] = field;
                this.fMap[field.jsonName] = field;
                this.fMap[field.localName] = field;
            }
        }
    }
    // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
    assert(condition, fieldName, jsonValue) {
        if (!condition) {
            let what = (0,_json_typings__WEBPACK_IMPORTED_MODULE_0__.typeofJsonValue)(jsonValue);
            if (what == "number" || what == "boolean")
                what = jsonValue.toString();
            throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
        }
    }
    /**
     * Reads a message from canonical JSON format into the target message.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    read(input, message, options) {
        this.prepare();
        const oneofsHandled = [];
        for (const [jsonKey, jsonValue] of Object.entries(input)) {
            const field = this.fMap[jsonKey];
            if (!field) {
                if (!options.ignoreUnknownFields)
                    throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
                continue;
            }
            const localName = field.localName;
            // handle oneof ADT
            let target; // this will be the target for the field value, whether it is member of a oneof or not
            if (field.oneof) {
                if (jsonValue === null && (field.kind !== 'enum' || field.T()[0] !== 'google.protobuf.NullValue')) {
                    continue;
                }
                // since json objects are unordered by specification, it is not possible to take the last of multiple oneofs
                if (oneofsHandled.includes(field.oneof))
                    throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
                oneofsHandled.push(field.oneof);
                target = message[field.oneof] = {
                    oneofKind: localName
                };
            }
            else {
                target = message;
            }
            // we have handled oneof above. we just have read the value into `target`.
            if (field.kind == 'map') {
                if (jsonValue === null) {
                    continue;
                }
                // check input
                this.assert((0,_json_typings__WEBPACK_IMPORTED_MODULE_0__.isJsonObject)(jsonValue), field.name, jsonValue);
                // our target to put map entries into
                const fieldObj = target[localName];
                // read entries
                for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
                    this.assert(jsonObjValue !== null, field.name + " map value", null);
                    // read value
                    let val;
                    switch (field.V.kind) {
                        case "message":
                            val = field.V.T().internalJsonRead(jsonObjValue, options);
                            break;
                        case "enum":
                            val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
                            if (val === false)
                                continue;
                            break;
                        case "scalar":
                            val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
                            break;
                    }
                    this.assert(val !== undefined, field.name + " map value", jsonObjValue);
                    // read key
                    let key = jsonObjKey;
                    if (field.K == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL)
                        key = key == "true" ? true : key == "false" ? false : key;
                    key = this.scalar(key, field.K, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.STRING, field.name).toString();
                    fieldObj[key] = val;
                }
            }
            else if (field.repeat) {
                if (jsonValue === null)
                    continue;
                // check input
                this.assert(Array.isArray(jsonValue), field.name, jsonValue);
                // our target to put array entries into
                const fieldArr = target[localName];
                // read array entries
                for (const jsonItem of jsonValue) {
                    this.assert(jsonItem !== null, field.name, null);
                    let val;
                    switch (field.kind) {
                        case "message":
                            val = field.T().internalJsonRead(jsonItem, options);
                            break;
                        case "enum":
                            val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
                            if (val === false)
                                continue;
                            break;
                        case "scalar":
                            val = this.scalar(jsonItem, field.T, field.L, field.name);
                            break;
                    }
                    this.assert(val !== undefined, field.name, jsonValue);
                    fieldArr.push(val);
                }
            }
            else {
                switch (field.kind) {
                    case "message":
                        if (jsonValue === null && field.T().typeName != 'google.protobuf.Value') {
                            this.assert(field.oneof === undefined, field.name + " (oneof member)", null);
                            continue;
                        }
                        target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
                        break;
                    case "enum":
                        if (jsonValue === null)
                            continue;
                        let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
                        if (val === false)
                            continue;
                        target[localName] = val;
                        break;
                    case "scalar":
                        if (jsonValue === null)
                            continue;
                        target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
                        break;
                }
            }
        }
    }
    /**
     * Returns `false` for unrecognized string representations.
     *
     * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
     */
    enum(type, json, fieldName, ignoreUnknownFields) {
        if (type[0] == 'google.protobuf.NullValue')
            (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assert)(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
        if (json === null)
            // we require 0 to be default value for all enums
            return 0;
        switch (typeof json) {
            case "number":
                (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assert)(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
                return json;
            case "string":
                let localEnumName = json;
                if (type[2] && json.substring(0, type[2].length) === type[2])
                    // lookup without the shared prefix
                    localEnumName = json.substring(type[2].length);
                let enumNumber = type[1][localEnumName];
                if (typeof enumNumber === 'undefined' && ignoreUnknownFields) {
                    return false;
                }
                (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
                return enumNumber;
        }
        (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assert)(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
    }
    scalar(json, type, longType, fieldName) {
        let e;
        try {
            switch (type) {
                // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
                // Either numbers or strings are accepted. Exponent notation is also accepted.
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.DOUBLE:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT:
                    if (json === null)
                        return .0;
                    if (json === "NaN")
                        return Number.NaN;
                    if (json === "Infinity")
                        return Number.POSITIVE_INFINITY;
                    if (json === "-Infinity")
                        return Number.NEGATIVE_INFINITY;
                    if (json === "") {
                        e = "empty string";
                        break;
                    }
                    if (typeof json == "string" && json.trim().length !== json.length) {
                        e = "extra whitespace";
                        break;
                    }
                    if (typeof json != "string" && typeof json != "number") {
                        break;
                    }
                    let float = Number(json);
                    if (Number.isNaN(float)) {
                        e = "not a number";
                        break;
                    }
                    if (!Number.isFinite(float)) {
                        // infinity and -infinity are handled by string representation above, so this is an error
                        e = "too large or small";
                        break;
                    }
                    if (type == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT)
                        (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assertFloat32)(float);
                    return float;
                // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED32:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED32:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT32:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32:
                    if (json === null)
                        return 0;
                    let int32;
                    if (typeof json == "number")
                        int32 = json;
                    else if (json === "")
                        e = "empty string";
                    else if (typeof json == "string") {
                        if (json.trim().length !== json.length)
                            e = "extra whitespace";
                        else
                            int32 = Number(json);
                    }
                    if (int32 === undefined)
                        break;
                    if (type == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32)
                        (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assertUInt32)(int32);
                    else
                        (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assertInt32)(int32);
                    return int32;
                // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT64:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED64:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT64:
                    if (json === null)
                        return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_4__.PbLong.ZERO, longType);
                    if (typeof json != "number" && typeof json != "string")
                        break;
                    return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_4__.PbLong.from(json), longType);
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED64:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT64:
                    if (json === null)
                        return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_4__.PbULong.ZERO, longType);
                    if (typeof json != "number" && typeof json != "string")
                        break;
                    return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_4__.PbULong.from(json), longType);
                // bool:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                    if (json === null)
                        return false;
                    if (typeof json !== "boolean")
                        break;
                    return json;
                // string:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING:
                    if (json === null)
                        return "";
                    if (typeof json !== "string") {
                        e = "extra whitespace";
                        break;
                    }
                    try {
                        encodeURIComponent(json);
                    }
                    catch (e) {
                        e = "invalid UTF8";
                        break;
                    }
                    return json;
                // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
                // Either standard or URL-safe base64 encoding with/without paddings are accepted.
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES:
                    if (json === null || json === "")
                        return new Uint8Array(0);
                    if (typeof json !== 'string')
                        break;
                    return (0,_base64__WEBPACK_IMPORTED_MODULE_5__.base64decode)(json);
            }
        }
        catch (error) {
            e = error.message;
        }
        this.assert(false, fieldName + (e ? " - " + e : ""), json);
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReflectionJsonWriter: () => (/* binding */ ReflectionJsonWriter)
/* harmony export */ });
/* harmony import */ var _base64__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base64 */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/base64.js");
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js");




/**
 * Writes proto3 messages in canonical JSON format using reflection
 * information.
 *
 * https://developers.google.com/protocol-buffers/docs/proto3#json
 */
class ReflectionJsonWriter {
    constructor(info) {
        var _a;
        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
    }
    /**
     * Converts the message to a JSON object, based on the field descriptors.
     */
    write(message, options) {
        const json = {}, source = message;
        for (const field of this.fields) {
            // field is not part of a oneof, simply write as is
            if (!field.oneof) {
                let jsonValue = this.field(field, source[field.localName], options);
                if (jsonValue !== undefined)
                    json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
                continue;
            }
            // field is part of a oneof
            const group = source[field.oneof];
            if (group.oneofKind !== field.localName)
                continue; // not selected, skip
            const opt = field.kind == 'scalar' || field.kind == 'enum'
                ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
            let jsonValue = this.field(field, group[field.localName], opt);
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(jsonValue !== undefined);
            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
        }
        return json;
    }
    field(field, value, options) {
        let jsonValue = undefined;
        if (field.kind == 'map') {
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == "object" && value !== null);
            const jsonObj = {};
            switch (field.V.kind) {
                case "scalar":
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        const val = this.scalar(field.V.T, entryValue, field.name, false, true);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
                case "message":
                    const messageType = field.V.T();
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        const val = this.message(messageType, entryValue, field.name, options);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
                case "enum":
                    const enumInfo = field.V.T();
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(entryValue === undefined || typeof entryValue == 'number');
                        const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
            }
            if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
                jsonValue = jsonObj;
        }
        else if (field.repeat) {
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(Array.isArray(value));
            const jsonArr = [];
            switch (field.kind) {
                case "scalar":
                    for (let i = 0; i < value.length; i++) {
                        const val = this.scalar(field.T, value[i], field.name, field.opt, true);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
                case "enum":
                    const enumInfo = field.T();
                    for (let i = 0; i < value.length; i++) {
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(value[i] === undefined || typeof value[i] == 'number');
                        const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
                case "message":
                    const messageType = field.T();
                    for (let i = 0; i < value.length; i++) {
                        const val = this.message(messageType, value[i], field.name, options);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
            }
            // add converted array to json output
            if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
                jsonValue = jsonArr;
        }
        else {
            switch (field.kind) {
                case "scalar":
                    jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
                    break;
                case "enum":
                    jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
                    break;
                case "message":
                    jsonValue = this.message(field.T(), value, field.name, options);
                    break;
            }
        }
        return jsonValue;
    }
    /**
     * Returns `null` as the default for google.protobuf.NullValue.
     */
    enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
        if (type[0] == 'google.protobuf.NullValue')
            return !emitDefaultValues && !optional ? undefined : null;
        if (value === undefined) {
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(optional);
            return undefined;
        }
        if (value === 0 && !emitDefaultValues && !optional)
            // we require 0 to be default value for all enums
            return undefined;
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'number');
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(Number.isInteger(value));
        if (enumAsInteger || !type[1].hasOwnProperty(value))
            // if we don't now the enum value, just return the number
            return value;
        if (type[2])
            // restore the dropped prefix
            return type[2] + type[1][value];
        return type[1][value];
    }
    message(type, value, fieldName, options) {
        if (value === undefined)
            return options.emitDefaultValues ? null : undefined;
        return type.internalJsonWrite(value, options);
    }
    scalar(type, value, fieldName, optional, emitDefaultValues) {
        if (value === undefined) {
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(optional);
            return undefined;
        }
        const ed = emitDefaultValues || optional;
        // noinspection FallThroughInSwitchStatementJS
        switch (type) {
            // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT32:
                if (value === 0)
                    return ed ? 0 : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertInt32)(value);
                return value;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32:
                if (value === 0)
                    return ed ? 0 : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertUInt32)(value);
                return value;
            // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
            // Either numbers or strings are accepted. Exponent notation is also accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT:
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertFloat32)(value);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.DOUBLE:
                if (value === 0)
                    return ed ? 0 : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'number');
                if (Number.isNaN(value))
                    return 'NaN';
                if (value === Number.POSITIVE_INFINITY)
                    return 'Infinity';
                if (value === Number.NEGATIVE_INFINITY)
                    return '-Infinity';
                return value;
            // string:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING:
                if (value === "")
                    return ed ? '' : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'string');
                return value;
            // bool:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                if (value === false)
                    return ed ? false : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'boolean');
                return value;
            // JSON value will be a decimal string. Either numbers or strings are accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED64:
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                let ulong = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong.from(value);
                if (ulong.isZero() && !ed)
                    return undefined;
                return ulong.toString();
            // JSON value will be a decimal string. Either numbers or strings are accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT64:
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.from(value);
                if (long.isZero() && !ed)
                    return undefined;
                return long.toString();
            // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
            // Either standard or URL-safe base64 encoding with/without paddings are accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES:
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(value instanceof Uint8Array);
                if (!value.byteLength)
                    return ed ? "" : undefined;
                return (0,_base64__WEBPACK_IMPORTED_MODULE_3__.base64encode)(value);
        }
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reflectionLongConvert: () => (/* binding */ reflectionLongConvert)
/* harmony export */ });
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");

/**
 * Utility method to convert a PbLong or PbUlong to a JavaScript
 * representation during runtime.
 *
 * Works with generated field information, `undefined` is equivalent
 * to `STRING`.
 */
function reflectionLongConvert(long, type) {
    switch (type) {
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.LongType.BIGINT:
            return long.toBigInt();
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.LongType.NUMBER:
            return long.toNumber();
        default:
            // case undefined:
            // case LongType.STRING:
            return long.toString();
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reflectionMergePartial: () => (/* binding */ reflectionMergePartial)
/* harmony export */ });
/**
 * Copy partial data into the target message.
 *
 * If a singular scalar or enum field is present in the source, it
 * replaces the field in the target.
 *
 * If a singular message field is present in the source, it is merged
 * with the target field by calling mergePartial() of the responsible
 * message type.
 *
 * If a repeated field is present in the source, its values replace
 * all values in the target array, removing extraneous values.
 * Repeated message fields are copied, not merged.
 *
 * If a map field is present in the source, entries are added to the
 * target map, replacing entries with the same key. Entries that only
 * exist in the target remain. Entries with message values are copied,
 * not merged.
 *
 * Note that this function differs from protobuf merge semantics,
 * which appends repeated fields.
 */
function reflectionMergePartial(info, target, source) {
    let fieldValue, // the field value we are working with
    input = source, output; // where we want our field value to go
    for (let field of info.fields) {
        let name = field.localName;
        if (field.oneof) {
            const group = input[field.oneof]; // this is the oneof`s group in the source
            if ((group === null || group === void 0 ? void 0 : group.oneofKind) == undefined) { // the user is free to omit
                continue; // we skip this field, and all other members too
            }
            fieldValue = group[name]; // our value comes from the the oneof group of the source
            output = target[field.oneof]; // and our output is the oneof group of the target
            output.oneofKind = group.oneofKind; // always update discriminator
            if (fieldValue == undefined) {
                delete output[name]; // remove any existing value
                continue; // skip further work on field
            }
        }
        else {
            fieldValue = input[name]; // we are using the source directly
            output = target; // we want our field value to go directly into the target
            if (fieldValue == undefined) {
                continue; // skip further work on field, existing value is used as is
            }
        }
        if (field.repeat)
            output[name].length = fieldValue.length; // resize target array to match source array
        // now we just work with `fieldValue` and `output` to merge the value
        switch (field.kind) {
            case "scalar":
            case "enum":
                if (field.repeat)
                    for (let i = 0; i < fieldValue.length; i++)
                        output[name][i] = fieldValue[i]; // not a reference type
                else
                    output[name] = fieldValue; // not a reference type
                break;
            case "message":
                let T = field.T();
                if (field.repeat)
                    for (let i = 0; i < fieldValue.length; i++)
                        output[name][i] = T.create(fieldValue[i]);
                else if (output[name] === undefined)
                    output[name] = T.create(fieldValue); // nothing to merge with
                else
                    T.mergePartial(output[name], fieldValue);
                break;
            case "map":
                // Map and repeated fields are simply overwritten, not appended or merged
                switch (field.V.kind) {
                    case "scalar":
                    case "enum":
                        Object.assign(output[name], fieldValue); // elements are not reference types
                        break;
                    case "message":
                        let T = field.V.T();
                        for (let k of Object.keys(fieldValue))
                            output[name][k] = T.create(fieldValue[k]);
                        break;
                }
                break;
        }
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js":
/*!********************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reflectionScalarDefault: () => (/* binding */ reflectionScalarDefault)
/* harmony export */ });
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _reflection_long_convert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-long-convert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js");
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");



/**
 * Creates the default value for a scalar type.
 */
function reflectionScalarDefault(type, longType = _reflection_info__WEBPACK_IMPORTED_MODULE_0__.LongType.STRING) {
    switch (type) {
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BOOL:
            return false;
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.UINT64:
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FIXED64:
            return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_1__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong.ZERO, longType);
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT64:
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SFIXED64:
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SINT64:
            return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_1__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.ZERO, longType);
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.DOUBLE:
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FLOAT:
            return 0.0;
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BYTES:
            return new Uint8Array(0);
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.STRING:
            return "";
        default:
            // case ScalarType.INT32:
            // case ScalarType.UINT32:
            // case ScalarType.SINT32:
            // case ScalarType.FIXED32:
            // case ScalarType.SFIXED32:
            return 0;
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js":
/*!****************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReflectionTypeCheck: () => (/* binding */ ReflectionTypeCheck)
/* harmony export */ });
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _oneof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./oneof */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/oneof.js");


// noinspection JSMethodCanBeStatic
class ReflectionTypeCheck {
    constructor(info) {
        var _a;
        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
    }
    prepare() {
        if (this.data)
            return;
        const req = [], known = [], oneofs = [];
        for (let field of this.fields) {
            if (field.oneof) {
                if (!oneofs.includes(field.oneof)) {
                    oneofs.push(field.oneof);
                    req.push(field.oneof);
                    known.push(field.oneof);
                }
            }
            else {
                known.push(field.localName);
                switch (field.kind) {
                    case "scalar":
                    case "enum":
                        if (!field.opt || field.repeat)
                            req.push(field.localName);
                        break;
                    case "message":
                        if (field.repeat)
                            req.push(field.localName);
                        break;
                    case "map":
                        req.push(field.localName);
                        break;
                }
            }
        }
        this.data = { req, known, oneofs: Object.values(oneofs) };
    }
    /**
     * Is the argument a valid message as specified by the
     * reflection information?
     *
     * Checks all field types recursively. The `depth`
     * specifies how deep into the structure the check will be.
     *
     * With a depth of 0, only the presence of fields
     * is checked.
     *
     * With a depth of 1 or more, the field types are checked.
     *
     * With a depth of 2 or more, the members of map, repeated
     * and message fields are checked.
     *
     * Message fields will be checked recursively with depth - 1.
     *
     * The number of map entries / repeated values being checked
     * is < depth.
     */
    is(message, depth, allowExcessProperties = false) {
        if (depth < 0)
            return true;
        if (message === null || message === undefined || typeof message != 'object')
            return false;
        this.prepare();
        let keys = Object.keys(message), data = this.data;
        // if a required field is missing in arg, this cannot be a T
        if (keys.length < data.req.length || data.req.some(n => !keys.includes(n)))
            return false;
        if (!allowExcessProperties) {
            // if the arg contains a key we dont know, this is not a literal T
            if (keys.some(k => !data.known.includes(k)))
                return false;
        }
        // "With a depth of 0, only the presence and absence of fields is checked."
        // "With a depth of 1 or more, the field types are checked."
        if (depth < 1) {
            return true;
        }
        // check oneof group
        for (const name of data.oneofs) {
            const group = message[name];
            if (!(0,_oneof__WEBPACK_IMPORTED_MODULE_0__.isOneofGroup)(group))
                return false;
            if (group.oneofKind === undefined)
                continue;
            const field = this.fields.find(f => f.localName === group.oneofKind);
            if (!field)
                return false; // we found no field, but have a kind, something is wrong
            if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
                return false;
        }
        // check types
        for (const field of this.fields) {
            if (field.oneof !== undefined)
                continue;
            if (!this.field(message[field.localName], field, allowExcessProperties, depth))
                return false;
        }
        return true;
    }
    field(arg, field, allowExcessProperties, depth) {
        let repeated = field.repeat;
        switch (field.kind) {
            case "scalar":
                if (arg === undefined)
                    return field.opt;
                if (repeated)
                    return this.scalars(arg, field.T, depth, field.L);
                return this.scalar(arg, field.T, field.L);
            case "enum":
                if (arg === undefined)
                    return field.opt;
                if (repeated)
                    return this.scalars(arg, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32, depth);
                return this.scalar(arg, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32);
            case "message":
                if (arg === undefined)
                    return true;
                if (repeated)
                    return this.messages(arg, field.T(), allowExcessProperties, depth);
                return this.message(arg, field.T(), allowExcessProperties, depth);
            case "map":
                if (typeof arg != 'object' || arg === null)
                    return false;
                if (depth < 2)
                    return true;
                if (!this.mapKeys(arg, field.K, depth))
                    return false;
                switch (field.V.kind) {
                    case "scalar":
                        return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
                    case "enum":
                        return this.scalars(Object.values(arg), _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32, depth);
                    case "message":
                        return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
                }
                break;
        }
        return true;
    }
    message(arg, type, allowExcessProperties, depth) {
        if (allowExcessProperties) {
            return type.isAssignable(arg, depth);
        }
        return type.is(arg, depth);
    }
    messages(arg, type, allowExcessProperties, depth) {
        if (!Array.isArray(arg))
            return false;
        if (depth < 2)
            return true;
        if (allowExcessProperties) {
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!type.isAssignable(arg[i], depth - 1))
                    return false;
        }
        else {
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!type.is(arg[i], depth - 1))
                    return false;
        }
        return true;
    }
    scalar(arg, type, longType) {
        let argType = typeof arg;
        switch (type) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT64:
                switch (longType) {
                    case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.BIGINT:
                        return argType == "bigint";
                    case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.NUMBER:
                        return argType == "number" && !isNaN(arg);
                    default:
                        return argType == "string";
                }
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                return argType == 'boolean';
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING:
                return argType == 'string';
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES:
                return arg instanceof Uint8Array;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.DOUBLE:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT:
                return argType == 'number' && !isNaN(arg);
            default:
                // case ScalarType.UINT32:
                // case ScalarType.FIXED32:
                // case ScalarType.INT32:
                // case ScalarType.SINT32:
                // case ScalarType.SFIXED32:
                return argType == 'number' && Number.isInteger(arg);
        }
    }
    scalars(arg, type, depth, longType) {
        if (!Array.isArray(arg))
            return false;
        if (depth < 2)
            return true;
        if (Array.isArray(arg))
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!this.scalar(arg[i], type, longType))
                    return false;
        return true;
    }
    mapKeys(map, type, depth) {
        let keys = Object.keys(map);
        switch (type) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32:
                return this.scalars(keys.slice(0, depth).map(k => parseInt(k)), type, depth);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                return this.scalars(keys.slice(0, depth).map(k => k == 'true' ? true : k == 'false' ? false : k), type, depth);
            default:
                return this.scalars(keys, type, depth, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.STRING);
        }
    }
}


/***/ }),

/***/ "../../../node_modules/sdp/sdp.js":
/*!****************************************!*\
  !*** ../../../node_modules/sdp/sdp.js ***!
  \****************************************/
/***/ ((module) => {

/* eslint-env node */


// SDP helpers.
const SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substring(2, 12);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(line => line.trim());
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  const parts = blob.split('\nm=');
  return parts.map((part, index) => (index > 0 ?
    'm=' + part : part).trim() + '\r\n');
};

// Returns the session description.
SDPUtils.getDescription = function(blob) {
  const sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// Returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  const sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
// Input can be prefixed with a=.
SDPUtils.parseCandidate = function(line) {
  let parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  const candidate = {
    foundation: parts[0],
    component: {1: 'rtp', 2: 'rtcp'}[parts[1]] || parts[1],
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    address: parts[4], // address is an alias for ip.
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7],
  };

  for (let i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compatibility.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag. Don't overwrite.
        if (candidate[parts[i]] === undefined) {
          candidate[parts[i]] = parts[i + 1];
        }
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
// This does not include the a= prefix!
SDPUtils.writeCandidate = function(candidate) {
  const sdp = [];
  sdp.push(candidate.foundation);

  const component = candidate.component;
  if (component === 'rtp') {
    sdp.push(1);
  } else if (component === 'rtcp') {
    sdp.push(2);
  } else {
    sdp.push(component);
  }
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.address || candidate.ip);
  sdp.push(candidate.port);

  const type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress);
    sdp.push('rport');
    sdp.push(candidate.relatedPort);
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// Sample input:
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substring(14).split(' ');
};

// Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  let parts = line.substring(9).split(' ');
  const parsed = {
    payloadType: parseInt(parts.shift(), 10), // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  // legacy alias, got renamed back to channels in ORTC.
  parsed.numChannels = parsed.channels;
  return parsed;
};

// Generates a rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  const channels = codec.channels || codec.numChannels || 1;
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (channels !== 1 ? '/' + channels : '') + '\r\n';
};

// Parses a extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  const parts = line.substring(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1],
    attributes: parts.slice(2).join(' '),
  };
};

// Generates an extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
        ? '/' + headerExtension.direction
        : '') +
      ' ' + headerExtension.uri +
      (headerExtension.attributes ? ' ' + headerExtension.attributes : '') +
      '\r\n';
};

// Parses a fmtp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  const parsed = {};
  let kv;
  const parts = line.substring(line.indexOf(' ') + 1).split(';');
  for (let j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  let line = '';
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    const params = [];
    Object.keys(codec.parameters).forEach(param => {
      if (codec.parameters[param] !== undefined) {
        params.push(param + '=' + codec.parameters[param]);
      } else {
        params.push(param);
      }
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  const parts = line.substring(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' '),
  };
};

// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  let lines = '';
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(fb => {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses a RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  const sp = line.indexOf(' ');
  const parts = {
    ssrc: parseInt(line.substring(7, sp), 10),
  };
  const colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substring(sp + 1, colon);
    parts.value = line.substring(colon + 1);
  } else {
    parts.attribute = line.substring(sp + 1);
  }
  return parts;
};

// Parse a ssrc-group line (see RFC 5576). Sample input:
// a=ssrc-group:semantics 12 34
SDPUtils.parseSsrcGroup = function(line) {
  const parts = line.substring(13).split(' ');
  return {
    semantics: parts.shift(),
    ssrcs: parts.map(ssrc => parseInt(ssrc, 10)),
  };
};

// Extracts the MID (RFC 5888) from a media section.
// Returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substring(6);
  }
};

// Parses a fingerprint line for DTLS-SRTP.
SDPUtils.parseFingerprint = function(line) {
  const parts = line.substring(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1].toUpperCase(), // the definition is upper-case in RFC 4572.
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint),
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  let sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(fp => {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};

// Parses a=crypto lines into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members
SDPUtils.parseCryptoLine = function(line) {
  const parts = line.substring(9).split(' ');
  return {
    tag: parseInt(parts[0], 10),
    cryptoSuite: parts[1],
    keyParams: parts[2],
    sessionParams: parts.slice(3),
  };
};

SDPUtils.writeCryptoLine = function(parameters) {
  return 'a=crypto:' + parameters.tag + ' ' +
    parameters.cryptoSuite + ' ' +
    (typeof parameters.keyParams === 'object'
      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)
      : parameters.keyParams) +
    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +
    '\r\n';
};

// Parses the crypto key parameters into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*
SDPUtils.parseCryptoKeyParams = function(keyParams) {
  if (keyParams.indexOf('inline:') !== 0) {
    return null;
  }
  const parts = keyParams.substring(7).split('|');
  return {
    keyMethod: 'inline',
    keySalt: parts[0],
    lifeTime: parts[1],
    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,
    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,
  };
};

SDPUtils.writeCryptoKeyParams = function(keyParams) {
  return keyParams.keyMethod + ':'
    + keyParams.keySalt +
    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +
    (keyParams.mkiValue && keyParams.mkiLength
      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength
      : '');
};

// Extracts all SDES parameters.
SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {
  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=crypto:');
  return lines.map(SDPUtils.parseCryptoLine);
};

// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=ice-ufrag:')[0];
  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=ice-pwd:')[0];
  if (!(ufrag && pwd)) {
    return null;
  }
  return {
    usernameFragment: ufrag.substring(12),
    password: pwd.substring(10),
  };
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
  if (params.iceLite) {
    sdp += 'a=ice-lite\r\n';
  }
  return sdp;
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  const description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: [],
  };
  const lines = SDPUtils.splitLines(mediaSection);
  const mline = lines[0].split(' ');
  description.profile = mline[2];
  for (let i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    const pt = mline[i];
    const rtpmapline = SDPUtils.matchPrefix(
      mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      const codec = SDPUtils.parseRtpMap(rtpmapline);
      const fmtps = SDPUtils.matchPrefix(
        mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
        mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:* ')
    .map(SDPUtils.parseRtcpFb);
  description.codecs.forEach(codec => {
    wildcardRtcpFb.forEach(fb=> {
      const duplicate = codec.rtcpFeedback.find(existingFeedback => {
        return existingFeedback.type === fb.type &&
          existingFeedback.parameter === fb.parameter;
      });
      if (!duplicate) {
        codec.rtcpFeedback.push(fb);
      }
    });
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  let sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' ' + (caps.profile || 'UDP/TLS/RTP/SAVPF') + ' ';
  sdp += caps.codecs.map(codec => {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(codec => {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  let maxptime = 0;
  caps.codecs.forEach(codec => {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }

  if (caps.headerExtensions) {
    caps.headerExtensions.forEach(extension => {
      sdp += SDPUtils.writeExtmap(extension);
    });
  }
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  const encodingParameters = [];
  const description = SDPUtils.parseRtpParameters(mediaSection);
  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(parts => parts.attribute === 'cname');
  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  let secondarySsrc;

  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
    .map(line => {
      const parts = line.substring(17).split(' ');
      return parts.map(part => parseInt(part, 10));
    });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(codec => {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      let encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10),
      };
      if (primarySsrc && secondarySsrc) {
        encParam.rtx = {ssrc: secondarySsrc};
      }
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: primarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red',
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc,
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substring(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(params => {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  const rtcpParameters = {};

  // Gets the first SSRC. Note that with RTX there might be multiple
  // SSRCs.
  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(obj => obj.attribute === 'cname')[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrbute.
  // Note that Edge does not support unmuxed RTCP.
  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

SDPUtils.writeRtcpParameters = function(rtcpParameters) {
  let sdp = '';
  if (rtcpParameters.reducedSize) {
    sdp += 'a=rtcp-rsize\r\n';
  }
  if (rtcpParameters.mux) {
    sdp += 'a=rtcp-mux\r\n';
  }
  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {
    sdp += 'a=ssrc:' + rtcpParameters.ssrc +
      ' cname:' + rtcpParameters.cname + '\r\n';
  }
  return sdp;
};


// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  let parts;
  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substring(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(msidParts => msidParts.attribute === 'msid');
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// SCTP
// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
// to draft-ietf-mmusic-sctp-sdp-05
SDPUtils.parseSctpDescription = function(mediaSection) {
  const mline = SDPUtils.parseMLine(mediaSection);
  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
  let maxMessageSize;
  if (maxSizeLine.length > 0) {
    maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);
  }
  if (isNaN(maxMessageSize)) {
    maxMessageSize = 65536;
  }
  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
  if (sctpPort.length > 0) {
    return {
      port: parseInt(sctpPort[0].substring(12), 10),
      protocol: mline.fmt,
      maxMessageSize,
    };
  }
  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');
  if (sctpMapLines.length > 0) {
    const parts = sctpMapLines[0]
      .substring(10)
      .split(' ');
    return {
      port: parseInt(parts[0], 10),
      protocol: parts[1],
      maxMessageSize,
    };
  }
};

// SCTP
// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
// support by now receiving in this format, unless we originally parsed
// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
// protocol of DTLS/SCTP -- without UDP/ or TCP/)
SDPUtils.writeSctpDescription = function(media, sctp) {
  let output = [];
  if (media.protocol !== 'DTLS/SCTP') {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctp-port:' + sctp.port + '\r\n',
    ];
  } else {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n',
    ];
  }
  if (sctp.maxMessageSize !== undefined) {
    output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
  }
  return output.join('');
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 22);
};

// Write boiler plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
// sessUser is optional and defaults to 'thisisadapterortc'
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
  let sessionId;
  const version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  const user = sessUser || 'thisisadapterortc';
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=' + user + ' ' + sessionId + ' ' + version +
        ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  const lines = SDPUtils.splitLines(mediaSection);
  for (let i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substring(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  const lines = SDPUtils.splitLines(mediaSection);
  const mline = lines[0].split(' ');
  return mline[0].substring(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  const lines = SDPUtils.splitLines(mediaSection);
  const parts = lines[0].substring(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' '),
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  const parts = line.substring(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5],
  };
};

// a very naive interpretation of a valid SDP.
SDPUtils.isValidSDP = function(blob) {
  if (typeof blob !== 'string' || blob.length === 0) {
    return false;
  }
  const lines = SDPUtils.splitLines(blob);
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
      return false;
    }
    // TODO: check the modifier a bit more.
  }
  return true;
};

// Expose public methods.
if (true) {
  module.exports = SDPUtils;
}


/***/ }),

/***/ "../../library/dist/esm/AFK/AFKController.js":
/*!***************************************************!*\
  !*** ../../library/dist/esm/AFK/AFKController.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AFKController: () => (/* binding */ AFKController)
/* harmony export */ });
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Util/EventEmitter */ "../../library/dist/esm/Util/EventEmitter.js");
// Copyright Epic Games, Inc. All Rights Reserved.



class AFKController {
    constructor(config, pixelStreaming, onDismissAfk) {
        // time out logic details
        this.active = false;
        this.countdownActive = false;
        this.warnTimer = undefined;
        this.countDown = 0;
        this.countDownTimer = undefined;
        this.config = config;
        this.pixelStreaming = pixelStreaming;
        this.onDismissAfk = onDismissAfk;
        this.onAFKTimedOutCallback = () => {
            console.log('AFK timed out, did you want to override this callback?');
        };
    }
    /**
     * The methods that occur when an afk event listener is clicked
     */
    onAfkClick() {
        clearInterval(this.countDownTimer);
        if (this.active || this.countdownActive) {
            this.startAfkWarningTimer();
            this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkWarningDeactivateEvent());
        }
    }
    /**
     * Start the warning timer if a timeout is set greater that 0 seconds
     */
    startAfkWarningTimer() {
        if (this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.NumericParameters.AFKTimeoutSecs) > 0 &&
            this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.AFKDetection)) {
            this.active = true;
        }
        else {
            this.active = false;
        }
        this.resetAfkWarningTimer();
    }
    /**
     * Stop the afk warning timer
     */
    stopAfkWarningTimer() {
        this.active = false;
        this.countdownActive = false;
        clearTimeout(this.warnTimer);
        clearInterval(this.countDownTimer);
    }
    /**
     * Pause the timer which when elapsed will warn the user they are inactive.
     */
    pauseAfkWarningTimer() {
        this.active = false;
    }
    /**
     * If the user interacts then reset the warning timer.
     */
    resetAfkWarningTimer() {
        if (this.active && this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.AFKDetection)) {
            clearTimeout(this.warnTimer);
            this.warnTimer = setTimeout(() => this.activateAfkEvent(), this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.NumericParameters.AFKTimeoutSecs) * 1000);
        }
    }
    /**
     * Show the AFK overlay and begin the countDown
     */
    activateAfkEvent() {
        // Pause the timer while the user is looking at the inactivity warning overlay
        this.pauseAfkWarningTimer();
        // instantiate a new overlay
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkWarningActivateEvent({
            countDown: this.countDown,
            dismissAfk: this.onDismissAfk
        }));
        // update our countDown timer and overlay contents
        this.countDown = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.NumericParameters.AFKCountdownSecs);
        this.countdownActive = true;
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkWarningUpdateEvent({ countDown: this.countDown }));
        // if we are in locked mouse exit pointerlock
        if (!this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.HoveringMouseMode)) {
            // minor hack to alleviate ios not supporting pointerlock
            if (document.exitPointerLock) {
                document.exitPointerLock();
            }
        }
        // reset our countDown interval accordingly
        this.countDownTimer = setInterval(() => {
            this.countDown--;
            if (this.countDown == 0) {
                // The user failed to click so hide the overlay and disconnect them.
                this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkTimedOutEvent());
                this.onAFKTimedOutCallback();
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_2__.Logger.Info('You have been disconnected due to inactivity');
                // switch off the afk feature as stream has closed
                this.stopAfkWarningTimer();
            }
            else {
                this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkWarningUpdateEvent({ countDown: this.countDown }));
            }
        }, 1000);
    }
}
//# sourceMappingURL=AFKController.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/Config.js":
/*!***********************************************!*\
  !*** ../../library/dist/esm/Config/Config.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Config: () => (/* binding */ Config),
/* harmony export */   ControlSchemeType: () => (/* binding */ ControlSchemeType),
/* harmony export */   Flags: () => (/* binding */ Flags),
/* harmony export */   NumericParameters: () => (/* binding */ NumericParameters),
/* harmony export */   OptionParameters: () => (/* binding */ OptionParameters),
/* harmony export */   TextParameters: () => (/* binding */ TextParameters),
/* harmony export */   isFlagId: () => (/* binding */ isFlagId),
/* harmony export */   isNumericId: () => (/* binding */ isNumericId),
/* harmony export */   isOptionId: () => (/* binding */ isOptionId),
/* harmony export */   isTextId: () => (/* binding */ isTextId)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _SettingFlag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SettingFlag */ "../../library/dist/esm/Config/SettingFlag.js");
/* harmony import */ var _SettingNumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SettingNumber */ "../../library/dist/esm/Config/SettingNumber.js");
/* harmony import */ var _SettingText__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingText */ "../../library/dist/esm/Config/SettingText.js");
/* harmony import */ var _SettingOption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SettingOption */ "../../library/dist/esm/Config/SettingOption.js");
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Util/EventEmitter */ "../../library/dist/esm/Util/EventEmitter.js");
/* harmony import */ var _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util/BrowserUtils */ "../../library/dist/esm/Util/BrowserUtils.js");
// Copyright Epic Games, Inc. All Rights Reserved.







/**
 * A collection of flags that can be toggled and are core to all Pixel Streaming experiences.
 * These are used in the `Config.Flags` map.
 */
class Flags {
}
Flags.AutoConnect = 'AutoConnect';
Flags.AutoPlayVideo = 'AutoPlayVideo';
Flags.AFKDetection = 'TimeoutIfIdle';
Flags.HoveringMouseMode = 'HoveringMouse';
Flags.ForceMonoAudio = 'ForceMonoAudio';
Flags.ForceTURN = 'ForceTURN';
Flags.FakeMouseWithTouches = 'FakeMouseWithTouches';
Flags.IsQualityController = 'ControlsQuality';
Flags.MatchViewportResolution = 'MatchViewportRes';
Flags.StartVideoMuted = 'StartVideoMuted';
Flags.SuppressBrowserKeys = 'SuppressBrowserKeys';
Flags.UseMic = 'UseMic';
Flags.UseModalForTextInput = 'UseModalForTextInput';
Flags.UseCamera = 'UseCamera';
Flags.KeyboardInput = 'KeyboardInput';
Flags.MouseInput = 'MouseInput';
Flags.TouchInput = 'TouchInput';
Flags.GamepadInput = 'GamepadInput';
Flags.XRControllerInput = 'XRControllerInput';
Flags.WaitForStreamer = 'WaitForStreamer';
Flags.HideUI = 'HideUI';
Flags.EnableCaptureTimeExt = 'EnableCaptureTimeExt';
Flags.BrowserSendOffer = 'BrowserSendOffer';
Flags.LatencyCSV = 'LatencyCSV';
const isFlagId = (id) => Object.getOwnPropertyNames(Flags).some((name) => Flags[name] === id);
/**
 * A collection of numeric parameters that are core to all Pixel Streaming experiences.
 *
 */
class NumericParameters {
}
NumericParameters.AFKTimeoutSecs = 'AFKTimeout';
NumericParameters.AFKCountdownSecs = 'AFKCountdown';
NumericParameters.MinQP = 'MinQP';
NumericParameters.MaxQP = 'MaxQP';
NumericParameters.MinQuality = 'MinQuality';
NumericParameters.MaxQuality = 'MaxQuality';
NumericParameters.CompatQualityMin = 'CompatQualityMin';
NumericParameters.CompatQualityMax = 'CompatQualityMax';
NumericParameters.WebRTCFPS = 'WebRTCFPS';
NumericParameters.WebRTCMinBitrate = 'WebRTCMinBitrate';
NumericParameters.WebRTCMaxBitrate = 'WebRTCMaxBitrate';
NumericParameters.MaxReconnectAttempts = 'MaxReconnectAttempts';
NumericParameters.StreamerAutoJoinInterval = 'StreamerAutoJoinInterval';
NumericParameters.KeepaliveDelay = 'KeepaliveDelay';
const isNumericId = (id) => Object.getOwnPropertyNames(NumericParameters).some((name) => NumericParameters[name] === id);
/**
 * A collection of textual parameters that are core to all Pixel Streaming experiences.
 *
 */
class TextParameters {
}
TextParameters.SignallingServerUrl = 'ss';
const isTextId = (id) => Object.getOwnPropertyNames(TextParameters).some((name) => TextParameters[name] === id);
/**
 * A collection of enum based parameters that are core to all Pixel Streaming experiences.
 *
 */
class OptionParameters {
}
OptionParameters.PreferredCodec = 'PreferredCodec';
OptionParameters.StreamerId = 'StreamerId';
OptionParameters.PreferredQuality = 'PreferredQuality';
const isOptionId = (id) => Object.getOwnPropertyNames(OptionParameters).some((name) => OptionParameters[name] === id);
class Config {
    // ------------ Settings -----------------
    constructor(config = {}) {
        /* A map of flags that can be toggled - options that can be set in the application - e.g. Use Mic? */
        this.flags = new Map();
        /* A map of numerical settings - options that can be in the application - e.g. MinBitrate */
        this.numericParameters = new Map();
        /* A map of text settings - e.g. signalling server url */
        this.textParameters = new Map();
        /* A map of enum based settings - e.g. preferred codec */
        this.optionParameters = new Map();
        const { initialSettings, useUrlParams, webSocketProtocols } = config;
        this._useUrlParams = !!useUrlParams;
        this._webSocketProtocols = webSocketProtocols;
        this.populateDefaultSettings(this._useUrlParams, initialSettings);
    }
    /**
     * True if reading configuration initial values from URL parameters, and
     * persisting changes in URL when changed.
     */
    get useUrlParams() {
        return this._useUrlParams;
    }
    /**
     * Gets a protocol or list of protocols to pass to the websocket if set.
     */
    get webSocketProtocols() {
        return this._webSocketProtocols;
    }
    /**
     * Populate the default settings for a Pixel Streaming application
     */
    populateDefaultSettings(useUrlParams, settings) {
        /**
         * Text Parameters
         */
        this.textParameters.set(TextParameters.SignallingServerUrl, new _SettingText__WEBPACK_IMPORTED_MODULE_0__.SettingText(TextParameters.SignallingServerUrl, 'Signalling url', 'Url of the signalling server', settings && Object.prototype.hasOwnProperty.call(settings, TextParameters.SignallingServerUrl)
            ? settings[TextParameters.SignallingServerUrl]
            : (location.protocol === 'https:' ? 'wss://' : 'ws://') +
                window.location.hostname +
                // for readability, we omit the port if it's 80
                (window.location.port === '80' || window.location.port === ''
                    ? ''
                    : `:${window.location.port}`), useUrlParams));
        this.optionParameters.set(OptionParameters.StreamerId, new _SettingOption__WEBPACK_IMPORTED_MODULE_1__.SettingOption(OptionParameters.StreamerId, 'Streamer ID', 'The ID of the streamer to stream.', settings && Object.prototype.hasOwnProperty.call(settings, OptionParameters.StreamerId)
            ? settings[OptionParameters.StreamerId]
            : '', settings && Object.prototype.hasOwnProperty.call(settings, OptionParameters.StreamerId)
            ? [settings[OptionParameters.StreamerId]]
            : undefined, useUrlParams));
        const getDefaultVideoCodec = function () {
            const videoCodecs = _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_2__.BrowserUtils.getSupportedVideoCodecs();
            // If only one option, then select that.
            if (videoCodecs.length == 1) {
                return videoCodecs[0];
            }
            else if (videoCodecs.length > 0) {
                const defaultCodec = videoCodecs[0];
                for (const codec of videoCodecs) {
                    if (codec.startsWith('H264')) {
                        return codec;
                    }
                }
                return defaultCodec;
            }
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error('Could not find any reasonable video codec to assign as a default.');
            return '';
        };
        const matchSpecifiedCodecToClosestSupported = function (specifiedCodec) {
            const browserSupportedCodecs = _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_2__.BrowserUtils.getSupportedVideoCodecs();
            // Codec supplied in url param is an exact match for the browser codec.
            // (e.g. H264 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f)
            if (browserSupportedCodecs.includes(specifiedCodec)) {
                return specifiedCodec;
            }
            // Try to match the start of whatever is passed into the url parameter with what the browser supports
            for (const browserCodec of browserSupportedCodecs) {
                if (browserCodec.startsWith(specifiedCodec)) {
                    return browserCodec;
                }
            }
            // If we weren't able to match, just return the codec as from the URL as-is.
            return specifiedCodec;
        };
        /**
         * Enum Parameters
         */
        this.optionParameters.set(OptionParameters.PreferredCodec, new _SettingOption__WEBPACK_IMPORTED_MODULE_1__.SettingOption(OptionParameters.PreferredCodec, 'Preferred Codec', 'The preferred codec to be used during codec negotiation', settings && Object.prototype.hasOwnProperty.call(settings, OptionParameters.PreferredCodec)
            ? matchSpecifiedCodecToClosestSupported(settings[OptionParameters.PreferredCodec])
            : getDefaultVideoCodec(), _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_2__.BrowserUtils.getSupportedVideoCodecs(), useUrlParams, matchSpecifiedCodecToClosestSupported));
        this.optionParameters.set(OptionParameters.PreferredQuality, new _SettingOption__WEBPACK_IMPORTED_MODULE_1__.SettingOption(OptionParameters.PreferredQuality, 'Preferred Quality', 'The preferred quality of the stream (only applicable when using the SFU)', settings && Object.prototype.hasOwnProperty.call(settings, OptionParameters.PreferredQuality)
            ? settings[OptionParameters.PreferredQuality]
            : 'Default', ['Default'], useUrlParams));
        /**
         * Boolean parameters
         */
        this.flags.set(Flags.AutoConnect, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.AutoConnect, 'Auto connect to stream', 'Whether we should attempt to auto connect to the signalling server or show a click to start prompt.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.AutoConnect)
            ? settings[Flags.AutoConnect]
            : false, useUrlParams));
        this.flags.set(Flags.AutoPlayVideo, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.AutoPlayVideo, 'Auto play video', 'When video is ready automatically start playing it as opposed to showing a play button.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.AutoPlayVideo)
            ? settings[Flags.AutoPlayVideo]
            : true, useUrlParams));
        this.flags.set(Flags.UseMic, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.UseMic, 'Use microphone', 'Make browser request microphone access and open an input audio track.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.UseMic)
            ? settings[Flags.UseMic]
            : false, useUrlParams));
        this.flags.set(Flags.UseModalForTextInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.UseModalForTextInput, 'Use modal for text input', 'When entering input into a streamed UE text widget, use an input modal.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.UseModalForTextInput)
            ? settings[Flags.UseModalForTextInput]
            : true, useUrlParams));
        this.flags.set(Flags.UseCamera, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.UseCamera, 'Use webcam', 'Make browser request webcam access and open a input video track.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.UseCamera)
            ? settings[Flags.UseCamera]
            : false, useUrlParams));
        this.flags.set(Flags.StartVideoMuted, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.StartVideoMuted, 'Start video muted', 'Video will start muted if true.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.StartVideoMuted)
            ? settings[Flags.StartVideoMuted]
            : false, useUrlParams));
        this.flags.set(Flags.SuppressBrowserKeys, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.SuppressBrowserKeys, 'Suppress browser keys', 'Suppress certain browser keys that we use in UE, for example F5 to show shader complexity instead of refresh the page.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.SuppressBrowserKeys)
            ? settings[Flags.SuppressBrowserKeys]
            : true, useUrlParams));
        this.flags.set(Flags.IsQualityController, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.IsQualityController, 'Is quality controller?', 'True if this peer controls stream quality', settings && Object.prototype.hasOwnProperty.call(settings, Flags.IsQualityController)
            ? settings[Flags.IsQualityController]
            : true, useUrlParams));
        this.flags.set(Flags.ForceMonoAudio, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.ForceMonoAudio, 'Force mono audio', 'Force browser to request mono audio in the SDP', settings && Object.prototype.hasOwnProperty.call(settings, Flags.ForceMonoAudio)
            ? settings[Flags.ForceMonoAudio]
            : false, useUrlParams));
        this.flags.set(Flags.ForceTURN, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.ForceTURN, 'Force TURN', 'Only generate TURN/Relayed ICE candidates.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.ForceTURN)
            ? settings[Flags.ForceTURN]
            : false, useUrlParams));
        this.flags.set(Flags.AFKDetection, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.AFKDetection, 'AFK if idle', 'Timeout the experience if user is AFK for a period.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.AFKDetection)
            ? settings[Flags.AFKDetection]
            : false, useUrlParams));
        this.flags.set(Flags.MatchViewportResolution, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.MatchViewportResolution, 'Match viewport resolution', 'Pixel Streaming will be instructed to dynamically resize the video stream to match the size of the video element.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.MatchViewportResolution)
            ? settings[Flags.MatchViewportResolution]
            : false, useUrlParams));
        this.flags.set(Flags.HoveringMouseMode, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.HoveringMouseMode, 'Control Scheme: Locked Mouse', 'Either locked mouse, where the pointer is consumed by the video and locked to it, or hovering mouse, where the mouse is not consumed.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.HoveringMouseMode)
            ? settings[Flags.HoveringMouseMode]
            : false, useUrlParams, (isHoveringMouse, setting) => {
            setting.label = `Control Scheme: ${isHoveringMouse ? 'Hovering' : 'Locked'} Mouse`;
        }));
        this.flags.set(Flags.FakeMouseWithTouches, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.FakeMouseWithTouches, 'Fake mouse with touches', 'A single finger touch is converted into a mouse event. This allows a non-touch application to be controlled partially via a touch device.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.FakeMouseWithTouches)
            ? settings[Flags.FakeMouseWithTouches]
            : false, useUrlParams));
        this.flags.set(Flags.KeyboardInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.KeyboardInput, 'Keyboard input', 'If enabled, send keyboard events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.KeyboardInput)
            ? settings[Flags.KeyboardInput]
            : true, useUrlParams));
        this.flags.set(Flags.MouseInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.MouseInput, 'Mouse input', 'If enabled, send mouse events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.MouseInput)
            ? settings[Flags.MouseInput]
            : true, useUrlParams));
        this.flags.set(Flags.TouchInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.TouchInput, 'Touch input', 'If enabled, send touch events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.TouchInput)
            ? settings[Flags.TouchInput]
            : true, useUrlParams));
        this.flags.set(Flags.GamepadInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.GamepadInput, 'Gamepad input', 'If enabled, send gamepad events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.GamepadInput)
            ? settings[Flags.GamepadInput]
            : true, useUrlParams));
        this.flags.set(Flags.XRControllerInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.XRControllerInput, 'XR controller input', 'If enabled, send XR controller events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.XRControllerInput)
            ? settings[Flags.XRControllerInput]
            : true, useUrlParams));
        this.flags.set(Flags.WaitForStreamer, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.WaitForStreamer, 'Wait for streamer', 'Will continue trying to connect to the first streamer available.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.WaitForStreamer)
            ? settings[Flags.WaitForStreamer]
            : true, useUrlParams));
        this.flags.set(Flags.HideUI, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.HideUI, 'Hide the UI overlay', 'Will hide all UI overlay details', settings && Object.prototype.hasOwnProperty.call(settings, Flags.HideUI)
            ? settings[Flags.HideUI]
            : false, useUrlParams));
        this.flags.set(Flags.EnableCaptureTimeExt, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.EnableCaptureTimeExt, 'Enable abs-capture-time', 'Enables the abs-capture-time RTP header extension', settings && Object.prototype.hasOwnProperty.call(settings, Flags.EnableCaptureTimeExt)
            ? settings[Flags.EnableCaptureTimeExt]
            : false, useUrlParams));
        this.flags.set(Flags.BrowserSendOffer, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.BrowserSendOffer, 'Browser send offer (4.27 ONLY)', 'Browser will initiate the WebRTC handshake by sending the offer to the streamer (4.27 ONLY)', settings && Object.prototype.hasOwnProperty.call(settings, Flags.BrowserSendOffer)
            ? settings[Flags.BrowserSendOffer]
            : false, useUrlParams));
        this.flags.set(Flags.LatencyCSV, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.LatencyCSV, 'Export Latency CSV', 'Shows a button in the stats panel that allows to run a latency test and export the results to a CSV file.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.LatencyCSV)
            ? settings[Flags.LatencyCSV]
            : false, useUrlParams));
        /**
         * Numeric parameters
         */
        this.numericParameters.set(NumericParameters.AFKTimeoutSecs, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.AFKTimeoutSecs, 'AFK timeout', 'The time (in seconds) it takes for the application to time out if AFK timeout is enabled.', 0 /*min*/, null /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.AFKTimeoutSecs)
            ? settings[NumericParameters.AFKTimeoutSecs]
            : 120 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.AFKCountdownSecs, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.AFKCountdownSecs, 'AFK countdown', 'The time (in seconds) for a user to respond before the stream is ended after an AFK timeout.', 10 /*min*/, null /*max*/, 10 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MaxReconnectAttempts, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MaxReconnectAttempts, 'Max Reconnects', 'Maximum number of reconnects the application will attempt when a streamer disconnects.', 0 /*min*/, 999 /*max*/, settings &&
            Object.prototype.hasOwnProperty.call(settings, NumericParameters.MaxReconnectAttempts)
            ? settings[NumericParameters.MaxReconnectAttempts]
            : 3 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MinQP, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MinQP, 'Min QP', 'The lower bound for the quantization parameter (QP) of the encoder. 0 = Best quality, 51 = worst quality.', 0 /*min*/, 51 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.MinQP)
            ? settings[NumericParameters.MinQP]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MaxQP, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MaxQP, 'Max QP', 'The upper bound for the quantization parameter (QP) of the encoder. 0 = Best quality, 51 = worst quality.', 0 /*min*/, 51 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.MaxQP)
            ? settings[NumericParameters.MaxQP]
            : 51 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MinQuality, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MinQuality, 'Min Quality', 'The lower bound for the quality factor of the encoder. 0 = Worst quality, 100 = Best quality.', 0 /*min*/, 100 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.MinQuality)
            ? settings[NumericParameters.MinQuality]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MaxQuality, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MaxQuality, 'Max Quality', 'The upper bound for the quality factor of the encoder. 0 = Worst quality, 100 = Best quality.', 0 /*min*/, 100 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.MaxQuality)
            ? settings[NumericParameters.MaxQuality]
            : 100 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.CompatQualityMin, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.CompatQualityMin, 'Min Quality', 'The lower bound for encoding quality. 0 = Worst, 100 = Best.', 0 /*min*/, 100 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.CompatQualityMin)
            ? settings[NumericParameters.CompatQualityMin]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.CompatQualityMax, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.CompatQualityMax, 'Max Quality', 'The upper bound for encoding quality. 0 = Worst, 100 = Best.', 0 /*min*/, 100 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.CompatQualityMax)
            ? settings[NumericParameters.CompatQualityMax]
            : 100 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.WebRTCFPS, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.WebRTCFPS, 'Max FPS', 'The maximum FPS that WebRTC will try to transmit frames at.', 1 /*min*/, 999 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.WebRTCFPS)
            ? settings[NumericParameters.WebRTCFPS]
            : 60 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.WebRTCMinBitrate, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.WebRTCMinBitrate, 'Min Bitrate (kbps)', 'The minimum bitrate that WebRTC should use.', 0 /*min*/, 500000 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.WebRTCMinBitrate)
            ? settings[NumericParameters.WebRTCMinBitrate]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.WebRTCMaxBitrate, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.WebRTCMaxBitrate, 'Max Bitrate (kbps)', 'The maximum bitrate that WebRTC should use.', 0 /*min*/, 500000 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.WebRTCMaxBitrate)
            ? settings[NumericParameters.WebRTCMaxBitrate]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.StreamerAutoJoinInterval, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.StreamerAutoJoinInterval, 'Streamer Auto Join Interval (ms)', 'Delay between retries when waiting for an available streamer.', 500 /*min*/, 900000 /*max*/, settings &&
            Object.prototype.hasOwnProperty.call(settings, NumericParameters.StreamerAutoJoinInterval)
            ? settings[NumericParameters.StreamerAutoJoinInterval]
            : 3000 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.KeepaliveDelay, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.KeepaliveDelay, 'Connection Keepalive delay', 'Delay between keepalive pings to the signalling server.', 0 /*min*/, 900000 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.KeepaliveDelay)
            ? settings[NumericParameters.KeepaliveDelay]
            : 30000 /*value*/, useUrlParams));
    }
    /**
     * Add a callback to fire when the numeric setting is toggled.
     * @param id The id of the flag.
     * @param onChangedListener The callback to fire when the numeric value changes.
     */
    _addOnNumericSettingChangedListener(id, onChangedListener) {
        if (this.numericParameters.has(id)) {
            this.numericParameters.get(id).addOnChangedListener(onChangedListener);
        }
    }
    _addOnOptionSettingChangedListener(id, onChangedListener) {
        if (this.optionParameters.has(id)) {
            this.optionParameters.get(id).addOnChangedListener(onChangedListener);
        }
    }
    /**
     * @param id The id of the numeric setting we are interested in getting a value for.
     * @returns The numeric value stored in the parameter with the passed id.
     */
    getNumericSettingValue(id) {
        if (this.numericParameters.has(id)) {
            return this.numericParameters.get(id).number;
        }
        else {
            throw new Error(`There is no numeric setting with the id of ${id}`);
        }
    }
    /**
     * @param id The id of the text setting we are interested in getting a value for.
     * @returns The text value stored in the parameter with the passed id.
     */
    getTextSettingValue(id) {
        if (this.textParameters.has(id)) {
            return this.textParameters.get(id).value;
        }
        else {
            throw new Error(`There is no numeric setting with the id of ${id}`);
        }
    }
    /**
     * Set number in the setting.
     * @param id The id of the numeric setting we are interested in.
     * @param value The numeric value to set.
     */
    setNumericSetting(id, value) {
        if (this.numericParameters.has(id)) {
            this.numericParameters.get(id).number = value;
        }
        else {
            throw new Error(`There is no numeric setting with the id of ${id}`);
        }
    }
    /**
     * Add a callback to fire when the flag is toggled.
     * @param id The id of the flag.
     * @param onChangeListener The callback to fire when the value changes.
     */
    _addOnSettingChangedListener(id, onChangeListener) {
        if (this.flags.has(id)) {
            this.flags.get(id).onChange = onChangeListener;
        }
    }
    /**
     * Add a callback to fire when the text is changed.
     * @param id The id of the flag.
     * @param onChangeListener The callback to fire when the value changes.
     */
    _addOnTextSettingChangedListener(id, onChangeListener) {
        if (this.textParameters.has(id)) {
            this.textParameters.get(id).onChange = onChangeListener;
        }
    }
    /**
     * Get the option which has the given id.
     * @param id The id of the option.
     * @returns The SettingOption object matching id
     */
    getSettingOption(id) {
        return this.optionParameters.get(id);
    }
    /**
     * Get the value of the configuration flag which has the given id.
     * @param id The unique id for the flag.
     * @returns True if the flag is enabled.
     */
    isFlagEnabled(id) {
        return this.flags.get(id).flag;
    }
    /**
     * Set flag to be enabled/disabled.
     * @param id The id of the flag to toggle.
     * @param flagEnabled True if the flag should be enabled.
     */
    setFlagEnabled(id, flagEnabled) {
        if (!this.flags.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot toggle flag called ${id} - it does not exist in the Config.flags map.`);
        }
        else {
            this.flags.get(id).flag = flagEnabled;
        }
    }
    /**
     * Set the text setting.
     * @param id The id of the setting
     * @param settingValue The value to set in the setting.
     */
    setTextSetting(id, settingValue) {
        if (!this.textParameters.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot set text setting called ${id} - it does not exist in the Config.textParameters map.`);
        }
        else {
            this.textParameters.get(id).text = settingValue;
        }
    }
    /**
     * Set the option setting list of options.
     * @param id The id of the setting
     * @param settingOptions The values the setting could take
     */
    setOptionSettingOptions(id, settingOptions) {
        if (!this.optionParameters.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot set text setting called ${id} - it does not exist in the Config.optionParameters map.`);
        }
        else {
            this.optionParameters.get(id).options = settingOptions;
        }
    }
    /**
     * Set option enum settings selected option.
     * @param id The id of the setting
     * @param settingOptions The value to select out of all the options
     */
    setOptionSettingValue(id, settingValue) {
        if (!this.optionParameters.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot set text setting called ${id} - it does not exist in the Config.enumParameters map.`);
        }
        else {
            const optionSetting = this.optionParameters.get(id);
            const existingOptions = optionSetting.options;
            if (!existingOptions.includes(settingValue)) {
                existingOptions.push(settingValue);
                optionSetting.options = existingOptions;
            }
            optionSetting.selected = settingValue;
        }
    }
    /**
     * Set the label for the flag.
     * @param id The id of the flag.
     * @param label The new label to use for the flag.
     */
    setFlagLabel(id, label) {
        if (!this.flags.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot set label for flag called ${id} - it does not exist in the Config.flags map.`);
        }
        else {
            this.flags.get(id).label = label;
        }
    }
    /**
     * Set a subset of all settings in one function call.
     *
     * @param settings A (partial) list of settings to set
     */
    setSettings(settings) {
        for (const key of Object.keys(settings)) {
            if (isFlagId(key)) {
                this.setFlagEnabled(key, settings[key]);
            }
            else if (isNumericId(key)) {
                this.setNumericSetting(key, settings[key]);
            }
            else if (isTextId(key)) {
                this.setTextSetting(key, settings[key]);
            }
            else if (isOptionId(key)) {
                this.setOptionSettingValue(key, settings[key]);
            }
        }
    }
    /**
     * Get all settings
     * @returns All setting values as an object with setting ids as keys
     */
    getSettings() {
        const settings = {};
        for (const [key, value] of this.flags.entries()) {
            settings[key] = value.flag;
        }
        for (const [key, value] of this.numericParameters.entries()) {
            settings[key] = value.number;
        }
        for (const [key, value] of this.textParameters.entries()) {
            settings[key] = value.text;
        }
        for (const [key, value] of this.optionParameters.entries()) {
            settings[key] = value.selected;
        }
        return settings;
    }
    /**
     * Get all Flag settings as an array.
     * @returns All SettingFlag objects
     */
    getFlags() {
        return Array.from(this.flags.values());
    }
    /**
     * Get all Text settings as an array.
     * @returns All SettingText objects
     */
    getTextSettings() {
        return Array.from(this.textParameters.values());
    }
    /**
     * Get all Number settings as an array.
     * @returns All SettingNumber objects
     */
    getNumericSettings() {
        return Array.from(this.numericParameters.values());
    }
    /**
     * Get all Option settings as an array.
     * @returns All SettingOption objects
     */
    getOptionSettings() {
        return Array.from(this.optionParameters.values());
    }
    /**
     * Emit events when settings change.
     * @param eventEmitter
     */
    _registerOnChangeEvents(eventEmitter) {
        for (const key of this.flags.keys()) {
            const flag = this.flags.get(key);
            if (flag) {
                flag.onChangeEmit = (newValue) => eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__.SettingsChangedEvent({
                    id: flag.id,
                    type: 'flag',
                    value: newValue,
                    target: flag
                }));
            }
        }
        for (const key of this.numericParameters.keys()) {
            const number = this.numericParameters.get(key);
            if (number) {
                number.onChangeEmit = (newValue) => eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__.SettingsChangedEvent({
                    id: number.id,
                    type: 'number',
                    value: newValue,
                    target: number
                }));
            }
        }
        for (const key of this.textParameters.keys()) {
            const text = this.textParameters.get(key);
            if (text) {
                text.onChangeEmit = (newValue) => eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__.SettingsChangedEvent({
                    id: text.id,
                    type: 'text',
                    value: newValue,
                    target: text
                }));
            }
        }
        for (const key of this.optionParameters.keys()) {
            const option = this.optionParameters.get(key);
            if (option) {
                option.onChangeEmit = (newValue) => eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__.SettingsChangedEvent({
                    id: option.id,
                    type: 'option',
                    value: newValue,
                    target: option
                }));
            }
        }
    }
}
/**
 * The enum associated with the mouse being locked or hovering
 */
var ControlSchemeType;
(function (ControlSchemeType) {
    ControlSchemeType[ControlSchemeType["LockedMouse"] = 0] = "LockedMouse";
    ControlSchemeType[ControlSchemeType["HoveringMouse"] = 1] = "HoveringMouse";
})(ControlSchemeType || (ControlSchemeType = {}));
//# sourceMappingURL=Config.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/SettingBase.js":
/*!****************************************************!*\
  !*** ../../library/dist/esm/Config/SettingBase.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingBase: () => (/* binding */ SettingBase)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Base class for a setting that has a text label and an arbitrary setting value it stores.
 */
class SettingBase {
    constructor(id, label, description, defaultSettingValue, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        this.parseURLParams();
        this.onChange = defaultOnChangeListener;
        this.onChangeEmit = () => {
            /* Do nothing, to be overridden. */
        };
        this.id = id;
        this.description = description;
        this.label = label;
        this.value = defaultSettingValue;
    }
    /**
     * Set the label text for the setting.
     * @param label setting label.
     */
    set label(inLabel) {
        this._label = inLabel;
        this.onChangeEmit(this._value);
    }
    /**
     * @returns The label text for the setting.
     */
    get label() {
        return this._label;
    }
    /**
     * @return The setting's value.
     */
    get value() {
        return this._value;
    }
    /**
     * Update the setting's stored value.
     * @param inValue The new value for the setting.
     */
    set value(inValue) {
        this._value = inValue;
        this.onChange(this._value, this);
        this.onChangeEmit(this._value);
    }
    /**
     * Persist the setting value in URL.
     */
    updateURLParams() {
        if (this.useUrlParams) {
            // set url params
            const urlParams = new URLSearchParams(window.location.search);
            const valueString = this.getValueAsString();
            let set = false;
            for (const [name, _value] of urlParams) {
                if (name.toLowerCase() == this.id.toLowerCase()) {
                    urlParams.set(name, valueString);
                    set = true;
                    break;
                }
            }
            if (!set) {
                urlParams.set(this.id, valueString);
            }
            window.history.replaceState({}, '', urlParams.toString() !== '' ? `${location.pathname}?${urlParams}` : `${location.pathname}`);
        }
    }
    /**
     * Allows sub types to provide their value for the url search params.
     */
    getValueAsString() {
        return '';
    }
    parseURLParams() {
        this._urlParams = {};
        const params = new URLSearchParams(window.location.search);
        for (const [name, value] of params) {
            this._urlParams[name.toLowerCase()] = value;
        }
    }
    hasURLParam(name) {
        return name.toLowerCase() in this._urlParams;
    }
    getURLParam(name) {
        if (this.hasURLParam(name)) {
            return this._urlParams[name.toLowerCase()];
        }
        return '';
    }
}
//# sourceMappingURL=SettingBase.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/SettingFlag.js":
/*!****************************************************!*\
  !*** ../../library/dist/esm/Config/SettingFlag.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingFlag: () => (/* binding */ SettingFlag)
/* harmony export */ });
/* harmony import */ var _SettingBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingBase */ "../../library/dist/esm/Config/SettingBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * A boolean flag setting object with a text label.
 */
class SettingFlag extends _SettingBase__WEBPACK_IMPORTED_MODULE_0__.SettingBase {
    constructor(id, label, description, defaultFlagValue, useUrlParams, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        super(id, label, description, defaultFlagValue, defaultOnChangeListener);
        if (!useUrlParams || !this.hasURLParam(this.id)) {
            this.flag = defaultFlagValue;
        }
        else {
            // parse flag from url parameters
            const urlParamFlag = this.getURLParam(this.id);
            this.flag = urlParamFlag.toLowerCase() != 'false';
        }
        this.useUrlParams = useUrlParams;
    }
    getValueAsString() {
        return this.flag ? 'true' : 'false';
    }
    /**
     * Enables this flag.
     */
    enable() {
        this.flag = true;
    }
    /**
     * @return The setting's value.
     */
    get flag() {
        return !!this.value;
    }
    /**
     * Update the setting's stored value.
     * @param inValue The new value for the setting.
     */
    set flag(inValue) {
        this.value = inValue;
    }
}
//# sourceMappingURL=SettingFlag.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/SettingNumber.js":
/*!******************************************************!*\
  !*** ../../library/dist/esm/Config/SettingNumber.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingNumber: () => (/* binding */ SettingNumber)
/* harmony export */ });
/* harmony import */ var _SettingBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingBase */ "../../library/dist/esm/Config/SettingBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * A number setting object with a text label. Min and max limit the range of allowed values.
 */
class SettingNumber extends _SettingBase__WEBPACK_IMPORTED_MODULE_0__.SettingBase {
    constructor(id, label, description, min, max, defaultNumber, useUrlParams, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        super(id, label, description, defaultNumber, defaultOnChangeListener);
        this._min = min;
        this._max = max;
        // attempt to read the number from the url params
        if (!useUrlParams || !this.hasURLParam(this.id)) {
            this.number = defaultNumber;
        }
        else {
            const parsedValue = Number.parseFloat(this.getURLParam(this.id));
            this.number = Number.isNaN(parsedValue) ? defaultNumber : parsedValue;
        }
        this.useUrlParams = useUrlParams;
    }
    getValueAsString() {
        return this.number.toString();
    }
    /**
     * Set the number value (will be clamped within range).
     */
    set number(newNumber) {
        this.value = this.clamp(newNumber);
    }
    /**
     * @returns The number stored.
     */
    get number() {
        return this.value;
    }
    /**
     * Clamps a number between the min and max values (inclusive).
     * @param inNumber The number to clamp.
     * @returns The clamped number.
     */
    clamp(inNumber) {
        if (this._min == null && this._max == null) {
            return inNumber;
        }
        else if (this._min == null) {
            return Math.min(this._max, inNumber);
        }
        else if (this._max == null) {
            return Math.max(this._min, inNumber);
        }
        else {
            return Math.max(Math.min(this._max, inNumber), this._min);
        }
    }
    /**
     * Returns the minimum value
     * @returns The minimum value
     */
    get min() {
        return this._min;
    }
    /**
     * Returns the maximum value
     * @returns The maximum value
     */
    get max() {
        return this._max;
    }
    /**
     * Add a change listener to the number object.
     */
    addOnChangedListener(onChangedFunc) {
        this.onChange = onChangedFunc;
    }
}
//# sourceMappingURL=SettingNumber.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/SettingOption.js":
/*!******************************************************!*\
  !*** ../../library/dist/esm/Config/SettingOption.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingOption: () => (/* binding */ SettingOption)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _SettingBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingBase */ "../../library/dist/esm/Config/SettingBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * An Option setting object with a text label. Allows you to specify an array of options and select one of them.
 */
class SettingOption extends _SettingBase__WEBPACK_IMPORTED_MODULE_0__.SettingBase {
    constructor(id, label, description, defaultTextValue, options, useUrlParams, defaultUrlParamResolver = function (value) {
        /* Return the string as-is by default */
        return value;
    }, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        super(id, label, description, defaultTextValue, defaultOnChangeListener);
        this._urlParamResolver = defaultUrlParamResolver;
        const stringToMatch = this.hasURLParam(this.id)
            ? this._urlParamResolver(this.getURLParam(this.id))
            : defaultTextValue;
        this.options = options !== null && options !== void 0 ? options : [stringToMatch];
        this.selected = stringToMatch;
        this.useUrlParams = useUrlParams;
    }
    getValueAsString() {
        return this.selected;
    }
    /**
     * Add a change listener to the select element.
     */
    addOnChangedListener(onChangedFunc) {
        this.onChange = onChangedFunc;
    }
    /**
     * @returns All available options as an array
     */
    get options() {
        return this._options;
    }
    /**
     * Set options
     * @param values Array of options
     */
    set options(values) {
        this._options = values;
        this.onChangeEmit(this.selected);
    }
    /**
     * @returns Selected option as a string
     */
    get selected() {
        return this.value;
    }
    /**
     * Set selected option if it matches one of the available options
     * @param value Selected option
     */
    set selected(value) {
        if (value === undefined) {
            return;
        }
        // If options contains the value, then set that as selected
        if (this.options.includes(value)) {
            this.value = value;
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`Could not set "${value}" as the selected option for ${this.id} because it wasn't one of the options.`);
        }
    }
    /**
     * Set the url parameter resolver to do some transformation to the string value
     * that is extracted from the url parameters.
     * @param urlParam A function that transforms the extracted url parameter string for this setting to something else.
     */
    set urlParamResolver(value) {
        this._urlParamResolver = value;
    }
}
//# sourceMappingURL=SettingOption.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/SettingText.js":
/*!****************************************************!*\
  !*** ../../library/dist/esm/Config/SettingText.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingText: () => (/* binding */ SettingText)
/* harmony export */ });
/* harmony import */ var _SettingBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingBase */ "../../library/dist/esm/Config/SettingBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * A text setting object with a text label.
 */
class SettingText extends _SettingBase__WEBPACK_IMPORTED_MODULE_0__.SettingBase {
    constructor(id, label, description, defaultTextValue, useUrlParams, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        super(id, label, description, defaultTextValue, defaultOnChangeListener);
        if (!useUrlParams || !this.hasURLParam(this.id)) {
            this.text = defaultTextValue;
        }
        else {
            // parse flag from url parameters
            this.text = this.getURLParam(this.id);
        }
        this.useUrlParams = useUrlParams;
    }
    getValueAsString() {
        return this.text;
    }
    /**
     * @return The setting's value.
     */
    get text() {
        return this.value;
    }
    /**
     * Update the setting's stored value.
     * @param inValue The new value for the setting.
     */
    set text(inValue) {
        this.value = inValue;
    }
}
//# sourceMappingURL=SettingText.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/DataChannelController.js":
/*!*******************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/DataChannelController.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataChannelController: () => (/* binding */ DataChannelController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Handles the Sending and Receiving of messages to the UE Instance via the Data Channel
 */
class DataChannelController {
    constructor() {
        this.isReceivingFreezeFrame = false;
    }
    /**
     * return the current state of a datachannel controller instance
     * @returns the current DataChannelController instance
     */
    getDataChannelInstance() {
        return this;
    }
    /**
     * To Create and Set up a Data Channel
     * @param peerConnection - The RTC Peer Connection
     * @param label - Label of the Data Channel
     * @param datachannelOptions - Optional RTC DataChannel options
     */
    createDataChannel(peerConnection, label, datachannelOptions) {
        this.peerConnection = peerConnection;
        this.label = label;
        this.datachannelOptions = datachannelOptions;
        if (datachannelOptions == null) {
            this.datachannelOptions = {};
            this.datachannelOptions.ordered = true;
        }
        this.dataChannel = this.peerConnection.createDataChannel(this.label, this.datachannelOptions);
        this.setupDataChannel();
    }
    setupDataChannel() {
        //We Want an Array Buffer not a blob
        this.dataChannel.binaryType = 'arraybuffer';
        this.dataChannel.onopen = (ev) => this.handleOnOpen(ev);
        this.dataChannel.onclose = (ev) => this.handleOnClose(ev);
        this.dataChannel.onmessage = (ev) => this.handleOnMessage(ev);
        this.dataChannel.onerror = (ev) => this.handleOnError(ev);
    }
    /**
     * Handles when the Data Channel is opened
     */
    handleOnOpen(ev) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data Channel (${this.label}) opened.`);
        this.onOpen((_a = this.dataChannel) === null || _a === void 0 ? void 0 : _a.label, ev);
    }
    /**
     * Handles when the Data Channel is closed
     */
    handleOnClose(ev) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data Channel (${this.label}) closed.`);
        this.onClose((_a = this.dataChannel) === null || _a === void 0 ? void 0 : _a.label, ev);
    }
    /**
     * Handles when a message is received
     * @param event - Message Event
     */
    handleOnMessage(event) {
        // Higher log level to prevent log spam with messages received
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data Channel (${this.label}) message: ${event}`);
    }
    /**
     * Handles when an error is thrown
     * @param event - Error Event
     */
    handleOnError(event) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data Channel (${this.label}) error: ${event}`);
        this.onError((_a = this.dataChannel) === null || _a === void 0 ? void 0 : _a.label, event);
    }
    /**
     * Override to register onOpen handler
     * @param label Data channel label ("datachannel", "send-datachannel", "recv-datachannel")
     * @param ev event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onOpen(label, ev) {
        // empty default implementation
    }
    /**
     * Override to register onClose handler
     * @param label Data channel label ("datachannel", "send-datachannel", "recv-datachannel")
     * @param ev event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onClose(label, ev) {
        // empty default implementation
    }
    /**
     * Override to register onError handler
     * @param label Data channel label ("datachannel", "send-datachannel", "recv-datachannel")
     * @param ev event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onError(label, ev) {
        // empty default implementation
    }
}
//# sourceMappingURL=DataChannelController.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/DataChannelLatencyTestController.js":
/*!******************************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/DataChannelLatencyTestController.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataChannelLatencyTestController: () => (/* binding */ DataChannelLatencyTestController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _DataChannelLatencyTestResults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DataChannelLatencyTestResults */ "../../library/dist/esm/DataChannel/DataChannelLatencyTestResults.js");
// Copyright Epic Games, Inc. All Rights Reserved.


class DataChannelLatencyTestController {
    constructor(sink, callback) {
        this.intervalHandle = undefined;
        this.sink = sink;
        this.callback = callback;
        this.records = new Map();
        this.seq = 0;
    }
    start(config) {
        if (this.isRunning()) {
            return false;
        }
        this.startTime = Date.now();
        this.records.clear();
        this.intervalHandle = window.setInterval((() => {
            if (Date.now() - this.startTime >= config.duration) {
                this.stop();
            }
            else {
                this.sendRequest(config.requestSize, config.responseSize);
            }
        }).bind(this), Math.floor(1000 / config.rps));
        return true;
    }
    stop() {
        if (this.intervalHandle) {
            window.clearInterval(this.intervalHandle);
            this.intervalHandle = undefined;
            this.callback(this.produceResult());
        }
    }
    produceResult() {
        const resultRecords = new Map(this.records);
        return {
            records: resultRecords,
            dataChannelRtt: Math.ceil(Array.from(this.records.values()).reduce((acc, next) => {
                return acc + (next.playerReceivedTimestamp - next.playerSentTimestamp);
            }, 0) / this.records.size),
            playerToStreamerTime: Math.ceil(Array.from(this.records.values()).reduce((acc, next) => {
                return acc + (next.streamerReceivedTimestamp - next.playerSentTimestamp);
            }, 0) / this.records.size),
            streamerToPlayerTime: Math.ceil(Array.from(this.records.values()).reduce((acc, next) => {
                return acc + (next.playerReceivedTimestamp - next.streamerSentTimestamp);
            }, 0) / this.records.size),
            exportLatencyAsCSV: () => {
                let csv = 'Timestamp;RTT;PlayerToStreamer;StreamerToPlayer;\n';
                resultRecords.forEach((record) => {
                    csv += record.playerSentTimestamp + ';';
                    csv += record.playerReceivedTimestamp - record.playerSentTimestamp + ';';
                    csv += record.streamerReceivedTimestamp - record.playerSentTimestamp + ';';
                    csv += record.playerReceivedTimestamp - record.streamerSentTimestamp + ';';
                    csv += '\n';
                });
                return csv;
            }
        };
    }
    isRunning() {
        return !!this.intervalHandle;
    }
    receive(response) {
        if (!this.isRunning()) {
            return;
        }
        if (!response) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Error('Undefined response from server');
            return;
        }
        const record = this.records.get(response.Seq);
        if (record) {
            record.update(response);
        }
    }
    sendRequest(requestSize, responseSize) {
        const request = this.createRequest(requestSize, responseSize);
        const record = new _DataChannelLatencyTestResults__WEBPACK_IMPORTED_MODULE_1__.DataChannelLatencyTestRecord(request);
        this.records.set(record.seq, record);
        this.sink(request);
    }
    createRequest(requestSize, responseSize) {
        return {
            Seq: this.seq++,
            FillResponseSize: responseSize,
            Filler: requestSize ? 'A'.repeat(requestSize) : ''
        };
    }
}
//# sourceMappingURL=DataChannelLatencyTestController.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/DataChannelLatencyTestResults.js":
/*!***************************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/DataChannelLatencyTestResults.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataChannelLatencyTestRecord: () => (/* binding */ DataChannelLatencyTestRecord)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class DataChannelLatencyTestRecord {
    constructor(request) {
        this.seq = request.Seq;
        this.playerSentTimestamp = Date.now();
        this.requestFillerSize = request.Filler ? request.Filler.length : 0;
    }
    update(response) {
        this.playerReceivedTimestamp = Date.now();
        this.streamerReceivedTimestamp = response.ReceivedTimestamp;
        this.streamerSentTimestamp = response.SentTimestamp;
        this.responseFillerSize = response.Filler ? response.Filler.length : 0;
    }
}
//# sourceMappingURL=DataChannelLatencyTestResults.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/DataChannelSender.js":
/*!***************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/DataChannelSender.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataChannelSender: () => (/* binding */ DataChannelSender)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * A class for sending data channel messages
 */
class DataChannelSender {
    /**
     * @param dataChannelProvider - Data channel object type
     */
    constructor(dataChannelProvider) {
        this.dataChannelProvider = dataChannelProvider;
    }
    canSend() {
        return (this.dataChannelProvider.getDataChannelInstance().dataChannel !== undefined &&
            this.dataChannelProvider.getDataChannelInstance().dataChannel.readyState == 'open');
    }
    /**
     * Send Data over the Data channel to the UE Instance
     * @param data - Message Data Array Buffer
     */
    sendData(data) {
        // reset the afk inactivity
        const dataChannelInstance = this.dataChannelProvider.getDataChannelInstance();
        if (dataChannelInstance.dataChannel.readyState == 'open') {
            dataChannelInstance.dataChannel.send(data);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Message Sent: ${new Uint8Array(data)}`);
            this.resetAfkWarningTimerOnDataSend();
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Message Failed: ${new Uint8Array(data)}`);
        }
    }
    /**
     * An override method for resetting the Afk warning timer when data is sent over the data channel
     */
    resetAfkWarningTimerOnDataSend() {
        // Base Functionality: Do Nothing
    }
}
//# sourceMappingURL=DataChannelSender.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/InitialSettings.js":
/*!*************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/InitialSettings.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EncoderSettings: () => (/* binding */ EncoderSettings),
/* harmony export */   InitialSettings: () => (/* binding */ InitialSettings),
/* harmony export */   PixelStreamingSettings: () => (/* binding */ PixelStreamingSettings),
/* harmony export */   WebRTCSettings: () => (/* binding */ WebRTCSettings)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Latency Test Results Data
 */
class InitialSettings {
    constructor() {
        this.PixelStreamingSettings = new PixelStreamingSettings();
        this.EncoderSettings = new EncoderSettings();
        this.WebRTCSettings = new WebRTCSettings();
    }
    /**
     * Checks for compatibility with the FPS and MaxFPS stats between 4.27 and 5
     */
    ueCompatible() {
        if (this.WebRTCSettings.MaxFPS != null) {
            this.WebRTCSettings.FPS = this.WebRTCSettings.MaxFPS;
        }
    }
}
/**
 * A class for handling Pixel Streaming details
 */
class PixelStreamingSettings {
}
/**
 * A class for handling encoder stats
 */
class EncoderSettings {
}
/**
 * A class for handling web rtc stats
 */
class WebRTCSettings {
}
//# sourceMappingURL=InitialSettings.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/LatencyTestResults.js":
/*!****************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/LatencyTestResults.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LatencyTestResults: () => (/* binding */ LatencyTestResults)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Latency Test Results Data
 */
class LatencyTestResults {
    constructor() {
        //Fields Set from the latency payload regardless of version
        this.ReceiptTimeMs = null;
        this.TransmissionTimeMs = null;
        //Fields Set from the latency payload from 4.27.2
        this.PreCaptureTimeMs = null;
        this.PostCaptureTimeMs = null;
        this.PreEncodeTimeMs = null;
        this.PostEncodeTimeMs = null;
        //Fields Set from the latency payload from 5.0
        this.EncodeMs = null;
        this.CaptureToSendMs = null;
        //Fields Set when processed
        this.testStartTimeMs = 0;
        this.browserReceiptTimeMs = 0;
        //Fields set from calculations
        this.latencyExcludingDecode = 0;
        this.testDuration = 0;
        //ueLatency: number = 0;
        this.networkLatency = 0;
        this.browserSendLatency = 0;
        this.frameDisplayDeltaTimeMs = 0;
        this.endToEndLatency = 0;
        //uePixelStreamLatency: number = 0;
        this.encodeLatency = 0;
    }
    /**
     * Sets the Delta Time Milliseconds
     * @param DeltaTimeMs - Delta Time Milliseconds
     */
    setFrameDisplayDeltaTime(DeltaTimeMs) {
        if (this.frameDisplayDeltaTimeMs == 0) {
            this.frameDisplayDeltaTimeMs = Math.round(DeltaTimeMs);
        }
    }
    /**
     * Process the encoder times and set them
     */
    processFields() {
        if (this.EncodeMs == null && (this.PreEncodeTimeMs != null || this.PostEncodeTimeMs != null)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Setting Encode Ms \n ${this.PostEncodeTimeMs} \n ${this.PreEncodeTimeMs}`);
            this.EncodeMs = this.PostEncodeTimeMs - this.PreEncodeTimeMs;
        }
        if (this.CaptureToSendMs == null &&
            (this.PreCaptureTimeMs != null || this.PostCaptureTimeMs != null)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Setting CaptureToSendMs Ms \n ${this.PostCaptureTimeMs} \n ${this.PreCaptureTimeMs}`);
            this.CaptureToSendMs = this.PostCaptureTimeMs - this.PreCaptureTimeMs;
        }
    }
}
//# sourceMappingURL=LatencyTestResults.js.map

/***/ }),

/***/ "../../library/dist/esm/FreezeFrame/FreezeFrame.js":
/*!*********************************************************!*\
  !*** ../../library/dist/esm/FreezeFrame/FreezeFrame.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FreezeFrame: () => (/* binding */ FreezeFrame)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * A class for managing the freeze frame object
 */
class FreezeFrame {
    /**
     * Construct a freeze frame
     * @param rootDiv the div that a freeze frame element will be injected into
     */
    constructor(rootDiv) {
        this.freezeFrameHeight = 0;
        this.freezeFrameWidth = 0;
        this.rootDiv = rootDiv;
        // create the overlay
        this.rootElement = document.createElement('div');
        this.rootElement.id = 'freezeFrame';
        this.rootElement.style.display = 'none';
        this.rootElement.style.pointerEvents = 'none';
        this.rootElement.style.position = 'absolute';
        this.rootElement.style.zIndex = '20';
        // create the image place holder
        this.imageElement = document.createElement('img');
        this.imageElement.style.position = 'absolute';
        // append the image into the root element and append the element to the root div
        this.rootElement.appendChild(this.imageElement);
        this.rootDiv.appendChild(this.rootElement);
    }
    /**
     * Set the freeze frame element for showing
     */
    setElementForShow() {
        this.rootElement.style.display = 'block';
    }
    /**
     * Set the freeze frame element for hiding
     */
    setElementForHide() {
        this.rootElement.style.display = 'none';
    }
    /**
     * Update the freeze frames image source
     * @param jpeg - the freeze frame image as a byte array data
     */
    updateImageElementSource(jpeg) {
        const base64 = btoa(jpeg.reduce((data, byte) => data + String.fromCharCode(byte), ''));
        this.imageElement.src = 'data:image/jpeg;base64,' + base64;
    }
    /**
     * Set the dimensions for the freeze frame from the element and resize it
     */
    setDimensionsFromElementAndResize() {
        this.freezeFrameHeight = this.imageElement.naturalHeight;
        this.freezeFrameWidth = this.imageElement.naturalWidth;
        this.resize();
    }
    /**
     * Resize a freeze frame element
     */
    resize() {
        if (this.freezeFrameWidth !== 0 && this.freezeFrameHeight !== 0) {
            let displayWidth = 0;
            let displayHeight = 0;
            let displayTop = 0;
            let displayLeft = 0;
            const parentAspectRatio = this.rootDiv.clientWidth / this.rootDiv.clientHeight;
            const videoAspectRatio = this.freezeFrameWidth / this.freezeFrameHeight;
            if (parentAspectRatio < videoAspectRatio) {
                displayWidth = this.rootDiv.clientWidth;
                displayHeight = Math.floor(this.rootDiv.clientWidth / videoAspectRatio);
                displayTop = Math.floor((this.rootDiv.clientHeight - displayHeight) * 0.5);
                displayLeft = 0;
            }
            else {
                displayWidth = Math.floor(this.rootDiv.clientHeight * videoAspectRatio);
                displayHeight = this.rootDiv.clientHeight;
                displayTop = 0;
                displayLeft = Math.floor((this.rootDiv.clientWidth - displayWidth) * 0.5);
            }
            this.rootElement.style.width = this.rootDiv.offsetWidth + 'px';
            this.rootElement.style.height = this.rootDiv.offsetHeight + 'px';
            this.rootElement.style.left = 0 + 'px';
            this.rootElement.style.top = 0 + 'px';
            this.imageElement.style.width = displayWidth + 'px';
            this.imageElement.style.height = displayHeight + 'px';
            this.imageElement.style.left = displayLeft + 'px';
            this.imageElement.style.top = displayTop + 'px';
        }
    }
}
//# sourceMappingURL=FreezeFrame.js.map

/***/ }),

/***/ "../../library/dist/esm/FreezeFrame/FreezeFrameController.js":
/*!*******************************************************************!*\
  !*** ../../library/dist/esm/FreezeFrame/FreezeFrameController.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FreezeFrameController: () => (/* binding */ FreezeFrameController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _FreezeFrame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FreezeFrame */ "../../library/dist/esm/FreezeFrame/FreezeFrame.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * A class for controlling freeze frame functionality
 */
class FreezeFrameController {
    /**
     * Construct a freeze frame controller
     * @param rootDiv - the div that a freeze frame element will be injected into
     */
    constructor(rootDiv) {
        this.receiving = false;
        this.size = 0;
        this.jpeg = undefined;
        this.valid = false;
        this.freezeFrameDelay = 50;
        this.freezeFrame = new _FreezeFrame__WEBPACK_IMPORTED_MODULE_0__.FreezeFrame(rootDiv);
    }
    /**
     * Show the freeze frame if it is valid
     */
    showFreezeFrame() {
        if (this.valid) {
            this.freezeFrame.setElementForShow();
        }
    }
    /**
     * Hide the freeze frame and set the validity to false
     */
    hideFreezeFrame() {
        this.valid = false;
        this.freezeFrame.setElementForHide();
    }
    /**
     * Update the freeze frames image source and load it
     * @param jpeg - the freeze frame image as a byte array data
     * @param onLoadCallBack - a call back for managing if the play overlay needs to be shown or not
     */
    updateFreezeFrameAndShow(jpeg, onLoadCallBack) {
        this.freezeFrame.updateImageElementSource(jpeg);
        this.freezeFrame.imageElement.onload = () => {
            this.freezeFrame.setDimensionsFromElementAndResize();
            onLoadCallBack();
        };
    }
    /**
     * Process the new freeze frame image and update it
     * @param view - the freeze frame image as a byte array data
     * @param onLoadCallBack - a call back for managing if the play overlay needs to be shown or not
     */
    processFreezeFrameMessage(view, onLoadCallBack) {
        // Reset freeze frame if we got a freeze frame message and we are not "receiving" yet.
        if (!this.receiving) {
            this.receiving = true;
            this.valid = false;
            this.size = 0;
            this.jpeg = undefined;
        }
        // Extract total size of freeze frame (across all chunks)
        this.size = new DataView(view.slice(1, 5).buffer).getInt32(0, true);
        // Get the jpeg part of the payload
        const jpegBytes = view.slice(1 + 4);
        // Append to existing jpeg that holds the freeze frame
        if (this.jpeg) {
            const jpeg = new Uint8Array(this.jpeg.length + jpegBytes.length);
            jpeg.set(this.jpeg, 0);
            jpeg.set(jpegBytes, this.jpeg.length);
            this.jpeg = jpeg;
        }
        // No existing freeze frame jpeg, make one
        else {
            this.jpeg = jpegBytes;
            this.receiving = true;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(`received first chunk of freeze frame: ${this.jpeg.length}/${this.size}`);
        }
        // Finished receiving freeze frame, we can show it now
        if (this.jpeg.length === this.size) {
            this.receiving = false;
            this.valid = true;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(`received complete freeze frame ${this.size}`);
            this.updateFreezeFrameAndShow(this.jpeg, onLoadCallBack);
        }
        // We received more data than the freeze frame payload message indicate (this is an error)
        else if (this.jpeg.length > this.size) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`received bigger freeze frame than advertised: ${this.jpeg.length}/${this.size}`);
            this.jpeg = undefined;
            this.receiving = false;
        }
    }
}
//# sourceMappingURL=FreezeFrameController.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/GamepadController.js":
/*!**********************************************************!*\
  !*** ../../library/dist/esm/Inputs/GamepadController.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GamepadController: () => (/* binding */ GamepadController),
/* harmony export */   GamepadLayout: () => (/* binding */ GamepadLayout)
/* harmony export */ });
/* harmony import */ var _GamepadTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GamepadTypes */ "../../library/dist/esm/Inputs/GamepadTypes.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Gamepad layout codes enum
 */
var GamepadLayout;
(function (GamepadLayout) {
    GamepadLayout[GamepadLayout["RightClusterBottomButton"] = 0] = "RightClusterBottomButton";
    GamepadLayout[GamepadLayout["RightClusterRightButton"] = 1] = "RightClusterRightButton";
    GamepadLayout[GamepadLayout["RightClusterLeftButton"] = 2] = "RightClusterLeftButton";
    GamepadLayout[GamepadLayout["RightClusterTopButton"] = 3] = "RightClusterTopButton";
    GamepadLayout[GamepadLayout["LeftShoulder"] = 4] = "LeftShoulder";
    GamepadLayout[GamepadLayout["RightShoulder"] = 5] = "RightShoulder";
    GamepadLayout[GamepadLayout["LeftTrigger"] = 6] = "LeftTrigger";
    GamepadLayout[GamepadLayout["RightTrigger"] = 7] = "RightTrigger";
    GamepadLayout[GamepadLayout["SelectOrBack"] = 8] = "SelectOrBack";
    GamepadLayout[GamepadLayout["StartOrForward"] = 9] = "StartOrForward";
    GamepadLayout[GamepadLayout["LeftAnalogPress"] = 10] = "LeftAnalogPress";
    GamepadLayout[GamepadLayout["RightAnalogPress"] = 11] = "RightAnalogPress";
    GamepadLayout[GamepadLayout["LeftClusterTopButton"] = 12] = "LeftClusterTopButton";
    GamepadLayout[GamepadLayout["LeftClusterBottomButton"] = 13] = "LeftClusterBottomButton";
    GamepadLayout[GamepadLayout["LeftClusterLeftButton"] = 14] = "LeftClusterLeftButton";
    GamepadLayout[GamepadLayout["LeftClusterRightButton"] = 15] = "LeftClusterRightButton";
    GamepadLayout[GamepadLayout["CentreButton"] = 16] = "CentreButton";
    // Axes
    GamepadLayout[GamepadLayout["LeftStickHorizontal"] = 0] = "LeftStickHorizontal";
    GamepadLayout[GamepadLayout["LeftStickVertical"] = 1] = "LeftStickVertical";
    GamepadLayout[GamepadLayout["RightStickHorizontal"] = 2] = "RightStickHorizontal";
    GamepadLayout[GamepadLayout["RightStickVertical"] = 3] = "RightStickVertical";
})(GamepadLayout || (GamepadLayout = {}));
/**
 * Handles gamepad events from the document to send to the streamer.
 */
class GamepadController {
    constructor(streamMessageController) {
        this.streamMessageController = streamMessageController;
        this.onGamepadConnectedListener = this.onGamepadConnected.bind(this);
        this.onGamepadDisconnectedListener = this.onGamepadDisconnected.bind(this);
        this.beforeUnloadListener = this.onBeforeUnload.bind(this);
        this.requestAnimationFrame = (window.mozRequestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.requestAnimationFrame).bind(window);
    }
    register() {
        window.addEventListener('beforeunload', this.beforeUnloadListener);
        const browserWindow = window;
        if ('GamepadEvent' in browserWindow) {
            window.addEventListener('gamepadconnected', this.onGamepadConnectedListener);
            window.addEventListener('gamepaddisconnected', this.onGamepadDisconnectedListener);
        }
        else if ('WebKitGamepadEvent' in browserWindow) {
            window.addEventListener('webkitgamepadconnected', this.onGamepadConnectedListener);
            window.addEventListener('webkitgamepaddisconnected', this.onGamepadDisconnectedListener);
        }
        this.controllers = [];
        if (navigator.getGamepads) {
            for (const gamepad of navigator.getGamepads()) {
                if (gamepad) {
                    this.onGamepadConnected(new GamepadEvent('gamepadconnected', { gamepad }));
                }
            }
        }
    }
    unregister() {
        window.removeEventListener('gamepadconnected', this.onGamepadConnectedListener);
        window.removeEventListener('gamepaddisconnected', this.onGamepadDisconnectedListener);
        window.removeEventListener('webkitgamepadconnected', this.onGamepadConnectedListener);
        window.removeEventListener('webkitgamepaddisconnected', this.onGamepadDisconnectedListener);
        for (const controller of this.controllers) {
            if (controller && controller.id !== undefined) {
                this.streamMessageController.toStreamerHandlers.get('GamepadDisconnected')([controller.id]);
            }
        }
        this.controllers = [];
    }
    onGamepadResponseReceived(gamepadId) {
        for (const controller of this.controllers) {
            if (controller && controller.id === undefined) {
                controller.id = gamepadId;
                break;
            }
        }
    }
    onGamepadConnected(event) {
        const gamepad = event.gamepad;
        const newController = {
            currentState: (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(gamepad),
            prevState: (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(gamepad),
            id: undefined
        };
        this.controllers[gamepad.index] = newController;
        window.requestAnimationFrame(() => this.updateStatus());
        this.streamMessageController.toStreamerHandlers.get('GamepadConnected')();
    }
    onGamepadDisconnected(event) {
        const gamepad = event.gamepad;
        const deletedController = this.controllers[gamepad.index];
        delete this.controllers[gamepad.index];
        this.controllers = this.controllers.filter((controller) => controller !== undefined);
        if (deletedController.id !== undefined) {
            this.streamMessageController.toStreamerHandlers.get('GamepadDisconnected')([
                deletedController.id
            ]);
        }
    }
    scanGamepads() {
        const gamepads = navigator.getGamepads
            ? navigator.getGamepads()
            : navigator.webkitGetGamepads
                ? navigator.webkitGetGamepads()
                : [];
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i] && this.controllers[gamepads[i].index] !== undefined) {
                this.controllers[gamepads[i].index].currentState = gamepads[i];
            }
        }
    }
    updateStatus() {
        this.scanGamepads();
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        // Iterate over multiple controllers in the case the multiple gamepads are connected
        for (const controller of this.controllers) {
            if (!controller) {
                continue;
            }
            // If we haven't received an id (possible if using an older version of UE), return to original functionality
            const controllerId = controller.id === undefined ? this.controllers.indexOf(controller) : controller.id;
            const currentState = controller.currentState;
            for (let i = 0; i < controller.currentState.buttons.length; i++) {
                const currentButton = controller.currentState.buttons[i];
                const previousButton = controller.prevState.buttons[i];
                if (currentButton.pressed) {
                    // press
                    if (i == GamepadLayout.LeftTrigger) {
                        // UEs left analog has a button index of 5
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 5, currentButton.value]);
                    }
                    else if (i == GamepadLayout.RightTrigger) {
                        // UEs right analog has a button index of 6
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 6, currentButton.value]);
                    }
                    else {
                        toStreamerHandlers.get('GamepadButtonPressed')([
                            controllerId,
                            i,
                            previousButton.pressed ? 1 : 0
                        ]);
                    }
                }
                else if (!currentButton.pressed && previousButton.pressed) {
                    // release
                    if (i == GamepadLayout.LeftTrigger) {
                        // UEs left analog has a button index of 5
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 5, 0]);
                    }
                    else if (i == GamepadLayout.RightTrigger) {
                        // UEs right analog has a button index of 6
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 6, 0]);
                    }
                    else {
                        toStreamerHandlers.get('GamepadButtonReleased')([controllerId, i, 0]);
                    }
                }
            }
            // Iterate over gamepad axes (we will increment in lots of 2 as there is 2 axes per stick)
            for (let i = 0; i < currentState.axes.length; i += 2) {
                // Horizontal axes are even numbered
                const x = parseFloat(currentState.axes[i].toFixed(4));
                // Vertical axes are odd numbered
                // https://w3c.github.io/gamepad/#remapping Gamepad browser side standard mapping has positive down, negative up. This is downright disgusting. So we fix it.
                const y = -parseFloat(currentState.axes[i + 1].toFixed(4));
                // UE's analog axes follow the same order as the browsers, but start at index 1 so we will offset as such
                toStreamerHandlers.get('GamepadAnalog')([controllerId, i + 1, x]); // Horizontal axes, only offset by 1
                toStreamerHandlers.get('GamepadAnalog')([controllerId, i + 2, y]); // Vertical axes, offset by two (1 to match UEs axes convention and then another 1 for the vertical axes)
            }
            const controllerIndex = this.controllers.indexOf(controller);
            this.controllers[controllerIndex].prevState = (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(currentState);
        }
        if (this.controllers.length > 0) {
            this.requestAnimationFrame(() => this.updateStatus());
        }
    }
    onBeforeUnload(_) {
        // When a user navigates away from the page, we need to inform UE of all the disconnecting
        // controllers
        for (const controller of this.controllers) {
            if (!controller || controller.id === undefined) {
                continue;
            }
            this.streamMessageController.toStreamerHandlers.get('GamepadDisconnected')([controller.id]);
        }
    }
}
//# sourceMappingURL=GamepadController.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/GamepadTypes.js":
/*!*****************************************************!*\
  !*** ../../library/dist/esm/Inputs/GamepadTypes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deepCopyGamepad: () => (/* binding */ deepCopyGamepad)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Deep copies the values from a gamepad by first converting it to a JSON object and then back to a gamepad
 *
 * @param gamepad the original gamepad
 * @returns a new gamepad object, populated with the original gamepads values
 */
function deepCopyGamepad(gamepad) {
    return JSON.parse(JSON.stringify({
        buttons: gamepad.buttons.map((b) => JSON.parse(JSON.stringify({
            pressed: b.pressed,
            touched: b.touched,
            value: b.value
        }))),
        axes: gamepad.axes
    }));
}
//# sourceMappingURL=GamepadTypes.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/InputClassesFactory.js":
/*!************************************************************!*\
  !*** ../../library/dist/esm/Inputs/InputClassesFactory.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActiveKeys: () => (/* binding */ ActiveKeys),
/* harmony export */   InputClassesFactory: () => (/* binding */ InputClassesFactory)
/* harmony export */ });
/* harmony import */ var _KeyboardController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KeyboardController */ "../../library/dist/esm/Inputs/KeyboardController.js");
/* harmony import */ var _MouseControllerLocked__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MouseControllerLocked */ "../../library/dist/esm/Inputs/MouseControllerLocked.js");
/* harmony import */ var _MouseControllerHovering__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MouseControllerHovering */ "../../library/dist/esm/Inputs/MouseControllerHovering.js");
/* harmony import */ var _TouchController__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TouchController */ "../../library/dist/esm/Inputs/TouchController.js");
/* harmony import */ var _TouchControllerFake__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TouchControllerFake */ "../../library/dist/esm/Inputs/TouchControllerFake.js");
/* harmony import */ var _GamepadController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GamepadController */ "../../library/dist/esm/Inputs/GamepadController.js");
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.








/**
 * Class for making and setting up input class types
 */
class InputClassesFactory {
    /**
     * @param toStreamerMessagesProvider - Stream message instance
     * @param videoElementProvider - Video Player instance
     * @param coordinateConverter - A coordinateConverter instance
     */
    constructor(toStreamerMessagesProvider, videoElementProvider, coordinateConverter) {
        this.activeKeys = new ActiveKeys();
        this.toStreamerMessagesProvider = toStreamerMessagesProvider;
        this.videoElementProvider = videoElementProvider;
        this.coordinateConverter = coordinateConverter;
    }
    /**
     * Registers browser key events.
     */
    registerKeyBoard(config) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Register Keyboard Events');
        const keyboardController = new _KeyboardController__WEBPACK_IMPORTED_MODULE_1__.KeyboardController(this.toStreamerMessagesProvider, config, this.activeKeys);
        keyboardController.register();
        return keyboardController;
    }
    /**
     * register mouse events based on a control type
     * @param controlScheme - if the mouse is either hovering or locked
     */
    registerMouse(controlScheme) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Register Mouse Events');
        let mouseController;
        if (controlScheme == _Config_Config__WEBPACK_IMPORTED_MODULE_2__.ControlSchemeType.HoveringMouse) {
            mouseController = new _MouseControllerHovering__WEBPACK_IMPORTED_MODULE_3__.MouseControllerHovering(this.toStreamerMessagesProvider, this.videoElementProvider, this.coordinateConverter, this.activeKeys);
        }
        else {
            mouseController = new _MouseControllerLocked__WEBPACK_IMPORTED_MODULE_4__.MouseControllerLocked(this.toStreamerMessagesProvider, this.videoElementProvider, this.coordinateConverter, this.activeKeys);
        }
        mouseController.register();
        return mouseController;
    }
    /**
     * register touch events
     * @param fakeMouseTouch - the faked mouse touch event
     */
    registerTouch(fakeMouseTouch) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Registering Touch');
        let touchController;
        if (fakeMouseTouch) {
            touchController = new _TouchControllerFake__WEBPACK_IMPORTED_MODULE_5__.TouchControllerFake(this.toStreamerMessagesProvider, this.videoElementProvider, this.coordinateConverter);
        }
        else {
            touchController = new _TouchController__WEBPACK_IMPORTED_MODULE_6__.TouchController(this.toStreamerMessagesProvider, this.videoElementProvider, this.coordinateConverter);
        }
        touchController.register();
        return touchController;
    }
    /**
     * registers a gamepad
     */
    registerGamePad() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Register Game Pad');
        const gamepadController = new _GamepadController__WEBPACK_IMPORTED_MODULE_7__.GamepadController(this.toStreamerMessagesProvider);
        gamepadController.register();
        return gamepadController;
    }
}
/**
 * A class that keeps track of current active keys
 */
class ActiveKeys {
    constructor() {
        this.activeKeys = [];
        this.activeKeys = [];
    }
    /**
     * Get the current array of active keys
     * @returns - an array of active keys
     */
    getActiveKeys() {
        return this.activeKeys;
    }
}
//# sourceMappingURL=InputClassesFactory.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/KeyCodes.js":
/*!*************************************************!*\
  !*** ../../library/dist/esm/Inputs/KeyCodes.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CodeToKeyCode: () => (/* binding */ CodeToKeyCode)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/*
 * New browser APIs have moved away from KeyboardEvent.keyCode to KeyboardEvent.Code.
 * For details see: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#constants_for_keycode_value
 * We still use old KeyboardEvent.keyCode integers in the UE C++ side, so we need a way to map the new
 * string-based KeyboardEvent.Code to the old integers.
 */
const CodeToKeyCode = Object.freeze({
    Escape: 27,
    Digit0: 48,
    Digit1: 49,
    Digit2: 50,
    Digit3: 51,
    Digit4: 52,
    Digit5: 53,
    Digit6: 54,
    Digit7: 55,
    Digit8: 56,
    Digit9: 57,
    Minus: 173,
    Equal: 187,
    Backspace: 8,
    Tab: 9,
    KeyQ: 81,
    KeyW: 87,
    KeyE: 69,
    KeyR: 82,
    KeyT: 84,
    KeyY: 89,
    KeyU: 85,
    KeyI: 73,
    KeyO: 79,
    KeyP: 80,
    BracketLeft: 219,
    BracketRight: 221,
    Enter: 13,
    ControlLeft: 17,
    KeyA: 65,
    KeyS: 83,
    KeyD: 68,
    KeyF: 70,
    KeyG: 71,
    KeyH: 72,
    KeyJ: 74,
    KeyK: 75,
    KeyL: 76,
    Semicolon: 186,
    Quote: 222,
    Backquote: 192,
    ShiftLeft: 16,
    Backslash: 220,
    KeyZ: 90,
    KeyX: 88,
    KeyC: 67,
    KeyV: 86,
    KeyB: 66,
    KeyN: 78,
    KeyM: 77,
    Comma: 188,
    Period: 190,
    Slash: 191,
    ShiftRight: 253,
    AltLeft: 18,
    Space: 32,
    CapsLock: 20,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    Pause: 19,
    ScrollLock: 145,
    NumpadDivide: 111,
    NumpadMultiply: 106,
    NumpadSubtract: 109,
    NumpadAdd: 107,
    NumpadDecimal: 110,
    Numpad9: 105,
    Numpad8: 104,
    Numpad7: 103,
    Numpad6: 102,
    Numpad5: 101,
    Numpad4: 100,
    Numpad3: 99,
    Numpad2: 98,
    Numpad1: 97,
    Numpad0: 96,
    NumLock: 144,
    ControlRight: 254,
    AltRight: 255,
    Home: 36,
    End: 35,
    ArrowUp: 38,
    ArrowLeft: 37,
    ArrowRight: 39,
    ArrowDown: 40,
    PageUp: 33,
    PageDown: 34,
    Insert: 45,
    Delete: 46,
    ContextMenu: 93
});
//# sourceMappingURL=KeyCodes.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/KeyboardController.js":
/*!***********************************************************!*\
  !*** ../../library/dist/esm/Inputs/KeyboardController.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeyboardController: () => (/* binding */ KeyboardController)
/* harmony export */ });
/* harmony import */ var _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SpecialKeyCodes */ "../../library/dist/esm/Inputs/SpecialKeyCodes.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _KeyCodes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./KeyCodes */ "../../library/dist/esm/Inputs/KeyCodes.js");
// Copyright Epic Games, Inc. All Rights Reserved.




/**
 * Handles the Keyboard Inputs for the document
 */
class KeyboardController {
    constructor(streamMessageController, config, activeKeys) {
        this.streamMessageController = streamMessageController;
        this.config = config;
        this.activeKeys = activeKeys;
        this.onKeyDownListener = this.handleOnKeyDown.bind(this);
        this.onKeyUpListener = this.handleOnKeyUp.bind(this);
        this.onKeyPressListener = this.handleOnKeyPress.bind(this);
    }
    register() {
        document.addEventListener('keydown', this.onKeyDownListener);
        document.addEventListener('keyup', this.onKeyUpListener);
        //This has been deprecated as at Jun 13 2021
        document.addEventListener('keypress', this.onKeyPressListener);
    }
    unregister() {
        document.removeEventListener('keydown', this.onKeyDownListener);
        document.removeEventListener('keyup', this.onKeyUpListener);
        document.removeEventListener('keypress', this.onKeyPressListener);
    }
    handleOnKeyDown(keyboardEvent) {
        var _a;
        const keyCode = this.getKeycode(keyboardEvent);
        if (!keyCode || keyCode === 229) {
            return;
        }
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        (_a = toStreamerHandlers.get('KeyDown')) === null || _a === void 0 ? void 0 : _a([this.getKeycode(keyboardEvent), keyboardEvent.repeat ? 1 : 0]);
        const activeKeys = this.activeKeys.getActiveKeys();
        activeKeys.push(keyCode);
        // Backspace is not considered a keypress in JavaScript but we need it
        // to be so characters may be deleted in a UE text entry field.
        // since keypress is deprecated we really should be sending all keys to keypress
        // or we change everything to handle the deprecation of these parts
        if (keyCode === _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.backSpace) {
            this.handleOnKeyPress(new KeyboardEvent('keypress', {
                charCode: _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.backSpace,
                keyCode: _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.backSpace
            }));
        }
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.SuppressBrowserKeys) && this.isKeyCodeBrowserKey(keyCode)) {
            keyboardEvent.preventDefault();
        }
    }
    handleOnKeyUp(keyboardEvent) {
        var _a;
        const keyCode = this.getKeycode(keyboardEvent);
        if (!keyCode) {
            return;
        }
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        (_a = toStreamerHandlers.get('KeyUp')) === null || _a === void 0 ? void 0 : _a([keyCode]);
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.SuppressBrowserKeys) && this.isKeyCodeBrowserKey(keyCode)) {
            keyboardEvent.preventDefault();
        }
    }
    handleOnKeyPress(keyboardEvent) {
        var _a;
        const keyCode = this.getKeycode(keyboardEvent);
        if (!keyCode) {
            return;
        }
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        (_a = toStreamerHandlers.get('KeyPress')) === null || _a === void 0 ? void 0 : _a([keyCode]);
    }
    /**
     * Gets the Keycode of the Key pressed
     * @param keyboardEvent - Key board Event
     * @returns - the key code of the Key
     */
    getKeycode(keyboardEvent) {
        // If we don't have keyCode property because browser API is deprecated then use KeyboardEvent.code instead.
        // See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#constants_for_keycode_value
        if (!('keyCode' in keyboardEvent)) {
            // this type assertion here is required because if 'keyCode' doesnt exist in keyboardEvent then
            // it cannot be a KeyboardEvent and so it gets narrowed to 'never'
            const event = keyboardEvent;
            // Convert KeyboardEvent.code string into integer-based key code for backwards compatibility reasons.
            if (event.code in _KeyCodes__WEBPACK_IMPORTED_MODULE_2__.CodeToKeyCode) {
                return _KeyCodes__WEBPACK_IMPORTED_MODULE_2__.CodeToKeyCode[event.code];
            }
            else {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Keyboard code of ${event.code} is not supported in our mapping, ignoring this key.`);
                return null;
            }
        }
        // If we made it here KeyboardEvent.keyCode is still supported so we can safely use it.
        if (keyboardEvent.keyCode === _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.shift && keyboardEvent.code === 'ShiftRight') {
            return _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.rightShift;
        }
        else if (keyboardEvent.keyCode === _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.control &&
            keyboardEvent.code === 'ControlRight') {
            return _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.rightControl;
        }
        else if (keyboardEvent.keyCode === _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.alt && keyboardEvent.code === 'AltRight') {
            return _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.rightAlt;
        }
        else {
            return keyboardEvent.keyCode;
        }
    }
    /**
     * Browser keys do not have a charCode so we only need to test keyCode.
     * @param keyCode - the browser keycode number
     */
    isKeyCodeBrowserKey(keyCode) {
        // Function keys or tab key are considered "browser keys" that we may wish to suppress by preventing them being process by browser.
        return (keyCode >= 112 && keyCode <= 123) || keyCode === 9;
    }
}
//# sourceMappingURL=KeyboardController.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/MouseButtons.js":
/*!*****************************************************!*\
  !*** ../../library/dist/esm/Inputs/MouseButtons.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MouseButton: () => (/* binding */ MouseButton),
/* harmony export */   MouseButtonsMask: () => (/* binding */ MouseButtonsMask)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Mouse Button Data
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button}
 */
class MouseButton {
}
MouseButton.mainButton = 0; // Left button.
MouseButton.auxiliaryButton = 1; // Wheel button.
MouseButton.secondaryButton = 2; // Right button.
MouseButton.fourthButton = 3; // Browser Back button.
MouseButton.fifthButton = 4; // Browser Forward button.
/**
 * Mouse Button Mask Data
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons}
 */
class MouseButtonsMask {
}
MouseButtonsMask.primaryButton = 1; // Left button.
MouseButtonsMask.secondaryButton = 2; // Right button.
MouseButtonsMask.auxiliaryButton = 4; // Wheel button.
MouseButtonsMask.fourthButton = 8; // Browser Back button.
MouseButtonsMask.fifthButton = 16; // Browser Forward button.
//# sourceMappingURL=MouseButtons.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/MouseController.js":
/*!********************************************************!*\
  !*** ../../library/dist/esm/Inputs/MouseController.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MouseController: () => (/* binding */ MouseController)
/* harmony export */ });
/* harmony import */ var _MouseButtons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MouseButtons */ "../../library/dist/esm/Inputs/MouseButtons.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * The base class for mouse controllers. Since there is a bunch of shared behaviour between locked and
 * hover mouse controllers this is where that shared behaviour lives.
 */
class MouseController {
    constructor(streamMessageController, videoPlayer, coordinateConverter, activeKeys) {
        this.streamMessageController = streamMessageController;
        this.coordinateConverter = coordinateConverter;
        this.videoPlayer = videoPlayer;
        this.activeKeys = activeKeys;
        this.onEnterListener = this.onMouseEnter.bind(this);
        this.onLeaveListener = this.onMouseLeave.bind(this);
    }
    register() {
        this.registerMouseEnterAndLeaveEvents();
    }
    unregister() {
        this.unregisterMouseEnterAndLeaveEvents();
    }
    registerMouseEnterAndLeaveEvents() {
        const videoElementParent = this.videoPlayer.getVideoParentElement();
        videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.addEventListener('mouseenter', this.onEnterListener);
        videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.addEventListener('mouseleave', this.onLeaveListener);
    }
    unregisterMouseEnterAndLeaveEvents() {
        const videoElementParent = this.videoPlayer.getVideoParentElement();
        videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.removeEventListener('mouseenter', this.onEnterListener);
        videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.removeEventListener('mouseleave', this.onLeaveListener);
    }
    onMouseEnter(event) {
        var _a;
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        (_a = this.streamMessageController.toStreamerHandlers.get('MouseEnter')) === null || _a === void 0 ? void 0 : _a();
        this.pressMouseButtons(event.buttons, event.x, event.y);
    }
    onMouseLeave(event) {
        var _a;
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        (_a = this.streamMessageController.toStreamerHandlers.get('MouseLeave')) === null || _a === void 0 ? void 0 : _a();
        this.releaseMouseButtons(event.buttons, event.x, event.y);
    }
    releaseMouseButtons(buttons, X, Y) {
        const coord = this.coordinateConverter.translateUnsigned(X, Y);
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.primaryButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.mainButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.secondaryButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.secondaryButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.auxiliaryButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.auxiliaryButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.fourthButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.fourthButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.fifthButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.fifthButton, coord.x, coord.y);
        }
    }
    pressMouseButtons(buttons, X, Y) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(X, Y);
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.primaryButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.mainButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.secondaryButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.secondaryButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.auxiliaryButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.auxiliaryButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.fourthButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.fourthButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.fifthButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.fifthButton, coord.x, coord.y);
        }
    }
    sendMouseDown(button, X, Y) {
        var _a;
        (_a = this.streamMessageController.toStreamerHandlers.get('MouseDown')) === null || _a === void 0 ? void 0 : _a([button, X, Y]);
    }
    sendMouseUp(button, X, Y) {
        var _a;
        const coord = this.coordinateConverter.translateUnsigned(X, Y);
        (_a = this.streamMessageController.toStreamerHandlers.get('MouseUp')) === null || _a === void 0 ? void 0 : _a([button, coord.x, coord.y]);
    }
}
//# sourceMappingURL=MouseController.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/MouseControllerHovering.js":
/*!****************************************************************!*\
  !*** ../../library/dist/esm/Inputs/MouseControllerHovering.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MouseControllerHovering: () => (/* binding */ MouseControllerHovering)
/* harmony export */ });
/* harmony import */ var _MouseController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MouseController */ "../../library/dist/esm/Inputs/MouseController.js");

/**
 * A mouse controller that allows the mouse to freely float over the video document.
 */
class MouseControllerHovering extends _MouseController__WEBPACK_IMPORTED_MODULE_0__.MouseController {
    constructor(streamMessageController, videoPlayer, coordinateConverter, activeKeys) {
        super(streamMessageController, videoPlayer, coordinateConverter, activeKeys);
        this.videoElementParent = videoPlayer.getVideoParentElement();
        this.onMouseUpListener = this.onMouseUp.bind(this);
        this.onMouseDownListener = this.onMouseDown.bind(this);
        this.onMouseDblClickListener = this.onMouseDblClick.bind(this);
        this.onMouseWheelListener = this.onMouseWheel.bind(this);
        this.onMouseMoveListener = this.onMouseMove.bind(this);
        this.onContextMenuListener = this.onContextMenu.bind(this);
    }
    register() {
        super.register();
        this.videoElementParent.addEventListener('mousemove', this.onMouseMoveListener);
        this.videoElementParent.addEventListener('mousedown', this.onMouseDownListener);
        this.videoElementParent.addEventListener('mouseup', this.onMouseUpListener);
        this.videoElementParent.addEventListener('contextmenu', this.onContextMenuListener);
        this.videoElementParent.addEventListener('wheel', this.onMouseWheelListener);
        this.videoElementParent.addEventListener('dblclick', this.onMouseDblClickListener);
    }
    unregister() {
        this.videoElementParent.removeEventListener('mousemove', this.onMouseMoveListener);
        this.videoElementParent.removeEventListener('mousedown', this.onMouseDownListener);
        this.videoElementParent.removeEventListener('mouseup', this.onMouseUpListener);
        this.videoElementParent.removeEventListener('contextmenu', this.onContextMenuListener);
        this.videoElementParent.removeEventListener('wheel', this.onMouseWheelListener);
        this.videoElementParent.removeEventListener('dblclick', this.onMouseDblClickListener);
        super.unregister();
    }
    onMouseDown(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        this.streamMessageController.toStreamerHandlers.get('MouseDown')([event.button, coord.x, coord.y]);
        event.preventDefault();
    }
    onMouseUp(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        this.streamMessageController.toStreamerHandlers.get('MouseUp')([event.button, coord.x, coord.y]);
        event.preventDefault();
    }
    onContextMenu(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        event.preventDefault();
    }
    onMouseMove(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        const delta = this.coordinateConverter.translateSigned(event.movementX, event.movementY);
        this.streamMessageController.toStreamerHandlers.get('MouseMove')([
            coord.x,
            coord.y,
            delta.x,
            delta.y
        ]);
        event.preventDefault();
    }
    onMouseWheel(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        this.streamMessageController.toStreamerHandlers.get('MouseWheel')([
            event.wheelDelta,
            coord.x,
            coord.y
        ]);
        event.preventDefault();
    }
    onMouseDblClick(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        this.streamMessageController.toStreamerHandlers.get('MouseDouble')([event.button, coord.x, coord.y]);
    }
}
//# sourceMappingURL=MouseControllerHovering.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/MouseControllerLocked.js":
/*!**************************************************************!*\
  !*** ../../library/dist/esm/Inputs/MouseControllerLocked.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MouseControllerLocked: () => (/* binding */ MouseControllerLocked)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _MouseController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MouseController */ "../../library/dist/esm/Inputs/MouseController.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * A mouse controller that locks the mouse to the video document and prevents it from leaving the window
 */
class MouseControllerLocked extends _MouseController__WEBPACK_IMPORTED_MODULE_0__.MouseController {
    constructor(streamMessageController, videoPlayer, coordinateConverter, activeKeys) {
        super(streamMessageController, videoPlayer, coordinateConverter, activeKeys);
        this.videoElementParent = videoPlayer.getVideoParentElement();
        this.x = this.videoElementParent.getBoundingClientRect().width / 2;
        this.y = this.videoElementParent.getBoundingClientRect().height / 2;
        this.normalizedCoord = this.coordinateConverter.translateUnsigned(this.x, this.y);
        this.onRequestLockListener = this.onRequestLock.bind(this);
        this.onLockStateChangeListener = this.onLockStateChange.bind(this);
        this.onMouseUpListener = this.onMouseUp.bind(this);
        this.onMouseDownListener = this.onMouseDown.bind(this);
        this.onMouseDblClickListener = this.onMouseDblClick.bind(this);
        this.onMouseWheelListener = this.onMouseWheel.bind(this);
        this.onMouseMoveListener = this.onMouseMove.bind(this);
    }
    register() {
        super.register();
        this.videoElementParent.requestPointerLock =
            this.videoElementParent.requestPointerLock || this.videoElementParent.mozRequestPointerLock;
        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
        if (this.videoElementParent.requestPointerLock) {
            this.videoElementParent.addEventListener('click', this.onRequestLockListener);
        }
        document.addEventListener('pointerlockchange', this.onLockStateChangeListener);
        document.addEventListener('mozpointerlockchange', this.onLockStateChangeListener);
        this.videoElementParent.addEventListener('mousedown', this.onMouseDownListener);
        this.videoElementParent.addEventListener('mouseup', this.onMouseUpListener);
        this.videoElementParent.addEventListener('wheel', this.onMouseWheelListener);
        this.videoElementParent.addEventListener('dblclick', this.onMouseDblClickListener);
    }
    unregister() {
        const pointerLockElement = document.pointerLockElement || document.mozPointerLockElement;
        if (document.exitPointerLock && pointerLockElement === this.videoElementParent) {
            document.exitPointerLock();
        }
        this.videoElementParent.removeEventListener('click', this.onRequestLockListener);
        document.removeEventListener('pointerlockchange', this.onLockStateChangeListener);
        document.removeEventListener('mozpointerlockchange', this.onLockStateChangeListener);
        document.removeEventListener('mousemove', this.onMouseMoveListener);
        this.videoElementParent.removeEventListener('mousedown', this.onMouseDownListener);
        this.videoElementParent.removeEventListener('mouseup', this.onMouseUpListener);
        this.videoElementParent.removeEventListener('wheel', this.onMouseWheelListener);
        this.videoElementParent.removeEventListener('dblclick', this.onMouseDblClickListener);
        super.unregister();
    }
    onRequestLock() {
        this.videoElementParent.requestPointerLock();
    }
    onLockStateChange() {
        const pointerLockElement = document.pointerLockElement || document.mozPointerLockElement;
        if (pointerLockElement === this.videoElementParent) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Pointer locked');
            document.addEventListener('mousemove', this.onMouseMoveListener);
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('The pointer lock status is now unlocked');
            document.removeEventListener('mousemove', this.onMouseMoveListener);
            // If mouse loses focus, send a key up for all of the currently held-down keys
            // This is necessary as when the mouse loses focus, the windows stops listening for events and as such
            // the keyup listener won't get fired
            const activeKeys = this.activeKeys.getActiveKeys();
            activeKeys.forEach((key) => {
                this.streamMessageController.toStreamerHandlers.get('KeyUp')([key]);
            });
        }
    }
    onMouseDown(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.streamMessageController.toStreamerHandlers.get('MouseDown')([
            event.button,
            // We use the store value of this.coord as opposed to the mouseEvent.x/y as the mouseEvent location
            // uses the system cursor location which hasn't moved
            this.normalizedCoord.x,
            this.normalizedCoord.y
        ]);
    }
    onMouseUp(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.streamMessageController.toStreamerHandlers.get('MouseUp')([
            event.button,
            // We use the store value of this.coord as opposed to the mouseEvent.x/y as the mouseEvent location
            // uses the system cursor location which hasn't moved
            this.normalizedCoord.x,
            this.normalizedCoord.y
        ]);
    }
    onMouseMove(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const styleWidth = this.videoPlayer.getVideoParentElement().clientWidth;
        const styleHeight = this.videoPlayer.getVideoParentElement().clientHeight;
        this.x += event.movementX;
        this.y += event.movementY;
        while (this.x > styleWidth) {
            this.x -= styleWidth;
        }
        while (this.y > styleHeight) {
            this.y -= styleHeight;
        }
        while (this.x < 0) {
            this.x += styleWidth;
        }
        while (this.y < 0) {
            this.y += styleHeight;
        }
        this.normalizedCoord = this.coordinateConverter.translateUnsigned(this.x, this.y);
        const delta = this.coordinateConverter.translateSigned(event.movementX, event.movementY);
        this.streamMessageController.toStreamerHandlers.get('MouseMove')([
            this.normalizedCoord.x,
            this.normalizedCoord.y,
            delta.x,
            delta.y
        ]);
    }
    onMouseWheel(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.streamMessageController.toStreamerHandlers.get('MouseWheel')([
            event.wheelDelta,
            // We use the store value of this.coord as opposed to the mouseEvent.x/y as the mouseEvent location
            // uses the system cursor location which hasn't moved
            this.normalizedCoord.x,
            this.normalizedCoord.y
        ]);
    }
    onMouseDblClick(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.streamMessageController.toStreamerHandlers.get('MouseDouble')([
            event.button,
            // We use the store value of this.coord as opposed to the mouseEvent.x/y as the mouseEvent location
            // uses the system cursor location which hasn't moved
            this.normalizedCoord.x,
            this.normalizedCoord.y
        ]);
    }
}
//# sourceMappingURL=MouseControllerLocked.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/SpecialKeyCodes.js":
/*!********************************************************!*\
  !*** ../../library/dist/esm/Inputs/SpecialKeyCodes.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpecialKeyCodes: () => (/* binding */ SpecialKeyCodes)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Registers the Special Key codes
 *  Must be kept in sync with JavaScriptKeyCodeToFKey C++ array.
 * The index of the entry in the array is the special key code given below.
 */
class SpecialKeyCodes {
}
SpecialKeyCodes.backSpace = 8;
SpecialKeyCodes.shift = 16;
SpecialKeyCodes.control = 17;
SpecialKeyCodes.alt = 18;
SpecialKeyCodes.rightShift = 253;
SpecialKeyCodes.rightControl = 254;
SpecialKeyCodes.rightAlt = 255;
//# sourceMappingURL=SpecialKeyCodes.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/TouchController.js":
/*!********************************************************!*\
  !*** ../../library/dist/esm/Inputs/TouchController.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TouchController: () => (/* binding */ TouchController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * The basic touch controller that handles the touch events on the document.
 */
class TouchController {
    constructor(streamMessageController, videoPlayer, coordinateConverter) {
        this.fingers = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0];
        this.fingerIds = new Map();
        this.maxByteValue = 255;
        this.streamMessageController = streamMessageController;
        this.videoPlayer = videoPlayer;
        this.coordinateConverter = coordinateConverter;
        this.videoElementParent = videoPlayer.getVideoElement();
        this.onTouchStartListener = this.onTouchStart.bind(this);
        this.onTouchEndListener = this.onTouchEnd.bind(this);
        this.onTouchMoveListener = this.onTouchMove.bind(this);
    }
    register() {
        this.videoElementParent.addEventListener('touchstart', this.onTouchStartListener);
        this.videoElementParent.addEventListener('touchend', this.onTouchEndListener);
        this.videoElementParent.addEventListener('touchmove', this.onTouchMoveListener);
    }
    unregister() {
        this.videoElementParent.removeEventListener('touchstart', this.onTouchStartListener);
        this.videoElementParent.removeEventListener('touchend', this.onTouchEndListener);
        this.videoElementParent.removeEventListener('touchmove', this.onTouchMoveListener);
    }
    rememberTouch(touch) {
        const finger = this.fingers.pop();
        if (finger === undefined) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('exhausted touch identifiers');
        }
        this.fingerIds.set(touch.identifier, finger);
    }
    forgetTouch(touch) {
        this.fingers.push(this.fingerIds.get(touch.identifier));
        // Sort array back into descending order. This means if finger '1' were to lift after finger '0', we would ensure that 0 will be the first index to pop
        this.fingers.sort(function (a, b) {
            return b - a;
        });
        this.fingerIds.delete(touch.identifier);
    }
    onTouchStart(touchEvent) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        for (let t = 0; t < touchEvent.changedTouches.length; t++) {
            this.rememberTouch(touchEvent.changedTouches[t]);
        }
        this.emitTouchData('TouchStart', touchEvent.changedTouches);
        touchEvent.preventDefault();
    }
    onTouchEnd(touchEvent) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.emitTouchData('TouchEnd', touchEvent.changedTouches);
        // Re-cycle unique identifiers previously assigned to each touch.
        for (let t = 0; t < touchEvent.changedTouches.length; t++) {
            this.forgetTouch(touchEvent.changedTouches[t]);
        }
        touchEvent.preventDefault();
    }
    onTouchMove(touchEvent) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.emitTouchData('TouchMove', touchEvent.touches);
        touchEvent.preventDefault();
    }
    emitTouchData(type, touches) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const offset = this.videoPlayer.getVideoParentElement().getBoundingClientRect();
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        for (let t = 0; t < touches.length; t++) {
            const numTouches = 1; // the number of touches to be sent this message
            const touch = touches[t];
            const x = touch.clientX - offset.left;
            const y = touch.clientY - offset.top;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`F${this.fingerIds.get(touch.identifier)}=(${x}, ${y})`);
            const coord = this.coordinateConverter.translateUnsigned(x, y);
            switch (type) {
                case 'TouchStart':
                    toStreamerHandlers.get('TouchStart')([
                        numTouches,
                        coord.x,
                        coord.y,
                        this.fingerIds.get(touch.identifier),
                        this.maxByteValue * (touch.force > 0 ? touch.force : 1),
                        coord.inRange ? 1 : 0
                    ]);
                    break;
                case 'TouchEnd':
                    toStreamerHandlers.get('TouchEnd')([
                        numTouches,
                        coord.x,
                        coord.y,
                        this.fingerIds.get(touch.identifier),
                        this.maxByteValue * touch.force,
                        coord.inRange ? 1 : 0
                    ]);
                    break;
                case 'TouchMove':
                    toStreamerHandlers.get('TouchMove')([
                        numTouches,
                        coord.x,
                        coord.y,
                        this.fingerIds.get(touch.identifier),
                        this.maxByteValue * (touch.force > 0 ? touch.force : 1),
                        coord.inRange ? 1 : 0
                    ]);
                    break;
            }
        }
    }
}
//# sourceMappingURL=TouchController.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/TouchControllerFake.js":
/*!************************************************************!*\
  !*** ../../library/dist/esm/Inputs/TouchControllerFake.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TouchControllerFake: () => (/* binding */ TouchControllerFake)
/* harmony export */ });
/* harmony import */ var _MouseButtons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MouseButtons */ "../../library/dist/esm/Inputs/MouseButtons.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Allows for the usage of fake touch events
 */
class TouchControllerFake {
    constructor(streamMessageController, videoPlayer, coordinateConverter) {
        this.streamMessageController = streamMessageController;
        this.videoPlayer = videoPlayer;
        this.coordinateConverter = coordinateConverter;
        this.onTouchStartListener = this.onTouchStart.bind(this);
        this.onTouchEndListener = this.onTouchEnd.bind(this);
        this.onTouchMoveListener = this.onTouchMove.bind(this);
        this.videoElementParentClientRect = this.videoPlayer.getVideoParentElement().getBoundingClientRect();
    }
    register() {
        document.addEventListener('touchstart', this.onTouchStartListener);
        document.addEventListener('touchend', this.onTouchEndListener);
        document.addEventListener('touchmove', this.onTouchMoveListener);
    }
    unregister() {
        document.removeEventListener('touchstart', this.onTouchStartListener);
        document.removeEventListener('touchend', this.onTouchEndListener);
        document.removeEventListener('touchmove', this.onTouchMoveListener);
    }
    onTouchStart(touch) {
        if (!this.videoPlayer.isVideoReady() || touch.target !== this.videoPlayer.getVideoElement()) {
            return;
        }
        if (this.fakeTouchFinger == null) {
            const first_touch = touch.changedTouches[0];
            this.fakeTouchFinger = {
                id: first_touch.identifier,
                x: first_touch.clientX - this.videoElementParentClientRect.left,
                y: first_touch.clientY - this.videoElementParentClientRect.top
            };
            const videoElementParent = this.videoPlayer.getVideoParentElement();
            const mouseEvent = new MouseEvent('mouseenter', first_touch);
            videoElementParent.dispatchEvent(mouseEvent);
            const coord = this.coordinateConverter.translateUnsigned(this.fakeTouchFinger.x, this.fakeTouchFinger.y);
            const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
            toStreamerHandlers.get('MouseDown')([_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.mainButton, coord.x, coord.y]);
        }
        touch.preventDefault();
    }
    onTouchEnd(touchEvent) {
        if (!this.videoPlayer.isVideoReady() || this.fakeTouchFinger == null) {
            return;
        }
        const videoElementParent = this.videoPlayer.getVideoParentElement();
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        for (let t = 0; t < touchEvent.changedTouches.length; t++) {
            const touch = touchEvent.changedTouches[t];
            if (touch.identifier === this.fakeTouchFinger.id) {
                const x = touch.clientX - this.videoElementParentClientRect.left;
                const y = touch.clientY - this.videoElementParentClientRect.top;
                const coord = this.coordinateConverter.translateUnsigned(x, y);
                toStreamerHandlers.get('MouseUp')([_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.mainButton, coord.x, coord.y]);
                const mouseEvent = new MouseEvent('mouseleave', touch);
                videoElementParent.dispatchEvent(mouseEvent);
                this.fakeTouchFinger = null;
                break;
            }
        }
        touchEvent.preventDefault();
    }
    onTouchMove(touchEvent) {
        if (!this.videoPlayer.isVideoReady() || this.fakeTouchFinger == null) {
            return;
        }
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        for (let t = 0; t < touchEvent.touches.length; t++) {
            const touch = touchEvent.touches[t];
            if (touch.identifier === this.fakeTouchFinger.id) {
                const x = touch.clientX - this.videoElementParentClientRect.left;
                const y = touch.clientY - this.videoElementParentClientRect.top;
                const coord = this.coordinateConverter.translateUnsigned(x, y);
                const delta = this.coordinateConverter.translateSigned(x - this.fakeTouchFinger.x, y - this.fakeTouchFinger.y);
                toStreamerHandlers.get('MouseMove')([coord.x, coord.y, delta.x, delta.y]);
                this.fakeTouchFinger.x = x;
                this.fakeTouchFinger.y = y;
                break;
            }
        }
        touchEvent.preventDefault();
    }
}
//# sourceMappingURL=TouchControllerFake.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/XRGamepadController.js":
/*!************************************************************!*\
  !*** ../../library/dist/esm/Inputs/XRGamepadController.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   XRGamepadController: () => (/* binding */ XRGamepadController)
/* harmony export */ });
/* harmony import */ var _GamepadTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GamepadTypes */ "../../library/dist/esm/Inputs/GamepadTypes.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * The class that handles the functionality of XR gamepads and controllers.
 */
class XRGamepadController {
    /**
     * @param toStreamerMessagesProvider - Stream message instance
     */
    constructor(toStreamerMessagesProvider) {
        this.toStreamerMessagesProvider = toStreamerMessagesProvider;
        this.controllers = [];
    }
    updateStatus(source, frame, refSpace) {
        if (source.gamepad) {
            const gamepadPose = frame.getPose(source.gripSpace, refSpace);
            if (!gamepadPose) {
                return;
            }
            let system = 0;
            if (source.profiles.includes('htc-vive')) {
                system = 1;
            }
            else if (source.profiles.includes('oculus-touch')) {
                system = 2;
            }
            // TODO (william.belcher): Add other profiles (Quest, Microsoft Mixed Reality, etc)
            this.toStreamerMessagesProvider.toStreamerHandlers.get('XRSystem')([system]);
            // Default: AnyHand (2)
            let handedness = 2;
            switch (source.handedness) {
                case 'left':
                    handedness = 0;
                    break;
                case 'right':
                    handedness = 1;
                    break;
            }
            // Send controller transform
            const matrix = gamepadPose.transform.matrix;
            const mat = [];
            for (let i = 0; i < 16; i++) {
                mat[i] = new Float32Array([matrix[i]])[0];
            }
            // prettier-ignore
            this.toStreamerMessagesProvider.toStreamerHandlers.get('XRControllerTransform')([
                mat[0], mat[4], mat[8], mat[12],
                mat[1], mat[5], mat[9], mat[13],
                mat[2], mat[6], mat[10], mat[14],
                mat[3], mat[7], mat[11], mat[15],
                handedness
            ]);
            // Handle controller buttons and axes
            if (this.controllers[handedness] === undefined) {
                this.controllers[handedness] = {
                    prevState: undefined,
                    currentState: undefined,
                    id: undefined
                };
                this.controllers[handedness].prevState = (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(source.gamepad);
            }
            this.controllers[handedness].currentState = (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(source.gamepad);
            const controller = this.controllers[handedness];
            const currState = controller.currentState;
            const prevState = controller.prevState;
            // Iterate over buttons
            for (let i = 0; i < currState.buttons.length; i++) {
                const currButton = currState.buttons[i];
                const prevButton = prevState.buttons[i];
                if (currButton.pressed) {
                    // press
                    const isRepeat = prevButton.pressed ? 1 : 0;
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRButtonPressed')([
                        handedness,
                        i,
                        isRepeat,
                        currButton.value
                    ]);
                }
                else if (prevButton.pressed) {
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRButtonReleased')([
                        handedness,
                        i,
                        0
                    ]);
                }
                if (currButton.touched) {
                    // touched
                    const isRepeat = prevButton.touched ? 1 : 0;
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRButtonTouched')([
                        handedness,
                        i,
                        isRepeat
                    ]);
                }
                else if (prevButton.touched) {
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRButtonTouchReleased')([
                        handedness,
                        i,
                        0
                    ]);
                }
            }
            // Iterate over gamepad axes
            for (let i = 0; i < currState.axes.length; i++) {
                const curAxisValue = currState.axes[i];
                const prevAxisValue = prevState.axes[i];
                // Only send axis update if there is a change
                if (curAxisValue != prevAxisValue) {
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRAnalog')([
                        handedness,
                        i,
                        curAxisValue
                    ]);
                }
            }
            this.controllers[handedness].prevState = currState;
        }
    }
}
//# sourceMappingURL=XRGamepadController.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/AggregatedStats.js":
/*!**************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/AggregatedStats.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AggregatedStats: () => (/* binding */ AggregatedStats)
/* harmony export */ });
/* harmony import */ var _InboundRTPStats__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InboundRTPStats */ "../../library/dist/esm/PeerConnectionController/InboundRTPStats.js");
/* harmony import */ var _DataChannelStats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DataChannelStats */ "../../library/dist/esm/PeerConnectionController/DataChannelStats.js");
/* harmony import */ var _CandidateStat__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CandidateStat */ "../../library/dist/esm/PeerConnectionController/CandidateStat.js");
/* harmony import */ var _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OutBoundRTPStats */ "../../library/dist/esm/PeerConnectionController/OutBoundRTPStats.js");
/* harmony import */ var _SessionStats__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SessionStats */ "../../library/dist/esm/PeerConnectionController/SessionStats.js");
/* harmony import */ var _StreamStats__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./StreamStats */ "../../library/dist/esm/PeerConnectionController/StreamStats.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.







/**
 * The Aggregated Stats that is generated from the RTC Stats Report
 */
class AggregatedStats {
    constructor() {
        this.inboundVideoStats = new _InboundRTPStats__WEBPACK_IMPORTED_MODULE_0__.InboundVideoStats();
        this.inboundAudioStats = new _InboundRTPStats__WEBPACK_IMPORTED_MODULE_0__.InboundAudioStats();
        this.candidatePairs = new Array();
        this.datachannelStats = new _DataChannelStats__WEBPACK_IMPORTED_MODULE_1__.DataChannelStats();
        this.localCandidates = new Array();
        this.remoteCandidates = new Array();
        this.outboundVideoStats = new _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__.OutboundRTPStats();
        this.outboundAudioStats = new _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__.OutboundRTPStats();
        this.remoteOutboundAudioStats = new _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__.RemoteOutboundRTPStats();
        this.remoteOutboundVideoStats = new _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__.RemoteOutboundRTPStats();
        this.sessionStats = new _SessionStats__WEBPACK_IMPORTED_MODULE_3__.SessionStats();
        this.streamStats = new _StreamStats__WEBPACK_IMPORTED_MODULE_4__.StreamStats();
        this.codecs = new Map();
    }
    /**
     * Gather all the information from the RTC Peer Connection Report
     * @param rtcStatsReport - RTC Stats Report
     */
    processStats(rtcStatsReport) {
        this.localCandidates = new Array();
        this.remoteCandidates = new Array();
        this.candidatePairs = new Array();
        rtcStatsReport.forEach((stat) => {
            const type = stat.type;
            switch (type) {
                case 'candidate-pair':
                    this.handleCandidatePair(stat);
                    break;
                case 'certificate':
                    break;
                case 'codec':
                    this.handleCodec(stat);
                    break;
                case 'data-channel':
                    this.handleDataChannel(stat);
                    break;
                case 'inbound-rtp':
                    this.handleInboundRTP(stat);
                    break;
                case 'local-candidate':
                    this.handleLocalCandidate(stat);
                    break;
                case 'media-source':
                    break;
                case 'media-playout':
                    break;
                case 'outbound-rtp':
                    this.handleLocalOutbound(stat);
                    break;
                case 'peer-connection':
                    break;
                case 'remote-candidate':
                    this.handleRemoteCandidate(stat);
                    break;
                case 'remote-inbound-rtp':
                    break;
                case 'remote-outbound-rtp':
                    this.handleRemoteOutbound(stat);
                    break;
                case 'track':
                    this.handleTrack(stat);
                    break;
                case 'transport':
                    this.handleTransport(stat);
                    break;
                case 'stream':
                    this.handleStream(stat);
                    break;
                default:
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Logger.Error('unhandled Stat Type');
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Logger.Info(stat);
                    break;
            }
        });
    }
    /**
     * Process stream stats data from webrtc
     *
     * @param stat - the stats coming in from webrtc
     */
    handleStream(stat) {
        this.streamStats = stat;
    }
    /**
     * Process the Ice Candidate Pair Data
     * @param stat - the stats coming in from ice candidates
     */
    handleCandidatePair(stat) {
        // Add the candidate pair to the candidate pair array
        this.candidatePairs.push(stat);
    }
    /**
     * Process the Data Channel Data
     * @param stat - the stats coming in from the data channel
     */
    handleDataChannel(stat) {
        this.datachannelStats.bytesReceived = stat.bytesReceived;
        this.datachannelStats.bytesSent = stat.bytesSent;
        this.datachannelStats.dataChannelIdentifier = stat.dataChannelIdentifier;
        this.datachannelStats.id = stat.id;
        this.datachannelStats.label = stat.label;
        this.datachannelStats.messagesReceived = stat.messagesReceived;
        this.datachannelStats.messagesSent = stat.messagesSent;
        this.datachannelStats.protocol = stat.protocol;
        this.datachannelStats.state = stat.state;
        this.datachannelStats.timestamp = stat.timestamp;
    }
    /**
     * Process the Local Ice Candidate Data
     * @param stat - local stats
     */
    handleLocalCandidate(stat) {
        const localCandidate = new _CandidateStat__WEBPACK_IMPORTED_MODULE_6__.CandidateStat();
        localCandidate.label = 'local-candidate';
        localCandidate.address = stat.address;
        localCandidate.port = stat.port;
        localCandidate.protocol = stat.protocol;
        localCandidate.candidateType = stat.candidateType;
        localCandidate.id = stat.id;
        localCandidate.relayProtocol = stat.relayProtocol;
        localCandidate.transportId = stat.transportId;
        this.localCandidates.push(localCandidate);
    }
    /**
     * Process the Remote Ice Candidate Data
     * @param stat - ice candidate stats
     */
    handleRemoteCandidate(stat) {
        const remoteCandidate = new _CandidateStat__WEBPACK_IMPORTED_MODULE_6__.CandidateStat();
        remoteCandidate.label = 'remote-candidate';
        remoteCandidate.address = stat.address;
        remoteCandidate.port = stat.port;
        remoteCandidate.protocol = stat.protocol;
        remoteCandidate.id = stat.id;
        remoteCandidate.candidateType = stat.candidateType;
        remoteCandidate.relayProtocol = stat.relayProtocol;
        remoteCandidate.transportId = stat.transportId;
        this.remoteCandidates.push(remoteCandidate);
    }
    /**
     * Process the Inbound RTP Audio and Video Data
     * @param stat - inbound rtp stats
     */
    handleInboundRTP(stat) {
        switch (stat.kind) {
            case 'video':
                // Calculate bitrate between stat updates
                if (stat.bytesReceived > this.inboundVideoStats.bytesReceived &&
                    stat.timestamp > this.inboundVideoStats.timestamp) {
                    this.inboundVideoStats.bitrate =
                        (8 * (stat.bytesReceived - this.inboundVideoStats.bytesReceived)) /
                            (stat.timestamp - this.inboundVideoStats.timestamp);
                    this.inboundVideoStats.bitrate = Math.floor(this.inboundVideoStats.bitrate);
                }
                // Copy members from stat into `this.inboundVideoStats`
                for (const key in stat) {
                    this.inboundVideoStats[key] = stat[key];
                }
                break;
            case 'audio':
                if (stat.bytesReceived > this.inboundAudioStats.bytesReceived &&
                    stat.timestamp > this.inboundAudioStats.timestamp) {
                    this.inboundAudioStats.bitrate =
                        (8 * (stat.bytesReceived - this.inboundAudioStats.bytesReceived)) /
                            (stat.timestamp - this.inboundAudioStats.timestamp);
                    this.inboundAudioStats.bitrate = Math.floor(this.inboundAudioStats.bitrate);
                }
                // Copy members from stat into `this.inboundAudioStats`
                for (const key in stat) {
                    this.inboundAudioStats[key] = stat[key];
                }
                break;
            default:
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Logger.Error(`Kind should be audio or video, we got ${stat.kind} - that's unsupported.`);
                break;
        }
    }
    /**
     * Process the "local" outbound RTP Audio and Video stats.
     * @param stat - local outbound rtp stats
     */
    handleLocalOutbound(stat) {
        const localOutboundStats = stat.kind === 'audio' ? this.outboundAudioStats : this.outboundVideoStats;
        localOutboundStats.active = stat.active;
        localOutboundStats.codecId = stat.codecId;
        localOutboundStats.bytesSent = stat.bytesSent;
        localOutboundStats.frameHeight = stat.frameHeight;
        localOutboundStats.frameWidth = stat.frameWidth;
        localOutboundStats.framesEncoded = stat.framesEncoded;
        localOutboundStats.framesPerSecond = stat.framesPerSecond;
        localOutboundStats.headerBytesSent = stat.headerBytesSent;
        localOutboundStats.id = stat.id;
        localOutboundStats.keyFramesEncoded = stat.keyFramesEncoded;
        localOutboundStats.kind = stat.kind;
        localOutboundStats.mediaSourceId = stat.mediaSourceId;
        localOutboundStats.mid = stat.mid;
        localOutboundStats.nackCount = stat.nackCount;
        localOutboundStats.packetsSent = stat.packetsSent;
        localOutboundStats.qpSum = stat.qpSum;
        localOutboundStats.qualityLimitationDurations = stat.qualityLimitationDurations;
        localOutboundStats.qualityLimitationReason = stat.qualityLimitationReason;
        localOutboundStats.remoteId = stat.remoteId;
        localOutboundStats.retransmittedBytesSent = stat.retransmittedBytesSent;
        localOutboundStats.rid = stat.rid;
        localOutboundStats.scalabilityMode = stat.scalabilityMode;
        localOutboundStats.ssrc = stat.ssrc;
        localOutboundStats.targetBitrate = stat.targetBitrate;
        localOutboundStats.timestamp = stat.timestamp;
        localOutboundStats.totalEncodeTime = stat.totalEncodeTime;
        localOutboundStats.totalEncodeBytesTarget = stat.totalEncodeBytesTarget;
        localOutboundStats.totalPacketSendDelay = stat.totalPacketSendDelay;
        localOutboundStats.transportId = stat.transportId;
    }
    /**
     * Process the "remote" outbound RTP Audio and Video stats.
     * @param stat - remote outbound rtp stats
     */
    handleRemoteOutbound(stat) {
        const remoteOutboundStats = stat.kind === 'audio' ? this.remoteOutboundAudioStats : this.remoteOutboundVideoStats;
        remoteOutboundStats.bytesSent = stat.bytesSent;
        remoteOutboundStats.codecId = stat.codecId;
        remoteOutboundStats.id = stat.id;
        remoteOutboundStats.kind = stat.kind;
        remoteOutboundStats.localId = stat.localId;
        remoteOutboundStats.packetsSent = stat.packetsSent;
        remoteOutboundStats.remoteTimestamp = stat.remoteTimestamp;
        remoteOutboundStats.reportsSent = stat.reportsSent;
        remoteOutboundStats.roundTripTimeMeasurements = stat.roundTripTimeMeasurements;
        remoteOutboundStats.ssrc = stat.ssrc;
        remoteOutboundStats.timestamp = stat.timestamp;
        remoteOutboundStats.totalRoundTripTime = stat.totalRoundTripTime;
        remoteOutboundStats.transportId = stat.transportId;
    }
    /**
     * Process the Inbound Video Track Data
     * @param stat - video track stats
     */
    handleTrack(stat) {
        // we only want to extract stats from the video track
        if (stat.type === 'track' && (stat.trackIdentifier === 'video_label' || stat.kind === 'video')) {
            this.inboundVideoStats.framesDropped = stat.framesDropped;
            this.inboundVideoStats.framesReceived = stat.framesReceived;
            this.inboundVideoStats.frameHeight = stat.frameHeight;
            this.inboundVideoStats.frameWidth = stat.frameWidth;
        }
    }
    handleTransport(stat) {
        this.transportStats = stat;
    }
    handleCodec(stat) {
        const codecId = stat.id;
        this.codecs.set(codecId, stat);
    }
    handleSessionStatistics(videoStartTime, inputController, videoEncoderAvgQP) {
        const deltaTime = Date.now() - videoStartTime;
        this.sessionStats.runTime = new Date(deltaTime).toISOString().substr(11, 8).toString();
        const controlsStreamInput = inputController === null ? 'Not sent yet' : inputController ? 'true' : 'false';
        this.sessionStats.controlsStreamInput = controlsStreamInput;
        this.sessionStats.videoEncoderAvgQP = videoEncoderAvgQP;
    }
    /**
     * Check if a value coming in from our stats is actually a number
     * @param value - the number to be checked
     */
    isNumber(value) {
        return typeof value === 'number' && isFinite(value);
    }
    /**
     * Helper function to return the active candidate pair
     * @returns The candidate pair that is currently receiving data
     */
    getActiveCandidatePair() {
        if (this.candidatePairs === undefined) {
            return null;
        }
        // Check if the RTCTransport stat is not undefined
        if (this.transportStats) {
            // Return the candidate pair that matches the transport candidate pair id
            const selectedPair = this.candidatePairs.find((candidatePair) => candidatePair.id === this.transportStats.selectedCandidatePairId);
            if (selectedPair === undefined) {
                return null;
            }
            else {
                return selectedPair;
            }
        }
        // Fall back to the `.selected` member of the candidate pair
        const selectedPair = this.candidatePairs.find((candidatePair) => candidatePair.selected);
        if (selectedPair === undefined) {
            return null;
        }
        else {
            return selectedPair;
        }
    }
}
//# sourceMappingURL=AggregatedStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/CandidateStat.js":
/*!************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/CandidateStat.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CandidateStat: () => (/* binding */ CandidateStat)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * ICE Candidate Stat collected from the RTC Stats Report
 */
class CandidateStat {
}
//# sourceMappingURL=CandidateStat.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/DataChannelStats.js":
/*!***************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/DataChannelStats.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataChannelStats: () => (/* binding */ DataChannelStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Data Channel Stats collected from the RTC Stats Report
 */
class DataChannelStats {
}
//# sourceMappingURL=DataChannelStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/InboundRTPStats.js":
/*!**************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/InboundRTPStats.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InboundAudioStats: () => (/* binding */ InboundAudioStats),
/* harmony export */   InboundRTPStats: () => (/* binding */ InboundRTPStats),
/* harmony export */   InboundVideoStats: () => (/* binding */ InboundVideoStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Inbound Audio Stats collected from the RTC Stats Report
 */
class InboundAudioStats {
}
/**
 * Inbound Video Stats collected from the RTC Stats Report
 */
class InboundVideoStats {
}
/**
 * Inbound Stats collected from the RTC Stats Report
 */
class InboundRTPStats {
}
//# sourceMappingURL=InboundRTPStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/LatencyCalculator.js":
/*!****************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/LatencyCalculator.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FrameTimingInfo: () => (/* binding */ FrameTimingInfo),
/* harmony export */   LatencyCalculator: () => (/* binding */ LatencyCalculator),
/* harmony export */   LatencyInfo: () => (/* binding */ LatencyInfo)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Represents either a:
 * - synchronization source: https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpReceiver/getSynchronizationSources
 * - contributing source: https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpReceiver/getContributingSources
 * Which also (if browser supports it) may optionall contain fields for captureTimestamp + senderCaptureTimeOffset
 * if the abs-capture-time RTP header extension is enabled (currently this only works in Chromium based browsers).
 */
class RTCRtpCaptureSource {
}
/**
 * FrameTimingInfo is a Chromium-specific set of WebRTC stats useful for latency calculation. It is stored in WebRTC stats as `googTimingFrameInfo`.
 * It is defined as an RTP header extension here: https://webrtc.googlesource.com/src/+/refs/heads/main/docs/native-code/rtp-hdrext/video-timing/README.md
 * It is defined in source code here: https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/api/video/video_timing.cc;l=82;drc=8d399817282e3c12ed54eb23ec42a5e418298ec6
 * It is discussed by its author here: https://github.com/w3c/webrtc-provisional-stats/issues/40#issuecomment-1272916692
 * In summary it a comma-delimited string that contains the following (in this order):
 * 1)  RTP timestamp: the RTP timestamp of the frame
 * 2)  Capture time: timestamp when this frame was captured
 * 3)  Encode start: timestamp when this frame started to be encoded
 * 4)  Encode finish: timestamp when this frame finished encoding
 * 5)  Packetization finish: timestamp when this frame was split into packets and was ready to be sent over the network
 * 6)  Pacer exit: timestamp when last packet of this frame was sent over the network by the sender at this timestamp
 * 7)  Network timestamp1: place for the SFU to mark when the frame started being forwarded. Application specific.
 * 8)  Network timestamp2: place for the SFU to mark when the frame finished being forwarded. Application specific.
 * 9)  Receive start: timestamp when the first packet of this frame was received
 * 10) Receive finish: timestamp when the last packet of this frame was received
 * 11) Decode start:  timestamp when the frame was passed to decoder
 * 12) Decode finish:  timestamp when the frame was decoded
 * 13) Render time:  timestamp of the projected render time for this frame
 * 14) "is outlier": a flag for if this frame is bigger in encoded size than the average frame by at least 5x.
 * 15) "triggered by timer": a flag for if this report was triggered by the timer (The report is sent every 200ms)
 */
class FrameTimingInfo {
}
/**
 * Calculates a combination of latency statistics using purely WebRTC API.
 */
class LatencyCalculator {
    constructor() {
        /* Clock offset between peer clocks cannot always be calculated as it relies of latest sender reports.
         * so we store the last time we had a valid clock offset in the assumption that clocks haven't drifted too much since then.
         */
        this.latestSenderRecvClockOffset = null;
    }
    calculate(stats, receivers) {
        const latencyInfo = new LatencyInfo();
        const rttMS = this.getRTTMs(stats);
        if (rttMS != null) {
            latencyInfo.rttMs = rttMS;
            // Calculate sender latency using the first valid video ssrc/csrc
            const captureSource = this.getCaptureSource(receivers);
            if (captureSource != null) {
                const senderLatencyMs = this.calculateSenderLatency(stats, captureSource);
                if (senderLatencyMs !== null) {
                    latencyInfo.senderLatencyMs = senderLatencyMs;
                }
            }
        }
        // https://w3c.github.io/webrtc-stats/#dom-rtcinboundrtpstreamstats-totalprocessingdelay
        if (stats.inboundVideoStats.totalProcessingDelay !== undefined &&
            stats.inboundVideoStats.framesDecoded !== undefined) {
            latencyInfo.averageProcessingDelayMs =
                (stats.inboundVideoStats.totalProcessingDelay / stats.inboundVideoStats.framesDecoded) * 1000;
        }
        // https://w3c.github.io/webrtc-stats/#dom-rtcinboundrtpstreamstats-jitterbufferminimumdelay
        if (stats.inboundVideoStats.jitterBufferDelay !== undefined &&
            stats.inboundVideoStats.jitterBufferEmittedCount !== undefined) {
            latencyInfo.averageJitterBufferDelayMs =
                (stats.inboundVideoStats.jitterBufferDelay /
                    stats.inboundVideoStats.jitterBufferEmittedCount) *
                    1000;
        }
        // https://w3c.github.io/webrtc-stats/#dom-rtcinboundrtpstreamstats-totaldecodetime
        if (stats.inboundVideoStats.framesDecoded !== undefined &&
            stats.inboundVideoStats.totalDecodeTime !== undefined) {
            latencyInfo.averageDecodeLatencyMs =
                (stats.inboundVideoStats.totalDecodeTime / stats.inboundVideoStats.framesDecoded) * 1000;
        }
        // https://w3c.github.io/webrtc-stats/#dom-rtcinboundrtpstreamstats-framesassembledfrommultiplepackets
        if (stats.inboundVideoStats.totalAssemblyTime !== undefined &&
            stats.inboundVideoStats.framesAssembledFromMultiplePackets !== undefined) {
            latencyInfo.averageAssemblyDelayMs =
                (stats.inboundVideoStats.totalAssemblyTime /
                    stats.inboundVideoStats.framesAssembledFromMultiplePackets) *
                    1000;
        }
        // Extract extra Chrome-specific stats like encoding latency
        if (stats.inboundVideoStats.googTimingFrameInfo !== undefined &&
            stats.inboundVideoStats.googTimingFrameInfo.length > 0) {
            latencyInfo.frameTiming = this.extractFrameTimingInfo(stats.inboundVideoStats.googTimingFrameInfo);
        }
        // Calculate E2E latency using video-timing capture to send time + one way network latency + receiver-side latency
        if (latencyInfo.frameTiming !== undefined &&
            latencyInfo.frameTiming.captureToSendLatencyMs !== undefined &&
            latencyInfo.averageProcessingDelayMs !== undefined &&
            latencyInfo.rttMs !== undefined) {
            latencyInfo.averageE2ELatency =
                latencyInfo.frameTiming.captureToSendLatencyMs +
                    latencyInfo.rttMs * 0.5 +
                    latencyInfo.averageProcessingDelayMs;
        }
        // Calculate E2E latency as abs-capture-time capture to send latency + one way network latency + receiver-side latency
        if (latencyInfo.senderLatencyMs != undefined &&
            latencyInfo.averageProcessingDelayMs !== undefined &&
            latencyInfo.rttMs !== undefined) {
            latencyInfo.averageE2ELatency =
                latencyInfo.senderLatencyMs + latencyInfo.rttMs * 0.5 + latencyInfo.averageProcessingDelayMs;
        }
        return latencyInfo;
    }
    extractFrameTimingInfo(googTimingFrameInfo) {
        const timingInfo = new FrameTimingInfo();
        const timingInfoArr = googTimingFrameInfo.split(',');
        // Should have exactly 15 elements according to:
        // https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/api/video/video_timing.cc;l=82;drc=8d399817282e3c12ed54eb23ec42a5e418298ec6
        if (timingInfoArr.length === 15) {
            timingInfo.rtpTimestamp = Number.parseInt(timingInfoArr[0]);
            timingInfo.captureTimestamp = Number.parseInt(timingInfoArr[1]);
            timingInfo.encodeStartTimestamp = Number.parseInt(timingInfoArr[2]);
            timingInfo.encodeFinishTimestamp = Number.parseInt(timingInfoArr[3]);
            timingInfo.packetizerFinishTimestamp = Number.parseInt(timingInfoArr[4]);
            timingInfo.pacerExitTimestamp = Number.parseInt(timingInfoArr[5]);
            timingInfo.networkTimestamp1 = Number.parseInt(timingInfoArr[6]);
            timingInfo.networkTimestamp2 = Number.parseInt(timingInfoArr[7]);
            timingInfo.receiveStart = Number.parseInt(timingInfoArr[8]);
            timingInfo.receiveFinish = Number.parseInt(timingInfoArr[9]);
            timingInfo.decodeStart = Number.parseInt(timingInfoArr[10]);
            timingInfo.decodeFinish = Number.parseInt(timingInfoArr[11]);
            timingInfo.renderTime = Number.parseInt(timingInfoArr[12]);
            timingInfo.isOutlier = Number.parseInt(timingInfoArr[13]) > 0;
            timingInfo.isTriggeredByTimer = Number.parseInt(timingInfoArr[14]) > 0;
            // Calculate some latency stats
            timingInfo.encoderLatencyMs = timingInfo.encodeFinishTimestamp - timingInfo.encodeStartTimestamp;
            timingInfo.packetizeLatencyMs =
                timingInfo.packetizerFinishTimestamp - timingInfo.encodeFinishTimestamp;
            timingInfo.pacerLatencyMs = timingInfo.pacerExitTimestamp - timingInfo.packetizerFinishTimestamp;
            timingInfo.captureToSendLatencyMs = timingInfo.pacerExitTimestamp - timingInfo.captureTimestamp;
        }
        return timingInfo;
    }
    calculateSenderLatency(stats, captureSource) {
        // The calculation performed in this function is as per the procedure defined here:
        // https://w3c.github.io/webrtc-extensions/#dom-rtcrtpcontributingsource-sendercapturetimeoffset
        // Get the sender capture in the sender's clock
        const senderCaptureTimestamp = captureSource.captureTimestamp + captureSource.senderCaptureTimeOffset;
        let sendRecvClockOffset = this.calculateSenderReceiverClockOffset(stats);
        // Use latest clock offset if we couldn't calculate one now
        if (sendRecvClockOffset == null) {
            if (this.latestSenderRecvClockOffset != null) {
                sendRecvClockOffset = this.latestSenderRecvClockOffset;
            }
            else {
                return null;
            }
        }
        else {
            this.latestSenderRecvClockOffset = sendRecvClockOffset;
        }
        // This brings sender clock roughly inline with recv clock
        const recvCaptureTimestampNTP = senderCaptureTimestamp + sendRecvClockOffset;
        // As defined in Chrome source: https://chromium.googlesource.com/external/webrtc/+/master/system_wrappers/include/clock.h#26
        const ntp1970 = 2208988800000;
        const recvCaptureTimestamp = recvCaptureTimestampNTP - ntp1970;
        const senderLatency = captureSource.timestamp - recvCaptureTimestamp;
        return senderLatency;
    }
    /**
     * Find the first valid ssrc or csrc that has capture time fields present from abs-capture-time header extension.
     * @param receivers The RTP receviers this peer connection has.
     * @returns A single valid ssrc or csrc that has capture time fields or null if there is none (e.g. in non-chromium browsers it will be null).
     */
    getCaptureSource(receivers) {
        // We only want video receivers
        receivers = receivers.filter((receiver) => receiver.track.kind === 'video');
        for (const receiver of receivers) {
            // Go through all ssrc and csrc to check for capture timestamp
            // Note: Conversion to `any` here is because TS does not have captureTimestamp etc defined in the types
            // these fields only exist in Chromium currently.
            const sources = receiver
                .getSynchronizationSources()
                .concat(receiver.getContributingSources());
            for (const src of sources) {
                if (src.captureTimestamp !== undefined &&
                    src.senderCaptureTimeOffset !== undefined &&
                    src.timestamp !== undefined) {
                    const captureSrc = new RTCRtpCaptureSource();
                    captureSrc.timestamp = src.timestamp;
                    captureSrc.captureTimestamp = src.captureTimestamp;
                    captureSrc.senderCaptureTimeOffset = src.senderCaptureTimeOffset;
                    return captureSrc;
                }
            }
        }
        return null;
    }
    calculateSenderReceiverClockOffset(stats) {
        // The calculation performed in this function is as per the procedure defined here:
        // https://w3c.github.io/webrtc-extensions/#dom-rtcrtpcontributingsource-sendercapturetimeoffset
        const hasRemoteOutboundVideoStats = stats.remoteOutboundVideoStats !== undefined &&
            stats.remoteOutboundVideoStats.timestamp !== undefined &&
            stats.remoteOutboundVideoStats.remoteTimestamp !== undefined;
        // Note: As of Chrome 132, remote-outbound-rtp stats for video are not yet implemented (audio works).
        // This codepath should activate once they do begin to work.
        if (!hasRemoteOutboundVideoStats) {
            return null;
        }
        const remoteStatsArrivedTimestamp = stats.remoteOutboundVideoStats.timestamp;
        const remoteStatsSentTimestamp = stats.remoteOutboundVideoStats.remoteTimestamp;
        const rttMs = this.getRTTMs(stats);
        if (remoteStatsArrivedTimestamp !== undefined &&
            remoteStatsSentTimestamp !== undefined &&
            rttMs !== null) {
            const onewayDelay = rttMs * 0.5;
            return remoteStatsArrivedTimestamp - (remoteStatsSentTimestamp + onewayDelay);
        }
        // Could not get stats to calculate sender/receiver clock offset
        else {
            return null;
        }
    }
    getRTTMs(stats) {
        // Try to get it from the active candidate pair
        const activeCandidatePair = stats.getActiveCandidatePair();
        if (!!activeCandidatePair && activeCandidatePair.currentRoundTripTime !== undefined) {
            const curRTTSeconds = activeCandidatePair.currentRoundTripTime;
            return curRTTSeconds * 1000;
        }
        // Next try to get it from remote-outbound-rtp video stats
        if (!!stats.remoteOutboundVideoStats &&
            stats.remoteOutboundVideoStats.totalRoundTripTime !== undefined &&
            stats.remoteOutboundVideoStats.roundTripTimeMeasurements !== undefined &&
            stats.remoteOutboundVideoStats.roundTripTimeMeasurements > 0) {
            const avgRttSeconds = stats.remoteOutboundVideoStats.totalRoundTripTime /
                stats.remoteOutboundVideoStats.roundTripTimeMeasurements;
            return avgRttSeconds * 1000;
        }
        // Next try to get it from remote-outbound-rtp audio stats
        if (!!stats.remoteOutboundAudioStats &&
            stats.remoteOutboundAudioStats.totalRoundTripTime !== undefined &&
            stats.remoteOutboundAudioStats.roundTripTimeMeasurements !== undefined &&
            stats.remoteOutboundAudioStats.roundTripTimeMeasurements > 0) {
            const avgRttSeconds = stats.remoteOutboundAudioStats.totalRoundTripTime /
                stats.remoteOutboundAudioStats.roundTripTimeMeasurements;
            return avgRttSeconds * 1000;
        }
        return null;
    }
}
/**
 * A collection of latency information calculated using the WebRTC API.
 * Most stats are calculated following the spec:
 * https://w3c.github.io/webrtc-stats/#dictionary-rtcinboundrtpstreamstats-members
 */
class LatencyInfo {
    constructor() {
        /**
         * The time taken from the moment a frame is done capturing to the moment it is sent over the network.
         * Note: This can only be calculated if both offer and answer contain the
         * the RTP header extension for `video-timing` (Chrome only for now)
         */
        this.senderLatencyMs = undefined;
        /**
         * The time taken from the moment a frame is done capturing to the moment it is sent over the network.
         * Note: This can only be calculated if both offer and answer contain the
         * the RTP header extension for `abs-capture-time` (Chrome only for now)
         */
        this.senderLatencyAbsCaptureTimeMs = undefined;
        /* The round trip time (milliseconds) between each sender->receiver->sender */
        this.rttMs = undefined;
        /* Average time taken (milliseconds) from video packet receipt to post-decode. */
        this.averageProcessingDelayMs = undefined;
        /* Average time taken (milliseconds) inside the jitter buffer (which is post-receipt but pre-decode). */
        this.averageJitterBufferDelayMs = undefined;
        /* Average time taken (milliseconds) to decode a video frame. */
        this.averageDecodeLatencyMs = undefined;
        /* Average time taken (milliseconds) to between receipt of the first and last video packet of a. */
        this.averageAssemblyDelayMs = undefined;
        /* The sender latency + RTT/2 + processing delay */
        this.averageE2ELatency = undefined;
        /* Timing information about the worst performing frame since the last getStats call (only works on Chrome) */
        this.frameTiming = undefined;
    }
}
//# sourceMappingURL=LatencyCalculator.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/OutBoundRTPStats.js":
/*!***************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/OutBoundRTPStats.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OutboundRTPStats: () => (/* binding */ OutboundRTPStats),
/* harmony export */   RemoteOutboundRTPStats: () => (/* binding */ RemoteOutboundRTPStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Outbound RTP stats collected from the RTC Stats Report under `outbound-rtp`.
 * Wrapper around: https://developer.mozilla.org/en-US/docs/Web/API/RTCOutboundRtpStreamStats
 * These are stats for video we are sending to a remote peer.
 */
class OutboundRTPStats {
}
/**
 * Remote outbound stats collected from the RTC Stats Report under `remote-outbound-rtp`.
 * Wrapper around: https://developer.mozilla.org/en-US/docs/Web/API/RTCRemoteOutboundRtpStreamStats
 * These are stats for media we are receiving from a remote peer.
 */
class RemoteOutboundRTPStats {
}
//# sourceMappingURL=OutBoundRTPStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/PeerConnectionController.js":
/*!***********************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/PeerConnectionController.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PeerConnectionController: () => (/* binding */ PeerConnectionController),
/* harmony export */   kAbsCaptureTime: () => (/* binding */ kAbsCaptureTime)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _AggregatedStats__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AggregatedStats */ "../../library/dist/esm/PeerConnectionController/AggregatedStats.js");
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sdp */ "../../../node_modules/sdp/sdp.js");
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sdp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Util_RTCUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Util/RTCUtils */ "../../library/dist/esm/Util/RTCUtils.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Util/SdpUtils.js");
/* harmony import */ var _LatencyCalculator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LatencyCalculator */ "../../library/dist/esm/PeerConnectionController/LatencyCalculator.js");
// Copyright Epic Games, Inc. All Rights Reserved.
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







const kAbsCaptureTime = 'http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time';
/**
 * Handles the Peer Connection
 */
class PeerConnectionController {
    /**
     * Create a new RTC Peer Connection client
     * @param options - Peer connection Options
     * @param config - The config for our PS experience.
     */
    constructor(options, config, preferredCodec) {
        this.config = config;
        this.createPeerConnection(options, preferredCodec);
        this.latencyCalculator = new _LatencyCalculator__WEBPACK_IMPORTED_MODULE_1__.LatencyCalculator();
    }
    createPeerConnection(options, preferredCodec) {
        // Set the ICE transport to relay if TURN enabled
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.ForceTURN)) {
            options.iceTransportPolicy = 'relay';
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('Forcing TURN usage by setting ICE Transport Policy in peer connection config.');
        }
        // build a new peer connection with the options
        this.peerConnection = new RTCPeerConnection(options);
        this.peerConnection.onsignalingstatechange = (ev) => this.handleSignalStateChange(ev);
        this.peerConnection.oniceconnectionstatechange = (ev) => this.handleIceConnectionStateChange(ev);
        this.peerConnection.onicegatheringstatechange = (ev) => this.handleIceGatheringStateChange(ev);
        this.peerConnection.ontrack = (ev) => this.handleOnTrack(ev);
        this.peerConnection.onicecandidate = (ev) => this.handleIceCandidate(ev);
        this.peerConnection.ondatachannel = (ev) => this.handleDataChannel(ev);
        this.aggregatedStats = new _AggregatedStats__WEBPACK_IMPORTED_MODULE_4__.AggregatedStats();
        this.preferredCodec = preferredCodec;
        this.updateCodecSelection = true;
    }
    /**
     * Create an offer for the Web RTC handshake and send the offer to the signaling server via websocket
     * @param offerOptions - RTC Offer Options
     */
    createOffer(offerOptions, config) {
        return __awaiter(this, void 0, void 0, function* () {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('Create Offer');
            const isLocalhostConnection = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
            const isHttpsConnection = location.protocol === 'https:';
            let useMic = config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.UseMic);
            let useCamera = config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.UseCamera);
            if ((useMic || useCamera) && !(isLocalhostConnection || isHttpsConnection)) {
                useMic = false;
                useCamera = false;
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error('Microphone and Webcam access in the browser will not work if you are not on HTTPS or localhost. Disabling mic and webcam access.');
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error("For testing you can enable HTTP microphone access Chrome by visiting chrome://flags/ and enabling 'unsafely-treat-insecure-origin-as-secure'");
            }
            this.setupTransceiversAsync(useMic, useCamera).finally(() => {
                var _a;
                (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.createOffer(offerOptions).then((offer) => {
                    var _a;
                    this.showTextOverlayConnecting();
                    offer.sdp = this.mungeSDP(offer.sdp, useMic);
                    (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setLocalDescription(offer);
                    this.onSendWebRTCOffer(offer);
                }).catch(() => {
                    this.showTextOverlaySetupFailure();
                });
            });
        });
    }
    /**
     * Receive offer from UE side and process it as the remote description of this peer connection
     */
    receiveOffer(offer, config) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('Receive Offer');
            // If UE or JSStreamer did send abs-capture-time RTP header extension to a non-Chrome browser
            // then remove it from the SDP because if Firefox detects it in offer or answer it will fail to connect
            // due having 15 or more header extensions: https://mailarchive.ietf.org/arch/msg/rtcweb/QRnWNuWzGuLRovWdHkodNP6VOgg/
            if (this.isFirefox()) {
                // example: a=extmap:15 http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time
                offer.sdp = offer.sdp.replace(/^a=extmap:\d+ http:\/\/www\.webrtc\.org\/experiments\/rtp-hdrext\/abs-capture-time\r\n/gm, '');
            }
            (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setRemoteDescription(offer).then(() => {
                // Fire event for when remote offer description is set
                this.onSetRemoteDescription(offer);
                const isLocalhostConnection = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
                const isHttpsConnection = location.protocol === 'https:';
                let useMic = config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.UseMic);
                let useCamera = config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.UseCamera);
                if ((useMic || useCamera) && !(isLocalhostConnection || isHttpsConnection)) {
                    useMic = false;
                    useCamera = false;
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error('Microphone and Webcam access in the browser will not work if you are not on HTTPS or localhost. Disabling mic and webcam access.');
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error("For testing you can enable HTTP microphone access Chrome by visiting chrome://flags/ and enabling 'unsafely-treat-insecure-origin-as-secure'");
                }
                // Add our list of preferred codecs, in order of preference
                this.config.setOptionSettingOptions(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec, this.fuzzyIntersectUEAndBrowserCodecs(offer));
                this.setupTransceiversAsync(useMic, useCamera).finally(() => {
                    var _a;
                    (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.createAnswer().then((Answer) => {
                        var _a;
                        Answer.sdp = this.mungeSDP(Answer.sdp, useMic);
                        return (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setLocalDescription(Answer);
                    }).then(() => {
                        var _a;
                        this.onSetLocalDescription((_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.localDescription);
                    }).catch((err) => {
                        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error(`createAnswer() failed - ${err}`);
                    });
                });
            });
        });
    }
    /**
     * Set the Remote Descriptor from the signaling server to the RTC Peer Connection
     * @param answer - RTC Session Descriptor from the Signaling Server
     */
    receiveAnswer(answer) {
        var _a;
        (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setRemoteDescription(answer);
        // Add our list of preferred codecs, in order of preference
        this.config.setOptionSettingOptions(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec, this.fuzzyIntersectUEAndBrowserCodecs(answer));
    }
    /**
     * Generate Aggregated Stats and then fire a onVideo Stats event
     */
    generateStats() {
        this.peerConnection.getStats().then((statsData) => {
            this.aggregatedStats.processStats(statsData);
            this.onVideoStats(this.aggregatedStats);
            // Calculate latency using stats and video receivers and then call the handling function
            const latencyInfo = this.latencyCalculator.calculate(this.aggregatedStats, this.peerConnection.getReceivers());
            this.onLatencyCalculated(latencyInfo);
            // Update the preferred codec selection based on what was actually negotiated
            if (this.updateCodecSelection && !!this.aggregatedStats.inboundVideoStats.codecId) {
                // Construct the qualified codec name from the mimetype and fmtp
                const codecStats = this.aggregatedStats.codecs.get(this.aggregatedStats.inboundVideoStats.codecId);
                if (codecStats === undefined) {
                    return;
                }
                const codecShortname = codecStats.mimeType.replace('video/', '');
                let fullCodecName = codecShortname;
                if (codecStats.sdpFmtpLine && codecStats.sdpFmtpLine.trim() !== '') {
                    fullCodecName = `${codecShortname} ${codecStats.sdpFmtpLine.trim()}`;
                }
                const allBrowserCodecs = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec).options;
                // The list of codecs directly contains the one that was negotiated, select that
                if (allBrowserCodecs.includes(fullCodecName)) {
                    this.config.setOptionSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec, fullCodecName);
                    return;
                }
                // If we couldn't match on the full name, try to match on just the codec shortname
                const filteredList = allBrowserCodecs.filter((option) => option.indexOf(codecShortname) !== -1);
                if (filteredList.length > 0) {
                    this.config.setOptionSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec, filteredList[0]);
                    return;
                }
            }
        });
    }
    /**
     * Close The Peer Connection
     */
    close() {
        if (this.peerConnection) {
            this.peerConnection.close();
            this.peerConnection = null;
        }
    }
    /**
     * Modify the Session Descriptor
     * @param sdp - Session Descriptor as a string
     * @param useMic - Is the microphone in use
     * @returns A modified Session Descriptor
     */
    mungeSDP(sdp, useMic) {
        let mungedSDP = sdp.replace(/(a=fmtp:\d+ .*level-asymmetry-allowed=.*)\r\n/gm, '$1;x-google-start-bitrate=10000;x-google-max-bitrate=100000\r\n');
        // set max bitrate to highest bitrate Opus supports
        let audioSDP = 'maxaveragebitrate=510000;';
        if (useMic) {
            // set the max capture rate to 48khz (so we can send high quality audio from mic)
            audioSDP += 'sprop-maxcapturerate=48000;';
        }
        // Force mono or stereo based on whether ?forceMono was passed or not
        audioSDP += this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.ForceMonoAudio) ? 'stereo=0;' : 'stereo=1;';
        // enable in-band forward error correction for opus audio
        audioSDP += 'useinbandfec=1';
        // We use the line 'useinbandfec=1' (which Opus uses) to set our Opus specific audio parameters.
        mungedSDP = mungedSDP.replace('useinbandfec=1', audioSDP);
        // Add abs-capture-time RTP header extension if we have enabled the setting.
        // Note: As at Feb 2025, Chromium based browsers are the only ones that support this and
        // munging it into the answer in Firefox will cause the connection to fail.
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.EnableCaptureTimeExt) && !this.isFirefox()) {
            mungedSDP = _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__.SDPUtils.addVideoHeaderExtensionToSdp(mungedSDP, kAbsCaptureTime);
        }
        return mungedSDP;
    }
    isFirefox() {
        return navigator.userAgent.indexOf('Firefox') > 0;
    }
    /**
     * When a Ice Candidate is received add to the RTC Peer Connection
     * @param iceCandidate - RTC Ice Candidate from the Signaling Server
     */
    handleOnIce(iceCandidate) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('peerconnection handleOnIce');
        // // if forcing TURN, reject any candidates not relay
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.ForceTURN)) {
            // check if no relay address is found, if so, we are assuming it means no TURN server
            if (iceCandidate.candidate.indexOf('relay') < 0) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info(`Dropping candidate because it was not TURN relay. | Type= ${iceCandidate.type} | Protocol= ${iceCandidate.protocol} | Address=${iceCandidate.address} | Port=${iceCandidate.port} |`);
                return;
            }
        }
        (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.addIceCandidate(iceCandidate);
    }
    /**
     * When the RTC Peer Connection Signaling server state Changes
     * @param state - Signaling Server State Change Event
     */
    handleSignalStateChange(state) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('signaling state change: ' + state);
    }
    /**
     * Handle when the Ice Connection State Changes
     * @param state - Ice Connection State
     */
    handleIceConnectionStateChange(state) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('ice connection state change: ' + state);
        this.onIceConnectionStateChange(state);
    }
    /**
     * Handle when the Ice Gathering State Changes
     * @param state - Ice Gathering State Change
     */
    handleIceGatheringStateChange(state) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('ice gathering state change: ' + JSON.stringify(state));
    }
    /**
     * Activates the onTrack method
     * @param event - The webRtc track event
     */
    handleOnTrack(event) {
        if (event.streams.length < 1 || event.streams[0].id == 'probator') {
            return;
        }
        if (event.track.kind == 'video') {
            this.videoTrack = event.track;
        }
        if (event.track.kind == 'audio') {
            this.audioTrack = event.track;
        }
        this.onTrack(event);
    }
    /**
     * Activates the onPeerIceCandidate
     * @param event - The peer ice candidate
     */
    handleIceCandidate(event) {
        this.onPeerIceCandidate(event);
    }
    /**
     * Activates the onDataChannel
     * @param event - The peer's data channel
     */
    handleDataChannel(event) {
        this.onDataChannel(event);
    }
    /**
     * An override method for onTrack for use outside of the PeerConnectionController
     * @param trackEvent - The webRtc track event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onTrack(trackEvent) {
        // Default Functionality: Do Nothing
    }
    /**
     * An override method for onIceConnectionStateChange for use outside of the PeerConnectionController
     * @param event - The webRtc iceconnectionstatechange event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onIceConnectionStateChange(event) {
        // Default Functionality: Do Nothing
    }
    /**
     * An override method for onPeerIceCandidate for use outside of the PeerConnectionController
     * @param peerConnectionIceEvent - The peer ice candidate
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onPeerIceCandidate(peerConnectionIceEvent) {
        // Default Functionality: Do Nothing
    }
    /**
     * An override method for onDataChannel for use outside of the PeerConnectionController
     * @param datachannelEvent - The peer's data channel
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onDataChannel(datachannelEvent) {
        // Default Functionality: Do Nothing
    }
    /**
     * Find the intersection between UE and browser codecs, with fuzzy matching if some parameters are mismatched.
     * @param sdp The remote sdp
     * @returns The intersection between browser supported codecs and ue supported codecs.
     */
    fuzzyIntersectUEAndBrowserCodecs(sdp) {
        // We want to build an array of all supported codecs on both sides
        const allSupportedCodecs = new Array();
        const allUECodecs = this.parseAvailableCodecs(sdp);
        const allBrowserCodecs = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec).options;
        for (const ueCodec of allUECodecs) {
            // Check if browser codecs directly matches UE codec (with parameters and everything)
            if (allBrowserCodecs.includes(ueCodec)) {
                allSupportedCodecs.push(ueCodec);
                continue;
            }
            // Otherwise check if browser codec at least contains a match for the UE codec name (without parameters).
            else {
                const ueCodecNameAndParams = ueCodec.split(' ');
                const ueCodecName = ueCodecNameAndParams[0];
                for (const browserCodec of allBrowserCodecs) {
                    if (browserCodec.includes(ueCodecName)) {
                        // We pass browser codec here as they option contain extra parameters.
                        allSupportedCodecs.push(browserCodec);
                        break;
                    }
                }
            }
        }
        return allSupportedCodecs;
    }
    /**
     * Setup tracks on the RTC Peer Connection
     * @param useMic - is mic in use
     * @param useCamera - is webcam in use
     */
    setupTransceiversAsync(useMic, useCamera) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            let hasVideoReceiver = false;
            for (const transceiver of (_b = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : []) {
                if (transceiver &&
                    transceiver.receiver &&
                    transceiver.receiver.track &&
                    transceiver.receiver.track.kind === 'video') {
                    hasVideoReceiver = true;
                    break;
                }
            }
            // Setup a transceiver for sending webcam video to UE and receiving video from UE
            if (!useCamera) {
                if (!hasVideoReceiver) {
                    (_c = this.peerConnection) === null || _c === void 0 ? void 0 : _c.addTransceiver('video', { direction: 'recvonly' });
                }
            }
            else {
                yield this.setupVideoSender(hasVideoReceiver);
            }
            if (RTCRtpReceiver.getCapabilities && this.preferredCodec != '') {
                for (const transceiver of (_e = (_d = this.peerConnection) === null || _d === void 0 ? void 0 : _d.getTransceivers()) !== null && _e !== void 0 ? _e : []) {
                    if (transceiver &&
                        transceiver.receiver &&
                        transceiver.receiver.track &&
                        transceiver.receiver.track.kind === 'video' &&
                        transceiver.setCodecPreferences) {
                        // Get our preferred codec from the codecs options drop down
                        const preferredRTPCodec = this.preferredCodec.split(' ');
                        const preferredRTCRtpCodecCapability = {
                            mimeType: 'video/' + preferredRTPCodec[0] /* Name */,
                            clockRate: 90000 /* All current video formats in browsers have 90khz clock rate */,
                            sdpFmtpLine: preferredRTPCodec[1] ? preferredRTPCodec[1] : ''
                        };
                        // Populate a list of codecs we will support with our preferred one in the first position
                        const ourSupportedCodecs = [preferredRTCRtpCodecCapability];
                        // Go through all codecs the browser supports and add them to the list (in any order)
                        RTCRtpReceiver.getCapabilities('video').codecs.forEach((browserSupportedCodec) => {
                            // Don't add our preferred codec again, but add everything else
                            if (browserSupportedCodec.mimeType != preferredRTCRtpCodecCapability.mimeType) {
                                ourSupportedCodecs.push(browserSupportedCodec);
                            }
                            else if ((browserSupportedCodec === null || browserSupportedCodec === void 0 ? void 0 : browserSupportedCodec.sdpFmtpLine) !=
                                (preferredRTCRtpCodecCapability === null || preferredRTCRtpCodecCapability === void 0 ? void 0 : preferredRTCRtpCodecCapability.sdpFmtpLine)) {
                                ourSupportedCodecs.push(browserSupportedCodec);
                            }
                        });
                        for (const codec of ourSupportedCodecs) {
                            if ((codec === null || codec === void 0 ? void 0 : codec.sdpFmtpLine) === undefined || codec.sdpFmtpLine === '') {
                                // We can't dynamically add members to the codec, so instead remove the field if it's empty
                                delete codec.sdpFmtpLine;
                            }
                        }
                        transceiver.setCodecPreferences(ourSupportedCodecs);
                    }
                }
            }
            let hasAudioReceiver = false;
            for (const transceiver of (_g = (_f = this.peerConnection) === null || _f === void 0 ? void 0 : _f.getTransceivers()) !== null && _g !== void 0 ? _g : []) {
                if (transceiver &&
                    transceiver.receiver &&
                    transceiver.receiver.track &&
                    transceiver.receiver.track.kind === 'audio') {
                    hasAudioReceiver = true;
                    break;
                }
            }
            // Setup a transceiver for sending mic audio to UE and receiving audio from UE
            if (!useMic) {
                if (!hasAudioReceiver) {
                    (_h = this.peerConnection) === null || _h === void 0 ? void 0 : _h.addTransceiver('audio', {
                        direction: 'recvonly'
                    });
                }
            }
            else {
                yield this.setupAudioSender(hasAudioReceiver);
            }
        });
    }
    setupVideoSender(hasVideoReceiver) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            // set the media send options
            const mediaSendOptions = {
                video: true
            };
            // Note using webcam on android chrome requires SSL or chrome://flags/ "unsafely-treat-insecure-origin-as-secure"
            const stream = yield navigator.mediaDevices.getUserMedia(mediaSendOptions);
            if (stream) {
                if (hasVideoReceiver) {
                    for (const transceiver of (_b = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : []) {
                        if (_Util_RTCUtils__WEBPACK_IMPORTED_MODULE_6__.RTCUtils.canTransceiverReceiveVideo(transceiver)) {
                            for (const track of stream.getTracks()) {
                                if (track.kind && track.kind == 'video') {
                                    transceiver.sender.replaceTrack(track);
                                    transceiver.direction = 'sendrecv';
                                }
                            }
                        }
                    }
                }
                else {
                    for (const track of stream.getTracks()) {
                        if (track.kind && track.kind == 'video') {
                            (_c = this.peerConnection) === null || _c === void 0 ? void 0 : _c.addTransceiver(track, {
                                direction: 'sendrecv'
                            });
                        }
                    }
                }
            }
            else {
                if (!hasVideoReceiver) {
                    (_d = this.peerConnection) === null || _d === void 0 ? void 0 : _d.addTransceiver('video', { direction: 'recvonly' });
                }
            }
        });
    }
    setupAudioSender(hasAudioReceiver) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            // set the audio options based on mic usage
            const audioOptions = {
                autoGainControl: false,
                channelCount: 1,
                echoCancellation: false,
                latency: 0,
                noiseSuppression: false,
                sampleRate: 48000,
                sampleSize: 16,
                volume: 1.0
            };
            // set the media send options
            const mediaSendOptions = {
                video: false,
                audio: audioOptions
            };
            // Note using mic on android chrome requires SSL or chrome://flags/ "unsafely-treat-insecure-origin-as-secure"
            const stream = yield navigator.mediaDevices.getUserMedia(mediaSendOptions);
            if (stream) {
                if (hasAudioReceiver) {
                    for (const transceiver of (_b = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : []) {
                        if (_Util_RTCUtils__WEBPACK_IMPORTED_MODULE_6__.RTCUtils.canTransceiverReceiveAudio(transceiver)) {
                            for (const track of stream.getTracks()) {
                                if (track.kind && track.kind == 'audio') {
                                    transceiver.sender.replaceTrack(track);
                                    transceiver.direction = 'sendrecv';
                                }
                            }
                        }
                    }
                }
                else {
                    for (const track of stream.getTracks()) {
                        if (track.kind && track.kind == 'audio') {
                            (_c = this.peerConnection) === null || _c === void 0 ? void 0 : _c.addTransceiver(track, {
                                direction: 'sendrecv'
                            });
                        }
                    }
                }
            }
            else {
                if (!hasAudioReceiver) {
                    (_d = this.peerConnection) === null || _d === void 0 ? void 0 : _d.addTransceiver('audio', {
                        direction: 'recvonly'
                    });
                }
            }
        });
    }
    /**
     * And override event for when the video stats are fired
     * @param event - Aggregated Stats
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVideoStats(event) {
        // Default Functionality: Do Nothing
    }
    /**
     * And override event for when latency info is calculated
     * @param latencyInfo - Calculated latency information.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onLatencyCalculated(latencyInfo) {
        // Default Functionality: Do Nothing
    }
    /**
     * Event to send the RTC offer to the Signaling server
     * @param offer - RTC Offer
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onSendWebRTCOffer(offer) {
        // Default Functionality: Do Nothing
    }
    /**
     * Event fired when remote offer description is set.
     * @param offer - RTC Offer
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onSetRemoteDescription(offer) {
        // Default Functionality: Do Nothing
    }
    /**
     * Event fire when local description answer is set.
     * @param answer - RTC Answer
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onSetLocalDescription(answer) {
        // Default Functionality: Do Nothing
    }
    /**
     * An override for showing the Peer connection connecting Overlay
     */
    showTextOverlayConnecting() {
        // Default Functionality: Do Nothing
    }
    /**
     * An override for showing the Peer connection Failed overlay
     */
    showTextOverlaySetupFailure() {
        // Default Functionality: Do Nothing
    }
    parseAvailableCodecs(rtcSessionDescription) {
        // No point in updating the available codecs if on FF
        if (!RTCRtpReceiver.getCapabilities)
            return ['Only available on Chrome'];
        const ueSupportedCodecs = [];
        const sections = (0,sdp__WEBPACK_IMPORTED_MODULE_0__.splitSections)(rtcSessionDescription.sdp);
        // discard the session information as we only want media related info
        sections.shift();
        sections.forEach((mediaSection) => {
            const { codecs } = (0,sdp__WEBPACK_IMPORTED_MODULE_0__.parseRtpParameters)(mediaSection);
            // Filter only for VPX / H26X / AV1
            const matcher = /(VP\d|H26\d|AV1).*/;
            codecs.forEach((c) => {
                const str = c.name +
                    ' ' +
                    Object.keys(c.parameters || {})
                        .map((p) => p + '=' + c.parameters[p])
                        .join(';');
                const match = matcher.exec(str);
                if (match !== null) {
                    if (c.name == 'VP9') {
                        // UE answers don't specify profile but we know we want profile 0
                        c.parameters = {
                            'profile-id': '0'
                        };
                    }
                    const codecStr = c.name +
                        ' ' +
                        Object.keys(c.parameters || {})
                            .map((p) => p + '=' + c.parameters[p])
                            .join(';');
                    ueSupportedCodecs.push(codecStr);
                }
            });
        });
        return ueSupportedCodecs;
    }
}
//# sourceMappingURL=PeerConnectionController.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/SessionStats.js":
/*!***********************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/SessionStats.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SessionStats: () => (/* binding */ SessionStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Session statistics
 */
class SessionStats {
}
//# sourceMappingURL=SessionStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/StreamStats.js":
/*!**********************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/StreamStats.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StreamStats: () => (/* binding */ StreamStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Class to hold the stream stats data coming in from webRtc
 */
class StreamStats {
}
//# sourceMappingURL=StreamStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PixelStreaming/PixelStreaming.js":
/*!***************************************************************!*\
  !*** ../../library/dist/esm/PixelStreaming/PixelStreaming.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PixelStreaming: () => (/* binding */ PixelStreaming)
/* harmony export */ });
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _WebRtcPlayer_WebRtcPlayerController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../WebRtcPlayer/WebRtcPlayerController */ "../../library/dist/esm/WebRtcPlayer/WebRtcPlayerController.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Util/EventEmitter */ "../../library/dist/esm/Util/EventEmitter.js");
/* harmony import */ var _WebXR_WebXRController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../WebXR/WebXRController */ "../../library/dist/esm/WebXR/WebXRController.js");
/* harmony import */ var _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../UeInstanceMessage/StreamMessageController */ "../../library/dist/esm/UeInstanceMessage/StreamMessageController.js");
/* harmony import */ var _DataChannel_DataChannelLatencyTestController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../DataChannel/DataChannelLatencyTestController */ "../../library/dist/esm/DataChannel/DataChannelLatencyTestController.js");
/* harmony import */ var _Util_RTCUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Util/RTCUtils */ "../../library/dist/esm/Util/RTCUtils.js");
/* harmony import */ var _Util_IURLSearchParams__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Util/IURLSearchParams */ "../../library/dist/esm/Util/IURLSearchParams.js");
// Copyright Epic Games, Inc. All Rights Reserved.










/**
 * The key class for the browser side of a Pixel Streaming application, it includes:
 * WebRTC handling, XR support, input handling, and emitters for lifetime and state change events.
 * Users are encouraged to use this class as is, through composition, or extend it. In any case,
 * this will likely be the core of your Pixel Streaming experience in terms of functionality.
 */
class PixelStreaming {
    /**
     * @param config - A newly instantiated config object
     * @param overrides - Parameters to override default behaviour
     * returns the base Pixel streaming object
     */
    constructor(config, overrides) {
        this.allowConsoleCommands = false;
        this.config = config;
        if (overrides === null || overrides === void 0 ? void 0 : overrides.videoElementParent) {
            this._videoElementParent = overrides.videoElementParent;
        }
        this._eventEmitter = new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.PixelStreamingEventEmitter();
        this.configureSettings();
        // setup WebRTC
        this.setWebRtcPlayerController(new _WebRtcPlayer_WebRtcPlayerController__WEBPACK_IMPORTED_MODULE_1__.WebRtcPlayerController(this.config, this));
        this._webXrController = new _WebXR_WebXRController__WEBPACK_IMPORTED_MODULE_2__.WebXRController(this._webRtcController);
        this._setupWebRtcTCPRelayDetection = this._setupWebRtcTCPRelayDetection.bind(this);
        // Add event listener for the webRtcConnected event
        this._eventEmitter.addEventListener('webRtcConnected', (_) => {
            // Bind to the stats received event
            this._eventEmitter.addEventListener('statsReceived', this._setupWebRtcTCPRelayDetection);
        });
    }
    /**
     * Gets the element that contains the video stream element.
     */
    get videoElementParent() {
        if (!this._videoElementParent) {
            this._videoElementParent = document.createElement('div');
            this._videoElementParent.id = 'videoElementParent';
        }
        return this._videoElementParent;
    }
    /**
     * Configure the settings with on change listeners and any additional per experience settings.
     */
    configureSettings() {
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.IsQualityController, (wantsQualityController) => {
            // If the setting has been set to true (either programmatically or the user has flicked the toggle)
            // and we aren't currently quality controller, send the request
            if (wantsQualityController === true && !this._webRtcController.isQualityController) {
                this._webRtcController.sendRequestQualityControlOwnership();
            }
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.AFKDetection, (isAFKEnabled) => {
            this._webRtcController.setAfkEnabled(isAFKEnabled);
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.MatchViewportResolution, () => {
            this._webRtcController.videoPlayer.updateVideoStreamSize();
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.HoveringMouseMode, (isHoveringMouse) => {
            this.config.setFlagLabel(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.HoveringMouseMode, `Control Scheme: ${isHoveringMouse ? 'Hovering' : 'Locked'} Mouse`);
            this._webRtcController.setMouseInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.MouseInput));
        });
        // user input
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.KeyboardInput, (isEnabled) => {
            this._webRtcController.setKeyboardInputEnabled(isEnabled);
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.MouseInput, (isEnabled) => {
            this._webRtcController.setMouseInputEnabled(isEnabled);
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.FakeMouseWithTouches, (_isFakeMouseEnabled) => {
            this._webRtcController.setTouchInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.TouchInput));
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.TouchInput, (isEnabled) => {
            this._webRtcController.setTouchInputEnabled(isEnabled);
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.GamepadInput, (isEnabled) => {
            this._webRtcController.setGamePadInputEnabled(isEnabled);
        });
        // direct qp settings
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQP, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MinQP  --------');
            this._webRtcController.sendEncoderMinQP(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
            const quality = Math.trunc(100 * (1 - newValue / 51));
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax, quality);
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQP, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MaxQP  --------');
            this._webRtcController.sendEncoderMaxQP(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
            const quality = Math.trunc(100 * (1 - newValue / 51));
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin, quality);
        });
        // direct quality factor settings
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQuality, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MinQuality  --------');
            this._webRtcController.sendEncoderMinQuality(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin, newValue);
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQuality, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MaxQuality  --------');
            this._webRtcController.sendEncoderMaxQuality(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax, newValue);
        });
        // new quality value that gets scaled to qp for legacy reasons
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin, (newValue) => {
            newValue = 51 - (newValue / 100) * 51;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MinQP from quality value  --------');
            this._webRtcController.sendEncoderMaxQP(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax, (newValue) => {
            newValue = 51 - (newValue / 100) * 51;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MaxQP from quality value  --------');
            this._webRtcController.sendEncoderMinQP(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        // WebRTC settings
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMinBitrate, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending web rtc settings  --------');
            this._webRtcController.sendWebRTCMinBitrate(newValue * 1000 /* kbps to bps */);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMaxBitrate, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending web rtc settings  --------');
            this._webRtcController.sendWebRTCMaxBitrate(newValue * 1000 /* kbps to bps */);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCFPS, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending web rtc settings  --------');
            this._webRtcController.sendWebRTCFps(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        this.config._addOnOptionSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.OptionParameters.PreferredCodec, (newValue) => {
            if (this._webRtcController) {
                this._webRtcController.setPreferredCodec(newValue);
            }
        });
        this.config._registerOnChangeEvents(this._eventEmitter);
    }
    /**
     * Set the input control ownership
     * @param inputControlOwnership - does the user have input control ownership
     */
    _onInputControlOwnership(inputControlOwnership) {
        this._inputController = inputControlOwnership;
    }
    /**
     * Instantiate the WebRTCPlayerController interface to provide WebRTCPlayerController functionality within this class and set up anything that requires it
     * @param webRtcPlayerController - a WebRtcPlayerController controller instance
     */
    setWebRtcPlayerController(webRtcPlayerController) {
        this._webRtcController = webRtcPlayerController;
        this._webRtcController.setPreferredCodec(this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.OptionParameters.PreferredCodec).selected);
        this._webRtcController.resizePlayerStyle();
        // connect if auto connect flag is enabled
        this.checkForAutoConnect();
    }
    /**
     * Connect to signaling server.
     */
    connect() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StreamPreConnectEvent());
        this._webRtcController.connectToSignallingServer();
    }
    /**
     * Reconnects to the signaling server. If connection is up, disconnects first
     * before establishing a new connection
     */
    reconnect() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StreamReconnectEvent());
        this._webRtcController.tryReconnect('Reconnecting...');
    }
    /**
     * Disconnect from the signaling server and close open peer connections.
     */
    disconnect() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StreamPreDisconnectEvent());
        this._webRtcController.close();
    }
    /**
     * Play the stream. Can be called only after a peer connection has been established.
     */
    play() {
        this._onStreamLoading();
        this._webRtcController.playStream();
    }
    /**
     * Auto connect if AutoConnect flag is enabled
     */
    checkForAutoConnect() {
        // set up if the auto play will be used or regular click to start
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.AutoConnect)) {
            // if autoplaying show an info overlay while while waiting for the connection to begin
            this._onWebRtcAutoConnect();
            this._webRtcController.connectToSignallingServer();
        }
    }
    /**
     * Will unmute the microphone track which is sent to Unreal Engine.
     * By default, will only unmute an existing mic track.
     *
     * @param forceEnable Can be used for cases when this object wasn't initialized with a mic track.
     * If this parameter is true, the connection will be restarted with a microphone.
     * Warning: this takes some time, as a full renegotiation and reconnection will happen.
     */
    unmuteMicrophone(forceEnable = false) {
        // If there's an existing mic track, we just set muted state
        if (this.config.isFlagEnabled('UseMic')) {
            this.setMicrophoneMuted(false);
            return;
        }
        // If there's no pre-existing mic track, and caller is ok with full reset, we enable and reset
        if (forceEnable) {
            this.config.setFlagEnabled('UseMic', true);
            this.reconnect();
            return;
        }
        // If we prefer not to force a reconnection, just warn the user that this operation didn't happen
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Warning('Trying to unmute mic, but PixelStreaming was initialized with no microphone track. Call with forceEnable == true to re-connect with a mic track.');
    }
    muteMicrophone() {
        if (this.config.isFlagEnabled('UseMic')) {
            this.setMicrophoneMuted(true);
            return;
        }
        // If there wasn't a mic track, just let user know there's nothing to mute
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('Trying to mute mic, but PixelStreaming has no microphone track, so sending sound is already disabled.');
    }
    setMicrophoneMuted(mute) {
        var _a, _b, _c, _d;
        for (const transceiver of (_d = (_c = (_b = (_a = this._webRtcController) === null || _a === void 0 ? void 0 : _a.peerConnectionController) === null || _b === void 0 ? void 0 : _b.peerConnection) === null || _c === void 0 ? void 0 : _c.getTransceivers()) !== null && _d !== void 0 ? _d : []) {
            if (_Util_RTCUtils__WEBPACK_IMPORTED_MODULE_5__.RTCUtils.canTransceiverSendAudio(transceiver)) {
                transceiver.sender.track.enabled = !mute;
            }
        }
    }
    /**
     * Will unmute the video track which is sent to Unreal Engine.
     * By default, will only unmute an existing video track.
     *
     * @param forceEnable Can be used for cases when this object wasn't initialized with a video track.
     * If this parameter is true, the connection will be restarted with a camera.
     * Warning: this takes some time, as a full renegotiation and reconnection will happen.
     */
    unmuteCamera(forceEnable = false) {
        // If there's an existing video track, we just set muted state
        if (this.config.isFlagEnabled('UseCamera')) {
            this.setCameraMuted(false);
            return;
        }
        // If there's no pre-existing video track, and caller is ok with full reset, we enable and reset
        if (forceEnable) {
            this.config.setFlagEnabled('UseCamera', true);
            this.reconnect();
            return;
        }
        // If we prefer not to force a reconnection, just warn the user that this operation didn't happen
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Warning('Trying to unmute video, but PixelStreaming was initialized with no video track. Call with forceEnable == true to re-connect with a video track.');
    }
    muteCamera() {
        if (this.config.isFlagEnabled('UseCamera')) {
            this.setCameraMuted(true);
            return;
        }
        // If there wasn't a mic track, just let user know there's nothing to mute
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('Trying to mute camera, but PixelStreaming has no video track, so sending video is already disabled.');
    }
    setCameraMuted(mute) {
        var _a, _b, _c, _d;
        for (const transceiver of (_d = (_c = (_b = (_a = this._webRtcController) === null || _a === void 0 ? void 0 : _a.peerConnectionController) === null || _b === void 0 ? void 0 : _b.peerConnection) === null || _c === void 0 ? void 0 : _c.getTransceivers()) !== null && _d !== void 0 ? _d : []) {
            if (_Util_RTCUtils__WEBPACK_IMPORTED_MODULE_5__.RTCUtils.canTransceiverSendVideo(transceiver)) {
                transceiver.sender.track.enabled = !mute;
            }
        }
    }
    /**
     * Internal function to emit an event when auto connecting occurs
     */
    _onWebRtcAutoConnect() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcAutoConnectEvent());
    }
    /**
     * Internal function to emit an event for when SDP negotiation is fully finished.
     */
    _onWebRtcSdp() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcSdpEvent());
    }
    /**
     * Internal function to emit an SDP offer after it has been set.
     */
    _onWebRtcSdpOffer(offer) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcSdpOfferEvent({ sdp: offer }));
    }
    /**
     * Internal function to emit an SDP answer after it has been set.
     */
    _onWebRtcSdpAnswer(answer) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcSdpAnswerEvent({ sdp: answer }));
    }
    /**
     * Internal function call to emit a `latencyCalculated` event.
     */
    _onLatencyCalculated(latencyInfo) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.LatencyCalculatedEvent({ latencyInfo }));
    }
    /**
     * Internal function to emits a StreamLoading event
     */
    _onStreamLoading() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StreamLoadingEvent());
    }
    /**
     * Event fired when the video is disconnected - emits given eventString or an override
     * message from webRtcController if one has been set
     * @param eventString - a string describing why the connection closed
     * @param allowClickToReconnect - true if we want to allow the user to retry the connection with a click
     */
    _onDisconnect(eventString, allowClickToReconnect) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcDisconnectedEvent({
            eventString: eventString,
            allowClickToReconnect: allowClickToReconnect
        }));
    }
    /**
     * Handles when Web Rtc is connecting
     */
    _onWebRtcConnecting() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcConnectingEvent());
    }
    /**
     * Handles when Web Rtc has connected
     */
    _onWebRtcConnected() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcConnectedEvent());
    }
    /**
     * Handles when Web Rtc fails to connect
     */
    _onWebRtcFailed() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcFailedEvent());
    }
    /**
     * Handle when the Video has been Initialized
     */
    _onVideoInitialized() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.VideoInitializedEvent());
        this._videoStartTime = Date.now();
    }
    /**
     * Set up functionality to happen when receiving latency test results
     * @param latency - latency test results object
     */
    _onLatencyTestResult(latencyTimings) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.LatencyTestResultEvent({ latencyTimings }));
    }
    _onDataChannelLatencyTestResponse(response) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.DataChannelLatencyTestResponseEvent({ response }));
    }
    /**
     * Set up functionality to happen when receiving video statistics
     * @param videoStats - video statistics as a aggregate stats object
     */
    _onVideoStats(videoStats) {
        // Duration
        if (!this._videoStartTime || this._videoStartTime === undefined) {
            this._videoStartTime = Date.now();
        }
        videoStats.handleSessionStatistics(this._videoStartTime, this._inputController, this._webRtcController.videoAvgQp);
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StatsReceivedEvent({ aggregatedStats: videoStats }));
    }
    /**
     * Set up functionality to happen when calculating the average video encoder qp
     * @param QP - the quality number of the stream
     */
    _onVideoEncoderAvgQP(QP) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.VideoEncoderAvgQPEvent({ avgQP: QP }));
    }
    /**
     * Set up functionality to happen when receiving and handling initial settings for the UE app
     * @param settings - initial UE app settings
     */
    _onInitialSettings(settings) {
        var _a;
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.InitialSettingsEvent({ settings }));
        if (settings.PixelStreamingSettings) {
            this.allowConsoleCommands = (_a = settings.PixelStreamingSettings.AllowPixelStreamingCommands) !== null && _a !== void 0 ? _a : false;
            if (this.allowConsoleCommands === false) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-AllowPixelStreamingCommands=false, sending arbitrary console commands from browser to UE is disabled.');
            }
        }
        const useUrlParams = this.config.useUrlParams;
        const urlParams = new _Util_IURLSearchParams__WEBPACK_IMPORTED_MODULE_6__.IURLSearchParams(window.location.search);
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info(`using URL parameters ${useUrlParams}`);
        if (settings.EncoderSettings) {
            // here we should either get Min/MaxQP from PS1
            // or Min/MaxQuality from PS2
            // we only want to set one set or the other as they converge in CompatQualityMin/Max and
            // we dont want to have them conflict with default values.
            if (settings.EncoderSettings.MinQP) {
                this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQP, 
                // If a setting is set in the URL, make sure we respect that value as opposed to what the application sends us
                useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQP)
                    ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQP))
                    : settings.EncoderSettings.MinQP || 0);
                this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQP, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQP)
                    ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQP))
                    : settings.EncoderSettings.MaxQP || 51);
            }
            if (settings.EncoderSettings.MinQuality) {
                this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQuality, 
                // If a setting is set in the URL, make sure we respect that value as opposed to what the application sends us
                useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQuality)
                    ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQuality))
                    : settings.EncoderSettings.MinQuality || 0);
                this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQuality, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQuality)
                    ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQuality))
                    : settings.EncoderSettings.MaxQuality || 100);
            }
            // these two are just used to converge quality and qp and behave slightly differently since they
            // shouldnt exist in EncoderSettings
            if (useUrlParams) {
                if (urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin)) {
                    this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin, Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin)));
                }
                if (urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax)) {
                    this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax, Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax)));
                }
            }
        }
        if (settings.WebRTCSettings) {
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMinBitrate, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMinBitrate)
                ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMinBitrate))
                : settings.WebRTCSettings.MinBitrate / 1000 /* bps to kbps */);
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMaxBitrate, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMaxBitrate)
                ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMaxBitrate))
                : settings.WebRTCSettings.MaxBitrate / 1000 /* bps to kbps */);
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCFPS, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCFPS)
                ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCFPS))
                : settings.WebRTCSettings.FPS);
        }
    }
    /**
     * Set up functionality to happen when setting quality control ownership of a stream
     * @param hasQualityOwnership - does this user have quality ownership of the stream true / false
     */
    _onQualityControlOwnership(hasQualityOwnership) {
        this.config.setFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.IsQualityController, hasQualityOwnership);
    }
    _onPlayerCount(playerCount) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.PlayerCountEvent({ count: playerCount }));
    }
    _onSubscribeFailed(message) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.SubscribeFailedEvent({ message: message }));
    }
    // Sets up to emit the webrtc tcp relay detect event
    _setupWebRtcTCPRelayDetection(statsReceivedEvent) {
        // Get the active candidate pair
        const activeCandidatePair = statsReceivedEvent.data.aggregatedStats.getActiveCandidatePair();
        // Check if the active candidate pair is not null
        if (activeCandidatePair != null) {
            // Get the local candidate assigned to the active candidate pair
            const localCandidate = statsReceivedEvent.data.aggregatedStats.localCandidates.find((candidate) => candidate.id == activeCandidatePair.localCandidateId, null);
            // Check if the local candidate is not null, candidate type is relay and the relay protocol is tcp
            if (localCandidate != null &&
                localCandidate.candidateType == 'relay' &&
                localCandidate.relayProtocol == 'tcp') {
                // Send the web rtc tcp relay detected event
                this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcTCPRelayDetectedEvent());
            }
            // The check is completed and the stats listen event can be removed
            this._eventEmitter.removeEventListener('statsReceived', this._setupWebRtcTCPRelayDetection);
        }
    }
    /**
     * Request a connection latency test.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     * @returns
     */
    requestLatencyTest() {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendLatencyTest();
        return true;
    }
    /**
     * Request a data channel latency test.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     */
    requestDataChannelLatencyTest(config) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        if (!this._dataChannelLatencyTestController) {
            this._dataChannelLatencyTestController = new _DataChannel_DataChannelLatencyTestController__WEBPACK_IMPORTED_MODULE_7__.DataChannelLatencyTestController(this._webRtcController.sendDataChannelLatencyTest.bind(this._webRtcController), (result) => {
                this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.DataChannelLatencyTestResultEvent({ result }));
            });
            this.addEventListener('dataChannelLatencyTestResponse', ({ data: { response } }) => {
                this._dataChannelLatencyTestController.receive(response);
            });
        }
        return this._dataChannelLatencyTestController.start(config);
    }
    /**
     * Request for the UE application to show FPS counter.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     * @returns
     */
    requestShowFps() {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendShowFps();
        return true;
    }
    /**
     * Request for a new IFrame from the UE application.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     * @returns
     */
    requestIframe() {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendIframeRequest();
        return true;
    }
    /**
     * Send data to UE application. The data will be run through JSON.stringify() so e.g. strings
     * and any serializable plain JSON objects with no recurrence can be sent.
     * @returns true if succeeded, false if rejected
     */
    emitUIInteraction(descriptor) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.emitUIInteraction(descriptor);
        return true;
    }
    /**
     * Send a command to UE application. Blocks ConsoleCommand descriptors unless UE
     * has signaled that it allows console commands.
     * @returns true if succeeded, false if rejected
     */
    emitCommand(descriptor) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        if (!this.allowConsoleCommands && 'ConsoleCommand' in descriptor) {
            return false;
        }
        this._webRtcController.emitCommand(descriptor);
        return true;
    }
    /**
     * Send a console command to UE application. Only allowed if UE has signaled that it allows
     * console commands.
     * @returns true if succeeded, false if rejected
     */
    emitConsoleCommand(command) {
        if (!this.allowConsoleCommands || !this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.emitConsoleCommand(command);
        return true;
    }
    /**
     * Sets the text contents of the currently focused UE text box widget.
     * @param contents The new contents of the UE text box.
     * @returns True if the message could be sent.
     */
    sendTextboxEntry(contents) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendTextboxEntry(contents);
        return true;
    }
    /**
     * Add a UE -> browser response event listener
     * @param name - The name of the response handler
     * @param listener - The method to be activated when a message is received
     */
    addResponseEventListener(name, listener) {
        this._webRtcController.responseController.addResponseEventListener(name, listener);
    }
    /**
     * Remove a UE -> browser response event listener
     * @param name - The name of the response handler
     */
    removeResponseEventListener(name) {
        this._webRtcController.responseController.removeResponseEventListener(name);
    }
    /**
     * Dispatch a new event.
     * @param e event
     * @returns
     */
    dispatchEvent(e) {
        return this._eventEmitter.dispatchEvent(e);
    }
    /**
     * Register an event handler.
     * @param type event name
     * @param listener event handler function
     */
    addEventListener(type, listener) {
        this._eventEmitter.addEventListener(type, listener);
    }
    /**
     * Remove an event handler.
     * @param type event name
     * @param listener event handler function
     */
    removeEventListener(type, listener) {
        this._eventEmitter.removeEventListener(type, listener);
    }
    /**
     * Enable/disable XR mode.
     */
    toggleXR() {
        this.webXrController.xrClicked();
    }
    /**
     * Pass in a function to generate a signalling server URL.
     * This function is useful if you need to programmatically construct your signalling server URL.
     * @param signallingUrlBuilderFunc A function that generates a signalling server url.
     */
    setSignallingUrlBuilder(signallingUrlBuilderFunc) {
        this._webRtcController.signallingUrlBuilder = signallingUrlBuilderFunc;
    }
    get webRtcController() {
        return this._webRtcController;
    }
    /**
     * Public getter for the websocket controller. Access to this property allows you to send
     * custom websocket messages.
     */
    get signallingProtocol() {
        return this._webRtcController.protocol;
    }
    /**
     * Public getter for the webXrController controller. Used for all XR features.
     */
    get webXrController() {
        return this._webXrController;
    }
    registerMessageHandler(name, direction, handler) {
        if (direction === _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_8__.MessageDirection.FromStreamer && typeof handler === 'undefined') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Warning(`Unable to register an undefined handler for ${name}`);
            return;
        }
        if (direction === _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_8__.MessageDirection.ToStreamer && typeof handler === 'undefined') {
            this._webRtcController.streamMessageController.registerMessageHandler(direction, name, (data) => this._webRtcController.sendMessageController.sendMessageToStreamer(name, data));
        }
        else {
            this._webRtcController.streamMessageController.registerMessageHandler(direction, name, (data) => handler(data));
        }
    }
    get toStreamerHandlers() {
        return this._webRtcController.streamMessageController.toStreamerHandlers;
    }
    isReconnecting() {
        return this._webRtcController.isReconnecting;
    }
}
//# sourceMappingURL=PixelStreaming.js.map

/***/ }),

/***/ "../../library/dist/esm/UeInstanceMessage/ResponseController.js":
/*!**********************************************************************!*\
  !*** ../../library/dist/esm/UeInstanceMessage/ResponseController.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ResponseController: () => (/* binding */ ResponseController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class ResponseController {
    constructor() {
        this.responseEventListeners = new Map();
    }
    /**
     * Add a response event listener to the response map
     * @param name - The name of the response
     * @param listener - The method to be activated when the response is selected
     */
    addResponseEventListener(name, listener) {
        this.responseEventListeners.set(name, listener);
    }
    /**
     * Remove a response event listener to the response map
     * @param name - The name of the response
     */
    removeResponseEventListener(name) {
        this.responseEventListeners.delete(name);
    }
    /**
     * Handle a response when receiving one form the streamer
     * @param message - Data received from the data channel with the command in question
     */
    onResponse(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('DataChannelReceiveMessageType.Response');
        const responses = new TextDecoder('utf-16').decode(message.slice(1));
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(responses);
        this.responseEventListeners.forEach((listener) => {
            listener(responses);
        });
    }
}
//# sourceMappingURL=ResponseController.js.map

/***/ }),

/***/ "../../library/dist/esm/UeInstanceMessage/SendMessageController.js":
/*!*************************************************************************!*\
  !*** ../../library/dist/esm/UeInstanceMessage/SendMessageController.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SendMessageController: () => (/* binding */ SendMessageController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class SendMessageController {
    /**
     * @param dataChannelSender - Data channel instance
     * @param toStreamerMessagesMapProvider - Stream Messages instance
     */
    constructor(dataChannelSender, toStreamerMessagesMapProvider) {
        this.dataChannelSender = dataChannelSender;
        this.toStreamerMessagesMapProvider = toStreamerMessagesMapProvider;
    }
    /**
     * Send a message to the streamer through the data channel
     * @param messageType - the type of message we are sending
     * @param messageData - the message data we are sending over the data channel
     * @returns - nil
     */
    sendMessageToStreamer(messageType, messageData) {
        if (messageData === undefined) {
            messageData = [];
        }
        const toStreamerMessages = this.toStreamerMessagesMapProvider.toStreamerMessages;
        const messageFormat = toStreamerMessages.get(messageType);
        if (messageFormat === undefined) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Attempted to send a message to the streamer with message type: ${messageType}, but the frontend hasn't been configured to send such a message. Check you've added the message type in your cpp`);
            return;
        }
        if (messageFormat.structure && messageData && messageFormat.structure.length !== messageData.length) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Provided message data doesn't match expected layout. Expected [ ${messageFormat.structure
                .map((element) => {
                switch (element) {
                    case 'uint8':
                    case 'uint16':
                    case 'int16':
                    case 'float':
                    case 'double':
                    default:
                        return 'number';
                    case 'string':
                        return 'string';
                }
            })
                .toString()} ] but received [ ${messageData.map((element) => typeof element).toString()} ]`);
            return;
        }
        let byteLength = 0;
        const textEncoder = new TextEncoder();
        // One loop to calculate the length in bytes of all of the provided data
        messageData.forEach((element, idx) => {
            const type = messageFormat.structure[idx];
            switch (type) {
                case 'uint8':
                    byteLength += 1;
                    break;
                case 'uint16':
                    byteLength += 2;
                    break;
                case 'int16':
                    byteLength += 2;
                    break;
                case 'float':
                    byteLength += 4;
                    break;
                case 'double':
                    byteLength += 8;
                    break;
                case 'string':
                    // 2 bytes for string length
                    byteLength += 2;
                    // 2 bytes per characters
                    byteLength += 2 * textEncoder.encode(element).length;
                    break;
            }
        });
        const data = new DataView(new ArrayBuffer(byteLength + 1));
        data.setUint8(0, messageFormat.id);
        let byteOffset = 1;
        messageData.forEach((element, idx) => {
            const type = messageFormat.structure[idx];
            switch (type) {
                case 'uint8':
                    data.setUint8(byteOffset, element);
                    byteOffset += 1;
                    break;
                case 'uint16':
                    data.setUint16(byteOffset, element, true);
                    byteOffset += 2;
                    break;
                case 'int16':
                    data.setInt16(byteOffset, element, true);
                    byteOffset += 2;
                    break;
                case 'float':
                    data.setFloat32(byteOffset, element, true);
                    byteOffset += 4;
                    break;
                case 'double':
                    data.setFloat64(byteOffset, element, true);
                    byteOffset += 8;
                    break;
                case 'string':
                    data.setUint16(byteOffset, element.length, true);
                    byteOffset += 2;
                    for (let i = 0; i < element.length; i++) {
                        data.setUint16(byteOffset, element.charCodeAt(i), true);
                        byteOffset += 2;
                    }
                    break;
            }
        });
        if (!this.dataChannelSender.canSend()) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data channel cannot send yet, skipping sending message: ${messageType} - ${new Uint8Array(data.buffer)}`);
            return;
        }
        this.dataChannelSender.sendData(data.buffer);
    }
}
//# sourceMappingURL=SendMessageController.js.map

/***/ }),

/***/ "../../library/dist/esm/UeInstanceMessage/StreamMessageController.js":
/*!***************************************************************************!*\
  !*** ../../library/dist/esm/UeInstanceMessage/StreamMessageController.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MessageDirection: () => (/* binding */ MessageDirection),
/* harmony export */   StreamMessageController: () => (/* binding */ StreamMessageController),
/* harmony export */   ToStreamerMessage: () => (/* binding */ ToStreamerMessage)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class ToStreamerMessage {
}
class StreamMessageController {
    constructor() {
        this.toStreamerHandlers = new Map();
        this.fromStreamerHandlers = new Map();
        this.toStreamerMessages = new Map();
        this.fromStreamerMessages = new Map();
    }
    /**
     * Populate the Default message protocol
     */
    populateDefaultProtocol() {
        /*
         * Control Messages. Range = 0..49.
         */
        this.toStreamerMessages.set('IFrameRequest', {
            id: 0,
            structure: []
        });
        this.toStreamerMessages.set('RequestQualityControl', {
            id: 1,
            structure: []
        });
        this.toStreamerMessages.set('FpsRequest', {
            id: 2,
            structure: []
        });
        this.toStreamerMessages.set('AverageBitrateRequest', {
            id: 3,
            structure: []
        });
        this.toStreamerMessages.set('StartStreaming', {
            id: 4,
            structure: []
        });
        this.toStreamerMessages.set('StopStreaming', {
            id: 5,
            structure: []
        });
        this.toStreamerMessages.set('LatencyTest', {
            id: 6,
            structure: ['string']
        });
        this.toStreamerMessages.set('RequestInitialSettings', {
            id: 7,
            structure: []
        });
        this.toStreamerMessages.set('TestEcho', {
            id: 8,
            structure: []
        });
        this.toStreamerMessages.set('DataChannelLatencyTest', {
            id: 9,
            structure: []
        });
        /*
         * Input Messages. Range = 50..89.
         */
        // Generic Input Messages. Range = 50..59.
        this.toStreamerMessages.set('UIInteraction', {
            id: 50,
            structure: ['string']
        });
        this.toStreamerMessages.set('Command', {
            id: 51,
            structure: ['string']
        });
        this.toStreamerMessages.set('TextboxEntry', {
            id: 52,
            structure: ['string']
        });
        // Keyboard Input Message. Range = 60..69.
        this.toStreamerMessages.set('KeyDown', {
            id: 60,
            //            keyCode  isRepeat
            structure: ['uint8', 'uint8']
        });
        this.toStreamerMessages.set('KeyUp', {
            id: 61,
            //            keyCode
            structure: ['uint8']
        });
        this.toStreamerMessages.set('KeyPress', {
            id: 62,
            //            charcode
            structure: ['uint16']
        });
        // Mouse Input Messages. Range = 70..79.
        this.toStreamerMessages.set('MouseEnter', {
            id: 70,
            structure: []
        });
        this.toStreamerMessages.set('MouseLeave', {
            id: 71,
            structure: []
        });
        this.toStreamerMessages.set('MouseDown', {
            id: 72,
            //              button     x         y
            structure: ['uint8', 'uint16', 'uint16']
        });
        this.toStreamerMessages.set('MouseUp', {
            id: 73,
            //              button     x         y
            structure: ['uint8', 'uint16', 'uint16']
        });
        this.toStreamerMessages.set('MouseMove', {
            id: 74,
            //              x           y      deltaX    deltaY
            structure: ['uint16', 'uint16', 'int16', 'int16']
        });
        this.toStreamerMessages.set('MouseWheel', {
            id: 75,
            //              delta       x        y
            structure: ['int16', 'uint16', 'uint16']
        });
        this.toStreamerMessages.set('MouseDouble', {
            id: 76,
            //              button     x         y
            structure: ['uint8', 'uint16', 'uint16']
        });
        // Touch Input Messages. Range = 80..89.
        this.toStreamerMessages.set('TouchStart', {
            id: 80,
            //          numtouches(1)   x       y        idx     force     valid
            structure: ['uint8', 'uint16', 'uint16', 'uint8', 'uint8', 'uint8']
        });
        this.toStreamerMessages.set('TouchEnd', {
            id: 81,
            //          numtouches(1)   x       y        idx     force     valid
            structure: ['uint8', 'uint16', 'uint16', 'uint8', 'uint8', 'uint8']
        });
        this.toStreamerMessages.set('TouchMove', {
            id: 82,
            //          numtouches(1)   x       y       idx      force     valid
            structure: ['uint8', 'uint16', 'uint16', 'uint8', 'uint8', 'uint8']
        });
        // Gamepad Input Messages. Range = 90..99
        this.toStreamerMessages.set('GamepadConnected', {
            id: 93,
            structure: []
        });
        this.toStreamerMessages.set('GamepadButtonPressed', {
            id: 90,
            //         ctrlerId   button  isRepeat
            structure: ['uint8', 'uint8', 'uint8']
        });
        this.toStreamerMessages.set('GamepadButtonReleased', {
            id: 91,
            //         ctrlerId   button  isRepeat(0)
            structure: ['uint8', 'uint8', 'uint8']
        });
        this.toStreamerMessages.set('GamepadAnalog', {
            id: 92,
            //         ctrlerId   button  analogValue
            structure: ['uint8', 'uint8', 'double']
        });
        this.toStreamerMessages.set('GamepadDisconnected', {
            id: 94,
            //          ctrlerId
            structure: ['uint8']
        });
        this.fromStreamerMessages.set(0, 'QualityControlOwnership');
        this.fromStreamerMessages.set(1, 'Response');
        this.fromStreamerMessages.set(2, 'Command');
        this.fromStreamerMessages.set(3, 'FreezeFrame');
        this.fromStreamerMessages.set(4, 'UnfreezeFrame');
        this.fromStreamerMessages.set(5, 'VideoEncoderAvgQP');
        this.fromStreamerMessages.set(6, 'LatencyTest');
        this.fromStreamerMessages.set(7, 'InitialSettings');
        this.fromStreamerMessages.set(8, 'FileExtension');
        this.fromStreamerMessages.set(9, 'FileMimeType');
        this.fromStreamerMessages.set(10, 'FileContents');
        this.fromStreamerMessages.set(11, 'TestEcho');
        this.fromStreamerMessages.set(12, 'InputControlOwnership');
        this.fromStreamerMessages.set(13, 'GamepadResponse');
        this.fromStreamerMessages.set(14, 'DataChannelLatencyTest');
        this.fromStreamerMessages.set(255, 'Protocol');
    }
    /**
     * Register a message handler
     * @param messageDirection - the direction of the message; toStreamer or fromStreamer
     * @param messageType - the type of the message
     * @param messageHandler - the function or method to be executed when this handler is called
     */
    registerMessageHandler(messageDirection, messageType, messageHandler) {
        switch (messageDirection) {
            case MessageDirection.ToStreamer:
                this.toStreamerHandlers.set(messageType, messageHandler);
                break;
            case MessageDirection.FromStreamer:
                this.fromStreamerHandlers.set(messageType, messageHandler);
                break;
            default:
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Unknown message direction ${messageDirection}`);
        }
    }
}
/**
 * The enum for message directions
 */
var MessageDirection;
(function (MessageDirection) {
    MessageDirection[MessageDirection["ToStreamer"] = 0] = "ToStreamer";
    MessageDirection[MessageDirection["FromStreamer"] = 1] = "FromStreamer";
})(MessageDirection || (MessageDirection = {}));
//# sourceMappingURL=StreamMessageController.js.map

/***/ }),

/***/ "../../library/dist/esm/UeInstanceMessage/ToStreamerMessagesController.js":
/*!********************************************************************************!*\
  !*** ../../library/dist/esm/UeInstanceMessage/ToStreamerMessagesController.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ToStreamerMessagesController: () => (/* binding */ ToStreamerMessagesController)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class ToStreamerMessagesController {
    /**
     * @param sendMessageController - Stream message controller instance
     */
    constructor(sendMessageController) {
        this.sendMessageController = sendMessageController;
    }
    /**
     * Send Request to Take Quality Control to the UE Instance
     */
    SendRequestQualityControl() {
        this.sendMessageController.sendMessageToStreamer('RequestQualityControl');
    }
    /**
     * Send Max FPS Request to the UE Instance
     */
    SendMaxFpsRequest() {
        this.sendMessageController.sendMessageToStreamer('FpsRequest');
    }
    /**
     * Send Average Bitrate Request to the UE Instance
     */
    SendAverageBitrateRequest() {
        this.sendMessageController.sendMessageToStreamer('AverageBitrateRequest');
    }
    /**
     * Send a Start Streaming Message to the UE Instance
     */
    SendStartStreaming() {
        this.sendMessageController.sendMessageToStreamer('StartStreaming');
    }
    /**
     * Send a Stop Streaming Message to the UE Instance
     */
    SendStopStreaming() {
        this.sendMessageController.sendMessageToStreamer('StopStreaming');
    }
    /**
     * Send a Request Initial Settings to the UE Instance
     */
    SendRequestInitialSettings() {
        this.sendMessageController.sendMessageToStreamer('RequestInitialSettings');
    }
}
//# sourceMappingURL=ToStreamerMessagesController.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/BrowserUtils.js":
/*!***************************************************!*\
  !*** ../../library/dist/esm/Util/BrowserUtils.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BrowserUtils: () => (/* binding */ BrowserUtils)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class BrowserUtils {
    static getSupportedVideoCodecs() {
        const browserSupportedCodecs = [];
        // Try get the info needed from the RTCRtpReceiver. This is only available on chrome
        if (!RTCRtpReceiver.getCapabilities) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Warning('RTCRtpReceiver.getCapabilities API is not available in your browser, defaulting to guess that we support H.264.');
            browserSupportedCodecs.push('H264 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f');
            return browserSupportedCodecs;
        }
        const matcher = /(VP\d|H26\d|AV1).*/;
        const capabilities = RTCRtpReceiver.getCapabilities('video');
        if (!capabilities) {
            browserSupportedCodecs.push('H264 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f');
            return browserSupportedCodecs;
        }
        capabilities.codecs.forEach((codec) => {
            const str = codec.mimeType.split('/')[1] + ' ' + (codec.sdpFmtpLine || '');
            const match = matcher.exec(str);
            if (match !== null) {
                browserSupportedCodecs.push(str);
            }
        });
        return browserSupportedCodecs;
    }
}
//# sourceMappingURL=BrowserUtils.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/EventEmitter.js":
/*!***************************************************!*\
  !*** ../../library/dist/esm/Util/EventEmitter.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AfkTimedOutEvent: () => (/* binding */ AfkTimedOutEvent),
/* harmony export */   AfkWarningActivateEvent: () => (/* binding */ AfkWarningActivateEvent),
/* harmony export */   AfkWarningDeactivateEvent: () => (/* binding */ AfkWarningDeactivateEvent),
/* harmony export */   AfkWarningUpdateEvent: () => (/* binding */ AfkWarningUpdateEvent),
/* harmony export */   DataChannelCloseEvent: () => (/* binding */ DataChannelCloseEvent),
/* harmony export */   DataChannelErrorEvent: () => (/* binding */ DataChannelErrorEvent),
/* harmony export */   DataChannelLatencyTestResponseEvent: () => (/* binding */ DataChannelLatencyTestResponseEvent),
/* harmony export */   DataChannelLatencyTestResultEvent: () => (/* binding */ DataChannelLatencyTestResultEvent),
/* harmony export */   DataChannelOpenEvent: () => (/* binding */ DataChannelOpenEvent),
/* harmony export */   HideFreezeFrameEvent: () => (/* binding */ HideFreezeFrameEvent),
/* harmony export */   InitialSettingsEvent: () => (/* binding */ InitialSettingsEvent),
/* harmony export */   LatencyCalculatedEvent: () => (/* binding */ LatencyCalculatedEvent),
/* harmony export */   LatencyTestResultEvent: () => (/* binding */ LatencyTestResultEvent),
/* harmony export */   LoadFreezeFrameEvent: () => (/* binding */ LoadFreezeFrameEvent),
/* harmony export */   PixelStreamingEventEmitter: () => (/* binding */ PixelStreamingEventEmitter),
/* harmony export */   PlayStreamErrorEvent: () => (/* binding */ PlayStreamErrorEvent),
/* harmony export */   PlayStreamEvent: () => (/* binding */ PlayStreamEvent),
/* harmony export */   PlayStreamRejectedEvent: () => (/* binding */ PlayStreamRejectedEvent),
/* harmony export */   PlayerCountEvent: () => (/* binding */ PlayerCountEvent),
/* harmony export */   SettingsChangedEvent: () => (/* binding */ SettingsChangedEvent),
/* harmony export */   ShowOnScreenKeyboardEvent: () => (/* binding */ ShowOnScreenKeyboardEvent),
/* harmony export */   StatsReceivedEvent: () => (/* binding */ StatsReceivedEvent),
/* harmony export */   StreamLoadingEvent: () => (/* binding */ StreamLoadingEvent),
/* harmony export */   StreamPreConnectEvent: () => (/* binding */ StreamPreConnectEvent),
/* harmony export */   StreamPreDisconnectEvent: () => (/* binding */ StreamPreDisconnectEvent),
/* harmony export */   StreamReconnectEvent: () => (/* binding */ StreamReconnectEvent),
/* harmony export */   StreamerIDChangedMessageEvent: () => (/* binding */ StreamerIDChangedMessageEvent),
/* harmony export */   StreamerListMessageEvent: () => (/* binding */ StreamerListMessageEvent),
/* harmony export */   SubscribeFailedEvent: () => (/* binding */ SubscribeFailedEvent),
/* harmony export */   VideoEncoderAvgQPEvent: () => (/* binding */ VideoEncoderAvgQPEvent),
/* harmony export */   VideoInitializedEvent: () => (/* binding */ VideoInitializedEvent),
/* harmony export */   WebRtcAutoConnectEvent: () => (/* binding */ WebRtcAutoConnectEvent),
/* harmony export */   WebRtcConnectedEvent: () => (/* binding */ WebRtcConnectedEvent),
/* harmony export */   WebRtcConnectingEvent: () => (/* binding */ WebRtcConnectingEvent),
/* harmony export */   WebRtcDisconnectedEvent: () => (/* binding */ WebRtcDisconnectedEvent),
/* harmony export */   WebRtcFailedEvent: () => (/* binding */ WebRtcFailedEvent),
/* harmony export */   WebRtcSdpAnswerEvent: () => (/* binding */ WebRtcSdpAnswerEvent),
/* harmony export */   WebRtcSdpEvent: () => (/* binding */ WebRtcSdpEvent),
/* harmony export */   WebRtcSdpOfferEvent: () => (/* binding */ WebRtcSdpOfferEvent),
/* harmony export */   WebRtcTCPRelayDetectedEvent: () => (/* binding */ WebRtcTCPRelayDetectedEvent),
/* harmony export */   XrFrameEvent: () => (/* binding */ XrFrameEvent),
/* harmony export */   XrSessionEndedEvent: () => (/* binding */ XrSessionEndedEvent),
/* harmony export */   XrSessionStartedEvent: () => (/* binding */ XrSessionStartedEvent)
/* harmony export */ });
/**
 * An event that is emitted when AFK disconnect is about to happen.
 * Can be cancelled by calling the callback function provided as part of the event.
 */
class AfkWarningActivateEvent extends Event {
    constructor(data) {
        super('afkWarningActivate');
        this.data = data;
    }
}
/**
 * An event that is emitted when the AFK disconnect countdown is updated.
 */
class AfkWarningUpdateEvent extends Event {
    constructor(data) {
        super('afkWarningUpdate');
        this.data = data;
    }
}
/**
 * An event that is emitted when AFK warning is deactivated.
 */
class AfkWarningDeactivateEvent extends Event {
    constructor() {
        super('afkWarningDeactivate');
    }
}
/**
 * An event that is emitted when AFK countdown reaches 0 and the user is disconnected.
 */
class AfkTimedOutEvent extends Event {
    constructor() {
        super('afkTimedOut');
    }
}
/**
 * An event that is emitted when we receive new video quality value.
 */
class VideoEncoderAvgQPEvent extends Event {
    constructor(data) {
        super('videoEncoderAvgQP');
        this.data = data;
    }
}
/**
 * An event that is emitted after a WebRtc connection has been negotiated.
 */
class WebRtcSdpEvent extends Event {
    constructor() {
        super('webRtcSdp');
    }
}
/**
 * An event that is emitted after the SDP answer is set.
 */
class WebRtcSdpAnswerEvent extends Event {
    constructor(data) {
        super('webRtcSdpAnswer');
        this.data = data;
    }
}
/**
 * An event that is emitted after the SDP offer is set.
 */
class WebRtcSdpOfferEvent extends Event {
    constructor(data) {
        super('webRtcSdpOffer');
        this.data = data;
    }
}
/**
 * An event that is emitted when auto connecting.
 */
class WebRtcAutoConnectEvent extends Event {
    constructor() {
        super('webRtcAutoConnect');
    }
}
/**
 * An event that is emitted when sending a WebRtc offer.
 */
class WebRtcConnectingEvent extends Event {
    constructor() {
        super('webRtcConnecting');
    }
}
/**
 * An event that is emitted when WebRtc connection has been established.
 */
class WebRtcConnectedEvent extends Event {
    constructor() {
        super('webRtcConnected');
    }
}
/**
 * An event that is emitted if WebRtc connection has failed.
 */
class WebRtcFailedEvent extends Event {
    constructor() {
        super('webRtcFailed');
    }
}
/**
 * An event that is emitted if WebRtc connection is disconnected.
 */
class WebRtcDisconnectedEvent extends Event {
    constructor(data) {
        super('webRtcDisconnected');
        this.data = data;
    }
}
/**
 * An event that is emitted when RTCDataChannel is opened.
 */
class DataChannelOpenEvent extends Event {
    constructor(data) {
        super('dataChannelOpen');
        this.data = data;
    }
}
/**
 * An event that is emitted when RTCDataChannel is closed.
 */
class DataChannelCloseEvent extends Event {
    constructor(data) {
        super('dataChannelClose');
        this.data = data;
    }
}
/**
 * An event that is emitted on RTCDataChannel errors.
 */
class DataChannelErrorEvent extends Event {
    constructor(data) {
        super('dataChannelError');
        this.data = data;
    }
}
/**
 * An event that is emitted when the video stream has been initialized.
 */
class VideoInitializedEvent extends Event {
    constructor() {
        super('videoInitialized');
    }
}
/**
 * An event that is emitted when video stream loading starts.
 */
class StreamLoadingEvent extends Event {
    constructor() {
        super('streamLoading');
    }
}
/**
 * An event that is emitted when video stream loading has finished.
 */
class StreamPreConnectEvent extends Event {
    constructor() {
        super('streamConnect');
    }
}
/**
 * An event that is emitted when video stream has stopped.
 */
class StreamPreDisconnectEvent extends Event {
    constructor() {
        super('streamDisconnect');
    }
}
/**
 * An event that is emitted when video stream is reconnecting.
 */
class StreamReconnectEvent extends Event {
    constructor() {
        super('streamReconnect');
    }
}
/**
 * An event that is emitted if there are errors loading the video stream.
 */
class PlayStreamErrorEvent extends Event {
    constructor(data) {
        super('playStreamError');
        this.data = data;
    }
}
/**
 * An event that is emitted before trying to start video playback.
 */
class PlayStreamEvent extends Event {
    constructor() {
        super('playStream');
    }
}
/**
 * An event that is emitted if the browser rejects video playback. Can happen for example if
 * video auto-play without user interaction is refused by the browser.
 */
class PlayStreamRejectedEvent extends Event {
    constructor(data) {
        super('playStreamRejected');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving a full FreezeFrame image from UE.
 */
class LoadFreezeFrameEvent extends Event {
    constructor(data) {
        super('loadFreezeFrame');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving UnfreezeFrame message from UE and video playback is about to be resumed.
 */
class HideFreezeFrameEvent extends Event {
    constructor() {
        super('hideFreezeFrame');
    }
}
/**
 * An event that is emitted when receiving WebRTC statistics.
 */
class StatsReceivedEvent extends Event {
    constructor(data) {
        super('statsReceived');
        this.data = data;
    }
}
/**
 * An event that is emitted when streamer list changes.
 */
class StreamerListMessageEvent extends Event {
    constructor(data) {
        super('streamerListMessage');
        this.data = data;
    }
}
/**
 * An event that is emitted when a subscribed to streamer's id changes.
 */
class StreamerIDChangedMessageEvent extends Event {
    constructor(data) {
        super('StreamerIDChangedMessage');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving latency test results.
 */
class LatencyTestResultEvent extends Event {
    constructor(data) {
        super('latencyTestResult');
        this.data = data;
    }
}
/**
 * An event that is emitted everytime latency is calculated using the WebRTC stats API.
 */
class LatencyCalculatedEvent extends Event {
    constructor(data) {
        super('latencyCalculated');
        this.data = data;
    }
}
/**
 * An event that is emitted when we receive the "onScreenKeyboard" command from UE.
 */
class ShowOnScreenKeyboardEvent extends Event {
    constructor(data) {
        super('showOnScreenKeyboard');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving data channel latency test response from server.
 * This event is handled by DataChannelLatencyTestController
 */
class DataChannelLatencyTestResponseEvent extends Event {
    constructor(data) {
        super('dataChannelLatencyTestResponse');
        this.data = data;
    }
}
/**
 * An event that is emitted when data channel latency test results are ready.
 */
class DataChannelLatencyTestResultEvent extends Event {
    constructor(data) {
        super('dataChannelLatencyTestResult');
        this.data = data;
    }
}
class SubscribeFailedEvent extends Event {
    constructor(data) {
        super('subscribeFailed');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving initial settings from UE.
 */
class InitialSettingsEvent extends Event {
    constructor(data) {
        super('initialSettings');
        this.data = data;
    }
}
/**
 * An event that is emitted when PixelStreaming settings change.
 */
class SettingsChangedEvent extends Event {
    constructor(data) {
        super('settingsChanged');
        this.data = data;
    }
}
/**
 * Event emitted when an XR Session starts
 */
class XrSessionStartedEvent extends Event {
    constructor() {
        super('xrSessionStarted');
    }
}
/**
 * Event emitted when an XR Session ends
 */
class XrSessionEndedEvent extends Event {
    constructor() {
        super('xrSessionEnded');
    }
}
/**
 * Event emitted when an XR Frame is complete
 */
class XrFrameEvent extends Event {
    constructor(data) {
        super('xrFrame');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving a player count from the signalling server
 */
class PlayerCountEvent extends Event {
    constructor(data) {
        super('playerCount');
        this.data = data;
    }
}
/**
 * An event that is emitted when the webRTC connections is relayed over TCP.
 */
class WebRtcTCPRelayDetectedEvent extends Event {
    constructor() {
        super('webRtcTCPRelayDetected');
    }
}
class PixelStreamingEventEmitter extends EventTarget {
    /**
     * Dispatch a new event.
     * @param e event
     * @returns
     */
    dispatchEvent(e) {
        return super.dispatchEvent(e);
    }
    /**
     * Register an event handler.
     * @param type event name
     * @param listener event handler function
     */
    addEventListener(type, listener) {
        super.addEventListener(type, listener);
    }
    /**
     * Remove an event handler.
     * @param type event name
     * @param listener event handler function
     */
    removeEventListener(type, listener) {
        super.removeEventListener(type, listener);
    }
}
//# sourceMappingURL=EventEmitter.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/FileUtil.js":
/*!***********************************************!*\
  !*** ../../library/dist/esm/Util/FileUtil.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FileTemplate: () => (/* binding */ FileTemplate),
/* harmony export */   FileUtil: () => (/* binding */ FileUtil)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Utility function for populate file information from byte buffers.
 */
class FileUtil {
    /**
     * Processes a files extension when received over data channel
     * @param view - the file extension data
     */
    static setExtensionFromBytes(view, file) {
        // Reset file if we got a file message and we are not "receiving" it yet
        if (!file.receiving) {
            file.mimetype = '';
            file.extension = '';
            file.receiving = true;
            file.valid = false;
            file.chunks = 0;
            file.data = [];
            file.timestampStart = new Date().getTime();
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Received first chunk of file');
        }
        const extensionAsString = new TextDecoder('utf-16').decode(view.slice(1));
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(extensionAsString);
        file.extension = extensionAsString;
    }
    /**
     * Processes a files mime type when received over data channel
     * @param view - the file mime type data
     */
    static setMimeTypeFromBytes(view, file) {
        // Reset file if we got a file message and we are not "receiving" it yet
        if (!file.receiving) {
            file.mimetype = '';
            file.extension = '';
            file.receiving = true;
            file.valid = false;
            file.chunks = 0;
            file.data = [];
            file.timestampStart = new Date().getTime();
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Received first chunk of file');
        }
        const mimeAsString = new TextDecoder('utf-16').decode(view.slice(1));
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(mimeAsString);
        file.mimetype = mimeAsString;
    }
    /**
     * Processes a files contents when received over data channel
     * @param view - the file contents data
     */
    static setContentsFromBytes(view, file) {
        // If we haven't received the initial setup instructions, return
        if (!file.receiving)
            return;
        const typeSize = 1;
        const intSize = 4;
        const maxMessageSize = 16 * 1024;
        const headerSize = typeSize + intSize;
        const maxPayloadSize = maxMessageSize - headerSize;
        // Calculate total number of chunks from the total file size
        file.chunks = Math.ceil(new DataView(view.slice(typeSize, headerSize).buffer).getInt32(0, true) / maxPayloadSize);
        // Get the file part of the payload
        const fileBytes = view.slice(headerSize);
        // Append to existing data that holds the file
        file.data.push(fileBytes);
        // Uncomment for debug
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Received file chunk: ${file.data.length}/${file.chunks}`);
        if (file.data.length === file.chunks) {
            file.receiving = false;
            file.valid = true;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Received complete file');
            const transferDuration = new Date().getTime() - file.timestampStart;
            const transferBitrate = Math.round((file.chunks * maxMessageSize) / transferDuration);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Average transfer bitrate: ${transferBitrate}kb/s over ${transferDuration / 1000} seconds`);
            // File reconstruction
            /**
             * Example code to reconstruct the file
             *
             * This code reconstructs the received data into the original file based on the mime type and extension provided and then downloads the reconstructed file
             */
            const received = new Blob(file.data, { type: file.mimetype });
            const a = document.createElement('a');
            a.setAttribute('href', URL.createObjectURL(received));
            a.setAttribute('download', `transfer.${file.extension}`);
            document.body.append(a);
            // if you are so inclined to make it auto-download, do something like: a.click();
            a.remove();
        }
        else if (file.data.length > file.chunks) {
            file.receiving = false;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Received bigger file than advertised: ${file.data.length}/${file.chunks}`);
        }
    }
}
/**
 * A class that represents a template for a downloaded file
 */
class FileTemplate {
    constructor() {
        this.mimetype = '';
        this.extension = '';
        this.receiving = false;
        this.chunks = 0;
        this.data = [];
        this.valid = false;
    }
}
//# sourceMappingURL=FileUtil.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/IURLSearchParams.js":
/*!*******************************************************!*\
  !*** ../../library/dist/esm/Util/IURLSearchParams.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IURLSearchParams: () => (/* binding */ IURLSearchParams)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * A case insensitive, partial implementation of URLSearchParams
 */
class IURLSearchParams {
    constructor(search) {
        this._urlParams = {};
        const urlParams = new URLSearchParams(search);
        for (const [name, value] of urlParams) {
            this._urlParams[name.toLowerCase()] = value;
        }
    }
    has(name) {
        return name.toLowerCase() in this._urlParams;
    }
    get(name) {
        if (this.has(name)) {
            return this._urlParams[name.toLowerCase()];
        }
        return null;
    }
}
//# sourceMappingURL=IURLSearchParams.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/InputCoordTranslator.js":
/*!***********************************************************!*\
  !*** ../../library/dist/esm/Util/InputCoordTranslator.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InputCoordTranslator: () => (/* binding */ InputCoordTranslator)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Converts coordinates from element relative coordinates to values normalized within the value range of a short (and back again)
 */
class InputCoordTranslator {
    // we dont use a constructor here because the object is created and passed around to various locations
    // possibly before this method is called.
    reconfigure(playerSize, videoSize) {
        const playerAspectRatio = playerSize.height / playerSize.width;
        const videoAspectRatio = videoSize.height / videoSize.width;
        this.playerIsLarger = playerAspectRatio > videoAspectRatio;
        this.playerSize = playerSize;
        this.ratio = this.playerIsLarger
            ? playerAspectRatio / videoAspectRatio
            : videoAspectRatio / playerAspectRatio;
    }
    translateUnsigned(x, y) {
        const normalizedX = this.playerIsLarger
            ? x / this.playerSize.width
            : this.ratio * (x / this.playerSize.width - 0.5) + 0.5;
        const normalizedY = this.playerIsLarger
            ? this.ratio * (y / this.playerSize.height - 0.5) + 0.5
            : y / this.playerSize.height;
        if (normalizedX < 0.0 || normalizedX > 1.0 || normalizedY < 0.0 || normalizedY > 1.0) {
            return { inRange: false, x: 65535, y: 65535 };
        }
        else {
            return { inRange: true, x: normalizedX * 65536, y: normalizedY * 65536 };
        }
    }
    translateSigned(x, y) {
        const normalizedX = this.playerIsLarger
            ? x / (0.5 * this.playerSize.width)
            : (this.ratio * x) / (0.5 * this.playerSize.width);
        const normalizedY = this.playerIsLarger
            ? (this.ratio * y) / (0.5 * this.playerSize.height)
            : y / (0.5 * this.playerSize.height);
        return { x: normalizedX * 32767, y: normalizedY * 32767 };
    }
    untranslateUnsigned(x, y) {
        const normalizedX = this.playerIsLarger ? x / 65536 : (x / 65536 - 0.5) / this.ratio + 0.5;
        const normalizedY = this.playerIsLarger ? (y / 65536 - 0.5) / this.ratio + 0.5 : y / 65536;
        return { x: normalizedX * this.playerSize.width, y: normalizedY * this.playerSize.height };
    }
}
//# sourceMappingURL=InputCoordTranslator.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/RTCUtils.js":
/*!***********************************************!*\
  !*** ../../library/dist/esm/Util/RTCUtils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RTCUtils: () => (/* binding */ RTCUtils)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class RTCUtils {
    static isVideoTransceiver(transceiver) {
        return this.canTransceiverReceiveVideo(transceiver) || this.canTransceiverSendVideo(transceiver);
    }
    static canTransceiverReceiveVideo(transceiver) {
        return (!!transceiver &&
            (transceiver.direction === 'sendrecv' || transceiver.direction === 'recvonly') &&
            transceiver.receiver &&
            transceiver.receiver.track &&
            transceiver.receiver.track.kind === 'video');
    }
    static canTransceiverSendVideo(transceiver) {
        return (!!transceiver &&
            (transceiver.direction === 'sendrecv' || transceiver.direction === 'sendonly') &&
            transceiver.sender &&
            transceiver.sender.track &&
            transceiver.sender.track.kind === 'video');
    }
    static isAudioTransceiver(transceiver) {
        return this.canTransceiverReceiveAudio(transceiver) || this.canTransceiverSendAudio(transceiver);
    }
    static canTransceiverReceiveAudio(transceiver) {
        return (!!transceiver &&
            (transceiver.direction === 'sendrecv' || transceiver.direction === 'recvonly') &&
            transceiver.receiver &&
            transceiver.receiver.track &&
            transceiver.receiver.track.kind === 'audio');
    }
    static canTransceiverSendAudio(transceiver) {
        return (!!transceiver &&
            (transceiver.direction === 'sendrecv' || transceiver.direction === 'sendonly') &&
            transceiver.sender &&
            transceiver.sender.track &&
            transceiver.sender.track.kind === 'audio');
    }
}
//# sourceMappingURL=RTCUtils.js.map

/***/ }),

/***/ "../../library/dist/esm/VideoPlayer/StreamController.js":
/*!**************************************************************!*\
  !*** ../../library/dist/esm/VideoPlayer/StreamController.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StreamController: () => (/* binding */ StreamController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Video Player Controller handles the creation of the video HTML element and all handlers
 */
class StreamController {
    /**
     * @param videoElementProvider Video Player instance
     */
    constructor(videoElementProvider) {
        this.videoElementProvider = videoElementProvider;
        this.audioElement = document.createElement('Audio');
        this.videoElementProvider.setAudioElement(this.audioElement);
    }
    /**
     * Handles when the Peer connection has a track event
     * @param rtcTrackEvent - RTC Track Event
     */
    handleOnTrack(rtcTrackEvent) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('handleOnTrack ' + JSON.stringify(rtcTrackEvent.streams));
        // Do not add the track if the ID is `probator` as this is special track created by mediasoup for bitrate probing.
        // Refer to https://github.com/EpicGamesExt/PixelStreamingInfrastructure/pull/86 for more details.
        if (rtcTrackEvent.streams.length < 1 || rtcTrackEvent.streams[0].id == 'probator') {
            return;
        }
        const videoElement = this.videoElementProvider.getVideoElement();
        if (rtcTrackEvent.track) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Got track - ' +
                rtcTrackEvent.track.kind +
                ' id=' +
                rtcTrackEvent.track.id +
                ' readyState=' +
                rtcTrackEvent.track.readyState);
        }
        if (rtcTrackEvent.track.kind == 'audio') {
            this.CreateAudioTrack(rtcTrackEvent.streams[0]);
            return;
        }
        else if (rtcTrackEvent.track.kind == 'video' &&
            videoElement.srcObject !== rtcTrackEvent.streams[0]) {
            videoElement.srcObject = rtcTrackEvent.streams[0];
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Set video source from video track ontrack.');
            return;
        }
    }
    /**
     * Creates the audio device when receiving an RTCTrackEvent with the kind of "audio"
     * @param audioMediaStream - Audio Media stream track
     */
    CreateAudioTrack(audioMediaStream) {
        const videoElement = this.videoElementProvider.getVideoElement();
        // do nothing the video has the same media stream as the audio track we have here (they are linked)
        if (videoElement.srcObject == audioMediaStream) {
            return;
        }
        // video element has some other media stream that is not associated with this audio track
        else if (videoElement.srcObject && videoElement.srcObject !== audioMediaStream) {
            // create a new audio element
            this.audioElement.srcObject = audioMediaStream;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Created new audio element to play separate audio stream.');
        }
    }
}
//# sourceMappingURL=StreamController.js.map

/***/ }),

/***/ "../../library/dist/esm/VideoPlayer/VideoPlayer.js":
/*!*********************************************************!*\
  !*** ../../library/dist/esm/VideoPlayer/VideoPlayer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VideoPlayer: () => (/* binding */ VideoPlayer)
/* harmony export */ });
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * The video player html element
 */
class VideoPlayer {
    /**
     * @param videoElementParent the html div the the video player will be injected into
     * @param config the applications configuration. We're interested in the startVideoMuted flag
     */
    constructor(videoElementParent, config) {
        this.lastTimeResized = new Date().getTime();
        this.videoElement = document.createElement('video');
        this.config = config;
        this.videoElement.id = 'streamingVideo';
        this.videoElement.disablePictureInPicture = true;
        this.videoElement.playsInline = true;
        this.videoElement.style.width = '100%';
        this.videoElement.style.height = '100%';
        this.videoElement.style.position = 'absolute';
        this.videoElement.style.pointerEvents = 'all';
        videoElementParent.appendChild(this.videoElement);
        this.onResizePlayerCallback = () => {
            console.log('Resolution changed, restyling player, did you forget to override this function?');
        };
        this.onMatchViewportResolutionCallback = () => {
            console.log('Resolution changed and match viewport resolution is turned on, did you forget to override this function?');
        };
        // set play for video (and audio)
        this.videoElement.onclick = () => {
            if (this.audioElement != undefined && this.audioElement.paused) {
                this.audioElement.play();
            }
            if (this.videoElement.paused) {
                this.videoElement.play();
            }
        };
        this.videoElement.onloadedmetadata = () => {
            this.onVideoInitialized();
        };
        // set resize events to the windows if it is resized or its orientation is changed
        window.addEventListener('resize', () => this.resizePlayerStyle(), true);
        window.addEventListener('orientationchange', () => this.onOrientationChange());
    }
    destroy() {
        this.videoElement.src = '';
        this.videoElement.srcObject = null;
        this.videoElement.remove();
        if (this.audioElement) {
            this.audioElement.src = '';
            this.audioElement.srcObject = null;
            this.audioElement.remove();
        }
    }
    setAudioElement(audioElement) {
        this.audioElement = audioElement;
    }
    /**
     * Sets up the video element with any application config and plays the video element.
     * @returns A promise for if playing the video was successful or not.
     */
    play() {
        this.videoElement.muted = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_0__.Flags.StartVideoMuted);
        this.videoElement.autoplay = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_0__.Flags.AutoPlayVideo);
        return this.videoElement.play();
    }
    /**
     * @returns True if the video element is paused.
     */
    isPaused() {
        return this.videoElement.paused;
    }
    /**
     * @returns - whether the video element is playing.
     */
    isVideoReady() {
        return this.videoElement.readyState !== undefined && this.videoElement.readyState > 0;
    }
    /**
     * @returns True if the video element has a valid video source (srcObject).
     */
    hasVideoSource() {
        return this.videoElement.srcObject !== undefined && this.videoElement.srcObject !== null;
    }
    /**
     * Get the current context of the html video element
     * @returns - the current context of the video element
     */
    getVideoElement() {
        return this.videoElement;
    }
    /**
     * Get the current context of the html video elements parent
     * @returns - the current context of the video elements parent
     */
    getVideoParentElement() {
        var _a;
        return (_a = this.videoElement.parentElement) !== null && _a !== void 0 ? _a : undefined;
    }
    /**
     * Set the Video Elements src object tracks to enable
     * @param enabled - Enable Tracks on the Src Object
     */
    setVideoEnabled(enabled) {
        // this is a temporary hack until type scripts video element is updated to reflect the need for tracks on a html video element
        const videoElement = this.videoElement;
        videoElement.srcObject
            .getTracks()
            .forEach((track) => (track.enabled = enabled));
    }
    /**
     * An override for when the video has been initialized with a srcObject
     */
    onVideoInitialized() {
        // Default Functionality: Do Nothing
    }
    /**
     * On the orientation change of a window clear the timeout
     */
    onOrientationChange() {
        clearTimeout(this.orientationChangeTimeout);
        this.orientationChangeTimeout = window.setTimeout(() => {
            this.resizePlayerStyle();
        }, 500);
    }
    /**
     * Resizes the player style based on the window height and width
     * @returns - nil if requirements are satisfied
     */
    resizePlayerStyle() {
        const videoElementParent = this.getVideoParentElement();
        if (!videoElementParent) {
            return;
        }
        this.updateVideoStreamSize();
        if (videoElementParent.classList.contains('fixed-size')) {
            this.onResizePlayerCallback();
            return;
        }
        // controls for resizing the player
        this.resizePlayerStyleToFillParentElement();
        this.onResizePlayerCallback();
    }
    /**
     * Resizes the player element to fill the parent element
     */
    resizePlayerStyleToFillParentElement() {
        const videoElementParent = this.getVideoParentElement();
        //Video is not initialized yet so set videoElementParent to size of parent element
        const styleWidth = '100%';
        const styleHeight = '100%';
        const styleTop = 0;
        const styleLeft = 0;
        videoElementParent.setAttribute('style', 'top: ' +
            styleTop +
            'px; left: ' +
            styleLeft +
            'px; width: ' +
            styleWidth +
            '; height: ' +
            styleHeight +
            '; cursor: default;');
    }
    updateVideoStreamSize() {
        if (!this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_0__.Flags.MatchViewportResolution)) {
            return;
        }
        const now = new Date().getTime();
        if (now - this.lastTimeResized > 300) {
            const videoElementParent = this.getVideoParentElement();
            if (!videoElementParent) {
                return;
            }
            this.onMatchViewportResolutionCallback(videoElementParent.clientWidth, videoElementParent.clientHeight);
            this.lastTimeResized = new Date().getTime();
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Resizing too often - skipping');
            clearTimeout(this.resizeTimeoutHandle);
            this.resizeTimeoutHandle = window.setTimeout(() => this.updateVideoStreamSize(), 100);
        }
    }
}
//# sourceMappingURL=VideoPlayer.js.map

/***/ }),

/***/ "../../library/dist/esm/WebRtcPlayer/WebRtcPlayerController.js":
/*!*********************************************************************!*\
  !*** ../../library/dist/esm/WebRtcPlayer/WebRtcPlayerController.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebRtcPlayerController: () => (/* binding */ WebRtcPlayerController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Transport/WebSocketTransport.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Protocol/SignallingProtocol.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Messages/signalling_messages.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Messages/message_helpers.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Protocol/KeepaliveMonitor.js");
/* harmony import */ var _VideoPlayer_StreamController__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../VideoPlayer/StreamController */ "../../library/dist/esm/VideoPlayer/StreamController.js");
/* harmony import */ var _FreezeFrame_FreezeFrameController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../FreezeFrame/FreezeFrameController */ "../../library/dist/esm/FreezeFrame/FreezeFrameController.js");
/* harmony import */ var _AFK_AFKController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../AFK/AFKController */ "../../library/dist/esm/AFK/AFKController.js");
/* harmony import */ var _DataChannel_DataChannelController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../DataChannel/DataChannelController */ "../../library/dist/esm/DataChannel/DataChannelController.js");
/* harmony import */ var _PeerConnectionController_PeerConnectionController__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../PeerConnectionController/PeerConnectionController */ "../../library/dist/esm/PeerConnectionController/PeerConnectionController.js");
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _DataChannel_InitialSettings__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../DataChannel/InitialSettings */ "../../library/dist/esm/DataChannel/InitialSettings.js");
/* harmony import */ var _DataChannel_LatencyTestResults__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../DataChannel/LatencyTestResults */ "../../library/dist/esm/DataChannel/LatencyTestResults.js");
/* harmony import */ var _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util/FileUtil */ "../../library/dist/esm/Util/FileUtil.js");
/* harmony import */ var _Inputs_InputClassesFactory__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../Inputs/InputClassesFactory */ "../../library/dist/esm/Inputs/InputClassesFactory.js");
/* harmony import */ var _VideoPlayer_VideoPlayer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../VideoPlayer/VideoPlayer */ "../../library/dist/esm/VideoPlayer/VideoPlayer.js");
/* harmony import */ var _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../UeInstanceMessage/StreamMessageController */ "../../library/dist/esm/UeInstanceMessage/StreamMessageController.js");
/* harmony import */ var _UeInstanceMessage_ResponseController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../UeInstanceMessage/ResponseController */ "../../library/dist/esm/UeInstanceMessage/ResponseController.js");
/* harmony import */ var _UeInstanceMessage_SendMessageController__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../UeInstanceMessage/SendMessageController */ "../../library/dist/esm/UeInstanceMessage/SendMessageController.js");
/* harmony import */ var _UeInstanceMessage_ToStreamerMessagesController__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../UeInstanceMessage/ToStreamerMessagesController */ "../../library/dist/esm/UeInstanceMessage/ToStreamerMessagesController.js");
/* harmony import */ var _DataChannel_DataChannelSender__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../DataChannel/DataChannelSender */ "../../library/dist/esm/DataChannel/DataChannelSender.js");
/* harmony import */ var _Util_InputCoordTranslator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Util/InputCoordTranslator */ "../../library/dist/esm/Util/InputCoordTranslator.js");
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../Util/EventEmitter */ "../../library/dist/esm/Util/EventEmitter.js");
/* harmony import */ var _Util_IURLSearchParams__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../Util/IURLSearchParams */ "../../library/dist/esm/Util/IURLSearchParams.js");
/* harmony import */ var _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../Util/BrowserUtils */ "../../library/dist/esm/Util/BrowserUtils.js");
// Copyright Epic Games, Inc. All Rights Reserved.





















/**
 * Entry point for the WebRTC Player
 */
class WebRtcPlayerController {
    /**
     *
     * @param config - the frontend config object
     * @param pixelStreaming - the PixelStreaming object
     */
    constructor(config, pixelStreaming) {
        this.shouldShowPlayOverlay = true;
        this.autoJoinTimer = undefined;
        this.config = config;
        this.pixelStreaming = pixelStreaming;
        this.responseController = new _UeInstanceMessage_ResponseController__WEBPACK_IMPORTED_MODULE_0__.ResponseController();
        this.file = new _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__.FileTemplate();
        this.sdpConstraints = {
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
        };
        // set up the afk logic class and connect up its method for closing the signaling server
        this.afkController = new _AFK_AFKController__WEBPACK_IMPORTED_MODULE_2__.AFKController(this.config, this.pixelStreaming, this.onAfkTriggered.bind(this));
        this.afkController.onAFKTimedOutCallback = () => {
            this.closeSignalingServer('You have been disconnected due to inactivity.', false);
        };
        this.freezeFrameController = new _FreezeFrame_FreezeFrameController__WEBPACK_IMPORTED_MODULE_3__.FreezeFrameController(this.pixelStreaming.videoElementParent);
        this.videoPlayer = new _VideoPlayer_VideoPlayer__WEBPACK_IMPORTED_MODULE_4__.VideoPlayer(this.pixelStreaming.videoElementParent, this.config);
        this.videoPlayer.onVideoInitialized = () => this.handleVideoInitialized();
        // When in match viewport resolution mode, when the browser viewport is resized we send a resize command back to UE.
        this.videoPlayer.onMatchViewportResolutionCallback = (width, height) => {
            const descriptor = {
                'Resolution.Width': width,
                'Resolution.Height': height
            };
            this.streamMessageController.toStreamerHandlers.get('Command')([JSON.stringify(descriptor)]);
        };
        // Every time video player is resized in browser we need to reinitialize the mouse coordinate conversion and freeze frame sizing logic.
        this.videoPlayer.onResizePlayerCallback = () => {
            this.setUpMouseAndFreezeFrame();
        };
        this.streamController = new _VideoPlayer_StreamController__WEBPACK_IMPORTED_MODULE_5__.StreamController(this.videoPlayer);
        this.coordinateConverter = new _Util_InputCoordTranslator__WEBPACK_IMPORTED_MODULE_6__.InputCoordTranslator();
        this.sendrecvDataChannelController = new _DataChannel_DataChannelController__WEBPACK_IMPORTED_MODULE_7__.DataChannelController();
        this.recvDataChannelController = new _DataChannel_DataChannelController__WEBPACK_IMPORTED_MODULE_7__.DataChannelController();
        this.registerDataChannelEventEmitters(this.sendrecvDataChannelController);
        this.registerDataChannelEventEmitters(this.recvDataChannelController);
        this.dataChannelSender = new _DataChannel_DataChannelSender__WEBPACK_IMPORTED_MODULE_8__.DataChannelSender(this.sendrecvDataChannelController);
        this.dataChannelSender.resetAfkWarningTimerOnDataSend = () => this.afkController.resetAfkWarningTimer();
        this.streamMessageController = new _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.StreamMessageController();
        // set up websocket methods
        this.transport = new _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_10__.WebSocketTransport(config.webSocketProtocols);
        this.protocol = new _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_11__.SignallingProtocol(this.transport);
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.config.typeName, (msg) => this.handleOnConfigMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.ping.typeName, (msg) => this.handlePingMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.streamerList.typeName, (msg) => this.handleStreamerListMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.subscribeFailed.typeName, (msg) => this.handleSubscribeFailedMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.streamerIdChanged.typeName, (msg) => this.handleStreamerIDChangedMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.playerCount.typeName, (msg) => {
            const playerCountMessage = msg;
            this.pixelStreaming._onPlayerCount(playerCountMessage.count);
        });
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.answer.typeName, (msg) => this.handleWebRtcAnswer(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.offer.typeName, (msg) => this.handleWebRtcOffer(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.peerDataChannels.typeName, (msg) => this.handleWebRtcSFUPeerDatachannels(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.iceCandidate.typeName, (msg) => {
            const iceCandidateMessage = msg;
            this.handleIceCandidate(iceCandidateMessage.candidate);
        });
        this.protocol.transport.addListener('open', () => {
            const BrowserSendOffer = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.BrowserSendOffer);
            if (!BrowserSendOffer) {
                const message = _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.listStreamers);
                this.protocol.sendMessage(message);
            }
            this.reconnectAttempt = 0;
            this.isReconnecting = false;
        });
        this.protocol.transport.addListener('error', () => {
            // dont really need to do anything here since the close event should follow.
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`Got a transport error.`);
        });
        this.protocol.transport.addListener('close', (event) => {
            // when we refresh the page during a stream we get the going away code.
            // in that case we don't want to reconnect since we're navigating away.
            // https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code
            // lists all the codes.
            const CODE_GOING_AWAY = 1001;
            const maxReconnectAttempts = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.MaxReconnectAttempts);
            const attemptsLeft = this.reconnectAttempt < maxReconnectAttempts;
            const reconnectEnabled = this.forceReconnect || (this.enableAutoReconnect && maxReconnectAttempts > 0 && attemptsLeft);
            const willTryReconnect = reconnectEnabled && event.code != CODE_GOING_AWAY;
            const allowClickToReconnect = !willTryReconnect;
            const disconnectMessage = this.disconnectMessage ? this.disconnectMessage : event.reason;
            this.forceReconnect = false;
            // Reset the list of all possible codecs on disconnect so that if the next connection has "NegotiateCodecs" on
            // then all codecs can be negotiated
            this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.PreferredCodec).options =
                _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_16__.BrowserUtils.getSupportedVideoCodecs();
            this.pixelStreaming._onDisconnect(disconnectMessage, allowClickToReconnect);
            this.afkController.stopAfkWarningTimer();
            // stop sending stats on interval if we have closed our connection
            if (this.statsTimerHandle && this.statsTimerHandle !== undefined) {
                window.clearInterval(this.statsTimerHandle);
            }
            // reset the stream quality icon.
            this.setVideoEncoderAvgQP(0);
            // unregister all input device event handlers on disconnect
            this.setTouchInputEnabled(false);
            this.setMouseInputEnabled(false);
            this.setKeyboardInputEnabled(false);
            this.setGamePadInputEnabled(false);
            if (willTryReconnect) {
                // need a small delay here to prevent reconnect spamming
                setTimeout(() => {
                    this.reconnectAttempt++;
                    this.doReconnect(event.reason);
                }, 2000);
            }
        });
        // set up the final webRtc player controller methods from within our application so a connection can be activated
        this.sendMessageController = new _UeInstanceMessage_SendMessageController__WEBPACK_IMPORTED_MODULE_17__.SendMessageController(this.dataChannelSender, this.streamMessageController);
        this.toStreamerMessagesController = new _UeInstanceMessage_ToStreamerMessagesController__WEBPACK_IMPORTED_MODULE_18__.ToStreamerMessagesController(this.sendMessageController);
        this.registerMessageHandlers();
        this.streamMessageController.populateDefaultProtocol();
        this.inputClassesFactory = new _Inputs_InputClassesFactory__WEBPACK_IMPORTED_MODULE_19__.InputClassesFactory(this.streamMessageController, this.videoPlayer, this.coordinateConverter);
        this.isUsingSFU = false;
        this.isUsingSVC = false;
        this.isQualityController = false;
        this.preferredCodec = '';
        this.enableAutoReconnect = true;
        this.forceReconnect = false;
        this.reconnectAttempt = 0;
        this.isReconnecting = false;
        this.config._addOnOptionSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId, (streamerid) => {
            if (streamerid === undefined || streamerid === '') {
                return;
            }
            // close the current peer connection and create a new one
            this.peerConnectionController.peerConnection.close();
            this.peerConnectionController.createPeerConnection(this.peerConfig, this.preferredCodec);
            this.subscribedStream = streamerid;
            const message = _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.subscribe, { streamerId: streamerid });
            this.protocol.sendMessage(message);
        });
        this.config._addOnOptionSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.PreferredQuality, (preferredQuality) => {
            if (preferredQuality === undefined || preferredQuality === '') {
                return;
            }
            let message;
            if (this.isUsingSVC) {
                // User is using SVC so selected quality will be of the form SxTy(h). Just extract the x and y numbers
                message = _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.layerPreference, {
                    spatialLayer: +preferredQuality[1] - 1,
                    temporalLayer: +preferredQuality[3] - 1
                });
            }
            else {
                // User is not using SVC so the selected quality will be either Low, Medium or High so we extract the appropriate spatial layer index
                const allQualities = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.PreferredQuality).options;
                const qualityIndex = allQualities.indexOf(preferredQuality);
                message = _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.layerPreference, {
                    spatialLayer: qualityIndex,
                    temporalLayer: 0
                });
            }
            this.protocol.sendMessage(message);
        });
        this.setVideoEncoderAvgQP(-1);
        this.signallingUrlBuilder = () => {
            const signallingServerUrl = this.config.getTextSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.TextParameters.SignallingServerUrl);
            return signallingServerUrl;
        };
    }
    /**
     * Destroys the video player and makes sure resources are freed. This helps to prevent the issue in chrome
     * where it refuses to make new video players.
     */
    destroyVideoPlayer() {
        this.videoPlayer.destroy();
    }
    /**
     * Handles when a message is received
     * @param event - Message Event
     */
    handleOnMessage(event) {
        const message = new Uint8Array(event.data);
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Message incoming:' + message);
        //try {
        const messageType = this.streamMessageController.fromStreamerMessages.get(message[0]);
        this.streamMessageController.fromStreamerHandlers.get(messageType)(event.data);
        //} catch (e) {
        //Logger.Error(Logger.GetStackTrace(), `Custom data channel message with message type that is unknown to the Pixel Streaming protocol. Does your PixelStreamingProtocol need updating? The message type was: ${message[0]}`);
        //}
    }
    /**
     * Register message all handlers
     */
    registerMessageHandlers() {
        // From Streamer
        // Message events from the streamer have a data type of ArrayBuffer as we force this type in the DatachannelController
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'QualityControlOwnership', (data) => this.onQualityControlOwnership(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'Response', (data) => this.responseController.onResponse(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'Command', (data) => {
            this.onCommand(data);
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'FreezeFrame', (data) => this.onFreezeFrameMessage(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'UnfreezeFrame', () => this.invalidateFreezeFrameAndEnableVideo());
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'VideoEncoderAvgQP', (data) => this.handleVideoEncoderAvgQP(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'LatencyTest', (data) => this.handleLatencyTestResult(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'DataChannelLatencyTest', (data) => this.handleDataChannelLatencyTestResponse(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'InitialSettings', (data) => this.handleInitialSettings(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'FileExtension', (data) => this.onFileExtension(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'FileMimeType', (data) => this.onFileMimeType(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'FileContents', (data) => this.onFileContents(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'TestEcho', () => {
            /* Do nothing */
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'InputControlOwnership', (data) => this.onInputControlOwnership(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'GamepadResponse', (data) => this.onGamepadResponse(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'Multiplexed', () => {
            /* Do nothing as this message type is used only by the SFU */
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'Protocol', (data) => this.onProtocolMessage(data));
        // To Streamer
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'IFrameRequest', () => this.sendMessageController.sendMessageToStreamer('IFrameRequest'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'RequestQualityControl', () => this.sendMessageController.sendMessageToStreamer('RequestQualityControl'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'FpsRequest', () => this.sendMessageController.sendMessageToStreamer('FpsRequest'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'AverageBitrateRequest', () => this.sendMessageController.sendMessageToStreamer('AverageBitrateRequest'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'StartStreaming', () => this.sendMessageController.sendMessageToStreamer('StartStreaming'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'StopStreaming', () => this.sendMessageController.sendMessageToStreamer('StopStreaming'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'LatencyTest', (data) => this.sendMessageController.sendMessageToStreamer('LatencyTest', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'RequestInitialSettings', () => this.sendMessageController.sendMessageToStreamer('RequestInitialSettings'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TestEcho', () => {
            /* Do nothing */
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'UIInteraction', (data) => this.sendMessageController.sendMessageToStreamer('UIInteraction', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'Command', (data) => this.sendMessageController.sendMessageToStreamer('Command', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TextboxEntry', (data) => this.sendMessageController.sendMessageToStreamer('TextboxEntry', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'KeyDown', (data) => this.sendMessageController.sendMessageToStreamer('KeyDown', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'KeyUp', (data) => this.sendMessageController.sendMessageToStreamer('KeyUp', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'KeyPress', (data) => this.sendMessageController.sendMessageToStreamer('KeyPress', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseEnter', (data) => this.sendMessageController.sendMessageToStreamer('MouseEnter', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseLeave', (data) => this.sendMessageController.sendMessageToStreamer('MouseLeave', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseDown', (data) => this.sendMessageController.sendMessageToStreamer('MouseDown', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseUp', (data) => this.sendMessageController.sendMessageToStreamer('MouseUp', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseMove', (data) => this.sendMessageController.sendMessageToStreamer('MouseMove', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseWheel', (data) => this.sendMessageController.sendMessageToStreamer('MouseWheel', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseDouble', (data) => this.sendMessageController.sendMessageToStreamer('MouseDouble', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TouchStart', (data) => this.sendMessageController.sendMessageToStreamer('TouchStart', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TouchEnd', (data) => this.sendMessageController.sendMessageToStreamer('TouchEnd', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TouchMove', (data) => this.sendMessageController.sendMessageToStreamer('TouchMove', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadConnected', () => this.sendMessageController.sendMessageToStreamer('GamepadConnected'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadButtonPressed', (data) => this.sendMessageController.sendMessageToStreamer('GamepadButtonPressed', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadButtonReleased', (data) => this.sendMessageController.sendMessageToStreamer('GamepadButtonReleased', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadAnalog', (data) => this.sendMessageController.sendMessageToStreamer('GamepadAnalog', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadDisconnected', (data) => this.sendMessageController.sendMessageToStreamer('GamepadDisconnected', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XREyeViews', (data) => this.sendMessageController.sendMessageToStreamer('XREyeViews', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRHMDTransform', (data) => this.sendMessageController.sendMessageToStreamer('XRHMDTransform', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRControllerTransform', (data) => this.sendMessageController.sendMessageToStreamer('XRControllerTransform', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRSystem', (data) => this.sendMessageController.sendMessageToStreamer('XRSystem', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRButtonTouched', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonTouched', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRButtonTouchReleased', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonTouchReleased', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRButtonPressed', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonPressed', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRButtonReleased', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonReleased', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRAnalog', (data) => this.sendMessageController.sendMessageToStreamer('XRAnalog', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'ChannelRelayStatus', () => {
            /* Do nothing as this message type is used only by the SFU */
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'Multiplexed', () => {
            /* Do nothing as this message type is used only by the SFU */
        });
    }
    /**
     * Activate the logic associated with a command from UE
     * @param message
     */
    onCommand(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.Command');
        const commandAsString = new TextDecoder('utf-16').decode(message.slice(1));
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Data Channel Command: ' + commandAsString);
        const command = JSON.parse(commandAsString);
        // Handle "onScreenKeyboard" event
        if (command.command === 'onScreenKeyboard') {
            this.handleOnScreenKeyboardCommand(command);
        }
    }
    handleOnScreenKeyboardCommand(command) {
        var _a, _b, _c, _d;
        const data = {
            showOnScreenKeyboard: (_a = command.showOnScreenKeyboard) !== null && _a !== void 0 ? _a : true,
            x: (_b = command.x) !== null && _b !== void 0 ? _b : 0,
            y: (_c = command.y) !== null && _c !== void 0 ? _c : 0,
            contents: (_d = command.contents) !== null && _d !== void 0 ? _d : ''
        };
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.ShowOnScreenKeyboardEvent(data));
    }
    /**
     * Handles a protocol message received from the streamer
     * @param message the message data from the streamer
     */
    onProtocolMessage(message) {
        try {
            const protocolString = new TextDecoder('utf-16').decode(message.slice(1));
            const protocolJSON = JSON.parse(protocolString);
            if (!Object.prototype.hasOwnProperty.call(protocolJSON, 'Direction')) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error('Malformed protocol received. Ensure the protocol message contains a direction');
            }
            const direction = protocolJSON.Direction;
            delete protocolJSON.Direction;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Received new ${direction == _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer ? 'FromStreamer' : 'ToStreamer'} protocol. Updating existing protocol...`);
            Object.keys(protocolJSON).forEach((messageType) => {
                const message = protocolJSON[messageType];
                switch (direction) {
                    case _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer:
                        // Check that the message contains all the relevant params
                        if (!Object.prototype.hasOwnProperty.call(message, 'id')) {
                            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`ToStreamer->${messageType} protocol definition was malformed as it didn't contain at least an id\n
                                           Definition was: ${JSON.stringify(message, null, 2)}`);
                            // return in a forEach is equivalent to a continue in a normal for loop
                            return;
                        }
                        // UE5.1 and UE5.2 don't send a structure for these message types, but they actually do have a structure so ignore updating them
                        if (messageType === 'UIInteraction' ||
                            messageType === 'Command' ||
                            messageType === 'LatencyTest') {
                            return;
                        }
                        if (this.streamMessageController.toStreamerHandlers.get(messageType)) {
                            // If we've registered a handler for this message type we can add it to our supported messages. ie registerMessageHandler(...)
                            this.streamMessageController.toStreamerMessages.set(messageType, message);
                        }
                        else {
                            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`There was no registered handler for "${messageType}" - try adding one using registerMessageHandler(MessageDirection.ToStreamer, "${messageType}", myHandler)`);
                        }
                        break;
                    case _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer:
                        // Check that the message contains all the relevant params
                        if (!Object.prototype.hasOwnProperty.call(message, 'id')) {
                            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`FromStreamer->${messageType} protocol definition was malformed as it didn't contain at least an id\n
                            Definition was: ${JSON.stringify(message, null, 2)}`);
                            // return in a forEach is equivalent to a continue in a normal for loop
                            return;
                        }
                        if (this.streamMessageController.fromStreamerHandlers.get(messageType)) {
                            // If we've registered a handler for this message type. ie registerMessageHandler(...)
                            this.streamMessageController.fromStreamerMessages.set(message.id, messageType);
                        }
                        else {
                            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`There was no registered handler for "${message}" - try adding one using registerMessageHandler(MessageDirection.FromStreamer, "${messageType}", myHandler)`);
                        }
                        break;
                    default:
                        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`Unknown direction: ${direction}`);
                }
            });
            // Once the protocol has been received, we can send our control messages
            this.toStreamerMessagesController.SendRequestInitialSettings();
            this.toStreamerMessagesController.SendRequestQualityControl();
        }
        catch (e) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(e);
        }
    }
    /**
     * Handles an input control message when it is received from the streamer
     * @param message The input control message
     */
    onInputControlOwnership(message) {
        const view = new Uint8Array(message);
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.InputControlOwnership');
        const inputControlOwnership = new Boolean(view[1]).valueOf();
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Received input controller message - will your input control the stream: ${inputControlOwnership}`);
        this.pixelStreaming._onInputControlOwnership(inputControlOwnership);
    }
    /**
     *
     * @param message
     */
    onGamepadResponse(message) {
        const responseString = new TextDecoder('utf-16').decode(message.slice(1));
        const responseJSON = JSON.parse(responseString);
        this.gamePadController.onGamepadResponseReceived(responseJSON.controllerId);
    }
    onAfkTriggered() {
        this.afkController.onAfkClick();
        // if the stream is paused play it, if we can
        if (this.videoPlayer.isPaused() && this.videoPlayer.hasVideoSource()) {
            this.playStream();
        }
    }
    /**
     * Set whether we should timeout when afk.
     * @param afkEnabled If true we timeout when idle for some given amount of time.
     */
    setAfkEnabled(afkEnabled) {
        if (afkEnabled) {
            this.onAfkTriggered();
        }
        else {
            this.afkController.stopAfkWarningTimer();
        }
    }
    /**
     * Attempt a reconnection to the signalling server. Manual trigger
     */
    tryReconnect(message) {
        this.forceReconnect = true;
        this.doReconnect(message);
    }
    /**
     * Does the actual reconnect work. Used by the auto reconnect feature to skip the manual flag.
     */
    doReconnect(message) {
        // if there is no webSocketController return immediately or this will not work
        if (!this.protocol) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('This player has no protocol connection.');
            return;
        }
        this.isReconnecting = true;
        // if the connection is open, first close it and force a reconnect.
        if (this.protocol.isConnected()) {
            if (!this.forceReconnect) {
                this.disconnectMessage = `${message} Reconnecting.`;
            }
            this.closeSignalingServer(message, true);
        }
        else {
            this.pixelStreaming._onWebRtcAutoConnect();
            this.connectToSignallingServer();
        }
    }
    /**
     * Loads a freeze frame if it is required otherwise shows the play overlay
     */
    loadFreezeFrameOrShowPlayOverlay() {
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.LoadFreezeFrameEvent({
            shouldShowPlayOverlay: this.shouldShowPlayOverlay,
            isValid: this.freezeFrameController.valid,
            jpegData: this.freezeFrameController.jpeg
        }));
        if (this.shouldShowPlayOverlay === true) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('showing play overlay');
            this.resizePlayerStyle();
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('showing freeze frame');
            this.freezeFrameController.showFreezeFrame();
        }
        setTimeout(() => {
            this.videoPlayer.setVideoEnabled(false);
        }, this.freezeFrameController.freezeFrameDelay);
    }
    /**
     * Process the freeze frame and load it
     * @param message The freeze frame data in bytes
     */
    onFreezeFrameMessage(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.FreezeFrame');
        const view = new Uint8Array(message);
        this.freezeFrameController.processFreezeFrameMessage(view, () => this.loadFreezeFrameOrShowPlayOverlay());
    }
    /**
     * Enable the video after hiding a freeze frame
     */
    invalidateFreezeFrameAndEnableVideo() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.FreezeFrame');
        setTimeout(() => {
            this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.HideFreezeFrameEvent());
            this.freezeFrameController.hideFreezeFrame();
        }, this.freezeFrameController.freezeFrameDelay);
        if (this.videoPlayer.getVideoElement()) {
            this.videoPlayer.setVideoEnabled(true);
        }
    }
    /**
     * Prep datachannel data for processing file extension
     * @param data the file extension data
     */
    onFileExtension(data) {
        const view = new Uint8Array(data);
        _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__.FileUtil.setExtensionFromBytes(view, this.file);
    }
    /**
     * Prep datachannel data for processing the file mime type
     * @param data the file mime type data
     */
    onFileMimeType(data) {
        const view = new Uint8Array(data);
        _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__.FileUtil.setMimeTypeFromBytes(view, this.file);
    }
    /**
     * Prep datachannel data for processing the file contents
     * @param data the file contents data
     */
    onFileContents(data) {
        const view = new Uint8Array(data);
        _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__.FileUtil.setContentsFromBytes(view, this.file);
    }
    /**
     * Plays the stream audio and video source and sets up other pieces while the stream starts
     */
    playStream() {
        if (!this.videoPlayer.getVideoElement()) {
            const message = 'Could not play video stream because the video player was not initialized correctly.';
            this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.PlayStreamErrorEvent({ message }));
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(message);
            // close the connection
            this.closeSignalingServer('Stream not initialized correctly', false);
            return;
        }
        if (!this.videoPlayer.hasVideoSource()) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Warning('Cannot play stream, the video element has no srcObject to play.');
            return;
        }
        this.setTouchInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.TouchInput));
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.PlayStreamEvent());
        if (this.streamController.audioElement.srcObject) {
            const startMuted = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.StartVideoMuted);
            this.streamController.audioElement.muted = startMuted;
            if (startMuted) {
                this.playVideo();
            }
            else {
                this.streamController.audioElement
                    .play()
                    .then(() => {
                    this.playVideo();
                })
                    .catch((onRejectedReason) => {
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(onRejectedReason);
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Browser does not support autoplaying video without interaction - to resolve this we are going to show the play button overlay.');
                    this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.PlayStreamRejectedEvent({
                        reason: onRejectedReason
                    }));
                });
            }
        }
        else {
            this.playVideo();
        }
        this.shouldShowPlayOverlay = false;
        this.freezeFrameController.showFreezeFrame();
    }
    /**
     * Plays the video stream
     */
    playVideo() {
        // handle play() with promise as it is an asynchronous call
        this.videoPlayer.play().catch((onRejectedReason) => {
            if (this.streamController.audioElement.srcObject) {
                this.streamController.audioElement.pause();
            }
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(onRejectedReason);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Browser does not support autoplaying video without interaction - to resolve this we are going to show the play button overlay.');
            this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.PlayStreamRejectedEvent({ reason: onRejectedReason }));
        });
    }
    /**
     * Enable the video to play automatically if enableAutoplay is true
     */
    autoPlayVideoOrSetUpPlayOverlay() {
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.AutoPlayVideo)) {
            // attempt to play the video
            this.playStream();
        }
        this.resizePlayerStyle();
    }
    /**
     * Connect to the Signaling server
     */
    connectToSignallingServer() {
        this.locallyClosed = false;
        this.enableAutoReconnect = true;
        this.disconnectMessage = null;
        const signallingUrl = this.signallingUrlBuilder();
        this.protocol.connect(signallingUrl);
        const keepaliveDelay = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.KeepaliveDelay);
        if (keepaliveDelay > 0) {
            this.keepalive = new _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_21__.KeepaliveMonitor(this.protocol, keepaliveDelay);
            this.keepalive.onTimeout = () => {
                // if the ping fails just disconnect
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`Protocol timeout`);
                this.protocol.disconnect();
            };
        }
    }
    /**
     * This will start the handshake to the signalling server
     * @param peerConfig  - RTC Configuration Options from the Signaling server
     * @remark RTC Peer Connection on Ice Candidate event have it handled by handle Send Ice Candidate
     */
    startSession(peerConfig) {
        this.peerConfig = peerConfig;
        // check for forcing turn
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.ForceTURN)) {
            // check for a turn server
            const hasTurnServer = this.checkTurnServerAvailability(peerConfig);
            // close and error if turn is forced and there is no turn server
            if (!hasTurnServer) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('No turn server was found in the Peer Connection Options. TURN cannot be forced, closing connection. Please use STUN instead');
                this.closeSignalingServer('TURN cannot be forced, closing connection. Please use STUN instead.', false);
                return;
            }
        }
        // set up the peer connection controller
        this.peerConnectionController = new _PeerConnectionController_PeerConnectionController__WEBPACK_IMPORTED_MODULE_22__.PeerConnectionController(this.peerConfig, this.config, this.preferredCodec);
        // set up peer connection controller video stats
        this.peerConnectionController.onVideoStats = (event) => {
            this.handleVideoStats(event);
        };
        /* Set event handler for latency information is calculated, handle the event by propogating to the PixelStreaming API */
        this.peerConnectionController.onLatencyCalculated = (latencyInfo) => {
            this.pixelStreaming._onLatencyCalculated(latencyInfo);
        };
        /* When our PeerConnection wants to send an offer call our handler */
        this.peerConnectionController.onSendWebRTCOffer = (offer) => {
            this.handleSendWebRTCOffer(offer);
        };
        /* Set event handler for when local description is set */
        this.peerConnectionController.onSetLocalDescription = (sdp) => {
            if (sdp.type === 'offer') {
                this.handleSendWebRTCOffer(sdp);
            }
            else if (sdp.type === 'answer') {
                this.handleSendWebRTCAnswer(sdp);
            }
            else {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`PeerConnectionController onSetLocalDescription was called with unexpected type ${sdp.type}`);
            }
        };
        /* Event handler for when PeerConnection's remote description is set */
        this.peerConnectionController.onSetRemoteDescription = (sdp) => {
            if (sdp.type === 'offer') {
                this.pixelStreaming._onWebRtcSdpOffer(sdp);
            }
            else if (sdp.type === 'answer') {
                this.pixelStreaming._onWebRtcSdpAnswer(sdp);
            }
            else {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`PeerConnectionController onSetRemoteDescription was called with unexpected type ${sdp.type}`);
            }
        };
        /* When the Peer Connection ice candidate is added have it handled */
        this.peerConnectionController.onPeerIceCandidate = (peerConnectionIceEvent) => this.handleSendIceCandidate(peerConnectionIceEvent);
        /* When the Peer Connection has a data channel created for it by the browser, handle it */
        this.peerConnectionController.onDataChannel = (datachannelEvent) => this.handleDataChannel(datachannelEvent);
        // set up webRtc text overlays
        this.peerConnectionController.showTextOverlayConnecting = () => this.pixelStreaming._onWebRtcConnecting();
        this.peerConnectionController.showTextOverlaySetupFailure = () => this.pixelStreaming._onWebRtcFailed();
        let webRtcConnectedSent = false;
        this.peerConnectionController.onIceConnectionStateChange = () => {
            // Browsers emit "connected" when getting first connection and "completed" when finishing
            // candidate checking. However, sometimes browsers can skip "connected" and only emit "completed".
            // Therefore need to check both cases and emit onWebRtcConnected only once on the first hit.
            if (!webRtcConnectedSent &&
                ['connected', 'completed'].includes(this.peerConnectionController.peerConnection.iceConnectionState)) {
                this.pixelStreaming._onWebRtcConnected();
                webRtcConnectedSent = true;
            }
        };
        /* RTC Peer Connection on Track event -> handle on track */
        this.peerConnectionController.onTrack = (trackEvent) => this.streamController.handleOnTrack(trackEvent);
        const BrowserSendOffer = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.BrowserSendOffer);
        if (BrowserSendOffer) {
            // If browser is sending the offer, create an offer and send it to the streamer
            this.sendrecvDataChannelController.createDataChannel(this.peerConnectionController.peerConnection, 'cirrus', this.datachannelOptions);
            this.sendrecvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
            this.peerConnectionController.createOffer(this.sdpConstraints, this.config);
        }
    }
    /**
     * Checks the peer connection options for a turn server and returns true or false
     */
    checkTurnServerAvailability(options) {
        // if iceServers is empty return false this should not be the general use case but is here incase
        if (!options.iceServers) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('A turn sever was not found');
            return false;
        }
        // loop through the ice servers to check for a turn url
        for (const iceServer of options.iceServers) {
            for (const url of iceServer.urls) {
                if (url.includes('turn')) {
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`A turn sever was found at ${url}`);
                    return true;
                }
            }
        }
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('A turn sever was not found');
        return false;
    }
    /**
     * Handles when a Config Message is received contains the Peer Connection Options required (STUN and TURN Server Info)
     * @param messageConfig - Config Message received from the signaling server
     */
    handleOnConfigMessage(messageConfig) {
        this.resizePlayerStyle();
        // Tell the WebRtcController to start a session with the peer options sent from the signaling server
        this.startSession(messageConfig.peerConnectionOptions);
    }
    handlePingMessage(pingMessage) {
        this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.pong, { time: pingMessage.time }));
    }
    /**
     * Handles when the signalling server gives us the list of streamer ids.
     */
    handleStreamerListMessage(messageStreamerList) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Got streamer list ${messageStreamerList.ids}`);
        let wantedStreamerId = '';
        // get the current selected streamer id option
        const streamerIDOption = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId);
        const existingSelection = streamerIDOption.selected.toString().trim();
        if (existingSelection) {
            // default to selected option if it exists
            wantedStreamerId = streamerIDOption.selected;
        }
        // add the streamers to the UI
        const settingOptions = [...messageStreamerList.ids]; // copy the original messageStreamerList.ids
        settingOptions.unshift(''); // add an empty option at the top
        this.config.setOptionSettingOptions(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId, settingOptions);
        let autoSelectedStreamerId = '';
        const waitForStreamer = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.WaitForStreamer);
        const reconnectLimit = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.MaxReconnectAttempts);
        const reconnectDelay = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.StreamerAutoJoinInterval);
        // first we figure out a wanted streamer id through various means
        const useUrlParams = this.config.useUrlParams;
        const urlParams = new _Util_IURLSearchParams__WEBPACK_IMPORTED_MODULE_23__.IURLSearchParams(window.location.search);
        if (useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId)) {
            // if we've set the streamer id on the url we only want that streamer id
            wantedStreamerId = urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId);
        }
        else if (this.subscribedStream) {
            // we were previously subscribed to a streamer, we want that
            wantedStreamerId = this.subscribedStream;
        }
        // now lets see if we can pick it.
        if (wantedStreamerId && messageStreamerList.ids.includes(wantedStreamerId)) {
            // if the wanted stream is in the list. we pick that
            autoSelectedStreamerId = wantedStreamerId;
        }
        else if ((!wantedStreamerId || !waitForStreamer) && messageStreamerList.ids.length == 1) {
            // otherwise, if we're not waiting for the wanted streamer and there's only one streamer, connect to it
            autoSelectedStreamerId = messageStreamerList.ids[0];
        }
        // if we found a streamer id to auto select, select it
        if (autoSelectedStreamerId) {
            this.reconnectAttempt = 0;
            this.isReconnecting = false;
            this.config.setOptionSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId, autoSelectedStreamerId);
        }
        else {
            // no auto selected streamer.
            // if we're waiting for a streamer then try reconnecting
            if (waitForStreamer) {
                if (this.reconnectAttempt < reconnectLimit) {
                    // still reconnects available
                    this.reconnectAttempt++;
                    this.isReconnecting = true;
                    setTimeout(() => {
                        this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.listStreamers));
                    }, reconnectDelay);
                }
                else {
                    // We've exhausted our reconnect attempts, return to main screen
                    this.reconnectAttempt = 0;
                    this.isReconnecting = false;
                    this.enableAutoReconnect = false;
                }
            }
        }
        // dispatch this event finally
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.StreamerListMessageEvent({
            messageStreamerList,
            autoSelectedStreamerId,
            wantedStreamerId
        }));
    }
    handleSubscribeFailedMessage(subscribeFailedMessage) {
        this.reconnectAttempt = 0;
        this.isReconnecting = false;
        this.enableAutoReconnect = false;
        this.pixelStreaming._onSubscribeFailed(subscribeFailedMessage.message);
    }
    handleStreamerIDChangedMessage(streamerIDChangedMessage) {
        const newID = streamerIDChangedMessage.newID;
        // need to edit the selected streamer in the settings list
        const streamerListOptions = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId);
        // temporarily prevent onChange from firing (it would try to subscribe to the streamer again)
        const oldOnChange = streamerListOptions.onChange;
        streamerListOptions.onChange = () => { };
        // change the selected entry.
        const streamerList = streamerListOptions.options;
        for (let i = 0; i < streamerList.length; ++i) {
            if (streamerList[i] == this.subscribedStream) {
                streamerList[i] = newID;
                break;
            }
        }
        // update the list
        streamerListOptions.options = streamerList;
        // update the selected entry
        streamerListOptions.selected = newID;
        // restore the old change notifier.
        streamerListOptions.onChange = oldOnChange;
        // remember which stream we're subscribe to
        this.subscribedStream = streamerIDChangedMessage.newID;
        // notify any listeners
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.StreamerIDChangedMessageEvent({
            newID
        }));
    }
    /**
     * Handle the RTC Answer from the signaling server
     * @param Answer - Answer SDP from the peer.
     */
    handleWebRtcAnswer(Answer) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Got answer sdp ${Answer.sdp}`);
        const sdpAnswer = {
            sdp: Answer.sdp,
            type: 'answer'
        };
        this.peerConnectionController.receiveAnswer(sdpAnswer);
        this.handlePostWebrtcNegotiation();
    }
    /**
     * Handle the RTC offer from a WebRTC peer (received through the signalling server).
     * @param Offer - Offer SDP from the peer.
     */
    handleWebRtcOffer(Offer) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Got offer sdp ${Offer.sdp}`);
        this.isUsingSFU = Offer.sfu ? Offer.sfu : false;
        this.isUsingSVC = Offer.scalabilityMode ? Offer.scalabilityMode != 'L1T1' : false;
        if (this.isUsingSFU || this.isUsingSVC) {
            // Disable negotiating with the sfu as the sfu only supports one codec at a time
            this.peerConnectionController.preferredCodec = '';
        }
        // NOTE: These two settings configurations are done outside of an if(this.isUsingSFU) so that users
        // can switch between a default and SFU stream and have the settings reconfigure appropriately
        const scalabilityMode = Offer.scalabilityMode ? Offer.scalabilityMode : 'L1T1';
        let availableQualities = ['Default'];
        if (this.isUsingSFU) {
            if (!this.isUsingSVC) {
                // User is using an SFU without any temporal scalability. Just offer easily readable names
                availableQualities = ['Low', 'Medium', 'High'];
            }
            else {
                // User is using SVC. Generate all available options.
                availableQualities = [];
                const maxSpatialLayers = +scalabilityMode[1];
                const maxTemporalLayers = +scalabilityMode[3];
                for (let s = 1; s <= maxSpatialLayers; s++) {
                    for (let t = 1; t <= maxTemporalLayers; t++) {
                        availableQualities.push(`S${s}T${t}`);
                    }
                }
            }
        }
        // Update the possible video quality options
        this.config.setOptionSettingOptions(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.PreferredQuality, availableQualities);
        // Update the selected video quality with the highest possible resolution
        this.config.setOptionSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.PreferredQuality, availableQualities.slice(-1)[0]);
        const sdpOffer = {
            sdp: Offer.sdp,
            type: 'offer'
        };
        this.peerConnectionController.receiveOffer(sdpOffer, this.config);
        this.handlePostWebrtcNegotiation();
    }
    /**
     * Handle when the SFU provides the peer with its data channels
     * @param DataChannels - The message from the SFU containing the data channels ids
     */
    handleWebRtcSFUPeerDatachannels(DataChannels) {
        const SendOptions = {
            ordered: true,
            negotiated: true,
            id: DataChannels.sendStreamId
        };
        const unidirectional = DataChannels.sendStreamId != DataChannels.recvStreamId;
        this.sendrecvDataChannelController.createDataChannel(this.peerConnectionController.peerConnection, unidirectional ? 'send-datachannel' : 'datachannel', SendOptions);
        if (unidirectional) {
            const RecvOptions = {
                ordered: true,
                negotiated: true,
                id: DataChannels.recvStreamId
            };
            this.recvDataChannelController.createDataChannel(this.peerConnectionController.peerConnection, 'recv-datachannel', RecvOptions);
            this.recvDataChannelController.handleOnOpen = () => this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.peerDataChannelsReady));
            // If we're uni-directional, only the recv data channel should handle incoming messages
            this.recvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
        }
        else {
            // else our primary datachannel is send/recv so it can handle incoming messages
            this.sendrecvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
        }
    }
    handlePostWebrtcNegotiation() {
        // start the afk warning timer as PS is now running
        this.afkController.startAfkWarningTimer();
        // show the overlay that we have negotiated a connection
        this.pixelStreaming._onWebRtcSdp();
        if (this.statsTimerHandle && this.statsTimerHandle !== undefined) {
            window.clearInterval(this.statsTimerHandle);
        }
        this.statsTimerHandle = window.setInterval(() => this.getStats(), 1000);
        /*  */
        this.setMouseInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.MouseInput));
        this.setKeyboardInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.KeyboardInput));
        this.setGamePadInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.GamepadInput));
    }
    /**
     * Handler for when a remote ICE candidate is received.
     * @param iceCandidateInit - Initialization data used to make the actual ICE Candidate.
     */
    handleIceCandidate(iceCandidateInit) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Remote ICE candidate information received: ${JSON.stringify(iceCandidateInit)}`);
        // We are using "bundle" policy for media lines so we remove the sdpMid and sdpMLineIndex attributes
        // from ICE candidates as these are legacy attributes for when bundle is not used.
        // If we don't do this the browser may be unable to form a media connection
        // because some browsers are brittle if the bundle master (e.g. commonly mid=0) doesn't get a candidate first.
        const remoteIceCandidate = new RTCIceCandidate({
            candidate: iceCandidateInit.candidate,
            sdpMid: ''
        });
        this.peerConnectionController.handleOnIce(remoteIceCandidate);
    }
    /**
     * Send the ice Candidate to the signaling server via websocket
     * @param iceEvent - RTC Peer ConnectionIceEvent) {
     */
    handleSendIceCandidate(iceEvent) {
        if (iceEvent.candidate && iceEvent.candidate.candidate) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Local ICE candidate generated: ` + JSON.stringify(iceEvent.candidate));
            this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.iceCandidate, { candidate: iceEvent.candidate }));
        }
    }
    /**
     * Send the ice Candidate to the signaling server via websocket
     * @param iceEvent - RTC Peer ConnectionIceEvent) {
     */
    handleDataChannel(datachannelEvent) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Data channel created for us by browser as we are a receiving peer.');
        this.sendrecvDataChannelController.dataChannel = datachannelEvent.channel;
        // Data channel was created for us, so we just need to setup its callbacks and array type
        this.sendrecvDataChannelController.setupDataChannel();
        this.sendrecvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
    }
    /**
     * Send the RTC Offer Session to the Signaling server via websocket
     * @param offer - RTC Session Description
     */
    handleSendWebRTCOffer(offer) {
        if (offer.type !== 'offer') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`handleSendWebRTCOffer was called with type ${offer.type} - it only expects "offer"`);
            return;
        }
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Sending the offer to the Server');
        const extraParams = {
            sdp: offer.sdp,
            minBitrateBps: 1000 * this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.WebRTCMinBitrate),
            maxBitrateBps: 1000 * this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.WebRTCMaxBitrate)
        };
        this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.offer, extraParams));
        // Send offer back to Pixel Streaming main class for event dispatch
        this.pixelStreaming._onWebRtcSdpOffer(offer);
    }
    /**
     * Send the RTC Offer Session to the Signaling server via websocket
     * @param answer - RTC Session Description
     */
    handleSendWebRTCAnswer(answer) {
        if (answer.type !== 'answer') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`handleSendWebRTCAnswer was called with type ${answer.type} - it only expects "answer"`);
            return;
        }
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Sending the answer to the Server');
        const extraParams = {
            sdp: answer.sdp,
            minBitrateBps: 1000 * this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.WebRTCMinBitrate),
            maxBitrateBps: 1000 * this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.WebRTCMaxBitrate)
        };
        this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.answer, extraParams));
        if (this.isUsingSFU) {
            this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.dataChannelRequest));
        }
        // Send answer back to Pixel Streaming main class for event dispatch
        this.pixelStreaming._onWebRtcSdpAnswer(answer);
    }
    /**
     * Set the freeze frame overlay to the player div
     */
    setUpMouseAndFreezeFrame() {
        // Calculating and normalizing positions depends on the width and height of the player.
        const playerElement = this.videoPlayer.getVideoParentElement();
        const videoElement = this.videoPlayer.getVideoElement();
        this.coordinateConverter.reconfigure({ width: playerElement.clientWidth, height: playerElement.clientHeight }, { width: videoElement.videoWidth, height: videoElement.videoHeight });
        this.freezeFrameController.freezeFrame.resize();
    }
    /**
     * Close the Connection to the signaling server
     */
    closeSignalingServer(message, allowReconnect) {
        var _a;
        this.locallyClosed = true;
        this.enableAutoReconnect = allowReconnect;
        this.disconnectMessage = message;
        (_a = this.protocol) === null || _a === void 0 ? void 0 : _a.disconnect(1000, message);
    }
    /**
     * Close the peer connection
     */
    closePeerConnection() {
        var _a;
        (_a = this.peerConnectionController) === null || _a === void 0 ? void 0 : _a.close();
    }
    /**
     * Close all connections
     */
    close() {
        this.closeSignalingServer('', false);
        this.closePeerConnection();
    }
    /**
     * Fires a Video Stats Event in the RTC Peer Connection
     */
    getStats() {
        this.peerConnectionController.generateStats();
    }
    /**
     * Send a Latency Test Request to the UE Instance
     */
    sendLatencyTest() {
        this.latencyStartTime = Date.now();
        this.streamMessageController.toStreamerHandlers.get('LatencyTest')([
            JSON.stringify({
                StartTime: this.latencyStartTime
            })
        ]);
    }
    /**
     * Send a Data Channel Latency Test Request to the UE Instance
     */
    sendDataChannelLatencyTest(descriptor) {
        this.streamMessageController.toStreamerHandlers.get('DataChannelLatencyTest')([
            JSON.stringify(descriptor)
        ]);
    }
    /**
     * Send the MinQP encoder setting to the UE Instance.
     * @param minQP - The lower bound for QP when encoding
     * valid values are (1-51) where:
     * 1 = Best quality but highest bitrate.
     * 51 = Worst quality but lowest bitrate.
     * By default the minQP is 1 meaning the encoder is free
     * to aim for the best quality it can on the given network link.
     */
    sendEncoderMinQP(minQP) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`MinQP=${minQP}\n`);
        if (minQP != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MinQP': minQP
                })
            ]);
        }
    }
    /**
     * Send the MaxQP encoder setting to the UE Instance.
     * @param maxQP - The upper bound for QP when encoding
     * valid values are (1-51) where:
     * 1 = Best quality but highest bitrate.
     * 51 = Worst quality but lowest bitrate.
     * By default the maxQP is 51 meaning the encoder is free
     * to drop quality as low as needed on the given network link.
     */
    sendEncoderMaxQP(maxQP) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`MaxQP=${maxQP}\n`);
        if (maxQP != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MaxQP': maxQP
                })
            ]);
        }
    }
    /**
     * Send the MinQuality encoder setting to the UE Instance.
     * @param minQuality - The lower bound for quality when encoding
     * valid values are (0-100) where:
     * 0 = Worst quality.
     * 100 = Best quality.
     */
    sendEncoderMinQuality(minQuality) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`MinQuality=${minQuality}\n`);
        if (minQuality != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MinQuality': minQuality
                })
            ]);
        }
    }
    /**
     * Send the MaxQuality encoder setting to the UE Instance.
     * @param maxQuality - The upper bound for quality when encoding
     * valid values are (0-100) where:
     * 0 = Worst quality.
     * 100 = Best quality.
     */
    sendEncoderMaxQuality(maxQuality) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`MaxQuality=${maxQuality}\n`);
        if (maxQuality != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MaxQuality': maxQuality
                })
            ]);
        }
    }
    /**
     * Send the { WebRTC.MinBitrate: SomeNumber }} command to UE to set
     * the minimum bitrate that we allow WebRTC to use
     * (note setting this too high in poor networks can be problematic).
     * @param minBitrate - The minimum bitrate we would like WebRTC to not fall below.
     */
    sendWebRTCMinBitrate(minBitrate) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`WebRTC Min Bitrate=${minBitrate}`);
        if (minBitrate != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'WebRTC.MinBitrate': minBitrate
                })
            ]);
        }
    }
    /**
     * Send the { WebRTC.MaxBitrate: SomeNumber }} command to UE to set
     * the minimum bitrate that we allow WebRTC to use
     * (note setting this too low could result in blocky video).
     * @param minBitrate - The minimum bitrate we would like WebRTC to not fall below.
     */
    sendWebRTCMaxBitrate(maxBitrate) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`WebRTC Max Bitrate=${maxBitrate}`);
        if (maxBitrate != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'WebRTC.MaxBitrate': maxBitrate
                })
            ]);
        }
    }
    /**
     * Send the { WebRTC.Fps: SomeNumber }} UE 5.0+
     * and { WebRTC.MaxFps } UE 4.27 command to set
     * the maximum fps we would like WebRTC to stream at.
     * @param fps - The maximum stream fps.
     */
    sendWebRTCFps(fps) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`WebRTC FPS=${fps}`);
        if (fps != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({ 'WebRTC.Fps': fps })
            ]);
            /* TODO: Remove when UE 4.27 unsupported. */
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({ 'WebRTC.MaxFps': fps })
            ]);
        }
    }
    /**
     * Sends the UI Descriptor `stat fps` to the UE Instance
     */
    sendShowFps() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending show stat to UE   ----');
        this.streamMessageController.toStreamerHandlers.get('Command')([JSON.stringify({ 'stat.fps': '' })]);
    }
    /**
     * Send an Iframe request to the streamer
     */
    sendIframeRequest() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending Request for an IFrame  ----');
        this.streamMessageController.toStreamerHandlers.get('IFrameRequest')();
    }
    /**
     * Send a UIInteraction message
     */
    emitUIInteraction(descriptor) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending custom UIInteraction message   ----');
        this.streamMessageController.toStreamerHandlers.get('UIInteraction')([JSON.stringify(descriptor)]);
    }
    /**
     * Send a Command message
     */
    emitCommand(descriptor) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending custom Command message   ----');
        this.streamMessageController.toStreamerHandlers.get('Command')([JSON.stringify(descriptor)]);
    }
    /**
     * Send a console command message
     */
    emitConsoleCommand(command) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending custom Command:ConsoleCommand message   ----');
        this.streamMessageController.toStreamerHandlers.get('Command')([
            JSON.stringify({
                ConsoleCommand: command
            })
        ]);
    }
    /**
     * Sends a request to the UE Instance to have ownership of Quality
     */
    sendRequestQualityControlOwnership() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending Request to Control Quality  ----');
        this.toStreamerMessagesController.SendRequestQualityControl();
    }
    /**
     * Send a `TextBoxEntry` message back to UE.
     * @param contents The new contents of the UE side text box.
     */
    sendTextboxEntry(contents) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending TextboxEntry message  ----');
        (_a = this.streamMessageController.toStreamerHandlers.get('TextboxEntry')) === null || _a === void 0 ? void 0 : _a([contents]);
    }
    /**
     * Handles when a Latency Test Result are received from the UE Instance
     * @param message - Latency Test Timings
     */
    handleLatencyTestResult(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.latencyTest');
        const latencyAsString = new TextDecoder('utf-16').decode(message.slice(1));
        const latencyTestResults = new _DataChannel_LatencyTestResults__WEBPACK_IMPORTED_MODULE_24__.LatencyTestResults();
        Object.assign(latencyTestResults, JSON.parse(latencyAsString));
        latencyTestResults.processFields();
        latencyTestResults.testStartTimeMs = this.latencyStartTime;
        latencyTestResults.browserReceiptTimeMs = Date.now();
        latencyTestResults.latencyExcludingDecode = ~~(latencyTestResults.browserReceiptTimeMs - latencyTestResults.testStartTimeMs);
        latencyTestResults.testDuration = ~~(latencyTestResults.TransmissionTimeMs - latencyTestResults.ReceiptTimeMs);
        latencyTestResults.networkLatency = ~~(latencyTestResults.latencyExcludingDecode - latencyTestResults.testDuration);
        if (latencyTestResults.frameDisplayDeltaTimeMs && latencyTestResults.browserReceiptTimeMs) {
            latencyTestResults.endToEndLatency = ~~(latencyTestResults.frameDisplayDeltaTimeMs +
                latencyTestResults.networkLatency,
                +latencyTestResults.CaptureToSendMs);
        }
        this.pixelStreaming._onLatencyTestResult(latencyTestResults);
    }
    /**
     * Handles when a Data Channel Latency Test Response is received from the UE Instance
     * @param message - Data Channel Latency Test Response
     */
    handleDataChannelLatencyTestResponse(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.dataChannelLatencyResponse');
        const responseAsString = new TextDecoder('utf-16').decode(message.slice(1));
        const latencyTestResponse = JSON.parse(responseAsString);
        this.pixelStreaming._onDataChannelLatencyTestResponse(latencyTestResponse);
    }
    /**
     * Handles when the Encoder and Web RTC Settings are received from the UE Instance
     * @param message - Initial Encoder and Web RTC Settings
     */
    handleInitialSettings(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.InitialSettings');
        const payloadAsString = new TextDecoder('utf-16').decode(message.slice(1));
        const parsedInitialSettings = JSON.parse(payloadAsString);
        const initialSettings = new _DataChannel_InitialSettings__WEBPACK_IMPORTED_MODULE_25__.InitialSettings();
        if (parsedInitialSettings.Encoder) {
            initialSettings.EncoderSettings = parsedInitialSettings.Encoder;
        }
        if (parsedInitialSettings.WebRTC) {
            initialSettings.WebRTCSettings = parsedInitialSettings.WebRTC;
        }
        if (parsedInitialSettings.PixelStreaming) {
            initialSettings.PixelStreamingSettings = parsedInitialSettings.PixelStreaming;
        }
        if (parsedInitialSettings.ConfigOptions &&
            parsedInitialSettings.ConfigOptions.DefaultToHover !== undefined) {
            this.config.setFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.HoveringMouseMode, !!parsedInitialSettings.ConfigOptions.DefaultToHover);
        }
        initialSettings.ueCompatible();
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(payloadAsString);
        this.pixelStreaming._onInitialSettings(initialSettings);
    }
    /**
     * Handles when the Quantization Parameter are received from the UE Instance
     * @param message - Encoders Quantization Parameter
     */
    handleVideoEncoderAvgQP(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.VideoEncoderAvgQP');
        const AvgQP = Number(new TextDecoder('utf-16').decode(message.slice(1)));
        this.setVideoEncoderAvgQP(AvgQP);
    }
    /**
     * Handles when the video element has been loaded with a srcObject
     */
    handleVideoInitialized() {
        this.pixelStreaming._onVideoInitialized();
        // either autoplay the video or set up the play overlay
        this.autoPlayVideoOrSetUpPlayOverlay();
        this.resizePlayerStyle();
        this.videoPlayer.updateVideoStreamSize();
    }
    /**
     * Flag set if the user has Quality Ownership
     * @param message - Does the current client have Quality Ownership
     */
    onQualityControlOwnership(message) {
        const view = new Uint8Array(message);
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.QualityControlOwnership');
        this.isQualityController = new Boolean(view[1]).valueOf();
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Received quality controller message, will control quality: ${this.isQualityController}`);
        this.pixelStreaming._onQualityControlOwnership(this.isQualityController);
    }
    /**
     * Handles when the Aggregated stats are Collected
     * @param stats - Aggregated Stats
     */
    handleVideoStats(stats) {
        this.pixelStreaming._onVideoStats(stats);
    }
    /**
     * To Resize the Video Player element
     */
    resizePlayerStyle() {
        this.videoPlayer.resizePlayerStyle();
    }
    setPreferredCodec(codec) {
        this.preferredCodec = codec;
        if (this.peerConnectionController) {
            this.peerConnectionController.preferredCodec = codec;
            this.peerConnectionController.updateCodecSelection = false;
        }
    }
    setVideoEncoderAvgQP(avgQP) {
        this.videoAvgQp = avgQP;
        this.pixelStreaming._onVideoEncoderAvgQP(this.videoAvgQp);
    }
    /**
     * enables/disables keyboard event listeners
     */
    setKeyboardInputEnabled(isEnabled) {
        var _a;
        (_a = this.keyboardController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            this.keyboardController = this.inputClassesFactory.registerKeyBoard(this.config);
        }
    }
    /**
     * enables/disables mouse event listeners
     */
    setMouseInputEnabled(isEnabled) {
        var _a;
        (_a = this.mouseController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            const mouseMode = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.HoveringMouseMode)
                ? _Config_Config__WEBPACK_IMPORTED_MODULE_13__.ControlSchemeType.HoveringMouse
                : _Config_Config__WEBPACK_IMPORTED_MODULE_13__.ControlSchemeType.LockedMouse;
            this.mouseController = this.inputClassesFactory.registerMouse(mouseMode);
        }
    }
    /**
     * enables/disables touch event listeners
     */
    setTouchInputEnabled(isEnabled) {
        var _a;
        (_a = this.touchController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            this.touchController = this.inputClassesFactory.registerTouch(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.FakeMouseWithTouches));
        }
    }
    /**
     * enables/disables game pad event listeners
     */
    setGamePadInputEnabled(isEnabled) {
        var _a;
        (_a = this.gamePadController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            this.gamePadController = this.inputClassesFactory.registerGamePad();
        }
    }
    registerDataChannelEventEmitters(dataChannel) {
        dataChannel.onOpen = (label, event) => this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.DataChannelOpenEvent({ label, event }));
        dataChannel.onClose = (label, event) => this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.DataChannelCloseEvent({ label, event }));
        dataChannel.onError = (label, event) => this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.DataChannelErrorEvent({ label, event }));
    }
    registerMessageHandler(name, direction, handler) {
        if (direction === _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer && typeof handler === 'undefined') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Warning(`Unable to register handler for ${name} as no handler was passed`);
        }
        this.streamMessageController.registerMessageHandler(direction, name, (data) => typeof handler === 'undefined' && direction === _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer
            ? this.sendMessageController.sendMessageToStreamer(name, data)
            : handler(data));
    }
}
//# sourceMappingURL=WebRtcPlayerController.js.map

/***/ }),

/***/ "../../library/dist/esm/WebXR/WebXRController.js":
/*!*******************************************************!*\
  !*** ../../library/dist/esm/WebXR/WebXRController.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebXRController: () => (/* binding */ WebXRController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Inputs_XRGamepadController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Inputs/XRGamepadController */ "../../library/dist/esm/Inputs/XRGamepadController.js");
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Util/EventEmitter */ "../../library/dist/esm/Util/EventEmitter.js");
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
// Copyright Epic Games, Inc. All Rights Reserved.




class WebXRController {
    constructor(webRtcPlayerController) {
        this.xrViewerPose = null;
        // Used for comparisons to ensure two numbers are close enough.
        this.EPSILON = 0.0000001;
        this.videoTexture = null;
        this.prevVideoWidth = 0;
        this.prevVideoHeight = 0;
        this.leftView = null;
        this.rightView = null;
        // Store the HMD data we have last sent (not all of it is needed every frame unless it changes)
        this.lastSentLeftEyeProj = null;
        this.lastSentRightEyeProj = null;
        this.lastSentRelativeLeftEyePos = null;
        this.lastSentRelativeRightEyePos = null;
        this.xrSession = null;
        this.webRtcController = webRtcPlayerController;
        this.xrGamepadController = new _Inputs_XRGamepadController__WEBPACK_IMPORTED_MODULE_0__.XRGamepadController(this.webRtcController.streamMessageController);
        this.onSessionEnded = new EventTarget();
        this.onSessionStarted = new EventTarget();
        this.onFrame = new EventTarget();
    }
    xrClicked() {
        if (!this.xrSession) {
            if (!navigator.xr) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Error('This browser does not support XR.');
                return;
            }
            navigator.xr
                /* Request immersive-vr session without any optional features. */
                .requestSession('immersive-vr', { optionalFeatures: [] })
                .then((session) => {
                this.onXrSessionStarted(session);
            });
        }
        else {
            this.xrSession.end();
        }
    }
    onXrSessionEnded() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('XR Session ended');
        this.xrSession = null;
        this.onSessionEnded.dispatchEvent(new Event('xrSessionEnded'));
    }
    initGL() {
        if (this.gl) {
            return;
        }
        const canvas = document.createElement('canvas');
        this.gl = canvas.getContext('webgl2', {
            xrCompatible: true
        });
        // Set our clear color
        this.gl.clearColor(0.0, 0.0, 0.0, 1);
    }
    initShaders() {
        // shader source code
        const vertexShaderSource = `
        attribute vec2 a_position;
        attribute vec2 a_texCoord;

        // varyings
        varying vec2 v_texCoord;

        void main() {
           gl_Position = vec4(a_position.x, a_position.y, 0, 1);
           // pass the texCoord to the fragment shader
           // The GPU will interpolate this value between points.
           v_texCoord = a_texCoord;
        }
        `;
        const fragmentShaderSource = `
        precision mediump float;

        // our texture
        uniform sampler2D u_image;

        // the texCoords passed in from the vertex shader.
        varying vec2 v_texCoord;

        void main() {
           gl_FragColor = texture2D(u_image, v_texCoord);
        }
        `;
        // setup vertex shader
        const vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
        this.gl.shaderSource(vertexShader, vertexShaderSource);
        this.gl.compileShader(vertexShader);
        // setup fragment shader
        const fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        this.gl.shaderSource(fragmentShader, fragmentShaderSource);
        this.gl.compileShader(fragmentShader);
        // setup GLSL program
        const shaderProgram = this.gl.createProgram();
        this.gl.attachShader(shaderProgram, vertexShader);
        this.gl.attachShader(shaderProgram, fragmentShader);
        this.gl.linkProgram(shaderProgram);
        this.gl.useProgram(shaderProgram);
        // look up where vertex data needs to go
        this.positionLocation = this.gl.getAttribLocation(shaderProgram, 'a_position');
        this.texcoordLocation = this.gl.getAttribLocation(shaderProgram, 'a_texCoord');
    }
    updateVideoTexture() {
        if (!this.videoTexture) {
            // Create our texture that we use in our shader
            // and bind it once because we never use any other texture.
            this.videoTexture = this.gl.createTexture();
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.videoTexture);
            // Set the parameters so we can render any size image.
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        }
        const videoHeight = this.webRtcController.videoPlayer.getVideoElement().videoHeight;
        const videoWidth = this.webRtcController.videoPlayer.getVideoElement().videoWidth;
        if (this.prevVideoHeight != videoHeight || this.prevVideoWidth != videoWidth) {
            // Do full update of texture if dimensions do not match
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, videoWidth, videoHeight, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.webRtcController.videoPlayer.getVideoElement());
        }
        else {
            // If dimensions match just update the sub region
            this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, 0, 0, videoWidth, videoHeight, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.webRtcController.videoPlayer.getVideoElement());
        }
        // Update prev video width/height
        this.prevVideoHeight = videoHeight;
        this.prevVideoWidth = videoWidth;
    }
    initBuffers() {
        // Create out position buffer and its vertex shader attribute
        {
            // Create a buffer to put the the vertices of the plane we will draw the video stream onto
            this.positionBuffer = this.gl.createBuffer();
            // Bind the position buffer
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
            // Enable `positionLocation` to be used as vertex shader attribute
            this.gl.enableVertexAttribArray(this.positionLocation);
            // Note: positions are passed in clip-space coordinates [-1..1] so no need to convert in-shader
            // prettier-ignore
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([
                -1.0, 1.0,
                1.0, 1.0,
                -1.0, -1.0,
                -1.0, -1.0,
                1.0, 1.0,
                1.0, -1.0
            ]), this.gl.STATIC_DRAW);
            // Tell position attribute of the vertex shader how to get data out of the bound buffer (the positionBuffer)
            this.gl.vertexAttribPointer(this.positionLocation, 2 /*size*/, this.gl.FLOAT /*type*/, false /*normalize*/, 0 /*stride*/, 0 /*offset*/);
        }
        // Create our texture coordinate buffers for accessing our texture
        {
            this.texcoordBuffer = this.gl.createBuffer();
            // Bind the texture coordinate buffer
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texcoordBuffer);
            // Enable `texcoordLocation` to be used as a vertex shader attribute
            this.gl.enableVertexAttribArray(this.texcoordLocation);
            // The texture coordinates to apply for rectangle we are drawing
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), this.gl.STATIC_DRAW);
            // Tell texture coordinate attribute of the vertex shader how to get data out of the bound buffer (the texcoordBuffer)
            this.gl.vertexAttribPointer(this.texcoordLocation, 2 /*size*/, this.gl.FLOAT /*type*/, false /*normalize*/, 0 /*stride*/, 0 /*offset*/);
        }
    }
    onXrSessionStarted(session) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('XR Session started');
        this.xrSession = session;
        this.xrSession.addEventListener('end', () => {
            this.onXrSessionEnded();
        });
        // Initialization
        this.initGL();
        this.initShaders();
        this.initBuffers();
        session.requestReferenceSpace('local').then((refSpace) => {
            this.xrRefSpace = refSpace;
            // Set up our base layer (i.e. a projection layer that fills the entire XR viewport).
            this.xrSession.updateRenderState({
                baseLayer: new XRWebGLLayer(this.xrSession, this.gl)
            });
            // Update target framerate to 90 fps if 90 fps is supported in this XR device
            if (this.xrSession.supportedFrameRates) {
                for (const frameRate of this.xrSession.supportedFrameRates) {
                    if (frameRate == 90) {
                        session.updateTargetFrameRate(90);
                    }
                }
            }
            // Binding to each new frame to get latest XR updates
            this.xrSession.requestAnimationFrame(this.onXrFrame.bind(this));
        });
        this.onSessionStarted.dispatchEvent(new Event('xrSessionStarted'));
    }
    areArraysEqual(a, b) {
        return (a.length === b.length && a.every((element, index) => Math.abs(element - b[index]) <= this.EPSILON));
    }
    arePointsEqual(a, b) {
        return (Math.abs(a.x - b.x) >= this.EPSILON &&
            Math.abs(a.y - b.y) >= this.EPSILON &&
            Math.abs(a.z - b.z) >= this.EPSILON);
    }
    sendXRDataToUE() {
        if (this.leftView == null || this.rightView == null) {
            return;
        }
        // We selectively send either the `XREyeViews` or `XRHMDTransform`
        // messages over the datachannel. The reason for this selective sending is that
        // the `XREyeViews` is a much larger message and changes infrequently (e.g. only when user changes headset IPD).
        // Therefore, we only need to send it once on startup and then any time it changes.
        // The rest of the time we can send the `XRHMDTransform` message.
        let shouldSendEyeViews = this.lastSentLeftEyeProj == null ||
            this.lastSentRightEyeProj == null ||
            this.lastSentRelativeLeftEyePos == null ||
            this.lastSentRelativeRightEyePos == null;
        const leftEyeTrans = this.leftView.transform.matrix;
        const leftEyeProj = this.leftView.projectionMatrix;
        const rightEyeTrans = this.rightView.transform.matrix;
        const rightEyeProj = this.rightView.projectionMatrix;
        const hmdTrans = this.xrViewerPose.transform.matrix;
        // Check if projection matrices have changed
        if (!shouldSendEyeViews && this.lastSentLeftEyeProj != null && this.lastSentRightEyeProj != null) {
            const leftEyeProjUnchanged = this.areArraysEqual(leftEyeProj, this.lastSentLeftEyeProj);
            const rightEyeProjUnchanged = this.areArraysEqual(rightEyeProj, this.lastSentRightEyeProj);
            shouldSendEyeViews = leftEyeProjUnchanged == false || rightEyeProjUnchanged == false;
        }
        const leftEyeRelativePos = new DOMPointReadOnly(this.leftView.transform.position.x - this.xrViewerPose.transform.position.x, this.leftView.transform.position.y - this.xrViewerPose.transform.position.y, this.leftView.transform.position.z - this.xrViewerPose.transform.position.z, 1.0);
        const rightEyeRelativePos = new DOMPointReadOnly(this.leftView.transform.position.x - this.xrViewerPose.transform.position.x, this.leftView.transform.position.y - this.xrViewerPose.transform.position.y, this.leftView.transform.position.z - this.xrViewerPose.transform.position.z, 1.0);
        // Check if relative eye pos has changed (e.g IPD changed)
        if (!shouldSendEyeViews &&
            this.lastSentRelativeLeftEyePos != null &&
            this.lastSentRelativeRightEyePos != null) {
            const leftEyePosUnchanged = this.arePointsEqual(leftEyeRelativePos, this.lastSentRelativeLeftEyePos);
            const rightEyePosUnchanged = this.arePointsEqual(rightEyeRelativePos, this.lastSentRelativeRightEyePos);
            shouldSendEyeViews = leftEyePosUnchanged == false || rightEyePosUnchanged == false;
            // Note: We are not checking if EyeView rotation changes (as far as I know no HMD supports changing this value at runtime).
        }
        if (shouldSendEyeViews) {
            // send transform (4x4) and projection matrix (4x4) data for each eye (left first, then right)
            // prettier-ignore
            this.webRtcController.streamMessageController.toStreamerHandlers.get('XREyeViews')([
                // Left eye 4x4 transform matrix
                leftEyeTrans[0], leftEyeTrans[4], leftEyeTrans[8], leftEyeTrans[12],
                leftEyeTrans[1], leftEyeTrans[5], leftEyeTrans[9], leftEyeTrans[13],
                leftEyeTrans[2], leftEyeTrans[6], leftEyeTrans[10], leftEyeTrans[14],
                leftEyeTrans[3], leftEyeTrans[7], leftEyeTrans[11], leftEyeTrans[15],
                // Left eye 4x4 projection matrix
                leftEyeProj[0], leftEyeProj[4], leftEyeProj[8], leftEyeProj[12],
                leftEyeProj[1], leftEyeProj[5], leftEyeProj[9], leftEyeProj[13],
                leftEyeProj[2], leftEyeProj[6], leftEyeProj[10], leftEyeProj[14],
                leftEyeProj[3], leftEyeProj[7], leftEyeProj[11], leftEyeProj[15],
                // Right eye 4x4 transform matrix
                rightEyeTrans[0], rightEyeTrans[4], rightEyeTrans[8], rightEyeTrans[12],
                rightEyeTrans[1], rightEyeTrans[5], rightEyeTrans[9], rightEyeTrans[13],
                rightEyeTrans[2], rightEyeTrans[6], rightEyeTrans[10], rightEyeTrans[14],
                rightEyeTrans[3], rightEyeTrans[7], rightEyeTrans[11], rightEyeTrans[15],
                // right eye 4x4 projection matrix
                rightEyeProj[0], rightEyeProj[4], rightEyeProj[8], rightEyeProj[12],
                rightEyeProj[1], rightEyeProj[5], rightEyeProj[9], rightEyeProj[13],
                rightEyeProj[2], rightEyeProj[6], rightEyeProj[10], rightEyeProj[14],
                rightEyeProj[3], rightEyeProj[7], rightEyeProj[11], rightEyeProj[15],
                // HMD 4x4 transform
                hmdTrans[0], hmdTrans[4], hmdTrans[8], hmdTrans[12],
                hmdTrans[1], hmdTrans[5], hmdTrans[9], hmdTrans[13],
                hmdTrans[2], hmdTrans[6], hmdTrans[10], hmdTrans[14],
                hmdTrans[3], hmdTrans[7], hmdTrans[11], hmdTrans[15],
            ]);
            this.lastSentLeftEyeProj = leftEyeProj;
            this.lastSentRightEyeProj = rightEyeProj;
            this.lastSentRelativeLeftEyePos = leftEyeRelativePos;
            this.lastSentRelativeRightEyePos = rightEyeRelativePos;
        }
        else {
            // If we don't need to the entire eye views being sent just send the HMD transform
            this.webRtcController.streamMessageController.toStreamerHandlers.get('XRHMDTransform')([
                // HMD 4x4 transform
                hmdTrans[0],
                hmdTrans[4],
                hmdTrans[8],
                hmdTrans[12],
                hmdTrans[1],
                hmdTrans[5],
                hmdTrans[9],
                hmdTrans[13],
                hmdTrans[2],
                hmdTrans[6],
                hmdTrans[10],
                hmdTrans[14],
                hmdTrans[3],
                hmdTrans[7],
                hmdTrans[11],
                hmdTrans[15]
            ]);
        }
    }
    onXrFrame(time, frame) {
        this.xrViewerPose = frame.getViewerPose(this.xrRefSpace);
        if (this.xrViewerPose) {
            this.updateViews();
            if (this.leftView == null || this.rightView == null) {
                return;
            }
            this.sendXRDataToUE();
            this.updateVideoTexture();
            this.render();
        }
        if (this.webRtcController.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.XRControllerInput)) {
            this.xrSession.inputSources.forEach((source, _index, _array) => {
                this.xrGamepadController.updateStatus(source, frame, this.xrRefSpace);
            }, this);
        }
        this.xrSession.requestAnimationFrame((time, frame) => this.onXrFrame(time, frame));
        this.onFrame.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_3__.XrFrameEvent({ time, frame }));
    }
    updateViews() {
        if (!this.xrViewerPose) {
            return;
        }
        for (const view of this.xrViewerPose.views) {
            if (view.eye === 'left') {
                this.leftView = view;
            }
            else if (view.eye === 'right') {
                this.rightView = view;
            }
        }
    }
    render() {
        if (!this.gl) {
            return;
        }
        // Bind the framebuffer to the base layer's framebuffer
        const glLayer = this.xrSession.renderState.baseLayer;
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, glLayer.framebuffer);
        // Set the relevant portion of clip space
        this.gl.viewport(0, 0, glLayer.framebufferWidth, glLayer.framebufferHeight);
        // Draw the rectangle we will show the video stream texture on
        this.gl.drawArrays(this.gl.TRIANGLES /*primitiveType*/, 0 /*offset*/, 6 /*count*/);
    }
    static isSessionSupported(mode) {
        if (location.protocol !== 'https:') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('WebXR requires https, if you want WebXR use https.');
        }
        if (navigator.xr) {
            return navigator.xr.isSessionSupported(mode);
        }
        else {
            return new Promise(() => {
                return false;
            });
        }
    }
}
//# sourceMappingURL=WebXRController.js.map

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!***********************!*\
  !*** ./src/uiless.ts ***!
  \***********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/PixelStreaming/PixelStreaming.js");
// Copyright Epic Games, Inc. All Rights Reserved.

document.body.onload = function () {
    // Create a config object
    const config = new _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Config({
        initialSettings: {
            AutoPlayVideo: true,
            AutoConnect: true,
            StartVideoMuted: true,
            WaitForStreamer: true,
        }
    });
    // Create a PixelStreaming instance and attach the video element to an existing parent div
    const pixelStreaming = new _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__.PixelStreaming(config, { videoElementParent: document.getElementById("videoParentElement") });
    // If browser denies autoplay, show "Click to play" and register a click-to-play handler
    pixelStreaming.addEventListener("playStreamRejected", () => {
        const clickToPlay = document.getElementById("clickToPlayElement");
        clickToPlay.className = "visible";
        clickToPlay.onclick = () => {
            pixelStreaming.play();
            clickToPlay.className = "";
            clickToPlay.onclick = undefined;
        };
    });
};

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidWlsZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPOzs7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGdFQUFnRTtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGdFQUFnRTtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSyxJQUFJLE1BQU07QUFDN0QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaFBBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQ0FBc0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOZ0Q7QUFDQTtBQUNPO0FBQ0U7QUFDQTtBQUNJO0FBQ0E7QUFDYjtBQUNhO0FBQ25CO0FBQzJCO0FBQ3JCO0FBQ0Y7QUFDRDtBQUNwRCxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnRUFBa0I7QUFDbkQ7QUFDQSxrRkFBa0Ysc0JBQXNCLENBQUMsZ0VBQVksS0FBSyxlQUFlO0FBQ3pJLGdDQUFnQyx1RUFBbUI7QUFDbkQsaUNBQWlDLHlFQUFvQjtBQUNyRCxpQ0FBaUMseUVBQW9CO0FBQ3JELGdDQUFnQyw2RUFBc0I7QUFDdEQsZ0NBQWdDLDZFQUFzQjtBQUN0RDtBQUNBO0FBQ0Esc0JBQXNCLG9FQUFnQjtBQUN0QztBQUNBLFlBQVksaUZBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRkFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvRUFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlGQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtFQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUVBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0VBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUVBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGVBQWUsWUFBWSwrREFBZSxPQUFPO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hHK0Q7QUFDL0Q7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0IsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxHQUFHO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsR0FBRztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsR0FBRztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdGQUFNLHNDQUFzQyxJQUFJO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU0sMkNBQTJDLElBQUk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTSwyQ0FBMkMsSUFBSTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdGQUFNLDJDQUEyQyxJQUFJO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU0sNkNBQTZDLElBQUk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsb0VBQW9CO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsb0VBQW9CO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsb0VBQW9CO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsb0VBQW9CO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQzs7Ozs7Ozs7Ozs7Ozs7QUNwa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVDQUF1QyxrQkFBa0IsR0FBRyxVQUFVLE9BQU8sa0JBQWtCO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzVGQTtBQUM0QztBQUM1QztBQUNBO0FBQ0E7QUFDTywwQkFBMEIscURBQVc7QUFDNUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ08sNEJBQTRCLHFEQUFXO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDN0VBO0FBQ3NFO0FBQzFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNPLDRCQUE0QixxREFBVztBQUM5QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTSx5QkFBeUIsTUFBTSwrQkFBK0IsU0FBUztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzVFQTtBQUM0QztBQUM1QztBQUNBO0FBQ0E7QUFDTywwQkFBMEIscURBQVc7QUFDNUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDcENBO0FBQ3NFO0FBQ3RFO0FB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UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU0sOEJBQThCLHVCQUF1QixLQUFLLHFCQUFxQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU0sdUNBQXVDLHdCQUF3QixLQUFLLHNCQUFzQjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3pGQTtBQUNzRTtBQUMxQjtBQUM1QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQ0FBc0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQ0FBc0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU0sVUFBVSxxQ0FBcUMsSUFBSSxFQUFFLElBQUksRUFBRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDdkhBO0FBQzZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxzREFBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0NBQXNDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsc0RBQVc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0JBQStCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN2RkE7QUFDaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCw4REFBZTtBQUN4RTtBQUNBLHdEQUF3RCw4REFBZTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4SEE7QUFDeUU7QUFDbkI7QUFDTjtBQUM4QjtBQUNoQztBQUNGO0FBQzBCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxxQ0FBcUMsK0RBQWlCO0FBQ3RELHFDQUFxQywrREFBaUI7QUFDdEQ7QUFDQSxvQ0FBb0MsK0RBQWdCO0FBQ3BEO0FBQ0E7QUFDQSxzQ0FBc0MsK0RBQWdCO0FBQ3RELHNDQUFzQywrREFBZ0I7QUFDdEQsNENBQTRDLHFFQUFzQjtBQUNsRSw0Q0FBNEMscUVBQXNCO0FBQ2xFLGdDQUFnQyx1REFBWTtBQUM1QywrQkFBK0IscURBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdGQUFNO0FBQzFCLG9CQUFvQixnRkFBTTtBQUMxQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseURBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlEQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0ZBQU0sZ0RBQWdELFdBQVc7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3JUQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SUFBNEksS0FBSztBQUNqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlIQUFpSCxLQUFLO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUMzUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQSxpQkFBaUIsU0FBSSxJQUFJ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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdGQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCw0REFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUhBQWlILHVCQUF1QjtBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9EQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUhBQWlILHVCQUF1QjtBQUN4STtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9EQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0ZBQWdCO0FBQzFDLFlBQVksZ0ZBQU0sd0RBQXdELEtBQUs7QUFDL0U7QUFDQTtBQUNBLDBCQUEwQix3RkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDdnFCQTtBQUNzRTtBQUMvRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdGQUFNO0FBQ2Q7QUFDQSxRQUFRLGdGQUFNO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2xDQTtBQUNzRTtBQUMvRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU0seUVBQXlFLFlBQVk7QUFDdkc7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTSwwRUFBMEU7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDZCQUE2QixtQkFBbUIseURBQXlEO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsWUFBWSxnRkFBTSxpRUFBaUUsYUFBYSxJQUFJLDRCQUE0QjtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckhBO0FBQ3NFO0FBQy9EO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0ZBQU0sbUNBQW1DLGlCQUFpQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDOzs7Ozs7Ozs7Ozs7OztBQ2pOQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDN0NBO0FBQ3NFO0FBQy9EO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdGQUFNO0FBQ2xCLHdFQUF3RSxxQkFBcUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxxQkFBcUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuWUE7QUFDc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTTtBQUNsQjtBQUNBO0FBQ0EsUUFBUSxnRkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTTtBQUNsQjtBQUNBO0FBQ0EsUUFBUSxnRkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUU7QUFDQSxTQUFTO0FBQ1QsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUU7QUFDQSxTQUFTO0FBQ1QsNERBQTRELHdGQUFnQjtBQUM1RTtBQUNBLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFO0FBQ0EsU0FBUztBQUNULDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0ZBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxpREFBSztBQUM1RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx1Q0FBdUMsNERBQVksR0FBRyxhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7Ozs7O1VDcFdBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsV0FBVztXQUM1QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7Ozs7Ozs7Ozs7O0FDTkEsa0RBQWtEO0FBRXNDO0FBRXhGLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHO0lBRXRCLHlCQUF5QjtJQUN6QixNQUFNLE1BQU0sR0FBRyxJQUFJLGtGQUFNLENBQUM7UUFDekIsZUFBZSxFQUFFO1lBQ2hCLGFBQWEsRUFBRSxJQUFJO1lBQ25CLFdBQVcsRUFBRSxJQUFJO1lBQ2pCLGVBQWUsRUFBRSxJQUFJO1lBQ3JCLGVBQWUsRUFBRSxJQUFJO1NBQ3JCO0tBQ0QsQ0FBQyxDQUFDO0lBRUgsMEZBQTBGO0lBQzFGLE1BQU0sY0FBYyxHQUFHLElBQUksMEZBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxrQkFBa0IsRUFBRSxRQUFRLENBQUMsY0FBYyxDQUFDLG9CQUFvQixDQUFDLEVBQUMsQ0FBQyxDQUFDO0lBRXhILHdGQUF3RjtJQUN4RixjQUFjLENBQUMsZ0JBQWdCLENBQUMsb0JBQW9CLEVBQUUsR0FBRyxFQUFFO1FBQzFELE1BQU0sV0FBVyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUNsRSxXQUFXLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztRQUNsQyxXQUFXLENBQUMsT0FBTyxHQUFHLEdBQUcsRUFBRTtZQUMxQixjQUFjLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDdEIsV0FBVyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7WUFDM0IsV0FBVyxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUM7UUFDakMsQ0FBQztJQUNGLENBQUMsQ0FBQztBQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9Db21tb24vZGlzdC9lc20vRXZlbnQvRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9Db21tb24vZGlzdC9lc20vTG9nZ2VyL0xvZ2dlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vQ29tbW9uL2Rpc3QvZXNtL01lc3NhZ2VzL21lc3NhZ2VfaGVscGVycy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vQ29tbW9uL2Rpc3QvZXNtL01lc3NhZ2VzL21lc3NhZ2VfcmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL0NvbW1vbi9kaXN0L2VzbS9NZXNzYWdlcy9zaWduYWxsaW5nX21lc3NhZ2VzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9Db21tb24vZGlzdC9lc20vUHJvdG9jb2wvS2VlcGFsaXZlTW9uaXRvci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vQ29tbW9uL2Rpc3QvZXNtL1Byb3RvY29sL1NpZ25hbGxpbmdQcm90b2NvbC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vQ29tbW9uL2Rpc3QvZXNtL1RyYW5zcG9ydC9XZWJTb2NrZXRUcmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL0NvbW1vbi9kaXN0L2VzbS9VdGlsL1NkcFV0aWxzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L2Fzc2VydC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvYmluYXJ5LWZvcm1hdC1jb250cmFjdC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9iaW5hcnktcmVhZGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L2JpbmFyeS13cml0ZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvZ29vZy12YXJpbnQuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvanNvbi1mb3JtYXQtY29udHJhY3QuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvanNvbi10eXBpbmdzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L2xvd2VyLWNhbWVsLWNhc2UuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvbWVzc2FnZS10eXBlLWNvbnRyYWN0LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L21lc3NhZ2UtdHlwZS5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9vbmVvZi5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9wYi1sb25nLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L3JlZmxlY3Rpb24tYmluYXJ5LXJlYWRlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9yZWZsZWN0aW9uLWJpbmFyeS13cml0ZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvcmVmbGVjdGlvbi1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvcmVmbGVjdGlvbi1lcXVhbHMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvcmVmbGVjdGlvbi1pbmZvLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L3JlZmxlY3Rpb24tanNvbi1yZWFkZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvcmVmbGVjdGlvbi1qc29uLXdyaXRlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9yZWZsZWN0aW9uLWxvbmctY29udmVydC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9yZWZsZWN0aW9uLW1lcmdlLXBhcnRpYWwuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvcmVmbGVjdGlvbi1zY2FsYXItZGVmYXVsdC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9yZWZsZWN0aW9uLXR5cGUtY2hlY2suanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZHAvc2RwLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0FGSy9BRktDb250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0NvbmZpZy9Db25maWcuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vQ29uZmlnL1NldHRpbmdCYXNlLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0NvbmZpZy9TZXR0aW5nRmxhZy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9Db25maWcvU2V0dGluZ051bWJlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9Db25maWcvU2V0dGluZ09wdGlvbi5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9Db25maWcvU2V0dGluZ1RleHQuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vRGF0YUNoYW5uZWwvRGF0YUNoYW5uZWxDb250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0RhdGFDaGFubmVsL0RhdGFDaGFubmVsTGF0ZW5jeVRlc3RDb250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0RhdGFDaGFubmVsL0RhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXN1bHRzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0RhdGFDaGFubmVsL0RhdGFDaGFubmVsU2VuZGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0RhdGFDaGFubmVsL0luaXRpYWxTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9EYXRhQ2hhbm5lbC9MYXRlbmN5VGVzdFJlc3VsdHMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vRnJlZXplRnJhbWUvRnJlZXplRnJhbWUuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vRnJlZXplRnJhbWUvRnJlZXplRnJhbWVDb250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0lucHV0cy9HYW1lcGFkQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9JbnB1dHMvR2FtZXBhZFR5cGVzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0lucHV0cy9JbnB1dENsYXNzZXNGYWN0b3J5LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0lucHV0cy9LZXlDb2Rlcy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9JbnB1dHMvS2V5Ym9hcmRDb250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0lucHV0cy9Nb3VzZUJ1dHRvbnMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vSW5wdXRzL01vdXNlQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9JbnB1dHMvTW91c2VDb250cm9sbGVySG92ZXJpbmcuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vSW5wdXRzL01vdXNlQ29udHJvbGxlckxvY2tlZC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9JbnB1dHMvU3BlY2lhbEtleUNvZGVzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0lucHV0cy9Ub3VjaENvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vSW5wdXRzL1RvdWNoQ29udHJvbGxlckZha2UuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vSW5wdXRzL1hSR2FtZXBhZENvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vUGVlckNvbm5lY3Rpb25Db250cm9sbGVyL0FnZ3JlZ2F0ZWRTdGF0cy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9QZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIvQ2FuZGlkYXRlU3RhdC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9QZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIvRGF0YUNoYW5uZWxTdGF0cy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9QZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIvSW5ib3VuZFJUUFN0YXRzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1BlZXJDb25uZWN0aW9uQ29udHJvbGxlci9MYXRlbmN5Q2FsY3VsYXRvci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9QZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIvT3V0Qm91bmRSVFBTdGF0cy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9QZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIvUGVlckNvbm5lY3Rpb25Db250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1BlZXJDb25uZWN0aW9uQ29udHJvbGxlci9TZXNzaW9uU3RhdHMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vUGVlckNvbm5lY3Rpb25Db250cm9sbGVyL1N0cmVhbVN0YXRzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1BpeGVsU3RyZWFtaW5nL1BpeGVsU3RyZWFtaW5nLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1VlSW5zdGFuY2VNZXNzYWdlL1Jlc3BvbnNlQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9VZUluc3RhbmNlTWVzc2FnZS9TZW5kTWVzc2FnZUNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vVWVJbnN0YW5jZU1lc3NhZ2UvU3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vVWVJbnN0YW5jZU1lc3NhZ2UvVG9TdHJlYW1lck1lc3NhZ2VzQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9VdGlsL0Jyb3dzZXJVdGlscy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9VdGlsL0V2ZW50RW1pdHRlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9VdGlsL0ZpbGVVdGlsLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1V0aWwvSVVSTFNlYXJjaFBhcmFtcy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9VdGlsL0lucHV0Q29vcmRUcmFuc2xhdG9yLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1V0aWwvUlRDVXRpbHMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vVmlkZW9QbGF5ZXIvU3RyZWFtQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9WaWRlb1BsYXllci9WaWRlb1BsYXllci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9XZWJSdGNQbGF5ZXIvV2ViUnRjUGxheWVyQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9XZWJYUi9XZWJYUkNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uL3NyYy91aWxlc3MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZXBpY2dhbWVzLWZyb250ZW5kXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImVwaWNnYW1lcy1mcm9udGVuZFwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsICgpID0+IHtcbnJldHVybiAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gVG8gbWF0Y2ggTm9kZUpTJyBFdmVudEVtaXR0ZXIgc3ludGF4IHdpdGhvdXQgZG93bnN0cmVhbSBjb2RlIGNoYW5nZXMgd2UgbmVlZCB0byB1c2UgYGFueWAuXG4vLyBUaGlzIG1lYW5zIHdlIG5lZWQgdG8gZGlzYWJsZSBsaW50aW5nIGBhbnlgIGNoZWNrcyBvbiB0aGlzIGZpbGUuXG4vL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCAqL1xuY2xhc3MgUGl4ZWxTdHJlYW1pbmdFdmVudExpc3RlbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9hcmdzID0gW107XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KF9ldnQpIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2soLi4udGhpcy5fYXJncyk7XG4gICAgICAgIC8vIFJlc2V0IHN0b3JhZ2Ugb2YgYXJncy5cbiAgICAgICAgdGhpcy5fYXJncyA9IFtdO1xuICAgIH1cbiAgICBzZXRBcmdzKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fYXJncyA9IGFyZ3M7XG4gICAgfVxufVxuLyoqXG4gKiBBIGZlYXR1cmUtbGltaXRlZCwgYnV0IF9tb3N0bHlfIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIE5vZGUncyBFdmVudEVtaXR0ZXIgdHlwZSB0aGF0IGlzIGltcGxlbWVudGVkIHVzaW5nIEV2ZW50VGFyZ2V0LlxuICpcbiAqIEZvciB0aG9zZSB1bmZhbWlsaWFyIHdpdGggTm9kZSdzIEV2ZW50RW1pdHRlciwgaGVyZSBpcyBzb21lIGluZm8gZnJvbSB0aGUgb2ZmaWNpYWwgZG9jczpcbiAqXG4gKiBbSW4gTm9kZUpTXSBhbGwgb2JqZWN0cyB0aGF0IGVtaXQgZXZlbnRzIGFyZSBpbnN0YW5jZXMgb2YgdGhlIGBFdmVudEVtaXR0ZXJgIGNsYXNzLiBUaGVzZVxuICogb2JqZWN0cyBleHBvc2UgYW4gYGV2ZW50RW1pdHRlci5vbigpYCBmdW5jdGlvbiB0aGF0IGFsbG93cyBvbmUgb3IgbW9yZVxuICogZnVuY3Rpb25zIHRvIGJlIGF0dGFjaGVkIHRvIG5hbWVkIGV2ZW50cyBlbWl0dGVkIGJ5IHRoZSBvYmplY3QuIFR5cGljYWxseSxcbiAqIGV2ZW50IG5hbWVzIGFyZSBjYW1lbC1jYXNlZCBzdHJpbmdzIGJ1dCBhbnkgdmFsaWQgSmF2YVNjcmlwdCBwcm9wZXJ0eSBrZXlcbiAqIGNhbiBiZSB1c2VkLlxuICpcbiAqIFdoZW4gdGhlIGBFdmVudEVtaXR0ZXJgIG9iamVjdCBlbWl0cyBhbiBldmVudCwgYWxsIG9mIHRoZSBmdW5jdGlvbnMgYXR0YWNoZWRcbiAqIHRvIHRoYXQgc3BlY2lmaWMgZXZlbnQgYXJlIGNhbGxlZCBfc3luY2hyb25vdXNseV8uIEFueSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlXG4gKiBjYWxsZWQgbGlzdGVuZXJzIGFyZSBfaWdub3JlZF8gYW5kIGRpc2NhcmRlZC5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgYSBzaW1wbGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2Ugd2l0aCBhIHNpbmdsZVxuICogbGlzdGVuZXIuIFRoZSBgZXZlbnRFbWl0dGVyLm9uKClgIG1ldGhvZCBpcyB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycywgd2hpbGVcbiAqIHRoZSBgZXZlbnRFbWl0dGVyLmVtaXQoKWAgbWV0aG9kIGlzIHVzZWQgdG8gdHJpZ2dlciB0aGUgZXZlbnQuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ25vZGU6ZXZlbnRzJztcbiAqXG4gKiBjbGFzcyBNeUVtaXR0ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge31cbiAqXG4gKiBjb25zdCBteUVtaXR0ZXIgPSBuZXcgTXlFbWl0dGVyKCk7XG4gKiBteUVtaXR0ZXIub24oJ2V2ZW50JywgKCkgPT4ge1xuICogICBjb25zb2xlLmxvZygnYW4gZXZlbnQgb2NjdXJyZWQhJyk7XG4gKiB9KTtcbiAqIG15RW1pdHRlci5lbWl0KCdldmVudCcpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudEVtaXR0ZXIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICByZW1vdmVMaXN0ZW5lckludGVybmFsKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50TGlzdGVuZXJzLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudExpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudFBhaXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50UGFpci5jYWxsYmFjayA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gZXZlbnQgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudFBhaXIuZXZlbnRMaXN0ZW5lcldyYXBwZXIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBvdXIgaW50ZXJuYWwgbWFwXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIGBlbWl0dGVyLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpYC5cbiAgICAgKi9cbiAgICBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBgbGlzdGVuZXJgIGZ1bmN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhlIGV2ZW50XG4gICAgICogbmFtZWQgYGV2ZW50TmFtZWAuXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIHNlcnZlci5vbignY29ubmVjdGlvbicsIChzdHJlYW0pID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdzb21lb25lIGNvbm5lY3RlZCEnKTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgLCBzbyB0aGF0IGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gV3JhcCBvdXIgbm9ybWFsIEpTIGZ1bmN0aW9uIGluIGEgZXZlbnQgbGlzdGVuZXIgaW50ZXJmYWNlXG4gICAgICAgIC8vIHNvIHdlIGNhbiB1c2UgaXQgd2l0aCBldmVudCB0YXJnZXQuXG4gICAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJXcmFwcGVyID0gbmV3IFBpeGVsU3RyZWFtaW5nRXZlbnRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgIHN1cGVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudExpc3RlbmVyV3JhcHBlcik7XG4gICAgICAgIC8vIFN0b3JlIHRoZSBldmVudCBsaXN0ZW5lci9mdW5jdGlvbiBwYWlyIGZvciBsYXRlciByZW1vdmFsLlxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50TGlzdGVuZXJzLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBuZXcgQXJyYXkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnNcbiAgICAgICAgICAgIC5nZXQoZXZlbnROYW1lKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnB1c2goeyBjYWxsYmFjazogbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJXcmFwcGVyOiBldmVudExpc3RlbmVyV3JhcHBlciB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSAqKm9uZS10aW1lKiogYGxpc3RlbmVyYCBmdW5jdGlvbiBmb3IgdGhlIGV2ZW50IG5hbWVkIGBldmVudE5hbWVgLiBUaGVcbiAgICAgKiBuZXh0IHRpbWUgYGV2ZW50TmFtZWAgaXMgdHJpZ2dlcmVkLCB0aGlzIGxpc3RlbmVyIGlzIHJlbW92ZWQgYW5kIHRoZW4gaW52b2tlZC5cbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogc2VydmVyLm9uY2UoJ2Nvbm5lY3Rpb24nLCAoc3RyZWFtKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygnQWgsIHdlIGhhdmUgb3VyIGZpcnN0IHVzZXIhJyk7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCwgc28gdGhhdCBjYWxscyBjYW4gYmUgY2hhaW5lZC5cbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIFRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqL1xuICAgIG9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFBhc3Mgb3B0aW9ucyBzbyB0aGlzIGV2ZW50IGNhbGxiYWNrIGlzIG9ubHkgY2FsbGVkIG9uY2VcbiAgICAgICAgY29uc3QgZXZlbnRMaXN0ZW5lck9wdHMgPSB7IG9uY2U6IHRydWUgfTtcbiAgICAgICAgLy8gV3JhcCBvdXIgbm9ybWFsIEpTIGZ1bmN0aW9uIGluIGEgZXZlbnQgbGlzdGVuZXIgaW50ZXJmYWNlXG4gICAgICAgIC8vIHNvIHdlIGNhbiB1c2UgaXQgd2l0aCBldmVudCB0YXJnZXQgYW5kIHJlbW92ZSBpdCBmcm9tIGV2ZW50IHRhcmdldCB3aGVuIHRoaXMgZnVuY3Rpb24gY29tcGxldGVzLlxuICAgICAgICBjb25zdCBldmVudExpc3RlbmVyV3JhcHBlciA9IG5ldyBQaXhlbFN0cmVhbWluZ0V2ZW50TGlzdGVuZXIoKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyKGFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lckludGVybmFsKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3VwZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXJXcmFwcGVyLCBldmVudExpc3RlbmVyT3B0cyk7XG4gICAgICAgIC8vIFN0b3JlIHRoZSBldmVudCBsaXN0ZW5lci9mdW5jdGlvbiBwYWlyIGZvciBsYXRlciByZW1vdmFsLlxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50TGlzdGVuZXJzLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBuZXcgQXJyYXkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnNcbiAgICAgICAgICAgIC5nZXQoZXZlbnROYW1lKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnB1c2goeyBjYWxsYmFjazogbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJXcmFwcGVyOiBldmVudExpc3RlbmVyV3JhcHBlciB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBgbGlzdGVuZXJgIGZyb20gdGhpcyBFdmVudEVtaXR0ZXIuXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGNhbGxiYWNrID0gKHN0cmVhbSkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3NvbWVvbmUgY29ubmVjdGVkIScpO1xuICAgICAqIH07XG4gICAgICogc2VydmVyLm9uKCdjb25uZWN0aW9uJywgY2FsbGJhY2spO1xuICAgICAqIC8vIC4uLlxuICAgICAqIHNlcnZlci5yZW1vdmVMaXN0ZW5lcignY29ubmVjdGlvbicsIGNhbGxiYWNrKTtcbiAgICAgKiBgYGBcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCwgc28gdGhhdCBjYWxscyBjYW4gYmUgY2hhaW5lZC5cbiAgICAgKi9cbiAgICByZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJJbnRlcm5hbChldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcigpYC5cbiAgICAgKi9cbiAgICBvZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGBldmVudE5hbWVgLlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgLCBzbyB0aGF0IGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50TGlzdGVuZXJzLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudExpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIGVhY2ggZXZlbnQgbGlzdGVuZXIgZnJvbSB0aGUgZXZlbnQgdGFyZ2V0XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyUGFpciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lclBhaXIuZXZlbnRMaXN0ZW5lcldyYXBwZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMgbWFwcGVkIHRvIHRoaXMgZXZlbnQgZnJvbSBvdXIgaW50ZXJuYWwgbWFwXG4gICAgICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVycy5kZWxldGUoZXZlbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXNseSBjYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgdGhlIGV2ZW50IG5hbWVkIGBldmVudE5hbWVgLCBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIHJlZ2lzdGVyZWQsIHBhc3NpbmcgdGhlIHN1cHBsaWVkIGFyZ3VtZW50c1xuICAgICAqIHRvIGVhY2guXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ25vZGU6ZXZlbnRzJztcbiAgICAgKiBjb25zdCBteUVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICpcbiAgICAgKiAvLyBGaXJzdCBsaXN0ZW5lclxuICAgICAqIG15RW1pdHRlci5vbignZXZlbnQnLCBmdW5jdGlvbiBmaXJzdExpc3RlbmVyKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ0hlbGxvb29vISBmaXJzdCBsaXN0ZW5lcicpO1xuICAgICAqIH0pO1xuICAgICAqIC8vIFNlY29uZCBsaXN0ZW5lclxuICAgICAqIG15RW1pdHRlci5vbignZXZlbnQnLCBmdW5jdGlvbiBzZWNvbmRMaXN0ZW5lcihhcmcxLCBhcmcyKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhgZXZlbnQgd2l0aCBwYXJhbWV0ZXJzICR7YXJnMX0sICR7YXJnMn0gaW4gc2Vjb25kIGxpc3RlbmVyYCk7XG4gICAgICogfSk7XG4gICAgICogLy8gVGhpcmQgbGlzdGVuZXJcbiAgICAgKiBteUVtaXR0ZXIub24oJ2V2ZW50JywgZnVuY3Rpb24gdGhpcmRMaXN0ZW5lciguLi5hcmdzKSB7XG4gICAgICogICBjb25zdCBwYXJhbWV0ZXJzID0gYXJncy5qb2luKCcsICcpO1xuICAgICAqICAgY29uc29sZS5sb2coYGV2ZW50IHdpdGggcGFyYW1ldGVycyAke3BhcmFtZXRlcnN9IGluIHRoaXJkIGxpc3RlbmVyYCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhteUVtaXR0ZXIubGlzdGVuZXJzKCdldmVudCcpKTtcbiAgICAgKlxuICAgICAqIG15RW1pdHRlci5lbWl0KCdldmVudCcsIDEsIDIsIDMsIDQsIDUpO1xuICAgICAqXG4gICAgICogLy8gUHJpbnRzOlxuICAgICAqIC8vIFtcbiAgICAgKiAvLyAgIFtGdW5jdGlvbjogZmlyc3RMaXN0ZW5lcl0sXG4gICAgICogLy8gICBbRnVuY3Rpb246IHNlY29uZExpc3RlbmVyXSxcbiAgICAgKiAvLyAgIFtGdW5jdGlvbjogdGhpcmRMaXN0ZW5lcl1cbiAgICAgKiAvLyBdXG4gICAgICogLy8gSGVsbG9vb28hIGZpcnN0IGxpc3RlbmVyXG4gICAgICogLy8gZXZlbnQgd2l0aCBwYXJhbWV0ZXJzIDEsIDIgaW4gc2Vjb25kIGxpc3RlbmVyXG4gICAgICogLy8gZXZlbnQgd2l0aCBwYXJhbWV0ZXJzIDEsIDIsIDMsIDQsIDUgaW4gdGhpcmQgbGlzdGVuZXJcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBlbWl0KGV2ZW50TmFtZSwgLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5fZXZlbnRMaXN0ZW5lcnMuaGFzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRW5zdXJlIGVhY2ggb2Ygb3VyIGxpc3RlbmVycyBoYXZlIHRoZSBhcmdzIHRoZSBjYWxsYmFjayBpbmplY3RlZFxuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lclBhaXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJQYWlyLmV2ZW50TGlzdGVuZXJXcmFwcGVyLnNldEFyZ3MoLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaXJlIG9mZiB0aGUgYWN0dWFsIGV2ZW50XG4gICAgICAgICAgICBzdXBlci5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChldmVudE5hbWUpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudEVtaXR0ZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmV4cG9ydCB2YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJEaXNhYmxlZFwiXSA9IDBdID0gXCJEaXNhYmxlZFwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRXJyb3JcIl0gPSAxXSA9IFwiRXJyb3JcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldhcm5pbmdcIl0gPSAyXSA9IFwiV2FybmluZ1wiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiSW5mb1wiXSA9IDNdID0gXCJJbmZvXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJEZWJ1Z1wiXSA9IDRdID0gXCJEZWJ1Z1wiO1xufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcbi8qKlxuICogVGhlIGdsb2JhbCBjb250ZXh0IGZvciB0aGUgbG9nZ2VyIGNvbmZpZ3VyYXRpb24uXG4gKiBUaGlzIGNhbm5vdCBiZSBzdG9yZWQgc3RhdGljYWxseSBpbiB0aGUgTG9nZ2VyIGNsYXNzIGJlY2F1c2Ugd2Ugc29tZXRpbWVzIGhhdmUgbXVsdGlwbGUgZXhlY3V0aW9uXG4gKiBjb250ZXh0cywgc3VjaCBhcyBzdGF0cyByZXBvcnRpbmcuIEluc3RlYWQgd2Ugc3RvcmUgdGhlIGxvZ2dlciBjb25maWcgY29udGV4dCBvbiB0aGUgd2luZG93IG9iamVjdFxuICogdG8gYmUgc2hhcmVkIHdpdGggYW55IExvZ2dlciBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2dnZXJDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5sb2dMZXZlbCA9IExvZ0xldmVsLkRlYnVnO1xuICAgICAgICB0aGlzLmluY2x1ZGVTdGFjayA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIG92ZXJyaWRlTG9nZ2VyKGxvZ2dlcikge1xuICAgIExvZ2dlciA9IGxvZ2dlcjtcbn1cbi8qKlxuICogQSBiYXNpYyBjb25zb2xlIGxvZ2dlciB1dGlsaXplZCBieSB0aGUgUGl4ZWwgU3RyZWFtaW5nIGZyb250ZW5kIHRvIGFsbG93XG4gKiBsb2dnaW5nIHRvIHRoZSBicm93c2VyIGNvbnNvbGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2dnZXJUeXBlIHtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxvZyB2ZXJib3NpdHkgbGV2ZWxcbiAgICAgKi9cbiAgICBJbml0TG9nZ2luZyhsb2dMZXZlbCwgaW5jbHVkZVN0YWNrKSB7XG4gICAgICAgIHRoaXMuVmFsaWRhdGVDb250ZXh0KCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5sb2dMZXZlbCA9IGxvZ0xldmVsO1xuICAgICAgICB0aGlzLmNvbnRleHQuaW5jbHVkZVN0YWNrID0gaW5jbHVkZVN0YWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dnaW5nIG91dHB1dCBmb3IgZGVidWdnaW5nXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWRcbiAgICAgKi9cbiAgICBEZWJ1ZyhtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuVmFsaWRhdGVDb250ZXh0KCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQubG9nTGV2ZWwgPj0gTG9nTGV2ZWwuRGVidWcpIHtcbiAgICAgICAgICAgIHRoaXMuQ29tbW9uTG9nKCdEZWJ1ZycsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhc2ljIGxvZ2dpbmcgb3V0cHV0IGZvciBzdGFuZGFyZCBtZXNzYWdlc1xuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gdGhlIG1lc3NhZ2UgdG8gYmUgbG9nZ2VkXG4gICAgICovXG4gICAgSW5mbyhtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuVmFsaWRhdGVDb250ZXh0KCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQubG9nTGV2ZWwgPj0gTG9nTGV2ZWwuSW5mbykge1xuICAgICAgICAgICAgdGhpcy5Db21tb25Mb2coJ0luZm8nLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dnaW5nIGZvciB3YXJuaW5nc1xuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gdGhlIG1lc3NhZ2UgdG8gYmUgbG9nZ2VkXG4gICAgICovXG4gICAgV2FybmluZyhtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuVmFsaWRhdGVDb250ZXh0KCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQubG9nTGV2ZWwgPj0gTG9nTGV2ZWwuV2FybmluZykge1xuICAgICAgICAgICAgdGhpcy5Db21tb25Mb2coJ1dhcm5pbmcnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcnJvciBsb2dnaW5nXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWRcbiAgICAgKi9cbiAgICBFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuVmFsaWRhdGVDb250ZXh0KCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQubG9nTGV2ZWwgPj0gTG9nTGV2ZWwuRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuQ29tbW9uTG9nKCdFcnJvcicsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb21tb24gbG9nIGZ1bmN0aW9uIHRoYXQgYWxsIG90aGVyIGxvZyBmdW5jdGlvbnMgY2FsbCB0by5cbiAgICAgKiBAcGFyYW0gbGV2ZWwgLSB0aGUgbGV2ZWwgb2YgdGhpcyBsb2cgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gc3RhY2sgLSBhbiBvcHRpb25hbCBzdGFjayB0cmFjZSBzdHJpbmcgZnJvbSB3aGVyZSB0aGUgbG9nIG1lc3NhZ2Ugd2FzIGNhbGxlZC5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBDb21tb25Mb2cobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgbGV0IGxvZ01lc3NhZ2UgPSBgWyR7bGV2ZWx9XSAtICR7bWVzc2FnZX1gO1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmluY2x1ZGVTdGFjaykge1xuICAgICAgICAgICAgbG9nTWVzc2FnZSArPSBgXFxuU3RhY2s6ICR7dGhpcy5HZXRTdGFja1RyYWNlKCl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV2ZWwgPT09ICdFcnJvcicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobG9nTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGV2ZWwgPT09ICdXYXJuaW5nJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGxvZ01lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobG9nTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FwdHVyZXMgdGhlIHN0YWNrIGFuZCByZXR1cm5zIGl0XG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgc3RhY2tcbiAgICAgKi9cbiAgICBHZXRTdGFja1RyYWNlKCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBsZXQgZm9ybWF0dGVkU3RhY2sgPSAnTm8gU3RhY2sgQXZhaWxhYmxlIGZvciB0aGlzIGJyb3dzZXInO1xuICAgICAgICAvLyBmb3JtYXQgdGhlIGVycm9yXG4gICAgICAgIGlmIChlcnJvci5zdGFjaykge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RhY2sgPSBlcnJvci5zdGFjay50b1N0cmluZygpLnJlcGxhY2UoL0Vycm9yL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkU3RhY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbmNlIHRoZXJlIGNhbiBiZSBtdWx0aXBsZSBleGVjdXRpb24gY29udGV4dHMsIChzdGF0cyByZXBvcnRpbmcgYW5kIHNvbWUgd2VieHIgbG9nZ2luZyBjb21lcyBmcm9tXG4gICAgICogZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0cyB3ZSBjYW4gZW5kIHVwIHdpdGggbXVsdGlwbGUgc3RhdGljIExvZ2dlciBpbnN0YW5jZXMuIEhlcmUgd2UgdHJ5IHRvXG4gICAgICogd29yayBhcm91bmQgaXQgYnkgc3RvcmluZyB0aGUgY29udGV4dCBvbiB0aGUgd2luZG93IG9iamVjdC5cbiAgICAgKi9cbiAgICBWYWxpZGF0ZUNvbnRleHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PSAndW5kZWZpbmVkJyB8fCAhd2luZG93KSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gd2luZG93IG9iamVjdCBzbyB3ZSBjYW4gb25seSBzdG9yZSBhIGxvY2FsIGNvbnRleHQuXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV3IExvZ2dlckNvbnRleHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF3aW5kb3cubG9nZ2VyQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IG5ldyBMb2dnZXJDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvZ2dlckNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSB3aW5kb3cubG9nZ2VyQ29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBsZXQgTG9nZ2VyID0gbmV3IExvZ2dlclR5cGUoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvZ2dlci5qcy5tYXAiLCJpbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi9Mb2dnZXIvTG9nZ2VyJztcbmltcG9ydCB7IE1lc3NhZ2VSZWdpc3RyeSB9IGZyb20gJy4vbWVzc2FnZV9yZWdpc3RyeSc7XG4vKipcbiAqIEEgaGVscGVyIGZvciBjcmVhdGluZyBzaWduYWxsaW5nIG1lc3NhZ2VzLiBUYWtlcyBpbiBvcHRpb25hbCBnaXZlbiBwYXJhbWV0ZXJzIGFuZFxuICogaW5jbHVkZXMgdGhlbSBpbiBhIG1lc3NhZ2Ugb2JqZWN0IHdpdGggdGhlICd0eXBlJyBmaWVsZCBzZXQgcHJvcGVybHkgZm9yIHRoZSBtZXNzYWdlXG4gKiB0eXBlIHN1cHBsaWVkLlxuICogQHBhcmFtIG1lc3NhZ2VUeXBlIC0gQSBtZXNzYWdlIHR5cGUgZnJvbSBNZXNzYWdlUmVnaXN0cnkgdGhhdCBpbmRpY2F0ZXMgdGhlIHR5cGUgb2YgbWVzc2FnZSB0byBjcmVhdGUuXG4gKiBAcGFyYW0gcGFyYW1zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHdob3NlIGZpZWxkcyBhcmUgYWRkZWQgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSByZXN1bHRpbmcgbWVzc2FnZSBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNZXNzYWdlKG1lc3NhZ2VUeXBlLCBwYXJhbXMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZVR5cGUuY3JlYXRlKCk7XG4gICAgbWVzc2FnZS50eXBlID0gbWVzc2FnZVR5cGUudHlwZU5hbWU7XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgICBtZXNzYWdlVHlwZS5tZXJnZVBhcnRpYWwobWVzc2FnZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG4vKipcbiAqIFRlc3RzIHRoYXQgdGhlIHN1cHBsaWVkIG1lc3NhZ2UgaXMgdmFsaWQuIFRoYXQgaXMgY29udGFpbnMgYWxsIGV4cGVjdGVkIGZpZWxkcyBhbmRcbiAqIGRvZXNuJ3QgY29udGFpbiBhbnkgdW5rbm93biBmaWVsZHMuXG4gKiBAcGFyYW0gbXNnIC0gVGhlIG1lc3NhZ2Ugb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJucyBUaGUgbWVzc2FnZSB0eXBlIGZyb20gTWVzc2FnZVJlZ2lzdHJ5IG9mIHRoZSBzdXBwbGllZCBtZXNzYWdlIG9iamVjdCBpZiBpdCdzIHZhbGlkLCBvciBudWxsIGlmIGludmFsaWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU1lc3NhZ2UobXNnKSB7XG4gICAgbGV0IHZhbGlkID0gdHJ1ZTtcbiAgICBpZiAoIW1zZy50eXBlKSB7XG4gICAgICAgIExvZ2dlci5FcnJvcihgUGFyc2VkIG1lc3NhZ2UgaGFzIG5vIHR5cGUuIFJlamVjdGVkLiAke0pTT04uc3RyaW5naWZ5KG1zZyl9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlVHlwZSA9IE1lc3NhZ2VSZWdpc3RyeVttc2cudHlwZV07XG4gICAgaWYgKCFtZXNzYWdlVHlwZSkge1xuICAgICAgICBMb2dnZXIuRXJyb3IoYE1lc3NhZ2UgaXMgb2YgYW4gdW5rbm93biB0eXBlOiBcIiR7bXNnLnR5cGV9XCIuIFJlamVjdGVkLmApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2VUeXBlLmZpZWxkcykge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIG1lc3NhZ2VUeXBlLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKCFmaWVsZC5vcHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtc2csIGZpZWxkLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihgTWVzc2FnZSBcIiR7bXNnLnR5cGV9XCJcIiBpcyBtaXNzaW5nIHJlcXVpcmVkIGZpZWxkIFwiJHtmaWVsZC5uYW1lfVwiLiBSZWplY3RlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWVsZE5hbWUgaW4gbXNnKSB7XG4gICAgICAgIGNvbnN0IGZvdW5kID0gbWVzc2FnZVR5cGUuZmllbGRzLmZpbmQoKGZpZWxkKSA9PiBmaWVsZC5uYW1lID09PSBmaWVsZE5hbWUpO1xuICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoYE1lc3NhZ2UgXCIke21zZy50eXBlfVwiIGNvbnRhaW5zIHVua25vd24gZmllbGQgXCIke2ZpZWxkTmFtZX1cIi4gUmVqZWN0ZWQuYCk7XG4gICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWxpZCA/IG1lc3NhZ2VUeXBlIDogbnVsbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2VfaGVscGVycy5qcy5tYXAiLCJpbXBvcnQgKiBhcyBNZXNzYWdlcyBmcm9tICcuL3NpZ25hbGxpbmdfbWVzc2FnZXMnO1xuLyoqXG4gKiBBIG1hcCBvZiBhbGwgdGhlIHN1cHBvcnRlZCBzaWduYWxsaW5nIG1lc3NhZ2VzIGluIHRoZSBQaXhlbCBTdHJlYW1pbmdcbiAqIHNpZ25hbGxpbmcgcHJvdG9jb2wuIFRoaXMgYWxsb3dzIG1hcHBpbmcgb2Ygc2lnbmFsbGluZyBtZXNzYWdlIG5hbWVzXG4gKiB0byBhY3R1YWwgbWVzc2FnZSB0eXBlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IE1lc3NhZ2VSZWdpc3RyeSA9IHtcbiAgICBhbnN3ZXI6IE1lc3NhZ2VzLmFuc3dlcixcbiAgICBjb25maWc6IE1lc3NhZ2VzLmNvbmZpZyxcbiAgICBkaXNjb25uZWN0UGxheWVyOiBNZXNzYWdlcy5kaXNjb25uZWN0UGxheWVyLFxuICAgIGVuZHBvaW50SWQ6IE1lc3NhZ2VzLmVuZHBvaW50SWQsXG4gICAgZW5kcG9pbnRJZENvbmZpcm06IE1lc3NhZ2VzLmVuZHBvaW50SWRDb25maXJtLFxuICAgIGljZUNhbmRpZGF0ZTogTWVzc2FnZXMuaWNlQ2FuZGlkYXRlLFxuICAgIGlkZW50aWZ5OiBNZXNzYWdlcy5pZGVudGlmeSxcbiAgICBsaXN0U3RyZWFtZXJzOiBNZXNzYWdlcy5saXN0U3RyZWFtZXJzLFxuICAgIG9mZmVyOiBNZXNzYWdlcy5vZmZlcixcbiAgICBwaW5nOiBNZXNzYWdlcy5waW5nLFxuICAgIHBsYXllckNvbm5lY3RlZDogTWVzc2FnZXMucGxheWVyQ29ubmVjdGVkLFxuICAgIHBsYXllckNvdW50OiBNZXNzYWdlcy5wbGF5ZXJDb3VudCxcbiAgICBwbGF5ZXJEaXNjb25uZWN0ZWQ6IE1lc3NhZ2VzLnBsYXllckRpc2Nvbm5lY3RlZCxcbiAgICBwb25nOiBNZXNzYWdlcy5wb25nLFxuICAgIHN0YXRzOiBNZXNzYWdlcy5zdGF0cyxcbiAgICBzdHJlYW1lckRpc2Nvbm5lY3RlZDogTWVzc2FnZXMuc3RyZWFtZXJEaXNjb25uZWN0ZWQsXG4gICAgc3RyZWFtZXJMaXN0OiBNZXNzYWdlcy5zdHJlYW1lckxpc3QsXG4gICAgc3Vic2NyaWJlOiBNZXNzYWdlcy5zdWJzY3JpYmUsXG4gICAgdW5zdWJzY3JpYmU6IE1lc3NhZ2VzLnVuc3Vic2NyaWJlLFxuICAgIGxheWVyUHJlZmVyZW5jZTogTWVzc2FnZXMubGF5ZXJQcmVmZXJlbmNlLFxuICAgIGRhdGFDaGFubmVsUmVxdWVzdDogTWVzc2FnZXMuZGF0YUNoYW5uZWxSZXF1ZXN0LFxuICAgIHBlZXJEYXRhQ2hhbm5lbHM6IE1lc3NhZ2VzLnBlZXJEYXRhQ2hhbm5lbHMsXG4gICAgcGVlckRhdGFDaGFubmVsc1JlYWR5OiBNZXNzYWdlcy5wZWVyRGF0YUNoYW5uZWxzUmVhZHksXG4gICAgc3RyZWFtZXJEYXRhQ2hhbm5lbHM6IE1lc3NhZ2VzLnN0cmVhbWVyRGF0YUNoYW5uZWxzLFxuICAgIHN0YXJ0U3RyZWFtaW5nOiBNZXNzYWdlcy5zdGFydFN0cmVhbWluZyxcbiAgICBzdG9wU3RyZWFtaW5nOiBNZXNzYWdlcy5zdG9wU3RyZWFtaW5nXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZV9yZWdpc3RyeS5qcy5tYXAiLCJpbXBvcnQgeyBXaXJlVHlwZSB9IGZyb20gXCJAcHJvdG9idWYtdHMvcnVudGltZVwiO1xuaW1wb3J0IHsgVW5rbm93bkZpZWxkSGFuZGxlciB9IGZyb20gXCJAcHJvdG9idWYtdHMvcnVudGltZVwiO1xuaW1wb3J0IHsgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCB9IGZyb20gXCJAcHJvdG9idWYtdHMvcnVudGltZVwiO1xuaW1wb3J0IHsgTWVzc2FnZVR5cGUgfSBmcm9tIFwiQHByb3RvYnVmLXRzL3J1bnRpbWVcIjtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIGJhc2VfbWVzc2FnZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImJhc2VfbWVzc2FnZVwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBiYXNlX21lc3NhZ2VcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2VfbWVzc2FnZSA9IG5ldyBiYXNlX21lc3NhZ2UkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgcGVlckNvbm5lY3Rpb25PcHRpb25zJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwicGVlckNvbm5lY3Rpb25PcHRpb25zXCIsIFtdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBwZWVyQ29ubmVjdGlvbk9wdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IHBlZXJDb25uZWN0aW9uT3B0aW9ucyA9IG5ldyBwZWVyQ29ubmVjdGlvbk9wdGlvbnMkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgY29uZmlnJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiY29uZmlnXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJwZWVyQ29ubmVjdGlvbk9wdGlvbnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6ICgpID0+IHBlZXJDb25uZWN0aW9uT3B0aW9ucyB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogXCJwcm90b2NvbFZlcnNpb25cIiwga2luZDogXCJzY2FsYXJcIiwgb3B0OiB0cnVlLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHBlZXJDb25uZWN0aW9uT3B0aW9ucyBwZWVyQ29ubmVjdGlvbk9wdGlvbnMgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wZWVyQ29ubmVjdGlvbk9wdGlvbnMgPSBwZWVyQ29ubmVjdGlvbk9wdGlvbnMuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLnBlZXJDb25uZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogb3B0aW9uYWwgc3RyaW5nIHByb3RvY29sVmVyc2lvbiAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByb3RvY29sVmVyc2lvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIHBlZXJDb25uZWN0aW9uT3B0aW9ucyBwZWVyQ29ubmVjdGlvbk9wdGlvbnMgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wZWVyQ29ubmVjdGlvbk9wdGlvbnMpXG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbk9wdGlvbnMuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnBlZXJDb25uZWN0aW9uT3B0aW9ucywgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBvcHRpb25hbCBzdHJpbmcgcHJvdG9jb2xWZXJzaW9uID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucHJvdG9jb2xWZXJzaW9uICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UucHJvdG9jb2xWZXJzaW9uKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGNvbmZpZ1xuICovXG5leHBvcnQgY29uc3QgY29uZmlnID0gbmV3IGNvbmZpZyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBpZGVudGlmeSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImlkZW50aWZ5XCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGlkZW50aWZ5XG4gKi9cbmV4cG9ydCBjb25zdCBpZGVudGlmeSA9IG5ldyBpZGVudGlmeSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBlbmRwb2ludElkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiZW5kcG9pbnRJZFwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwiaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6IFwicHJvdG9jb2xWZXJzaW9uXCIsIGtpbmQ6IFwic2NhbGFyXCIsIG9wdDogdHJ1ZSwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLmlkID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIGlkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogb3B0aW9uYWwgc3RyaW5nIHByb3RvY29sVmVyc2lvbiAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByb3RvY29sVmVyc2lvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBpZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmlkICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmlkKTtcbiAgICAgICAgLyogb3B0aW9uYWwgc3RyaW5nIHByb3RvY29sVmVyc2lvbiA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnByb3RvY29sVmVyc2lvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnByb3RvY29sVmVyc2lvbik7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBlbmRwb2ludElkXG4gKi9cbmV4cG9ydCBjb25zdCBlbmRwb2ludElkID0gbmV3IGVuZHBvaW50SWQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgZW5kcG9pbnRJZENvbmZpcm0kVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJlbmRwb2ludElkQ29uZmlybVwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwiY29tbWl0dGVkSWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLmNvbW1pdHRlZElkID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIGNvbW1pdHRlZElkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29tbWl0dGVkSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBzdHJpbmcgY29tbWl0dGVkSWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jb21taXR0ZWRJZCAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5jb21taXR0ZWRJZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBlbmRwb2ludElkQ29uZmlybVxuICovXG5leHBvcnQgY29uc3QgZW5kcG9pbnRJZENvbmZpcm0gPSBuZXcgZW5kcG9pbnRJZENvbmZpcm0kVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3Mgc3RyZWFtZXJJZENoYW5nZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJzdHJlYW1lcklkQ2hhbmdlZFwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwibmV3SURcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLm5ld0lEID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIG5ld0lEICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmV3SUQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBzdHJpbmcgbmV3SUQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5uZXdJRCAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5uZXdJRCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW1lcklkQ2hhbmdlZFxuICovXG5leHBvcnQgY29uc3Qgc3RyZWFtZXJJZENoYW5nZWQgPSBuZXcgc3RyZWFtZXJJZENoYW5nZWQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgbGlzdFN0cmVhbWVycyRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImxpc3RTdHJlYW1lcnNcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgbGlzdFN0cmVhbWVyc1xuICovXG5leHBvcnQgY29uc3QgbGlzdFN0cmVhbWVycyA9IG5ldyBsaXN0U3RyZWFtZXJzJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHN0cmVhbWVyTGlzdCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInN0cmVhbWVyTGlzdFwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwiaWRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIHJlcGVhdDogMiAvKlJlcGVhdFR5cGUuVU5QQUNLRUQqLywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLmlkcyA9IFtdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJpbmcgaWRzICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIHJlcGVhdGVkIHN0cmluZyBpZHMgPSAyOyAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UuaWRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmlkc1tpXSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW1lckxpc3RcbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmVhbWVyTGlzdCA9IG5ldyBzdHJlYW1lckxpc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3Mgc3Vic2NyaWJlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwic3Vic2NyaWJlXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJzdHJlYW1lcklkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zdHJlYW1lcklkID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHN0cmVhbWVySWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJlYW1lcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyaW5nIHN0cmVhbWVySWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zdHJlYW1lcklkICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnN0cmVhbWVySWQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3Vic2NyaWJlXG4gKi9cbmV4cG9ydCBjb25zdCBzdWJzY3JpYmUgPSBuZXcgc3Vic2NyaWJlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHVuc3Vic2NyaWJlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwidW5zdWJzY3JpYmVcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgdW5zdWJzY3JpYmVcbiAqL1xuZXhwb3J0IGNvbnN0IHVuc3Vic2NyaWJlID0gbmV3IHVuc3Vic2NyaWJlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHN1YnNjcmliZUZhaWxlZCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInN1YnNjcmliZUZhaWxlZFwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwibWVzc2FnZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UubWVzc2FnZSA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBtZXNzYWdlICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWVzc2FnZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBtZXNzYWdlID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubWVzc2FnZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN1YnNjcmliZUZhaWxlZFxuICovXG5leHBvcnQgY29uc3Qgc3Vic2NyaWJlRmFpbGVkID0gbmV3IHN1YnNjcmliZUZhaWxlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBwbGF5ZXJDb25uZWN0ZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJwbGF5ZXJDb25uZWN0ZWRcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcImRhdGFDaGFubmVsXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogXCJzZnVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgICAgICAgICB7IG5vOiA1LCBuYW1lOiBcInBsYXllcklkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5kYXRhQ2hhbm5lbCA9IGZhbHNlO1xuICAgICAgICBtZXNzYWdlLnNmdSA9IGZhbHNlO1xuICAgICAgICBtZXNzYWdlLnBsYXllcklkID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBkYXRhQ2hhbm5lbCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGFDaGFubmVsID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIHNmdSAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNmdSA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHBsYXllcklkICovIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGxheWVySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBib29sIGRhdGFDaGFubmVsID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YUNoYW5uZWwgIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5kYXRhQ2hhbm5lbCk7XG4gICAgICAgIC8qIGJvb2wgc2Z1ID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Z1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2Uuc2Z1KTtcbiAgICAgICAgLyogc3RyaW5nIHBsYXllcklkID0gNTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGxheWVySWQgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDUsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UucGxheWVySWQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgcGxheWVyQ29ubmVjdGVkXG4gKi9cbmV4cG9ydCBjb25zdCBwbGF5ZXJDb25uZWN0ZWQgPSBuZXcgcGxheWVyQ29ubmVjdGVkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHBsYXllckRpc2Nvbm5lY3RlZCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInBsYXllckRpc2Nvbm5lY3RlZFwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwicGxheWVySWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLnBsYXllcklkID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHBsYXllcklkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGxheWVySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBzdHJpbmcgcGxheWVySWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wbGF5ZXJJZCAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5wbGF5ZXJJZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBwbGF5ZXJEaXNjb25uZWN0ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHBsYXllckRpc2Nvbm5lY3RlZCA9IG5ldyBwbGF5ZXJEaXNjb25uZWN0ZWQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3Mgb2ZmZXIkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJvZmZlclwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwic2RwXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiBcInBsYXllcklkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIG9wdDogdHJ1ZSwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6IFwic2Z1XCIsIGtpbmQ6IFwic2NhbGFyXCIsIG9wdDogdHJ1ZSwgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgICAgICAgICB7IG5vOiA1LCBuYW1lOiBcIm11bHRpcGxleFwiLCBraW5kOiBcInNjYWxhclwiLCBvcHQ6IHRydWUsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICAgICAgeyBubzogNiwgbmFtZTogXCJzY2FsYWJpbGl0eU1vZGVcIiwga2luZDogXCJzY2FsYXJcIiwgb3B0OiB0cnVlLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2Uuc2RwID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNkcCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNkcCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBvcHRpb25hbCBzdHJpbmcgcGxheWVySWQgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wbGF5ZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBvcHRpb25hbCBib29sIHNmdSAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNmdSA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogb3B0aW9uYWwgYm9vbCBtdWx0aXBsZXggKi8gNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tdWx0aXBsZXggPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIG9wdGlvbmFsIHN0cmluZyBzY2FsYWJpbGl0eU1vZGUgKi8gNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zY2FsYWJpbGl0eU1vZGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBzdHJpbmcgc2RwID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2RwICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNkcCk7XG4gICAgICAgIC8qIG9wdGlvbmFsIHN0cmluZyBwbGF5ZXJJZCA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBsYXllcklkICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UucGxheWVySWQpO1xuICAgICAgICAvKiBvcHRpb25hbCBib29sIHNmdSA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNmdSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5zZnUpO1xuICAgICAgICAvKiBvcHRpb25hbCBib29sIG11bHRpcGxleCA9IDU7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm11bHRpcGxleCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg1LCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5tdWx0aXBsZXgpO1xuICAgICAgICAvKiBvcHRpb25hbCBzdHJpbmcgc2NhbGFiaWxpdHlNb2RlID0gNjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2NhbGFiaWxpdHlNb2RlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDYsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2NhbGFiaWxpdHlNb2RlKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIG9mZmVyXG4gKi9cbmV4cG9ydCBjb25zdCBvZmZlciA9IG5ldyBvZmZlciRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBhbnN3ZXIkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJhbnN3ZXJcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcInNkcFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogXCJwbGF5ZXJJZFwiLCBraW5kOiBcInNjYWxhclwiLCBvcHQ6IHRydWUsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiA0LCBuYW1lOiBcIm1pbkJpdHJhdGVCcHNcIiwga2luZDogXCJzY2FsYXJcIiwgb3B0OiB0cnVlLCBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovIH0sXG4gICAgICAgICAgICB7IG5vOiA1LCBuYW1lOiBcIm1heEJpdHJhdGVCcHNcIiwga2luZDogXCJzY2FsYXJcIiwgb3B0OiB0cnVlLCBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zZHAgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2RwICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2RwID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIG9wdGlvbmFsIHN0cmluZyBwbGF5ZXJJZCAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBsYXllcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIG9wdGlvbmFsIGludDMyIG1pbkJpdHJhdGVCcHMgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5taW5CaXRyYXRlQnBzID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogb3B0aW9uYWwgaW50MzIgbWF4Qml0cmF0ZUJwcyAqLyA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1heEJpdHJhdGVCcHMgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBzZHAgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZHAgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2RwKTtcbiAgICAgICAgLyogb3B0aW9uYWwgc3RyaW5nIHBsYXllcklkID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGxheWVySWQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5wbGF5ZXJJZCk7XG4gICAgICAgIC8qIG9wdGlvbmFsIGludDMyIG1pbkJpdHJhdGVCcHMgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5taW5CaXRyYXRlQnBzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5taW5CaXRyYXRlQnBzKTtcbiAgICAgICAgLyogb3B0aW9uYWwgaW50MzIgbWF4Qml0cmF0ZUJwcyA9IDU7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm1heEJpdHJhdGVCcHMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNSwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLm1heEJpdHJhdGVCcHMpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgYW5zd2VyXG4gKi9cbmV4cG9ydCBjb25zdCBhbnN3ZXIgPSBuZXcgYW5zd2VyJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIGljZUNhbmRpZGF0ZURhdGEkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJpY2VDYW5kaWRhdGVEYXRhXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwiY2FuZGlkYXRlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcInNkcE1pZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogXCJzZHBNTGluZUluZGV4XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6IFwidXNlcm5hbWVGcmFnbWVudFwiLCBraW5kOiBcInNjYWxhclwiLCBvcHQ6IHRydWUsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS5jYW5kaWRhdGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLnNkcE1pZCA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2Uuc2RwTUxpbmVJbmRleCA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIGNhbmRpZGF0ZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNhbmRpZGF0ZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2RwTWlkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2RwTWlkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDMyIHNkcE1MaW5lSW5kZXggKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZHBNTGluZUluZGV4ID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogb3B0aW9uYWwgc3RyaW5nIHVzZXJuYW1lRnJhZ21lbnQgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51c2VybmFtZUZyYWdtZW50ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBjYW5kaWRhdGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jYW5kaWRhdGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuY2FuZGlkYXRlKTtcbiAgICAgICAgLyogc3RyaW5nIHNkcE1pZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNkcE1pZCAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZHBNaWQpO1xuICAgICAgICAvKiBpbnQzMiBzZHBNTGluZUluZGV4ID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2RwTUxpbmVJbmRleCAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnNkcE1MaW5lSW5kZXgpO1xuICAgICAgICAvKiBvcHRpb25hbCBzdHJpbmcgdXNlcm5hbWVGcmFnbWVudCA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnVzZXJuYW1lRnJhZ21lbnQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS51c2VybmFtZUZyYWdtZW50KTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGljZUNhbmRpZGF0ZURhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGljZUNhbmRpZGF0ZURhdGEgPSBuZXcgaWNlQ2FuZGlkYXRlRGF0YSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBpY2VDYW5kaWRhdGUkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJpY2VDYW5kaWRhdGVcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcImNhbmRpZGF0ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogKCkgPT4gaWNlQ2FuZGlkYXRlRGF0YSB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogXCJwbGF5ZXJJZFwiLCBraW5kOiBcInNjYWxhclwiLCBvcHQ6IHRydWUsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogaWNlQ2FuZGlkYXRlRGF0YSBjYW5kaWRhdGUgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jYW5kaWRhdGUgPSBpY2VDYW5kaWRhdGVEYXRhLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5jYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIG9wdGlvbmFsIHN0cmluZyBwbGF5ZXJJZCAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBsYXllcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogaWNlQ2FuZGlkYXRlRGF0YSBjYW5kaWRhdGUgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jYW5kaWRhdGUpXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVEYXRhLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5jYW5kaWRhdGUsIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogb3B0aW9uYWwgc3RyaW5nIHBsYXllcklkID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGxheWVySWQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5wbGF5ZXJJZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBpY2VDYW5kaWRhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGljZUNhbmRpZGF0ZSA9IG5ldyBpY2VDYW5kaWRhdGUkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgZGlzY29ubmVjdFBsYXllciRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImRpc2Nvbm5lY3RQbGF5ZXJcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcInBsYXllcklkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiBcInJlYXNvblwiLCBraW5kOiBcInNjYWxhclwiLCBvcHQ6IHRydWUsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5wbGF5ZXJJZCA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBwbGF5ZXJJZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBsYXllcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIG9wdGlvbmFsIHN0cmluZyByZWFzb24gKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZWFzb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBzdHJpbmcgcGxheWVySWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wbGF5ZXJJZCAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5wbGF5ZXJJZCk7XG4gICAgICAgIC8qIG9wdGlvbmFsIHN0cmluZyByZWFzb24gPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5yZWFzb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5yZWFzb24pO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgZGlzY29ubmVjdFBsYXllclxuICovXG5leHBvcnQgY29uc3QgZGlzY29ubmVjdFBsYXllciA9IG5ldyBkaXNjb25uZWN0UGxheWVyJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHBpbmckVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJwaW5nXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJ0aW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLnRpbWUgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiB0aW1lICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGltZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogaW50MzIgdGltZSA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnRpbWUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS50aW1lKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHBpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHBpbmcgPSBuZXcgcGluZyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBwb25nJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwicG9uZ1wiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwidGltZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS50aW1lID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogaW50MzIgdGltZSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRpbWUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIGludDMyIHRpbWUgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50aW1lICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UudGltZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBwb25nXG4gKi9cbmV4cG9ydCBjb25zdCBwb25nID0gbmV3IHBvbmckVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3Mgc3RyZWFtZXJEaXNjb25uZWN0ZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJzdHJlYW1lckRpc2Nvbm5lY3RlZFwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW1lckRpc2Nvbm5lY3RlZFxuICovXG5leHBvcnQgY29uc3Qgc3RyZWFtZXJEaXNjb25uZWN0ZWQgPSBuZXcgc3RyZWFtZXJEaXNjb25uZWN0ZWQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgbGF5ZXJQcmVmZXJlbmNlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwibGF5ZXJQcmVmZXJlbmNlXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJzcGF0aWFsTGF5ZXJcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogXCJ0ZW1wb3JhbExheWVyXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6IFwicGxheWVySWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLnNwYXRpYWxMYXllciA9IDA7XG4gICAgICAgIG1lc3NhZ2UudGVtcG9yYWxMYXllciA9IDA7XG4gICAgICAgIG1lc3NhZ2UucGxheWVySWQgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiBzcGF0aWFsTGF5ZXIgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zcGF0aWFsTGF5ZXIgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiB0ZW1wb3JhbExheWVyICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVtcG9yYWxMYXllciA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBwbGF5ZXJJZCAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBsYXllcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogaW50MzIgc3BhdGlhbExheWVyID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3BhdGlhbExheWVyICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2Uuc3BhdGlhbExheWVyKTtcbiAgICAgICAgLyogaW50MzIgdGVtcG9yYWxMYXllciA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnRlbXBvcmFsTGF5ZXIgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS50ZW1wb3JhbExheWVyKTtcbiAgICAgICAgLyogc3RyaW5nIHBsYXllcklkID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGxheWVySWQgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UucGxheWVySWQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgbGF5ZXJQcmVmZXJlbmNlXG4gKi9cbmV4cG9ydCBjb25zdCBsYXllclByZWZlcmVuY2UgPSBuZXcgbGF5ZXJQcmVmZXJlbmNlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIGRhdGFDaGFubmVsUmVxdWVzdCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImRhdGFDaGFubmVsUmVxdWVzdFwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBkYXRhQ2hhbm5lbFJlcXVlc3RcbiAqL1xuZXhwb3J0IGNvbnN0IGRhdGFDaGFubmVsUmVxdWVzdCA9IG5ldyBkYXRhQ2hhbm5lbFJlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgcGVlckRhdGFDaGFubmVscyRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInBlZXJEYXRhQ2hhbm5lbHNcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcInBsYXllcklkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiBcInNlbmRTdHJlYW1JZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovIH0sXG4gICAgICAgICAgICB7IG5vOiA0LCBuYW1lOiBcInJlY3ZTdHJlYW1JZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5wbGF5ZXJJZCA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2Uuc2VuZFN0cmVhbUlkID0gMDtcbiAgICAgICAgbWVzc2FnZS5yZWN2U3RyZWFtSWQgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgcGxheWVySWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wbGF5ZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiBzZW5kU3RyZWFtSWQgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZW5kU3RyZWFtSWQgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiByZWN2U3RyZWFtSWQgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZWN2U3RyZWFtSWQgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBwbGF5ZXJJZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBsYXllcklkICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnBsYXllcklkKTtcbiAgICAgICAgLyogaW50MzIgc2VuZFN0cmVhbUlkID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VuZFN0cmVhbUlkICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2Uuc2VuZFN0cmVhbUlkKTtcbiAgICAgICAgLyogaW50MzIgcmVjdlN0cmVhbUlkID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucmVjdlN0cmVhbUlkICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UucmVjdlN0cmVhbUlkKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHBlZXJEYXRhQ2hhbm5lbHNcbiAqL1xuZXhwb3J0IGNvbnN0IHBlZXJEYXRhQ2hhbm5lbHMgPSBuZXcgcGVlckRhdGFDaGFubmVscyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBwZWVyRGF0YUNoYW5uZWxzUmVhZHkkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJwZWVyRGF0YUNoYW5uZWxzUmVhZHlcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgcGVlckRhdGFDaGFubmVsc1JlYWR5XG4gKi9cbmV4cG9ydCBjb25zdCBwZWVyRGF0YUNoYW5uZWxzUmVhZHkgPSBuZXcgcGVlckRhdGFDaGFubmVsc1JlYWR5JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHN0cmVhbWVyRGF0YUNoYW5uZWxzJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwic3RyZWFtZXJEYXRhQ2hhbm5lbHNcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcInNmdUlkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiBcInNlbmRTdHJlYW1JZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovIH0sXG4gICAgICAgICAgICB7IG5vOiA0LCBuYW1lOiBcInJlY3ZTdHJlYW1JZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zZnVJZCA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2Uuc2VuZFN0cmVhbUlkID0gMDtcbiAgICAgICAgbWVzc2FnZS5yZWN2U3RyZWFtSWQgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Z1SWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZnVJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiBzZW5kU3RyZWFtSWQgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZW5kU3RyZWFtSWQgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiByZWN2U3RyZWFtSWQgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZWN2U3RyZWFtSWQgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBzZnVJZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNmdUlkICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNmdUlkKTtcbiAgICAgICAgLyogaW50MzIgc2VuZFN0cmVhbUlkID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VuZFN0cmVhbUlkICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2Uuc2VuZFN0cmVhbUlkKTtcbiAgICAgICAgLyogaW50MzIgcmVjdlN0cmVhbUlkID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucmVjdlN0cmVhbUlkICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UucmVjdlN0cmVhbUlkKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbWVyRGF0YUNoYW5uZWxzXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJlYW1lckRhdGFDaGFubmVscyA9IG5ldyBzdHJlYW1lckRhdGFDaGFubmVscyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBzdGFydFN0cmVhbWluZyRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInN0YXJ0U3RyZWFtaW5nXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0YXJ0U3RyZWFtaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBzdGFydFN0cmVhbWluZyA9IG5ldyBzdGFydFN0cmVhbWluZyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBzdG9wU3RyZWFtaW5nJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwic3RvcFN0cmVhbWluZ1wiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdG9wU3RyZWFtaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBzdG9wU3RyZWFtaW5nID0gbmV3IHN0b3BTdHJlYW1pbmckVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgcGxheWVyQ291bnQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJwbGF5ZXJDb3VudFwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwiY291bnRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuY291bnQgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiBjb3VudCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvdW50ID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBpbnQzMiBjb3VudCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNvdW50ICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UuY291bnQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgcGxheWVyQ291bnRcbiAqL1xuZXhwb3J0IGNvbnN0IHBsYXllckNvdW50ID0gbmV3IHBsYXllckNvdW50JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHN0YXRzJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwic3RhdHNcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcImRhdGFcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLmRhdGEgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgZGF0YSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBzdHJpbmcgZGF0YSA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmRhdGEgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdGF0c1xuICovXG5leHBvcnQgY29uc3Qgc3RhdHMgPSBuZXcgc3RhdHMkVHlwZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmFsbGluZ19tZXNzYWdlcy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0ICogYXMgTWVzc2FnZXMgZnJvbSAnLi4vTWVzc2FnZXMvc2lnbmFsbGluZ19tZXNzYWdlcyc7XG5pbXBvcnQgKiBhcyBNZXNzYWdlSGVscGVycyBmcm9tICcuLi9NZXNzYWdlcy9tZXNzYWdlX2hlbHBlcnMnO1xuLyoqXG4gKiBVc2VkIHRvIHJlZ3VsYXJseSBwaW5nIGEgcHJvdG9jb2wgY29ubmVjdGlvbiB0byBtYWtlIHN1cmUgdGhlIGNvbm5lY3Rpb24gaXMgc3RpbGwgZ29vZCBhbmQgb3Blbi5cbiAqIFdoZW4gdGhlIHBvbmcgZG9lc24ndCBjb21lIGluIHJlc3BvbnNlIHRvIGEgcGluZyBpbiB0aW1lIGEgY2FsbGJhY2sgaXMgZmlyZWQgdGhhdCBjYW4gYmUgaGFuZGVkXG4gKiBieSB0aGUgb3duZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBLZWVwYWxpdmVNb25pdG9yIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBSb3VuZCBUcmlwIFRpbWUgb2YgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgZ2V0IFJUVCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnR0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG1vbml0b3IgYW5kIHN0YXJ0cyB0aGUgcGluZyB0aW1lci4gSWYgYSBwb25nIGRvZXMgbm90IGNvbWUgYmFjayBieSB0aGUgdGltZSB3ZSB3YW50XG4gICAgICogdG8gc2VuZCBhIHNlY29uZCBwaW5nIHRoZW4gdGhlIGNvbm5lY3Rpb24gaXMgY29uc2lkZXJlZCBkZWFkIGFuZCB0aGUgb25UaW1lb3V0IGNhbGxiYWNrIGlzIGZpcmVkLlxuICAgICAqIEBwYXJhbSBwcm90b2NvbCAtIFRoZSBjb25uZWN0aW9uIHRoYXQgd2Ugd2FudCB0byBtb25pdG9yLlxuICAgICAqIEBwYXJhbSB0aW1lb3V0IC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGJldHdlZW4gcGluZyBtZXNzYWdlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm90b2NvbCwgdGltZW91dCkge1xuICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucnR0ID0gMDtcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICB0aGlzLm9uUmVzcG9uc2UgPSB0aGlzLm9uSGVhcnRiZWF0UmVzcG9uc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC50cmFuc3BvcnQub24oJ2Nsb3NlJywgdGhpcy5zdG9wLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLmFsaXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC5vbigncG9uZycsIHRoaXMub25SZXNwb25zZSk7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlID0gc2V0SW50ZXJ2YWwodGhpcy5zZW5kSGVhcnRiZWF0LmJpbmQodGhpcyksIHRoaXMudGltZW91dCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwYWxpdmUpO1xuICAgICAgICB0aGlzLnByb3RvY29sLm9mZigncG9uZycsIHRoaXMub25SZXNwb25zZSk7XG4gICAgfVxuICAgIHNlbmRIZWFydGJlYXQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gaWYgd2UgbmV2ZXIgZ290IGEgcmVzcG9uc2UgZnJvbSB0aGUgbGFzdCBoZWFydGJlYXQsIGFzc3VtZSB0aGUgY29ubmVjdGlvbiBpcyBkZWFkIGFuZCB0aW1lb3V0XG4gICAgICAgIGlmICh0aGlzLmFsaXZlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5vblRpbWVvdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1hcmsgdGhlIGNvbm5lY3Rpb24gYXMgdGVtcG9yYXJpbHkgZGVhZCB1bnRpbCB3ZSBnZXQgYSByZXNwb25zZSBmcm9tIHRoZSBwaW5nXG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC5zZW5kTWVzc2FnZShNZXNzYWdlSGVscGVycy5jcmVhdGVNZXNzYWdlKE1lc3NhZ2VzLnBpbmcsIHsgdGltZTogbmV3IERhdGUoKS5nZXRUaW1lKCkgfSkpO1xuICAgIH1cbiAgICBvbkhlYXJ0YmVhdFJlc3BvbnNlKHBvbmdNc2cpIHtcbiAgICAgICAgLy8gd2UgZ290IGEgcG9uZyByZXNwb25zZSBmcm9tIHRoZSBvdGhlciBzaWRlLCB0aGUgY29ubmVjdGlvbiBpcyBnb29kLlxuICAgICAgICAvLyB3ZSBhbHNvIHN0b3JlIHRoZSByb3VuZCB0cmlwIHRpbWUgaWYgYW55b25lIGlzIGN1cmlvdXNcbiAgICAgICAgdGhpcy5ydHQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHBvbmdNc2cudGltZTtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IHRydWU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9S2VlcGFsaXZlTW9uaXRvci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vRXZlbnQvRXZlbnRFbWl0dGVyJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL0xvZ2dlci9Mb2dnZXInO1xuLyoqXG4gKiBTaWduYWxsaW5nIHByb3RvY29sIGZvciBoYW5kbGluZyBtZXNzYWdlcyBmcm9tIHRoZSBzaWduYWxsaW5nIHNlcnZlci5cbiAqXG4gKiBMaXN0ZW4gb24gdGhpcyBlbWl0dGVyIGZvciBtZXNzYWdlcy4gTWVzc2FnZSB0eXBlIGlzIHRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yLlxuICogRXhhbXBsZTpcbiAqICAgICAgc2lnbmFsbGluZ1Byb3RvY29sLm9uKCdjb25maWcnLCAobWVzc2FnZTogTWVzc2FnZXMuY29uZmlnKSA9XFw+IGNvbnNvbGUubG9nKGBHb3QgYSBjb25maWcgbWVzc2FnZTogJHttZXNzYWdlfWApKSk7XG4gKlxuICogVGhlIHRyYW5zcG9ydCBpbiB0aGlzIGNsYXNzIHdpbGwgYWxzbyBlbWl0IG9uIG1lc3NhZ2UgZXZlbnRzLlxuICpcbiAqIEV2ZW50cyBlbWl0dGVkIG9uIHRyYW5zcG9ydDpcbiAqICAgbWVzc2FnZTpcbiAqICAgICAgRW1pdHRlZCBhbnkgdGltZSBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgYnkgdGhlIHRyYW5zcG9ydC4gTGlzdGVuIG9uIHRoaXMgaWZcbiAqICAgICAgeW91IHdpc2ggdG8gY2FwdHVyZSBhbGwgbWVzc2FnZXMsIHJhdGhlciB0aGFuIHNwZWNpZmljIG1lc3NhZ2VzIG9uXG4gKiAgICAgICdtZXNzYWdlSGFuZGxlcnMnLlxuICpcbiAqICAgb3V0OlxuICogICAgICBFbWl0dGVkIHdoZW4gc2VuZGluZyBhIG1lc3NhZ2Ugb3V0IG9uIHRoZSB0cmFuc3BvcnQuIFNpbWlsYXIgdG8gJ21lc3NhZ2UnIGJ1dFxuICogICAgICBvbmx5IGZvciB3aGVuIG1lc3NhZ2VzIGFyZSBzZW50IGZyb20gdGhpcyBlbmRwb2ludC4gVXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBTaWduYWxsaW5nUHJvdG9jb2wgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIHN0YXRpYyBnZXQgU0lHTkFMTElOR19WRVJTSU9OKCkge1xuICAgICAgICByZXR1cm4gJzEuMy4wJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICB0cmFuc3BvcnQub25NZXNzYWdlID0gKG1zZykgPT4ge1xuICAgICAgICAgICAgbGV0IHBhcnNlZE1lc3NhZ2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gSlNPTi5wYXJzZShtc2cpO1xuICAgICAgICAgICAgICAgIExvZ2dlci5EZWJ1ZygnUHJvdG9jb2wgcmVjZWl2ZWQgPT4gXFxuJyArIEpTT04uc3RyaW5naWZ5KHBhcnNlZERhdGEsIHVuZGVmaW5lZCwgNCkpO1xuICAgICAgICAgICAgICAgIHBhcnNlZE1lc3NhZ2UgPSBwYXJzZWREYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihgRXJyb3IgcGFyc2luZyBtZXNzYWdlIHN0cmluZyAke21zZ30uXFxuJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoYFVua25vd24gZXJyb3Igd2hpbGUgcGFyc2luZyBtZXNzYWdlIGRhdGEgaW4gaGFuZGxlT25NZXNzYWdlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNhbGwgdGhlIGhhbmRsZXJzXG4gICAgICAgICAgICB0cmFuc3BvcnQuZW1pdCgnbWVzc2FnZScsIHBhcnNlZE1lc3NhZ2UpOyAvLyBlbWl0IHRoaXMgZm9yIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYW55IG1lc3NhZ2VcbiAgICAgICAgICAgIGlmICghdGhpcy5lbWl0KHBhcnNlZE1lc3NhZ2UudHlwZSwgcGFyc2VkTWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBlbWl0IHRoaXMgZm9yIGxpc3RlbmVycyBsaXN0ZW5pbmcgZm9yIHNwZWNpZmljIG1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgLy8gbm8gbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd1bmhhbmRsZWQnLCBwYXJzZWRNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNrcyB0aGUgdHJhbnNwb3J0IHRvIGNvbm5lY3QgdG8gdGhlIGdpdmVuIFVSTC5cbiAgICAgKiBAcGFyYW0gdXJsIC0gVGhlIHVybCB0byBjb25uZWN0IHRvLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGNvbm5lY3Rpb24gY2FsbCBzdWNjZWVkZWQuXG4gICAgICovXG4gICAgY29ubmVjdCh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmNvbm5lY3QodXJsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNrcyB0aGUgdHJhbnNwb3J0IHRvIGRpc2Nvbm5lY3QgZnJvbSBhbnkgY29ubmVjdGlvbiBpdCBtaWdodCBoYXZlLlxuICAgICAqIEBwYXJhbSBjb2RlIC0gQW4gb3B0aW9uYWwgZGlzY29ubmVjdGlvbiBjb2RlLlxuICAgICAqIEBwYXJhbSByZWFzb24gLSBBbiBvcHRpb25hbCBkZXNjcmlwdGl2ZSBzdHJpbmcgZm9yIHRoZSBkaXNjb25uZWN0IHJlYXNvbi5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KGNvZGUsIHJlYXNvbikge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5kaXNjb25uZWN0KGNvZGUsIHJlYXNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZCBhbmQgcmVhZHkgdG8gc2VuZC9yZWNlaXZlIG1lc3NhZ2VzLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHByb3RvY29sIGlzIGNvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmlzQ29ubmVjdGVkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhc3NlcyBhIG1lc3NhZ2UgdG8gdGhlIHRyYW5zcG9ydCB0byBzZW5kIHRvIHRoZSBvdGhlciBlbmQuXG4gICAgICogQHBhcmFtIG1zZyAtIFRoZSBtZXNzYWdlIHRvIHNlbmQuXG4gICAgICovXG4gICAgc2VuZE1lc3NhZ2UobXNnKSB7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KG1zZykpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5lbWl0KCdvdXQnLCBtc2cpOyAvLyBlbWl0IHRoaXMgZm9yIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gb3V0Z29pbmcgbWVzc2FnZXNcbiAgICAgICAgTG9nZ2VyLkRlYnVnKCdQcm90b2NvbCBzZW50ID0+IFxcbicgKyBKU09OLnN0cmluZ2lmeShtc2csIHVuZGVmaW5lZCwgNCkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpZ25hbGxpbmdQcm90b2NvbC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vTG9nZ2VyL0xvZ2dlcic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9FdmVudC9FdmVudEVtaXR0ZXInO1xuLyoqXG4gKiBUaGUgY29udHJvbGxlciBmb3IgdGhlIFdlYlNvY2tldCBhbmQgYWxsIGFzc29jaWF0ZWQgbWV0aG9kc1xuICovXG5leHBvcnQgY2xhc3MgV2ViU29ja2V0VHJhbnNwb3J0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFdlYlNvY2tldFRyYW5zcG9ydCBmb3IgYnJvd3NlciBjb250ZXh0cy5cbiAgICAgKiBAcGFyYW0gcHJvdG9jb2xzIC0gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIGxpc3Qgb2Ygc3RyaW5ncyB0byBwYXNzIHRvIHRoZSBuZXcgd2Vic29ja2V0IHByb3RvY29scyBwYXJhbVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3RvY29scykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLldTX09QRU5fU1RBVEUgPSAxO1xuICAgICAgICB0aGlzLnByb3RvY29scyA9IHByb3RvY29scztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIG92ZXIgdGhlIHdlYnNvY2tldC5cbiAgICAgKiBAcGFyYW0gbXNnIC0gVGhlIG1lc3NhZ2UgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBzZW5kTWVzc2FnZShtc2cpIHtcbiAgICAgICAgaWYgKHRoaXMud2ViU29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldC5zZW5kKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byB0aGUgc2lnbmFsaW5nIHNlcnZlclxuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uVVJMIC0gVGhlIEFkZHJlc3Mgb2YgdGhlIHNpZ25hbGluZyBzZXJ2ZXJcbiAgICAgKiBAcmV0dXJucyBJZiB0aGVyZSBpcyBhIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBjb25uZWN0KGNvbm5lY3Rpb25VUkwpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oY29ubmVjdGlvblVSTCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldCA9IG5ldyBXZWJTb2NrZXQoY29ubmVjdGlvblVSTCwgdGhpcy5wcm90b2NvbHMpO1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQub25vcGVuID0gKF8pID0+IHRoaXMuaGFuZGxlT25PcGVuKCk7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldC5vbmVycm9yID0gKF8pID0+IHRoaXMuaGFuZGxlT25FcnJvcigpO1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQub25jbG9zZSA9IChldmVudCkgPT4gdGhpcy5oYW5kbGVPbkNsb3NlKGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0Lm9ubWVzc2FnZSA9IChldmVudCkgPT4gdGhpcy5oYW5kbGVPbk1lc3NhZ2UoZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQub25tZXNzYWdlYmluYXJ5ID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU9uTWVzc2FnZUJpbmFyeShldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCB0aGlzIHRyYW5zcG9ydC5cbiAgICAgKiBAcGFyYW0gY29kZSAtIEFuIG9wdGlvbmFsIGRpc2Nvbm5lY3QgY29kZS5cbiAgICAgKiBAcGFyYW0gcmVhc29uIC0gQSBkZXNjcmlwdGl2ZSBzdHJpbmcgZm9yIHRoZSBkaXNjb25uZWN0IHJlYXNvbi5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KGNvZGUsIHJlYXNvbikge1xuICAgICAgICBpZiAodGhpcy53ZWJTb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0LmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdWxkIHJldHVybiB0cnVlIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQgYW5kIHJlYWR5IHRvIHNlbmQvcmVjZWl2ZSBtZXNzYWdlcy5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB0cmFuc3BvcnQgaXMgY29ubmVjdGVkLlxuICAgICAqL1xuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLndlYlNvY2tldCAmJiB0aGlzLndlYlNvY2tldC5yZWFkeVN0YXRlICE9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hhdCBoYXBwZW5zIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkIGluIGJpbmFyeSBmb3JtXG4gICAgICogQHBhcmFtIGV2ZW50IC0gTWVzc2FnZSBSZWNlaXZlZFxuICAgICAqL1xuICAgIGhhbmRsZU9uTWVzc2FnZUJpbmFyeShldmVudCkge1xuICAgICAgICAvLyBpZiB0aGUgZXZlbnQgaXMgZW1wdHkgcmV0dXJuXG4gICAgICAgIGlmICghZXZlbnQgfHwgIWV2ZW50LmRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgdGhlIGJpbmFyeSBhbmQgdGhlbiBoYW5kbGUgdGhlIG1lc3NhZ2VcbiAgICAgICAgZXZlbnQuZGF0YVxuICAgICAgICAgICAgLnRleHQoKVxuICAgICAgICAgICAgLnRoZW4oKG1lc3NhZ2VTdHJpbmcpID0+IHtcbiAgICAgICAgICAgIC8vIGJ1aWxkIGEgbmV3IG1lc3NhZ2VcbiAgICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdGVkTWVzc2FnZSA9IG5ldyBNZXNzYWdlRXZlbnQoJ21lc3NhZ2VGcm9tQmluYXJ5Jywge1xuICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2VTdHJpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gc2VuZCB0aGUgbmV3IHN0cmluZ2lmaWVkIGV2ZW50IGJhY2sgaW50byBgb25tZXNzYWdlYFxuICAgICAgICAgICAgdGhpcy5oYW5kbGVPbk1lc3NhZ2UoY29uc3RydWN0ZWRNZXNzYWdlKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihgRmFpbGVkIHRvIHBhcnNlIGJpbmFyeSBibG9iIGZyb20gd2Vic29ja2V0LCByZWFzb246ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hhdCBoYXBwZW5zIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkXG4gICAgICogQHBhcmFtIGV2ZW50IC0gTWVzc2FnZSBSZWNlaXZlZFxuICAgICAqL1xuICAgIGhhbmRsZU9uTWVzc2FnZShldmVudCkge1xuICAgICAgICAvLyBDaGVjayBpZiB3ZWJzb2NrZXQgbWVzc2FnZSBpcyBiaW5hcnksIGlmIHNvLCBzdHJpbmdpZnkgaXQuXG4gICAgICAgIGlmIChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU9uTWVzc2FnZUJpbmFyeShldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub25NZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLm9uTWVzc2FnZShldmVudC5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gdGhlIFdlYnNvY2tldCBpcyBvcGVuZWRcbiAgICAgKi9cbiAgICBoYW5kbGVPbk9wZW4oKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCdDb25uZWN0ZWQgdG8gdGhlIHNpZ25hbGxpbmcgc2VydmVyIHZpYSBXZWJTb2NrZXQnKTtcbiAgICAgICAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hlbiB0aGVyZSBpcyBhbiBlcnJvciBvbiB0aGUgd2Vic29ja2V0XG4gICAgICovXG4gICAgaGFuZGxlT25FcnJvcigpIHtcbiAgICAgICAgLy9Mb2dnZXIuRXJyb3IoTG9nZ2VyLkdldFN0YWNrVHJhY2UoKSwgJ1dlYlNvY2tldCBlcnJvcicpO1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hlbiB0aGUgV2Vic29ja2V0IGlzIGNsb3NlZFxuICAgICAqIEBwYXJhbSBldmVudCAtIENsb3NlIEV2ZW50XG4gICAgICovXG4gICAgaGFuZGxlT25DbG9zZShldmVudCkge1xuICAgICAgICBMb2dnZXIuSW5mbygnRGlzY29ubmVjdGVkIHRvIHRoZSBzaWduYWxsaW5nIHNlcnZlciB2aWEgV2ViU29ja2V0OiAnICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGV2ZW50LmNvZGUpICtcbiAgICAgICAgICAgICcgLSAnICtcbiAgICAgICAgICAgIGV2ZW50LnJlYXNvbik7XG4gICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBldmVudCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2ViU29ja2V0VHJhbnNwb3J0LmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5leHBvcnQgY2xhc3MgU0RQVXRpbHMge1xuICAgIHN0YXRpYyBhZGRWaWRlb0hlYWRlckV4dGVuc2lvblRvU2RwKHNkcCwgdXJpKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGhpZ2hlc3QgdXNlZCBoZWFkZXIgZXh0ZW5zaW9uIGlkIGJ5IHNvcnRpbmcgdGhlIGV4dGVuc2lvbiBpZHMgdXNlZCxcbiAgICAgICAgLy8gZWxpbWluYXRpbmcgZHVwbGljYXRlcyBhbmQgYWRkaW5nIG9uZS5cbiAgICAgICAgLy8gVG9kbzogVXBkYXRlIHRoaXMgd2hlbiBXZWJSVEMgaW4gQ2hyb21lIHN1cHBvcnRzIHRoZSBoZWFkZXIgZXh0ZW5zaW9uIEFQSS5cbiAgICAgICAgY29uc3QgdXNlZElkcyA9IHNkcFxuICAgICAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAgICAgLmZpbHRlcigobGluZSkgPT4gbGluZS5zdGFydHNXaXRoKCdhPWV4dG1hcDonKSlcbiAgICAgICAgICAgIC5tYXAoKGxpbmUpID0+IHBhcnNlSW50KGxpbmUuc3BsaXQoJyAnKVswXS5zdWJzdHJpbmcoOSksIDEwKSlcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhIC0gYilcbiAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0sIGluZGV4LCBhcnJheSkgPT4gYXJyYXkuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXgpO1xuICAgICAgICBjb25zdCBuZXh0SWQgPSB1c2VkSWRzW3VzZWRJZHMubGVuZ3RoIC0gMV0gKyAxO1xuICAgICAgICBjb25zdCBleHRtYXBMaW5lID0gJ2E9ZXh0bWFwOicgKyBuZXh0SWQgKyAnICcgKyB1cmkgKyAnXFxyXFxuJztcbiAgICAgICAgY29uc3Qgc2VjdGlvbnMgPSBzZHAuc3BsaXQoJ1xcbm09JykubWFwKChwYXJ0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChpbmRleCA+IDAgPyAnbT0nICsgcGFydCA6IHBhcnQpLnRyaW0oKSArICdcXHJcXG4nO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2Vzc2lvblBhcnQgPSBzZWN0aW9ucy5zaGlmdCgpO1xuICAgICAgICAvLyBPbmx5IGFkZCBleHRlbnNpb24gdG8gbT12aWRlbyBtZWRpYSBzZWN0aW9uXG4gICAgICAgIHJldHVybiAoc2Vzc2lvblBhcnQgK1xuICAgICAgICAgICAgc2VjdGlvbnNcbiAgICAgICAgICAgICAgICAubWFwKChtZWRpYVNlY3Rpb24pID0+IG1lZGlhU2VjdGlvbi5zdGFydHNXaXRoKCdtPXZpZGVvJykgPyBtZWRpYVNlY3Rpb24gKyBleHRtYXBMaW5lIDogbWVkaWFTZWN0aW9uKVxuICAgICAgICAgICAgICAgIC5qb2luKCcnKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2RwVXRpbHMuanMubWFwIiwiLyoqXG4gKiBhc3NlcnQgdGhhdCBjb25kaXRpb24gaXMgdHJ1ZSBvciB0aHJvdyBlcnJvciAod2l0aCBtZXNzYWdlKVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuLyoqXG4gKiBhc3NlcnQgdGhhdCB2YWx1ZSBjYW5ub3QgZXhpc3QgPSB0eXBlIGBuZXZlcmAuIHRocm93IHJ1bnRpbWUgZXJyb3IgaWYgaXQgZG9lcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5ldmVyKHZhbHVlLCBtc2cpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnICE9PSBudWxsICYmIG1zZyAhPT0gdm9pZCAwID8gbXNnIDogJ1VuZXhwZWN0ZWQgb2JqZWN0OiAnICsgdmFsdWUpO1xufVxuY29uc3QgRkxPQVQzMl9NQVggPSAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCBGTE9BVDMyX01JTiA9IC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCBVSU5UMzJfTUFYID0gMHhGRkZGRkZGRiwgSU5UMzJfTUFYID0gMFg3RkZGRkZGRiwgSU5UMzJfTUlOID0gLTBYODAwMDAwMDA7XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SW50MzIoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnQgMzI6ICcgKyB0eXBlb2YgYXJnKTtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJnKSB8fCBhcmcgPiBJTlQzMl9NQVggfHwgYXJnIDwgSU5UMzJfTUlOKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW50IDMyOiAnICsgYXJnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRVSW50MzIoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB1aW50IDMyOiAnICsgdHlwZW9mIGFyZyk7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGFyZykgfHwgYXJnID4gVUlOVDMyX01BWCB8fCBhcmcgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdWludCAzMjogJyArIGFyZyk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RmxvYXQzMihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZsb2F0IDMyOiAnICsgdHlwZW9mIGFyZyk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYXJnKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChhcmcgPiBGTE9BVDMyX01BWCB8fCBhcmcgPCBGTE9BVDMyX01JTilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZsb2F0IDMyOiAnICsgYXJnKTtcbn1cbiIsIi8vIGxvb2t1cCB0YWJsZSBmcm9tIGJhc2U2NCBjaGFyYWN0ZXIgdG8gYnl0ZVxubGV0IGVuY1RhYmxlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcbi8vIGxvb2t1cCB0YWJsZSBmcm9tIGJhc2U2NCBjaGFyYWN0ZXIgKmNvZGUqIHRvIGJ5dGUgYmVjYXVzZSBsb29rdXAgYnkgbnVtYmVyIGlzIGZhc3RcbmxldCBkZWNUYWJsZSA9IFtdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNUYWJsZS5sZW5ndGg7IGkrKylcbiAgICBkZWNUYWJsZVtlbmNUYWJsZVtpXS5jaGFyQ29kZUF0KDApXSA9IGk7XG4vLyBzdXBwb3J0IGJhc2U2NHVybCB2YXJpYW50c1xuZGVjVGFibGVbXCItXCIuY2hhckNvZGVBdCgwKV0gPSBlbmNUYWJsZS5pbmRleE9mKFwiK1wiKTtcbmRlY1RhYmxlW1wiX1wiLmNoYXJDb2RlQXQoMCldID0gZW5jVGFibGUuaW5kZXhPZihcIi9cIik7XG4vKipcbiAqIERlY29kZXMgYSBiYXNlNjQgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheS5cbiAqXG4gKiAtIGlnbm9yZXMgd2hpdGUtc3BhY2UsIGluY2x1ZGluZyBsaW5lIGJyZWFrcyBhbmQgdGFic1xuICogLSBhbGxvd3MgaW5uZXIgcGFkZGluZyAoY2FuIGRlY29kZSBjb25jYXRlbmF0ZWQgYmFzZTY0IHN0cmluZ3MpXG4gKiAtIGRvZXMgbm90IHJlcXVpcmUgcGFkZGluZ1xuICogLSB1bmRlcnN0YW5kcyBiYXNlNjR1cmwgZW5jb2Rpbmc6XG4gKiAgIFwiLVwiIGluc3RlYWQgb2YgXCIrXCIsXG4gKiAgIFwiX1wiIGluc3RlYWQgb2YgXCIvXCIsXG4gKiAgIG5vIHBhZGRpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NGRlY29kZShiYXNlNjRTdHIpIHtcbiAgICAvLyBlc3RpbWF0ZSBieXRlIHNpemUsIG5vdCBhY2NvdW50aW5nIGZvciBpbm5lciBwYWRkaW5nIGFuZCB3aGl0ZXNwYWNlXG4gICAgbGV0IGVzID0gYmFzZTY0U3RyLmxlbmd0aCAqIDMgLyA0O1xuICAgIC8vIGlmIChlcyAlIDMgIT09IDApXG4gICAgLy8gdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJhc2U2NCBzdHJpbmcnKTtcbiAgICBpZiAoYmFzZTY0U3RyW2Jhc2U2NFN0ci5sZW5ndGggLSAyXSA9PSAnPScpXG4gICAgICAgIGVzIC09IDI7XG4gICAgZWxzZSBpZiAoYmFzZTY0U3RyW2Jhc2U2NFN0ci5sZW5ndGggLSAxXSA9PSAnPScpXG4gICAgICAgIGVzIC09IDE7XG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZXMpLCBieXRlUG9zID0gMCwgLy8gcG9zaXRpb24gaW4gYnl0ZSBhcnJheVxuICAgIGdyb3VwUG9zID0gMCwgLy8gcG9zaXRpb24gaW4gYmFzZTY0IGdyb3VwXG4gICAgYiwgLy8gY3VycmVudCBieXRlXG4gICAgcCA9IDAgLy8gcHJldmlvdXMgYnl0ZVxuICAgIDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2U2NFN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBiID0gZGVjVGFibGVbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSldO1xuICAgICAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gRmFsbFRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgICAgICAgICBzd2l0Y2ggKGJhc2U2NFN0cltpXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgICAgICAgICBncm91cFBvcyA9IDA7IC8vIHJlc2V0IHN0YXRlIHdoZW4gcGFkZGluZyBmb3VuZFxuICAgICAgICAgICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgICAgICAgY2FzZSAnXFxyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCB3aGl0ZS1zcGFjZSwgYW5kIHBhZGRpbmdcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgaW52YWxpZCBiYXNlNjQgc3RyaW5nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZ3JvdXBQb3MpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBwID0gYjtcbiAgICAgICAgICAgICAgICBncm91cFBvcyA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYnl0ZXNbYnl0ZVBvcysrXSA9IHAgPDwgMiB8IChiICYgNDgpID4+IDQ7XG4gICAgICAgICAgICAgICAgcCA9IGI7XG4gICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGJ5dGVzW2J5dGVQb3MrK10gPSAocCAmIDE1KSA8PCA0IHwgKGIgJiA2MCkgPj4gMjtcbiAgICAgICAgICAgICAgICBwID0gYjtcbiAgICAgICAgICAgICAgICBncm91cFBvcyA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgYnl0ZXNbYnl0ZVBvcysrXSA9IChwICYgMykgPDwgNiB8IGI7XG4gICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChncm91cFBvcyA9PSAxKVxuICAgICAgICB0aHJvdyBFcnJvcihgaW52YWxpZCBiYXNlNjQgc3RyaW5nLmApO1xuICAgIHJldHVybiBieXRlcy5zdWJhcnJheSgwLCBieXRlUG9zKTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIGJ5dGUgYXJyYXkgdG8gYSBiYXNlNjQgc3RyaW5nLlxuICogQWRkcyBwYWRkaW5nIGF0IHRoZSBlbmQuXG4gKiBEb2VzIG5vdCBpbnNlcnQgbmV3bGluZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRlbmNvZGUoYnl0ZXMpIHtcbiAgICBsZXQgYmFzZTY0ID0gJycsIGdyb3VwUG9zID0gMCwgLy8gcG9zaXRpb24gaW4gYmFzZTY0IGdyb3VwXG4gICAgYiwgLy8gY3VycmVudCBieXRlXG4gICAgcCA9IDA7IC8vIGNhcnJ5IG92ZXIgZnJvbSBwcmV2aW91cyBieXRlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBiID0gYnl0ZXNbaV07XG4gICAgICAgIHN3aXRjaCAoZ3JvdXBQb3MpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbYiA+PiAyXTtcbiAgICAgICAgICAgICAgICBwID0gKGIgJiAzKSA8PCA0O1xuICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcCB8IGIgPj4gNF07XG4gICAgICAgICAgICAgICAgcCA9IChiICYgMTUpIDw8IDI7XG4gICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtwIHwgYiA+PiA2XTtcbiAgICAgICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbYiAmIDYzXTtcbiAgICAgICAgICAgICAgICBncm91cFBvcyA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcGFkZGluZyByZXF1aXJlZD9cbiAgICBpZiAoZ3JvdXBQb3MpIHtcbiAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW3BdO1xuICAgICAgICBiYXNlNjQgKz0gJz0nO1xuICAgICAgICBpZiAoZ3JvdXBQb3MgPT0gMSlcbiAgICAgICAgICAgIGJhc2U2NCArPSAnPSc7XG4gICAgfVxuICAgIHJldHVybiBiYXNlNjQ7XG59XG4iLCIvKipcbiAqIFRoaXMgaGFuZGxlciBpbXBsZW1lbnRzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBmb3IgdW5rbm93biBmaWVsZHMuXG4gKiBXaGVuIHJlYWRpbmcgZGF0YSwgdW5rbm93biBmaWVsZHMgYXJlIHN0b3JlZCBvbiB0aGUgbWVzc2FnZSwgaW4gYVxuICogc3ltYm9sIHByb3BlcnR5LlxuICogV2hlbiB3cml0aW5nIGRhdGEsIHRoZSBzeW1ib2wgcHJvcGVydHkgaXMgcXVlcmllZCBhbmQgdW5rbm93biBmaWVsZHNcbiAqIGFyZSBzZXJpYWxpemVkIGludG8gdGhlIG91dHB1dCBhZ2Fpbi5cbiAqL1xuZXhwb3J0IHZhciBVbmtub3duRmllbGRIYW5kbGVyO1xuKGZ1bmN0aW9uIChVbmtub3duRmllbGRIYW5kbGVyKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHN5bWJvbCB1c2VkIHRvIHN0b3JlIHVua25vd24gZmllbGRzIGZvciBhIG1lc3NhZ2UuXG4gICAgICogVGhlIHByb3BlcnR5IG11c3QgY29uZm9ybSB0byBgVW5rbm93bkZpZWxkQ29udGFpbmVyYC5cbiAgICAgKi9cbiAgICBVbmtub3duRmllbGRIYW5kbGVyLnN5bWJvbCA9IFN5bWJvbC5mb3IoXCJwcm90b2J1Zi10cy91bmtub3duXCIpO1xuICAgIC8qKlxuICAgICAqIFN0b3JlIGFuIHVua25vd24gZmllbGQgZHVyaW5nIGJpbmFyeSByZWFkIGRpcmVjdGx5IG9uIHRoZSBtZXNzYWdlLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvbXBhdGlibGUgd2l0aCBgQmluYXJ5UmVhZE9wdGlvbnMucmVhZFVua25vd25GaWVsZGAuXG4gICAgICovXG4gICAgVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgPSAodHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkYXRhKSA9PiB7XG4gICAgICAgIGxldCBjb250YWluZXIgPSBpcyhtZXNzYWdlKSA/IG1lc3NhZ2VbVW5rbm93bkZpZWxkSGFuZGxlci5zeW1ib2xdIDogbWVzc2FnZVtVbmtub3duRmllbGRIYW5kbGVyLnN5bWJvbF0gPSBbXTtcbiAgICAgICAgY29udGFpbmVyLnB1c2goeyBubzogZmllbGRObywgd2lyZVR5cGUsIGRhdGEgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZSB1bmtub3duIGZpZWxkcyBzdG9yZWQgZm9yIHRoZSBtZXNzYWdlIHRvIHRoZSB3cml0ZXIuXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29tcGF0aWJsZSB3aXRoIGBCaW5hcnlXcml0ZU9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzYC5cbiAgICAgKi9cbiAgICBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgPSAodHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcikgPT4ge1xuICAgICAgICBmb3IgKGxldCB7IG5vLCB3aXJlVHlwZSwgZGF0YSB9IG9mIFVua25vd25GaWVsZEhhbmRsZXIubGlzdChtZXNzYWdlKSlcbiAgICAgICAgICAgIHdyaXRlci50YWcobm8sIHdpcmVUeXBlKS5yYXcoZGF0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMaXN0IHVua25vd24gZmllbGRzIHN0b3JlZCBmb3IgdGhlIG1lc3NhZ2UuXG4gICAgICogTm90ZSB0aGF0IHRoZXJlIG1heSBiZSBtdWx0aXBsZXMgZmllbGRzIHdpdGggdGhlIHNhbWUgbnVtYmVyLlxuICAgICAqL1xuICAgIFVua25vd25GaWVsZEhhbmRsZXIubGlzdCA9IChtZXNzYWdlLCBmaWVsZE5vKSA9PiB7XG4gICAgICAgIGlmIChpcyhtZXNzYWdlKSkge1xuICAgICAgICAgICAgbGV0IGFsbCA9IG1lc3NhZ2VbVW5rbm93bkZpZWxkSGFuZGxlci5zeW1ib2xdO1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkTm8gPyBhbGwuZmlsdGVyKHVmID0+IHVmLm5vID09IGZpZWxkTm8pIDogYWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhc3QgdW5rbm93biBmaWVsZCBieSBmaWVsZCBudW1iZXIuXG4gICAgICovXG4gICAgVW5rbm93bkZpZWxkSGFuZGxlci5sYXN0ID0gKG1lc3NhZ2UsIGZpZWxkTm8pID0+IFVua25vd25GaWVsZEhhbmRsZXIubGlzdChtZXNzYWdlLCBmaWVsZE5vKS5zbGljZSgtMSlbMF07XG4gICAgY29uc3QgaXMgPSAobWVzc2FnZSkgPT4gbWVzc2FnZSAmJiBBcnJheS5pc0FycmF5KG1lc3NhZ2VbVW5rbm93bkZpZWxkSGFuZGxlci5zeW1ib2xdKTtcbn0pKFVua25vd25GaWVsZEhhbmRsZXIgfHwgKFVua25vd25GaWVsZEhhbmRsZXIgPSB7fSkpO1xuLyoqXG4gKiBNZXJnZXMgYmluYXJ5IHdyaXRlIG9yIHJlYWQgb3B0aW9ucy4gTGF0ZXIgdmFsdWVzIG92ZXJyaWRlIGVhcmxpZXIgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VCaW5hcnlPcHRpb25zKGEsIGIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhKSwgYik7XG59XG4vKipcbiAqIFByb3RvYnVmIGJpbmFyeSBmb3JtYXQgd2lyZSB0eXBlcy5cbiAqXG4gKiBBIHdpcmUgdHlwZSBwcm92aWRlcyBqdXN0IGVub3VnaCBpbmZvcm1hdGlvbiB0byBmaW5kIHRoZSBsZW5ndGggb2YgdGhlXG4gKiBmb2xsb3dpbmcgdmFsdWUuXG4gKlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9lbmNvZGluZyNzdHJ1Y3R1cmVcbiAqL1xuZXhwb3J0IHZhciBXaXJlVHlwZTtcbihmdW5jdGlvbiAoV2lyZVR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBpbnQzMiwgaW50NjQsIHVpbnQzMiwgdWludDY0LCBzaW50MzIsIHNpbnQ2NCwgYm9vbCwgZW51bVxuICAgICAqL1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiVmFyaW50XCJdID0gMF0gPSBcIlZhcmludFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGZpeGVkNjQsIHNmaXhlZDY0LCBkb3VibGUuXG4gICAgICogQWx3YXlzIDggYnl0ZXMgd2l0aCBsaXR0bGUtZW5kaWFuIGJ5dGUgb3JkZXIuXG4gICAgICovXG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJCaXQ2NFwiXSA9IDFdID0gXCJCaXQ2NFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIHN0cmluZywgYnl0ZXMsIGVtYmVkZGVkIG1lc3NhZ2VzLCBwYWNrZWQgcmVwZWF0ZWQgZmllbGRzXG4gICAgICpcbiAgICAgKiBPbmx5IHJlcGVhdGVkIG51bWVyaWMgdHlwZXMgKHR5cGVzIHdoaWNoIHVzZSB0aGUgdmFyaW50LCAzMi1iaXQsXG4gICAgICogb3IgNjQtYml0IHdpcmUgdHlwZXMpIGNhbiBiZSBwYWNrZWQuIEluIHByb3RvMywgc3VjaCBmaWVsZHMgYXJlXG4gICAgICogcGFja2VkIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJMZW5ndGhEZWxpbWl0ZWRcIl0gPSAyXSA9IFwiTGVuZ3RoRGVsaW1pdGVkXCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgZ3JvdXBzXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIlN0YXJ0R3JvdXBcIl0gPSAzXSA9IFwiU3RhcnRHcm91cFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGdyb3Vwc1xuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJFbmRHcm91cFwiXSA9IDRdID0gXCJFbmRHcm91cFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGZpeGVkMzIsIHNmaXhlZDMyLCBmbG9hdC5cbiAgICAgKiBBbHdheXMgNCBieXRlcyB3aXRoIGxpdHRsZS1lbmRpYW4gYnl0ZSBvcmRlci5cbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIkJpdDMyXCJdID0gNV0gPSBcIkJpdDMyXCI7XG59KShXaXJlVHlwZSB8fCAoV2lyZVR5cGUgPSB7fSkpO1xuIiwiaW1wb3J0IHsgV2lyZVR5cGUgfSBmcm9tIFwiLi9iaW5hcnktZm9ybWF0LWNvbnRyYWN0XCI7XG5pbXBvcnQgeyBQYkxvbmcsIFBiVUxvbmcgfSBmcm9tIFwiLi9wYi1sb25nXCI7XG5pbXBvcnQgeyB2YXJpbnQzMnJlYWQsIHZhcmludDY0cmVhZCB9IGZyb20gXCIuL2dvb2ctdmFyaW50XCI7XG5jb25zdCBkZWZhdWx0c1JlYWQgPSB7XG4gICAgcmVhZFVua25vd25GaWVsZDogdHJ1ZSxcbiAgICByZWFkZXJGYWN0b3J5OiBieXRlcyA9PiBuZXcgQmluYXJ5UmVhZGVyKGJ5dGVzKSxcbn07XG4vKipcbiAqIE1ha2Ugb3B0aW9ucyBmb3IgcmVhZGluZyBiaW5hcnkgZGF0YSBmb3JtIHBhcnRpYWwgb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVJlYWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHNSZWFkKSwgb3B0aW9ucykgOiBkZWZhdWx0c1JlYWQ7XG59XG5leHBvcnQgY2xhc3MgQmluYXJ5UmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihidWYsIHRleHREZWNvZGVyKSB7XG4gICAgICAgIHRoaXMudmFyaW50NjQgPSB2YXJpbnQ2NHJlYWQ7IC8vIGRpcnR5IGNhc3QgZm9yIGB0aGlzYFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVhZCBhIGB1aW50MzJgIGZpZWxkLCBhbiB1bnNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51aW50MzIgPSB2YXJpbnQzMnJlYWQ7IC8vIGRpcnR5IGNhc3QgZm9yIGB0aGlzYCBhbmQgYWNjZXNzIHRvIHByb3RlY3RlZCBgYnVmYFxuICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICAgICAgdGhpcy5sZW4gPSBidWYubGVuZ3RoO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyhidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLnRleHREZWNvZGVyID0gdGV4dERlY29kZXIgIT09IG51bGwgJiYgdGV4dERlY29kZXIgIT09IHZvaWQgMCA/IHRleHREZWNvZGVyIDogbmV3IFRleHREZWNvZGVyKFwidXRmLThcIiwge1xuICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICBpZ25vcmVCT006IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIHRhZyAtIGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlLlxuICAgICAqL1xuICAgIHRhZygpIHtcbiAgICAgICAgbGV0IHRhZyA9IHRoaXMudWludDMyKCksIGZpZWxkTm8gPSB0YWcgPj4+IDMsIHdpcmVUeXBlID0gdGFnICYgNztcbiAgICAgICAgaWYgKGZpZWxkTm8gPD0gMCB8fCB3aXJlVHlwZSA8IDAgfHwgd2lyZVR5cGUgPiA1KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0YWc6IGZpZWxkIG5vIFwiICsgZmllbGRObyArIFwiIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlKTtcbiAgICAgICAgcmV0dXJuIFtmaWVsZE5vLCB3aXJlVHlwZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNraXAgb25lIGVsZW1lbnQgb24gdGhlIHdpcmUgYW5kIHJldHVybiB0aGUgc2tpcHBlZCBkYXRhLlxuICAgICAqIFN1cHBvcnRzIFdpcmVUeXBlLlN0YXJ0R3JvdXAgc2luY2UgdjIuMC4wLWFscGhhLjIzLlxuICAgICAqL1xuICAgIHNraXAod2lyZVR5cGUpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBGYWxsVGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICAgICAgc3dpdGNoICh3aXJlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBXaXJlVHlwZS5WYXJpbnQ6XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLkJpdDY0OlxuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLkJpdDMyOlxuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDpcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gdGhpcy51aW50MzIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSBsZW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLlN0YXJ0R3JvdXA6XG4gICAgICAgICAgICAgICAgLy8gRnJvbSBkZXNjcmlwdG9yLnByb3RvOiBHcm91cCB0eXBlIGlzIGRlcHJlY2F0ZWQsIG5vdCBzdXBwb3J0ZWQgaW4gcHJvdG8zLlxuICAgICAgICAgICAgICAgIC8vIEJ1dCB3ZSBtdXN0IHN0aWxsIGJlIGFibGUgdG8gcGFyc2UgYW5kIHRyZWF0IGFzIHVua25vd24uXG4gICAgICAgICAgICAgICAgbGV0IHQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCh0ID0gdGhpcy50YWcoKVsxXSkgIT09IFdpcmVUeXBlLkVuZEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcCh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbnQgc2tpcCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnN1YmFycmF5KHN0YXJ0LCB0aGlzLnBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRocm93cyBlcnJvciBpZiBwb3NpdGlvbiBpbiBieXRlIGFycmF5IGlzIG91dCBvZiByYW5nZS5cbiAgICAgKi9cbiAgICBhc3NlcnRCb3VuZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA+IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJwcmVtYXR1cmUgRU9GXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGludDMyYCBmaWVsZCwgYSBzaWduZWQgMzIgYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBpbnQzMigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDMyKCkgfCAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHNpbnQzMmAgZmllbGQsIGEgc2lnbmVkLCB6aWd6YWctZW5jb2RlZCAzMi1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHNpbnQzMigpIHtcbiAgICAgICAgbGV0IHp6ZSA9IHRoaXMudWludDMyKCk7XG4gICAgICAgIC8vIGRlY29kZSB6aWd6YWdcbiAgICAgICAgcmV0dXJuICh6emUgPj4+IDEpIF4gLSh6emUgJiAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBpbnQ2NGAgZmllbGQsIGEgc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgaW50NjQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGJMb25nKC4uLnRoaXMudmFyaW50NjQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgdWludDY0YCBmaWVsZCwgYW4gdW5zaWduZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICB1aW50NjQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGJVTG9uZyguLi50aGlzLnZhcmludDY0KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHNpbnQ2NGAgZmllbGQsIGEgc2lnbmVkLCB6aWctemFnLWVuY29kZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBzaW50NjQoKSB7XG4gICAgICAgIGxldCBbbG8sIGhpXSA9IHRoaXMudmFyaW50NjQoKTtcbiAgICAgICAgLy8gZGVjb2RlIHppZyB6YWdcbiAgICAgICAgbGV0IHMgPSAtKGxvICYgMSk7XG4gICAgICAgIGxvID0gKChsbyA+Pj4gMSB8IChoaSAmIDEpIDw8IDMxKSBeIHMpO1xuICAgICAgICBoaSA9IChoaSA+Pj4gMSBeIHMpO1xuICAgICAgICByZXR1cm4gbmV3IFBiTG9uZyhsbywgaGkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGJvb2xgIGZpZWxkLCBhIHZhcmlhbnQuXG4gICAgICovXG4gICAgYm9vbCgpIHtcbiAgICAgICAgbGV0IFtsbywgaGldID0gdGhpcy52YXJpbnQ2NCgpO1xuICAgICAgICByZXR1cm4gbG8gIT09IDAgfHwgaGkgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgZml4ZWQzMmAgZmllbGQsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgZml4ZWQzMigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRVaW50MzIoKHRoaXMucG9zICs9IDQpIC0gNCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgc2ZpeGVkMzJgIGZpZWxkLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIHNmaXhlZDMyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldEludDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGZpeGVkNjRgIGZpZWxkLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0IGJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGZpeGVkNjQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGJVTG9uZyh0aGlzLnNmaXhlZDMyKCksIHRoaXMuc2ZpeGVkMzIoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgZml4ZWQ2NGAgZmllbGQsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQtYml0IGludGVnZXIuXG4gICAgICovXG4gICAgc2ZpeGVkNjQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGJMb25nKHRoaXMuc2ZpeGVkMzIoKSwgdGhpcy5zZml4ZWQzMigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBmbG9hdGAgZmllbGQsIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAgICovXG4gICAgZmxvYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0RmxvYXQzMigodGhpcy5wb3MgKz0gNCkgLSA0LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBkb3VibGVgIGZpZWxkLCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAgICovXG4gICAgZG91YmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldEZsb2F0NjQoKHRoaXMucG9zICs9IDgpIC0gOCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgYnl0ZXNgIGZpZWxkLCBsZW5ndGgtZGVsaW1pdGVkIGFyYml0cmFyeSBkYXRhLlxuICAgICAqL1xuICAgIGJ5dGVzKCkge1xuICAgICAgICBsZXQgbGVuID0gdGhpcy51aW50MzIoKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgc3RyaW5nYCBmaWVsZCwgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGNvbnZlcnRlZCB0byBVVEYtOCB0ZXh0LlxuICAgICAqL1xuICAgIHN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dERlY29kZXIuZGVjb2RlKHRoaXMuYnl0ZXMoKSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgUGJMb25nLCBQYlVMb25nIH0gZnJvbSBcIi4vcGItbG9uZ1wiO1xuaW1wb3J0IHsgdmFyaW50MzJ3cml0ZSwgdmFyaW50NjR3cml0ZSB9IGZyb20gXCIuL2dvb2ctdmFyaW50XCI7XG5pbXBvcnQgeyBhc3NlcnRGbG9hdDMyLCBhc3NlcnRJbnQzMiwgYXNzZXJ0VUludDMyIH0gZnJvbSBcIi4vYXNzZXJ0XCI7XG5jb25zdCBkZWZhdWx0c1dyaXRlID0ge1xuICAgIHdyaXRlVW5rbm93bkZpZWxkczogdHJ1ZSxcbiAgICB3cml0ZXJGYWN0b3J5OiAoKSA9PiBuZXcgQmluYXJ5V3JpdGVyKCksXG59O1xuLyoqXG4gKiBNYWtlIG9wdGlvbnMgZm9yIHdyaXRpbmcgYmluYXJ5IGRhdGEgZm9ybSBwYXJ0aWFsIG9wdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlXcml0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0c1dyaXRlKSwgb3B0aW9ucykgOiBkZWZhdWx0c1dyaXRlO1xufVxuZXhwb3J0IGNsYXNzIEJpbmFyeVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IodGV4dEVuY29kZXIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByZXZpb3VzIGZvcmsgc3RhdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICB0aGlzLnRleHRFbmNvZGVyID0gdGV4dEVuY29kZXIgIT09IG51bGwgJiYgdGV4dEVuY29kZXIgIT09IHZvaWQgMCA/IHRleHRFbmNvZGVyIDogbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuYnVmID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbGwgYnl0ZXMgd3JpdHRlbiBhbmQgcmVzZXQgdGhpcyB3cml0ZXIuXG4gICAgICovXG4gICAgZmluaXNoKCkge1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKG5ldyBVaW50OEFycmF5KHRoaXMuYnVmKSk7IC8vIGZsdXNoIHRoZSBidWZmZXJcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBsZW4gKz0gdGhpcy5jaHVua3NbaV0ubGVuZ3RoO1xuICAgICAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnl0ZXMuc2V0KHRoaXMuY2h1bmtzW2ldLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRoaXMuY2h1bmtzW2ldLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGEgbmV3IGZvcmsgZm9yIGxlbmd0aC1kZWxpbWl0ZWQgZGF0YSBsaWtlIGEgbWVzc2FnZVxuICAgICAqIG9yIGEgcGFja2VkIHJlcGVhdGVkIGZpZWxkLlxuICAgICAqXG4gICAgICogTXVzdCBiZSBqb2luZWQgbGF0ZXIgd2l0aCBgam9pbigpYC5cbiAgICAgKi9cbiAgICBmb3JrKCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2goeyBjaHVua3M6IHRoaXMuY2h1bmtzLCBidWY6IHRoaXMuYnVmIH0pO1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZiA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSm9pbiB0aGUgbGFzdCBmb3JrLiBXcml0ZSBpdHMgbGVuZ3RoIGFuZCBieXRlcywgdGhlblxuICAgICAqIHJldHVybiB0byB0aGUgcHJldmlvdXMgc3RhdGUuXG4gICAgICovXG4gICAgam9pbigpIHtcbiAgICAgICAgLy8gZ2V0IGNodW5rIG9mIGZvcmtcbiAgICAgICAgbGV0IGNodW5rID0gdGhpcy5maW5pc2goKTtcbiAgICAgICAgLy8gcmVzdG9yZSBwcmV2aW91cyBzdGF0ZVxuICAgICAgICBsZXQgcHJldiA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIGlmICghcHJldilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZSwgZm9yayBzdGFjayBlbXB0eScpO1xuICAgICAgICB0aGlzLmNodW5rcyA9IHByZXYuY2h1bmtzO1xuICAgICAgICB0aGlzLmJ1ZiA9IHByZXYuYnVmO1xuICAgICAgICAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgICAgIHRoaXMudWludDMyKGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSB0YWcgKGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlKS5cbiAgICAgKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gYHVpbnQzMiggKGZpZWxkTm8gPDwgMyB8IHR5cGUpID4+PiAwIClgLlxuICAgICAqXG4gICAgICogR2VuZXJhdGVkIGNvZGUgc2hvdWxkIGNvbXB1dGUgdGhlIHRhZyBhaGVhZCBvZiB0aW1lIGFuZCBjYWxsIGB1aW50MzIoKWAuXG4gICAgICovXG4gICAgdGFnKGZpZWxkTm8sIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDMyKChmaWVsZE5vIDw8IDMgfCB0eXBlKSA+Pj4gMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgY2h1bmsgb2YgcmF3IGJ5dGVzLlxuICAgICAqL1xuICAgIHJhdyhjaHVuaykge1xuICAgICAgICBpZiAodGhpcy5idWYubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKG5ldyBVaW50OEFycmF5KHRoaXMuYnVmKSk7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgdWludDMyYCB2YWx1ZSwgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cbiAgICAgKi9cbiAgICB1aW50MzIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0VUludDMyKHZhbHVlKTtcbiAgICAgICAgLy8gd3JpdGUgdmFsdWUgYXMgdmFyaW50IDMyLCBpbmxpbmVkIGZvciBzcGVlZFxuICAgICAgICB3aGlsZSAodmFsdWUgPiAweDdmKSB7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5wdXNoKCh2YWx1ZSAmIDB4N2YpIHwgMHg4MCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgaW50MzJgIHZhbHVlLCBhIHNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgICAqL1xuICAgIGludDMyKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEludDMyKHZhbHVlKTtcbiAgICAgICAgdmFyaW50MzJ3cml0ZSh2YWx1ZSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgYm9vbGAgdmFsdWUsIGEgdmFyaWFudC5cbiAgICAgKi9cbiAgICBib29sKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnVmLnB1c2godmFsdWUgPyAxIDogMCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBieXRlc2AgdmFsdWUsIGxlbmd0aC1kZWxpbWl0ZWQgYXJiaXRyYXJ5IGRhdGEuXG4gICAgICovXG4gICAgYnl0ZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy51aW50MzIodmFsdWUuYnl0ZUxlbmd0aCk7IC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgc3RyaW5nYCB2YWx1ZSwgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGNvbnZlcnRlZCB0byBVVEYtOCB0ZXh0LlxuICAgICAqL1xuICAgIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2h1bmsgPSB0aGlzLnRleHRFbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMudWludDMyKGNodW5rLmJ5dGVMZW5ndGgpOyAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGZsb2F0YCB2YWx1ZSwgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAgKi9cbiAgICBmbG9hdCh2YWx1ZSkge1xuICAgICAgICBhc3NlcnRGbG9hdDMyKHZhbHVlKTtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEZsb2F0MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBkb3VibGVgIHZhbHVlLCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAgICovXG4gICAgZG91YmxlKHZhbHVlKSB7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRGbG9hdDY0KDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgZml4ZWQzMmAgdmFsdWUsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgZml4ZWQzMih2YWx1ZSkge1xuICAgICAgICBhc3NlcnRVSW50MzIodmFsdWUpO1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0VWludDMyKDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgc2ZpeGVkMzJgIHZhbHVlLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIHNmaXhlZDMyKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEludDMyKHZhbHVlKTtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEludDMyKDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgc2ludDMyYCB2YWx1ZSwgYSBzaWduZWQsIHppZ3phZy1lbmNvZGVkIDMyLWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgc2ludDMyKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEludDMyKHZhbHVlKTtcbiAgICAgICAgLy8gemlnemFnIGVuY29kZVxuICAgICAgICB2YWx1ZSA9ICgodmFsdWUgPDwgMSkgXiAodmFsdWUgPj4gMzEpKSA+Pj4gMDtcbiAgICAgICAgdmFyaW50MzJ3cml0ZSh2YWx1ZSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgZml4ZWQ2NGAgdmFsdWUsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQtYml0IGludGVnZXIuXG4gICAgICovXG4gICAgc2ZpeGVkNjQodmFsdWUpIHtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcik7XG4gICAgICAgIGxldCBsb25nID0gUGJMb25nLmZyb20odmFsdWUpO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIGxvbmcubG8sIHRydWUpO1xuICAgICAgICB2aWV3LnNldEludDMyKDQsIGxvbmcuaGksIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBmaXhlZDY0YCB2YWx1ZSwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCA2NCBiaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBmaXhlZDY0KHZhbHVlKSB7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpO1xuICAgICAgICBsZXQgbG9uZyA9IFBiVUxvbmcuZnJvbSh2YWx1ZSk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgbG9uZy5sbywgdHJ1ZSk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoNCwgbG9uZy5oaSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGludDY0YCB2YWx1ZSwgYSBzaWduZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBpbnQ2NCh2YWx1ZSkge1xuICAgICAgICBsZXQgbG9uZyA9IFBiTG9uZy5mcm9tKHZhbHVlKTtcbiAgICAgICAgdmFyaW50NjR3cml0ZShsb25nLmxvLCBsb25nLmhpLCB0aGlzLmJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBzaW50NjRgIHZhbHVlLCBhIHNpZ25lZCwgemlnLXphZy1lbmNvZGVkIDY0LWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgc2ludDY0KHZhbHVlKSB7XG4gICAgICAgIGxldCBsb25nID0gUGJMb25nLmZyb20odmFsdWUpLCBcbiAgICAgICAgLy8gemlnemFnIGVuY29kZVxuICAgICAgICBzaWduID0gbG9uZy5oaSA+PiAzMSwgbG8gPSAobG9uZy5sbyA8PCAxKSBeIHNpZ24sIGhpID0gKChsb25nLmhpIDw8IDEpIHwgKGxvbmcubG8gPj4+IDMxKSkgXiBzaWduO1xuICAgICAgICB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgdWludDY0YCB2YWx1ZSwgYW4gdW5zaWduZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICB1aW50NjQodmFsdWUpIHtcbiAgICAgICAgbGV0IGxvbmcgPSBQYlVMb25nLmZyb20odmFsdWUpO1xuICAgICAgICB2YXJpbnQ2NHdyaXRlKGxvbmcubG8sIGxvbmcuaGksIHRoaXMuYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyBkaXN0cmlidXRpb24uXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgUHJvdG9jb2wgQnVmZmVyIGNvbXBpbGVyIGlzIG93bmVkIGJ5IHRoZSBvd25lclxuLy8gb2YgdGhlIGlucHV0IGZpbGUgdXNlZCB3aGVuIGdlbmVyYXRpbmcgaXQuICBUaGlzIGNvZGUgaXMgbm90XG4vLyBzdGFuZGFsb25lIGFuZCByZXF1aXJlcyBhIHN1cHBvcnQgbGlicmFyeSB0byBiZSBsaW5rZWQgd2l0aCBpdC4gIFRoaXNcbi8vIHN1cHBvcnQgbGlicmFyeSBpcyBpdHNlbGYgY292ZXJlZCBieSB0aGUgYWJvdmUgbGljZW5zZS5cbi8qKlxuICogUmVhZCBhIDY0IGJpdCB2YXJpbnQgYXMgdHdvIEpTIG51bWJlcnMuXG4gKlxuICogUmV0dXJucyB0dXBsZTpcbiAqIFswXTogbG93IGJpdHNcbiAqIFswXTogaGlnaCBiaXRzXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC9idWZmZXJfZGVjb2Rlci5qcyNMMTc1XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YXJpbnQ2NHJlYWQoKSB7XG4gICAgbGV0IGxvd0JpdHMgPSAwO1xuICAgIGxldCBoaWdoQml0cyA9IDA7XG4gICAgZm9yIChsZXQgc2hpZnQgPSAwOyBzaGlmdCA8IDI4OyBzaGlmdCArPSA3KSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgICAgIGxvd0JpdHMgfD0gKGIgJiAweDdGKSA8PCBzaGlmdDtcbiAgICAgICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBtaWRkbGVCeXRlID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgLy8gbGFzdCBmb3VyIGJpdHMgb2YgdGhlIGZpcnN0IDMyIGJpdCBudW1iZXJcbiAgICBsb3dCaXRzIHw9IChtaWRkbGVCeXRlICYgMHgwRikgPDwgMjg7XG4gICAgLy8gMyB1cHBlciBiaXRzIGFyZSBwYXJ0IG9mIHRoZSBuZXh0IDMyIGJpdCBudW1iZXJcbiAgICBoaWdoQml0cyA9IChtaWRkbGVCeXRlICYgMHg3MCkgPj4gNDtcbiAgICBpZiAoKG1pZGRsZUJ5dGUgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICAgIH1cbiAgICBmb3IgKGxldCBzaGlmdCA9IDM7IHNoaWZ0IDw9IDMxOyBzaGlmdCArPSA3KSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgICAgIGhpZ2hCaXRzIHw9IChiICYgMHg3RikgPDwgc2hpZnQ7XG4gICAgICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgICAgICByZXR1cm4gW2xvd0JpdHMsIGhpZ2hCaXRzXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdmFyaW50Jyk7XG59XG4vKipcbiAqIFdyaXRlIGEgNjQgYml0IHZhcmludCwgZ2l2ZW4gYXMgdHdvIEpTIG51bWJlcnMsIHRvIHRoZSBnaXZlbiBieXRlcyBhcnJheS5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL3dyaXRlci5qcyNMMzQ0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgYnl0ZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI4OyBpID0gaSArIDcpIHtcbiAgICAgICAgY29uc3Qgc2hpZnQgPSBsbyA+Pj4gaTtcbiAgICAgICAgY29uc3QgaGFzTmV4dCA9ICEoKHNoaWZ0ID4+PiA3KSA9PSAwICYmIGhpID09IDApO1xuICAgICAgICBjb25zdCBieXRlID0gKGhhc05leHQgPyBzaGlmdCB8IDB4ODAgOiBzaGlmdCkgJiAweEZGO1xuICAgICAgICBieXRlcy5wdXNoKGJ5dGUpO1xuICAgICAgICBpZiAoIWhhc05leHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzcGxpdEJpdHMgPSAoKGxvID4+PiAyOCkgJiAweDBGKSB8ICgoaGkgJiAweDA3KSA8PCA0KTtcbiAgICBjb25zdCBoYXNNb3JlQml0cyA9ICEoKGhpID4+IDMpID09IDApO1xuICAgIGJ5dGVzLnB1c2goKGhhc01vcmVCaXRzID8gc3BsaXRCaXRzIHwgMHg4MCA6IHNwbGl0Qml0cykgJiAweEZGKTtcbiAgICBpZiAoIWhhc01vcmVCaXRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDM7IGkgPCAzMTsgaSA9IGkgKyA3KSB7XG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gaGkgPj4+IGk7XG4gICAgICAgIGNvbnN0IGhhc05leHQgPSAhKChzaGlmdCA+Pj4gNykgPT0gMCk7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSAoaGFzTmV4dCA/IHNoaWZ0IHwgMHg4MCA6IHNoaWZ0KSAmIDB4RkY7XG4gICAgICAgIGJ5dGVzLnB1c2goYnl0ZSk7XG4gICAgICAgIGlmICghaGFzTmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ5dGVzLnB1c2goKGhpID4+PiAzMSkgJiAweDAxKTtcbn1cbi8vIGNvbnN0YW50cyBmb3IgYmluYXJ5IG1hdGhcbmNvbnN0IFRXT19QV1JfMzJfREJMID0gKDEgPDwgMTYpICogKDEgPDwgMTYpO1xuLyoqXG4gKiBQYXJzZSBkZWNpbWFsIHN0cmluZyBvZiA2NCBiaXQgaW50ZWdlciB2YWx1ZSBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBSZXR1cm5zIHR1cGxlOlxuICogWzBdOiBtaW51cyBzaWduP1xuICogWzFdOiBsb3cgYml0c1xuICogWzJdOiBoaWdoIGJpdHNcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50NjRmcm9tU3RyaW5nKGRlYykge1xuICAgIC8vIENoZWNrIGZvciBtaW51cyBzaWduLlxuICAgIGxldCBtaW51cyA9IGRlY1swXSA9PSAnLSc7XG4gICAgaWYgKG1pbnVzKVxuICAgICAgICBkZWMgPSBkZWMuc2xpY2UoMSk7XG4gICAgLy8gV29yayA2IGRlY2ltYWwgZGlnaXRzIGF0IGEgdGltZSwgYWN0aW5nIGxpa2Ugd2UncmUgY29udmVydGluZyBiYXNlIDFlNlxuICAgIC8vIGRpZ2l0cyB0byBiaW5hcnkuIFRoaXMgaXMgc2FmZSB0byBkbyB3aXRoIGZsb2F0aW5nIHBvaW50IG1hdGggYmVjYXVzZVxuICAgIC8vIE51bWJlci5pc1NhZmVJbnRlZ2VyKEFMTF8zMl9CSVRTICogMWU2KSA9PSB0cnVlLlxuICAgIGNvbnN0IGJhc2UgPSAxZTY7XG4gICAgbGV0IGxvd0JpdHMgPSAwO1xuICAgIGxldCBoaWdoQml0cyA9IDA7XG4gICAgZnVuY3Rpb24gYWRkMWU2ZGlnaXQoYmVnaW4sIGVuZCkge1xuICAgICAgICAvLyBOb3RlOiBOdW1iZXIoJycpIGlzIDAuXG4gICAgICAgIGNvbnN0IGRpZ2l0MWU2ID0gTnVtYmVyKGRlYy5zbGljZShiZWdpbiwgZW5kKSk7XG4gICAgICAgIGhpZ2hCaXRzICo9IGJhc2U7XG4gICAgICAgIGxvd0JpdHMgPSBsb3dCaXRzICogYmFzZSArIGRpZ2l0MWU2O1xuICAgICAgICAvLyBDYXJyeSBiaXRzIGZyb20gbG93Qml0cyB0byBoaWdoQml0c1xuICAgICAgICBpZiAobG93Qml0cyA+PSBUV09fUFdSXzMyX0RCTCkge1xuICAgICAgICAgICAgaGlnaEJpdHMgPSBoaWdoQml0cyArICgobG93Qml0cyAvIFRXT19QV1JfMzJfREJMKSB8IDApO1xuICAgICAgICAgICAgbG93Qml0cyA9IGxvd0JpdHMgJSBUV09fUFdSXzMyX0RCTDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGQxZTZkaWdpdCgtMjQsIC0xOCk7XG4gICAgYWRkMWU2ZGlnaXQoLTE4LCAtMTIpO1xuICAgIGFkZDFlNmRpZ2l0KC0xMiwgLTYpO1xuICAgIGFkZDFlNmRpZ2l0KC02KTtcbiAgICByZXR1cm4gW21pbnVzLCBsb3dCaXRzLCBoaWdoQml0c107XG59XG4vKipcbiAqIEZvcm1hdCA2NCBiaXQgaW50ZWdlciB2YWx1ZSAoYXMgdHdvIEpTIG51bWJlcnMpIHRvIGRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnQ2NHRvU3RyaW5nKGJpdHNMb3csIGJpdHNIaWdoKSB7XG4gICAgLy8gU2tpcCB0aGUgZXhwZW5zaXZlIGNvbnZlcnNpb24gaWYgdGhlIG51bWJlciBpcyBzbWFsbCBlbm91Z2ggdG8gdXNlIHRoZVxuICAgIC8vIGJ1aWx0LWluIGNvbnZlcnNpb25zLlxuICAgIGlmICgoYml0c0hpZ2ggPj4+IDApIDw9IDB4MUZGRkZGKSB7XG4gICAgICAgIHJldHVybiAnJyArIChUV09fUFdSXzMyX0RCTCAqIGJpdHNIaWdoICsgKGJpdHNMb3cgPj4+IDApKTtcbiAgICB9XG4gICAgLy8gV2hhdCB0aGlzIGNvZGUgaXMgZG9pbmcgaXMgZXNzZW50aWFsbHkgY29udmVydGluZyB0aGUgaW5wdXQgbnVtYmVyIGZyb21cbiAgICAvLyBiYXNlLTIgdG8gYmFzZS0xZTcsIHdoaWNoIGFsbG93cyB1cyB0byByZXByZXNlbnQgdGhlIDY0LWJpdCByYW5nZSB3aXRoXG4gICAgLy8gb25seSAzICh2ZXJ5IGxhcmdlKSBkaWdpdHMuIFRob3NlIGRpZ2l0cyBhcmUgdGhlbiB0cml2aWFsIHRvIGNvbnZlcnQgdG9cbiAgICAvLyBhIGJhc2UtMTAgc3RyaW5nLlxuICAgIC8vIFRoZSBtYWdpYyBudW1iZXJzIHVzZWQgaGVyZSBhcmUgLVxuICAgIC8vIDJeMjQgPSAxNjc3NzIxNiA9ICgxLDY3NzcyMTYpIGluIGJhc2UtMWU3LlxuICAgIC8vIDJeNDggPSAyODE0NzQ5NzY3MTA2NTYgPSAoMiw4MTQ3NDk3LDY3MTA2NTYpIGluIGJhc2UtMWU3LlxuICAgIC8vIFNwbGl0IDMyOjMyIHJlcHJlc2VudGF0aW9uIGludG8gMTY6MjQ6MjQgcmVwcmVzZW50YXRpb24gc28gb3VyXG4gICAgLy8gaW50ZXJtZWRpYXRlIGRpZ2l0cyBkb24ndCBvdmVyZmxvdy5cbiAgICBsZXQgbG93ID0gYml0c0xvdyAmIDB4RkZGRkZGO1xuICAgIGxldCBtaWQgPSAoKChiaXRzTG93ID4+PiAyNCkgfCAoYml0c0hpZ2ggPDwgOCkpID4+PiAwKSAmIDB4RkZGRkZGO1xuICAgIGxldCBoaWdoID0gKGJpdHNIaWdoID4+IDE2KSAmIDB4RkZGRjtcbiAgICAvLyBBc3NlbWJsZSBvdXIgdGhyZWUgYmFzZS0xZTcgZGlnaXRzLCBpZ25vcmluZyBjYXJyaWVzLiBUaGUgbWF4aW11bVxuICAgIC8vIHZhbHVlIGluIGEgZGlnaXQgYXQgdGhpcyBzdGVwIGlzIHJlcHJlc2VudGFibGUgYXMgYSA0OC1iaXQgaW50ZWdlciwgd2hpY2hcbiAgICAvLyBjYW4gYmUgc3RvcmVkIGluIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICBsZXQgZGlnaXRBID0gbG93ICsgKG1pZCAqIDY3NzcyMTYpICsgKGhpZ2ggKiA2NzEwNjU2KTtcbiAgICBsZXQgZGlnaXRCID0gbWlkICsgKGhpZ2ggKiA4MTQ3NDk3KTtcbiAgICBsZXQgZGlnaXRDID0gKGhpZ2ggKiAyKTtcbiAgICAvLyBBcHBseSBjYXJyaWVzIGZyb20gQSB0byBCIGFuZCBmcm9tIEIgdG8gQy5cbiAgICBsZXQgYmFzZSA9IDEwMDAwMDAwO1xuICAgIGlmIChkaWdpdEEgPj0gYmFzZSkge1xuICAgICAgICBkaWdpdEIgKz0gTWF0aC5mbG9vcihkaWdpdEEgLyBiYXNlKTtcbiAgICAgICAgZGlnaXRBICU9IGJhc2U7XG4gICAgfVxuICAgIGlmIChkaWdpdEIgPj0gYmFzZSkge1xuICAgICAgICBkaWdpdEMgKz0gTWF0aC5mbG9vcihkaWdpdEIgLyBiYXNlKTtcbiAgICAgICAgZGlnaXRCICU9IGJhc2U7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgYmFzZS0xZTcgZGlnaXRzIHRvIGJhc2UtMTAsIHdpdGggb3B0aW9uYWwgbGVhZGluZyB6ZXJvZXMuXG4gICAgZnVuY3Rpb24gZGVjaW1hbEZyb20xZTcoZGlnaXQxZTcsIG5lZWRMZWFkaW5nWmVyb3MpIHtcbiAgICAgICAgbGV0IHBhcnRpYWwgPSBkaWdpdDFlNyA/IFN0cmluZyhkaWdpdDFlNykgOiAnJztcbiAgICAgICAgaWYgKG5lZWRMZWFkaW5nWmVyb3MpIHtcbiAgICAgICAgICAgIHJldHVybiAnMDAwMDAwMCcuc2xpY2UocGFydGlhbC5sZW5ndGgpICsgcGFydGlhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydGlhbDtcbiAgICB9XG4gICAgcmV0dXJuIGRlY2ltYWxGcm9tMWU3KGRpZ2l0QywgLypuZWVkTGVhZGluZ1plcm9zPSovIDApICtcbiAgICAgICAgZGVjaW1hbEZyb20xZTcoZGlnaXRCLCAvKm5lZWRMZWFkaW5nWmVyb3M9Ki8gZGlnaXRDKSArXG4gICAgICAgIC8vIElmIHRoZSBmaW5hbCAxZTcgZGlnaXQgZGlkbid0IG5lZWQgbGVhZGluZyB6ZXJvcywgd2Ugd291bGQgaGF2ZVxuICAgICAgICAvLyByZXR1cm5lZCB2aWEgdGhlIHRyaXZpYWwgY29kZSBwYXRoIGF0IHRoZSB0b3AuXG4gICAgICAgIGRlY2ltYWxGcm9tMWU3KGRpZ2l0QSwgLypuZWVkTGVhZGluZ1plcm9zPSovIDEpO1xufVxuLyoqXG4gKiBXcml0ZSBhIDMyIGJpdCB2YXJpbnQsIHNpZ25lZCBvciB1bnNpZ25lZC4gU2FtZSBhcyBgdmFyaW50NjR3cml0ZSgwLCB2YWx1ZSwgYnl0ZXMpYFxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvMWIxODgzM2Y0ZjJhMmY2ODFmNGU0YTI1Y2RmM2IwYTQzMTE1ZWMyNi9qcy9iaW5hcnkvZW5jb2Rlci5qcyNMMTQ0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YXJpbnQzMndyaXRlKHZhbHVlLCBieXRlcykge1xuICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICAgIC8vIHdyaXRlIHZhbHVlIGFzIHZhcmludCAzMlxuICAgICAgICB3aGlsZSAodmFsdWUgPiAweDdmKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKCh2YWx1ZSAmIDB4N2YpIHwgMHg4MCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2godmFsdWUgJiAxMjcgfCAxMjgpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PiA3O1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzLnB1c2goMSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZWFkIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC9idWZmZXJfZGVjb2Rlci5qcyNMMjIwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YXJpbnQzMnJlYWQoKSB7XG4gICAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICBsZXQgcmVzdWx0ID0gYiAmIDB4N0Y7XG4gICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgcmVzdWx0IHw9IChiICYgMHg3RikgPDwgNztcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDdGKSA8PCAxNDtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDdGKSA8PCAyMTtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEV4dHJhY3Qgb25seSBsYXN0IDQgYml0c1xuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDBGKSA8PCAyODtcbiAgICBmb3IgKGxldCByZWFkQnl0ZXMgPSA1OyAoKGIgJiAweDgwKSAhPT0gMCkgJiYgcmVhZEJ5dGVzIDwgMTA7IHJlYWRCeXRlcysrKVxuICAgICAgICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgaWYgKChiICYgMHg4MCkgIT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHZhcmludCcpO1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgLy8gUmVzdWx0IGNhbiBoYXZlIDMyIGJpdHMsIGNvbnZlcnQgaXQgdG8gdW5zaWduZWRcbiAgICByZXR1cm4gcmVzdWx0ID4+PiAwO1xufVxuIiwiY29uc3QgZGVmYXVsdHNXcml0ZSA9IHtcbiAgICBlbWl0RGVmYXVsdFZhbHVlczogZmFsc2UsXG4gICAgZW51bUFzSW50ZWdlcjogZmFsc2UsXG4gICAgdXNlUHJvdG9GaWVsZE5hbWU6IGZhbHNlLFxuICAgIHByZXR0eVNwYWNlczogMCxcbn0sIGRlZmF1bHRzUmVhZCA9IHtcbiAgICBpZ25vcmVVbmtub3duRmllbGRzOiBmYWxzZSxcbn07XG4vKipcbiAqIE1ha2Ugb3B0aW9ucyBmb3IgcmVhZGluZyBKU09OIGRhdGEgZnJvbSBwYXJ0aWFsIG9wdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqc29uUmVhZE9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0c1JlYWQpLCBvcHRpb25zKSA6IGRlZmF1bHRzUmVhZDtcbn1cbi8qKlxuICogTWFrZSBvcHRpb25zIGZvciB3cml0aW5nIEpTT04gZGF0YSBmcm9tIHBhcnRpYWwgb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpzb25Xcml0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0c1dyaXRlKSwgb3B0aW9ucykgOiBkZWZhdWx0c1dyaXRlO1xufVxuLyoqXG4gKiBNZXJnZXMgSlNPTiB3cml0ZSBvciByZWFkIG9wdGlvbnMuIExhdGVyIHZhbHVlcyBvdmVycmlkZSBlYXJsaWVyIHZhbHVlcy4gVHlwZSByZWdpc3RyaWVzIGFyZSBtZXJnZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUpzb25PcHRpb25zKGEsIGIpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGxldCBjID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhKSwgYik7XG4gICAgYy50eXBlUmVnaXN0cnkgPSBbLi4uKChfYSA9IGEgPT09IG51bGwgfHwgYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYS50eXBlUmVnaXN0cnkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSwgLi4uKChfYiA9IGIgPT09IG51bGwgfHwgYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYi50eXBlUmVnaXN0cnkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKV07XG4gICAgcmV0dXJuIGM7XG59XG4iLCIvKipcbiAqIEdldCB0aGUgdHlwZSBvZiBhIEpTT04gdmFsdWUuXG4gKiBEaXN0aW5ndWlzaGVzIGJldHdlZW4gYXJyYXksIG51bGwgYW5kIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR5cGVvZkpzb25WYWx1ZSh2YWx1ZSkge1xuICAgIGxldCB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmICh0ID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn1cbi8qKlxuICogSXMgdGhpcyBhIEpTT04gb2JqZWN0IChpbnN0ZWFkIG9mIGFuIGFycmF5IG9yIG51bGwpP1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNKc29uT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbiIsIi8qKlxuICogQ29udmVydHMgc25ha2VfY2FzZSB0byBsb3dlckNhbWVsQ2FzZS5cbiAqXG4gKiBTaG91bGQgYmVoYXZlIGxpa2UgcHJvdG9jOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iL2U4YWUxMzdjOTY0NDRlYTMxMzQ4NWVkMTExOGM1ZTQzYjIwOTljZjEvc3JjL2dvb2dsZS9wcm90b2J1Zi9jb21waWxlci9qYXZhL2phdmFfaGVscGVycy5jYyNMMTE4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb3dlckNhbWVsQ2FzZShzbmFrZUNhc2UpIHtcbiAgICBsZXQgY2FwTmV4dCA9IGZhbHNlO1xuICAgIGNvbnN0IHNiID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbmFrZUNhc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5leHQgPSBzbmFrZUNhc2UuY2hhckF0KGkpO1xuICAgICAgICBpZiAobmV4dCA9PSAnXycpIHtcbiAgICAgICAgICAgIGNhcE5leHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9cXGQvLnRlc3QobmV4dCkpIHtcbiAgICAgICAgICAgIHNiLnB1c2gobmV4dCk7XG4gICAgICAgICAgICBjYXBOZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYXBOZXh0KSB7XG4gICAgICAgICAgICBzYi5wdXNoKG5leHQudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgICBjYXBOZXh0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICBzYi5wdXNoKG5leHQudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzYi5wdXNoKG5leHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzYi5qb2luKCcnKTtcbn1cbiIsIi8qKlxuICogVGhlIHN5bWJvbCB1c2VkIGFzIGEga2V5IG9uIG1lc3NhZ2Ugb2JqZWN0cyB0byBzdG9yZSB0aGUgbWVzc2FnZSB0eXBlLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIC0gaXQgaXMgaGVyZSB0byBzdGF5LCBidXRcbiAqIGltcGxlbWVudGF0aW9uIGRldGFpbHMgbWF5IGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAqL1xuZXhwb3J0IGNvbnN0IE1FU1NBR0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJwcm90b2J1Zi10cy9tZXNzYWdlLXR5cGVcIik7XG4iLCJpbXBvcnQgeyBNRVNTQUdFX1RZUEUgfSBmcm9tIFwiLi9tZXNzYWdlLXR5cGUtY29udHJhY3RcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZUZpZWxkSW5mbyB9IGZyb20gXCIuL3JlZmxlY3Rpb24taW5mb1wiO1xuaW1wb3J0IHsgUmVmbGVjdGlvblR5cGVDaGVjayB9IGZyb20gXCIuL3JlZmxlY3Rpb24tdHlwZS1jaGVja1wiO1xuaW1wb3J0IHsgUmVmbGVjdGlvbkpzb25SZWFkZXIgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWpzb24tcmVhZGVyXCI7XG5pbXBvcnQgeyBSZWZsZWN0aW9uSnNvbldyaXRlciB9IGZyb20gXCIuL3JlZmxlY3Rpb24tanNvbi13cml0ZXJcIjtcbmltcG9ydCB7IFJlZmxlY3Rpb25CaW5hcnlSZWFkZXIgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWJpbmFyeS1yZWFkZXJcIjtcbmltcG9ydCB7IFJlZmxlY3Rpb25CaW5hcnlXcml0ZXIgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWJpbmFyeS13cml0ZXJcIjtcbmltcG9ydCB7IHJlZmxlY3Rpb25DcmVhdGUgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWNyZWF0ZVwiO1xuaW1wb3J0IHsgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCB9IGZyb20gXCIuL3JlZmxlY3Rpb24tbWVyZ2UtcGFydGlhbFwiO1xuaW1wb3J0IHsgdHlwZW9mSnNvblZhbHVlIH0gZnJvbSBcIi4vanNvbi10eXBpbmdzXCI7XG5pbXBvcnQgeyBqc29uUmVhZE9wdGlvbnMsIGpzb25Xcml0ZU9wdGlvbnMsIH0gZnJvbSBcIi4vanNvbi1mb3JtYXQtY29udHJhY3RcIjtcbmltcG9ydCB7IHJlZmxlY3Rpb25FcXVhbHMgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWVxdWFsc1wiO1xuaW1wb3J0IHsgYmluYXJ5V3JpdGVPcHRpb25zIH0gZnJvbSBcIi4vYmluYXJ5LXdyaXRlclwiO1xuaW1wb3J0IHsgYmluYXJ5UmVhZE9wdGlvbnMgfSBmcm9tIFwiLi9iaW5hcnktcmVhZGVyXCI7XG5jb25zdCBiYXNlRGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pKTtcbi8qKlxuICogVGhpcyBzdGFuZGFyZCBtZXNzYWdlIHR5cGUgcHJvdmlkZXMgcmVmbGVjdGlvbi1iYXNlZFxuICogb3BlcmF0aW9ucyB0byB3b3JrIHdpdGggYSBtZXNzYWdlLlxuICovXG5leHBvcnQgY2xhc3MgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGZpZWxkcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmRlZmF1bHRDaGVja0RlcHRoID0gMTY7XG4gICAgICAgIHRoaXMudHlwZU5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcy5tYXAobm9ybWFsaXplRmllbGRJbmZvKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XG4gICAgICAgIHRoaXMubWVzc2FnZVByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBiYXNlRGVzY3JpcHRvcnMpLCB7IFtNRVNTQUdFX1RZUEVdOiB7IHZhbHVlOiB0aGlzIH0gfSkpO1xuICAgICAgICB0aGlzLnJlZlR5cGVDaGVjayA9IG5ldyBSZWZsZWN0aW9uVHlwZUNoZWNrKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZkpzb25SZWFkZXIgPSBuZXcgUmVmbGVjdGlvbkpzb25SZWFkZXIodGhpcyk7XG4gICAgICAgIHRoaXMucmVmSnNvbldyaXRlciA9IG5ldyBSZWZsZWN0aW9uSnNvbldyaXRlcih0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZCaW5SZWFkZXIgPSBuZXcgUmVmbGVjdGlvbkJpbmFyeVJlYWRlcih0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZCaW5Xcml0ZXIgPSBuZXcgUmVmbGVjdGlvbkJpbmFyeVdyaXRlcih0aGlzKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gcmVmbGVjdGlvbkNyZWF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9uZSB0aGUgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIFVua25vd24gZmllbGRzIGFyZSBkaXNjYXJkZWQuXG4gICAgICovXG4gICAgY2xvbmUobWVzc2FnZSkge1xuICAgICAgICBsZXQgY29weSA9IHRoaXMuY3JlYXRlKCk7XG4gICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgY29weSwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdHdvIG1lc3NhZ2Ugb2YgdGhlIHNhbWUgdHlwZSBoYXZlIHRoZSBzYW1lIGZpZWxkIHZhbHVlcy5cbiAgICAgKiBDaGVja3MgZm9yIGRlZXAgZXF1YWxpdHksIHRyYXZlcnNpbmcgcmVwZWF0ZWQgZmllbGRzLCBvbmVvZiBncm91cHMsIG1hcHNcbiAgICAgKiBhbmQgbWVzc2FnZXMgcmVjdXJzaXZlbHkuXG4gICAgICogV2lsbCBhbHNvIHJldHVybiB0cnVlIGlmIGJvdGggbWVzc2FnZXMgYXJlIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiByZWZsZWN0aW9uRXF1YWxzKHRoaXMsIGEsIGIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgZ2l2ZW4gdmFsdWUgYXNzaWduYWJsZSB0byBvdXIgbWVzc2FnZSB0eXBlXG4gICAgICogYW5kIGNvbnRhaW5zIG5vIFtleGNlc3MgcHJvcGVydGllc10oaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svaW50ZXJmYWNlcy5odG1sI2V4Y2Vzcy1wcm9wZXJ0eS1jaGVja3MpP1xuICAgICAqL1xuICAgIGlzKGFyZywgZGVwdGggPSB0aGlzLmRlZmF1bHRDaGVja0RlcHRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZlR5cGVDaGVjay5pcyhhcmcsIGRlcHRoLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSBnaXZlbiB2YWx1ZSBhc3NpZ25hYmxlIHRvIG91ciBtZXNzYWdlIHR5cGUsXG4gICAgICogcmVnYXJkbGVzcyBvZiBbZXhjZXNzIHByb3BlcnRpZXNdKGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL2ludGVyZmFjZXMuaHRtbCNleGNlc3MtcHJvcGVydHktY2hlY2tzKT9cbiAgICAgKi9cbiAgICBpc0Fzc2lnbmFibGUoYXJnLCBkZXB0aCA9IHRoaXMuZGVmYXVsdENoZWNrRGVwdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmVHlwZUNoZWNrLmlzKGFyZywgZGVwdGgsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3B5IHBhcnRpYWwgZGF0YSBpbnRvIHRoZSB0YXJnZXQgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBtZXJnZVBhcnRpYWwodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCB0YXJnZXQsIHNvdXJjZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBtZXNzYWdlIGZyb20gYmluYXJ5IGZvcm1hdC5cbiAgICAgKi9cbiAgICBmcm9tQmluYXJ5KGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG9wdCA9IGJpbmFyeVJlYWRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEJpbmFyeVJlYWQob3B0LnJlYWRlckZhY3RvcnkoZGF0YSksIGRhdGEuYnl0ZUxlbmd0aCwgb3B0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIG5ldyBtZXNzYWdlIGZyb20gYSBKU09OIHZhbHVlLlxuICAgICAqL1xuICAgIGZyb21Kc29uKGpzb24sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxKc29uUmVhZChqc29uLCBqc29uUmVhZE9wdGlvbnMob3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgbmV3IG1lc3NhZ2UgZnJvbSBhIEpTT04gc3RyaW5nLlxuICAgICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byBgVC5mcm9tSnNvbihKU09OLnBhcnNlKGpzb24pKWAuXG4gICAgICovXG4gICAgZnJvbUpzb25TdHJpbmcoanNvbiwgb3B0aW9ucykge1xuICAgICAgICBsZXQgdmFsdWUgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tSnNvbih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIHRoZSBtZXNzYWdlIHRvIGNhbm9uaWNhbCBKU09OIHZhbHVlLlxuICAgICAqL1xuICAgIHRvSnNvbihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsSnNvbldyaXRlKG1lc3NhZ2UsIGpzb25Xcml0ZU9wdGlvbnMob3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBtZXNzYWdlIHRvIGNhbm9uaWNhbCBKU09OIHN0cmluZy5cbiAgICAgKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gYEpTT04uc3RyaW5naWZ5KFQudG9Kc29uKHQpKWBcbiAgICAgKi9cbiAgICB0b0pzb25TdHJpbmcobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudG9Kc29uKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV0dHlTcGFjZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0aGUgbWVzc2FnZSB0byBiaW5hcnkgZm9ybWF0LlxuICAgICAqL1xuICAgIHRvQmluYXJ5KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG9wdCA9IGJpbmFyeVdyaXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCBvcHQud3JpdGVyRmFjdG9yeSgpLCBvcHQpLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGFuIGludGVybmFsIG1ldGhvZC4gSWYgeW91IGp1c3Qgd2FudCB0byByZWFkIGEgbWVzc2FnZSBmcm9tXG4gICAgICogSlNPTiwgdXNlIGBmcm9tSnNvbigpYCBvciBgZnJvbUpzb25TdHJpbmcoKWAuXG4gICAgICpcbiAgICAgKiBSZWFkcyBKU09OIHZhbHVlIGFuZCBtZXJnZXMgdGhlIGZpZWxkcyBpbnRvIHRoZSB0YXJnZXRcbiAgICAgKiBhY2NvcmRpbmcgdG8gcHJvdG9idWYgcnVsZXMuIElmIHRoZSB0YXJnZXQgaXMgb21pdHRlZCxcbiAgICAgKiBhIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGZpcnN0LlxuICAgICAqL1xuICAgIGludGVybmFsSnNvblJlYWQoanNvbiwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGlmIChqc29uICE9PSBudWxsICYmIHR5cGVvZiBqc29uID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoanNvbikpIHtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKTtcbiAgICAgICAgICAgIHRoaXMucmVmSnNvblJlYWRlci5yZWFkKGpzb24sIG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcGFyc2UgbWVzc2FnZSAke3RoaXMudHlwZU5hbWV9IGZyb20gSlNPTiAke3R5cGVvZkpzb25WYWx1ZShqc29uKX0uYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYW4gaW50ZXJuYWwgbWV0aG9kLiBJZiB5b3UganVzdCB3YW50IHRvIHdyaXRlIGEgbWVzc2FnZVxuICAgICAqIHRvIEpTT04sIHVzZSBgdG9Kc29uKClgIG9yIGB0b0pzb25TdHJpbmcoKS5cbiAgICAgKlxuICAgICAqIFdyaXRlcyBKU09OIHZhbHVlIGFuZCByZXR1cm5zIGl0LlxuICAgICAqL1xuICAgIGludGVybmFsSnNvbldyaXRlKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmSnNvbldyaXRlci53cml0ZShtZXNzYWdlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhbiBpbnRlcm5hbCBtZXRob2QuIElmIHlvdSBqdXN0IHdhbnQgdG8gd3JpdGUgYSBtZXNzYWdlXG4gICAgICogaW4gYmluYXJ5IGZvcm1hdCwgdXNlIGB0b0JpbmFyeSgpYC5cbiAgICAgKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIG1lc3NhZ2UgaW4gYmluYXJ5IGZvcm1hdCBhbmQgYXBwZW5kcyBpdCB0byB0aGUgZ2l2ZW5cbiAgICAgKiB3cml0ZXIuIFJldHVybnMgcGFzc2VkIHdyaXRlci5cbiAgICAgKi9cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlZkJpbldyaXRlci53cml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGFuIGludGVybmFsIG1ldGhvZC4gSWYgeW91IGp1c3Qgd2FudCB0byByZWFkIGEgbWVzc2FnZSBmcm9tXG4gICAgICogYmluYXJ5IGRhdGEsIHVzZSBgZnJvbUJpbmFyeSgpYC5cbiAgICAgKlxuICAgICAqIFJlYWRzIGRhdGEgZnJvbSBiaW5hcnkgZm9ybWF0IGFuZCBtZXJnZXMgdGhlIGZpZWxkcyBpbnRvXG4gICAgICogdGhlIHRhcmdldCBhY2NvcmRpbmcgdG8gcHJvdG9idWYgcnVsZXMuIElmIHRoZSB0YXJnZXQgaXNcbiAgICAgKiBvbWl0dGVkLCBhIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGZpcnN0LlxuICAgICAqL1xuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKTtcbiAgICAgICAgdGhpcy5yZWZCaW5SZWFkZXIucmVhZChyZWFkZXIsIG1lc3NhZ2UsIG9wdGlvbnMsIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbn1cbiIsIi8qKlxuICogSXMgdGhlIGdpdmVuIHZhbHVlIGEgdmFsaWQgb25lb2YgZ3JvdXA/XG4gKlxuICogV2UgcmVwcmVzZW50IHByb3RvYnVmIGBvbmVvZmAgYXMgYWxnZWJyYWljIGRhdGEgdHlwZXMgKEFEVCkgaW4gZ2VuZXJhdGVkXG4gKiBjb2RlLiBCdXQgd2hlbiB3b3JraW5nIHdpdGggbWVzc2FnZXMgb2YgdW5rbm93biB0eXBlLCB0aGUgQURUIGRvZXMgbm90XG4gKiBoZWxwIHVzLlxuICpcbiAqIFRoaXMgdHlwZSBndWFyZCBjaGVja3MgaWYgdGhlIGdpdmVuIG9iamVjdCBhZGhlcmVzIHRvIHRoZSBBRFQgcnVsZXMsIHdoaWNoXG4gKiBhcmUgYXMgZm9sbG93czpcbiAqXG4gKiAxKSBNdXN0IGJlIGFuIG9iamVjdC5cbiAqXG4gKiAyKSBNdXN0IGhhdmUgYSBcIm9uZW9mS2luZFwiIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkuXG4gKlxuICogMykgSWYgXCJvbmVvZktpbmRcIiBpcyBgdW5kZWZpbmVkYCwgbm8gbWVtYmVyIGZpZWxkIGlzIHNlbGVjdGVkLiBUaGUgb2JqZWN0XG4gKiBtdXN0IG5vdCBoYXZlIGFueSBvdGhlciBwcm9wZXJ0aWVzLlxuICpcbiAqIDQpIElmIFwib25lb2ZLaW5kXCIgaXMgYSBgc3RyaW5nYCwgdGhlIG1lbWJlciBmaWVsZCB3aXRoIHRoaXMgbmFtZSBpc1xuICogc2VsZWN0ZWQuXG4gKlxuICogNSkgSWYgYSBtZW1iZXIgZmllbGQgaXMgc2VsZWN0ZWQsIHRoZSBvYmplY3QgbXVzdCBoYXZlIGEgc2Vjb25kIHByb3BlcnR5XG4gKiB3aXRoIHRoaXMgbmFtZS4gVGhlIHByb3BlcnR5IG11c3Qgbm90IGJlIGB1bmRlZmluZWRgLlxuICpcbiAqIDYpIE5vIGV4dHJhIHByb3BlcnRpZXMgYXJlIGFsbG93ZWQuIFRoZSBvYmplY3QgaGFzIGVpdGhlciBvbmUgcHJvcGVydHlcbiAqIChubyBzZWxlY3Rpb24pIG9yIHR3byBwcm9wZXJ0aWVzIChzZWxlY3Rpb24pLlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT25lb2ZHcm91cChhbnkpIHtcbiAgICBpZiAodHlwZW9mIGFueSAhPSAnb2JqZWN0JyB8fCBhbnkgPT09IG51bGwgfHwgIWFueS5oYXNPd25Qcm9wZXJ0eSgnb25lb2ZLaW5kJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiBhbnkub25lb2ZLaW5kKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIGlmIChhbnlbYW55Lm9uZW9mS2luZF0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYW55KS5sZW5ndGggPT0gMjtcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGFueSkubGVuZ3RoID09IDE7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZmllbGQgaW4gYSBvbmVvZiBncm91cC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9uZW9mVmFsdWUob25lb2YsIGtpbmQpIHtcbiAgICByZXR1cm4gb25lb2Zba2luZF07XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0T25lb2ZWYWx1ZShvbmVvZiwga2luZCwgdmFsdWUpIHtcbiAgICBpZiAob25lb2Yub25lb2ZLaW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIG9uZW9mW29uZW9mLm9uZW9mS2luZF07XG4gICAgfVxuICAgIG9uZW9mLm9uZW9mS2luZCA9IGtpbmQ7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25lb2Zba2luZF0gPSB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0VW5rbm93bk9uZW9mVmFsdWUob25lb2YsIGtpbmQsIHZhbHVlKSB7XG4gICAgaWYgKG9uZW9mLm9uZW9mS2luZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSBvbmVvZltvbmVvZi5vbmVvZktpbmRdO1xuICAgIH1cbiAgICBvbmVvZi5vbmVvZktpbmQgPSBraW5kO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGtpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbmVvZltraW5kXSA9IHZhbHVlO1xuICAgIH1cbn1cbi8qKlxuICogUmVtb3ZlcyB0aGUgc2VsZWN0ZWQgZmllbGQgaW4gYSBvbmVvZiBncm91cC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIHJlY29tbWVuZGVkIHdheSB0byBtb2RpZnkgYSBvbmVvZiBncm91cCBpcyB0byBzZXRcbiAqIGEgbmV3IG9iamVjdDpcbiAqXG4gKiBgYGB0c1xuICogbWVzc2FnZS5yZXN1bHQgPSB7IG9uZW9mS2luZDogdW5kZWZpbmVkIH07XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyT25lb2ZWYWx1ZShvbmVvZikge1xuICAgIGlmIChvbmVvZi5vbmVvZktpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgb25lb2Zbb25lb2Yub25lb2ZLaW5kXTtcbiAgICB9XG4gICAgb25lb2Yub25lb2ZLaW5kID0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzZWxlY3RlZCB2YWx1ZSBvZiB0aGUgZ2l2ZW4gb25lb2YgZ3JvdXAuXG4gKlxuICogTm90IHRoYXQgdGhlIHJlY29tbWVuZGVkIHdheSB0byBhY2Nlc3MgYSBvbmVvZiBncm91cCBpcyB0byBjaGVja1xuICogdGhlIFwib25lb2ZLaW5kXCIgcHJvcGVydHkgYW5kIGxldCBUeXBlU2NyaXB0IG5hcnJvdyBkb3duIHRoZSB1bmlvblxuICogdHlwZSBmb3IgeW91OlxuICpcbiAqIGBgYHRzXG4gKiBpZiAobWVzc2FnZS5yZXN1bHQub25lb2ZLaW5kID09PSBcImVycm9yXCIpIHtcbiAqICAgbWVzc2FnZS5yZXN1bHQuZXJyb3I7IC8vIHN0cmluZ1xuICogfVxuICogYGBgXG4gKlxuICogSW4gdGhlIHJhcmUgY2FzZSB5b3UganVzdCBuZWVkIHRoZSB2YWx1ZSwgYW5kIGRvIG5vdCBjYXJlIGFib3V0XG4gKiB3aGljaCBwcm90b2J1ZiBmaWVsZCBpcyBzZWxlY3RlZCwgeW91IGNhbiB1c2UgdGhpcyBmdW5jdGlvblxuICogZm9yIGNvbnZlbmllbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0ZWRPbmVvZlZhbHVlKG9uZW9mKSB7XG4gICAgaWYgKG9uZW9mLm9uZW9mS2luZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBvbmVvZltvbmVvZi5vbmVvZktpbmRdO1xufVxuIiwiaW1wb3J0IHsgaW50NjRmcm9tU3RyaW5nLCBpbnQ2NHRvU3RyaW5nIH0gZnJvbSBcIi4vZ29vZy12YXJpbnRcIjtcbmxldCBCSTtcbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RCaSgpIHtcbiAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoOCkpO1xuICAgIGNvbnN0IG9rID0gZ2xvYmFsVGhpcy5CaWdJbnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAmJiB0eXBlb2YgZHYuZ2V0QmlnSW50NjQgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAmJiB0eXBlb2YgZHYuZ2V0QmlnVWludDY0ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgJiYgdHlwZW9mIGR2LnNldEJpZ0ludDY0ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgJiYgdHlwZW9mIGR2LnNldEJpZ1VpbnQ2NCA9PT0gXCJmdW5jdGlvblwiO1xuICAgIEJJID0gb2sgPyB7XG4gICAgICAgIE1JTjogQmlnSW50KFwiLTkyMjMzNzIwMzY4NTQ3NzU4MDhcIiksXG4gICAgICAgIE1BWDogQmlnSW50KFwiOTIyMzM3MjAzNjg1NDc3NTgwN1wiKSxcbiAgICAgICAgVU1JTjogQmlnSW50KFwiMFwiKSxcbiAgICAgICAgVU1BWDogQmlnSW50KFwiMTg0NDY3NDQwNzM3MDk1NTE2MTVcIiksXG4gICAgICAgIEM6IEJpZ0ludCxcbiAgICAgICAgVjogZHYsXG4gICAgfSA6IHVuZGVmaW5lZDtcbn1cbmRldGVjdEJpKCk7XG5mdW5jdGlvbiBhc3NlcnRCaShiaSkge1xuICAgIGlmICghYmkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJpZ0ludCB1bmF2YWlsYWJsZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vc3RhbW0vcHJvdG9idWYtdHMvYmxvYi92MS4wLjgvTUFOVUFMLm1kI2JpZ2ludC1zdXBwb3J0XCIpO1xufVxuLy8gdXNlZCB0byB2YWxpZGF0ZSBmcm9tKHN0cmluZykgaW5wdXQgKHdoZW4gYmlnaW50IGlzIHVuYXZhaWxhYmxlKVxuY29uc3QgUkVfREVDSU1BTF9TVFIgPSAvXi0/WzAtOV0rJC87XG4vLyBjb25zdGFudHMgZm9yIGJpbmFyeSBtYXRoXG5jb25zdCBUV09fUFdSXzMyX0RCTCA9IDB4MTAwMDAwMDAwO1xuY29uc3QgSEFMRl8yX1BXUl8zMiA9IDB4MDgwMDAwMDAwO1xuLy8gYmFzZSBjbGFzcyBmb3IgUGJMb25nIGFuZCBQYlVMb25nIHByb3ZpZGVzIHNoYXJlZCBjb2RlXG5jbGFzcyBTaGFyZWRQYkxvbmcge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBiaXRzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvLCBoaSkge1xuICAgICAgICB0aGlzLmxvID0gbG8gfCAwO1xuICAgICAgICB0aGlzLmhpID0gaGkgfCAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIGluc3RhbmNlIGVxdWFsIHRvIDA/XG4gICAgICovXG4gICAgaXNaZXJvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sbyA9PSAwICYmIHRoaXMuaGkgPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0byBhIG5hdGl2ZSBudW1iZXIuXG4gICAgICovXG4gICAgdG9OdW1iZXIoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmhpICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sbyA+Pj4gMCk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIocmVzdWx0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBjb252ZXJ0IHRvIHNhZmUgbnVtYmVyXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuICogNjQtYml0IHVuc2lnbmVkIGludGVnZXIgYXMgdHdvIDMyLWJpdCB2YWx1ZXMuXG4gKiBDb252ZXJ0cyBiZXR3ZWVuIGBzdHJpbmdgLCBgbnVtYmVyYCBhbmQgYGJpZ2ludGAgcmVwcmVzZW50YXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgUGJVTG9uZyBleHRlbmRzIFNoYXJlZFBiTG9uZyB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGluc3RhbmNlIGZyb20gYSBgc3RyaW5nYCwgYG51bWJlcmAgb3IgYGJpZ2ludGAuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKEJJKVxuICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIEZhbGxUaHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIjBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlpFUk87XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgaXMgbm8gaW50ZWdlcicpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEJJLkModmFsdWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuWkVSTztcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBCSS5DKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5aRVJPO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCBCSS5VTUlOKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduZWQgdmFsdWUgZm9yIHVsb25nJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IEJJLlVNQVgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vsb25nIHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgICAgICAgICBCSS5WLnNldEJpZ1VpbnQ2NCgwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGJVTG9uZyhCSS5WLmdldEludDMyKDAsIHRydWUpLCBCSS5WLmdldEludDMyKDQsIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIjBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlpFUk87XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIVJFX0RFQ0lNQUxfU1RSLnRlc3QodmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgaXMgbm8gaW50ZWdlcicpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgW21pbnVzLCBsbywgaGldID0gaW50NjRmcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbnVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduZWQgdmFsdWUgZm9yIHVsb25nJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGJVTG9uZyhsbywgaGkpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5aRVJPO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIGlzIG5vIGludGVnZXInKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbmVkIHZhbHVlIGZvciB1bG9uZycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBiVUxvbmcodmFsdWUsIHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gdmFsdWUgJyArIHR5cGVvZiB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdG8gZGVjaW1hbCBzdHJpbmcuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBCSSA/IHRoaXMudG9CaWdJbnQoKS50b1N0cmluZygpIDogaW50NjR0b1N0cmluZyh0aGlzLmxvLCB0aGlzLmhpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0byBuYXRpdmUgYmlnaW50LlxuICAgICAqL1xuICAgIHRvQmlnSW50KCkge1xuICAgICAgICBhc3NlcnRCaShCSSk7XG4gICAgICAgIEJJLlYuc2V0SW50MzIoMCwgdGhpcy5sbywgdHJ1ZSk7XG4gICAgICAgIEJJLlYuc2V0SW50MzIoNCwgdGhpcy5oaSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBCSS5WLmdldEJpZ1VpbnQ2NCgwLCB0cnVlKTtcbiAgICB9XG59XG4vKipcbiAqIHVsb25nIDAgc2luZ2xldG9uLlxuICovXG5QYlVMb25nLlpFUk8gPSBuZXcgUGJVTG9uZygwLCAwKTtcbi8qKlxuICogNjQtYml0IHNpZ25lZCBpbnRlZ2VyIGFzIHR3byAzMi1iaXQgdmFsdWVzLlxuICogQ29udmVydHMgYmV0d2VlbiBgc3RyaW5nYCwgYG51bWJlcmAgYW5kIGBiaWdpbnRgIHJlcHJlc2VudGF0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFBiTG9uZyBleHRlbmRzIFNoYXJlZFBiTG9uZyB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGluc3RhbmNlIGZyb20gYSBgc3RyaW5nYCwgYG51bWJlcmAgb3IgYGJpZ2ludGAuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKEJJKVxuICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIEZhbGxUaHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIjBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlpFUk87XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgaXMgbm8gaW50ZWdlcicpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEJJLkModmFsdWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuWkVSTztcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBCSS5DKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5aRVJPO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCBCSS5NSU4pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25lZCBsb25nIHRvbyBzbWFsbCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBCSS5NQVgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25lZCBsb25nIHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgICAgICAgICBCSS5WLnNldEJpZ0ludDY0KDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYkxvbmcoQkkuVi5nZXRJbnQzMigwLCB0cnVlKSwgQkkuVi5nZXRJbnQzMig0LCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIwXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5aRVJPO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFSRV9ERUNJTUFMX1NUUi50ZXN0KHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIGlzIG5vIGludGVnZXInKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IFttaW51cywgbG8sIGhpXSA9IGludDY0ZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW51cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhpID4gSEFMRl8yX1BXUl8zMiB8fCAoaGkgPT0gSEFMRl8yX1BXUl8zMiAmJiBsbyAhPSAwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25lZCBsb25nIHRvbyBzbWFsbCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhpID49IEhBTEZfMl9QV1JfMzIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25lZCBsb25nIHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGJsID0gbmV3IFBiTG9uZyhsbywgaGkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWludXMgPyBwYmwubmVnYXRlKCkgOiBwYmw7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlpFUk87XG4gICAgICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgaXMgbm8gaW50ZWdlcicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBQYkxvbmcodmFsdWUsIHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyBQYkxvbmcoLXZhbHVlLCAtdmFsdWUgLyBUV09fUFdSXzMyX0RCTCkubmVnYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biB2YWx1ZSAnICsgdHlwZW9mIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG8gd2UgaGF2ZSBhIG1pbnVzIHNpZ24/XG4gICAgICovXG4gICAgaXNOZWdhdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmhpICYgSEFMRl8yX1BXUl8zMikgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5lZ2F0ZSB0d28ncyBjb21wbGVtZW50LlxuICAgICAqIEludmVydCBhbGwgdGhlIGJpdHMgYW5kIGFkZCBvbmUgdG8gdGhlIHJlc3VsdC5cbiAgICAgKi9cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIGxldCBoaSA9IH50aGlzLmhpLCBsbyA9IHRoaXMubG87XG4gICAgICAgIGlmIChsbylcbiAgICAgICAgICAgIGxvID0gfmxvICsgMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaGkgKz0gMTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYkxvbmcobG8sIGhpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0byBkZWNpbWFsIHN0cmluZy5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKEJJKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CaWdJbnQoKS50b1N0cmluZygpO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICAgIGxldCBuID0gdGhpcy5uZWdhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiAnLScgKyBpbnQ2NHRvU3RyaW5nKG4ubG8sIG4uaGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnQ2NHRvU3RyaW5nKHRoaXMubG8sIHRoaXMuaGkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRvIG5hdGl2ZSBiaWdpbnQuXG4gICAgICovXG4gICAgdG9CaWdJbnQoKSB7XG4gICAgICAgIGFzc2VydEJpKEJJKTtcbiAgICAgICAgQkkuVi5zZXRJbnQzMigwLCB0aGlzLmxvLCB0cnVlKTtcbiAgICAgICAgQkkuVi5zZXRJbnQzMig0LCB0aGlzLmhpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIEJJLlYuZ2V0QmlnSW50NjQoMCwgdHJ1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiBsb25nIDAgc2luZ2xldG9uLlxuICovXG5QYkxvbmcuWkVSTyA9IG5ldyBQYkxvbmcoMCwgMCk7XG4iLCJpbXBvcnQgeyBVbmtub3duRmllbGRIYW5kbGVyLCBXaXJlVHlwZSB9IGZyb20gXCIuL2JpbmFyeS1mb3JtYXQtY29udHJhY3RcIjtcbmltcG9ydCB7IExvbmdUeXBlLCBTY2FsYXJUeXBlIH0gZnJvbSBcIi4vcmVmbGVjdGlvbi1pbmZvXCI7XG5pbXBvcnQgeyByZWZsZWN0aW9uTG9uZ0NvbnZlcnQgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWxvbmctY29udmVydFwiO1xuaW1wb3J0IHsgcmVmbGVjdGlvblNjYWxhckRlZmF1bHQgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLXNjYWxhci1kZWZhdWx0XCI7XG4vKipcbiAqIFJlYWRzIHByb3RvMyBtZXNzYWdlcyBpbiBiaW5hcnkgZm9ybWF0IHVzaW5nIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24uXG4gKlxuICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL2VuY29kaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWZsZWN0aW9uQmluYXJ5UmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpbmZvKSB7XG4gICAgICAgIHRoaXMuaW5mbyA9IGluZm87XG4gICAgfVxuICAgIHByZXBhcmUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkTm9Ub0ZpZWxkKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZHNJbnB1dCA9IChfYSA9IHRoaXMuaW5mby5maWVsZHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgdGhpcy5maWVsZE5vVG9GaWVsZCA9IG5ldyBNYXAoZmllbGRzSW5wdXQubWFwKGZpZWxkID0+IFtmaWVsZC5ubywgZmllbGRdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBtZXNzYWdlIGZyb20gYmluYXJ5IGZvcm1hdCBpbnRvIHRoZSB0YXJnZXQgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIFJlcGVhdGVkIGZpZWxkcyBhcmUgYXBwZW5kZWQuIE1hcCBlbnRyaWVzIGFyZSBhZGRlZCwgb3ZlcndyaXRpbmdcbiAgICAgKiBleGlzdGluZyBrZXlzLlxuICAgICAqXG4gICAgICogSWYgYSBtZXNzYWdlIGZpZWxkIGlzIGFscmVhZHkgcHJlc2VudCwgaXQgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGVcbiAgICAgKiBuZXcgZGF0YS5cbiAgICAgKi9cbiAgICByZWFkKHJlYWRlciwgbWVzc2FnZSwgb3B0aW9ucywgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZSgpO1xuICAgICAgICBjb25zdCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgLy8gcmVhZCB0aGUgdGFnIGFuZCBmaW5kIHRoZSBmaWVsZFxuICAgICAgICAgICAgY29uc3QgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKSwgZmllbGQgPSB0aGlzLmZpZWxkTm9Ub0ZpZWxkLmdldChmaWVsZE5vKTtcbiAgICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICBpZiAodSA9PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMuaW5mby50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLmluZm8udHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRhcmdldCBvYmplY3QgZm9yIHRoZSBmaWVsZCB3ZSBhcmUgcmVhZGluZ1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IG1lc3NhZ2UsIHJlcGVhdGVkID0gZmllbGQucmVwZWF0LCBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gICAgICAgICAgICAvLyBpZiBmaWVsZCBpcyBtZW1iZXIgb2Ygb25lb2YgQURULCB1c2UgQURUIGFzIHRhcmdldFxuICAgICAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W2ZpZWxkLm9uZW9mXTtcbiAgICAgICAgICAgICAgICAvLyBpZiBvdGhlciBvbmVvZiBtZW1iZXIgc2VsZWN0ZWQsIHNldCBuZXcgQURUXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5vbmVvZktpbmQgIT09IGxvY2FsTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gbWVzc2FnZVtmaWVsZC5vbmVvZl0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6IGxvY2FsTmFtZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UgaGF2ZSBoYW5kbGVkIG9uZW9mIGFib3ZlLCB3ZSBqdXN0IGhhdmUgcmVhZCB0aGUgdmFsdWUgaW50byBgdGFyZ2V0W2xvY2FsTmFtZV1gXG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgbGV0IFQgPSBmaWVsZC5raW5kID09IFwiZW51bVwiID8gU2NhbGFyVHlwZS5JTlQzMiA6IGZpZWxkLlQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBMID0gZmllbGQua2luZCA9PSBcInNjYWxhclwiID8gZmllbGQuTCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXJyID0gdGFyZ2V0W2xvY2FsTmFtZV07IC8vIHNhZmUgdG8gYXNzdW1lIHByZXNlbmNlIG9mIGFycmF5LCBvbmVvZiBjYW5ub3QgY29udGFpbiByZXBlYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQgJiYgVCAhPSBTY2FsYXJUeXBlLlNUUklORyAmJiBUICE9IFNjYWxhclR5cGUuQllURVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZSA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCh0aGlzLnNjYWxhcihyZWFkZXIsIFQsIEwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCh0aGlzLnNjYWxhcihyZWFkZXIsIFQsIEwpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHRoaXMuc2NhbGFyKHJlYWRlciwgVCwgTCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFyciA9IHRhcmdldFtsb2NhbE5hbWVdOyAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBhcnJheSwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbXNnID0gZmllbGQuVCgpLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChtc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gZmllbGQuVCgpLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgdGFyZ2V0W2xvY2FsTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgICAgIGxldCBbbWFwS2V5LCBtYXBWYWxdID0gdGhpcy5tYXBFbnRyeShmaWVsZCwgcmVhZGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgbWFwIG9iamVjdCwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdW21hcEtleV0gPSBtYXBWYWw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBtYXAgZmllbGQsIGV4cGVjdGluZyBrZXkgZmllbGQgPSAxLCB2YWx1ZSBmaWVsZCA9IDJcbiAgICAgKi9cbiAgICBtYXBFbnRyeShmaWVsZCwgcmVhZGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBsZW5ndGggPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgIGxldCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBsZXQga2V5ID0gdW5kZWZpbmVkOyAvLyBqYXZhc2NyaXB0IG9ubHkgYWxsb3dzIG51bWJlciBvciBzdHJpbmcgZm9yIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgICAgIGxldCB2YWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLksgPT0gU2NhbGFyVHlwZS5CT09MKVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gcmVhZGVyLmJvb2woKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb25nIHR5cGVzIGFyZSByZWFkIGFzIHN0cmluZywgbnVtYmVyIHR5cGVzIGFyZSBva2F5IGFzIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5zY2FsYXIocmVhZGVyLCBmaWVsZC5LLCBMb25nVHlwZS5TVFJJTkcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5zY2FsYXIocmVhZGVyLCBmaWVsZC5WLlQsIGZpZWxkLlYuTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBmaWVsZC5WLlQoKS5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGluIG1hcCBlbnRyeSBmb3IgJHt0aGlzLmluZm8udHlwZU5hbWV9IyR7ZmllbGQubmFtZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBrZXlSYXcgPSByZWZsZWN0aW9uU2NhbGFyRGVmYXVsdChmaWVsZC5LKTtcbiAgICAgICAgICAgIGtleSA9IGZpZWxkLksgPT0gU2NhbGFyVHlwZS5CT09MID8ga2V5UmF3LnRvU3RyaW5nKCkgOiBrZXlSYXc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHJlZmxlY3Rpb25TY2FsYXJEZWZhdWx0KGZpZWxkLlYuVCwgZmllbGQuVi5MKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gZmllbGQuVi5UKCkuY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2tleSwgdmFsXTtcbiAgICB9XG4gICAgc2NhbGFyKHJlYWRlciwgdHlwZSwgbG9uZ1R5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIuZG91YmxlKCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgICAgICAgICAgIHJldHVybiByZWZsZWN0aW9uTG9uZ0NvbnZlcnQocmVhZGVyLmludDY0KCksIGxvbmdUeXBlKTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3Rpb25Mb25nQ29udmVydChyZWFkZXIudWludDY0KCksIGxvbmdUeXBlKTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgICAgICAgICAgIHJldHVybiByZWZsZWN0aW9uTG9uZ0NvbnZlcnQocmVhZGVyLmZpeGVkNjQoKSwgbG9uZ1R5cGUpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5maXhlZDMyKCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIuc2ZpeGVkMzIoKTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmbGVjdGlvbkxvbmdDb252ZXJ0KHJlYWRlci5zZml4ZWQ2NCgpLCBsb25nVHlwZSk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIuc2ludDMyKCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgICAgICAgICAgIHJldHVybiByZWZsZWN0aW9uTG9uZ0NvbnZlcnQocmVhZGVyLnNpbnQ2NCgpLCBsb25nVHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBVbmtub3duRmllbGRIYW5kbGVyLCBXaXJlVHlwZSB9IGZyb20gXCIuL2JpbmFyeS1mb3JtYXQtY29udHJhY3RcIjtcbmltcG9ydCB7IFJlcGVhdFR5cGUsIFNjYWxhclR5cGUgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWluZm9cIjtcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuL2Fzc2VydFwiO1xuaW1wb3J0IHsgUGJMb25nLCBQYlVMb25nIH0gZnJvbSBcIi4vcGItbG9uZ1wiO1xuLyoqXG4gKiBXcml0ZXMgcHJvdG8zIG1lc3NhZ2VzIGluIGJpbmFyeSBmb3JtYXQgdXNpbmcgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvZW5jb2RpbmdcbiAqL1xuZXhwb3J0IGNsYXNzIFJlZmxlY3Rpb25CaW5hcnlXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGluZm8pIHtcbiAgICAgICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICB9XG4gICAgcHJlcGFyZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgZmllbGRzSW5wdXQgPSB0aGlzLmluZm8uZmllbGRzID8gdGhpcy5pbmZvLmZpZWxkcy5jb25jYXQoKSA6IFtdO1xuICAgICAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHNJbnB1dC5zb3J0KChhLCBiKSA9PiBhLm5vIC0gYi5ubyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIHRoZSBtZXNzYWdlIHRvIGJpbmFyeSBmb3JtYXQuXG4gICAgICovXG4gICAgd3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUsIC8vIHRoaXMgd2lsbCBiZSBvdXIgZmllbGQgdmFsdWUsIHdoZXRoZXIgaXQgaXMgbWVtYmVyIG9mIGEgb25lb2Ygb3Igbm90XG4gICAgICAgICAgICBlbWl0RGVmYXVsdCwgLy8gd2hldGhlciB3ZSBlbWl0IHRoZSBkZWZhdWx0IHZhbHVlIChvbmx5IHRydWUgZm9yIG9uZW9mIG1lbWJlcnMpXG4gICAgICAgICAgICByZXBlYXRlZCA9IGZpZWxkLnJlcGVhdCwgbG9jYWxOYW1lID0gZmllbGQubG9jYWxOYW1lO1xuICAgICAgICAgICAgLy8gaGFuZGxlIG9uZW9mIEFEVFxuICAgICAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBtZXNzYWdlW2ZpZWxkLm9uZW9mXTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAub25lb2ZLaW5kICE9PSBsb2NhbE5hbWUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBpZiBmaWVsZCBpcyBub3Qgc2VsZWN0ZWQsIHNraXBcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGdyb3VwW2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgZW1pdERlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtZXNzYWdlW2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgZW1pdERlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGhhdmUgaGFuZGxlZCBvbmVvZiBhYm92ZS4gd2UganVzdCBoYXZlIHRvIGhvbm9yIGBlbWl0RGVmYXVsdGAuXG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgbGV0IFQgPSBmaWVsZC5raW5kID09IFwiZW51bVwiID8gU2NhbGFyVHlwZS5JTlQzMiA6IGZpZWxkLlQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBlYXRlZCA9PSBSZXBlYXRUeXBlLlBBQ0tFRClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhY2tlZCh3cml0ZXIsIFQsIGZpZWxkLm5vLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYWxhcih3cml0ZXIsIFQsIGZpZWxkLm5vLCBpdGVtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZpZWxkLm9wdCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NhbGFyKHdyaXRlciwgVCwgZmllbGQubm8sIHZhbHVlLCBlbWl0RGVmYXVsdCB8fCBmaWVsZC5vcHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydChBcnJheS5pc0FycmF5KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlKHdyaXRlciwgb3B0aW9ucywgZmllbGQuVCgpLCBmaWVsZC5ubywgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2Uod3JpdGVyLCBvcHRpb25zLCBmaWVsZC5UKCksIGZpZWxkLm5vLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwRW50cnkod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwga2V5LCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMuaW5mby50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICB9XG4gICAgbWFwRW50cnkod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwga2V5LCB2YWx1ZSkge1xuICAgICAgICB3cml0ZXIudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpO1xuICAgICAgICB3cml0ZXIuZm9yaygpO1xuICAgICAgICAvLyBqYXZhc2NyaXB0IG9ubHkgYWxsb3dzIG51bWJlciBvciBzdHJpbmcgZm9yIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIHdlIGNvbnZlcnQgZnJvbSBvdXIgcmVwcmVzZW50YXRpb24gdG8gdGhlIHByb3RvYnVmIHR5cGVcbiAgICAgICAgbGV0IGtleVZhbHVlID0ga2V5O1xuICAgICAgICBzd2l0Y2ggKGZpZWxkLkspIHtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgICAgICAgICAga2V5VmFsdWUgPSBOdW1iZXIucGFyc2VJbnQoa2V5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgICAgIGFzc2VydChrZXkgPT0gJ3RydWUnIHx8IGtleSA9PSAnZmFsc2UnKTtcbiAgICAgICAgICAgICAgICBrZXlWYWx1ZSA9IGtleSA9PSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd3JpdGUga2V5LCBleHBlY3Rpbmcga2V5IGZpZWxkIG51bWJlciA9IDFcbiAgICAgICAgdGhpcy5zY2FsYXIod3JpdGVyLCBmaWVsZC5LLCAxLCBrZXlWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgIC8vIHdyaXRlIHZhbHVlLCBleHBlY3RpbmcgdmFsdWUgZmllbGQgbnVtYmVyID0gMlxuICAgICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxhcih3cml0ZXIsIGZpZWxkLlYuVCwgMiwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZW51bSc6XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsYXIod3JpdGVyLCBTY2FsYXJUeXBlLklOVDMyLCAyLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2Uod3JpdGVyLCBvcHRpb25zLCBmaWVsZC5WLlQoKSwgMiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5qb2luKCk7XG4gICAgfVxuICAgIG1lc3NhZ2Uod3JpdGVyLCBvcHRpb25zLCBoYW5kbGVyLCBmaWVsZE5vLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaGFuZGxlci5pbnRlcm5hbEJpbmFyeVdyaXRlKHZhbHVlLCB3cml0ZXIudGFnKGZpZWxkTm8sIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKTtcbiAgICAgICAgd3JpdGVyLmpvaW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBzaW5nbGUgc2NhbGFyIHZhbHVlLlxuICAgICAqL1xuICAgIHNjYWxhcih3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlLCBlbWl0RGVmYXVsdCkge1xuICAgICAgICBsZXQgW3dpcmVUeXBlLCBtZXRob2QsIGlzRGVmYXVsdF0gPSB0aGlzLnNjYWxhckluZm8odHlwZSwgdmFsdWUpO1xuICAgICAgICBpZiAoIWlzRGVmYXVsdCB8fCBlbWl0RGVmYXVsdCkge1xuICAgICAgICAgICAgd3JpdGVyLnRhZyhmaWVsZE5vLCB3aXJlVHlwZSk7XG4gICAgICAgICAgICB3cml0ZXJbbWV0aG9kXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYW4gYXJyYXkgb2Ygc2NhbGFyIHZhbHVlcyBpbiBwYWNrZWQgZm9ybWF0LlxuICAgICAqL1xuICAgIHBhY2tlZCh3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBhc3NlcnQodHlwZSAhPT0gU2NhbGFyVHlwZS5CWVRFUyAmJiB0eXBlICE9PSBTY2FsYXJUeXBlLlNUUklORyk7XG4gICAgICAgIC8vIHdyaXRlIHRhZ1xuICAgICAgICB3cml0ZXIudGFnKGZpZWxkTm8sIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCk7XG4gICAgICAgIC8vIGJlZ2luIGxlbmd0aC1kZWxpbWl0ZWRcbiAgICAgICAgd3JpdGVyLmZvcmsoKTtcbiAgICAgICAgLy8gd3JpdGUgdmFsdWVzIHdpdGhvdXQgdGFnc1xuICAgICAgICBsZXQgWywgbWV0aG9kLF0gPSB0aGlzLnNjYWxhckluZm8odHlwZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXJbbWV0aG9kXSh2YWx1ZVtpXSk7XG4gICAgICAgIC8vIGVuZCBsZW5ndGggZGVsaW1pdGVkXG4gICAgICAgIHdyaXRlci5qb2luKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBpbmZvcm1hdGlvbiBmb3Igd3JpdGluZyBhIHNjYWxhciB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFJldHVybnMgdHVwbGU6XG4gICAgICogWzBdOiBhcHByb3ByaWF0ZSBXaXJlVHlwZVxuICAgICAqIFsxXTogbmFtZSBvZiB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIG9mIElCaW5hcnlXcml0ZXJcbiAgICAgKiBbMl06IHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZGVmYXVsdCB2YWx1ZVxuICAgICAqXG4gICAgICogSWYgYXJndW1lbnQgYHZhbHVlYCBpcyBvbWl0dGVkLCBbMl0gaXMgYWx3YXlzIGZhbHNlLlxuICAgICAqL1xuICAgIHNjYWxhckluZm8odHlwZSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IHQgPSBXaXJlVHlwZS5WYXJpbnQ7XG4gICAgICAgIGxldCBtO1xuICAgICAgICBsZXQgaSA9IHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBkID0gdmFsdWUgPT09IDA7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgICAgICAgICAgICAgIG0gPSBcImludDMyXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgICAgIGQgPSBpIHx8ICF2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdCA9IFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDtcbiAgICAgICAgICAgICAgICBtID0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgICAgIGQgPSB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbSA9IFwiYm9vbFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgICAgICAgICBtID0gXCJ1aW50MzJcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgICAgICAgICAgICAgdCA9IFdpcmVUeXBlLkJpdDY0O1xuICAgICAgICAgICAgICAgIG0gPSBcImRvdWJsZVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgICAgICAgICAgIHQgPSBXaXJlVHlwZS5CaXQzMjtcbiAgICAgICAgICAgICAgICBtID0gXCJmbG9hdFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgICAgICAgICAgIGQgPSBpIHx8IFBiTG9uZy5mcm9tKHZhbHVlKS5pc1plcm8oKTtcbiAgICAgICAgICAgICAgICBtID0gXCJpbnQ2NFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgICAgICAgICAgICBkID0gaSB8fCBQYlVMb25nLmZyb20odmFsdWUpLmlzWmVybygpO1xuICAgICAgICAgICAgICAgIG0gPSBcInVpbnQ2NFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgICAgICAgICAgICAgZCA9IGkgfHwgUGJVTG9uZy5mcm9tKHZhbHVlKS5pc1plcm8oKTtcbiAgICAgICAgICAgICAgICB0ID0gV2lyZVR5cGUuQml0NjQ7XG4gICAgICAgICAgICAgICAgbSA9IFwiZml4ZWQ2NFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgICAgICAgICAgIGQgPSBpIHx8ICF2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHQgPSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQ7XG4gICAgICAgICAgICAgICAgbSA9IFwiYnl0ZXNcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICAgICAgICAgIHQgPSBXaXJlVHlwZS5CaXQzMjtcbiAgICAgICAgICAgICAgICBtID0gXCJmaXhlZDMyXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgICAgICAgICAgdCA9IFdpcmVUeXBlLkJpdDMyO1xuICAgICAgICAgICAgICAgIG0gPSBcInNmaXhlZDMyXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgICAgICAgICAgICAgZCA9IGkgfHwgUGJMb25nLmZyb20odmFsdWUpLmlzWmVybygpO1xuICAgICAgICAgICAgICAgIHQgPSBXaXJlVHlwZS5CaXQ2NDtcbiAgICAgICAgICAgICAgICBtID0gXCJzZml4ZWQ2NFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICAgICAgICAgICAgICBtID0gXCJzaW50MzJcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICAgICAgZCA9IGkgfHwgUGJMb25nLmZyb20odmFsdWUpLmlzWmVybygpO1xuICAgICAgICAgICAgICAgIG0gPSBcInNpbnQ2NFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdCwgbSwgaSB8fCBkXTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyByZWZsZWN0aW9uU2NhbGFyRGVmYXVsdCB9IGZyb20gXCIuL3JlZmxlY3Rpb24tc2NhbGFyLWRlZmF1bHRcIjtcbmltcG9ydCB7IE1FU1NBR0VfVFlQRSB9IGZyb20gJy4vbWVzc2FnZS10eXBlLWNvbnRyYWN0Jztcbi8qKlxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgZ2VuZXJpYyBtZXNzYWdlLCB1c2luZyB0aGUgZmllbGRcbiAqIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVmbGVjdGlvbkNyZWF0ZSh0eXBlKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyB0ZXJuYXJ5IGNhbiBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAgICogVGhlIGBPYmplY3QuY3JlYXRlKClgIGNvZGUgcGF0aCB1dGlsaXplcyBhIG5ldyBgbWVzc2FnZVByb3RvdHlwZWBcbiAgICAgKiBwcm9wZXJ0eSBvbiB0aGUgYElNZXNzYWdlVHlwZWAgd2hpY2ggaGFzIHRoaXMgc2FtZSBgTUVTU0FHRV9UWVBFYFxuICAgICAqIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIGl0LiBEb2luZyBpdCB0aGlzIHdheSBtZWFucyB0aGF0IHdlIG9ubHlcbiAgICAgKiBwYXkgdGhlIGNvc3Qgb2YgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpYCBvbmNlIHBlciBgSU1lc3NhZ2VUeXBlYFxuICAgICAqIGNsYXNzIG9mIG9uY2UgcGVyIFwiaW5zdGFuY2VcIi4gVGhlIGZhbHN5IGNvZGUgcGF0aCBpcyBvbmx5IHByb3ZpZGVkXG4gICAgICogZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGluIGNhc2VzIHdoZXJlIHRoZSBydW50aW1lIGxpYnJhcnkgaXNcbiAgICAgKiB1cGRhdGVkIHdpdGhvdXQgYWxzbyB1cGRhdGluZyB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4gICAgICovXG4gICAgY29uc3QgbXNnID0gdHlwZS5tZXNzYWdlUHJvdG90eXBlXG4gICAgICAgID8gT2JqZWN0LmNyZWF0ZSh0eXBlLm1lc3NhZ2VQcm90b3R5cGUpXG4gICAgICAgIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBNRVNTQUdFX1RZUEUsIHsgdmFsdWU6IHR5cGUgfSk7XG4gICAgZm9yIChsZXQgZmllbGQgb2YgdHlwZS5maWVsZHMpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gICAgICAgIGlmIChmaWVsZC5vcHQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGZpZWxkLm9uZW9mKVxuICAgICAgICAgICAgbXNnW2ZpZWxkLm9uZW9mXSA9IHsgb25lb2ZLaW5kOiB1bmRlZmluZWQgfTtcbiAgICAgICAgZWxzZSBpZiAoZmllbGQucmVwZWF0KVxuICAgICAgICAgICAgbXNnW25hbWVdID0gW107XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgbXNnW25hbWVdID0gcmVmbGVjdGlvblNjYWxhckRlZmF1bHQoZmllbGQuVCwgZmllbGQuTCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHJlcXVpcmUgMCB0byBiZSBkZWZhdWx0IHZhbHVlIGZvciBhbGwgZW51bXNcbiAgICAgICAgICAgICAgICAgICAgbXNnW25hbWVdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgICAgICBtc2dbbmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtc2c7XG59XG4iLCJpbXBvcnQgeyBTY2FsYXJUeXBlIH0gZnJvbSBcIi4vcmVmbGVjdGlvbi1pbmZvXCI7XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0d28gbWVzc2FnZSBvZiB0aGUgc2FtZSB0eXBlIGhhdmUgdGhlIHNhbWUgZmllbGQgdmFsdWVzLlxuICogQ2hlY2tzIGZvciBkZWVwIGVxdWFsaXR5LCB0cmF2ZXJzaW5nIHJlcGVhdGVkIGZpZWxkcywgb25lb2YgZ3JvdXBzLCBtYXBzXG4gKiBhbmQgbWVzc2FnZXMgcmVjdXJzaXZlbHkuXG4gKiBXaWxsIGFsc28gcmV0dXJuIHRydWUgaWYgYm90aCBtZXNzYWdlcyBhcmUgYHVuZGVmaW5lZGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWZsZWN0aW9uRXF1YWxzKGluZm8sIGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFhIHx8ICFiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgZmllbGQgb2YgaW5mby5maWVsZHMpIHtcbiAgICAgICAgbGV0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgICAgICAgbGV0IHZhbF9hID0gZmllbGQub25lb2YgPyBhW2ZpZWxkLm9uZW9mXVtsb2NhbE5hbWVdIDogYVtsb2NhbE5hbWVdO1xuICAgICAgICBsZXQgdmFsX2IgPSBmaWVsZC5vbmVvZiA/IGJbZmllbGQub25lb2ZdW2xvY2FsTmFtZV0gOiBiW2xvY2FsTmFtZV07XG4gICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICBsZXQgdCA9IGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgPyBTY2FsYXJUeXBlLklOVDMyIDogZmllbGQuVDtcbiAgICAgICAgICAgICAgICBpZiAoIShmaWVsZC5yZXBlYXRcbiAgICAgICAgICAgICAgICAgICAgPyByZXBlYXRlZFByaW1pdGl2ZUVxKHQsIHZhbF9hLCB2YWxfYilcbiAgICAgICAgICAgICAgICAgICAgOiBwcmltaXRpdmVFcSh0LCB2YWxfYSwgdmFsX2IpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgIGlmICghKGZpZWxkLlYua2luZCA9PSBcIm1lc3NhZ2VcIlxuICAgICAgICAgICAgICAgICAgICA/IHJlcGVhdGVkTXNnRXEoZmllbGQuVi5UKCksIG9iamVjdFZhbHVlcyh2YWxfYSksIG9iamVjdFZhbHVlcyh2YWxfYikpXG4gICAgICAgICAgICAgICAgICAgIDogcmVwZWF0ZWRQcmltaXRpdmVFcShmaWVsZC5WLmtpbmQgPT0gXCJlbnVtXCIgPyBTY2FsYXJUeXBlLklOVDMyIDogZmllbGQuVi5ULCBvYmplY3RWYWx1ZXModmFsX2EpLCBvYmplY3RWYWx1ZXModmFsX2IpKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgbGV0IFQgPSBmaWVsZC5UKCk7XG4gICAgICAgICAgICAgICAgaWYgKCEoZmllbGQucmVwZWF0XG4gICAgICAgICAgICAgICAgICAgID8gcmVwZWF0ZWRNc2dFcShULCB2YWxfYSwgdmFsX2IpXG4gICAgICAgICAgICAgICAgICAgIDogVC5lcXVhbHModmFsX2EsIHZhbF9iKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IG9iamVjdFZhbHVlcyA9IE9iamVjdC52YWx1ZXM7XG5mdW5jdGlvbiBwcmltaXRpdmVFcSh0eXBlLCBhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlICE9PSBTY2FsYXJUeXBlLkJZVEVTKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGJhID0gYTtcbiAgICBsZXQgYmIgPSBiO1xuICAgIGlmIChiYS5sZW5ndGggIT09IGJiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChiYVtpXSAhPSBiYltpXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlcGVhdGVkUHJpbWl0aXZlRXEodHlwZSwgYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghcHJpbWl0aXZlRXEodHlwZSwgYVtpXSwgYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZXBlYXRlZE1zZ0VxKHR5cGUsIGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIXR5cGUuZXF1YWxzKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuIiwiaW1wb3J0IHsgbG93ZXJDYW1lbENhc2UgfSBmcm9tIFwiLi9sb3dlci1jYW1lbC1jYXNlXCI7XG4vKipcbiAqIFNjYWxhciB2YWx1ZSB0eXBlcy4gVGhpcyBpcyBhIHN1YnNldCBvZiBmaWVsZCB0eXBlcyBkZWNsYXJlZCBieSBwcm90b2J1ZlxuICogZW51bSBnb29nbGUucHJvdG9idWYuRmllbGREZXNjcmlwdG9yUHJvdG8uVHlwZSBUaGUgdHlwZXMgR1JPVVAgYW5kIE1FU1NBR0VcbiAqIGFyZSBvbWl0dGVkLCBidXQgdGhlIG51bWVyaWNhbCB2YWx1ZXMgYXJlIGlkZW50aWNhbC5cbiAqL1xuZXhwb3J0IHZhciBTY2FsYXJUeXBlO1xuKGZ1bmN0aW9uIChTY2FsYXJUeXBlKSB7XG4gICAgLy8gMCBpcyByZXNlcnZlZCBmb3IgZXJyb3JzLlxuICAgIC8vIE9yZGVyIGlzIHdlaXJkIGZvciBoaXN0b3JpY2FsIHJlYXNvbnMuXG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRE9VQkxFXCJdID0gMV0gPSBcIkRPVUJMRVwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZMT0FUXCJdID0gMl0gPSBcIkZMT0FUXCI7XG4gICAgLy8gTm90IFppZ1phZyBlbmNvZGVkLiAgTmVnYXRpdmUgbnVtYmVycyB0YWtlIDEwIGJ5dGVzLiAgVXNlIFRZUEVfU0lOVDY0IGlmXG4gICAgLy8gbmVnYXRpdmUgdmFsdWVzIGFyZSBsaWtlbHkuXG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiSU5UNjRcIl0gPSAzXSA9IFwiSU5UNjRcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJVSU5UNjRcIl0gPSA0XSA9IFwiVUlOVDY0XCI7XG4gICAgLy8gTm90IFppZ1phZyBlbmNvZGVkLiAgTmVnYXRpdmUgbnVtYmVycyB0YWtlIDEwIGJ5dGVzLiAgVXNlIFRZUEVfU0lOVDMyIGlmXG4gICAgLy8gbmVnYXRpdmUgdmFsdWVzIGFyZSBsaWtlbHkuXG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiSU5UMzJcIl0gPSA1XSA9IFwiSU5UMzJcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJGSVhFRDY0XCJdID0gNl0gPSBcIkZJWEVENjRcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJGSVhFRDMyXCJdID0gN10gPSBcIkZJWEVEMzJcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJCT09MXCJdID0gOF0gPSBcIkJPT0xcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTVFJJTkdcIl0gPSA5XSA9IFwiU1RSSU5HXCI7XG4gICAgLy8gVGFnLWRlbGltaXRlZCBhZ2dyZWdhdGUuXG4gICAgLy8gR3JvdXAgdHlwZSBpcyBkZXByZWNhdGVkIGFuZCBub3Qgc3VwcG9ydGVkIGluIHByb3RvMy4gSG93ZXZlciwgUHJvdG8zXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIHNob3VsZCBzdGlsbCBiZSBhYmxlIHRvIHBhcnNlIHRoZSBncm91cCB3aXJlIGZvcm1hdCBhbmRcbiAgICAvLyB0cmVhdCBncm91cCBmaWVsZHMgYXMgdW5rbm93biBmaWVsZHMuXG4gICAgLy8gVFlQRV9HUk9VUCA9IDEwLFxuICAgIC8vIFRZUEVfTUVTU0FHRSA9IDExLCAgLy8gTGVuZ3RoLWRlbGltaXRlZCBhZ2dyZWdhdGUuXG4gICAgLy8gTmV3IGluIHZlcnNpb24gMi5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJCWVRFU1wiXSA9IDEyXSA9IFwiQllURVNcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJVSU5UMzJcIl0gPSAxM10gPSBcIlVJTlQzMlwiO1xuICAgIC8vIFRZUEVfRU5VTSA9IDE0LFxuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNGSVhFRDMyXCJdID0gMTVdID0gXCJTRklYRUQzMlwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNGSVhFRDY0XCJdID0gMTZdID0gXCJTRklYRUQ2NFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNJTlQzMlwiXSA9IDE3XSA9IFwiU0lOVDMyXCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0lOVDY0XCJdID0gMThdID0gXCJTSU5UNjRcIjtcbn0pKFNjYWxhclR5cGUgfHwgKFNjYWxhclR5cGUgPSB7fSkpO1xuLyoqXG4gKiBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIDY0IGJpdCBpbnRlZ3JhbCB0eXBlcy4gRXF1aXZhbGVudCB0byB0aGVcbiAqIGZpZWxkIG9wdGlvbiBcImpzdHlwZVwiLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHByb3RvYnVmLXRzIHJlcHJlc2VudHMgNjQgYml0IHR5cGVzIGFzIGBiaWdpbnRgLlxuICpcbiAqIFlvdSBjYW4gY2hhbmdlIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBieSBlbmFibGluZyB0aGUgcGx1Z2luIHBhcmFtZXRlclxuICogYGxvbmdfdHlwZV9zdHJpbmdgLCB3aGljaCB3aWxsIHJlcHJlc2VudCA2NCBiaXQgdHlwZXMgYXMgYHN0cmluZ2AuXG4gKlxuICogQWx0ZXJuYXRpdmVseSwgeW91IGNhbiBjaGFuZ2UgdGhlIGJlaGF2aW91ciBmb3IgaW5kaXZpZHVhbCBmaWVsZHNcbiAqIHdpdGggdGhlIGZpZWxkIG9wdGlvbiBcImpzdHlwZVwiOlxuICpcbiAqIGBgYHByb3RvYnVmXG4gKiB1aW50NjQgbXlfZmllbGQgPSAxIFtqc3R5cGUgPSBKU19TVFJJTkddO1xuICogdWludDY0IG90aGVyX2ZpZWxkID0gMiBbanN0eXBlID0gSlNfTlVNQkVSXTtcbiAqIGBgYFxuICovXG5leHBvcnQgdmFyIExvbmdUeXBlO1xuKGZ1bmN0aW9uIChMb25nVHlwZSkge1xuICAgIC8qKlxuICAgICAqIFVzZSBKYXZhU2NyaXB0IGBiaWdpbnRgLlxuICAgICAqXG4gICAgICogRmllbGQgb3B0aW9uIGBbanN0eXBlID0gSlNfTk9STUFMXWAuXG4gICAgICovXG4gICAgTG9uZ1R5cGVbTG9uZ1R5cGVbXCJCSUdJTlRcIl0gPSAwXSA9IFwiQklHSU5UXCI7XG4gICAgLyoqXG4gICAgICogVXNlIEphdmFTY3JpcHQgYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBGaWVsZCBvcHRpb24gYFtqc3R5cGUgPSBKU19TVFJJTkddYC5cbiAgICAgKi9cbiAgICBMb25nVHlwZVtMb25nVHlwZVtcIlNUUklOR1wiXSA9IDFdID0gXCJTVFJJTkdcIjtcbiAgICAvKipcbiAgICAgKiBVc2UgSmF2YVNjcmlwdCBgbnVtYmVyYC5cbiAgICAgKlxuICAgICAqIExhcmdlIHZhbHVlcyB3aWxsIGxvb3NlIHByZWNpc2lvbi5cbiAgICAgKlxuICAgICAqIEZpZWxkIG9wdGlvbiBgW2pzdHlwZSA9IEpTX05VTUJFUl1gLlxuICAgICAqL1xuICAgIExvbmdUeXBlW0xvbmdUeXBlW1wiTlVNQkVSXCJdID0gMl0gPSBcIk5VTUJFUlwiO1xufSkoTG9uZ1R5cGUgfHwgKExvbmdUeXBlID0ge30pKTtcbi8qKlxuICogUHJvdG9idWYgMi4xLjAgaW50cm9kdWNlZCBwYWNrZWQgcmVwZWF0ZWQgZmllbGRzLlxuICogU2V0dGluZyB0aGUgZmllbGQgb3B0aW9uIGBbcGFja2VkID0gdHJ1ZV1gIGVuYWJsZXMgcGFja2luZy5cbiAqXG4gKiBJbiBwcm90bzMsIGFsbCByZXBlYXRlZCBmaWVsZHMgYXJlIHBhY2tlZCBieSBkZWZhdWx0LlxuICogU2V0dGluZyB0aGUgZmllbGQgb3B0aW9uIGBbcGFja2VkID0gZmFsc2VdYCBkaXNhYmxlcyBwYWNraW5nLlxuICpcbiAqIFBhY2tlZCByZXBlYXRlZCBmaWVsZHMgYXJlIGVuY29kZWQgd2l0aCBhIHNpbmdsZSB0YWcsXG4gKiB0aGVuIGEgbGVuZ3RoLWRlbGltaXRlciwgdGhlbiB0aGUgZWxlbWVudCB2YWx1ZXMuXG4gKlxuICogVW5wYWNrZWQgcmVwZWF0ZWQgZmllbGRzIGFyZSBlbmNvZGVkIHdpdGggYSB0YWcgYW5kXG4gKiB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50LlxuICpcbiAqIGBieXRlc2AgYW5kIGBzdHJpbmdgIGNhbm5vdCBiZSBwYWNrZWQuXG4gKi9cbmV4cG9ydCB2YXIgUmVwZWF0VHlwZTtcbihmdW5jdGlvbiAoUmVwZWF0VHlwZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCBpcyBub3QgcmVwZWF0ZWQuXG4gICAgICovXG4gICAgUmVwZWF0VHlwZVtSZXBlYXRUeXBlW1wiTk9cIl0gPSAwXSA9IFwiTk9cIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZmllbGQgaXMgcmVwZWF0ZWQgYW5kIHNob3VsZCBiZSBwYWNrZWQuXG4gICAgICogSW52YWxpZCBmb3IgYGJ5dGVzYCBhbmQgYHN0cmluZ2AsIHRoZXkgY2Fubm90IGJlIHBhY2tlZC5cbiAgICAgKi9cbiAgICBSZXBlYXRUeXBlW1JlcGVhdFR5cGVbXCJQQUNLRURcIl0gPSAxXSA9IFwiUEFDS0VEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGZpZWxkIGlzIHJlcGVhdGVkIGJ1dCBzaG91bGQgbm90IGJlIHBhY2tlZC5cbiAgICAgKiBUaGUgb25seSB2YWxpZCByZXBlYXQgdHlwZSBmb3IgcmVwZWF0ZWQgYGJ5dGVzYCBhbmQgYHN0cmluZ2AuXG4gICAgICovXG4gICAgUmVwZWF0VHlwZVtSZXBlYXRUeXBlW1wiVU5QQUNLRURcIl0gPSAyXSA9IFwiVU5QQUNLRURcIjtcbn0pKFJlcGVhdFR5cGUgfHwgKFJlcGVhdFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBUdXJucyBQYXJ0aWFsRmllbGRJbmZvIGludG8gRmllbGRJbmZvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRmllbGRJbmZvKGZpZWxkKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGZpZWxkLmxvY2FsTmFtZSA9IChfYSA9IGZpZWxkLmxvY2FsTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbG93ZXJDYW1lbENhc2UoZmllbGQubmFtZSk7XG4gICAgZmllbGQuanNvbk5hbWUgPSAoX2IgPSBmaWVsZC5qc29uTmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbG93ZXJDYW1lbENhc2UoZmllbGQubmFtZSk7XG4gICAgZmllbGQucmVwZWF0ID0gKF9jID0gZmllbGQucmVwZWF0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBSZXBlYXRUeXBlLk5PO1xuICAgIGZpZWxkLm9wdCA9IChfZCA9IGZpZWxkLm9wdCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogKGZpZWxkLnJlcGVhdCA/IGZhbHNlIDogZmllbGQub25lb2YgPyBmYWxzZSA6IGZpZWxkLmtpbmQgPT0gXCJtZXNzYWdlXCIpO1xuICAgIHJldHVybiBmaWVsZDtcbn1cbi8qKlxuICogUmVhZCBjdXN0b20gZmllbGQgb3B0aW9ucyBmcm9tIGEgZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCB1c2UgcmVhZEZpZWxkT3B0aW9uKClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRGaWVsZE9wdGlvbnMobWVzc2FnZVR5cGUsIGZpZWxkTmFtZSwgZXh0ZW5zaW9uTmFtZSwgZXh0ZW5zaW9uVHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBvcHRpb25zID0gKF9hID0gbWVzc2FnZVR5cGUuZmllbGRzLmZpbmQoKG0sIGkpID0+IG0ubG9jYWxOYW1lID09IGZpZWxkTmFtZSB8fCBpID09IGZpZWxkTmFtZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpb25zO1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnNbZXh0ZW5zaW9uTmFtZV0gPyBleHRlbnNpb25UeXBlLmZyb21Kc29uKG9wdGlvbnNbZXh0ZW5zaW9uTmFtZV0pIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRGaWVsZE9wdGlvbihtZXNzYWdlVHlwZSwgZmllbGROYW1lLCBleHRlbnNpb25OYW1lLCBleHRlbnNpb25UeXBlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG9wdGlvbnMgPSAoX2EgPSBtZXNzYWdlVHlwZS5maWVsZHMuZmluZCgobSwgaSkgPT4gbS5sb2NhbE5hbWUgPT0gZmllbGROYW1lIHx8IGkgPT0gZmllbGROYW1lKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGlvbnM7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvblZhbCA9IG9wdGlvbnNbZXh0ZW5zaW9uTmFtZV07XG4gICAgaWYgKG9wdGlvblZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25WYWw7XG4gICAgfVxuICAgIHJldHVybiBleHRlbnNpb25UeXBlID8gZXh0ZW5zaW9uVHlwZS5mcm9tSnNvbihvcHRpb25WYWwpIDogb3B0aW9uVmFsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRNZXNzYWdlT3B0aW9uKG1lc3NhZ2VUeXBlLCBleHRlbnNpb25OYW1lLCBleHRlbnNpb25UeXBlKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lc3NhZ2VUeXBlLm9wdGlvbnM7XG4gICAgY29uc3Qgb3B0aW9uVmFsID0gb3B0aW9uc1tleHRlbnNpb25OYW1lXTtcbiAgICBpZiAob3B0aW9uVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvblZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuc2lvblR5cGUgPyBleHRlbnNpb25UeXBlLmZyb21Kc29uKG9wdGlvblZhbCkgOiBvcHRpb25WYWw7XG59XG4iLCJpbXBvcnQgeyBpc0pzb25PYmplY3QsIHR5cGVvZkpzb25WYWx1ZSB9IGZyb20gXCIuL2pzb24tdHlwaW5nc1wiO1xuaW1wb3J0IHsgYmFzZTY0ZGVjb2RlIH0gZnJvbSBcIi4vYmFzZTY0XCI7XG5pbXBvcnQgeyBMb25nVHlwZSwgU2NhbGFyVHlwZSB9IGZyb20gXCIuL3JlZmxlY3Rpb24taW5mb1wiO1xuaW1wb3J0IHsgUGJMb25nLCBQYlVMb25nIH0gZnJvbSBcIi4vcGItbG9uZ1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRGbG9hdDMyLCBhc3NlcnRJbnQzMiwgYXNzZXJ0VUludDMyIH0gZnJvbSBcIi4vYXNzZXJ0XCI7XG5pbXBvcnQgeyByZWZsZWN0aW9uTG9uZ0NvbnZlcnQgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWxvbmctY29udmVydFwiO1xuLyoqXG4gKiBSZWFkcyBwcm90bzMgbWVzc2FnZXMgaW4gY2Fub25pY2FsIEpTT04gZm9ybWF0IHVzaW5nIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24uXG4gKlxuICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL3Byb3RvMyNqc29uXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWZsZWN0aW9uSnNvblJlYWRlciB7XG4gICAgY29uc3RydWN0b3IoaW5mbykge1xuICAgICAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgIH1cbiAgICBwcmVwYXJlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmZNYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5mTWFwID0ge307XG4gICAgICAgICAgICBjb25zdCBmaWVsZHNJbnB1dCA9IChfYSA9IHRoaXMuaW5mby5maWVsZHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHNJbnB1dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZk1hcFtmaWVsZC5uYW1lXSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgIHRoaXMuZk1hcFtmaWVsZC5qc29uTmFtZV0gPSBmaWVsZDtcbiAgICAgICAgICAgICAgICB0aGlzLmZNYXBbZmllbGQubG9jYWxOYW1lXSA9IGZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENhbm5vdCBwYXJzZSBKU09OIDx0eXBlIG9mIGpzb25WYWx1ZT4gZm9yIDx0eXBlIG5hbWU+IzxmaWVsZE5hbWU+LlxuICAgIGFzc2VydChjb25kaXRpb24sIGZpZWxkTmFtZSwganNvblZhbHVlKSB7XG4gICAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgICAgICBsZXQgd2hhdCA9IHR5cGVvZkpzb25WYWx1ZShqc29uVmFsdWUpO1xuICAgICAgICAgICAgaWYgKHdoYXQgPT0gXCJudW1iZXJcIiB8fCB3aGF0ID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgICAgIHdoYXQgPSBqc29uVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHBhcnNlIEpTT04gJHt3aGF0fSBmb3IgJHt0aGlzLmluZm8udHlwZU5hbWV9IyR7ZmllbGROYW1lfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgbWVzc2FnZSBmcm9tIGNhbm9uaWNhbCBKU09OIGZvcm1hdCBpbnRvIHRoZSB0YXJnZXQgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIFJlcGVhdGVkIGZpZWxkcyBhcmUgYXBwZW5kZWQuIE1hcCBlbnRyaWVzIGFyZSBhZGRlZCwgb3ZlcndyaXRpbmdcbiAgICAgKiBleGlzdGluZyBrZXlzLlxuICAgICAqXG4gICAgICogSWYgYSBtZXNzYWdlIGZpZWxkIGlzIGFscmVhZHkgcHJlc2VudCwgaXQgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGVcbiAgICAgKiBuZXcgZGF0YS5cbiAgICAgKi9cbiAgICByZWFkKGlucHV0LCBtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZSgpO1xuICAgICAgICBjb25zdCBvbmVvZnNIYW5kbGVkID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2pzb25LZXksIGpzb25WYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZk1hcFtqc29uS2V5XTtcbiAgICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCB1bmtub3duIGZpZWxkIHdoaWxlIHJlYWRpbmcgJHt0aGlzLmluZm8udHlwZU5hbWV9IGZyb20gSlNPTiBmb3JtYXQuIEpTT04ga2V5OiAke2pzb25LZXl9YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gICAgICAgICAgICAvLyBoYW5kbGUgb25lb2YgQURUXG4gICAgICAgICAgICBsZXQgdGFyZ2V0OyAvLyB0aGlzIHdpbGwgYmUgdGhlIHRhcmdldCBmb3IgdGhlIGZpZWxkIHZhbHVlLCB3aGV0aGVyIGl0IGlzIG1lbWJlciBvZiBhIG9uZW9mIG9yIG5vdFxuICAgICAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCAmJiAoZmllbGQua2luZCAhPT0gJ2VudW0nIHx8IGZpZWxkLlQoKVswXSAhPT0gJ2dvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWUnKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc2luY2UganNvbiBvYmplY3RzIGFyZSB1bm9yZGVyZWQgYnkgc3BlY2lmaWNhdGlvbiwgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHRha2UgdGhlIGxhc3Qgb2YgbXVsdGlwbGUgb25lb2ZzXG4gICAgICAgICAgICAgICAgaWYgKG9uZW9mc0hhbmRsZWQuaW5jbHVkZXMoZmllbGQub25lb2YpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpcGxlIG1lbWJlcnMgb2YgdGhlIG9uZW9mIGdyb3VwIFwiJHtmaWVsZC5vbmVvZn1cIiBvZiAke3RoaXMuaW5mby50eXBlTmFtZX0gYXJlIHByZXNlbnQgaW4gSlNPTi5gKTtcbiAgICAgICAgICAgICAgICBvbmVvZnNIYW5kbGVkLnB1c2goZmllbGQub25lb2YpO1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IG1lc3NhZ2VbZmllbGQub25lb2ZdID0ge1xuICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6IGxvY2FsTmFtZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UgaGF2ZSBoYW5kbGVkIG9uZW9mIGFib3ZlLiB3ZSBqdXN0IGhhdmUgcmVhZCB0aGUgdmFsdWUgaW50byBgdGFyZ2V0YC5cbiAgICAgICAgICAgIGlmIChmaWVsZC5raW5kID09ICdtYXAnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaW5wdXRcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2VydChpc0pzb25PYmplY3QoanNvblZhbHVlKSwgZmllbGQubmFtZSwganNvblZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBvdXIgdGFyZ2V0IHRvIHB1dCBtYXAgZW50cmllcyBpbnRvXG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRPYmogPSB0YXJnZXRbbG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICAvLyByZWFkIGVudHJpZXNcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtqc29uT2JqS2V5LCBqc29uT2JqVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGpzb25WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc3NlcnQoanNvbk9ialZhbHVlICE9PSBudWxsLCBmaWVsZC5uYW1lICsgXCIgbWFwIHZhbHVlXCIsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZWFkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWw7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGZpZWxkLlYuVCgpLmludGVybmFsSnNvblJlYWQoanNvbk9ialZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5lbnVtKGZpZWxkLlYuVCgpLCBqc29uT2JqVmFsdWUsIGZpZWxkLm5hbWUsIG9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHRoaXMuc2NhbGFyKGpzb25PYmpWYWx1ZSwgZmllbGQuVi5ULCBmaWVsZC5WLkwsIGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0KHZhbCAhPT0gdW5kZWZpbmVkLCBmaWVsZC5uYW1lICsgXCIgbWFwIHZhbHVlXCIsIGpzb25PYmpWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWQga2V5XG4gICAgICAgICAgICAgICAgICAgIGxldCBrZXkgPSBqc29uT2JqS2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuSyA9PSBTY2FsYXJUeXBlLkJPT0wpXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXkgPT0gXCJ0cnVlXCIgPyB0cnVlIDoga2V5ID09IFwiZmFsc2VcIiA/IGZhbHNlIDoga2V5O1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnNjYWxhcihrZXksIGZpZWxkLkssIExvbmdUeXBlLlNUUklORywgZmllbGQubmFtZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRPYmpba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5yZXBlYXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpbnB1dFxuICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0KEFycmF5LmlzQXJyYXkoanNvblZhbHVlKSwgZmllbGQubmFtZSwganNvblZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBvdXIgdGFyZ2V0IHRvIHB1dCBhcnJheSBlbnRyaWVzIGludG9cbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZEFyciA9IHRhcmdldFtsb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgIC8vIHJlYWQgYXJyYXkgZW50cmllc1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QganNvbkl0ZW0gb2YganNvblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0KGpzb25JdGVtICE9PSBudWxsLCBmaWVsZC5uYW1lLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGZpZWxkLlQoKS5pbnRlcm5hbEpzb25SZWFkKGpzb25JdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5lbnVtKGZpZWxkLlQoKSwganNvbkl0ZW0sIGZpZWxkLm5hbWUsIG9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHRoaXMuc2NhbGFyKGpzb25JdGVtLCBmaWVsZC5ULCBmaWVsZC5MLCBmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFzc2VydCh2YWwgIT09IHVuZGVmaW5lZCwgZmllbGQubmFtZSwganNvblZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRBcnIucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCAmJiBmaWVsZC5UKCkudHlwZU5hbWUgIT0gJ2dvb2dsZS5wcm90b2J1Zi5WYWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFzc2VydChmaWVsZC5vbmVvZiA9PT0gdW5kZWZpbmVkLCBmaWVsZC5uYW1lICsgXCIgKG9uZW9mIG1lbWJlcilcIiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGZpZWxkLlQoKS5pbnRlcm5hbEpzb25SZWFkKGpzb25WYWx1ZSwgb3B0aW9ucywgdGFyZ2V0W2xvY2FsTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHRoaXMuZW51bShmaWVsZC5UKCksIGpzb25WYWx1ZSwgZmllbGQubmFtZSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gdGhpcy5zY2FsYXIoanNvblZhbHVlLCBmaWVsZC5ULCBmaWVsZC5MLCBmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGBmYWxzZWAgZm9yIHVucmVjb2duaXplZCBzdHJpbmcgcmVwcmVzZW50YXRpb25zLlxuICAgICAqXG4gICAgICogZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZSBhY2NlcHRzIG9ubHkgSlNPTiBgbnVsbGAgKG9yIHRoZSBvbGQgYFwiTlVMTF9WQUxVRVwiYCkuXG4gICAgICovXG4gICAgZW51bSh0eXBlLCBqc29uLCBmaWVsZE5hbWUsIGlnbm9yZVVua25vd25GaWVsZHMpIHtcbiAgICAgICAgaWYgKHR5cGVbMF0gPT0gJ2dvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWUnKVxuICAgICAgICAgICAgYXNzZXJ0KGpzb24gPT09IG51bGwgfHwganNvbiA9PT0gXCJOVUxMX1ZBTFVFXCIsIGBVbmFibGUgdG8gcGFyc2UgZmllbGQgJHt0aGlzLmluZm8udHlwZU5hbWV9IyR7ZmllbGROYW1lfSwgZW51bSAke3R5cGVbMF19IG9ubHkgYWNjZXB0cyBudWxsLmApO1xuICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgIC8vIHdlIHJlcXVpcmUgMCB0byBiZSBkZWZhdWx0IHZhbHVlIGZvciBhbGwgZW51bXNcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBqc29uKSB7XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgYXNzZXJ0KE51bWJlci5pc0ludGVnZXIoanNvbiksIGBVbmFibGUgdG8gcGFyc2UgZmllbGQgJHt0aGlzLmluZm8udHlwZU5hbWV9IyR7ZmllbGROYW1lfSwgZW51bSBjYW4gb25seSBiZSBpbnRlZ3JhbCBudW1iZXIsIGdvdCAke2pzb259LmApO1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGxldCBsb2NhbEVudW1OYW1lID0ganNvbjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZVsyXSAmJiBqc29uLnN1YnN0cmluZygwLCB0eXBlWzJdLmxlbmd0aCkgPT09IHR5cGVbMl0pXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb2t1cCB3aXRob3V0IHRoZSBzaGFyZWQgcHJlZml4XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRW51bU5hbWUgPSBqc29uLnN1YnN0cmluZyh0eXBlWzJdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGV0IGVudW1OdW1iZXIgPSB0eXBlWzFdW2xvY2FsRW51bU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW51bU51bWJlciA9PT0gJ3VuZGVmaW5lZCcgJiYgaWdub3JlVW5rbm93bkZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgZW51bU51bWJlciA9PSBcIm51bWJlclwiLCBgVW5hYmxlIHRvIHBhcnNlIGZpZWxkICR7dGhpcy5pbmZvLnR5cGVOYW1lfSMke2ZpZWxkTmFtZX0sIGVudW0gJHt0eXBlWzBdfSBoYXMgbm8gdmFsdWUgZm9yIFwiJHtqc29ufVwiLmApO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnVtTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYFVuYWJsZSB0byBwYXJzZSBmaWVsZCAke3RoaXMuaW5mby50eXBlTmFtZX0jJHtmaWVsZE5hbWV9LCBjYW5ub3QgcGFyc2UgZW51bSB2YWx1ZSBmcm9tICR7dHlwZW9mIGpzb259XCIuYCk7XG4gICAgfVxuICAgIHNjYWxhcihqc29uLCB0eXBlLCBsb25nVHlwZSwgZmllbGROYW1lKSB7XG4gICAgICAgIGxldCBlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gZmxvYXQsIGRvdWJsZTogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgbnVtYmVyIG9yIG9uZSBvZiB0aGUgc3BlY2lhbCBzdHJpbmcgdmFsdWVzIFwiTmFOXCIsIFwiSW5maW5pdHlcIiwgYW5kIFwiLUluZmluaXR5XCIuXG4gICAgICAgICAgICAgICAgLy8gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuIEV4cG9uZW50IG5vdGF0aW9uIGlzIGFsc28gYWNjZXB0ZWQuXG4gICAgICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC4wO1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbiA9PT0gXCJOYU5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTmFOO1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbiA9PT0gXCJJbmZpbml0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24gPT09IFwiLUluZmluaXR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbiA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IFwiZW1wdHkgc3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gPT0gXCJzdHJpbmdcIiAmJiBqc29uLnRyaW0oKS5sZW5ndGggIT09IGpzb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gXCJleHRyYSB3aGl0ZXNwYWNlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YganNvbiAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgZmxvYXQgPSBOdW1iZXIoanNvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4oZmxvYXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gXCJub3QgYSBudW1iZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGZsb2F0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5maW5pdHkgYW5kIC1pbmZpbml0eSBhcmUgaGFuZGxlZCBieSBzdHJpbmcgcmVwcmVzZW50YXRpb24gYWJvdmUsIHNvIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBcInRvbyBsYXJnZSBvciBzbWFsbFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5GTE9BVClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEZsb2F0MzIoZmxvYXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvYXQ7XG4gICAgICAgICAgICAgICAgLy8gaW50MzIsIGZpeGVkMzIsIHVpbnQzMjogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBudW1iZXIuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgICAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW50MzI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgaW50MzIgPSBqc29uO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChqc29uID09PSBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IFwiZW1wdHkgc3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBqc29uID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uLnRyaW0oKS5sZW5ndGggIT09IGpzb24ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBcImV4dHJhIHdoaXRlc3BhY2VcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQzMiA9IE51bWJlcihqc29uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW50MzIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBTY2FsYXJUeXBlLlVJTlQzMilcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydFVJbnQzMihpbnQzMik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEludDMyKGludDMyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludDMyO1xuICAgICAgICAgICAgICAgIC8vIGludDY0LCBmaXhlZDY0LCB1aW50NjQ6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgc3RyaW5nLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3Rpb25Mb25nQ29udmVydChQYkxvbmcuWkVSTywgbG9uZ1R5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIiAmJiB0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWZsZWN0aW9uTG9uZ0NvbnZlcnQoUGJMb25nLmZyb20oanNvbiksIGxvbmdUeXBlKTtcbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWZsZWN0aW9uTG9uZ0NvbnZlcnQoUGJVTG9uZy5aRVJPLCBsb25nVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcIm51bWJlclwiICYmIHR5cGVvZiBqc29uICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3Rpb25Mb25nQ29udmVydChQYlVMb25nLmZyb20oanNvbiksIGxvbmdUeXBlKTtcbiAgICAgICAgICAgICAgICAvLyBib29sOlxuICAgICAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmc6XG4gICAgICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gXCJleHRyYSB3aGl0ZXNwYWNlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGpzb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gXCJpbnZhbGlkIFVURjhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICAgICAgICAgIC8vIGJ5dGVzOiBKU09OIHZhbHVlIHdpbGwgYmUgdGhlIGRhdGEgZW5jb2RlZCBhcyBhIHN0cmluZyB1c2luZyBzdGFuZGFyZCBiYXNlNjQgZW5jb2Rpbmcgd2l0aCBwYWRkaW5ncy5cbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgc3RhbmRhcmQgb3IgVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nIHdpdGgvd2l0aG91dCBwYWRkaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbCB8fCBqc29uID09PSBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNjRkZWNvZGUoanNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFzc2VydChmYWxzZSwgZmllbGROYW1lICsgKGUgPyBcIiAtIFwiICsgZSA6IFwiXCIpLCBqc29uKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBiYXNlNjRlbmNvZGUgfSBmcm9tIFwiLi9iYXNlNjRcIjtcbmltcG9ydCB7IFBiTG9uZywgUGJVTG9uZyB9IGZyb20gXCIuL3BiLWxvbmdcIjtcbmltcG9ydCB7IFNjYWxhclR5cGUgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWluZm9cIjtcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0RmxvYXQzMiwgYXNzZXJ0SW50MzIsIGFzc2VydFVJbnQzMiB9IGZyb20gXCIuL2Fzc2VydFwiO1xuLyoqXG4gKiBXcml0ZXMgcHJvdG8zIG1lc3NhZ2VzIGluIGNhbm9uaWNhbCBKU09OIGZvcm1hdCB1c2luZyByZWZsZWN0aW9uXG4gKiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvcHJvdG8zI2pzb25cbiAqL1xuZXhwb3J0IGNsYXNzIFJlZmxlY3Rpb25Kc29uV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpbmZvKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSAoX2EgPSBpbmZvLmZpZWxkcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBtZXNzYWdlIHRvIGEgSlNPTiBvYmplY3QsIGJhc2VkIG9uIHRoZSBmaWVsZCBkZXNjcmlwdG9ycy5cbiAgICAgKi9cbiAgICB3cml0ZShtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSB7fSwgc291cmNlID0gbWVzc2FnZTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgLy8gZmllbGQgaXMgbm90IHBhcnQgb2YgYSBvbmVvZiwgc2ltcGx5IHdyaXRlIGFzIGlzXG4gICAgICAgICAgICBpZiAoIWZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICAgICAgbGV0IGpzb25WYWx1ZSA9IHRoaXMuZmllbGQoZmllbGQsIHNvdXJjZVtmaWVsZC5sb2NhbE5hbWVdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGpzb25bb3B0aW9ucy51c2VQcm90b0ZpZWxkTmFtZSA/IGZpZWxkLm5hbWUgOiBmaWVsZC5qc29uTmFtZV0gPSBqc29uVmFsdWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmaWVsZCBpcyBwYXJ0IG9mIGEgb25lb2ZcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gc291cmNlW2ZpZWxkLm9uZW9mXTtcbiAgICAgICAgICAgIGlmIChncm91cC5vbmVvZktpbmQgIT09IGZpZWxkLmxvY2FsTmFtZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gbm90IHNlbGVjdGVkLCBza2lwXG4gICAgICAgICAgICBjb25zdCBvcHQgPSBmaWVsZC5raW5kID09ICdzY2FsYXInIHx8IGZpZWxkLmtpbmQgPT0gJ2VudW0nXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGVtaXREZWZhdWx0VmFsdWVzOiB0cnVlIH0pIDogb3B0aW9ucztcbiAgICAgICAgICAgIGxldCBqc29uVmFsdWUgPSB0aGlzLmZpZWxkKGZpZWxkLCBncm91cFtmaWVsZC5sb2NhbE5hbWVdLCBvcHQpO1xuICAgICAgICAgICAgYXNzZXJ0KGpzb25WYWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGpzb25bb3B0aW9ucy51c2VQcm90b0ZpZWxkTmFtZSA/IGZpZWxkLm5hbWUgOiBmaWVsZC5qc29uTmFtZV0gPSBqc29uVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIGZpZWxkKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBsZXQganNvblZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZmllbGQua2luZCA9PSAnbWFwJykge1xuICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGpzb25PYmogPSB7fTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeUtleSwgZW50cnlWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzLnNjYWxhcihmaWVsZC5WLlQsIGVudHJ5VmFsdWUsIGZpZWxkLm5hbWUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCh2YWwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gdmFsOyAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBmaWVsZC5WLlQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpcy5tZXNzYWdlKG1lc3NhZ2VUeXBlLCBlbnRyeVZhbHVlLCBmaWVsZC5uYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCh2YWwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gdmFsOyAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW51bUluZm8gPSBmaWVsZC5WLlQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGVudHJ5VmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgZW50cnlWYWx1ZSA9PSAnbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzLmVudW0oZW51bUluZm8sIGVudHJ5VmFsdWUsIGZpZWxkLm5hbWUsIGZhbHNlLCB0cnVlLCBvcHRpb25zLmVudW1Bc0ludGVnZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25PYmpbZW50cnlLZXkudG9TdHJpbmcoKV0gPSB2YWw7IC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzIHx8IE9iamVjdC5rZXlzKGpzb25PYmopLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAganNvblZhbHVlID0ganNvbk9iajtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZC5yZXBlYXQpIHtcbiAgICAgICAgICAgIGFzc2VydChBcnJheS5pc0FycmF5KHZhbHVlKSk7XG4gICAgICAgICAgICBjb25zdCBqc29uQXJyID0gW107XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuc2NhbGFyKGZpZWxkLlQsIHZhbHVlW2ldLCBmaWVsZC5uYW1lLCBmaWVsZC5vcHQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25BcnIucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudW1JbmZvID0gZmllbGQuVCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQodmFsdWVbaV0gPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWVbaV0gPT0gJ251bWJlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpcy5lbnVtKGVudW1JbmZvLCB2YWx1ZVtpXSwgZmllbGQubmFtZSwgZmllbGQub3B0LCB0cnVlLCBvcHRpb25zLmVudW1Bc0ludGVnZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25BcnIucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gZmllbGQuVCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzLm1lc3NhZ2UobWVzc2FnZVR5cGUsIHZhbHVlW2ldLCBmaWVsZC5uYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCh2YWwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uQXJyLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCBjb252ZXJ0ZWQgYXJyYXkgdG8ganNvbiBvdXRwdXRcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzIHx8IGpzb25BcnIubGVuZ3RoID4gMCB8fCBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzKVxuICAgICAgICAgICAgICAgIGpzb25WYWx1ZSA9IGpzb25BcnI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgIGpzb25WYWx1ZSA9IHRoaXMuc2NhbGFyKGZpZWxkLlQsIHZhbHVlLCBmaWVsZC5uYW1lLCBmaWVsZC5vcHQsIG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICBqc29uVmFsdWUgPSB0aGlzLmVudW0oZmllbGQuVCgpLCB2YWx1ZSwgZmllbGQubmFtZSwgZmllbGQub3B0LCBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzLCBvcHRpb25zLmVudW1Bc0ludGVnZXIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICBqc29uVmFsdWUgPSB0aGlzLm1lc3NhZ2UoZmllbGQuVCgpLCB2YWx1ZSwgZmllbGQubmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYG51bGxgIGFzIHRoZSBkZWZhdWx0IGZvciBnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlLlxuICAgICAqL1xuICAgIGVudW0odHlwZSwgdmFsdWUsIGZpZWxkTmFtZSwgb3B0aW9uYWwsIGVtaXREZWZhdWx0VmFsdWVzLCBlbnVtQXNJbnRlZ2VyKSB7XG4gICAgICAgIGlmICh0eXBlWzBdID09ICdnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlJylcbiAgICAgICAgICAgIHJldHVybiAhZW1pdERlZmF1bHRWYWx1ZXMgJiYgIW9wdGlvbmFsID8gdW5kZWZpbmVkIDogbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydChvcHRpb25hbCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiAhZW1pdERlZmF1bHRWYWx1ZXMgJiYgIW9wdGlvbmFsKVxuICAgICAgICAgICAgLy8gd2UgcmVxdWlyZSAwIHRvIGJlIGRlZmF1bHQgdmFsdWUgZm9yIGFsbCBlbnVtc1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyk7XG4gICAgICAgIGFzc2VydChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSk7XG4gICAgICAgIGlmIChlbnVtQXNJbnRlZ2VyIHx8ICF0eXBlWzFdLmhhc093blByb3BlcnR5KHZhbHVlKSlcbiAgICAgICAgICAgIC8vIGlmIHdlIGRvbid0IG5vdyB0aGUgZW51bSB2YWx1ZSwganVzdCByZXR1cm4gdGhlIG51bWJlclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAodHlwZVsyXSlcbiAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIGRyb3BwZWQgcHJlZml4XG4gICAgICAgICAgICByZXR1cm4gdHlwZVsyXSArIHR5cGVbMV1bdmFsdWVdO1xuICAgICAgICByZXR1cm4gdHlwZVsxXVt2YWx1ZV07XG4gICAgfVxuICAgIG1lc3NhZ2UodHlwZSwgdmFsdWUsIGZpZWxkTmFtZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzID8gbnVsbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHR5cGUuaW50ZXJuYWxKc29uV3JpdGUodmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzY2FsYXIodHlwZSwgdmFsdWUsIGZpZWxkTmFtZSwgb3B0aW9uYWwsIGVtaXREZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnQob3B0aW9uYWwpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZCA9IGVtaXREZWZhdWx0VmFsdWVzIHx8IG9wdGlvbmFsO1xuICAgICAgICAvLyBub2luc3BlY3Rpb24gRmFsbFRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgLy8gaW50MzIsIGZpeGVkMzIsIHVpbnQzMjogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBudW1iZXIuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlZCA/IDAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlZCA/IDAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VUludDMyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAvLyBmbG9hdCwgZG91YmxlOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBzcGVjaWFsIHN0cmluZyB2YWx1ZXMgXCJOYU5cIiwgXCJJbmZpbml0eVwiLCBhbmQgXCItSW5maW5pdHlcIi5cbiAgICAgICAgICAgIC8vIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLiBFeHBvbmVudCBub3RhdGlvbiBpcyBhbHNvIGFjY2VwdGVkLlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgICAgICAgICAgIGFzc2VydEZsb2F0MzIodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlZCA/IDAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTih2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnTmFOJztcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdJbmZpbml0eSc7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnLUluZmluaXR5JztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAvLyBzdHJpbmc6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVkID8gJycgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgLy8gYm9vbDpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlZCA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gJ2Jvb2xlYW4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAvLyBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIHN0cmluZy4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09ICdiaWdpbnQnKTtcbiAgICAgICAgICAgICAgICBsZXQgdWxvbmcgPSBQYlVMb25nLmZyb20odmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh1bG9uZy5pc1plcm8oKSAmJiAhZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVsb25nLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIHN0cmluZy4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PSAnYmlnaW50Jyk7XG4gICAgICAgICAgICAgICAgbGV0IGxvbmcgPSBQYkxvbmcuZnJvbSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvbmcuaXNaZXJvKCkgJiYgIWVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb25nLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBieXRlczogSlNPTiB2YWx1ZSB3aWxsIGJlIHRoZSBkYXRhIGVuY29kZWQgYXMgYSBzdHJpbmcgdXNpbmcgc3RhbmRhcmQgYmFzZTY0IGVuY29kaW5nIHdpdGggcGFkZGluZ3MuXG4gICAgICAgICAgICAvLyBFaXRoZXIgc3RhbmRhcmQgb3IgVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nIHdpdGgvd2l0aG91dCBwYWRkaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSk7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWQgPyBcIlwiIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNjRlbmNvZGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTG9uZ1R5cGUgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWluZm9cIjtcbi8qKlxuICogVXRpbGl0eSBtZXRob2QgdG8gY29udmVydCBhIFBiTG9uZyBvciBQYlVsb25nIHRvIGEgSmF2YVNjcmlwdFxuICogcmVwcmVzZW50YXRpb24gZHVyaW5nIHJ1bnRpbWUuXG4gKlxuICogV29ya3Mgd2l0aCBnZW5lcmF0ZWQgZmllbGQgaW5mb3JtYXRpb24sIGB1bmRlZmluZWRgIGlzIGVxdWl2YWxlbnRcbiAqIHRvIGBTVFJJTkdgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVmbGVjdGlvbkxvbmdDb252ZXJ0KGxvbmcsIHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBMb25nVHlwZS5CSUdJTlQ6XG4gICAgICAgICAgICByZXR1cm4gbG9uZy50b0JpZ0ludCgpO1xuICAgICAgICBjYXNlIExvbmdUeXBlLk5VTUJFUjpcbiAgICAgICAgICAgIHJldHVybiBsb25nLnRvTnVtYmVyKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIC8vIGNhc2UgTG9uZ1R5cGUuU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIGxvbmcudG9TdHJpbmcoKTtcbiAgICB9XG59XG4iLCIvKipcbiAqIENvcHkgcGFydGlhbCBkYXRhIGludG8gdGhlIHRhcmdldCBtZXNzYWdlLlxuICpcbiAqIElmIGEgc2luZ3VsYXIgc2NhbGFyIG9yIGVudW0gZmllbGQgaXMgcHJlc2VudCBpbiB0aGUgc291cmNlLCBpdFxuICogcmVwbGFjZXMgdGhlIGZpZWxkIGluIHRoZSB0YXJnZXQuXG4gKlxuICogSWYgYSBzaW5ndWxhciBtZXNzYWdlIGZpZWxkIGlzIHByZXNlbnQgaW4gdGhlIHNvdXJjZSwgaXQgaXMgbWVyZ2VkXG4gKiB3aXRoIHRoZSB0YXJnZXQgZmllbGQgYnkgY2FsbGluZyBtZXJnZVBhcnRpYWwoKSBvZiB0aGUgcmVzcG9uc2libGVcbiAqIG1lc3NhZ2UgdHlwZS5cbiAqXG4gKiBJZiBhIHJlcGVhdGVkIGZpZWxkIGlzIHByZXNlbnQgaW4gdGhlIHNvdXJjZSwgaXRzIHZhbHVlcyByZXBsYWNlXG4gKiBhbGwgdmFsdWVzIGluIHRoZSB0YXJnZXQgYXJyYXksIHJlbW92aW5nIGV4dHJhbmVvdXMgdmFsdWVzLlxuICogUmVwZWF0ZWQgbWVzc2FnZSBmaWVsZHMgYXJlIGNvcGllZCwgbm90IG1lcmdlZC5cbiAqXG4gKiBJZiBhIG1hcCBmaWVsZCBpcyBwcmVzZW50IGluIHRoZSBzb3VyY2UsIGVudHJpZXMgYXJlIGFkZGVkIHRvIHRoZVxuICogdGFyZ2V0IG1hcCwgcmVwbGFjaW5nIGVudHJpZXMgd2l0aCB0aGUgc2FtZSBrZXkuIEVudHJpZXMgdGhhdCBvbmx5XG4gKiBleGlzdCBpbiB0aGUgdGFyZ2V0IHJlbWFpbi4gRW50cmllcyB3aXRoIG1lc3NhZ2UgdmFsdWVzIGFyZSBjb3BpZWQsXG4gKiBub3QgbWVyZ2VkLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGRpZmZlcnMgZnJvbSBwcm90b2J1ZiBtZXJnZSBzZW1hbnRpY3MsXG4gKiB3aGljaCBhcHBlbmRzIHJlcGVhdGVkIGZpZWxkcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwoaW5mbywgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBsZXQgZmllbGRWYWx1ZSwgLy8gdGhlIGZpZWxkIHZhbHVlIHdlIGFyZSB3b3JraW5nIHdpdGhcbiAgICBpbnB1dCA9IHNvdXJjZSwgb3V0cHV0OyAvLyB3aGVyZSB3ZSB3YW50IG91ciBmaWVsZCB2YWx1ZSB0byBnb1xuICAgIGZvciAobGV0IGZpZWxkIG9mIGluZm8uZmllbGRzKSB7XG4gICAgICAgIGxldCBuYW1lID0gZmllbGQubG9jYWxOYW1lO1xuICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gaW5wdXRbZmllbGQub25lb2ZdOyAvLyB0aGlzIGlzIHRoZSBvbmVvZmBzIGdyb3VwIGluIHRoZSBzb3VyY2VcbiAgICAgICAgICAgIGlmICgoZ3JvdXAgPT09IG51bGwgfHwgZ3JvdXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyb3VwLm9uZW9mS2luZCkgPT0gdW5kZWZpbmVkKSB7IC8vIHRoZSB1c2VyIGlzIGZyZWUgdG8gb21pdFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyB3ZSBza2lwIHRoaXMgZmllbGQsIGFuZCBhbGwgb3RoZXIgbWVtYmVycyB0b29cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBncm91cFtuYW1lXTsgLy8gb3VyIHZhbHVlIGNvbWVzIGZyb20gdGhlIHRoZSBvbmVvZiBncm91cCBvZiB0aGUgc291cmNlXG4gICAgICAgICAgICBvdXRwdXQgPSB0YXJnZXRbZmllbGQub25lb2ZdOyAvLyBhbmQgb3VyIG91dHB1dCBpcyB0aGUgb25lb2YgZ3JvdXAgb2YgdGhlIHRhcmdldFxuICAgICAgICAgICAgb3V0cHV0Lm9uZW9mS2luZCA9IGdyb3VwLm9uZW9mS2luZDsgLy8gYWx3YXlzIHVwZGF0ZSBkaXNjcmltaW5hdG9yXG4gICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3V0cHV0W25hbWVdOyAvLyByZW1vdmUgYW55IGV4aXN0aW5nIHZhbHVlXG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIHNraXAgZnVydGhlciB3b3JrIG9uIGZpZWxkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWVsZFZhbHVlID0gaW5wdXRbbmFtZV07IC8vIHdlIGFyZSB1c2luZyB0aGUgc291cmNlIGRpcmVjdGx5XG4gICAgICAgICAgICBvdXRwdXQgPSB0YXJnZXQ7IC8vIHdlIHdhbnQgb3VyIGZpZWxkIHZhbHVlIHRvIGdvIGRpcmVjdGx5IGludG8gdGhlIHRhcmdldFxuICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIHNraXAgZnVydGhlciB3b3JrIG9uIGZpZWxkLCBleGlzdGluZyB2YWx1ZSBpcyB1c2VkIGFzIGlzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkLnJlcGVhdClcbiAgICAgICAgICAgIG91dHB1dFtuYW1lXS5sZW5ndGggPSBmaWVsZFZhbHVlLmxlbmd0aDsgLy8gcmVzaXplIHRhcmdldCBhcnJheSB0byBtYXRjaCBzb3VyY2UgYXJyYXlcbiAgICAgICAgLy8gbm93IHdlIGp1c3Qgd29yayB3aXRoIGBmaWVsZFZhbHVlYCBhbmQgYG91dHB1dGAgdG8gbWVyZ2UgdGhlIHZhbHVlXG4gICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVwZWF0KVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkVmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmFtZV1baV0gPSBmaWVsZFZhbHVlW2ldOyAvLyBub3QgYSByZWZlcmVuY2UgdHlwZVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W25hbWVdID0gZmllbGRWYWx1ZTsgLy8gbm90IGEgcmVmZXJlbmNlIHR5cGVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgbGV0IFQgPSBmaWVsZC5UKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLnJlcGVhdClcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZFZhbHVlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W25hbWVdW2ldID0gVC5jcmVhdGUoZmllbGRWYWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3V0cHV0W25hbWVdID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtuYW1lXSA9IFQuY3JlYXRlKGZpZWxkVmFsdWUpOyAvLyBub3RoaW5nIHRvIG1lcmdlIHdpdGhcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIFQubWVyZ2VQYXJ0aWFsKG91dHB1dFtuYW1lXSwgZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgLy8gTWFwIGFuZCByZXBlYXRlZCBmaWVsZHMgYXJlIHNpbXBseSBvdmVyd3JpdHRlbiwgbm90IGFwcGVuZGVkIG9yIG1lcmdlZFxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3V0cHV0W25hbWVdLCBmaWVsZFZhbHVlKTsgLy8gZWxlbWVudHMgYXJlIG5vdCByZWZlcmVuY2UgdHlwZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFQgPSBmaWVsZC5WLlQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgb2YgT2JqZWN0LmtleXMoZmllbGRWYWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W25hbWVdW2tdID0gVC5jcmVhdGUoZmllbGRWYWx1ZVtrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBMb25nVHlwZSwgU2NhbGFyVHlwZSB9IGZyb20gXCIuL3JlZmxlY3Rpb24taW5mb1wiO1xuaW1wb3J0IHsgcmVmbGVjdGlvbkxvbmdDb252ZXJ0IH0gZnJvbSBcIi4vcmVmbGVjdGlvbi1sb25nLWNvbnZlcnRcIjtcbmltcG9ydCB7IFBiTG9uZywgUGJVTG9uZyB9IGZyb20gXCIuL3BiLWxvbmdcIjtcbi8qKlxuICogQ3JlYXRlcyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgYSBzY2FsYXIgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZmxlY3Rpb25TY2FsYXJEZWZhdWx0KHR5cGUsIGxvbmdUeXBlID0gTG9uZ1R5cGUuU1RSSU5HKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgICAgIHJldHVybiByZWZsZWN0aW9uTG9uZ0NvbnZlcnQoUGJVTG9uZy5aRVJPLCBsb25nVHlwZSk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3Rpb25Mb25nQ29udmVydChQYkxvbmcuWkVSTywgbG9uZ1R5cGUpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICAgICAgICAgIC8vIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgICAgICAgICAvLyBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAgICAgICAgLy8gY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICAgICAgICAvLyBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBMb25nVHlwZSwgU2NhbGFyVHlwZSB9IGZyb20gXCIuL3JlZmxlY3Rpb24taW5mb1wiO1xuaW1wb3J0IHsgaXNPbmVvZkdyb3VwIH0gZnJvbSBcIi4vb25lb2ZcIjtcbi8vIG5vaW5zcGVjdGlvbiBKU01ldGhvZENhbkJlU3RhdGljXG5leHBvcnQgY2xhc3MgUmVmbGVjdGlvblR5cGVDaGVjayB7XG4gICAgY29uc3RydWN0b3IoaW5mbykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZmllbGRzID0gKF9hID0gaW5mby5maWVsZHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgIH1cbiAgICBwcmVwYXJlKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCByZXEgPSBbXSwga25vd24gPSBbXSwgb25lb2ZzID0gW107XG4gICAgICAgIGZvciAobGV0IGZpZWxkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9uZW9mcy5pbmNsdWRlcyhmaWVsZC5vbmVvZikpIHtcbiAgICAgICAgICAgICAgICAgICAgb25lb2ZzLnB1c2goZmllbGQub25lb2YpO1xuICAgICAgICAgICAgICAgICAgICByZXEucHVzaChmaWVsZC5vbmVvZik7XG4gICAgICAgICAgICAgICAgICAgIGtub3duLnB1c2goZmllbGQub25lb2YpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtub3duLnB1c2goZmllbGQubG9jYWxOYW1lKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZC5vcHQgfHwgZmllbGQucmVwZWF0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5wdXNoKGZpZWxkLmxvY2FsTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5yZXBlYXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnB1c2goZmllbGQubG9jYWxOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEucHVzaChmaWVsZC5sb2NhbE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YSA9IHsgcmVxLCBrbm93biwgb25lb2ZzOiBPYmplY3QudmFsdWVzKG9uZW9mcykgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIGFyZ3VtZW50IGEgdmFsaWQgbWVzc2FnZSBhcyBzcGVjaWZpZWQgYnkgdGhlXG4gICAgICogcmVmbGVjdGlvbiBpbmZvcm1hdGlvbj9cbiAgICAgKlxuICAgICAqIENoZWNrcyBhbGwgZmllbGQgdHlwZXMgcmVjdXJzaXZlbHkuIFRoZSBgZGVwdGhgXG4gICAgICogc3BlY2lmaWVzIGhvdyBkZWVwIGludG8gdGhlIHN0cnVjdHVyZSB0aGUgY2hlY2sgd2lsbCBiZS5cbiAgICAgKlxuICAgICAqIFdpdGggYSBkZXB0aCBvZiAwLCBvbmx5IHRoZSBwcmVzZW5jZSBvZiBmaWVsZHNcbiAgICAgKiBpcyBjaGVja2VkLlxuICAgICAqXG4gICAgICogV2l0aCBhIGRlcHRoIG9mIDEgb3IgbW9yZSwgdGhlIGZpZWxkIHR5cGVzIGFyZSBjaGVja2VkLlxuICAgICAqXG4gICAgICogV2l0aCBhIGRlcHRoIG9mIDIgb3IgbW9yZSwgdGhlIG1lbWJlcnMgb2YgbWFwLCByZXBlYXRlZFxuICAgICAqIGFuZCBtZXNzYWdlIGZpZWxkcyBhcmUgY2hlY2tlZC5cbiAgICAgKlxuICAgICAqIE1lc3NhZ2UgZmllbGRzIHdpbGwgYmUgY2hlY2tlZCByZWN1cnNpdmVseSB3aXRoIGRlcHRoIC0gMS5cbiAgICAgKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbWFwIGVudHJpZXMgLyByZXBlYXRlZCB2YWx1ZXMgYmVpbmcgY2hlY2tlZFxuICAgICAqIGlzIDwgZGVwdGguXG4gICAgICovXG4gICAgaXMobWVzc2FnZSwgZGVwdGgsIGFsbG93RXhjZXNzUHJvcGVydGllcyA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChkZXB0aCA8IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwgfHwgbWVzc2FnZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXNzYWdlICE9ICdvYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnByZXBhcmUoKTtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhtZXNzYWdlKSwgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgLy8gaWYgYSByZXF1aXJlZCBmaWVsZCBpcyBtaXNzaW5nIGluIGFyZywgdGhpcyBjYW5ub3QgYmUgYSBUXG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA8IGRhdGEucmVxLmxlbmd0aCB8fCBkYXRhLnJlcS5zb21lKG4gPT4gIWtleXMuaW5jbHVkZXMobikpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWFsbG93RXhjZXNzUHJvcGVydGllcykge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGFyZyBjb250YWlucyBhIGtleSB3ZSBkb250IGtub3csIHRoaXMgaXMgbm90IGEgbGl0ZXJhbCBUXG4gICAgICAgICAgICBpZiAoa2V5cy5zb21lKGsgPT4gIWRhdGEua25vd24uaW5jbHVkZXMoaykpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBcIldpdGggYSBkZXB0aCBvZiAwLCBvbmx5IHRoZSBwcmVzZW5jZSBhbmQgYWJzZW5jZSBvZiBmaWVsZHMgaXMgY2hlY2tlZC5cIlxuICAgICAgICAvLyBcIldpdGggYSBkZXB0aCBvZiAxIG9yIG1vcmUsIHRoZSBmaWVsZCB0eXBlcyBhcmUgY2hlY2tlZC5cIlxuICAgICAgICBpZiAoZGVwdGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBvbmVvZiBncm91cFxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgZGF0YS5vbmVvZnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gbWVzc2FnZVtuYW1lXTtcbiAgICAgICAgICAgIGlmICghaXNPbmVvZkdyb3VwKGdyb3VwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZ3JvdXAub25lb2ZLaW5kID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGRzLmZpbmQoZiA9PiBmLmxvY2FsTmFtZSA9PT0gZ3JvdXAub25lb2ZLaW5kKTtcbiAgICAgICAgICAgIGlmICghZmllbGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSBmb3VuZCBubyBmaWVsZCwgYnV0IGhhdmUgYSBraW5kLCBzb21ldGhpbmcgaXMgd3JvbmdcbiAgICAgICAgICAgIGlmICghdGhpcy5maWVsZChncm91cFtncm91cC5vbmVvZktpbmRdLCBmaWVsZCwgYWxsb3dFeGNlc3NQcm9wZXJ0aWVzLCBkZXB0aCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIHR5cGVzXG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5vbmVvZiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpZWxkKG1lc3NhZ2VbZmllbGQubG9jYWxOYW1lXSwgZmllbGQsIGFsbG93RXhjZXNzUHJvcGVydGllcywgZGVwdGgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZmllbGQoYXJnLCBmaWVsZCwgYWxsb3dFeGNlc3NQcm9wZXJ0aWVzLCBkZXB0aCkge1xuICAgICAgICBsZXQgcmVwZWF0ZWQgPSBmaWVsZC5yZXBlYXQ7XG4gICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkLm9wdDtcbiAgICAgICAgICAgICAgICBpZiAocmVwZWF0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxhcnMoYXJnLCBmaWVsZC5ULCBkZXB0aCwgZmllbGQuTCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGFyKGFyZywgZmllbGQuVCwgZmllbGQuTCk7XG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkLm9wdDtcbiAgICAgICAgICAgICAgICBpZiAocmVwZWF0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxhcnMoYXJnLCBTY2FsYXJUeXBlLklOVDMyLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGFyKGFyZywgU2NhbGFyVHlwZS5JTlQzMik7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGVhdGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcyhhcmcsIGZpZWxkLlQoKSwgYWxsb3dFeGNlc3NQcm9wZXJ0aWVzLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZShhcmcsIGZpZWxkLlQoKSwgYWxsb3dFeGNlc3NQcm9wZXJ0aWVzLCBkZXB0aCk7XG4gICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgIT0gJ29iamVjdCcgfHwgYXJnID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIDwgMilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hcEtleXMoYXJnLCBmaWVsZC5LLCBkZXB0aCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsYXJzKE9iamVjdC52YWx1ZXMoYXJnKSwgZmllbGQuVi5ULCBkZXB0aCwgZmllbGQuVi5MKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxhcnMoT2JqZWN0LnZhbHVlcyhhcmcpLCBTY2FsYXJUeXBlLklOVDMyLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcyhPYmplY3QudmFsdWVzKGFyZyksIGZpZWxkLlYuVCgpLCBhbGxvd0V4Y2Vzc1Byb3BlcnRpZXMsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG1lc3NhZ2UoYXJnLCB0eXBlLCBhbGxvd0V4Y2Vzc1Byb3BlcnRpZXMsIGRlcHRoKSB7XG4gICAgICAgIGlmIChhbGxvd0V4Y2Vzc1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmlzQXNzaWduYWJsZShhcmcsIGRlcHRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZS5pcyhhcmcsIGRlcHRoKTtcbiAgICB9XG4gICAgbWVzc2FnZXMoYXJnLCB0eXBlLCBhbGxvd0V4Y2Vzc1Byb3BlcnRpZXMsIGRlcHRoKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGVwdGggPCAyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChhbGxvd0V4Y2Vzc1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJnLmxlbmd0aCAmJiBpIDwgZGVwdGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuaXNBc3NpZ25hYmxlKGFyZ1tpXSwgZGVwdGggLSAxKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmcubGVuZ3RoICYmIGkgPCBkZXB0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmICghdHlwZS5pcyhhcmdbaV0sIGRlcHRoIC0gMSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2NhbGFyKGFyZywgdHlwZSwgbG9uZ1R5cGUpIHtcbiAgICAgICAgbGV0IGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChsb25nVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExvbmdUeXBlLkJJR0lOVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09IFwiYmlnaW50XCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTG9uZ1R5cGUuTlVNQkVSOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT0gXCJudW1iZXJcIiAmJiAhaXNOYU4oYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09IFwic3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT0gJ2Jvb2xlYW4nO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PSAnc3RyaW5nJztcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnIGluc3RhbmNlb2YgVWludDhBcnJheTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT0gJ251bWJlcicgJiYgIWlzTmFOKGFyZyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgICAgICAgICAgICAgLy8gY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICAgICAgICAgICAgLy8gY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgICAgICAgICAgICAgIC8vIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgICAgICAgICAgLy8gY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09ICdudW1iZXInICYmIE51bWJlci5pc0ludGVnZXIoYXJnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY2FsYXJzKGFyZywgdHlwZSwgZGVwdGgsIGxvbmdUeXBlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGVwdGggPCAyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZy5sZW5ndGggJiYgaSA8IGRlcHRoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNjYWxhcihhcmdbaV0sIHR5cGUsIGxvbmdUeXBlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbWFwS2V5cyhtYXAsIHR5cGUsIGRlcHRoKSB7XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMobWFwKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxhcnMoa2V5cy5zbGljZSgwLCBkZXB0aCkubWFwKGsgPT4gcGFyc2VJbnQoaykpLCB0eXBlLCBkZXB0aCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsYXJzKGtleXMuc2xpY2UoMCwgZGVwdGgpLm1hcChrID0+IGsgPT0gJ3RydWUnID8gdHJ1ZSA6IGsgPT0gJ2ZhbHNlJyA/IGZhbHNlIDogayksIHR5cGUsIGRlcHRoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGFycyhrZXlzLCB0eXBlLCBkZXB0aCwgTG9uZ1R5cGUuU1RSSU5HKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBTRFAgaGVscGVycy5cbmNvbnN0IFNEUFV0aWxzID0ge307XG5cbi8vIEdlbmVyYXRlIGFuIGFscGhhbnVtZXJpYyBpZGVudGlmaWVyIGZvciBjbmFtZSBvciBtaWRzLlxuLy8gVE9ETzogdXNlIFVVSURzIGluc3RlYWQ/IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2plZC85ODI4ODNcblNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEyKTtcbn07XG5cbi8vIFRoZSBSVENQIENOQU1FIHVzZWQgYnkgYWxsIHBlZXJjb25uZWN0aW9ucyBmcm9tIHRoZSBzYW1lIEpTLlxuU0RQVXRpbHMubG9jYWxDTmFtZSA9IFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllcigpO1xuXG4vLyBTcGxpdHMgU0RQIGludG8gbGluZXMsIGRlYWxpbmcgd2l0aCBib3RoIENSTEYgYW5kIExGLlxuU0RQVXRpbHMuc3BsaXRMaW5lcyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgcmV0dXJuIGJsb2IudHJpbSgpLnNwbGl0KCdcXG4nKS5tYXAobGluZSA9PiBsaW5lLnRyaW0oKSk7XG59O1xuLy8gU3BsaXRzIFNEUCBpbnRvIHNlc3Npb25wYXJ0IGFuZCBtZWRpYXNlY3Rpb25zLiBFbnN1cmVzIENSTEYuXG5TRFBVdGlscy5zcGxpdFNlY3Rpb25zID0gZnVuY3Rpb24oYmxvYikge1xuICBjb25zdCBwYXJ0cyA9IGJsb2Iuc3BsaXQoJ1xcbm09Jyk7XG4gIHJldHVybiBwYXJ0cy5tYXAoKHBhcnQsIGluZGV4KSA9PiAoaW5kZXggPiAwID9cbiAgICAnbT0nICsgcGFydCA6IHBhcnQpLnRyaW0oKSArICdcXHJcXG4nKTtcbn07XG5cbi8vIFJldHVybnMgdGhlIHNlc3Npb24gZGVzY3JpcHRpb24uXG5TRFBVdGlscy5nZXREZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICByZXR1cm4gc2VjdGlvbnMgJiYgc2VjdGlvbnNbMF07XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBpbmRpdmlkdWFsIG1lZGlhIHNlY3Rpb25zLlxuU0RQVXRpbHMuZ2V0TWVkaWFTZWN0aW9ucyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICBzZWN0aW9ucy5zaGlmdCgpO1xuICByZXR1cm4gc2VjdGlvbnM7XG59O1xuXG4vLyBSZXR1cm5zIGxpbmVzIHRoYXQgc3RhcnQgd2l0aCBhIGNlcnRhaW4gcHJlZml4LlxuU0RQVXRpbHMubWF0Y2hQcmVmaXggPSBmdW5jdGlvbihibG9iLCBwcmVmaXgpIHtcbiAgcmV0dXJuIFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYikuZmlsdGVyKGxpbmUgPT4gbGluZS5pbmRleE9mKHByZWZpeCkgPT09IDApO1xufTtcblxuLy8gUGFyc2VzIGFuIElDRSBjYW5kaWRhdGUgbGluZS4gU2FtcGxlIGlucHV0OlxuLy8gY2FuZGlkYXRlOjcwMjc4NjM1MCAyIHVkcCA0MTgxOTkwMiA4LjguOC44IDYwNzY5IHR5cCByZWxheSByYWRkciA4LjguOC44XG4vLyBycG9ydCA1NTk5NlwiXG4vLyBJbnB1dCBjYW4gYmUgcHJlZml4ZWQgd2l0aCBhPS5cblNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlID0gZnVuY3Rpb24obGluZSkge1xuICBsZXQgcGFydHM7XG4gIC8vIFBhcnNlIGJvdGggdmFyaWFudHMuXG4gIGlmIChsaW5lLmluZGV4T2YoJ2E9Y2FuZGlkYXRlOicpID09PSAwKSB7XG4gICAgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMikuc3BsaXQoJyAnKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEwKS5zcGxpdCgnICcpO1xuICB9XG5cbiAgY29uc3QgY2FuZGlkYXRlID0ge1xuICAgIGZvdW5kYXRpb246IHBhcnRzWzBdLFxuICAgIGNvbXBvbmVudDogezE6ICdydHAnLCAyOiAncnRjcCd9W3BhcnRzWzFdXSB8fCBwYXJ0c1sxXSxcbiAgICBwcm90b2NvbDogcGFydHNbMl0udG9Mb3dlckNhc2UoKSxcbiAgICBwcmlvcml0eTogcGFyc2VJbnQocGFydHNbM10sIDEwKSxcbiAgICBpcDogcGFydHNbNF0sXG4gICAgYWRkcmVzczogcGFydHNbNF0sIC8vIGFkZHJlc3MgaXMgYW4gYWxpYXMgZm9yIGlwLlxuICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzVdLCAxMCksXG4gICAgLy8gc2tpcCBwYXJ0c1s2XSA9PSAndHlwJ1xuICAgIHR5cGU6IHBhcnRzWzddLFxuICB9O1xuXG4gIGZvciAobGV0IGkgPSA4OyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBzd2l0Y2ggKHBhcnRzW2ldKSB7XG4gICAgICBjYXNlICdyYWRkcic6XG4gICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdycG9ydCc6XG4gICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCA9IHBhcnNlSW50KHBhcnRzW2kgKyAxXSwgMTApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RjcHR5cGUnOlxuICAgICAgICBjYW5kaWRhdGUudGNwVHlwZSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1ZnJhZyc6XG4gICAgICAgIGNhbmRpZGF0ZS51ZnJhZyA9IHBhcnRzW2kgKyAxXTsgLy8gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50ID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIGV4dGVuc2lvbiBoYW5kbGluZywgaW4gcGFydGljdWxhciB1ZnJhZy4gRG9uJ3Qgb3ZlcndyaXRlLlxuICAgICAgICBpZiAoY2FuZGlkYXRlW3BhcnRzW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2FuZGlkYXRlW3BhcnRzW2ldXSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZTtcbn07XG5cbi8vIFRyYW5zbGF0ZXMgYSBjYW5kaWRhdGUgb2JqZWN0IGludG8gU0RQIGNhbmRpZGF0ZSBhdHRyaWJ1dGUuXG4vLyBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdGhlIGE9IHByZWZpeCFcblNEUFV0aWxzLndyaXRlQ2FuZGlkYXRlID0gZnVuY3Rpb24oY2FuZGlkYXRlKSB7XG4gIGNvbnN0IHNkcCA9IFtdO1xuICBzZHAucHVzaChjYW5kaWRhdGUuZm91bmRhdGlvbik7XG5cbiAgY29uc3QgY29tcG9uZW50ID0gY2FuZGlkYXRlLmNvbXBvbmVudDtcbiAgaWYgKGNvbXBvbmVudCA9PT0gJ3J0cCcpIHtcbiAgICBzZHAucHVzaCgxKTtcbiAgfSBlbHNlIGlmIChjb21wb25lbnQgPT09ICdydGNwJykge1xuICAgIHNkcC5wdXNoKDIpO1xuICB9IGVsc2Uge1xuICAgIHNkcC5wdXNoKGNvbXBvbmVudCk7XG4gIH1cbiAgc2RwLnB1c2goY2FuZGlkYXRlLnByb3RvY29sLnRvVXBwZXJDYXNlKCkpO1xuICBzZHAucHVzaChjYW5kaWRhdGUucHJpb3JpdHkpO1xuICBzZHAucHVzaChjYW5kaWRhdGUuYWRkcmVzcyB8fCBjYW5kaWRhdGUuaXApO1xuICBzZHAucHVzaChjYW5kaWRhdGUucG9ydCk7XG5cbiAgY29uc3QgdHlwZSA9IGNhbmRpZGF0ZS50eXBlO1xuICBzZHAucHVzaCgndHlwJyk7XG4gIHNkcC5wdXNoKHR5cGUpO1xuICBpZiAodHlwZSAhPT0gJ2hvc3QnICYmIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyAmJlxuICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KSB7XG4gICAgc2RwLnB1c2goJ3JhZGRyJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzKTtcbiAgICBzZHAucHVzaCgncnBvcnQnKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUucmVsYXRlZFBvcnQpO1xuICB9XG4gIGlmIChjYW5kaWRhdGUudGNwVHlwZSAmJiBjYW5kaWRhdGUucHJvdG9jb2wudG9Mb3dlckNhc2UoKSA9PT0gJ3RjcCcpIHtcbiAgICBzZHAucHVzaCgndGNwdHlwZScpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS50Y3BUeXBlKTtcbiAgfVxuICBpZiAoY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKSB7XG4gICAgc2RwLnB1c2goJ3VmcmFnJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKTtcbiAgfVxuICByZXR1cm4gJ2NhbmRpZGF0ZTonICsgc2RwLmpvaW4oJyAnKTtcbn07XG5cbi8vIFBhcnNlcyBhbiBpY2Utb3B0aW9ucyBsaW5lLCByZXR1cm5zIGFuIGFycmF5IG9mIG9wdGlvbiB0YWdzLlxuLy8gU2FtcGxlIGlucHV0OlxuLy8gYT1pY2Utb3B0aW9uczpmb28gYmFyXG5TRFBVdGlscy5wYXJzZUljZU9wdGlvbnMgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHJldHVybiBsaW5lLnN1YnN0cmluZygxNCkuc3BsaXQoJyAnKTtcbn07XG5cbi8vIFBhcnNlcyBhIHJ0cG1hcCBsaW5lLCByZXR1cm5zIFJUQ1J0cENvZGRlY1BhcmFtZXRlcnMuIFNhbXBsZSBpbnB1dDpcbi8vIGE9cnRwbWFwOjExMSBvcHVzLzQ4MDAwLzJcblNEUFV0aWxzLnBhcnNlUnRwTWFwID0gZnVuY3Rpb24obGluZSkge1xuICBsZXQgcGFydHMgPSBsaW5lLnN1YnN0cmluZyg5KS5zcGxpdCgnICcpO1xuICBjb25zdCBwYXJzZWQgPSB7XG4gICAgcGF5bG9hZFR5cGU6IHBhcnNlSW50KHBhcnRzLnNoaWZ0KCksIDEwKSwgLy8gd2FzOiBpZFxuICB9O1xuXG4gIHBhcnRzID0gcGFydHNbMF0uc3BsaXQoJy8nKTtcblxuICBwYXJzZWQubmFtZSA9IHBhcnRzWzBdO1xuICBwYXJzZWQuY2xvY2tSYXRlID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTsgLy8gd2FzOiBjbG9ja3JhdGVcbiAgcGFyc2VkLmNoYW5uZWxzID0gcGFydHMubGVuZ3RoID09PSAzID8gcGFyc2VJbnQocGFydHNbMl0sIDEwKSA6IDE7XG4gIC8vIGxlZ2FjeSBhbGlhcywgZ290IHJlbmFtZWQgYmFjayB0byBjaGFubmVscyBpbiBPUlRDLlxuICBwYXJzZWQubnVtQ2hhbm5lbHMgPSBwYXJzZWQuY2hhbm5lbHM7XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vLyBHZW5lcmF0ZXMgYSBydHBtYXAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvclxuLy8gUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdHBNYXAgPSBmdW5jdGlvbihjb2RlYykge1xuICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIGNvbnN0IGNoYW5uZWxzID0gY29kZWMuY2hhbm5lbHMgfHwgY29kZWMubnVtQ2hhbm5lbHMgfHwgMTtcbiAgcmV0dXJuICdhPXJ0cG1hcDonICsgcHQgKyAnICcgKyBjb2RlYy5uYW1lICsgJy8nICsgY29kZWMuY2xvY2tSYXRlICtcbiAgICAgIChjaGFubmVscyAhPT0gMSA/ICcvJyArIGNoYW5uZWxzIDogJycpICsgJ1xcclxcbic7XG59O1xuXG4vLyBQYXJzZXMgYSBleHRtYXAgbGluZSAoaGVhZGVyZXh0ZW5zaW9uIGZyb20gUkZDIDUyODUpLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbi8vIGE9ZXh0bWFwOjIvc2VuZG9ubHkgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuU0RQVXRpbHMucGFyc2VFeHRtYXAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBpZDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICBkaXJlY3Rpb246IHBhcnRzWzBdLmluZGV4T2YoJy8nKSA+IDAgPyBwYXJ0c1swXS5zcGxpdCgnLycpWzFdIDogJ3NlbmRyZWN2JyxcbiAgICB1cmk6IHBhcnRzWzFdLFxuICAgIGF0dHJpYnV0ZXM6IHBhcnRzLnNsaWNlKDIpLmpvaW4oJyAnKSxcbiAgfTtcbn07XG5cbi8vIEdlbmVyYXRlcyBhbiBleHRtYXAgbGluZSBmcm9tIFJUQ1J0cEhlYWRlckV4dGVuc2lvblBhcmFtZXRlcnMgb3Jcbi8vIFJUQ1J0cEhlYWRlckV4dGVuc2lvbi5cblNEUFV0aWxzLndyaXRlRXh0bWFwID0gZnVuY3Rpb24oaGVhZGVyRXh0ZW5zaW9uKSB7XG4gIHJldHVybiAnYT1leHRtYXA6JyArIChoZWFkZXJFeHRlbnNpb24uaWQgfHwgaGVhZGVyRXh0ZW5zaW9uLnByZWZlcnJlZElkKSArXG4gICAgICAoaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiAmJiBoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uICE9PSAnc2VuZHJlY3YnXG4gICAgICAgID8gJy8nICsgaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvblxuICAgICAgICA6ICcnKSArXG4gICAgICAnICcgKyBoZWFkZXJFeHRlbnNpb24udXJpICtcbiAgICAgIChoZWFkZXJFeHRlbnNpb24uYXR0cmlidXRlcyA/ICcgJyArIGhlYWRlckV4dGVuc2lvbi5hdHRyaWJ1dGVzIDogJycpICtcbiAgICAgICdcXHJcXG4nO1xufTtcblxuLy8gUGFyc2VzIGEgZm10cCBsaW5lLCByZXR1cm5zIGRpY3Rpb25hcnkuIFNhbXBsZSBpbnB1dDpcbi8vIGE9Zm10cDo5NiB2YnI9b247Y25nPW9uXG4vLyBBbHNvIGRlYWxzIHdpdGggdmJyPW9uOyBjbmc9b25cblNEUFV0aWxzLnBhcnNlRm10cCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3QgcGFyc2VkID0ge307XG4gIGxldCBrdjtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyhsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCc7Jyk7XG4gIGZvciAobGV0IGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICBrdiA9IHBhcnRzW2pdLnRyaW0oKS5zcGxpdCgnPScpO1xuICAgIHBhcnNlZFtrdlswXS50cmltKCldID0ga3ZbMV07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbi8vIEdlbmVyYXRlcyBhIGZtdHAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvciBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZUZtdHAgPSBmdW5jdGlvbihjb2RlYykge1xuICBsZXQgbGluZSA9ICcnO1xuICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIGlmIChjb2RlYy5wYXJhbWV0ZXJzICYmIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmxlbmd0aCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmZvckVhY2gocGFyYW0gPT4ge1xuICAgICAgaWYgKGNvZGVjLnBhcmFtZXRlcnNbcGFyYW1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0gKyAnPScgKyBjb2RlYy5wYXJhbWV0ZXJzW3BhcmFtXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGluZSArPSAnYT1mbXRwOicgKyBwdCArICcgJyArIHBhcmFtcy5qb2luKCc7JykgKyAnXFxyXFxuJztcbiAgfVxuICByZXR1cm4gbGluZTtcbn07XG5cbi8vIFBhcnNlcyBhIHJ0Y3AtZmIgbGluZSwgcmV0dXJucyBSVENQUnRjcEZlZWRiYWNrIG9iamVjdC4gU2FtcGxlIGlucHV0OlxuLy8gYT1ydGNwLWZiOjk4IG5hY2sgcnBzaVxuU0RQVXRpbHMucGFyc2VSdGNwRmIgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcobGluZS5pbmRleE9mKCcgJykgKyAxKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHBhcnRzLnNoaWZ0KCksXG4gICAgcGFyYW1ldGVyOiBwYXJ0cy5qb2luKCcgJyksXG4gIH07XG59O1xuXG4vLyBHZW5lcmF0ZSBhPXJ0Y3AtZmIgbGluZXMgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdGNwRmIgPSBmdW5jdGlvbihjb2RlYykge1xuICBsZXQgbGluZXMgPSAnJztcbiAgbGV0IHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgfVxuICBpZiAoY29kZWMucnRjcEZlZWRiYWNrICYmIGNvZGVjLnJ0Y3BGZWVkYmFjay5sZW5ndGgpIHtcbiAgICAvLyBGSVhNRTogc3BlY2lhbCBoYW5kbGluZyBmb3IgdHJyLWludD9cbiAgICBjb2RlYy5ydGNwRmVlZGJhY2suZm9yRWFjaChmYiA9PiB7XG4gICAgICBsaW5lcyArPSAnYT1ydGNwLWZiOicgKyBwdCArICcgJyArIGZiLnR5cGUgK1xuICAgICAgKGZiLnBhcmFtZXRlciAmJiBmYi5wYXJhbWV0ZXIubGVuZ3RoID8gJyAnICsgZmIucGFyYW1ldGVyIDogJycpICtcbiAgICAgICAgICAnXFxyXFxuJztcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbGluZXM7XG59O1xuXG4vLyBQYXJzZXMgYSBSRkMgNTU3NiBzc3JjIG1lZGlhIGF0dHJpYnV0ZS4gU2FtcGxlIGlucHV0OlxuLy8gYT1zc3JjOjM3MzU5Mjg1NTkgY25hbWU6c29tZXRoaW5nXG5TRFBVdGlscy5wYXJzZVNzcmNNZWRpYSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3Qgc3AgPSBsaW5lLmluZGV4T2YoJyAnKTtcbiAgY29uc3QgcGFydHMgPSB7XG4gICAgc3NyYzogcGFyc2VJbnQobGluZS5zdWJzdHJpbmcoNywgc3ApLCAxMCksXG4gIH07XG4gIGNvbnN0IGNvbG9uID0gbGluZS5pbmRleE9mKCc6Jywgc3ApO1xuICBpZiAoY29sb24gPiAtMSkge1xuICAgIHBhcnRzLmF0dHJpYnV0ZSA9IGxpbmUuc3Vic3RyaW5nKHNwICsgMSwgY29sb24pO1xuICAgIHBhcnRzLnZhbHVlID0gbGluZS5zdWJzdHJpbmcoY29sb24gKyAxKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cy5hdHRyaWJ1dGUgPSBsaW5lLnN1YnN0cmluZyhzcCArIDEpO1xuICB9XG4gIHJldHVybiBwYXJ0cztcbn07XG5cbi8vIFBhcnNlIGEgc3NyYy1ncm91cCBsaW5lIChzZWUgUkZDIDU1NzYpLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPXNzcmMtZ3JvdXA6c2VtYW50aWNzIDEyIDM0XG5TRFBVdGlscy5wYXJzZVNzcmNHcm91cCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMykuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBzZW1hbnRpY3M6IHBhcnRzLnNoaWZ0KCksXG4gICAgc3NyY3M6IHBhcnRzLm1hcChzc3JjID0+IHBhcnNlSW50KHNzcmMsIDEwKSksXG4gIH07XG59O1xuXG4vLyBFeHRyYWN0cyB0aGUgTUlEIChSRkMgNTg4OCkgZnJvbSBhIG1lZGlhIHNlY3Rpb24uXG4vLyBSZXR1cm5zIHRoZSBNSUQgb3IgdW5kZWZpbmVkIGlmIG5vIG1pZCBsaW5lIHdhcyBmb3VuZC5cblNEUFV0aWxzLmdldE1pZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBtaWQgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1pZDonKVswXTtcbiAgaWYgKG1pZCkge1xuICAgIHJldHVybiBtaWQuc3Vic3RyaW5nKDYpO1xuICB9XG59O1xuXG4vLyBQYXJzZXMgYSBmaW5nZXJwcmludCBsaW5lIGZvciBEVExTLVNSVFAuXG5TRFBVdGlscy5wYXJzZUZpbmdlcnByaW50ID0gZnVuY3Rpb24obGluZSkge1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDE0KS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIGFsZ29yaXRobTogcGFydHNbMF0udG9Mb3dlckNhc2UoKSwgLy8gYWxnb3JpdGhtIGlzIGNhc2Utc2Vuc2l0aXZlIGluIEVkZ2UuXG4gICAgdmFsdWU6IHBhcnRzWzFdLnRvVXBwZXJDYXNlKCksIC8vIHRoZSBkZWZpbml0aW9uIGlzIHVwcGVyLWNhc2UgaW4gUkZDIDQ1NzIuXG4gIH07XG59O1xuXG4vLyBFeHRyYWN0cyBEVExTIHBhcmFtZXRlcnMgZnJvbSBTRFAgbWVkaWEgc2VjdGlvbiBvciBzZXNzaW9ucGFydC5cbi8vIEZJWE1FOiBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBmdW5jdGlvbnMgdGhpcyBzaG91bGQgb25seVxuLy8gICBnZXQgdGhlIGZpbmdlcnByaW50IGxpbmUgYXMgaW5wdXQuIFNlZSBhbHNvIGdldEljZVBhcmFtZXRlcnMuXG5TRFBVdGlscy5nZXREdGxzUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCxcbiAgICAnYT1maW5nZXJwcmludDonKTtcbiAgLy8gTm90ZTogYT1zZXR1cCBsaW5lIGlzIGlnbm9yZWQgc2luY2Ugd2UgdXNlIHRoZSAnYXV0bycgcm9sZSBpbiBFZGdlLlxuICByZXR1cm4ge1xuICAgIHJvbGU6ICdhdXRvJyxcbiAgICBmaW5nZXJwcmludHM6IGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUZpbmdlcnByaW50KSxcbiAgfTtcbn07XG5cbi8vIFNlcmlhbGl6ZXMgRFRMUyBwYXJhbWV0ZXJzIHRvIFNEUC5cblNEUFV0aWxzLndyaXRlRHRsc1BhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMsIHNldHVwVHlwZSkge1xuICBsZXQgc2RwID0gJ2E9c2V0dXA6JyArIHNldHVwVHlwZSArICdcXHJcXG4nO1xuICBwYXJhbXMuZmluZ2VycHJpbnRzLmZvckVhY2goZnAgPT4ge1xuICAgIHNkcCArPSAnYT1maW5nZXJwcmludDonICsgZnAuYWxnb3JpdGhtICsgJyAnICsgZnAudmFsdWUgKyAnXFxyXFxuJztcbiAgfSk7XG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBQYXJzZXMgYT1jcnlwdG8gbGluZXMgaW50b1xuLy8gICBodHRwczovL3Jhd2dpdC5jb20vYWJvYmEvZWRnZXJ0Yy9tYXN0ZXIvbXNvcnRjLXJzNC5odG1sI2RpY3Rpb25hcnktcnRjc3J0cHNkZXNwYXJhbWV0ZXJzLW1lbWJlcnNcblNEUFV0aWxzLnBhcnNlQ3J5cHRvTGluZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyg5KS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHRhZzogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICBjcnlwdG9TdWl0ZTogcGFydHNbMV0sXG4gICAga2V5UGFyYW1zOiBwYXJ0c1syXSxcbiAgICBzZXNzaW9uUGFyYW1zOiBwYXJ0cy5zbGljZSgzKSxcbiAgfTtcbn07XG5cblNEUFV0aWxzLndyaXRlQ3J5cHRvTGluZSA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcbiAgcmV0dXJuICdhPWNyeXB0bzonICsgcGFyYW1ldGVycy50YWcgKyAnICcgK1xuICAgIHBhcmFtZXRlcnMuY3J5cHRvU3VpdGUgKyAnICcgK1xuICAgICh0eXBlb2YgcGFyYW1ldGVycy5rZXlQYXJhbXMgPT09ICdvYmplY3QnXG4gICAgICA/IFNEUFV0aWxzLndyaXRlQ3J5cHRvS2V5UGFyYW1zKHBhcmFtZXRlcnMua2V5UGFyYW1zKVxuICAgICAgOiBwYXJhbWV0ZXJzLmtleVBhcmFtcykgK1xuICAgIChwYXJhbWV0ZXJzLnNlc3Npb25QYXJhbXMgPyAnICcgKyBwYXJhbWV0ZXJzLnNlc3Npb25QYXJhbXMuam9pbignICcpIDogJycpICtcbiAgICAnXFxyXFxuJztcbn07XG5cbi8vIFBhcnNlcyB0aGUgY3J5cHRvIGtleSBwYXJhbWV0ZXJzIGludG9cbi8vICAgaHR0cHM6Ly9yYXdnaXQuY29tL2Fib2JhL2VkZ2VydGMvbWFzdGVyL21zb3J0Yy1yczQuaHRtbCNydGNzcnRwa2V5cGFyYW0qXG5TRFBVdGlscy5wYXJzZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uKGtleVBhcmFtcykge1xuICBpZiAoa2V5UGFyYW1zLmluZGV4T2YoJ2lubGluZTonKSAhPT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHBhcnRzID0ga2V5UGFyYW1zLnN1YnN0cmluZyg3KS5zcGxpdCgnfCcpO1xuICByZXR1cm4ge1xuICAgIGtleU1ldGhvZDogJ2lubGluZScsXG4gICAga2V5U2FsdDogcGFydHNbMF0sXG4gICAgbGlmZVRpbWU6IHBhcnRzWzFdLFxuICAgIG1raVZhbHVlOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCc6JylbMF0gOiB1bmRlZmluZWQsXG4gICAgbWtpTGVuZ3RoOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCc6JylbMV0gOiB1bmRlZmluZWQsXG4gIH07XG59O1xuXG5TRFBVdGlscy53cml0ZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uKGtleVBhcmFtcykge1xuICByZXR1cm4ga2V5UGFyYW1zLmtleU1ldGhvZCArICc6J1xuICAgICsga2V5UGFyYW1zLmtleVNhbHQgK1xuICAgIChrZXlQYXJhbXMubGlmZVRpbWUgPyAnfCcgKyBrZXlQYXJhbXMubGlmZVRpbWUgOiAnJykgK1xuICAgIChrZXlQYXJhbXMubWtpVmFsdWUgJiYga2V5UGFyYW1zLm1raUxlbmd0aFxuICAgICAgPyAnfCcgKyBrZXlQYXJhbXMubWtpVmFsdWUgKyAnOicgKyBrZXlQYXJhbXMubWtpTGVuZ3RoXG4gICAgICA6ICcnKTtcbn07XG5cbi8vIEV4dHJhY3RzIGFsbCBTREVTIHBhcmFtZXRlcnMuXG5TRFBVdGlscy5nZXRDcnlwdG9QYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LFxuICAgICdhPWNyeXB0bzonKTtcbiAgcmV0dXJuIGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUNyeXB0b0xpbmUpO1xufTtcblxuLy8gUGFyc2VzIElDRSBpbmZvcm1hdGlvbiBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxuLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4vLyAgIGdldCB0aGUgaWNlLXVmcmFnIGFuZCBpY2UtcHdkIGxpbmVzIGFzIGlucHV0LlxuU0RQVXRpbHMuZ2V0SWNlUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgY29uc3QgdWZyYWcgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCxcbiAgICAnYT1pY2UtdWZyYWc6JylbMF07XG4gIGNvbnN0IHB3ZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LFxuICAgICdhPWljZS1wd2Q6JylbMF07XG4gIGlmICghKHVmcmFnICYmIHB3ZCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHVzZXJuYW1lRnJhZ21lbnQ6IHVmcmFnLnN1YnN0cmluZygxMiksXG4gICAgcGFzc3dvcmQ6IHB3ZC5zdWJzdHJpbmcoMTApLFxuICB9O1xufTtcblxuLy8gU2VyaWFsaXplcyBJQ0UgcGFyYW1ldGVycyB0byBTRFAuXG5TRFBVdGlscy53cml0ZUljZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgbGV0IHNkcCA9ICdhPWljZS11ZnJhZzonICsgcGFyYW1zLnVzZXJuYW1lRnJhZ21lbnQgKyAnXFxyXFxuJyArXG4gICAgICAnYT1pY2UtcHdkOicgKyBwYXJhbXMucGFzc3dvcmQgKyAnXFxyXFxuJztcbiAgaWYgKHBhcmFtcy5pY2VMaXRlKSB7XG4gICAgc2RwICs9ICdhPWljZS1saXRlXFxyXFxuJztcbiAgfVxuICByZXR1cm4gc2RwO1xufTtcblxuLy8gUGFyc2VzIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBhbmQgcmV0dXJucyBSVENSdHBQYXJhbWV0ZXJzLlxuU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0ge1xuICAgIGNvZGVjczogW10sXG4gICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgZmVjTWVjaGFuaXNtczogW10sXG4gICAgcnRjcDogW10sXG4gIH07XG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICBjb25zdCBtbGluZSA9IGxpbmVzWzBdLnNwbGl0KCcgJyk7XG4gIGRlc2NyaXB0aW9uLnByb2ZpbGUgPSBtbGluZVsyXTtcbiAgZm9yIChsZXQgaSA9IDM7IGkgPCBtbGluZS5sZW5ndGg7IGkrKykgeyAvLyBmaW5kIGFsbCBjb2RlY3MgZnJvbSBtbGluZVszLi5dXG4gICAgY29uc3QgcHQgPSBtbGluZVtpXTtcbiAgICBjb25zdCBydHBtYXBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoXG4gICAgICBtZWRpYVNlY3Rpb24sICdhPXJ0cG1hcDonICsgcHQgKyAnICcpWzBdO1xuICAgIGlmIChydHBtYXBsaW5lKSB7XG4gICAgICBjb25zdCBjb2RlYyA9IFNEUFV0aWxzLnBhcnNlUnRwTWFwKHJ0cG1hcGxpbmUpO1xuICAgICAgY29uc3QgZm10cHMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChcbiAgICAgICAgbWVkaWFTZWN0aW9uLCAnYT1mbXRwOicgKyBwdCArICcgJyk7XG4gICAgICAvLyBPbmx5IHRoZSBmaXJzdCBhPWZtdHA6PHB0PiBpcyBjb25zaWRlcmVkLlxuICAgICAgY29kZWMucGFyYW1ldGVycyA9IGZtdHBzLmxlbmd0aCA/IFNEUFV0aWxzLnBhcnNlRm10cChmbXRwc1swXSkgOiB7fTtcbiAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KFxuICAgICAgICBtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtZmI6JyArIHB0ICsgJyAnKVxuICAgICAgICAubWFwKFNEUFV0aWxzLnBhcnNlUnRjcEZiKTtcbiAgICAgIGRlc2NyaXB0aW9uLmNvZGVjcy5wdXNoKGNvZGVjKTtcbiAgICAgIC8vIHBhcnNlIEZFQyBtZWNoYW5pc21zIGZyb20gcnRwbWFwIGxpbmVzLlxuICAgICAgc3dpdGNoIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnUkVEJzpcbiAgICAgICAgY2FzZSAnVUxQRkVDJzpcbiAgICAgICAgICBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLnB1c2goY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogLy8gb25seSBSRUQgYW5kIFVMUEZFQyBhcmUgcmVjb2duaXplZCBhcyBGRUMgbWVjaGFuaXNtcy5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1leHRtYXA6JykuZm9yRWFjaChsaW5lID0+IHtcbiAgICBkZXNjcmlwdGlvbi5oZWFkZXJFeHRlbnNpb25zLnB1c2goU0RQVXRpbHMucGFyc2VFeHRtYXAobGluZSkpO1xuICB9KTtcbiAgY29uc3Qgd2lsZGNhcmRSdGNwRmIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtZmI6KiAnKVxuICAgIC5tYXAoU0RQVXRpbHMucGFyc2VSdGNwRmIpO1xuICBkZXNjcmlwdGlvbi5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgd2lsZGNhcmRSdGNwRmIuZm9yRWFjaChmYj0+IHtcbiAgICAgIGNvbnN0IGR1cGxpY2F0ZSA9IGNvZGVjLnJ0Y3BGZWVkYmFjay5maW5kKGV4aXN0aW5nRmVlZGJhY2sgPT4ge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdGZWVkYmFjay50eXBlID09PSBmYi50eXBlICYmXG4gICAgICAgICAgZXhpc3RpbmdGZWVkYmFjay5wYXJhbWV0ZXIgPT09IGZiLnBhcmFtZXRlcjtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFkdXBsaWNhdGUpIHtcbiAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrLnB1c2goZmIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgLy8gRklYTUU6IHBhcnNlIHJ0Y3AuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn07XG5cbi8vIEdlbmVyYXRlcyBwYXJ0cyBvZiB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gZGVzY3JpYmluZyB0aGUgY2FwYWJpbGl0aWVzIC9cbi8vIHBhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZVJ0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24oa2luZCwgY2Fwcykge1xuICBsZXQgc2RwID0gJyc7XG5cbiAgLy8gQnVpbGQgdGhlIG1saW5lLlxuICBzZHAgKz0gJ209JyArIGtpbmQgKyAnICc7XG4gIHNkcCArPSBjYXBzLmNvZGVjcy5sZW5ndGggPiAwID8gJzknIDogJzAnOyAvLyByZWplY3QgaWYgbm8gY29kZWNzLlxuICBzZHAgKz0gJyAnICsgKGNhcHMucHJvZmlsZSB8fCAnVURQL1RMUy9SVFAvU0FWUEYnKSArICcgJztcbiAgc2RwICs9IGNhcHMuY29kZWNzLm1hcChjb2RlYyA9PiB7XG4gICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVjLnBheWxvYWRUeXBlO1xuICB9KS5qb2luKCcgJykgKyAnXFxyXFxuJztcblxuICBzZHAgKz0gJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nO1xuICBzZHAgKz0gJ2E9cnRjcDo5IElOIElQNCAwLjAuMC4wXFxyXFxuJztcblxuICAvLyBBZGQgYT1ydHBtYXAgbGluZXMgZm9yIGVhY2ggY29kZWMuIEFsc28gZm10cCBhbmQgcnRjcC1mYi5cbiAgY2Fwcy5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgc2RwICs9IFNEUFV0aWxzLndyaXRlUnRwTWFwKGNvZGVjKTtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVGbXRwKGNvZGVjKTtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVSdGNwRmIoY29kZWMpO1xuICB9KTtcbiAgbGV0IG1heHB0aW1lID0gMDtcbiAgY2Fwcy5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgaWYgKGNvZGVjLm1heHB0aW1lID4gbWF4cHRpbWUpIHtcbiAgICAgIG1heHB0aW1lID0gY29kZWMubWF4cHRpbWU7XG4gICAgfVxuICB9KTtcbiAgaWYgKG1heHB0aW1lID4gMCkge1xuICAgIHNkcCArPSAnYT1tYXhwdGltZTonICsgbWF4cHRpbWUgKyAnXFxyXFxuJztcbiAgfVxuXG4gIGlmIChjYXBzLmhlYWRlckV4dGVuc2lvbnMpIHtcbiAgICBjYXBzLmhlYWRlckV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlRXh0bWFwKGV4dGVuc2lvbik7XG4gICAgfSk7XG4gIH1cbiAgLy8gRklYTUU6IHdyaXRlIGZlY01lY2hhbmlzbXMuXG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mXG4vLyBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnMuXG5TRFBVdGlscy5wYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBlbmNvZGluZ1BhcmFtZXRlcnMgPSBbXTtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBTRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMobWVkaWFTZWN0aW9uKTtcbiAgY29uc3QgaGFzUmVkID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdSRUQnKSAhPT0gLTE7XG4gIGNvbnN0IGhhc1VscGZlYyA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignVUxQRkVDJykgIT09IC0xO1xuXG4gIC8vIGZpbHRlciBhPXNzcmM6Li4uIGNuYW1lOiwgaWdub3JlIFBsYW5CLW1zaWRcbiAgY29uc3Qgc3NyY3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpXG4gICAgLmZpbHRlcihwYXJ0cyA9PiBwYXJ0cy5hdHRyaWJ1dGUgPT09ICdjbmFtZScpO1xuICBjb25zdCBwcmltYXJ5U3NyYyA9IHNzcmNzLmxlbmd0aCA+IDAgJiYgc3NyY3NbMF0uc3NyYztcbiAgbGV0IHNlY29uZGFyeVNzcmM7XG5cbiAgY29uc3QgZmxvd3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmMtZ3JvdXA6RklEJylcbiAgICAubWFwKGxpbmUgPT4ge1xuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxNykuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiBwYXJ0cy5tYXAocGFydCA9PiBwYXJzZUludChwYXJ0LCAxMCkpO1xuICAgIH0pO1xuICBpZiAoZmxvd3MubGVuZ3RoID4gMCAmJiBmbG93c1swXS5sZW5ndGggPiAxICYmIGZsb3dzWzBdWzBdID09PSBwcmltYXJ5U3NyYykge1xuICAgIHNlY29uZGFyeVNzcmMgPSBmbG93c1swXVsxXTtcbiAgfVxuXG4gIGRlc2NyaXB0aW9uLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICBpZiAoY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpID09PSAnUlRYJyAmJiBjb2RlYy5wYXJhbWV0ZXJzLmFwdCkge1xuICAgICAgbGV0IGVuY1BhcmFtID0ge1xuICAgICAgICBzc3JjOiBwcmltYXJ5U3NyYyxcbiAgICAgICAgY29kZWNQYXlsb2FkVHlwZTogcGFyc2VJbnQoY29kZWMucGFyYW1ldGVycy5hcHQsIDEwKSxcbiAgICAgIH07XG4gICAgICBpZiAocHJpbWFyeVNzcmMgJiYgc2Vjb25kYXJ5U3NyYykge1xuICAgICAgICBlbmNQYXJhbS5ydHggPSB7c3NyYzogc2Vjb25kYXJ5U3NyY307XG4gICAgICB9XG4gICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaChlbmNQYXJhbSk7XG4gICAgICBpZiAoaGFzUmVkKSB7XG4gICAgICAgIGVuY1BhcmFtID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbmNQYXJhbSkpO1xuICAgICAgICBlbmNQYXJhbS5mZWMgPSB7XG4gICAgICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXG4gICAgICAgICAgbWVjaGFuaXNtOiBoYXNVbHBmZWMgPyAncmVkK3VscGZlYycgOiAncmVkJyxcbiAgICAgICAgfTtcbiAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChlbmNvZGluZ1BhcmFtZXRlcnMubGVuZ3RoID09PSAwICYmIHByaW1hcnlTc3JjKSB7XG4gICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goe1xuICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXG4gICAgfSk7XG4gIH1cblxuICAvLyB3ZSBzdXBwb3J0IGJvdGggYj1BUyBhbmQgYj1USUFTIGJ1dCBpbnRlcnByZXQgQVMgYXMgVElBUy5cbiAgbGV0IGJhbmR3aWR0aCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2I9Jyk7XG4gIGlmIChiYW5kd2lkdGgubGVuZ3RoKSB7XG4gICAgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPVRJQVM6JykgPT09IDApIHtcbiAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHJpbmcoNyksIDEwKTtcbiAgICB9IGVsc2UgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPUFTOicpID09PSAwKSB7XG4gICAgICAvLyB1c2UgZm9ybXVsYSBmcm9tIEpTRVAgdG8gY29udmVydCBiPUFTIHRvIFRJQVMgdmFsdWUuXG4gICAgICBiYW5kd2lkdGggPSBwYXJzZUludChiYW5kd2lkdGhbMF0uc3Vic3RyaW5nKDUpLCAxMCkgKiAxMDAwICogMC45NVxuICAgICAgICAgIC0gKDUwICogNDAgKiA4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFuZHdpZHRoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbmNvZGluZ1BhcmFtZXRlcnMuZm9yRWFjaChwYXJhbXMgPT4ge1xuICAgICAgcGFyYW1zLm1heEJpdHJhdGUgPSBiYW5kd2lkdGg7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nUGFyYW1ldGVycztcbn07XG5cbi8vIHBhcnNlcyBodHRwOi8vZHJhZnQub3J0Yy5vcmcvI3J0Y3J0Y3BwYXJhbWV0ZXJzKlxuU0RQVXRpbHMucGFyc2VSdGNwUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBydGNwUGFyYW1ldGVycyA9IHt9O1xuXG4gIC8vIEdldHMgdGhlIGZpcnN0IFNTUkMuIE5vdGUgdGhhdCB3aXRoIFJUWCB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZVxuICAvLyBTU1JDcy5cbiAgY29uc3QgcmVtb3RlU3NyYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAgIC5tYXAobGluZSA9PiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKSlcbiAgICAuZmlsdGVyKG9iaiA9PiBvYmouYXR0cmlidXRlID09PSAnY25hbWUnKVswXTtcbiAgaWYgKHJlbW90ZVNzcmMpIHtcbiAgICBydGNwUGFyYW1ldGVycy5jbmFtZSA9IHJlbW90ZVNzcmMudmFsdWU7XG4gICAgcnRjcFBhcmFtZXRlcnMuc3NyYyA9IHJlbW90ZVNzcmMuc3NyYztcbiAgfVxuXG4gIC8vIEVkZ2UgdXNlcyB0aGUgY29tcG91bmQgYXR0cmlidXRlIGluc3RlYWQgb2YgcmVkdWNlZFNpemVcbiAgLy8gY29tcG91bmQgaXMgIXJlZHVjZWRTaXplXG4gIGNvbnN0IHJzaXplID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLXJzaXplJyk7XG4gIHJ0Y3BQYXJhbWV0ZXJzLnJlZHVjZWRTaXplID0gcnNpemUubGVuZ3RoID4gMDtcbiAgcnRjcFBhcmFtZXRlcnMuY29tcG91bmQgPSByc2l6ZS5sZW5ndGggPT09IDA7XG5cbiAgLy8gcGFyc2VzIHRoZSBydGNwLW11eCBhdHRy0ZZidXRlLlxuICAvLyBOb3RlIHRoYXQgRWRnZSBkb2VzIG5vdCBzdXBwb3J0IHVubXV4ZWQgUlRDUC5cbiAgY29uc3QgbXV4ID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLW11eCcpO1xuICBydGNwUGFyYW1ldGVycy5tdXggPSBtdXgubGVuZ3RoID4gMDtcblxuICByZXR1cm4gcnRjcFBhcmFtZXRlcnM7XG59O1xuXG5TRFBVdGlscy53cml0ZVJ0Y3BQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocnRjcFBhcmFtZXRlcnMpIHtcbiAgbGV0IHNkcCA9ICcnO1xuICBpZiAocnRjcFBhcmFtZXRlcnMucmVkdWNlZFNpemUpIHtcbiAgICBzZHAgKz0gJ2E9cnRjcC1yc2l6ZVxcclxcbic7XG4gIH1cbiAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLm11eCkge1xuICAgIHNkcCArPSAnYT1ydGNwLW11eFxcclxcbic7XG4gIH1cbiAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLnNzcmMgIT09IHVuZGVmaW5lZCAmJiBydGNwUGFyYW1ldGVycy5jbmFtZSkge1xuICAgIHNkcCArPSAnYT1zc3JjOicgKyBydGNwUGFyYW1ldGVycy5zc3JjICtcbiAgICAgICcgY25hbWU6JyArIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lICsgJ1xcclxcbic7XG4gIH1cbiAgcmV0dXJuIHNkcDtcbn07XG5cblxuLy8gcGFyc2VzIGVpdGhlciBhPW1zaWQ6IG9yIGE9c3NyYzouLi4gbXNpZCBsaW5lcyBhbmQgcmV0dXJuc1xuLy8gdGhlIGlkIG9mIHRoZSBNZWRpYVN0cmVhbSBhbmQgTWVkaWFTdHJlYW1UcmFjay5cblNEUFV0aWxzLnBhcnNlTXNpZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBsZXQgcGFydHM7XG4gIGNvbnN0IHNwZWMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1zaWQ6Jyk7XG4gIGlmIChzcGVjLmxlbmd0aCA9PT0gMSkge1xuICAgIHBhcnRzID0gc3BlY1swXS5zdWJzdHJpbmcoNykuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge3N0cmVhbTogcGFydHNbMF0sIHRyYWNrOiBwYXJ0c1sxXX07XG4gIH1cbiAgY29uc3QgcGxhbkIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpXG4gICAgLmZpbHRlcihtc2lkUGFydHMgPT4gbXNpZFBhcnRzLmF0dHJpYnV0ZSA9PT0gJ21zaWQnKTtcbiAgaWYgKHBsYW5CLmxlbmd0aCA+IDApIHtcbiAgICBwYXJ0cyA9IHBsYW5CWzBdLnZhbHVlLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtzdHJlYW06IHBhcnRzWzBdLCB0cmFjazogcGFydHNbMV19O1xuICB9XG59O1xuXG4vLyBTQ1RQXG4vLyBwYXJzZXMgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYgZmlyc3QgYW5kIGZhbGxzIGJhY2tcbi8vIHRvIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTA1XG5TRFBVdGlscy5wYXJzZVNjdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBtbGluZSA9IFNEUFV0aWxzLnBhcnNlTUxpbmUobWVkaWFTZWN0aW9uKTtcbiAgY29uc3QgbWF4U2l6ZUxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1heC1tZXNzYWdlLXNpemU6Jyk7XG4gIGxldCBtYXhNZXNzYWdlU2l6ZTtcbiAgaWYgKG1heFNpemVMaW5lLmxlbmd0aCA+IDApIHtcbiAgICBtYXhNZXNzYWdlU2l6ZSA9IHBhcnNlSW50KG1heFNpemVMaW5lWzBdLnN1YnN0cmluZygxOSksIDEwKTtcbiAgfVxuICBpZiAoaXNOYU4obWF4TWVzc2FnZVNpemUpKSB7XG4gICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcbiAgfVxuICBjb25zdCBzY3RwUG9ydCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c2N0cC1wb3J0OicpO1xuICBpZiAoc2N0cFBvcnQubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBwb3J0OiBwYXJzZUludChzY3RwUG9ydFswXS5zdWJzdHJpbmcoMTIpLCAxMCksXG4gICAgICBwcm90b2NvbDogbWxpbmUuZm10LFxuICAgICAgbWF4TWVzc2FnZVNpemUsXG4gICAgfTtcbiAgfVxuICBjb25zdCBzY3RwTWFwTGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHBtYXA6Jyk7XG4gIGlmIChzY3RwTWFwTGluZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHBhcnRzID0gc2N0cE1hcExpbmVzWzBdXG4gICAgICAuc3Vic3RyaW5nKDEwKVxuICAgICAgLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICBwcm90b2NvbDogcGFydHNbMV0sXG4gICAgICBtYXhNZXNzYWdlU2l6ZSxcbiAgICB9O1xuICB9XG59O1xuXG4vLyBTQ1RQXG4vLyBvdXRwdXRzIHRoZSBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiB2ZXJzaW9uIHRoYXQgYWxsIGJyb3dzZXJzXG4vLyBzdXBwb3J0IGJ5IG5vdyByZWNlaXZpbmcgaW4gdGhpcyBmb3JtYXQsIHVubGVzcyB3ZSBvcmlnaW5hbGx5IHBhcnNlZFxuLy8gYXMgdGhlIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTA1IGZvcm1hdCAoaW5kaWNhdGVkIGJ5IHRoZSBtLWxpbmVcbi8vIHByb3RvY29sIG9mIERUTFMvU0NUUCAtLSB3aXRob3V0IFVEUC8gb3IgVENQLylcblNEUFV0aWxzLndyaXRlU2N0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24obWVkaWEsIHNjdHApIHtcbiAgbGV0IG91dHB1dCA9IFtdO1xuICBpZiAobWVkaWEucHJvdG9jb2wgIT09ICdEVExTL1NDVFAnKSB7XG4gICAgb3V0cHV0ID0gW1xuICAgICAgJ209JyArIG1lZGlhLmtpbmQgKyAnIDkgJyArIG1lZGlhLnByb3RvY29sICsgJyAnICsgc2N0cC5wcm90b2NvbCArICdcXHJcXG4nLFxuICAgICAgJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nLFxuICAgICAgJ2E9c2N0cC1wb3J0OicgKyBzY3RwLnBvcnQgKyAnXFxyXFxuJyxcbiAgICBdO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IFtcbiAgICAgICdtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucG9ydCArICdcXHJcXG4nLFxuICAgICAgJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nLFxuICAgICAgJ2E9c2N0cG1hcDonICsgc2N0cC5wb3J0ICsgJyAnICsgc2N0cC5wcm90b2NvbCArICcgNjU1MzVcXHJcXG4nLFxuICAgIF07XG4gIH1cbiAgaWYgKHNjdHAubWF4TWVzc2FnZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC5wdXNoKCdhPW1heC1tZXNzYWdlLXNpemU6JyArIHNjdHAubWF4TWVzc2FnZVNpemUgKyAnXFxyXFxuJyk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbi8vIEdlbmVyYXRlIGEgc2Vzc2lvbiBJRCBmb3IgU0RQLlxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtcnRjd2ViLWpzZXAtMjAjc2VjdGlvbi01LjIuMVxuLy8gcmVjb21tZW5kcyB1c2luZyBhIGNyeXB0b2dyYXBoaWNhbGx5IHJhbmRvbSArdmUgNjQtYml0IHZhbHVlXG4vLyBidXQgcmlnaHQgbm93IHRoaXMgc2hvdWxkIGJlIGFjY2VwdGFibGUgYW5kIHdpdGhpbiB0aGUgcmlnaHQgcmFuZ2VcblNEUFV0aWxzLmdlbmVyYXRlU2Vzc2lvbklkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc3Vic3RyKDIsIDIyKTtcbn07XG5cbi8vIFdyaXRlIGJvaWxlciBwbGF0ZSBmb3Igc3RhcnQgb2YgU0RQXG4vLyBzZXNzSWQgYXJndW1lbnQgaXMgb3B0aW9uYWwgLSBpZiBub3Qgc3VwcGxpZWQgaXQgd2lsbFxuLy8gYmUgZ2VuZXJhdGVkIHJhbmRvbWx5XG4vLyBzZXNzVmVyc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gMlxuLy8gc2Vzc1VzZXIgaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvICd0aGlzaXNhZGFwdGVyb3J0YydcblNEUFV0aWxzLndyaXRlU2Vzc2lvbkJvaWxlcnBsYXRlID0gZnVuY3Rpb24oc2Vzc0lkLCBzZXNzVmVyLCBzZXNzVXNlcikge1xuICBsZXQgc2Vzc2lvbklkO1xuICBjb25zdCB2ZXJzaW9uID0gc2Vzc1ZlciAhPT0gdW5kZWZpbmVkID8gc2Vzc1ZlciA6IDI7XG4gIGlmIChzZXNzSWQpIHtcbiAgICBzZXNzaW9uSWQgPSBzZXNzSWQ7XG4gIH0gZWxzZSB7XG4gICAgc2Vzc2lvbklkID0gU0RQVXRpbHMuZ2VuZXJhdGVTZXNzaW9uSWQoKTtcbiAgfVxuICBjb25zdCB1c2VyID0gc2Vzc1VzZXIgfHwgJ3RoaXNpc2FkYXB0ZXJvcnRjJztcbiAgLy8gRklYTUU6IHNlc3MtaWQgc2hvdWxkIGJlIGFuIE5UUCB0aW1lc3RhbXAuXG4gIHJldHVybiAndj0wXFxyXFxuJyArXG4gICAgICAnbz0nICsgdXNlciArICcgJyArIHNlc3Npb25JZCArICcgJyArIHZlcnNpb24gK1xuICAgICAgICAnIElOIElQNCAxMjcuMC4wLjFcXHJcXG4nICtcbiAgICAgICdzPS1cXHJcXG4nICtcbiAgICAgICd0PTAgMFxcclxcbic7XG59O1xuXG4vLyBHZXRzIHRoZSBkaXJlY3Rpb24gZnJvbSB0aGUgbWVkaWFTZWN0aW9uIG9yIHRoZSBzZXNzaW9ucGFydC5cblNEUFV0aWxzLmdldERpcmVjdGlvbiA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgLy8gTG9vayBmb3Igc2VuZHJlY3YsIHNlbmRvbmx5LCByZWN2b25seSwgaW5hY3RpdmUsIGRlZmF1bHQgdG8gc2VuZHJlY3YuXG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3dpdGNoIChsaW5lc1tpXSkge1xuICAgICAgY2FzZSAnYT1zZW5kcmVjdic6XG4gICAgICBjYXNlICdhPXNlbmRvbmx5JzpcbiAgICAgIGNhc2UgJ2E9cmVjdm9ubHknOlxuICAgICAgY2FzZSAnYT1pbmFjdGl2ZSc6XG4gICAgICAgIHJldHVybiBsaW5lc1tpXS5zdWJzdHJpbmcoMik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBGSVhNRTogV2hhdCBzaG91bGQgaGFwcGVuIGhlcmU/XG4gICAgfVxuICB9XG4gIGlmIChzZXNzaW9ucGFydCkge1xuICAgIHJldHVybiBTRFBVdGlscy5nZXREaXJlY3Rpb24oc2Vzc2lvbnBhcnQpO1xuICB9XG4gIHJldHVybiAnc2VuZHJlY3YnO1xufTtcblxuU0RQVXRpbHMuZ2V0S2luZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgY29uc3QgbWxpbmUgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xuICByZXR1cm4gbWxpbmVbMF0uc3Vic3RyaW5nKDIpO1xufTtcblxuU0RQVXRpbHMuaXNSZWplY3RlZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICByZXR1cm4gbWVkaWFTZWN0aW9uLnNwbGl0KCcgJywgMilbMV0gPT09ICcwJztcbn07XG5cblNEUFV0aWxzLnBhcnNlTUxpbmUgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIGNvbnN0IHBhcnRzID0gbGluZXNbMF0uc3Vic3RyaW5nKDIpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAga2luZDogcGFydHNbMF0sXG4gICAgcG9ydDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICBwcm90b2NvbDogcGFydHNbMl0sXG4gICAgZm10OiBwYXJ0cy5zbGljZSgzKS5qb2luKCcgJyksXG4gIH07XG59O1xuXG5TRFBVdGlscy5wYXJzZU9MaW5lID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IGxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdvPScpWzBdO1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDIpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgdXNlcm5hbWU6IHBhcnRzWzBdLFxuICAgIHNlc3Npb25JZDogcGFydHNbMV0sXG4gICAgc2Vzc2lvblZlcnNpb246IHBhcnNlSW50KHBhcnRzWzJdLCAxMCksXG4gICAgbmV0VHlwZTogcGFydHNbM10sXG4gICAgYWRkcmVzc1R5cGU6IHBhcnRzWzRdLFxuICAgIGFkZHJlc3M6IHBhcnRzWzVdLFxuICB9O1xufTtcblxuLy8gYSB2ZXJ5IG5haXZlIGludGVycHJldGF0aW9uIG9mIGEgdmFsaWQgU0RQLlxuU0RQVXRpbHMuaXNWYWxpZFNEUCA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgaWYgKHR5cGVvZiBibG9iICE9PSAnc3RyaW5nJyB8fCBibG9iLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGluZXNbaV0ubGVuZ3RoIDwgMiB8fCBsaW5lc1tpXS5jaGFyQXQoMSkgIT09ICc9Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBUT0RPOiBjaGVjayB0aGUgbW9kaWZpZXIgYSBiaXQgbW9yZS5cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICBtb2R1bGUuZXhwb3J0cyA9IFNEUFV0aWxzO1xufVxuIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IEZsYWdzLCBOdW1lcmljUGFyYW1ldGVycyB9IGZyb20gJy4uL0NvbmZpZy9Db25maWcnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuaW1wb3J0IHsgQWZrVGltZWRPdXRFdmVudCwgQWZrV2FybmluZ0FjdGl2YXRlRXZlbnQsIEFma1dhcm5pbmdEZWFjdGl2YXRlRXZlbnQsIEFma1dhcm5pbmdVcGRhdGVFdmVudCB9IGZyb20gJy4uL1V0aWwvRXZlbnRFbWl0dGVyJztcbmV4cG9ydCBjbGFzcyBBRktDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHBpeGVsU3RyZWFtaW5nLCBvbkRpc21pc3NBZmspIHtcbiAgICAgICAgLy8gdGltZSBvdXQgbG9naWMgZGV0YWlsc1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvdW50ZG93bkFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLndhcm5UaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jb3VudERvd24gPSAwO1xuICAgICAgICB0aGlzLmNvdW50RG93blRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZyA9IHBpeGVsU3RyZWFtaW5nO1xuICAgICAgICB0aGlzLm9uRGlzbWlzc0FmayA9IG9uRGlzbWlzc0FmaztcbiAgICAgICAgdGhpcy5vbkFGS1RpbWVkT3V0Q2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQUZLIHRpbWVkIG91dCwgZGlkIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoaXMgY2FsbGJhY2s/Jyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2RzIHRoYXQgb2NjdXIgd2hlbiBhbiBhZmsgZXZlbnQgbGlzdGVuZXIgaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIG9uQWZrQ2xpY2soKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jb3VudERvd25UaW1lcik7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSB8fCB0aGlzLmNvdW50ZG93bkFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydEFma1dhcm5pbmdUaW1lcigpO1xuICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBBZmtXYXJuaW5nRGVhY3RpdmF0ZUV2ZW50KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSB3YXJuaW5nIHRpbWVyIGlmIGEgdGltZW91dCBpcyBzZXQgZ3JlYXRlciB0aGF0IDAgc2Vjb25kc1xuICAgICAqL1xuICAgIHN0YXJ0QWZrV2FybmluZ1RpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZ2V0TnVtZXJpY1NldHRpbmdWYWx1ZShOdW1lcmljUGFyYW1ldGVycy5BRktUaW1lb3V0U2VjcykgPiAwICYmXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkFGS0RldGVjdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldEFma1dhcm5pbmdUaW1lcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSBhZmsgd2FybmluZyB0aW1lclxuICAgICAqL1xuICAgIHN0b3BBZmtXYXJuaW5nVGltZXIoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY291bnRkb3duQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLndhcm5UaW1lcik7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jb3VudERvd25UaW1lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdXNlIHRoZSB0aW1lciB3aGljaCB3aGVuIGVsYXBzZWQgd2lsbCB3YXJuIHRoZSB1c2VyIHRoZXkgYXJlIGluYWN0aXZlLlxuICAgICAqL1xuICAgIHBhdXNlQWZrV2FybmluZ1RpbWVyKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdXNlciBpbnRlcmFjdHMgdGhlbiByZXNldCB0aGUgd2FybmluZyB0aW1lci5cbiAgICAgKi9cbiAgICByZXNldEFma1dhcm5pbmdUaW1lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlICYmIHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuQUZLRGV0ZWN0aW9uKSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMud2FyblRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMud2FyblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmFjdGl2YXRlQWZrRXZlbnQoKSwgdGhpcy5jb25maWcuZ2V0TnVtZXJpY1NldHRpbmdWYWx1ZShOdW1lcmljUGFyYW1ldGVycy5BRktUaW1lb3V0U2VjcykgKiAxMDAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBBRksgb3ZlcmxheSBhbmQgYmVnaW4gdGhlIGNvdW50RG93blxuICAgICAqL1xuICAgIGFjdGl2YXRlQWZrRXZlbnQoKSB7XG4gICAgICAgIC8vIFBhdXNlIHRoZSB0aW1lciB3aGlsZSB0aGUgdXNlciBpcyBsb29raW5nIGF0IHRoZSBpbmFjdGl2aXR5IHdhcm5pbmcgb3ZlcmxheVxuICAgICAgICB0aGlzLnBhdXNlQWZrV2FybmluZ1RpbWVyKCk7XG4gICAgICAgIC8vIGluc3RhbnRpYXRlIGEgbmV3IG92ZXJsYXlcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBBZmtXYXJuaW5nQWN0aXZhdGVFdmVudCh7XG4gICAgICAgICAgICBjb3VudERvd246IHRoaXMuY291bnREb3duLFxuICAgICAgICAgICAgZGlzbWlzc0FmazogdGhpcy5vbkRpc21pc3NBZmtcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyB1cGRhdGUgb3VyIGNvdW50RG93biB0aW1lciBhbmQgb3ZlcmxheSBjb250ZW50c1xuICAgICAgICB0aGlzLmNvdW50RG93biA9IHRoaXMuY29uZmlnLmdldE51bWVyaWNTZXR0aW5nVmFsdWUoTnVtZXJpY1BhcmFtZXRlcnMuQUZLQ291bnRkb3duU2Vjcyk7XG4gICAgICAgIHRoaXMuY291bnRkb3duQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBBZmtXYXJuaW5nVXBkYXRlRXZlbnQoeyBjb3VudERvd246IHRoaXMuY291bnREb3duIH0pKTtcbiAgICAgICAgLy8gaWYgd2UgYXJlIGluIGxvY2tlZCBtb3VzZSBleGl0IHBvaW50ZXJsb2NrXG4gICAgICAgIGlmICghdGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5Ib3ZlcmluZ01vdXNlTW9kZSkpIHtcbiAgICAgICAgICAgIC8vIG1pbm9yIGhhY2sgdG8gYWxsZXZpYXRlIGlvcyBub3Qgc3VwcG9ydGluZyBwb2ludGVybG9ja1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmV4aXRQb2ludGVyTG9jaykge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmV4aXRQb2ludGVyTG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlc2V0IG91ciBjb3VudERvd24gaW50ZXJ2YWwgYWNjb3JkaW5nbHlcbiAgICAgICAgdGhpcy5jb3VudERvd25UaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY291bnREb3duLS07XG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudERvd24gPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB1c2VyIGZhaWxlZCB0byBjbGljayBzbyBoaWRlIHRoZSBvdmVybGF5IGFuZCBkaXNjb25uZWN0IHRoZW0uXG4gICAgICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBBZmtUaW1lZE91dEV2ZW50KCkpO1xuICAgICAgICAgICAgICAgIHRoaXMub25BRktUaW1lZE91dENhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ1lvdSBoYXZlIGJlZW4gZGlzY29ubmVjdGVkIGR1ZSB0byBpbmFjdGl2aXR5Jyk7XG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoIG9mZiB0aGUgYWZrIGZlYXR1cmUgYXMgc3RyZWFtIGhhcyBjbG9zZWRcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BBZmtXYXJuaW5nVGltZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuZGlzcGF0Y2hFdmVudChuZXcgQWZrV2FybmluZ1VwZGF0ZUV2ZW50KHsgY291bnREb3duOiB0aGlzLmNvdW50RG93biB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMDApO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFGS0NvbnRyb2xsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42JztcbmltcG9ydCB7IFNldHRpbmdGbGFnIH0gZnJvbSAnLi9TZXR0aW5nRmxhZyc7XG5pbXBvcnQgeyBTZXR0aW5nTnVtYmVyIH0gZnJvbSAnLi9TZXR0aW5nTnVtYmVyJztcbmltcG9ydCB7IFNldHRpbmdUZXh0IH0gZnJvbSAnLi9TZXR0aW5nVGV4dCc7XG5pbXBvcnQgeyBTZXR0aW5nT3B0aW9uIH0gZnJvbSAnLi9TZXR0aW5nT3B0aW9uJztcbmltcG9ydCB7IFNldHRpbmdzQ2hhbmdlZEV2ZW50IH0gZnJvbSAnLi4vVXRpbC9FdmVudEVtaXR0ZXInO1xuaW1wb3J0IHsgQnJvd3NlclV0aWxzIH0gZnJvbSAnLi4vVXRpbC9Ccm93c2VyVXRpbHMnO1xuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgZmxhZ3MgdGhhdCBjYW4gYmUgdG9nZ2xlZCBhbmQgYXJlIGNvcmUgdG8gYWxsIFBpeGVsIFN0cmVhbWluZyBleHBlcmllbmNlcy5cbiAqIFRoZXNlIGFyZSB1c2VkIGluIHRoZSBgQ29uZmlnLkZsYWdzYCBtYXAuXG4gKi9cbmV4cG9ydCBjbGFzcyBGbGFncyB7XG59XG5GbGFncy5BdXRvQ29ubmVjdCA9ICdBdXRvQ29ubmVjdCc7XG5GbGFncy5BdXRvUGxheVZpZGVvID0gJ0F1dG9QbGF5VmlkZW8nO1xuRmxhZ3MuQUZLRGV0ZWN0aW9uID0gJ1RpbWVvdXRJZklkbGUnO1xuRmxhZ3MuSG92ZXJpbmdNb3VzZU1vZGUgPSAnSG92ZXJpbmdNb3VzZSc7XG5GbGFncy5Gb3JjZU1vbm9BdWRpbyA9ICdGb3JjZU1vbm9BdWRpbyc7XG5GbGFncy5Gb3JjZVRVUk4gPSAnRm9yY2VUVVJOJztcbkZsYWdzLkZha2VNb3VzZVdpdGhUb3VjaGVzID0gJ0Zha2VNb3VzZVdpdGhUb3VjaGVzJztcbkZsYWdzLklzUXVhbGl0eUNvbnRyb2xsZXIgPSAnQ29udHJvbHNRdWFsaXR5JztcbkZsYWdzLk1hdGNoVmlld3BvcnRSZXNvbHV0aW9uID0gJ01hdGNoVmlld3BvcnRSZXMnO1xuRmxhZ3MuU3RhcnRWaWRlb011dGVkID0gJ1N0YXJ0VmlkZW9NdXRlZCc7XG5GbGFncy5TdXBwcmVzc0Jyb3dzZXJLZXlzID0gJ1N1cHByZXNzQnJvd3NlcktleXMnO1xuRmxhZ3MuVXNlTWljID0gJ1VzZU1pYyc7XG5GbGFncy5Vc2VNb2RhbEZvclRleHRJbnB1dCA9ICdVc2VNb2RhbEZvclRleHRJbnB1dCc7XG5GbGFncy5Vc2VDYW1lcmEgPSAnVXNlQ2FtZXJhJztcbkZsYWdzLktleWJvYXJkSW5wdXQgPSAnS2V5Ym9hcmRJbnB1dCc7XG5GbGFncy5Nb3VzZUlucHV0ID0gJ01vdXNlSW5wdXQnO1xuRmxhZ3MuVG91Y2hJbnB1dCA9ICdUb3VjaElucHV0JztcbkZsYWdzLkdhbWVwYWRJbnB1dCA9ICdHYW1lcGFkSW5wdXQnO1xuRmxhZ3MuWFJDb250cm9sbGVySW5wdXQgPSAnWFJDb250cm9sbGVySW5wdXQnO1xuRmxhZ3MuV2FpdEZvclN0cmVhbWVyID0gJ1dhaXRGb3JTdHJlYW1lcic7XG5GbGFncy5IaWRlVUkgPSAnSGlkZVVJJztcbkZsYWdzLkVuYWJsZUNhcHR1cmVUaW1lRXh0ID0gJ0VuYWJsZUNhcHR1cmVUaW1lRXh0JztcbkZsYWdzLkJyb3dzZXJTZW5kT2ZmZXIgPSAnQnJvd3NlclNlbmRPZmZlcic7XG5GbGFncy5MYXRlbmN5Q1NWID0gJ0xhdGVuY3lDU1YnO1xuZXhwb3J0IGNvbnN0IGlzRmxhZ0lkID0gKGlkKSA9PiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhGbGFncykuc29tZSgobmFtZSkgPT4gRmxhZ3NbbmFtZV0gPT09IGlkKTtcbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIG51bWVyaWMgcGFyYW1ldGVycyB0aGF0IGFyZSBjb3JlIHRvIGFsbCBQaXhlbCBTdHJlYW1pbmcgZXhwZXJpZW5jZXMuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgTnVtZXJpY1BhcmFtZXRlcnMge1xufVxuTnVtZXJpY1BhcmFtZXRlcnMuQUZLVGltZW91dFNlY3MgPSAnQUZLVGltZW91dCc7XG5OdW1lcmljUGFyYW1ldGVycy5BRktDb3VudGRvd25TZWNzID0gJ0FGS0NvdW50ZG93bic7XG5OdW1lcmljUGFyYW1ldGVycy5NaW5RUCA9ICdNaW5RUCc7XG5OdW1lcmljUGFyYW1ldGVycy5NYXhRUCA9ICdNYXhRUCc7XG5OdW1lcmljUGFyYW1ldGVycy5NaW5RdWFsaXR5ID0gJ01pblF1YWxpdHknO1xuTnVtZXJpY1BhcmFtZXRlcnMuTWF4UXVhbGl0eSA9ICdNYXhRdWFsaXR5Jztcbk51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNaW4gPSAnQ29tcGF0UXVhbGl0eU1pbic7XG5OdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWF4ID0gJ0NvbXBhdFF1YWxpdHlNYXgnO1xuTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDRlBTID0gJ1dlYlJUQ0ZQUyc7XG5OdW1lcmljUGFyYW1ldGVycy5XZWJSVENNaW5CaXRyYXRlID0gJ1dlYlJUQ01pbkJpdHJhdGUnO1xuTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWF4Qml0cmF0ZSA9ICdXZWJSVENNYXhCaXRyYXRlJztcbk51bWVyaWNQYXJhbWV0ZXJzLk1heFJlY29ubmVjdEF0dGVtcHRzID0gJ01heFJlY29ubmVjdEF0dGVtcHRzJztcbk51bWVyaWNQYXJhbWV0ZXJzLlN0cmVhbWVyQXV0b0pvaW5JbnRlcnZhbCA9ICdTdHJlYW1lckF1dG9Kb2luSW50ZXJ2YWwnO1xuTnVtZXJpY1BhcmFtZXRlcnMuS2VlcGFsaXZlRGVsYXkgPSAnS2VlcGFsaXZlRGVsYXknO1xuZXhwb3J0IGNvbnN0IGlzTnVtZXJpY0lkID0gKGlkKSA9PiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhOdW1lcmljUGFyYW1ldGVycykuc29tZSgobmFtZSkgPT4gTnVtZXJpY1BhcmFtZXRlcnNbbmFtZV0gPT09IGlkKTtcbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHRleHR1YWwgcGFyYW1ldGVycyB0aGF0IGFyZSBjb3JlIHRvIGFsbCBQaXhlbCBTdHJlYW1pbmcgZXhwZXJpZW5jZXMuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgVGV4dFBhcmFtZXRlcnMge1xufVxuVGV4dFBhcmFtZXRlcnMuU2lnbmFsbGluZ1NlcnZlclVybCA9ICdzcyc7XG5leHBvcnQgY29uc3QgaXNUZXh0SWQgPSAoaWQpID0+IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFRleHRQYXJhbWV0ZXJzKS5zb21lKChuYW1lKSA9PiBUZXh0UGFyYW1ldGVyc1tuYW1lXSA9PT0gaWQpO1xuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgZW51bSBiYXNlZCBwYXJhbWV0ZXJzIHRoYXQgYXJlIGNvcmUgdG8gYWxsIFBpeGVsIFN0cmVhbWluZyBleHBlcmllbmNlcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBPcHRpb25QYXJhbWV0ZXJzIHtcbn1cbk9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkQ29kZWMgPSAnUHJlZmVycmVkQ29kZWMnO1xuT3B0aW9uUGFyYW1ldGVycy5TdHJlYW1lcklkID0gJ1N0cmVhbWVySWQnO1xuT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRRdWFsaXR5ID0gJ1ByZWZlcnJlZFF1YWxpdHknO1xuZXhwb3J0IGNvbnN0IGlzT3B0aW9uSWQgPSAoaWQpID0+IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9wdGlvblBhcmFtZXRlcnMpLnNvbWUoKG5hbWUpID0+IE9wdGlvblBhcmFtZXRlcnNbbmFtZV0gPT09IGlkKTtcbmV4cG9ydCBjbGFzcyBDb25maWcge1xuICAgIC8vIC0tLS0tLS0tLS0tLSBTZXR0aW5ncyAtLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIC8qIEEgbWFwIG9mIGZsYWdzIHRoYXQgY2FuIGJlIHRvZ2dsZWQgLSBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCBpbiB0aGUgYXBwbGljYXRpb24gLSBlLmcuIFVzZSBNaWM/ICovXG4gICAgICAgIHRoaXMuZmxhZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qIEEgbWFwIG9mIG51bWVyaWNhbCBzZXR0aW5ncyAtIG9wdGlvbnMgdGhhdCBjYW4gYmUgaW4gdGhlIGFwcGxpY2F0aW9uIC0gZS5nLiBNaW5CaXRyYXRlICovXG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qIEEgbWFwIG9mIHRleHQgc2V0dGluZ3MgLSBlLmcuIHNpZ25hbGxpbmcgc2VydmVyIHVybCAqL1xuICAgICAgICB0aGlzLnRleHRQYXJhbWV0ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiBBIG1hcCBvZiBlbnVtIGJhc2VkIHNldHRpbmdzIC0gZS5nLiBwcmVmZXJyZWQgY29kZWMgKi9cbiAgICAgICAgdGhpcy5vcHRpb25QYXJhbWV0ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCB7IGluaXRpYWxTZXR0aW5ncywgdXNlVXJsUGFyYW1zLCB3ZWJTb2NrZXRQcm90b2NvbHMgfSA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5fdXNlVXJsUGFyYW1zID0gISF1c2VVcmxQYXJhbXM7XG4gICAgICAgIHRoaXMuX3dlYlNvY2tldFByb3RvY29scyA9IHdlYlNvY2tldFByb3RvY29scztcbiAgICAgICAgdGhpcy5wb3B1bGF0ZURlZmF1bHRTZXR0aW5ncyh0aGlzLl91c2VVcmxQYXJhbXMsIGluaXRpYWxTZXR0aW5ncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgcmVhZGluZyBjb25maWd1cmF0aW9uIGluaXRpYWwgdmFsdWVzIGZyb20gVVJMIHBhcmFtZXRlcnMsIGFuZFxuICAgICAqIHBlcnNpc3RpbmcgY2hhbmdlcyBpbiBVUkwgd2hlbiBjaGFuZ2VkLlxuICAgICAqL1xuICAgIGdldCB1c2VVcmxQYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91c2VVcmxQYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBwcm90b2NvbCBvciBsaXN0IG9mIHByb3RvY29scyB0byBwYXNzIHRvIHRoZSB3ZWJzb2NrZXQgaWYgc2V0LlxuICAgICAqL1xuICAgIGdldCB3ZWJTb2NrZXRQcm90b2NvbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWJTb2NrZXRQcm90b2NvbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlIHRoZSBkZWZhdWx0IHNldHRpbmdzIGZvciBhIFBpeGVsIFN0cmVhbWluZyBhcHBsaWNhdGlvblxuICAgICAqL1xuICAgIHBvcHVsYXRlRGVmYXVsdFNldHRpbmdzKHVzZVVybFBhcmFtcywgc2V0dGluZ3MpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRleHQgUGFyYW1ldGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZXh0UGFyYW1ldGVycy5zZXQoVGV4dFBhcmFtZXRlcnMuU2lnbmFsbGluZ1NlcnZlclVybCwgbmV3IFNldHRpbmdUZXh0KFRleHRQYXJhbWV0ZXJzLlNpZ25hbGxpbmdTZXJ2ZXJVcmwsICdTaWduYWxsaW5nIHVybCcsICdVcmwgb2YgdGhlIHNpZ25hbGxpbmcgc2VydmVyJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBUZXh0UGFyYW1ldGVycy5TaWduYWxsaW5nU2VydmVyVXJsKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tUZXh0UGFyYW1ldGVycy5TaWduYWxsaW5nU2VydmVyVXJsXVxuICAgICAgICAgICAgOiAobG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonID8gJ3dzczovLycgOiAnd3M6Ly8nKSArXG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lICtcbiAgICAgICAgICAgICAgICAvLyBmb3IgcmVhZGFiaWxpdHksIHdlIG9taXQgdGhlIHBvcnQgaWYgaXQncyA4MFxuICAgICAgICAgICAgICAgICh3aW5kb3cubG9jYXRpb24ucG9ydCA9PT0gJzgwJyB8fCB3aW5kb3cubG9jYXRpb24ucG9ydCA9PT0gJydcbiAgICAgICAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICAgICAgICA6IGA6JHt3aW5kb3cubG9jYXRpb24ucG9ydH1gKSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMub3B0aW9uUGFyYW1ldGVycy5zZXQoT3B0aW9uUGFyYW1ldGVycy5TdHJlYW1lcklkLCBuZXcgU2V0dGluZ09wdGlvbihPcHRpb25QYXJhbWV0ZXJzLlN0cmVhbWVySWQsICdTdHJlYW1lciBJRCcsICdUaGUgSUQgb2YgdGhlIHN0cmVhbWVyIHRvIHN0cmVhbS4nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIE9wdGlvblBhcmFtZXRlcnMuU3RyZWFtZXJJZClcbiAgICAgICAgICAgID8gc2V0dGluZ3NbT3B0aW9uUGFyYW1ldGVycy5TdHJlYW1lcklkXVxuICAgICAgICAgICAgOiAnJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBPcHRpb25QYXJhbWV0ZXJzLlN0cmVhbWVySWQpXG4gICAgICAgICAgICA/IFtzZXR0aW5nc1tPcHRpb25QYXJhbWV0ZXJzLlN0cmVhbWVySWRdXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICBjb25zdCBnZXREZWZhdWx0VmlkZW9Db2RlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZGVvQ29kZWNzID0gQnJvd3NlclV0aWxzLmdldFN1cHBvcnRlZFZpZGVvQ29kZWNzKCk7XG4gICAgICAgICAgICAvLyBJZiBvbmx5IG9uZSBvcHRpb24sIHRoZW4gc2VsZWN0IHRoYXQuXG4gICAgICAgICAgICBpZiAodmlkZW9Db2RlY3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW9Db2RlY3NbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2aWRlb0NvZGVjcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdENvZGVjID0gdmlkZW9Db2RlY3NbMF07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb2RlYyBvZiB2aWRlb0NvZGVjcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZWMuc3RhcnRzV2l0aCgnSDI2NCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZWM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRDb2RlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIExvZ2dlci5FcnJvcignQ291bGQgbm90IGZpbmQgYW55IHJlYXNvbmFibGUgdmlkZW8gY29kZWMgdG8gYXNzaWduIGFzIGEgZGVmYXVsdC4nKTtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWF0Y2hTcGVjaWZpZWRDb2RlY1RvQ2xvc2VzdFN1cHBvcnRlZCA9IGZ1bmN0aW9uIChzcGVjaWZpZWRDb2RlYykge1xuICAgICAgICAgICAgY29uc3QgYnJvd3NlclN1cHBvcnRlZENvZGVjcyA9IEJyb3dzZXJVdGlscy5nZXRTdXBwb3J0ZWRWaWRlb0NvZGVjcygpO1xuICAgICAgICAgICAgLy8gQ29kZWMgc3VwcGxpZWQgaW4gdXJsIHBhcmFtIGlzIGFuIGV4YWN0IG1hdGNoIGZvciB0aGUgYnJvd3NlciBjb2RlYy5cbiAgICAgICAgICAgIC8vIChlLmcuIEgyNjQgbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQ9MTtwYWNrZXRpemF0aW9uLW1vZGU9MTtwcm9maWxlLWxldmVsLWlkPTQyZTAxZilcbiAgICAgICAgICAgIGlmIChicm93c2VyU3VwcG9ydGVkQ29kZWNzLmluY2x1ZGVzKHNwZWNpZmllZENvZGVjKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVjaWZpZWRDb2RlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRyeSB0byBtYXRjaCB0aGUgc3RhcnQgb2Ygd2hhdGV2ZXIgaXMgcGFzc2VkIGludG8gdGhlIHVybCBwYXJhbWV0ZXIgd2l0aCB3aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJyb3dzZXJDb2RlYyBvZiBicm93c2VyU3VwcG9ydGVkQ29kZWNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyb3dzZXJDb2RlYy5zdGFydHNXaXRoKHNwZWNpZmllZENvZGVjKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3NlckNvZGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIHdlcmVuJ3QgYWJsZSB0byBtYXRjaCwganVzdCByZXR1cm4gdGhlIGNvZGVjIGFzIGZyb20gdGhlIFVSTCBhcy1pcy5cbiAgICAgICAgICAgIHJldHVybiBzcGVjaWZpZWRDb2RlYztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVudW0gUGFyYW1ldGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpb25QYXJhbWV0ZXJzLnNldChPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZENvZGVjLCBuZXcgU2V0dGluZ09wdGlvbihPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZENvZGVjLCAnUHJlZmVycmVkIENvZGVjJywgJ1RoZSBwcmVmZXJyZWQgY29kZWMgdG8gYmUgdXNlZCBkdXJpbmcgY29kZWMgbmVnb3RpYXRpb24nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkQ29kZWMpXG4gICAgICAgICAgICA/IG1hdGNoU3BlY2lmaWVkQ29kZWNUb0Nsb3Nlc3RTdXBwb3J0ZWQoc2V0dGluZ3NbT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRDb2RlY10pXG4gICAgICAgICAgICA6IGdldERlZmF1bHRWaWRlb0NvZGVjKCksIEJyb3dzZXJVdGlscy5nZXRTdXBwb3J0ZWRWaWRlb0NvZGVjcygpLCB1c2VVcmxQYXJhbXMsIG1hdGNoU3BlY2lmaWVkQ29kZWNUb0Nsb3Nlc3RTdXBwb3J0ZWQpKTtcbiAgICAgICAgdGhpcy5vcHRpb25QYXJhbWV0ZXJzLnNldChPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZFF1YWxpdHksIG5ldyBTZXR0aW5nT3B0aW9uKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkUXVhbGl0eSwgJ1ByZWZlcnJlZCBRdWFsaXR5JywgJ1RoZSBwcmVmZXJyZWQgcXVhbGl0eSBvZiB0aGUgc3RyZWFtIChvbmx5IGFwcGxpY2FibGUgd2hlbiB1c2luZyB0aGUgU0ZVKScsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRRdWFsaXR5KVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZFF1YWxpdHldXG4gICAgICAgICAgICA6ICdEZWZhdWx0JywgWydEZWZhdWx0J10sIHVzZVVybFBhcmFtcykpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQm9vbGVhbiBwYXJhbWV0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5BdXRvQ29ubmVjdCwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLkF1dG9Db25uZWN0LCAnQXV0byBjb25uZWN0IHRvIHN0cmVhbScsICdXaGV0aGVyIHdlIHNob3VsZCBhdHRlbXB0IHRvIGF1dG8gY29ubmVjdCB0byB0aGUgc2lnbmFsbGluZyBzZXJ2ZXIgb3Igc2hvdyBhIGNsaWNrIHRvIHN0YXJ0IHByb21wdC4nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLkF1dG9Db25uZWN0KVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5BdXRvQ29ubmVjdF1cbiAgICAgICAgICAgIDogZmFsc2UsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5BdXRvUGxheVZpZGVvLCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuQXV0b1BsYXlWaWRlbywgJ0F1dG8gcGxheSB2aWRlbycsICdXaGVuIHZpZGVvIGlzIHJlYWR5IGF1dG9tYXRpY2FsbHkgc3RhcnQgcGxheWluZyBpdCBhcyBvcHBvc2VkIHRvIHNob3dpbmcgYSBwbGF5IGJ1dHRvbi4nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLkF1dG9QbGF5VmlkZW8pXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLkF1dG9QbGF5VmlkZW9dXG4gICAgICAgICAgICA6IHRydWUsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5Vc2VNaWMsIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5Vc2VNaWMsICdVc2UgbWljcm9waG9uZScsICdNYWtlIGJyb3dzZXIgcmVxdWVzdCBtaWNyb3Bob25lIGFjY2VzcyBhbmQgb3BlbiBhbiBpbnB1dCBhdWRpbyB0cmFjay4nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLlVzZU1pYylcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuVXNlTWljXVxuICAgICAgICAgICAgOiBmYWxzZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLlVzZU1vZGFsRm9yVGV4dElucHV0LCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuVXNlTW9kYWxGb3JUZXh0SW5wdXQsICdVc2UgbW9kYWwgZm9yIHRleHQgaW5wdXQnLCAnV2hlbiBlbnRlcmluZyBpbnB1dCBpbnRvIGEgc3RyZWFtZWQgVUUgdGV4dCB3aWRnZXQsIHVzZSBhbiBpbnB1dCBtb2RhbC4nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLlVzZU1vZGFsRm9yVGV4dElucHV0KVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5Vc2VNb2RhbEZvclRleHRJbnB1dF1cbiAgICAgICAgICAgIDogdHJ1ZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLlVzZUNhbWVyYSwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLlVzZUNhbWVyYSwgJ1VzZSB3ZWJjYW0nLCAnTWFrZSBicm93c2VyIHJlcXVlc3Qgd2ViY2FtIGFjY2VzcyBhbmQgb3BlbiBhIGlucHV0IHZpZGVvIHRyYWNrLicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuVXNlQ2FtZXJhKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5Vc2VDYW1lcmFdXG4gICAgICAgICAgICA6IGZhbHNlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuU3RhcnRWaWRlb011dGVkLCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuU3RhcnRWaWRlb011dGVkLCAnU3RhcnQgdmlkZW8gbXV0ZWQnLCAnVmlkZW8gd2lsbCBzdGFydCBtdXRlZCBpZiB0cnVlLicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuU3RhcnRWaWRlb011dGVkKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5TdGFydFZpZGVvTXV0ZWRdXG4gICAgICAgICAgICA6IGZhbHNlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuU3VwcHJlc3NCcm93c2VyS2V5cywgbmV3IFNldHRpbmdGbGFnKEZsYWdzLlN1cHByZXNzQnJvd3NlcktleXMsICdTdXBwcmVzcyBicm93c2VyIGtleXMnLCAnU3VwcHJlc3MgY2VydGFpbiBicm93c2VyIGtleXMgdGhhdCB3ZSB1c2UgaW4gVUUsIGZvciBleGFtcGxlIEY1IHRvIHNob3cgc2hhZGVyIGNvbXBsZXhpdHkgaW5zdGVhZCBvZiByZWZyZXNoIHRoZSBwYWdlLicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuU3VwcHJlc3NCcm93c2VyS2V5cylcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuU3VwcHJlc3NCcm93c2VyS2V5c11cbiAgICAgICAgICAgIDogdHJ1ZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLklzUXVhbGl0eUNvbnRyb2xsZXIsIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5Jc1F1YWxpdHlDb250cm9sbGVyLCAnSXMgcXVhbGl0eSBjb250cm9sbGVyPycsICdUcnVlIGlmIHRoaXMgcGVlciBjb250cm9scyBzdHJlYW0gcXVhbGl0eScsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuSXNRdWFsaXR5Q29udHJvbGxlcilcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuSXNRdWFsaXR5Q29udHJvbGxlcl1cbiAgICAgICAgICAgIDogdHJ1ZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLkZvcmNlTW9ub0F1ZGlvLCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuRm9yY2VNb25vQXVkaW8sICdGb3JjZSBtb25vIGF1ZGlvJywgJ0ZvcmNlIGJyb3dzZXIgdG8gcmVxdWVzdCBtb25vIGF1ZGlvIGluIHRoZSBTRFAnLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLkZvcmNlTW9ub0F1ZGlvKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5Gb3JjZU1vbm9BdWRpb11cbiAgICAgICAgICAgIDogZmFsc2UsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5Gb3JjZVRVUk4sIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5Gb3JjZVRVUk4sICdGb3JjZSBUVVJOJywgJ09ubHkgZ2VuZXJhdGUgVFVSTi9SZWxheWVkIElDRSBjYW5kaWRhdGVzLicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuRm9yY2VUVVJOKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5Gb3JjZVRVUk5dXG4gICAgICAgICAgICA6IGZhbHNlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuQUZLRGV0ZWN0aW9uLCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuQUZLRGV0ZWN0aW9uLCAnQUZLIGlmIGlkbGUnLCAnVGltZW91dCB0aGUgZXhwZXJpZW5jZSBpZiB1c2VyIGlzIEFGSyBmb3IgYSBwZXJpb2QuJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5BRktEZXRlY3Rpb24pXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLkFGS0RldGVjdGlvbl1cbiAgICAgICAgICAgIDogZmFsc2UsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5NYXRjaFZpZXdwb3J0UmVzb2x1dGlvbiwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLk1hdGNoVmlld3BvcnRSZXNvbHV0aW9uLCAnTWF0Y2ggdmlld3BvcnQgcmVzb2x1dGlvbicsICdQaXhlbCBTdHJlYW1pbmcgd2lsbCBiZSBpbnN0cnVjdGVkIHRvIGR5bmFtaWNhbGx5IHJlc2l6ZSB0aGUgdmlkZW8gc3RyZWFtIHRvIG1hdGNoIHRoZSBzaXplIG9mIHRoZSB2aWRlbyBlbGVtZW50LicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuTWF0Y2hWaWV3cG9ydFJlc29sdXRpb24pXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLk1hdGNoVmlld3BvcnRSZXNvbHV0aW9uXVxuICAgICAgICAgICAgOiBmYWxzZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLkhvdmVyaW5nTW91c2VNb2RlLCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuSG92ZXJpbmdNb3VzZU1vZGUsICdDb250cm9sIFNjaGVtZTogTG9ja2VkIE1vdXNlJywgJ0VpdGhlciBsb2NrZWQgbW91c2UsIHdoZXJlIHRoZSBwb2ludGVyIGlzIGNvbnN1bWVkIGJ5IHRoZSB2aWRlbyBhbmQgbG9ja2VkIHRvIGl0LCBvciBob3ZlcmluZyBtb3VzZSwgd2hlcmUgdGhlIG1vdXNlIGlzIG5vdCBjb25zdW1lZC4nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLkhvdmVyaW5nTW91c2VNb2RlKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5Ib3ZlcmluZ01vdXNlTW9kZV1cbiAgICAgICAgICAgIDogZmFsc2UsIHVzZVVybFBhcmFtcywgKGlzSG92ZXJpbmdNb3VzZSwgc2V0dGluZykgPT4ge1xuICAgICAgICAgICAgc2V0dGluZy5sYWJlbCA9IGBDb250cm9sIFNjaGVtZTogJHtpc0hvdmVyaW5nTW91c2UgPyAnSG92ZXJpbmcnIDogJ0xvY2tlZCd9IE1vdXNlYDtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5GYWtlTW91c2VXaXRoVG91Y2hlcywgbmV3IFNldHRpbmdGbGFnKEZsYWdzLkZha2VNb3VzZVdpdGhUb3VjaGVzLCAnRmFrZSBtb3VzZSB3aXRoIHRvdWNoZXMnLCAnQSBzaW5nbGUgZmluZ2VyIHRvdWNoIGlzIGNvbnZlcnRlZCBpbnRvIGEgbW91c2UgZXZlbnQuIFRoaXMgYWxsb3dzIGEgbm9uLXRvdWNoIGFwcGxpY2F0aW9uIHRvIGJlIGNvbnRyb2xsZWQgcGFydGlhbGx5IHZpYSBhIHRvdWNoIGRldmljZS4nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLkZha2VNb3VzZVdpdGhUb3VjaGVzKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5GYWtlTW91c2VXaXRoVG91Y2hlc11cbiAgICAgICAgICAgIDogZmFsc2UsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5LZXlib2FyZElucHV0LCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuS2V5Ym9hcmRJbnB1dCwgJ0tleWJvYXJkIGlucHV0JywgJ0lmIGVuYWJsZWQsIHNlbmQga2V5Ym9hcmQgZXZlbnRzIHRvIHN0cmVhbWVyJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5LZXlib2FyZElucHV0KVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5LZXlib2FyZElucHV0XVxuICAgICAgICAgICAgOiB0cnVlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuTW91c2VJbnB1dCwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLk1vdXNlSW5wdXQsICdNb3VzZSBpbnB1dCcsICdJZiBlbmFibGVkLCBzZW5kIG1vdXNlIGV2ZW50cyB0byBzdHJlYW1lcicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuTW91c2VJbnB1dClcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuTW91c2VJbnB1dF1cbiAgICAgICAgICAgIDogdHJ1ZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLlRvdWNoSW5wdXQsIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5Ub3VjaElucHV0LCAnVG91Y2ggaW5wdXQnLCAnSWYgZW5hYmxlZCwgc2VuZCB0b3VjaCBldmVudHMgdG8gc3RyZWFtZXInLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLlRvdWNoSW5wdXQpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLlRvdWNoSW5wdXRdXG4gICAgICAgICAgICA6IHRydWUsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5HYW1lcGFkSW5wdXQsIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5HYW1lcGFkSW5wdXQsICdHYW1lcGFkIGlucHV0JywgJ0lmIGVuYWJsZWQsIHNlbmQgZ2FtZXBhZCBldmVudHMgdG8gc3RyZWFtZXInLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLkdhbWVwYWRJbnB1dClcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuR2FtZXBhZElucHV0XVxuICAgICAgICAgICAgOiB0cnVlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuWFJDb250cm9sbGVySW5wdXQsIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5YUkNvbnRyb2xsZXJJbnB1dCwgJ1hSIGNvbnRyb2xsZXIgaW5wdXQnLCAnSWYgZW5hYmxlZCwgc2VuZCBYUiBjb250cm9sbGVyIGV2ZW50cyB0byBzdHJlYW1lcicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuWFJDb250cm9sbGVySW5wdXQpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLlhSQ29udHJvbGxlcklucHV0XVxuICAgICAgICAgICAgOiB0cnVlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuV2FpdEZvclN0cmVhbWVyLCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuV2FpdEZvclN0cmVhbWVyLCAnV2FpdCBmb3Igc3RyZWFtZXInLCAnV2lsbCBjb250aW51ZSB0cnlpbmcgdG8gY29ubmVjdCB0byB0aGUgZmlyc3Qgc3RyZWFtZXIgYXZhaWxhYmxlLicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuV2FpdEZvclN0cmVhbWVyKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5XYWl0Rm9yU3RyZWFtZXJdXG4gICAgICAgICAgICA6IHRydWUsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5IaWRlVUksIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5IaWRlVUksICdIaWRlIHRoZSBVSSBvdmVybGF5JywgJ1dpbGwgaGlkZSBhbGwgVUkgb3ZlcmxheSBkZXRhaWxzJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5IaWRlVUkpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLkhpZGVVSV1cbiAgICAgICAgICAgIDogZmFsc2UsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5FbmFibGVDYXB0dXJlVGltZUV4dCwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLkVuYWJsZUNhcHR1cmVUaW1lRXh0LCAnRW5hYmxlIGFicy1jYXB0dXJlLXRpbWUnLCAnRW5hYmxlcyB0aGUgYWJzLWNhcHR1cmUtdGltZSBSVFAgaGVhZGVyIGV4dGVuc2lvbicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuRW5hYmxlQ2FwdHVyZVRpbWVFeHQpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLkVuYWJsZUNhcHR1cmVUaW1lRXh0XVxuICAgICAgICAgICAgOiBmYWxzZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLkJyb3dzZXJTZW5kT2ZmZXIsIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5Ccm93c2VyU2VuZE9mZmVyLCAnQnJvd3NlciBzZW5kIG9mZmVyICg0LjI3IE9OTFkpJywgJ0Jyb3dzZXIgd2lsbCBpbml0aWF0ZSB0aGUgV2ViUlRDIGhhbmRzaGFrZSBieSBzZW5kaW5nIHRoZSBvZmZlciB0byB0aGUgc3RyZWFtZXIgKDQuMjcgT05MWSknLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLkJyb3dzZXJTZW5kT2ZmZXIpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLkJyb3dzZXJTZW5kT2ZmZXJdXG4gICAgICAgICAgICA6IGZhbHNlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuTGF0ZW5jeUNTViwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLkxhdGVuY3lDU1YsICdFeHBvcnQgTGF0ZW5jeSBDU1YnLCAnU2hvd3MgYSBidXR0b24gaW4gdGhlIHN0YXRzIHBhbmVsIHRoYXQgYWxsb3dzIHRvIHJ1biBhIGxhdGVuY3kgdGVzdCBhbmQgZXhwb3J0IHRoZSByZXN1bHRzIHRvIGEgQ1NWIGZpbGUuJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5MYXRlbmN5Q1NWKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5MYXRlbmN5Q1NWXVxuICAgICAgICAgICAgOiBmYWxzZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1lcmljIHBhcmFtZXRlcnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLkFGS1RpbWVvdXRTZWNzLCBuZXcgU2V0dGluZ051bWJlcihOdW1lcmljUGFyYW1ldGVycy5BRktUaW1lb3V0U2VjcywgJ0FGSyB0aW1lb3V0JywgJ1RoZSB0aW1lIChpbiBzZWNvbmRzKSBpdCB0YWtlcyBmb3IgdGhlIGFwcGxpY2F0aW9uIHRvIHRpbWUgb3V0IGlmIEFGSyB0aW1lb3V0IGlzIGVuYWJsZWQuJywgMCAvKm1pbiovLCBudWxsIC8qbWF4Ki8sIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgTnVtZXJpY1BhcmFtZXRlcnMuQUZLVGltZW91dFNlY3MpXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLkFGS1RpbWVvdXRTZWNzXVxuICAgICAgICAgICAgOiAxMjAgLyp2YWx1ZSovLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycy5zZXQoTnVtZXJpY1BhcmFtZXRlcnMuQUZLQ291bnRkb3duU2VjcywgbmV3IFNldHRpbmdOdW1iZXIoTnVtZXJpY1BhcmFtZXRlcnMuQUZLQ291bnRkb3duU2VjcywgJ0FGSyBjb3VudGRvd24nLCAnVGhlIHRpbWUgKGluIHNlY29uZHMpIGZvciBhIHVzZXIgdG8gcmVzcG9uZCBiZWZvcmUgdGhlIHN0cmVhbSBpcyBlbmRlZCBhZnRlciBhbiBBRksgdGltZW91dC4nLCAxMCAvKm1pbiovLCBudWxsIC8qbWF4Ki8sIDEwIC8qdmFsdWUqLywgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLk1heFJlY29ubmVjdEF0dGVtcHRzLCBuZXcgU2V0dGluZ051bWJlcihOdW1lcmljUGFyYW1ldGVycy5NYXhSZWNvbm5lY3RBdHRlbXB0cywgJ01heCBSZWNvbm5lY3RzJywgJ01heGltdW0gbnVtYmVyIG9mIHJlY29ubmVjdHMgdGhlIGFwcGxpY2F0aW9uIHdpbGwgYXR0ZW1wdCB3aGVuIGEgc3RyZWFtZXIgZGlzY29ubmVjdHMuJywgMCAvKm1pbiovLCA5OTkgLyptYXgqLywgc2V0dGluZ3MgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgTnVtZXJpY1BhcmFtZXRlcnMuTWF4UmVjb25uZWN0QXR0ZW1wdHMpXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLk1heFJlY29ubmVjdEF0dGVtcHRzXVxuICAgICAgICAgICAgOiAzIC8qdmFsdWUqLywgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLk1pblFQLCBuZXcgU2V0dGluZ051bWJlcihOdW1lcmljUGFyYW1ldGVycy5NaW5RUCwgJ01pbiBRUCcsICdUaGUgbG93ZXIgYm91bmQgZm9yIHRoZSBxdWFudGl6YXRpb24gcGFyYW1ldGVyIChRUCkgb2YgdGhlIGVuY29kZXIuIDAgPSBCZXN0IHF1YWxpdHksIDUxID0gd29yc3QgcXVhbGl0eS4nLCAwIC8qbWluKi8sIDUxIC8qbWF4Ki8sIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgTnVtZXJpY1BhcmFtZXRlcnMuTWluUVApXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLk1pblFQXVxuICAgICAgICAgICAgOiAwIC8qdmFsdWUqLywgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLk1heFFQLCBuZXcgU2V0dGluZ051bWJlcihOdW1lcmljUGFyYW1ldGVycy5NYXhRUCwgJ01heCBRUCcsICdUaGUgdXBwZXIgYm91bmQgZm9yIHRoZSBxdWFudGl6YXRpb24gcGFyYW1ldGVyIChRUCkgb2YgdGhlIGVuY29kZXIuIDAgPSBCZXN0IHF1YWxpdHksIDUxID0gd29yc3QgcXVhbGl0eS4nLCAwIC8qbWluKi8sIDUxIC8qbWF4Ki8sIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgTnVtZXJpY1BhcmFtZXRlcnMuTWF4UVApXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLk1heFFQXVxuICAgICAgICAgICAgOiA1MSAvKnZhbHVlKi8sIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzLnNldChOdW1lcmljUGFyYW1ldGVycy5NaW5RdWFsaXR5LCBuZXcgU2V0dGluZ051bWJlcihOdW1lcmljUGFyYW1ldGVycy5NaW5RdWFsaXR5LCAnTWluIFF1YWxpdHknLCAnVGhlIGxvd2VyIGJvdW5kIGZvciB0aGUgcXVhbGl0eSBmYWN0b3Igb2YgdGhlIGVuY29kZXIuIDAgPSBXb3JzdCBxdWFsaXR5LCAxMDAgPSBCZXN0IHF1YWxpdHkuJywgMCAvKm1pbiovLCAxMDAgLyptYXgqLywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBOdW1lcmljUGFyYW1ldGVycy5NaW5RdWFsaXR5KVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tOdW1lcmljUGFyYW1ldGVycy5NaW5RdWFsaXR5XVxuICAgICAgICAgICAgOiAwIC8qdmFsdWUqLywgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLk1heFF1YWxpdHksIG5ldyBTZXR0aW5nTnVtYmVyKE51bWVyaWNQYXJhbWV0ZXJzLk1heFF1YWxpdHksICdNYXggUXVhbGl0eScsICdUaGUgdXBwZXIgYm91bmQgZm9yIHRoZSBxdWFsaXR5IGZhY3RvciBvZiB0aGUgZW5jb2Rlci4gMCA9IFdvcnN0IHF1YWxpdHksIDEwMCA9IEJlc3QgcXVhbGl0eS4nLCAwIC8qbWluKi8sIDEwMCAvKm1heCovLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIE51bWVyaWNQYXJhbWV0ZXJzLk1heFF1YWxpdHkpXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLk1heFF1YWxpdHldXG4gICAgICAgICAgICA6IDEwMCAvKnZhbHVlKi8sIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzLnNldChOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWluLCBuZXcgU2V0dGluZ051bWJlcihOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWluLCAnTWluIFF1YWxpdHknLCAnVGhlIGxvd2VyIGJvdW5kIGZvciBlbmNvZGluZyBxdWFsaXR5LiAwID0gV29yc3QsIDEwMCA9IEJlc3QuJywgMCAvKm1pbiovLCAxMDAgLyptYXgqLywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWluKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWluXVxuICAgICAgICAgICAgOiAwIC8qdmFsdWUqLywgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNYXgsIG5ldyBTZXR0aW5nTnVtYmVyKE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNYXgsICdNYXggUXVhbGl0eScsICdUaGUgdXBwZXIgYm91bmQgZm9yIGVuY29kaW5nIHF1YWxpdHkuIDAgPSBXb3JzdCwgMTAwID0gQmVzdC4nLCAwIC8qbWluKi8sIDEwMCAvKm1heCovLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNYXgpXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNYXhdXG4gICAgICAgICAgICA6IDEwMCAvKnZhbHVlKi8sIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzLnNldChOdW1lcmljUGFyYW1ldGVycy5XZWJSVENGUFMsIG5ldyBTZXR0aW5nTnVtYmVyKE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ0ZQUywgJ01heCBGUFMnLCAnVGhlIG1heGltdW0gRlBTIHRoYXQgV2ViUlRDIHdpbGwgdHJ5IHRvIHRyYW5zbWl0IGZyYW1lcyBhdC4nLCAxIC8qbWluKi8sIDk5OSAvKm1heCovLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ0ZQUylcbiAgICAgICAgICAgID8gc2V0dGluZ3NbTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDRlBTXVxuICAgICAgICAgICAgOiA2MCAvKnZhbHVlKi8sIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzLnNldChOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNaW5CaXRyYXRlLCBuZXcgU2V0dGluZ051bWJlcihOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNaW5CaXRyYXRlLCAnTWluIEJpdHJhdGUgKGticHMpJywgJ1RoZSBtaW5pbXVtIGJpdHJhdGUgdGhhdCBXZWJSVEMgc2hvdWxkIHVzZS4nLCAwIC8qbWluKi8sIDUwMDAwMCAvKm1heCovLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01pbkJpdHJhdGUpXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01pbkJpdHJhdGVdXG4gICAgICAgICAgICA6IDAgLyp2YWx1ZSovLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycy5zZXQoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWF4Qml0cmF0ZSwgbmV3IFNldHRpbmdOdW1iZXIoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWF4Qml0cmF0ZSwgJ01heCBCaXRyYXRlIChrYnBzKScsICdUaGUgbWF4aW11bSBiaXRyYXRlIHRoYXQgV2ViUlRDIHNob3VsZCB1c2UuJywgMCAvKm1pbiovLCA1MDAwMDAgLyptYXgqLywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNYXhCaXRyYXRlKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNYXhCaXRyYXRlXVxuICAgICAgICAgICAgOiAwIC8qdmFsdWUqLywgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLlN0cmVhbWVyQXV0b0pvaW5JbnRlcnZhbCwgbmV3IFNldHRpbmdOdW1iZXIoTnVtZXJpY1BhcmFtZXRlcnMuU3RyZWFtZXJBdXRvSm9pbkludGVydmFsLCAnU3RyZWFtZXIgQXV0byBKb2luIEludGVydmFsIChtcyknLCAnRGVsYXkgYmV0d2VlbiByZXRyaWVzIHdoZW4gd2FpdGluZyBmb3IgYW4gYXZhaWxhYmxlIHN0cmVhbWVyLicsIDUwMCAvKm1pbiovLCA5MDAwMDAgLyptYXgqLywgc2V0dGluZ3MgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgTnVtZXJpY1BhcmFtZXRlcnMuU3RyZWFtZXJBdXRvSm9pbkludGVydmFsKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tOdW1lcmljUGFyYW1ldGVycy5TdHJlYW1lckF1dG9Kb2luSW50ZXJ2YWxdXG4gICAgICAgICAgICA6IDMwMDAgLyp2YWx1ZSovLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycy5zZXQoTnVtZXJpY1BhcmFtZXRlcnMuS2VlcGFsaXZlRGVsYXksIG5ldyBTZXR0aW5nTnVtYmVyKE51bWVyaWNQYXJhbWV0ZXJzLktlZXBhbGl2ZURlbGF5LCAnQ29ubmVjdGlvbiBLZWVwYWxpdmUgZGVsYXknLCAnRGVsYXkgYmV0d2VlbiBrZWVwYWxpdmUgcGluZ3MgdG8gdGhlIHNpZ25hbGxpbmcgc2VydmVyLicsIDAgLyptaW4qLywgOTAwMDAwIC8qbWF4Ki8sIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgTnVtZXJpY1BhcmFtZXRlcnMuS2VlcGFsaXZlRGVsYXkpXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLktlZXBhbGl2ZURlbGF5XVxuICAgICAgICAgICAgOiAzMDAwMCAvKnZhbHVlKi8sIHVzZVVybFBhcmFtcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjYWxsYmFjayB0byBmaXJlIHdoZW4gdGhlIG51bWVyaWMgc2V0dGluZyBpcyB0b2dnbGVkLlxuICAgICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIGZsYWcuXG4gICAgICogQHBhcmFtIG9uQ2hhbmdlZExpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBmaXJlIHdoZW4gdGhlIG51bWVyaWMgdmFsdWUgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBfYWRkT25OdW1lcmljU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihpZCwgb25DaGFuZ2VkTGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycy5nZXQoaWQpLmFkZE9uQ2hhbmdlZExpc3RlbmVyKG9uQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYWRkT25PcHRpb25TZXR0aW5nQ2hhbmdlZExpc3RlbmVyKGlkLCBvbkNoYW5nZWRMaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25QYXJhbWV0ZXJzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uUGFyYW1ldGVycy5nZXQoaWQpLmFkZE9uQ2hhbmdlZExpc3RlbmVyKG9uQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBudW1lcmljIHNldHRpbmcgd2UgYXJlIGludGVyZXN0ZWQgaW4gZ2V0dGluZyBhIHZhbHVlIGZvci5cbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtZXJpYyB2YWx1ZSBzdG9yZWQgaW4gdGhlIHBhcmFtZXRlciB3aXRoIHRoZSBwYXNzZWQgaWQuXG4gICAgICovXG4gICAgZ2V0TnVtZXJpY1NldHRpbmdWYWx1ZShpZCkge1xuICAgICAgICBpZiAodGhpcy5udW1lcmljUGFyYW1ldGVycy5oYXMoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW1lcmljUGFyYW1ldGVycy5nZXQoaWQpLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgbm8gbnVtZXJpYyBzZXR0aW5nIHdpdGggdGhlIGlkIG9mICR7aWR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgdGV4dCBzZXR0aW5nIHdlIGFyZSBpbnRlcmVzdGVkIGluIGdldHRpbmcgYSB2YWx1ZSBmb3IuXG4gICAgICogQHJldHVybnMgVGhlIHRleHQgdmFsdWUgc3RvcmVkIGluIHRoZSBwYXJhbWV0ZXIgd2l0aCB0aGUgcGFzc2VkIGlkLlxuICAgICAqL1xuICAgIGdldFRleHRTZXR0aW5nVmFsdWUoaWQpIHtcbiAgICAgICAgaWYgKHRoaXMudGV4dFBhcmFtZXRlcnMuaGFzKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dFBhcmFtZXRlcnMuZ2V0KGlkKS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgbm8gbnVtZXJpYyBzZXR0aW5nIHdpdGggdGhlIGlkIG9mICR7aWR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IG51bWJlciBpbiB0aGUgc2V0dGluZy5cbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBudW1lcmljIHNldHRpbmcgd2UgYXJlIGludGVyZXN0ZWQgaW4uXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBudW1lcmljIHZhbHVlIHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXROdW1lcmljU2V0dGluZyhpZCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycy5nZXQoaWQpLm51bWJlciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBubyBudW1lcmljIHNldHRpbmcgd2l0aCB0aGUgaWQgb2YgJHtpZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjYWxsYmFjayB0byBmaXJlIHdoZW4gdGhlIGZsYWcgaXMgdG9nZ2xlZC5cbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBmbGFnLlxuICAgICAqIEBwYXJhbSBvbkNoYW5nZUxpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBmaXJlIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuXG4gICAgICovXG4gICAgX2FkZE9uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihpZCwgb25DaGFuZ2VMaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLmZsYWdzLmdldChpZCkub25DaGFuZ2UgPSBvbkNoYW5nZUxpc3RlbmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiB0aGUgdGV4dCBpcyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIGZsYWcuXG4gICAgICogQHBhcmFtIG9uQ2hhbmdlTGlzdGVuZXIgVGhlIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBfYWRkT25UZXh0U2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihpZCwgb25DaGFuZ2VMaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy50ZXh0UGFyYW1ldGVycy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLnRleHRQYXJhbWV0ZXJzLmdldChpZCkub25DaGFuZ2UgPSBvbkNoYW5nZUxpc3RlbmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb3B0aW9uIHdoaWNoIGhhcyB0aGUgZ2l2ZW4gaWQuXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgb3B0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSBTZXR0aW5nT3B0aW9uIG9iamVjdCBtYXRjaGluZyBpZFxuICAgICAqL1xuICAgIGdldFNldHRpbmdPcHRpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uUGFyYW1ldGVycy5nZXQoaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBjb25maWd1cmF0aW9uIGZsYWcgd2hpY2ggaGFzIHRoZSBnaXZlbiBpZC5cbiAgICAgKiBAcGFyYW0gaWQgVGhlIHVuaXF1ZSBpZCBmb3IgdGhlIGZsYWcuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZmxhZyBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGlzRmxhZ0VuYWJsZWQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MuZ2V0KGlkKS5mbGFnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgZmxhZyB0byBiZSBlbmFibGVkL2Rpc2FibGVkLlxuICAgICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIGZsYWcgdG8gdG9nZ2xlLlxuICAgICAqIEBwYXJhbSBmbGFnRW5hYmxlZCBUcnVlIGlmIHRoZSBmbGFnIHNob3VsZCBiZSBlbmFibGVkLlxuICAgICAqL1xuICAgIHNldEZsYWdFbmFibGVkKGlkLCBmbGFnRW5hYmxlZCkge1xuICAgICAgICBpZiAoIXRoaXMuZmxhZ3MuaGFzKGlkKSkge1xuICAgICAgICAgICAgTG9nZ2VyLldhcm5pbmcoYENhbm5vdCB0b2dnbGUgZmxhZyBjYWxsZWQgJHtpZH0gLSBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgQ29uZmlnLmZsYWdzIG1hcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MuZ2V0KGlkKS5mbGFnID0gZmxhZ0VuYWJsZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB0ZXh0IHNldHRpbmcuXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgc2V0dGluZ1xuICAgICAqIEBwYXJhbSBzZXR0aW5nVmFsdWUgVGhlIHZhbHVlIHRvIHNldCBpbiB0aGUgc2V0dGluZy5cbiAgICAgKi9cbiAgICBzZXRUZXh0U2V0dGluZyhpZCwgc2V0dGluZ1ZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy50ZXh0UGFyYW1ldGVycy5oYXMoaWQpKSB7XG4gICAgICAgICAgICBMb2dnZXIuV2FybmluZyhgQ2Fubm90IHNldCB0ZXh0IHNldHRpbmcgY2FsbGVkICR7aWR9IC0gaXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIENvbmZpZy50ZXh0UGFyYW1ldGVycyBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRleHRQYXJhbWV0ZXJzLmdldChpZCkudGV4dCA9IHNldHRpbmdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG9wdGlvbiBzZXR0aW5nIGxpc3Qgb2Ygb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBzZXR0aW5nXG4gICAgICogQHBhcmFtIHNldHRpbmdPcHRpb25zIFRoZSB2YWx1ZXMgdGhlIHNldHRpbmcgY291bGQgdGFrZVxuICAgICAqL1xuICAgIHNldE9wdGlvblNldHRpbmdPcHRpb25zKGlkLCBzZXR0aW5nT3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9uUGFyYW1ldGVycy5oYXMoaWQpKSB7XG4gICAgICAgICAgICBMb2dnZXIuV2FybmluZyhgQ2Fubm90IHNldCB0ZXh0IHNldHRpbmcgY2FsbGVkICR7aWR9IC0gaXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIENvbmZpZy5vcHRpb25QYXJhbWV0ZXJzIG1hcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uUGFyYW1ldGVycy5nZXQoaWQpLm9wdGlvbnMgPSBzZXR0aW5nT3B0aW9ucztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgb3B0aW9uIGVudW0gc2V0dGluZ3Mgc2VsZWN0ZWQgb3B0aW9uLlxuICAgICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIHNldHRpbmdcbiAgICAgKiBAcGFyYW0gc2V0dGluZ09wdGlvbnMgVGhlIHZhbHVlIHRvIHNlbGVjdCBvdXQgb2YgYWxsIHRoZSBvcHRpb25zXG4gICAgICovXG4gICAgc2V0T3B0aW9uU2V0dGluZ1ZhbHVlKGlkLCBzZXR0aW5nVmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvblBhcmFtZXRlcnMuaGFzKGlkKSkge1xuICAgICAgICAgICAgTG9nZ2VyLldhcm5pbmcoYENhbm5vdCBzZXQgdGV4dCBzZXR0aW5nIGNhbGxlZCAke2lkfSAtIGl0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBDb25maWcuZW51bVBhcmFtZXRlcnMgbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uU2V0dGluZyA9IHRoaXMub3B0aW9uUGFyYW1ldGVycy5nZXQoaWQpO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdPcHRpb25zID0gb3B0aW9uU2V0dGluZy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKCFleGlzdGluZ09wdGlvbnMuaW5jbHVkZXMoc2V0dGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nT3B0aW9ucy5wdXNoKHNldHRpbmdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgb3B0aW9uU2V0dGluZy5vcHRpb25zID0gZXhpc3RpbmdPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9uU2V0dGluZy5zZWxlY3RlZCA9IHNldHRpbmdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxhYmVsIGZvciB0aGUgZmxhZy5cbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBmbGFnLlxuICAgICAqIEBwYXJhbSBsYWJlbCBUaGUgbmV3IGxhYmVsIHRvIHVzZSBmb3IgdGhlIGZsYWcuXG4gICAgICovXG4gICAgc2V0RmxhZ0xhYmVsKGlkLCBsYWJlbCkge1xuICAgICAgICBpZiAoIXRoaXMuZmxhZ3MuaGFzKGlkKSkge1xuICAgICAgICAgICAgTG9nZ2VyLldhcm5pbmcoYENhbm5vdCBzZXQgbGFiZWwgZm9yIGZsYWcgY2FsbGVkICR7aWR9IC0gaXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIENvbmZpZy5mbGFncyBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZsYWdzLmdldChpZCkubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBzdWJzZXQgb2YgYWxsIHNldHRpbmdzIGluIG9uZSBmdW5jdGlvbiBjYWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNldHRpbmdzIEEgKHBhcnRpYWwpIGxpc3Qgb2Ygc2V0dGluZ3MgdG8gc2V0XG4gICAgICovXG4gICAgc2V0U2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2V0dGluZ3MpKSB7XG4gICAgICAgICAgICBpZiAoaXNGbGFnSWQoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmxhZ0VuYWJsZWQoa2V5LCBzZXR0aW5nc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTnVtZXJpY0lkKGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE51bWVyaWNTZXR0aW5nKGtleSwgc2V0dGluZ3Nba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1RleHRJZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUZXh0U2V0dGluZyhrZXksIHNldHRpbmdzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPcHRpb25JZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25TZXR0aW5nVmFsdWUoa2V5LCBzZXR0aW5nc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHNldHRpbmdzXG4gICAgICogQHJldHVybnMgQWxsIHNldHRpbmcgdmFsdWVzIGFzIGFuIG9iamVjdCB3aXRoIHNldHRpbmcgaWRzIGFzIGtleXNcbiAgICAgKi9cbiAgICBnZXRTZXR0aW5ncygpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5mbGFncy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzW2tleV0gPSB2YWx1ZS5mbGFnO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWUubnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMudGV4dFBhcmFtZXRlcnMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWUudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLm9wdGlvblBhcmFtZXRlcnMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWUuc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIEZsYWcgc2V0dGluZ3MgYXMgYW4gYXJyYXkuXG4gICAgICogQHJldHVybnMgQWxsIFNldHRpbmdGbGFnIG9iamVjdHNcbiAgICAgKi9cbiAgICBnZXRGbGFncygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5mbGFncy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgVGV4dCBzZXR0aW5ncyBhcyBhbiBhcnJheS5cbiAgICAgKiBAcmV0dXJucyBBbGwgU2V0dGluZ1RleHQgb2JqZWN0c1xuICAgICAqL1xuICAgIGdldFRleHRTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy50ZXh0UGFyYW1ldGVycy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgTnVtYmVyIHNldHRpbmdzIGFzIGFuIGFycmF5LlxuICAgICAqIEByZXR1cm5zIEFsbCBTZXR0aW5nTnVtYmVyIG9iamVjdHNcbiAgICAgKi9cbiAgICBnZXROdW1lcmljU2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubnVtZXJpY1BhcmFtZXRlcnMudmFsdWVzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIE9wdGlvbiBzZXR0aW5ncyBhcyBhbiBhcnJheS5cbiAgICAgKiBAcmV0dXJucyBBbGwgU2V0dGluZ09wdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgZ2V0T3B0aW9uU2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMub3B0aW9uUGFyYW1ldGVycy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXQgZXZlbnRzIHdoZW4gc2V0dGluZ3MgY2hhbmdlLlxuICAgICAqIEBwYXJhbSBldmVudEVtaXR0ZXJcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJPbkNoYW5nZUV2ZW50cyhldmVudEVtaXR0ZXIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5mbGFncy5rZXlzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZsYWcgPSB0aGlzLmZsYWdzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgICAgICBmbGFnLm9uQ2hhbmdlRW1pdCA9IChuZXdWYWx1ZSkgPT4gZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFNldHRpbmdzQ2hhbmdlZEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGZsYWcuaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmbGFnJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGZsYWdcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5udW1lcmljUGFyYW1ldGVycy5rZXlzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bWJlciA9IHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAobnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyLm9uQ2hhbmdlRW1pdCA9IChuZXdWYWx1ZSkgPT4gZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFNldHRpbmdzQ2hhbmdlZEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG51bWJlci5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBudW1iZXJcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy50ZXh0UGFyYW1ldGVycy5rZXlzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLnRleHRQYXJhbWV0ZXJzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0Lm9uQ2hhbmdlRW1pdCA9IChuZXdWYWx1ZSkgPT4gZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFNldHRpbmdzQ2hhbmdlZEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRleHQuaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRleHRcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5vcHRpb25QYXJhbWV0ZXJzLmtleXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gdGhpcy5vcHRpb25QYXJhbWV0ZXJzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5vbkNoYW5nZUVtaXQgPSAobmV3VmFsdWUpID0+IGV2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBTZXR0aW5nc0NoYW5nZWRFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBvcHRpb24uaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdvcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogb3B0aW9uXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgZW51bSBhc3NvY2lhdGVkIHdpdGggdGhlIG1vdXNlIGJlaW5nIGxvY2tlZCBvciBob3ZlcmluZ1xuICovXG5leHBvcnQgdmFyIENvbnRyb2xTY2hlbWVUeXBlO1xuKGZ1bmN0aW9uIChDb250cm9sU2NoZW1lVHlwZSkge1xuICAgIENvbnRyb2xTY2hlbWVUeXBlW0NvbnRyb2xTY2hlbWVUeXBlW1wiTG9ja2VkTW91c2VcIl0gPSAwXSA9IFwiTG9ja2VkTW91c2VcIjtcbiAgICBDb250cm9sU2NoZW1lVHlwZVtDb250cm9sU2NoZW1lVHlwZVtcIkhvdmVyaW5nTW91c2VcIl0gPSAxXSA9IFwiSG92ZXJpbmdNb3VzZVwiO1xufSkoQ29udHJvbFNjaGVtZVR5cGUgfHwgKENvbnRyb2xTY2hlbWVUeXBlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbmZpZy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhIHNldHRpbmcgdGhhdCBoYXMgYSB0ZXh0IGxhYmVsIGFuZCBhbiBhcmJpdHJhcnkgc2V0dGluZyB2YWx1ZSBpdCBzdG9yZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXR0aW5nQmFzZSB7XG4gICAgY29uc3RydWN0b3IoaWQsIGxhYmVsLCBkZXNjcmlwdGlvbiwgZGVmYXVsdFNldHRpbmdWYWx1ZSwgZGVmYXVsdE9uQ2hhbmdlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIC8qIERvIG5vdGhpbmcsIHRvIGJlIG92ZXJyaWRkZW4uICovXG4gICAgfSkge1xuICAgICAgICB0aGlzLnBhcnNlVVJMUGFyYW1zKCk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBkZWZhdWx0T25DaGFuZ2VMaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUVtaXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAvKiBEbyBub3RoaW5nLCB0byBiZSBvdmVycmlkZGVuLiAqL1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB0aGlzLnZhbHVlID0gZGVmYXVsdFNldHRpbmdWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsYWJlbCB0ZXh0IGZvciB0aGUgc2V0dGluZy5cbiAgICAgKiBAcGFyYW0gbGFiZWwgc2V0dGluZyBsYWJlbC5cbiAgICAgKi9cbiAgICBzZXQgbGFiZWwoaW5MYWJlbCkge1xuICAgICAgICB0aGlzLl9sYWJlbCA9IGluTGFiZWw7XG4gICAgICAgIHRoaXMub25DaGFuZ2VFbWl0KHRoaXMuX3ZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIGxhYmVsIHRleHQgZm9yIHRoZSBzZXR0aW5nLlxuICAgICAqL1xuICAgIGdldCBsYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhYmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFRoZSBzZXR0aW5nJ3MgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc2V0dGluZydzIHN0b3JlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gaW5WYWx1ZSBUaGUgbmV3IHZhbHVlIGZvciB0aGUgc2V0dGluZy5cbiAgICAgKi9cbiAgICBzZXQgdmFsdWUoaW5WYWx1ZSkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IGluVmFsdWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2UodGhpcy5fdmFsdWUsIHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlRW1pdCh0aGlzLl92YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcnNpc3QgdGhlIHNldHRpbmcgdmFsdWUgaW4gVVJMLlxuICAgICAqL1xuICAgIHVwZGF0ZVVSTFBhcmFtcygpIHtcbiAgICAgICAgaWYgKHRoaXMudXNlVXJsUGFyYW1zKSB7XG4gICAgICAgICAgICAvLyBzZXQgdXJsIHBhcmFtc1xuICAgICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlU3RyaW5nID0gdGhpcy5nZXRWYWx1ZUFzU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBfdmFsdWVdIG9mIHVybFBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgPT0gdGhpcy5pZC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybFBhcmFtcy5zZXQobmFtZSwgdmFsdWVTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBzZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNldCkge1xuICAgICAgICAgICAgICAgIHVybFBhcmFtcy5zZXQodGhpcy5pZCwgdmFsdWVTdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCAnJywgdXJsUGFyYW1zLnRvU3RyaW5nKCkgIT09ICcnID8gYCR7bG9jYXRpb24ucGF0aG5hbWV9PyR7dXJsUGFyYW1zfWAgOiBgJHtsb2NhdGlvbi5wYXRobmFtZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3Mgc3ViIHR5cGVzIHRvIHByb3ZpZGUgdGhlaXIgdmFsdWUgZm9yIHRoZSB1cmwgc2VhcmNoIHBhcmFtcy5cbiAgICAgKi9cbiAgICBnZXRWYWx1ZUFzU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHBhcnNlVVJMUGFyYW1zKCkge1xuICAgICAgICB0aGlzLl91cmxQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIHBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5fdXJsUGFyYW1zW25hbWUudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNVUkxQYXJhbShuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCkgaW4gdGhpcy5fdXJsUGFyYW1zO1xuICAgIH1cbiAgICBnZXRVUkxQYXJhbShuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1VSTFBhcmFtKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXJsUGFyYW1zW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNldHRpbmdCYXNlLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBTZXR0aW5nQmFzZSB9IGZyb20gJy4vU2V0dGluZ0Jhc2UnO1xuLyoqXG4gKiBBIGJvb2xlYW4gZmxhZyBzZXR0aW5nIG9iamVjdCB3aXRoIGEgdGV4dCBsYWJlbC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNldHRpbmdGbGFnIGV4dGVuZHMgU2V0dGluZ0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBsYWJlbCwgZGVzY3JpcHRpb24sIGRlZmF1bHRGbGFnVmFsdWUsIHVzZVVybFBhcmFtcywgZGVmYXVsdE9uQ2hhbmdlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIC8qIERvIG5vdGhpbmcsIHRvIGJlIG92ZXJyaWRkZW4uICovXG4gICAgfSkge1xuICAgICAgICBzdXBlcihpZCwgbGFiZWwsIGRlc2NyaXB0aW9uLCBkZWZhdWx0RmxhZ1ZhbHVlLCBkZWZhdWx0T25DaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgIGlmICghdXNlVXJsUGFyYW1zIHx8ICF0aGlzLmhhc1VSTFBhcmFtKHRoaXMuaWQpKSB7XG4gICAgICAgICAgICB0aGlzLmZsYWcgPSBkZWZhdWx0RmxhZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFyc2UgZmxhZyBmcm9tIHVybCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICBjb25zdCB1cmxQYXJhbUZsYWcgPSB0aGlzLmdldFVSTFBhcmFtKHRoaXMuaWQpO1xuICAgICAgICAgICAgdGhpcy5mbGFnID0gdXJsUGFyYW1GbGFnLnRvTG93ZXJDYXNlKCkgIT0gJ2ZhbHNlJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZVVybFBhcmFtcyA9IHVzZVVybFBhcmFtcztcbiAgICB9XG4gICAgZ2V0VmFsdWVBc1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZyA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhpcyBmbGFnLlxuICAgICAqL1xuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgdGhpcy5mbGFnID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiBUaGUgc2V0dGluZydzIHZhbHVlLlxuICAgICAqL1xuICAgIGdldCBmbGFnKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHNldHRpbmcncyBzdG9yZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIGluVmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHNldHRpbmcuXG4gICAgICovXG4gICAgc2V0IGZsYWcoaW5WYWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gaW5WYWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXR0aW5nRmxhZy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgU2V0dGluZ0Jhc2UgfSBmcm9tICcuL1NldHRpbmdCYXNlJztcbi8qKlxuICogQSBudW1iZXIgc2V0dGluZyBvYmplY3Qgd2l0aCBhIHRleHQgbGFiZWwuIE1pbiBhbmQgbWF4IGxpbWl0IHRoZSByYW5nZSBvZiBhbGxvd2VkIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNldHRpbmdOdW1iZXIgZXh0ZW5kcyBTZXR0aW5nQmFzZSB7XG4gICAgY29uc3RydWN0b3IoaWQsIGxhYmVsLCBkZXNjcmlwdGlvbiwgbWluLCBtYXgsIGRlZmF1bHROdW1iZXIsIHVzZVVybFBhcmFtcywgZGVmYXVsdE9uQ2hhbmdlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIC8qIERvIG5vdGhpbmcsIHRvIGJlIG92ZXJyaWRkZW4uICovXG4gICAgfSkge1xuICAgICAgICBzdXBlcihpZCwgbGFiZWwsIGRlc2NyaXB0aW9uLCBkZWZhdWx0TnVtYmVyLCBkZWZhdWx0T25DaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX21pbiA9IG1pbjtcbiAgICAgICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgICAgICAvLyBhdHRlbXB0IHRvIHJlYWQgdGhlIG51bWJlciBmcm9tIHRoZSB1cmwgcGFyYW1zXG4gICAgICAgIGlmICghdXNlVXJsUGFyYW1zIHx8ICF0aGlzLmhhc1VSTFBhcmFtKHRoaXMuaWQpKSB7XG4gICAgICAgICAgICB0aGlzLm51bWJlciA9IGRlZmF1bHROdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IE51bWJlci5wYXJzZUZsb2F0KHRoaXMuZ2V0VVJMUGFyYW0odGhpcy5pZCkpO1xuICAgICAgICAgICAgdGhpcy5udW1iZXIgPSBOdW1iZXIuaXNOYU4ocGFyc2VkVmFsdWUpID8gZGVmYXVsdE51bWJlciA6IHBhcnNlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNlVXJsUGFyYW1zID0gdXNlVXJsUGFyYW1zO1xuICAgIH1cbiAgICBnZXRWYWx1ZUFzU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1iZXIudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBudW1iZXIgdmFsdWUgKHdpbGwgYmUgY2xhbXBlZCB3aXRoaW4gcmFuZ2UpLlxuICAgICAqL1xuICAgIHNldCBudW1iZXIobmV3TnVtYmVyKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmNsYW1wKG5ld051bWJlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgc3RvcmVkLlxuICAgICAqL1xuICAgIGdldCBudW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgYSBudW1iZXIgYmV0d2VlbiB0aGUgbWluIGFuZCBtYXggdmFsdWVzIChpbmNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSBpbk51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEByZXR1cm5zIFRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKi9cbiAgICBjbGFtcChpbk51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5fbWluID09IG51bGwgJiYgdGhpcy5fbWF4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpbk51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9taW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuX21heCwgaW5OdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX21heCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5fbWluLCBpbk51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4odGhpcy5fbWF4LCBpbk51bWJlciksIHRoaXMuX21pbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBtaW5pbXVtIHZhbHVlXG4gICAgICovXG4gICAgZ2V0IG1pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBtYXhpbXVtIHZhbHVlXG4gICAgICovXG4gICAgZ2V0IG1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgY2hhbmdlIGxpc3RlbmVyIHRvIHRoZSBudW1iZXIgb2JqZWN0LlxuICAgICAqL1xuICAgIGFkZE9uQ2hhbmdlZExpc3RlbmVyKG9uQ2hhbmdlZEZ1bmMpIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlZEZ1bmM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2V0dGluZ051bWJlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuaW1wb3J0IHsgU2V0dGluZ0Jhc2UgfSBmcm9tICcuL1NldHRpbmdCYXNlJztcbi8qKlxuICogQW4gT3B0aW9uIHNldHRpbmcgb2JqZWN0IHdpdGggYSB0ZXh0IGxhYmVsLiBBbGxvd3MgeW91IHRvIHNwZWNpZnkgYW4gYXJyYXkgb2Ygb3B0aW9ucyBhbmQgc2VsZWN0IG9uZSBvZiB0aGVtLlxuICovXG5leHBvcnQgY2xhc3MgU2V0dGluZ09wdGlvbiBleHRlbmRzIFNldHRpbmdCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgbGFiZWwsIGRlc2NyaXB0aW9uLCBkZWZhdWx0VGV4dFZhbHVlLCBvcHRpb25zLCB1c2VVcmxQYXJhbXMsIGRlZmF1bHRVcmxQYXJhbVJlc29sdmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8qIFJldHVybiB0aGUgc3RyaW5nIGFzLWlzIGJ5IGRlZmF1bHQgKi9cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIGRlZmF1bHRPbkNoYW5nZUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAvKiBEbyBub3RoaW5nLCB0byBiZSBvdmVycmlkZGVuLiAqL1xuICAgIH0pIHtcbiAgICAgICAgc3VwZXIoaWQsIGxhYmVsLCBkZXNjcmlwdGlvbiwgZGVmYXVsdFRleHRWYWx1ZSwgZGVmYXVsdE9uQ2hhbmdlTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLl91cmxQYXJhbVJlc29sdmVyID0gZGVmYXVsdFVybFBhcmFtUmVzb2x2ZXI7XG4gICAgICAgIGNvbnN0IHN0cmluZ1RvTWF0Y2ggPSB0aGlzLmhhc1VSTFBhcmFtKHRoaXMuaWQpXG4gICAgICAgICAgICA/IHRoaXMuX3VybFBhcmFtUmVzb2x2ZXIodGhpcy5nZXRVUkxQYXJhbSh0aGlzLmlkKSlcbiAgICAgICAgICAgIDogZGVmYXVsdFRleHRWYWx1ZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDogW3N0cmluZ1RvTWF0Y2hdO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gc3RyaW5nVG9NYXRjaDtcbiAgICAgICAgdGhpcy51c2VVcmxQYXJhbXMgPSB1c2VVcmxQYXJhbXM7XG4gICAgfVxuICAgIGdldFZhbHVlQXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjaGFuZ2UgbGlzdGVuZXIgdG8gdGhlIHNlbGVjdCBlbGVtZW50LlxuICAgICAqL1xuICAgIGFkZE9uQ2hhbmdlZExpc3RlbmVyKG9uQ2hhbmdlZEZ1bmMpIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlZEZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEFsbCBhdmFpbGFibGUgb3B0aW9ucyBhcyBhbiBhcnJheVxuICAgICAqL1xuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gdmFsdWVzIEFycmF5IG9mIG9wdGlvbnNcbiAgICAgKi9cbiAgICBzZXQgb3B0aW9ucyh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHZhbHVlcztcbiAgICAgICAgdGhpcy5vbkNoYW5nZUVtaXQodGhpcy5zZWxlY3RlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFNlbGVjdGVkIG9wdGlvbiBhcyBhIHN0cmluZ1xuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBzZWxlY3RlZCBvcHRpb24gaWYgaXQgbWF0Y2hlcyBvbmUgb2YgdGhlIGF2YWlsYWJsZSBvcHRpb25zXG4gICAgICogQHBhcmFtIHZhbHVlIFNlbGVjdGVkIG9wdGlvblxuICAgICAqL1xuICAgIHNldCBzZWxlY3RlZCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG9wdGlvbnMgY29udGFpbnMgdGhlIHZhbHVlLCB0aGVuIHNldCB0aGF0IGFzIHNlbGVjdGVkXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoYENvdWxkIG5vdCBzZXQgXCIke3ZhbHVlfVwiIGFzIHRoZSBzZWxlY3RlZCBvcHRpb24gZm9yICR7dGhpcy5pZH0gYmVjYXVzZSBpdCB3YXNuJ3Qgb25lIG9mIHRoZSBvcHRpb25zLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdXJsIHBhcmFtZXRlciByZXNvbHZlciB0byBkbyBzb21lIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBzdHJpbmcgdmFsdWVcbiAgICAgKiB0aGF0IGlzIGV4dHJhY3RlZCBmcm9tIHRoZSB1cmwgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0gdXJsUGFyYW0gQSBmdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIGV4dHJhY3RlZCB1cmwgcGFyYW1ldGVyIHN0cmluZyBmb3IgdGhpcyBzZXR0aW5nIHRvIHNvbWV0aGluZyBlbHNlLlxuICAgICAqL1xuICAgIHNldCB1cmxQYXJhbVJlc29sdmVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3VybFBhcmFtUmVzb2x2ZXIgPSB2YWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXR0aW5nT3B0aW9uLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBTZXR0aW5nQmFzZSB9IGZyb20gJy4vU2V0dGluZ0Jhc2UnO1xuLyoqXG4gKiBBIHRleHQgc2V0dGluZyBvYmplY3Qgd2l0aCBhIHRleHQgbGFiZWwuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXR0aW5nVGV4dCBleHRlbmRzIFNldHRpbmdCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgbGFiZWwsIGRlc2NyaXB0aW9uLCBkZWZhdWx0VGV4dFZhbHVlLCB1c2VVcmxQYXJhbXMsIGRlZmF1bHRPbkNoYW5nZUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAvKiBEbyBub3RoaW5nLCB0byBiZSBvdmVycmlkZGVuLiAqL1xuICAgIH0pIHtcbiAgICAgICAgc3VwZXIoaWQsIGxhYmVsLCBkZXNjcmlwdGlvbiwgZGVmYXVsdFRleHRWYWx1ZSwgZGVmYXVsdE9uQ2hhbmdlTGlzdGVuZXIpO1xuICAgICAgICBpZiAoIXVzZVVybFBhcmFtcyB8fCAhdGhpcy5oYXNVUkxQYXJhbSh0aGlzLmlkKSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gZGVmYXVsdFRleHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhcnNlIGZsYWcgZnJvbSB1cmwgcGFyYW1ldGVyc1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy5nZXRVUkxQYXJhbSh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZVVybFBhcmFtcyA9IHVzZVVybFBhcmFtcztcbiAgICB9XG4gICAgZ2V0VmFsdWVBc1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiBUaGUgc2V0dGluZydzIHZhbHVlLlxuICAgICAqL1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzZXR0aW5nJ3Mgc3RvcmVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSBpblZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBzZXR0aW5nLlxuICAgICAqL1xuICAgIHNldCB0ZXh0KGluVmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGluVmFsdWU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2V0dGluZ1RleHQuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42Jztcbi8qKlxuICogSGFuZGxlcyB0aGUgU2VuZGluZyBhbmQgUmVjZWl2aW5nIG9mIG1lc3NhZ2VzIHRvIHRoZSBVRSBJbnN0YW5jZSB2aWEgdGhlIERhdGEgQ2hhbm5lbFxuICovXG5leHBvcnQgY2xhc3MgRGF0YUNoYW5uZWxDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pc1JlY2VpdmluZ0ZyZWV6ZUZyYW1lID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgY3VycmVudCBzdGF0ZSBvZiBhIGRhdGFjaGFubmVsIGNvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBEYXRhQ2hhbm5lbENvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXREYXRhQ2hhbm5lbEluc3RhbmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gQ3JlYXRlIGFuZCBTZXQgdXAgYSBEYXRhIENoYW5uZWxcbiAgICAgKiBAcGFyYW0gcGVlckNvbm5lY3Rpb24gLSBUaGUgUlRDIFBlZXIgQ29ubmVjdGlvblxuICAgICAqIEBwYXJhbSBsYWJlbCAtIExhYmVsIG9mIHRoZSBEYXRhIENoYW5uZWxcbiAgICAgKiBAcGFyYW0gZGF0YWNoYW5uZWxPcHRpb25zIC0gT3B0aW9uYWwgUlRDIERhdGFDaGFubmVsIG9wdGlvbnNcbiAgICAgKi9cbiAgICBjcmVhdGVEYXRhQ2hhbm5lbChwZWVyQ29ubmVjdGlvbiwgbGFiZWwsIGRhdGFjaGFubmVsT3B0aW9ucykge1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uID0gcGVlckNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbE9wdGlvbnMgPSBkYXRhY2hhbm5lbE9wdGlvbnM7XG4gICAgICAgIGlmIChkYXRhY2hhbm5lbE9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhY2hhbm5lbE9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuZGF0YWNoYW5uZWxPcHRpb25zLm9yZGVyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwgPSB0aGlzLnBlZXJDb25uZWN0aW9uLmNyZWF0ZURhdGFDaGFubmVsKHRoaXMubGFiZWwsIHRoaXMuZGF0YWNoYW5uZWxPcHRpb25zKTtcbiAgICAgICAgdGhpcy5zZXR1cERhdGFDaGFubmVsKCk7XG4gICAgfVxuICAgIHNldHVwRGF0YUNoYW5uZWwoKSB7XG4gICAgICAgIC8vV2UgV2FudCBhbiBBcnJheSBCdWZmZXIgbm90IGEgYmxvYlxuICAgICAgICB0aGlzLmRhdGFDaGFubmVsLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsLm9ub3BlbiA9IChldikgPT4gdGhpcy5oYW5kbGVPbk9wZW4oZXYpO1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsLm9uY2xvc2UgPSAoZXYpID0+IHRoaXMuaGFuZGxlT25DbG9zZShldik7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwub25tZXNzYWdlID0gKGV2KSA9PiB0aGlzLmhhbmRsZU9uTWVzc2FnZShldik7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwub25lcnJvciA9IChldikgPT4gdGhpcy5oYW5kbGVPbkVycm9yKGV2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIHRoZSBEYXRhIENoYW5uZWwgaXMgb3BlbmVkXG4gICAgICovXG4gICAgaGFuZGxlT25PcGVuKGV2KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgTG9nZ2VyLkluZm8oYERhdGEgQ2hhbm5lbCAoJHt0aGlzLmxhYmVsfSkgb3BlbmVkLmApO1xuICAgICAgICB0aGlzLm9uT3BlbigoX2EgPSB0aGlzLmRhdGFDaGFubmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFiZWwsIGV2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIHRoZSBEYXRhIENoYW5uZWwgaXMgY2xvc2VkXG4gICAgICovXG4gICAgaGFuZGxlT25DbG9zZShldikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIExvZ2dlci5JbmZvKGBEYXRhIENoYW5uZWwgKCR7dGhpcy5sYWJlbH0pIGNsb3NlZC5gKTtcbiAgICAgICAgdGhpcy5vbkNsb3NlKChfYSA9IHRoaXMuZGF0YUNoYW5uZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYWJlbCwgZXYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkXG4gICAgICogQHBhcmFtIGV2ZW50IC0gTWVzc2FnZSBFdmVudFxuICAgICAqL1xuICAgIGhhbmRsZU9uTWVzc2FnZShldmVudCkge1xuICAgICAgICAvLyBIaWdoZXIgbG9nIGxldmVsIHRvIHByZXZlbnQgbG9nIHNwYW0gd2l0aCBtZXNzYWdlcyByZWNlaXZlZFxuICAgICAgICBMb2dnZXIuSW5mbyhgRGF0YSBDaGFubmVsICgke3RoaXMubGFiZWx9KSBtZXNzYWdlOiAke2V2ZW50fWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gYW4gZXJyb3IgaXMgdGhyb3duXG4gICAgICogQHBhcmFtIGV2ZW50IC0gRXJyb3IgRXZlbnRcbiAgICAgKi9cbiAgICBoYW5kbGVPbkVycm9yKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgTG9nZ2VyLkluZm8oYERhdGEgQ2hhbm5lbCAoJHt0aGlzLmxhYmVsfSkgZXJyb3I6ICR7ZXZlbnR9YCk7XG4gICAgICAgIHRoaXMub25FcnJvcigoX2EgPSB0aGlzLmRhdGFDaGFubmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFiZWwsIGV2ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdG8gcmVnaXN0ZXIgb25PcGVuIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gbGFiZWwgRGF0YSBjaGFubmVsIGxhYmVsIChcImRhdGFjaGFubmVsXCIsIFwic2VuZC1kYXRhY2hhbm5lbFwiLCBcInJlY3YtZGF0YWNoYW5uZWxcIilcbiAgICAgKiBAcGFyYW0gZXYgZXZlbnRcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb25PcGVuKGxhYmVsLCBldikge1xuICAgICAgICAvLyBlbXB0eSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRvIHJlZ2lzdGVyIG9uQ2xvc2UgaGFuZGxlclxuICAgICAqIEBwYXJhbSBsYWJlbCBEYXRhIGNoYW5uZWwgbGFiZWwgKFwiZGF0YWNoYW5uZWxcIiwgXCJzZW5kLWRhdGFjaGFubmVsXCIsIFwicmVjdi1kYXRhY2hhbm5lbFwiKVxuICAgICAqIEBwYXJhbSBldiBldmVudFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBvbkNsb3NlKGxhYmVsLCBldikge1xuICAgICAgICAvLyBlbXB0eSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRvIHJlZ2lzdGVyIG9uRXJyb3IgaGFuZGxlclxuICAgICAqIEBwYXJhbSBsYWJlbCBEYXRhIGNoYW5uZWwgbGFiZWwgKFwiZGF0YWNoYW5uZWxcIiwgXCJzZW5kLWRhdGFjaGFubmVsXCIsIFwicmVjdi1kYXRhY2hhbm5lbFwiKVxuICAgICAqIEBwYXJhbSBldiBldmVudFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBvbkVycm9yKGxhYmVsLCBldikge1xuICAgICAgICAvLyBlbXB0eSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0YUNoYW5uZWxDb250cm9sbGVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG5pbXBvcnQgeyBEYXRhQ2hhbm5lbExhdGVuY3lUZXN0UmVjb3JkIH0gZnJvbSAnLi9EYXRhQ2hhbm5lbExhdGVuY3lUZXN0UmVzdWx0cyc7XG5leHBvcnQgY2xhc3MgRGF0YUNoYW5uZWxMYXRlbmN5VGVzdENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKHNpbmssIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxIYW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2luayA9IHNpbms7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5yZWNvcmRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNlcSA9IDA7XG4gICAgfVxuICAgIHN0YXJ0KGNvbmZpZykge1xuICAgICAgICBpZiAodGhpcy5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5yZWNvcmRzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxIYW5kbGUgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5zdGFydFRpbWUgPj0gY29uZmlnLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGNvbmZpZy5yZXF1ZXN0U2l6ZSwgY29uZmlnLnJlc3BvbnNlU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmJpbmQodGhpcyksIE1hdGguZmxvb3IoMTAwMCAvIGNvbmZpZy5ycHMpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFsSGFuZGxlKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSGFuZGxlKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxIYW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMucHJvZHVjZVJlc3VsdCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9kdWNlUmVzdWx0KCkge1xuICAgICAgICBjb25zdCByZXN1bHRSZWNvcmRzID0gbmV3IE1hcCh0aGlzLnJlY29yZHMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVjb3JkczogcmVzdWx0UmVjb3JkcyxcbiAgICAgICAgICAgIGRhdGFDaGFubmVsUnR0OiBNYXRoLmNlaWwoQXJyYXkuZnJvbSh0aGlzLnJlY29yZHMudmFsdWVzKCkpLnJlZHVjZSgoYWNjLCBuZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIChuZXh0LnBsYXllclJlY2VpdmVkVGltZXN0YW1wIC0gbmV4dC5wbGF5ZXJTZW50VGltZXN0YW1wKTtcbiAgICAgICAgICAgIH0sIDApIC8gdGhpcy5yZWNvcmRzLnNpemUpLFxuICAgICAgICAgICAgcGxheWVyVG9TdHJlYW1lclRpbWU6IE1hdGguY2VpbChBcnJheS5mcm9tKHRoaXMucmVjb3Jkcy52YWx1ZXMoKSkucmVkdWNlKChhY2MsIG5leHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjICsgKG5leHQuc3RyZWFtZXJSZWNlaXZlZFRpbWVzdGFtcCAtIG5leHQucGxheWVyU2VudFRpbWVzdGFtcCk7XG4gICAgICAgICAgICB9LCAwKSAvIHRoaXMucmVjb3Jkcy5zaXplKSxcbiAgICAgICAgICAgIHN0cmVhbWVyVG9QbGF5ZXJUaW1lOiBNYXRoLmNlaWwoQXJyYXkuZnJvbSh0aGlzLnJlY29yZHMudmFsdWVzKCkpLnJlZHVjZSgoYWNjLCBuZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIChuZXh0LnBsYXllclJlY2VpdmVkVGltZXN0YW1wIC0gbmV4dC5zdHJlYW1lclNlbnRUaW1lc3RhbXApO1xuICAgICAgICAgICAgfSwgMCkgLyB0aGlzLnJlY29yZHMuc2l6ZSksXG4gICAgICAgICAgICBleHBvcnRMYXRlbmN5QXNDU1Y6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY3N2ID0gJ1RpbWVzdGFtcDtSVFQ7UGxheWVyVG9TdHJlYW1lcjtTdHJlYW1lclRvUGxheWVyO1xcbic7XG4gICAgICAgICAgICAgICAgcmVzdWx0UmVjb3Jkcy5mb3JFYWNoKChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY3N2ICs9IHJlY29yZC5wbGF5ZXJTZW50VGltZXN0YW1wICsgJzsnO1xuICAgICAgICAgICAgICAgICAgICBjc3YgKz0gcmVjb3JkLnBsYXllclJlY2VpdmVkVGltZXN0YW1wIC0gcmVjb3JkLnBsYXllclNlbnRUaW1lc3RhbXAgKyAnOyc7XG4gICAgICAgICAgICAgICAgICAgIGNzdiArPSByZWNvcmQuc3RyZWFtZXJSZWNlaXZlZFRpbWVzdGFtcCAtIHJlY29yZC5wbGF5ZXJTZW50VGltZXN0YW1wICsgJzsnO1xuICAgICAgICAgICAgICAgICAgICBjc3YgKz0gcmVjb3JkLnBsYXllclJlY2VpdmVkVGltZXN0YW1wIC0gcmVjb3JkLnN0cmVhbWVyU2VudFRpbWVzdGFtcCArICc7JztcbiAgICAgICAgICAgICAgICAgICAgY3N2ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjc3Y7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlzUnVubmluZygpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5pbnRlcnZhbEhhbmRsZTtcbiAgICB9XG4gICAgcmVjZWl2ZShyZXNwb25zZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoJ1VuZGVmaW5lZCByZXNwb25zZSBmcm9tIHNlcnZlcicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlY29yZCA9IHRoaXMucmVjb3Jkcy5nZXQocmVzcG9uc2UuU2VxKTtcbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgcmVjb3JkLnVwZGF0ZShyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZFJlcXVlc3QocmVxdWVzdFNpemUsIHJlc3BvbnNlU2l6ZSkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KHJlcXVlc3RTaXplLCByZXNwb25zZVNpemUpO1xuICAgICAgICBjb25zdCByZWNvcmQgPSBuZXcgRGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlY29yZChyZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5yZWNvcmRzLnNldChyZWNvcmQuc2VxLCByZWNvcmQpO1xuICAgICAgICB0aGlzLnNpbmsocmVxdWVzdCk7XG4gICAgfVxuICAgIGNyZWF0ZVJlcXVlc3QocmVxdWVzdFNpemUsIHJlc3BvbnNlU2l6ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgU2VxOiB0aGlzLnNlcSsrLFxuICAgICAgICAgICAgRmlsbFJlc3BvbnNlU2l6ZTogcmVzcG9uc2VTaXplLFxuICAgICAgICAgICAgRmlsbGVyOiByZXF1ZXN0U2l6ZSA/ICdBJy5yZXBlYXQocmVxdWVzdFNpemUpIDogJydcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhQ2hhbm5lbExhdGVuY3lUZXN0Q29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuZXhwb3J0IGNsYXNzIERhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZWNvcmQge1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5zZXEgPSByZXF1ZXN0LlNlcTtcbiAgICAgICAgdGhpcy5wbGF5ZXJTZW50VGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0RmlsbGVyU2l6ZSA9IHJlcXVlc3QuRmlsbGVyID8gcmVxdWVzdC5GaWxsZXIubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgdXBkYXRlKHJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMucGxheWVyUmVjZWl2ZWRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnN0cmVhbWVyUmVjZWl2ZWRUaW1lc3RhbXAgPSByZXNwb25zZS5SZWNlaXZlZFRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5zdHJlYW1lclNlbnRUaW1lc3RhbXAgPSByZXNwb25zZS5TZW50VGltZXN0YW1wO1xuICAgICAgICB0aGlzLnJlc3BvbnNlRmlsbGVyU2l6ZSA9IHJlc3BvbnNlLkZpbGxlciA/IHJlc3BvbnNlLkZpbGxlci5sZW5ndGggOiAwO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXN1bHRzLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG4vKipcbiAqIEEgY2xhc3MgZm9yIHNlbmRpbmcgZGF0YSBjaGFubmVsIG1lc3NhZ2VzXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhQ2hhbm5lbFNlbmRlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGFDaGFubmVsUHJvdmlkZXIgLSBEYXRhIGNoYW5uZWwgb2JqZWN0IHR5cGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkYXRhQ2hhbm5lbFByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWxQcm92aWRlciA9IGRhdGFDaGFubmVsUHJvdmlkZXI7XG4gICAgfVxuICAgIGNhblNlbmQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5kYXRhQ2hhbm5lbFByb3ZpZGVyLmdldERhdGFDaGFubmVsSW5zdGFuY2UoKS5kYXRhQ2hhbm5lbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFubmVsUHJvdmlkZXIuZ2V0RGF0YUNoYW5uZWxJbnN0YW5jZSgpLmRhdGFDaGFubmVsLnJlYWR5U3RhdGUgPT0gJ29wZW4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBEYXRhIG92ZXIgdGhlIERhdGEgY2hhbm5lbCB0byB0aGUgVUUgSW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gZGF0YSAtIE1lc3NhZ2UgRGF0YSBBcnJheSBCdWZmZXJcbiAgICAgKi9cbiAgICBzZW5kRGF0YShkYXRhKSB7XG4gICAgICAgIC8vIHJlc2V0IHRoZSBhZmsgaW5hY3Rpdml0eVxuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbEluc3RhbmNlID0gdGhpcy5kYXRhQ2hhbm5lbFByb3ZpZGVyLmdldERhdGFDaGFubmVsSW5zdGFuY2UoKTtcbiAgICAgICAgaWYgKGRhdGFDaGFubmVsSW5zdGFuY2UuZGF0YUNoYW5uZWwucmVhZHlTdGF0ZSA9PSAnb3BlbicpIHtcbiAgICAgICAgICAgIGRhdGFDaGFubmVsSW5zdGFuY2UuZGF0YUNoYW5uZWwuc2VuZChkYXRhKTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKGBNZXNzYWdlIFNlbnQ6ICR7bmV3IFVpbnQ4QXJyYXkoZGF0YSl9YCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0QWZrV2FybmluZ1RpbWVyT25EYXRhU2VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBNZXNzYWdlIEZhaWxlZDogJHtuZXcgVWludDhBcnJheShkYXRhKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBvdmVycmlkZSBtZXRob2QgZm9yIHJlc2V0dGluZyB0aGUgQWZrIHdhcm5pbmcgdGltZXIgd2hlbiBkYXRhIGlzIHNlbnQgb3ZlciB0aGUgZGF0YSBjaGFubmVsXG4gICAgICovXG4gICAgcmVzZXRBZmtXYXJuaW5nVGltZXJPbkRhdGFTZW5kKCkge1xuICAgICAgICAvLyBCYXNlIEZ1bmN0aW9uYWxpdHk6IERvIE5vdGhpbmdcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhQ2hhbm5lbFNlbmRlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBMYXRlbmN5IFRlc3QgUmVzdWx0cyBEYXRhXG4gKi9cbmV4cG9ydCBjbGFzcyBJbml0aWFsU2V0dGluZ3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLlBpeGVsU3RyZWFtaW5nU2V0dGluZ3MgPSBuZXcgUGl4ZWxTdHJlYW1pbmdTZXR0aW5ncygpO1xuICAgICAgICB0aGlzLkVuY29kZXJTZXR0aW5ncyA9IG5ldyBFbmNvZGVyU2V0dGluZ3MoKTtcbiAgICAgICAgdGhpcy5XZWJSVENTZXR0aW5ncyA9IG5ldyBXZWJSVENTZXR0aW5ncygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgRlBTIGFuZCBNYXhGUFMgc3RhdHMgYmV0d2VlbiA0LjI3IGFuZCA1XG4gICAgICovXG4gICAgdWVDb21wYXRpYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5XZWJSVENTZXR0aW5ncy5NYXhGUFMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5XZWJSVENTZXR0aW5ncy5GUFMgPSB0aGlzLldlYlJUQ1NldHRpbmdzLk1heEZQUztcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBjbGFzcyBmb3IgaGFuZGxpbmcgUGl4ZWwgU3RyZWFtaW5nIGRldGFpbHNcbiAqL1xuZXhwb3J0IGNsYXNzIFBpeGVsU3RyZWFtaW5nU2V0dGluZ3Mge1xufVxuLyoqXG4gKiBBIGNsYXNzIGZvciBoYW5kbGluZyBlbmNvZGVyIHN0YXRzXG4gKi9cbmV4cG9ydCBjbGFzcyBFbmNvZGVyU2V0dGluZ3Mge1xufVxuLyoqXG4gKiBBIGNsYXNzIGZvciBoYW5kbGluZyB3ZWIgcnRjIHN0YXRzXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJSVENTZXR0aW5ncyB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jbml0aWFsU2V0dGluZ3MuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42Jztcbi8qKlxuICogTGF0ZW5jeSBUZXN0IFJlc3VsdHMgRGF0YVxuICovXG5leHBvcnQgY2xhc3MgTGF0ZW5jeVRlc3RSZXN1bHRzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy9GaWVsZHMgU2V0IGZyb20gdGhlIGxhdGVuY3kgcGF5bG9hZCByZWdhcmRsZXNzIG9mIHZlcnNpb25cbiAgICAgICAgdGhpcy5SZWNlaXB0VGltZU1zID0gbnVsbDtcbiAgICAgICAgdGhpcy5UcmFuc21pc3Npb25UaW1lTXMgPSBudWxsO1xuICAgICAgICAvL0ZpZWxkcyBTZXQgZnJvbSB0aGUgbGF0ZW5jeSBwYXlsb2FkIGZyb20gNC4yNy4yXG4gICAgICAgIHRoaXMuUHJlQ2FwdHVyZVRpbWVNcyA9IG51bGw7XG4gICAgICAgIHRoaXMuUG9zdENhcHR1cmVUaW1lTXMgPSBudWxsO1xuICAgICAgICB0aGlzLlByZUVuY29kZVRpbWVNcyA9IG51bGw7XG4gICAgICAgIHRoaXMuUG9zdEVuY29kZVRpbWVNcyA9IG51bGw7XG4gICAgICAgIC8vRmllbGRzIFNldCBmcm9tIHRoZSBsYXRlbmN5IHBheWxvYWQgZnJvbSA1LjBcbiAgICAgICAgdGhpcy5FbmNvZGVNcyA9IG51bGw7XG4gICAgICAgIHRoaXMuQ2FwdHVyZVRvU2VuZE1zID0gbnVsbDtcbiAgICAgICAgLy9GaWVsZHMgU2V0IHdoZW4gcHJvY2Vzc2VkXG4gICAgICAgIHRoaXMudGVzdFN0YXJ0VGltZU1zID0gMDtcbiAgICAgICAgdGhpcy5icm93c2VyUmVjZWlwdFRpbWVNcyA9IDA7XG4gICAgICAgIC8vRmllbGRzIHNldCBmcm9tIGNhbGN1bGF0aW9uc1xuICAgICAgICB0aGlzLmxhdGVuY3lFeGNsdWRpbmdEZWNvZGUgPSAwO1xuICAgICAgICB0aGlzLnRlc3REdXJhdGlvbiA9IDA7XG4gICAgICAgIC8vdWVMYXRlbmN5OiBudW1iZXIgPSAwO1xuICAgICAgICB0aGlzLm5ldHdvcmtMYXRlbmN5ID0gMDtcbiAgICAgICAgdGhpcy5icm93c2VyU2VuZExhdGVuY3kgPSAwO1xuICAgICAgICB0aGlzLmZyYW1lRGlzcGxheURlbHRhVGltZU1zID0gMDtcbiAgICAgICAgdGhpcy5lbmRUb0VuZExhdGVuY3kgPSAwO1xuICAgICAgICAvL3VlUGl4ZWxTdHJlYW1MYXRlbmN5OiBudW1iZXIgPSAwO1xuICAgICAgICB0aGlzLmVuY29kZUxhdGVuY3kgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBEZWx0YSBUaW1lIE1pbGxpc2Vjb25kc1xuICAgICAqIEBwYXJhbSBEZWx0YVRpbWVNcyAtIERlbHRhIFRpbWUgTWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgc2V0RnJhbWVEaXNwbGF5RGVsdGFUaW1lKERlbHRhVGltZU1zKSB7XG4gICAgICAgIGlmICh0aGlzLmZyYW1lRGlzcGxheURlbHRhVGltZU1zID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZnJhbWVEaXNwbGF5RGVsdGFUaW1lTXMgPSBNYXRoLnJvdW5kKERlbHRhVGltZU1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBlbmNvZGVyIHRpbWVzIGFuZCBzZXQgdGhlbVxuICAgICAqL1xuICAgIHByb2Nlc3NGaWVsZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLkVuY29kZU1zID09IG51bGwgJiYgKHRoaXMuUHJlRW5jb2RlVGltZU1zICE9IG51bGwgfHwgdGhpcy5Qb3N0RW5jb2RlVGltZU1zICE9IG51bGwpKSB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbyhgU2V0dGluZyBFbmNvZGUgTXMgXFxuICR7dGhpcy5Qb3N0RW5jb2RlVGltZU1zfSBcXG4gJHt0aGlzLlByZUVuY29kZVRpbWVNc31gKTtcbiAgICAgICAgICAgIHRoaXMuRW5jb2RlTXMgPSB0aGlzLlBvc3RFbmNvZGVUaW1lTXMgLSB0aGlzLlByZUVuY29kZVRpbWVNcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5DYXB0dXJlVG9TZW5kTXMgPT0gbnVsbCAmJlxuICAgICAgICAgICAgKHRoaXMuUHJlQ2FwdHVyZVRpbWVNcyAhPSBudWxsIHx8IHRoaXMuUG9zdENhcHR1cmVUaW1lTXMgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKGBTZXR0aW5nIENhcHR1cmVUb1NlbmRNcyBNcyBcXG4gJHt0aGlzLlBvc3RDYXB0dXJlVGltZU1zfSBcXG4gJHt0aGlzLlByZUNhcHR1cmVUaW1lTXN9YCk7XG4gICAgICAgICAgICB0aGlzLkNhcHR1cmVUb1NlbmRNcyA9IHRoaXMuUG9zdENhcHR1cmVUaW1lTXMgLSB0aGlzLlByZUNhcHR1cmVUaW1lTXM7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYXRlbmN5VGVzdFJlc3VsdHMuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogQSBjbGFzcyBmb3IgbWFuYWdpbmcgdGhlIGZyZWV6ZSBmcmFtZSBvYmplY3RcbiAqL1xuZXhwb3J0IGNsYXNzIEZyZWV6ZUZyYW1lIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBmcmVlemUgZnJhbWVcbiAgICAgKiBAcGFyYW0gcm9vdERpdiB0aGUgZGl2IHRoYXQgYSBmcmVlemUgZnJhbWUgZWxlbWVudCB3aWxsIGJlIGluamVjdGVkIGludG9cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihyb290RGl2KSB7XG4gICAgICAgIHRoaXMuZnJlZXplRnJhbWVIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lV2lkdGggPSAwO1xuICAgICAgICB0aGlzLnJvb3REaXYgPSByb290RGl2O1xuICAgICAgICAvLyBjcmVhdGUgdGhlIG92ZXJsYXlcbiAgICAgICAgdGhpcy5yb290RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LmlkID0gJ2ZyZWV6ZUZyYW1lJztcbiAgICAgICAgdGhpcy5yb290RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LnN0eWxlLnpJbmRleCA9ICcyMCc7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgaW1hZ2UgcGxhY2UgaG9sZGVyXG4gICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBpbWFnZSBpbnRvIHRoZSByb290IGVsZW1lbnQgYW5kIGFwcGVuZCB0aGUgZWxlbWVudCB0byB0aGUgcm9vdCBkaXZcbiAgICAgICAgdGhpcy5yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmltYWdlRWxlbWVudCk7XG4gICAgICAgIHRoaXMucm9vdERpdi5hcHBlbmRDaGlsZCh0aGlzLnJvb3RFbGVtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmcmVlemUgZnJhbWUgZWxlbWVudCBmb3Igc2hvd2luZ1xuICAgICAqL1xuICAgIHNldEVsZW1lbnRGb3JTaG93KCkge1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZyZWV6ZSBmcmFtZSBlbGVtZW50IGZvciBoaWRpbmdcbiAgICAgKi9cbiAgICBzZXRFbGVtZW50Rm9ySGlkZSgpIHtcbiAgICAgICAgdGhpcy5yb290RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGZyZWV6ZSBmcmFtZXMgaW1hZ2Ugc291cmNlXG4gICAgICogQHBhcmFtIGpwZWcgLSB0aGUgZnJlZXplIGZyYW1lIGltYWdlIGFzIGEgYnl0ZSBhcnJheSBkYXRhXG4gICAgICovXG4gICAgdXBkYXRlSW1hZ2VFbGVtZW50U291cmNlKGpwZWcpIHtcbiAgICAgICAgY29uc3QgYmFzZTY0ID0gYnRvYShqcGVnLnJlZHVjZSgoZGF0YSwgYnl0ZSkgPT4gZGF0YSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSksICcnKSk7XG4gICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50LnNyYyA9ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LCcgKyBiYXNlNjQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZGltZW5zaW9ucyBmb3IgdGhlIGZyZWV6ZSBmcmFtZSBmcm9tIHRoZSBlbGVtZW50IGFuZCByZXNpemUgaXRcbiAgICAgKi9cbiAgICBzZXREaW1lbnNpb25zRnJvbUVsZW1lbnRBbmRSZXNpemUoKSB7XG4gICAgICAgIHRoaXMuZnJlZXplRnJhbWVIZWlnaHQgPSB0aGlzLmltYWdlRWxlbWVudC5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lV2lkdGggPSB0aGlzLmltYWdlRWxlbWVudC5uYXR1cmFsV2lkdGg7XG4gICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBhIGZyZWV6ZSBmcmFtZSBlbGVtZW50XG4gICAgICovXG4gICAgcmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5mcmVlemVGcmFtZVdpZHRoICE9PSAwICYmIHRoaXMuZnJlZXplRnJhbWVIZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgIGxldCBkaXNwbGF5V2lkdGggPSAwO1xuICAgICAgICAgICAgbGV0IGRpc3BsYXlIZWlnaHQgPSAwO1xuICAgICAgICAgICAgbGV0IGRpc3BsYXlUb3AgPSAwO1xuICAgICAgICAgICAgbGV0IGRpc3BsYXlMZWZ0ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEFzcGVjdFJhdGlvID0gdGhpcy5yb290RGl2LmNsaWVudFdpZHRoIC8gdGhpcy5yb290RGl2LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHZpZGVvQXNwZWN0UmF0aW8gPSB0aGlzLmZyZWV6ZUZyYW1lV2lkdGggLyB0aGlzLmZyZWV6ZUZyYW1lSGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHBhcmVudEFzcGVjdFJhdGlvIDwgdmlkZW9Bc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlXaWR0aCA9IHRoaXMucm9vdERpdi5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBkaXNwbGF5SGVpZ2h0ID0gTWF0aC5mbG9vcih0aGlzLnJvb3REaXYuY2xpZW50V2lkdGggLyB2aWRlb0FzcGVjdFJhdGlvKTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5VG9wID0gTWF0aC5mbG9vcigodGhpcy5yb290RGl2LmNsaWVudEhlaWdodCAtIGRpc3BsYXlIZWlnaHQpICogMC41KTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5TGVmdCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5V2lkdGggPSBNYXRoLmZsb29yKHRoaXMucm9vdERpdi5jbGllbnRIZWlnaHQgKiB2aWRlb0FzcGVjdFJhdGlvKTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5SGVpZ2h0ID0gdGhpcy5yb290RGl2LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICBkaXNwbGF5VG9wID0gMDtcbiAgICAgICAgICAgICAgICBkaXNwbGF5TGVmdCA9IE1hdGguZmxvb3IoKHRoaXMucm9vdERpdi5jbGllbnRXaWR0aCAtIGRpc3BsYXlXaWR0aCkgKiAwLjUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yb290RWxlbWVudC5zdHlsZS53aWR0aCA9IHRoaXMucm9vdERpdi5vZmZzZXRXaWR0aCArICdweCc7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMucm9vdERpdi5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5yb290RWxlbWVudC5zdHlsZS5sZWZ0ID0gMCArICdweCc7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbGVtZW50LnN0eWxlLnRvcCA9IDAgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5pbWFnZUVsZW1lbnQuc3R5bGUud2lkdGggPSBkaXNwbGF5V2lkdGggKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5pbWFnZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gZGlzcGxheUhlaWdodCArICdweCc7XG4gICAgICAgICAgICB0aGlzLmltYWdlRWxlbWVudC5zdHlsZS5sZWZ0ID0gZGlzcGxheUxlZnQgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5pbWFnZUVsZW1lbnQuc3R5bGUudG9wID0gZGlzcGxheVRvcCArICdweCc7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GcmVlemVGcmFtZS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuaW1wb3J0IHsgRnJlZXplRnJhbWUgfSBmcm9tICcuL0ZyZWV6ZUZyYW1lJztcbi8qKlxuICogQSBjbGFzcyBmb3IgY29udHJvbGxpbmcgZnJlZXplIGZyYW1lIGZ1bmN0aW9uYWxpdHlcbiAqL1xuZXhwb3J0IGNsYXNzIEZyZWV6ZUZyYW1lQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgZnJlZXplIGZyYW1lIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gcm9vdERpdiAtIHRoZSBkaXYgdGhhdCBhIGZyZWV6ZSBmcmFtZSBlbGVtZW50IHdpbGwgYmUgaW5qZWN0ZWQgaW50b1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJvb3REaXYpIHtcbiAgICAgICAgdGhpcy5yZWNlaXZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5qcGVnID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZnJlZXplRnJhbWVEZWxheSA9IDUwO1xuICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lID0gbmV3IEZyZWV6ZUZyYW1lKHJvb3REaXYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBmcmVlemUgZnJhbWUgaWYgaXQgaXMgdmFsaWRcbiAgICAgKi9cbiAgICBzaG93RnJlZXplRnJhbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lLnNldEVsZW1lbnRGb3JTaG93KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgZnJlZXplIGZyYW1lIGFuZCBzZXQgdGhlIHZhbGlkaXR5IHRvIGZhbHNlXG4gICAgICovXG4gICAgaGlkZUZyZWV6ZUZyYW1lKCkge1xuICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZnJlZXplRnJhbWUuc2V0RWxlbWVudEZvckhpZGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBmcmVlemUgZnJhbWVzIGltYWdlIHNvdXJjZSBhbmQgbG9hZCBpdFxuICAgICAqIEBwYXJhbSBqcGVnIC0gdGhlIGZyZWV6ZSBmcmFtZSBpbWFnZSBhcyBhIGJ5dGUgYXJyYXkgZGF0YVxuICAgICAqIEBwYXJhbSBvbkxvYWRDYWxsQmFjayAtIGEgY2FsbCBiYWNrIGZvciBtYW5hZ2luZyBpZiB0aGUgcGxheSBvdmVybGF5IG5lZWRzIHRvIGJlIHNob3duIG9yIG5vdFxuICAgICAqL1xuICAgIHVwZGF0ZUZyZWV6ZUZyYW1lQW5kU2hvdyhqcGVnLCBvbkxvYWRDYWxsQmFjaykge1xuICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lLnVwZGF0ZUltYWdlRWxlbWVudFNvdXJjZShqcGVnKTtcbiAgICAgICAgdGhpcy5mcmVlemVGcmFtZS5pbWFnZUVsZW1lbnQub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5mcmVlemVGcmFtZS5zZXREaW1lbnNpb25zRnJvbUVsZW1lbnRBbmRSZXNpemUoKTtcbiAgICAgICAgICAgIG9uTG9hZENhbGxCYWNrKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIG5ldyBmcmVlemUgZnJhbWUgaW1hZ2UgYW5kIHVwZGF0ZSBpdFxuICAgICAqIEBwYXJhbSB2aWV3IC0gdGhlIGZyZWV6ZSBmcmFtZSBpbWFnZSBhcyBhIGJ5dGUgYXJyYXkgZGF0YVxuICAgICAqIEBwYXJhbSBvbkxvYWRDYWxsQmFjayAtIGEgY2FsbCBiYWNrIGZvciBtYW5hZ2luZyBpZiB0aGUgcGxheSBvdmVybGF5IG5lZWRzIHRvIGJlIHNob3duIG9yIG5vdFxuICAgICAqL1xuICAgIHByb2Nlc3NGcmVlemVGcmFtZU1lc3NhZ2Uodmlldywgb25Mb2FkQ2FsbEJhY2spIHtcbiAgICAgICAgLy8gUmVzZXQgZnJlZXplIGZyYW1lIGlmIHdlIGdvdCBhIGZyZWV6ZSBmcmFtZSBtZXNzYWdlIGFuZCB3ZSBhcmUgbm90IFwicmVjZWl2aW5nXCIgeWV0LlxuICAgICAgICBpZiAoIXRoaXMucmVjZWl2aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlY2VpdmluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICAgICAgdGhpcy5qcGVnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4dHJhY3QgdG90YWwgc2l6ZSBvZiBmcmVlemUgZnJhbWUgKGFjcm9zcyBhbGwgY2h1bmtzKVxuICAgICAgICB0aGlzLnNpemUgPSBuZXcgRGF0YVZpZXcodmlldy5zbGljZSgxLCA1KS5idWZmZXIpLmdldEludDMyKDAsIHRydWUpO1xuICAgICAgICAvLyBHZXQgdGhlIGpwZWcgcGFydCBvZiB0aGUgcGF5bG9hZFxuICAgICAgICBjb25zdCBqcGVnQnl0ZXMgPSB2aWV3LnNsaWNlKDEgKyA0KTtcbiAgICAgICAgLy8gQXBwZW5kIHRvIGV4aXN0aW5nIGpwZWcgdGhhdCBob2xkcyB0aGUgZnJlZXplIGZyYW1lXG4gICAgICAgIGlmICh0aGlzLmpwZWcpIHtcbiAgICAgICAgICAgIGNvbnN0IGpwZWcgPSBuZXcgVWludDhBcnJheSh0aGlzLmpwZWcubGVuZ3RoICsganBlZ0J5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBqcGVnLnNldCh0aGlzLmpwZWcsIDApO1xuICAgICAgICAgICAganBlZy5zZXQoanBlZ0J5dGVzLCB0aGlzLmpwZWcubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuanBlZyA9IGpwZWc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gZXhpc3RpbmcgZnJlZXplIGZyYW1lIGpwZWcsIG1ha2Ugb25lXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5qcGVnID0ganBlZ0J5dGVzO1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oYHJlY2VpdmVkIGZpcnN0IGNodW5rIG9mIGZyZWV6ZSBmcmFtZTogJHt0aGlzLmpwZWcubGVuZ3RofS8ke3RoaXMuc2l6ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5pc2hlZCByZWNlaXZpbmcgZnJlZXplIGZyYW1lLCB3ZSBjYW4gc2hvdyBpdCBub3dcbiAgICAgICAgaWYgKHRoaXMuanBlZy5sZW5ndGggPT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oYHJlY2VpdmVkIGNvbXBsZXRlIGZyZWV6ZSBmcmFtZSAke3RoaXMuc2l6ZX1gKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRnJlZXplRnJhbWVBbmRTaG93KHRoaXMuanBlZywgb25Mb2FkQ2FsbEJhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHJlY2VpdmVkIG1vcmUgZGF0YSB0aGFuIHRoZSBmcmVlemUgZnJhbWUgcGF5bG9hZCBtZXNzYWdlIGluZGljYXRlICh0aGlzIGlzIGFuIGVycm9yKVxuICAgICAgICBlbHNlIGlmICh0aGlzLmpwZWcubGVuZ3RoID4gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoYHJlY2VpdmVkIGJpZ2dlciBmcmVlemUgZnJhbWUgdGhhbiBhZHZlcnRpc2VkOiAke3RoaXMuanBlZy5sZW5ndGh9LyR7dGhpcy5zaXplfWApO1xuICAgICAgICAgICAgdGhpcy5qcGVnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZyZWV6ZUZyYW1lQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgZGVlcENvcHlHYW1lcGFkIH0gZnJvbSAnLi9HYW1lcGFkVHlwZXMnO1xuLyoqXG4gKiBHYW1lcGFkIGxheW91dCBjb2RlcyBlbnVtXG4gKi9cbmV4cG9ydCB2YXIgR2FtZXBhZExheW91dDtcbihmdW5jdGlvbiAoR2FtZXBhZExheW91dCkge1xuICAgIEdhbWVwYWRMYXlvdXRbR2FtZXBhZExheW91dFtcIlJpZ2h0Q2x1c3RlckJvdHRvbUJ1dHRvblwiXSA9IDBdID0gXCJSaWdodENsdXN0ZXJCb3R0b21CdXR0b25cIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJSaWdodENsdXN0ZXJSaWdodEJ1dHRvblwiXSA9IDFdID0gXCJSaWdodENsdXN0ZXJSaWdodEJ1dHRvblwiO1xuICAgIEdhbWVwYWRMYXlvdXRbR2FtZXBhZExheW91dFtcIlJpZ2h0Q2x1c3RlckxlZnRCdXR0b25cIl0gPSAyXSA9IFwiUmlnaHRDbHVzdGVyTGVmdEJ1dHRvblwiO1xuICAgIEdhbWVwYWRMYXlvdXRbR2FtZXBhZExheW91dFtcIlJpZ2h0Q2x1c3RlclRvcEJ1dHRvblwiXSA9IDNdID0gXCJSaWdodENsdXN0ZXJUb3BCdXR0b25cIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJMZWZ0U2hvdWxkZXJcIl0gPSA0XSA9IFwiTGVmdFNob3VsZGVyXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiUmlnaHRTaG91bGRlclwiXSA9IDVdID0gXCJSaWdodFNob3VsZGVyXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiTGVmdFRyaWdnZXJcIl0gPSA2XSA9IFwiTGVmdFRyaWdnZXJcIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJSaWdodFRyaWdnZXJcIl0gPSA3XSA9IFwiUmlnaHRUcmlnZ2VyXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiU2VsZWN0T3JCYWNrXCJdID0gOF0gPSBcIlNlbGVjdE9yQmFja1wiO1xuICAgIEdhbWVwYWRMYXlvdXRbR2FtZXBhZExheW91dFtcIlN0YXJ0T3JGb3J3YXJkXCJdID0gOV0gPSBcIlN0YXJ0T3JGb3J3YXJkXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiTGVmdEFuYWxvZ1ByZXNzXCJdID0gMTBdID0gXCJMZWZ0QW5hbG9nUHJlc3NcIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJSaWdodEFuYWxvZ1ByZXNzXCJdID0gMTFdID0gXCJSaWdodEFuYWxvZ1ByZXNzXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiTGVmdENsdXN0ZXJUb3BCdXR0b25cIl0gPSAxMl0gPSBcIkxlZnRDbHVzdGVyVG9wQnV0dG9uXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiTGVmdENsdXN0ZXJCb3R0b21CdXR0b25cIl0gPSAxM10gPSBcIkxlZnRDbHVzdGVyQm90dG9tQnV0dG9uXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiTGVmdENsdXN0ZXJMZWZ0QnV0dG9uXCJdID0gMTRdID0gXCJMZWZ0Q2x1c3RlckxlZnRCdXR0b25cIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJMZWZ0Q2x1c3RlclJpZ2h0QnV0dG9uXCJdID0gMTVdID0gXCJMZWZ0Q2x1c3RlclJpZ2h0QnV0dG9uXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiQ2VudHJlQnV0dG9uXCJdID0gMTZdID0gXCJDZW50cmVCdXR0b25cIjtcbiAgICAvLyBBeGVzXG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiTGVmdFN0aWNrSG9yaXpvbnRhbFwiXSA9IDBdID0gXCJMZWZ0U3RpY2tIb3Jpem9udGFsXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiTGVmdFN0aWNrVmVydGljYWxcIl0gPSAxXSA9IFwiTGVmdFN0aWNrVmVydGljYWxcIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJSaWdodFN0aWNrSG9yaXpvbnRhbFwiXSA9IDJdID0gXCJSaWdodFN0aWNrSG9yaXpvbnRhbFwiO1xuICAgIEdhbWVwYWRMYXlvdXRbR2FtZXBhZExheW91dFtcIlJpZ2h0U3RpY2tWZXJ0aWNhbFwiXSA9IDNdID0gXCJSaWdodFN0aWNrVmVydGljYWxcIjtcbn0pKEdhbWVwYWRMYXlvdXQgfHwgKEdhbWVwYWRMYXlvdXQgPSB7fSkpO1xuLyoqXG4gKiBIYW5kbGVzIGdhbWVwYWQgZXZlbnRzIGZyb20gdGhlIGRvY3VtZW50IHRvIHNlbmQgdG8gdGhlIHN0cmVhbWVyLlxuICovXG5leHBvcnQgY2xhc3MgR2FtZXBhZENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbU1lc3NhZ2VDb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIgPSBzdHJlYW1NZXNzYWdlQ29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5vbkdhbWVwYWRDb25uZWN0ZWRMaXN0ZW5lciA9IHRoaXMub25HYW1lcGFkQ29ubmVjdGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25HYW1lcGFkRGlzY29ubmVjdGVkTGlzdGVuZXIgPSB0aGlzLm9uR2FtZXBhZERpc2Nvbm5lY3RlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJlZm9yZVVubG9hZExpc3RlbmVyID0gdGhpcy5vbkJlZm9yZVVubG9hZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9ICh3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKS5iaW5kKHdpbmRvdyk7XG4gICAgfVxuICAgIHJlZ2lzdGVyKCkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdGhpcy5iZWZvcmVVbmxvYWRMaXN0ZW5lcik7XG4gICAgICAgIGNvbnN0IGJyb3dzZXJXaW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIGlmICgnR2FtZXBhZEV2ZW50JyBpbiBicm93c2VyV2luZG93KSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZ2FtZXBhZGNvbm5lY3RlZCcsIHRoaXMub25HYW1lcGFkQ29ubmVjdGVkTGlzdGVuZXIpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2dhbWVwYWRkaXNjb25uZWN0ZWQnLCB0aGlzLm9uR2FtZXBhZERpc2Nvbm5lY3RlZExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnV2ViS2l0R2FtZXBhZEV2ZW50JyBpbiBicm93c2VyV2luZG93KSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0Z2FtZXBhZGNvbm5lY3RlZCcsIHRoaXMub25HYW1lcGFkQ29ubmVjdGVkTGlzdGVuZXIpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdGdhbWVwYWRkaXNjb25uZWN0ZWQnLCB0aGlzLm9uR2FtZXBhZERpc2Nvbm5lY3RlZExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJzID0gW107XG4gICAgICAgIGlmIChuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZ2FtZXBhZCBvZiBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChnYW1lcGFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25HYW1lcGFkQ29ubmVjdGVkKG5ldyBHYW1lcGFkRXZlbnQoJ2dhbWVwYWRjb25uZWN0ZWQnLCB7IGdhbWVwYWQgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZ2FtZXBhZGNvbm5lY3RlZCcsIHRoaXMub25HYW1lcGFkQ29ubmVjdGVkTGlzdGVuZXIpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZ2FtZXBhZGRpc2Nvbm5lY3RlZCcsIHRoaXMub25HYW1lcGFkRGlzY29ubmVjdGVkTGlzdGVuZXIpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0Z2FtZXBhZGNvbm5lY3RlZCcsIHRoaXMub25HYW1lcGFkQ29ubmVjdGVkTGlzdGVuZXIpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0Z2FtZXBhZGRpc2Nvbm5lY3RlZCcsIHRoaXMub25HYW1lcGFkRGlzY29ubmVjdGVkTGlzdGVuZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXIgb2YgdGhpcy5jb250cm9sbGVycykge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIgJiYgY29udHJvbGxlci5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdHYW1lcGFkRGlzY29ubmVjdGVkJykoW2NvbnRyb2xsZXIuaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJzID0gW107XG4gICAgfVxuICAgIG9uR2FtZXBhZFJlc3BvbnNlUmVjZWl2ZWQoZ2FtZXBhZElkKSB7XG4gICAgICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzKSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlciAmJiBjb250cm9sbGVyLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmlkID0gZ2FtZXBhZElkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9uR2FtZXBhZENvbm5lY3RlZChldmVudCkge1xuICAgICAgICBjb25zdCBnYW1lcGFkID0gZXZlbnQuZ2FtZXBhZDtcbiAgICAgICAgY29uc3QgbmV3Q29udHJvbGxlciA9IHtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZTogZGVlcENvcHlHYW1lcGFkKGdhbWVwYWQpLFxuICAgICAgICAgICAgcHJldlN0YXRlOiBkZWVwQ29weUdhbWVwYWQoZ2FtZXBhZCksXG4gICAgICAgICAgICBpZDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnNbZ2FtZXBhZC5pbmRleF0gPSBuZXdDb250cm9sbGVyO1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMudXBkYXRlU3RhdHVzKCkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0dhbWVwYWRDb25uZWN0ZWQnKSgpO1xuICAgIH1cbiAgICBvbkdhbWVwYWREaXNjb25uZWN0ZWQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZ2FtZXBhZCA9IGV2ZW50LmdhbWVwYWQ7XG4gICAgICAgIGNvbnN0IGRlbGV0ZWRDb250cm9sbGVyID0gdGhpcy5jb250cm9sbGVyc1tnYW1lcGFkLmluZGV4XTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY29udHJvbGxlcnNbZ2FtZXBhZC5pbmRleF07XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnMgPSB0aGlzLmNvbnRyb2xsZXJzLmZpbHRlcigoY29udHJvbGxlcikgPT4gY29udHJvbGxlciAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGRlbGV0ZWRDb250cm9sbGVyLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnR2FtZXBhZERpc2Nvbm5lY3RlZCcpKFtcbiAgICAgICAgICAgICAgICBkZWxldGVkQ29udHJvbGxlci5pZFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2NhbkdhbWVwYWRzKCkge1xuICAgICAgICBjb25zdCBnYW1lcGFkcyA9IG5hdmlnYXRvci5nZXRHYW1lcGFkc1xuICAgICAgICAgICAgPyBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKVxuICAgICAgICAgICAgOiBuYXZpZ2F0b3Iud2Via2l0R2V0R2FtZXBhZHNcbiAgICAgICAgICAgICAgICA/IG5hdmlnYXRvci53ZWJraXRHZXRHYW1lcGFkcygpXG4gICAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnYW1lcGFkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGdhbWVwYWRzW2ldICYmIHRoaXMuY29udHJvbGxlcnNbZ2FtZXBhZHNbaV0uaW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJzW2dhbWVwYWRzW2ldLmluZGV4XS5jdXJyZW50U3RhdGUgPSBnYW1lcGFkc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTdGF0dXMoKSB7XG4gICAgICAgIHRoaXMuc2NhbkdhbWVwYWRzKCk7XG4gICAgICAgIGNvbnN0IHRvU3RyZWFtZXJIYW5kbGVycyA9IHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzO1xuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgbXVsdGlwbGUgY29udHJvbGxlcnMgaW4gdGhlIGNhc2UgdGhlIG11bHRpcGxlIGdhbWVwYWRzIGFyZSBjb25uZWN0ZWRcbiAgICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuY29udHJvbGxlcnMpIHtcbiAgICAgICAgICAgIGlmICghY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCByZWNlaXZlZCBhbiBpZCAocG9zc2libGUgaWYgdXNpbmcgYW4gb2xkZXIgdmVyc2lvbiBvZiBVRSksIHJldHVybiB0byBvcmlnaW5hbCBmdW5jdGlvbmFsaXR5XG4gICAgICAgICAgICBjb25zdCBjb250cm9sbGVySWQgPSBjb250cm9sbGVyLmlkID09PSB1bmRlZmluZWQgPyB0aGlzLmNvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcikgOiBjb250cm9sbGVyLmlkO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gY29udHJvbGxlci5jdXJyZW50U3RhdGU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRyb2xsZXIuY3VycmVudFN0YXRlLmJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50QnV0dG9uID0gY29udHJvbGxlci5jdXJyZW50U3RhdGUuYnV0dG9uc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0J1dHRvbiA9IGNvbnRyb2xsZXIucHJldlN0YXRlLmJ1dHRvbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCdXR0b24ucHJlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmVzc1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBHYW1lcGFkTGF5b3V0LkxlZnRUcmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVRXMgbGVmdCBhbmFsb2cgaGFzIGEgYnV0dG9uIGluZGV4IG9mIDVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0dhbWVwYWRBbmFsb2cnKShbY29udHJvbGxlcklkLCA1LCBjdXJyZW50QnV0dG9uLnZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSBHYW1lcGFkTGF5b3V0LlJpZ2h0VHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVUVzIHJpZ2h0IGFuYWxvZyBoYXMgYSBidXR0b24gaW5kZXggb2YgNlxuICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnR2FtZXBhZEFuYWxvZycpKFtjb250cm9sbGVySWQsIDYsIGN1cnJlbnRCdXR0b24udmFsdWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0dhbWVwYWRCdXR0b25QcmVzc2VkJykoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQnV0dG9uLnByZXNzZWQgPyAxIDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnJlbnRCdXR0b24ucHJlc3NlZCAmJiBwcmV2aW91c0J1dHRvbi5wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbGVhc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gR2FtZXBhZExheW91dC5MZWZ0VHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVUVzIGxlZnQgYW5hbG9nIGhhcyBhIGJ1dHRvbiBpbmRleCBvZiA1XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdHYW1lcGFkQW5hbG9nJykoW2NvbnRyb2xsZXJJZCwgNSwgMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gR2FtZXBhZExheW91dC5SaWdodFRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVFcyByaWdodCBhbmFsb2cgaGFzIGEgYnV0dG9uIGluZGV4IG9mIDZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0dhbWVwYWRBbmFsb2cnKShbY29udHJvbGxlcklkLCA2LCAwXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdHYW1lcGFkQnV0dG9uUmVsZWFzZWQnKShbY29udHJvbGxlcklkLCBpLCAwXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgZ2FtZXBhZCBheGVzICh3ZSB3aWxsIGluY3JlbWVudCBpbiBsb3RzIG9mIDIgYXMgdGhlcmUgaXMgMiBheGVzIHBlciBzdGljaylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudFN0YXRlLmF4ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBIb3Jpem9udGFsIGF4ZXMgYXJlIGV2ZW4gbnVtYmVyZWRcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gcGFyc2VGbG9hdChjdXJyZW50U3RhdGUuYXhlc1tpXS50b0ZpeGVkKDQpKTtcbiAgICAgICAgICAgICAgICAvLyBWZXJ0aWNhbCBheGVzIGFyZSBvZGQgbnVtYmVyZWRcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vZ2FtZXBhZC8jcmVtYXBwaW5nIEdhbWVwYWQgYnJvd3NlciBzaWRlIHN0YW5kYXJkIG1hcHBpbmcgaGFzIHBvc2l0aXZlIGRvd24sIG5lZ2F0aXZlIHVwLiBUaGlzIGlzIGRvd25yaWdodCBkaXNndXN0aW5nLiBTbyB3ZSBmaXggaXQuXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IC1wYXJzZUZsb2F0KGN1cnJlbnRTdGF0ZS5heGVzW2kgKyAxXS50b0ZpeGVkKDQpKTtcbiAgICAgICAgICAgICAgICAvLyBVRSdzIGFuYWxvZyBheGVzIGZvbGxvdyB0aGUgc2FtZSBvcmRlciBhcyB0aGUgYnJvd3NlcnMsIGJ1dCBzdGFydCBhdCBpbmRleCAxIHNvIHdlIHdpbGwgb2Zmc2V0IGFzIHN1Y2hcbiAgICAgICAgICAgICAgICB0b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdHYW1lcGFkQW5hbG9nJykoW2NvbnRyb2xsZXJJZCwgaSArIDEsIHhdKTsgLy8gSG9yaXpvbnRhbCBheGVzLCBvbmx5IG9mZnNldCBieSAxXG4gICAgICAgICAgICAgICAgdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnR2FtZXBhZEFuYWxvZycpKFtjb250cm9sbGVySWQsIGkgKyAyLCB5XSk7IC8vIFZlcnRpY2FsIGF4ZXMsIG9mZnNldCBieSB0d28gKDEgdG8gbWF0Y2ggVUVzIGF4ZXMgY29udmVudGlvbiBhbmQgdGhlbiBhbm90aGVyIDEgZm9yIHRoZSB2ZXJ0aWNhbCBheGVzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlckluZGV4ID0gdGhpcy5jb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyc1tjb250cm9sbGVySW5kZXhdLnByZXZTdGF0ZSA9IGRlZXBDb3B5R2FtZXBhZChjdXJyZW50U3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2xsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMudXBkYXRlU3RhdHVzKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uQmVmb3JlVW5sb2FkKF8pIHtcbiAgICAgICAgLy8gV2hlbiBhIHVzZXIgbmF2aWdhdGVzIGF3YXkgZnJvbSB0aGUgcGFnZSwgd2UgbmVlZCB0byBpbmZvcm0gVUUgb2YgYWxsIHRoZSBkaXNjb25uZWN0aW5nXG4gICAgICAgIC8vIGNvbnRyb2xsZXJzXG4gICAgICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRyb2xsZXIgfHwgY29udHJvbGxlci5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0dhbWVwYWREaXNjb25uZWN0ZWQnKShbY29udHJvbGxlci5pZF0pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2FtZXBhZENvbnRyb2xsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogRGVlcCBjb3BpZXMgdGhlIHZhbHVlcyBmcm9tIGEgZ2FtZXBhZCBieSBmaXJzdCBjb252ZXJ0aW5nIGl0IHRvIGEgSlNPTiBvYmplY3QgYW5kIHRoZW4gYmFjayB0byBhIGdhbWVwYWRcbiAqXG4gKiBAcGFyYW0gZ2FtZXBhZCB0aGUgb3JpZ2luYWwgZ2FtZXBhZFxuICogQHJldHVybnMgYSBuZXcgZ2FtZXBhZCBvYmplY3QsIHBvcHVsYXRlZCB3aXRoIHRoZSBvcmlnaW5hbCBnYW1lcGFkcyB2YWx1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDb3B5R2FtZXBhZChnYW1lcGFkKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBidXR0b25zOiBnYW1lcGFkLmJ1dHRvbnMubWFwKChiKSA9PiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHByZXNzZWQ6IGIucHJlc3NlZCxcbiAgICAgICAgICAgIHRvdWNoZWQ6IGIudG91Y2hlZCxcbiAgICAgICAgICAgIHZhbHVlOiBiLnZhbHVlXG4gICAgICAgIH0pKSksXG4gICAgICAgIGF4ZXM6IGdhbWVwYWQuYXhlc1xuICAgIH0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdhbWVwYWRUeXBlcy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgS2V5Ym9hcmRDb250cm9sbGVyIH0gZnJvbSAnLi9LZXlib2FyZENvbnRyb2xsZXInO1xuaW1wb3J0IHsgTW91c2VDb250cm9sbGVyTG9ja2VkIH0gZnJvbSAnLi9Nb3VzZUNvbnRyb2xsZXJMb2NrZWQnO1xuaW1wb3J0IHsgTW91c2VDb250cm9sbGVySG92ZXJpbmcgfSBmcm9tICcuL01vdXNlQ29udHJvbGxlckhvdmVyaW5nJztcbmltcG9ydCB7IFRvdWNoQ29udHJvbGxlciB9IGZyb20gJy4vVG91Y2hDb250cm9sbGVyJztcbmltcG9ydCB7IFRvdWNoQ29udHJvbGxlckZha2UgfSBmcm9tICcuL1RvdWNoQ29udHJvbGxlckZha2UnO1xuaW1wb3J0IHsgR2FtZXBhZENvbnRyb2xsZXIgfSBmcm9tICcuL0dhbWVwYWRDb250cm9sbGVyJztcbmltcG9ydCB7IENvbnRyb2xTY2hlbWVUeXBlIH0gZnJvbSAnLi4vQ29uZmlnL0NvbmZpZyc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG4vKipcbiAqIENsYXNzIGZvciBtYWtpbmcgYW5kIHNldHRpbmcgdXAgaW5wdXQgY2xhc3MgdHlwZXNcbiAqL1xuZXhwb3J0IGNsYXNzIElucHV0Q2xhc3Nlc0ZhY3Rvcnkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB0b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlciAtIFN0cmVhbSBtZXNzYWdlIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHZpZGVvRWxlbWVudFByb3ZpZGVyIC0gVmlkZW8gUGxheWVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIGNvb3JkaW5hdGVDb252ZXJ0ZXIgLSBBIGNvb3JkaW5hdGVDb252ZXJ0ZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlciwgdmlkZW9FbGVtZW50UHJvdmlkZXIsIGNvb3JkaW5hdGVDb252ZXJ0ZXIpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVLZXlzID0gbmV3IEFjdGl2ZUtleXMoKTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlciA9IHRvU3RyZWFtZXJNZXNzYWdlc1Byb3ZpZGVyO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFByb3ZpZGVyID0gdmlkZW9FbGVtZW50UHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlciA9IGNvb3JkaW5hdGVDb252ZXJ0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBicm93c2VyIGtleSBldmVudHMuXG4gICAgICovXG4gICAgcmVnaXN0ZXJLZXlCb2FyZChjb25maWcpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ1JlZ2lzdGVyIEtleWJvYXJkIEV2ZW50cycpO1xuICAgICAgICBjb25zdCBrZXlib2FyZENvbnRyb2xsZXIgPSBuZXcgS2V5Ym9hcmRDb250cm9sbGVyKHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXIsIGNvbmZpZywgdGhpcy5hY3RpdmVLZXlzKTtcbiAgICAgICAga2V5Ym9hcmRDb250cm9sbGVyLnJlZ2lzdGVyKCk7XG4gICAgICAgIHJldHVybiBrZXlib2FyZENvbnRyb2xsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJlZ2lzdGVyIG1vdXNlIGV2ZW50cyBiYXNlZCBvbiBhIGNvbnRyb2wgdHlwZVxuICAgICAqIEBwYXJhbSBjb250cm9sU2NoZW1lIC0gaWYgdGhlIG1vdXNlIGlzIGVpdGhlciBob3ZlcmluZyBvciBsb2NrZWRcbiAgICAgKi9cbiAgICByZWdpc3Rlck1vdXNlKGNvbnRyb2xTY2hlbWUpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ1JlZ2lzdGVyIE1vdXNlIEV2ZW50cycpO1xuICAgICAgICBsZXQgbW91c2VDb250cm9sbGVyO1xuICAgICAgICBpZiAoY29udHJvbFNjaGVtZSA9PSBDb250cm9sU2NoZW1lVHlwZS5Ib3ZlcmluZ01vdXNlKSB7XG4gICAgICAgICAgICBtb3VzZUNvbnRyb2xsZXIgPSBuZXcgTW91c2VDb250cm9sbGVySG92ZXJpbmcodGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlciwgdGhpcy52aWRlb0VsZW1lbnRQcm92aWRlciwgdGhpcy5jb29yZGluYXRlQ29udmVydGVyLCB0aGlzLmFjdGl2ZUtleXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW91c2VDb250cm9sbGVyID0gbmV3IE1vdXNlQ29udHJvbGxlckxvY2tlZCh0aGlzLnRvU3RyZWFtZXJNZXNzYWdlc1Byb3ZpZGVyLCB0aGlzLnZpZGVvRWxlbWVudFByb3ZpZGVyLCB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIsIHRoaXMuYWN0aXZlS2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgbW91c2VDb250cm9sbGVyLnJlZ2lzdGVyKCk7XG4gICAgICAgIHJldHVybiBtb3VzZUNvbnRyb2xsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJlZ2lzdGVyIHRvdWNoIGV2ZW50c1xuICAgICAqIEBwYXJhbSBmYWtlTW91c2VUb3VjaCAtIHRoZSBmYWtlZCBtb3VzZSB0b3VjaCBldmVudFxuICAgICAqL1xuICAgIHJlZ2lzdGVyVG91Y2goZmFrZU1vdXNlVG91Y2gpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ1JlZ2lzdGVyaW5nIFRvdWNoJyk7XG4gICAgICAgIGxldCB0b3VjaENvbnRyb2xsZXI7XG4gICAgICAgIGlmIChmYWtlTW91c2VUb3VjaCkge1xuICAgICAgICAgICAgdG91Y2hDb250cm9sbGVyID0gbmV3IFRvdWNoQ29udHJvbGxlckZha2UodGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlciwgdGhpcy52aWRlb0VsZW1lbnRQcm92aWRlciwgdGhpcy5jb29yZGluYXRlQ29udmVydGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvdWNoQ29udHJvbGxlciA9IG5ldyBUb3VjaENvbnRyb2xsZXIodGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlciwgdGhpcy52aWRlb0VsZW1lbnRQcm92aWRlciwgdGhpcy5jb29yZGluYXRlQ29udmVydGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0b3VjaENvbnRyb2xsZXIucmVnaXN0ZXIoKTtcbiAgICAgICAgcmV0dXJuIHRvdWNoQ29udHJvbGxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmVnaXN0ZXJzIGEgZ2FtZXBhZFxuICAgICAqL1xuICAgIHJlZ2lzdGVyR2FtZVBhZCgpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ1JlZ2lzdGVyIEdhbWUgUGFkJyk7XG4gICAgICAgIGNvbnN0IGdhbWVwYWRDb250cm9sbGVyID0gbmV3IEdhbWVwYWRDb250cm9sbGVyKHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXIpO1xuICAgICAgICBnYW1lcGFkQ29udHJvbGxlci5yZWdpc3RlcigpO1xuICAgICAgICByZXR1cm4gZ2FtZXBhZENvbnRyb2xsZXI7XG4gICAgfVxufVxuLyoqXG4gKiBBIGNsYXNzIHRoYXQga2VlcHMgdHJhY2sgb2YgY3VycmVudCBhY3RpdmUga2V5c1xuICovXG5leHBvcnQgY2xhc3MgQWN0aXZlS2V5cyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlS2V5cyA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZUtleXMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGFycmF5IG9mIGFjdGl2ZSBrZXlzXG4gICAgICogQHJldHVybnMgLSBhbiBhcnJheSBvZiBhY3RpdmUga2V5c1xuICAgICAqL1xuICAgIGdldEFjdGl2ZUtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUtleXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5wdXRDbGFzc2VzRmFjdG9yeS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLypcbiAqIE5ldyBicm93c2VyIEFQSXMgaGF2ZSBtb3ZlZCBhd2F5IGZyb20gS2V5Ym9hcmRFdmVudC5rZXlDb2RlIHRvIEtleWJvYXJkRXZlbnQuQ29kZS5cbiAqIEZvciBkZXRhaWxzIHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5Q29kZSNjb25zdGFudHNfZm9yX2tleWNvZGVfdmFsdWVcbiAqIFdlIHN0aWxsIHVzZSBvbGQgS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGludGVnZXJzIGluIHRoZSBVRSBDKysgc2lkZSwgc28gd2UgbmVlZCBhIHdheSB0byBtYXAgdGhlIG5ld1xuICogc3RyaW5nLWJhc2VkIEtleWJvYXJkRXZlbnQuQ29kZSB0byB0aGUgb2xkIGludGVnZXJzLlxuICovXG5leHBvcnQgY29uc3QgQ29kZVRvS2V5Q29kZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIEVzY2FwZTogMjcsXG4gICAgRGlnaXQwOiA0OCxcbiAgICBEaWdpdDE6IDQ5LFxuICAgIERpZ2l0MjogNTAsXG4gICAgRGlnaXQzOiA1MSxcbiAgICBEaWdpdDQ6IDUyLFxuICAgIERpZ2l0NTogNTMsXG4gICAgRGlnaXQ2OiA1NCxcbiAgICBEaWdpdDc6IDU1LFxuICAgIERpZ2l0ODogNTYsXG4gICAgRGlnaXQ5OiA1NyxcbiAgICBNaW51czogMTczLFxuICAgIEVxdWFsOiAxODcsXG4gICAgQmFja3NwYWNlOiA4LFxuICAgIFRhYjogOSxcbiAgICBLZXlROiA4MSxcbiAgICBLZXlXOiA4NyxcbiAgICBLZXlFOiA2OSxcbiAgICBLZXlSOiA4MixcbiAgICBLZXlUOiA4NCxcbiAgICBLZXlZOiA4OSxcbiAgICBLZXlVOiA4NSxcbiAgICBLZXlJOiA3MyxcbiAgICBLZXlPOiA3OSxcbiAgICBLZXlQOiA4MCxcbiAgICBCcmFja2V0TGVmdDogMjE5LFxuICAgIEJyYWNrZXRSaWdodDogMjIxLFxuICAgIEVudGVyOiAxMyxcbiAgICBDb250cm9sTGVmdDogMTcsXG4gICAgS2V5QTogNjUsXG4gICAgS2V5UzogODMsXG4gICAgS2V5RDogNjgsXG4gICAgS2V5RjogNzAsXG4gICAgS2V5RzogNzEsXG4gICAgS2V5SDogNzIsXG4gICAgS2V5SjogNzQsXG4gICAgS2V5SzogNzUsXG4gICAgS2V5TDogNzYsXG4gICAgU2VtaWNvbG9uOiAxODYsXG4gICAgUXVvdGU6IDIyMixcbiAgICBCYWNrcXVvdGU6IDE5MixcbiAgICBTaGlmdExlZnQ6IDE2LFxuICAgIEJhY2tzbGFzaDogMjIwLFxuICAgIEtleVo6IDkwLFxuICAgIEtleVg6IDg4LFxuICAgIEtleUM6IDY3LFxuICAgIEtleVY6IDg2LFxuICAgIEtleUI6IDY2LFxuICAgIEtleU46IDc4LFxuICAgIEtleU06IDc3LFxuICAgIENvbW1hOiAxODgsXG4gICAgUGVyaW9kOiAxOTAsXG4gICAgU2xhc2g6IDE5MSxcbiAgICBTaGlmdFJpZ2h0OiAyNTMsXG4gICAgQWx0TGVmdDogMTgsXG4gICAgU3BhY2U6IDMyLFxuICAgIENhcHNMb2NrOiAyMCxcbiAgICBGMTogMTEyLFxuICAgIEYyOiAxMTMsXG4gICAgRjM6IDExNCxcbiAgICBGNDogMTE1LFxuICAgIEY1OiAxMTYsXG4gICAgRjY6IDExNyxcbiAgICBGNzogMTE4LFxuICAgIEY4OiAxMTksXG4gICAgRjk6IDEyMCxcbiAgICBGMTA6IDEyMSxcbiAgICBGMTE6IDEyMixcbiAgICBGMTI6IDEyMyxcbiAgICBQYXVzZTogMTksXG4gICAgU2Nyb2xsTG9jazogMTQ1LFxuICAgIE51bXBhZERpdmlkZTogMTExLFxuICAgIE51bXBhZE11bHRpcGx5OiAxMDYsXG4gICAgTnVtcGFkU3VidHJhY3Q6IDEwOSxcbiAgICBOdW1wYWRBZGQ6IDEwNyxcbiAgICBOdW1wYWREZWNpbWFsOiAxMTAsXG4gICAgTnVtcGFkOTogMTA1LFxuICAgIE51bXBhZDg6IDEwNCxcbiAgICBOdW1wYWQ3OiAxMDMsXG4gICAgTnVtcGFkNjogMTAyLFxuICAgIE51bXBhZDU6IDEwMSxcbiAgICBOdW1wYWQ0OiAxMDAsXG4gICAgTnVtcGFkMzogOTksXG4gICAgTnVtcGFkMjogOTgsXG4gICAgTnVtcGFkMTogOTcsXG4gICAgTnVtcGFkMDogOTYsXG4gICAgTnVtTG9jazogMTQ0LFxuICAgIENvbnRyb2xSaWdodDogMjU0LFxuICAgIEFsdFJpZ2h0OiAyNTUsXG4gICAgSG9tZTogMzYsXG4gICAgRW5kOiAzNSxcbiAgICBBcnJvd1VwOiAzOCxcbiAgICBBcnJvd0xlZnQ6IDM3LFxuICAgIEFycm93UmlnaHQ6IDM5LFxuICAgIEFycm93RG93bjogNDAsXG4gICAgUGFnZVVwOiAzMyxcbiAgICBQYWdlRG93bjogMzQsXG4gICAgSW5zZXJ0OiA0NSxcbiAgICBEZWxldGU6IDQ2LFxuICAgIENvbnRleHRNZW51OiA5M1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1LZXlDb2Rlcy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgU3BlY2lhbEtleUNvZGVzIH0gZnJvbSAnLi9TcGVjaWFsS2V5Q29kZXMnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuaW1wb3J0IHsgRmxhZ3MgfSBmcm9tICcuLi9Db25maWcvQ29uZmlnJztcbmltcG9ydCB7IENvZGVUb0tleUNvZGUgfSBmcm9tICcuL0tleUNvZGVzJztcbi8qKlxuICogSGFuZGxlcyB0aGUgS2V5Ym9hcmQgSW5wdXRzIGZvciB0aGUgZG9jdW1lbnRcbiAqL1xuZXhwb3J0IGNsYXNzIEtleWJvYXJkQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3Ioc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIsIGNvbmZpZywgYWN0aXZlS2V5cykge1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyID0gc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmFjdGl2ZUtleXMgPSBhY3RpdmVLZXlzO1xuICAgICAgICB0aGlzLm9uS2V5RG93bkxpc3RlbmVyID0gdGhpcy5oYW5kbGVPbktleURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbktleVVwTGlzdGVuZXIgPSB0aGlzLmhhbmRsZU9uS2V5VXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbktleVByZXNzTGlzdGVuZXIgPSB0aGlzLmhhbmRsZU9uS2V5UHJlc3MuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bkxpc3RlbmVyKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uS2V5VXBMaXN0ZW5lcik7XG4gICAgICAgIC8vVGhpcyBoYXMgYmVlbiBkZXByZWNhdGVkIGFzIGF0IEp1biAxMyAyMDIxXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgdGhpcy5vbktleVByZXNzTGlzdGVuZXIpO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleURvd25MaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5vbktleVVwTGlzdGVuZXIpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHRoaXMub25LZXlQcmVzc0xpc3RlbmVyKTtcbiAgICB9XG4gICAgaGFuZGxlT25LZXlEb3duKGtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBrZXlDb2RlID0gdGhpcy5nZXRLZXljb2RlKGtleWJvYXJkRXZlbnQpO1xuICAgICAgICBpZiAoIWtleUNvZGUgfHwga2V5Q29kZSA9PT0gMjI5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9TdHJlYW1lckhhbmRsZXJzID0gdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnM7XG4gICAgICAgIChfYSA9IHRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0tleURvd24nKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKFt0aGlzLmdldEtleWNvZGUoa2V5Ym9hcmRFdmVudCksIGtleWJvYXJkRXZlbnQucmVwZWF0ID8gMSA6IDBdKTtcbiAgICAgICAgY29uc3QgYWN0aXZlS2V5cyA9IHRoaXMuYWN0aXZlS2V5cy5nZXRBY3RpdmVLZXlzKCk7XG4gICAgICAgIGFjdGl2ZUtleXMucHVzaChrZXlDb2RlKTtcbiAgICAgICAgLy8gQmFja3NwYWNlIGlzIG5vdCBjb25zaWRlcmVkIGEga2V5cHJlc3MgaW4gSmF2YVNjcmlwdCBidXQgd2UgbmVlZCBpdFxuICAgICAgICAvLyB0byBiZSBzbyBjaGFyYWN0ZXJzIG1heSBiZSBkZWxldGVkIGluIGEgVUUgdGV4dCBlbnRyeSBmaWVsZC5cbiAgICAgICAgLy8gc2luY2Uga2V5cHJlc3MgaXMgZGVwcmVjYXRlZCB3ZSByZWFsbHkgc2hvdWxkIGJlIHNlbmRpbmcgYWxsIGtleXMgdG8ga2V5cHJlc3NcbiAgICAgICAgLy8gb3Igd2UgY2hhbmdlIGV2ZXJ5dGhpbmcgdG8gaGFuZGxlIHRoZSBkZXByZWNhdGlvbiBvZiB0aGVzZSBwYXJ0c1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gU3BlY2lhbEtleUNvZGVzLmJhY2tTcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVPbktleVByZXNzKG5ldyBLZXlib2FyZEV2ZW50KCdrZXlwcmVzcycsIHtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZTogU3BlY2lhbEtleUNvZGVzLmJhY2tTcGFjZSxcbiAgICAgICAgICAgICAgICBrZXlDb2RlOiBTcGVjaWFsS2V5Q29kZXMuYmFja1NwYWNlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuU3VwcHJlc3NCcm93c2VyS2V5cykgJiYgdGhpcy5pc0tleUNvZGVCcm93c2VyS2V5KGtleUNvZGUpKSB7XG4gICAgICAgICAgICBrZXlib2FyZEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlT25LZXlVcChrZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qga2V5Q29kZSA9IHRoaXMuZ2V0S2V5Y29kZShrZXlib2FyZEV2ZW50KTtcbiAgICAgICAgaWYgKCFrZXlDb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9TdHJlYW1lckhhbmRsZXJzID0gdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnM7XG4gICAgICAgIChfYSA9IHRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0tleVVwJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYShba2V5Q29kZV0pO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5TdXBwcmVzc0Jyb3dzZXJLZXlzKSAmJiB0aGlzLmlzS2V5Q29kZUJyb3dzZXJLZXkoa2V5Q29kZSkpIHtcbiAgICAgICAgICAgIGtleWJvYXJkRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVPbktleVByZXNzKGtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBrZXlDb2RlID0gdGhpcy5nZXRLZXljb2RlKGtleWJvYXJkRXZlbnQpO1xuICAgICAgICBpZiAoIWtleUNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b1N0cmVhbWVySGFuZGxlcnMgPSB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycztcbiAgICAgICAgKF9hID0gdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnS2V5UHJlc3MnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKFtrZXlDb2RlXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEtleWNvZGUgb2YgdGhlIEtleSBwcmVzc2VkXG4gICAgICogQHBhcmFtIGtleWJvYXJkRXZlbnQgLSBLZXkgYm9hcmQgRXZlbnRcbiAgICAgKiBAcmV0dXJucyAtIHRoZSBrZXkgY29kZSBvZiB0aGUgS2V5XG4gICAgICovXG4gICAgZ2V0S2V5Y29kZShrZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUga2V5Q29kZSBwcm9wZXJ0eSBiZWNhdXNlIGJyb3dzZXIgQVBJIGlzIGRlcHJlY2F0ZWQgdGhlbiB1c2UgS2V5Ym9hcmRFdmVudC5jb2RlIGluc3RlYWQuXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5Q29kZSNjb25zdGFudHNfZm9yX2tleWNvZGVfdmFsdWVcbiAgICAgICAgaWYgKCEoJ2tleUNvZGUnIGluIGtleWJvYXJkRXZlbnQpKSB7XG4gICAgICAgICAgICAvLyB0aGlzIHR5cGUgYXNzZXJ0aW9uIGhlcmUgaXMgcmVxdWlyZWQgYmVjYXVzZSBpZiAna2V5Q29kZScgZG9lc250IGV4aXN0IGluIGtleWJvYXJkRXZlbnQgdGhlblxuICAgICAgICAgICAgLy8gaXQgY2Fubm90IGJlIGEgS2V5Ym9hcmRFdmVudCBhbmQgc28gaXQgZ2V0cyBuYXJyb3dlZCB0byAnbmV2ZXInXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGtleWJvYXJkRXZlbnQ7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IEtleWJvYXJkRXZlbnQuY29kZSBzdHJpbmcgaW50byBpbnRlZ2VyLWJhc2VkIGtleSBjb2RlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zLlxuICAgICAgICAgICAgaWYgKGV2ZW50LmNvZGUgaW4gQ29kZVRvS2V5Q29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb2RlVG9LZXlDb2RlW2V2ZW50LmNvZGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLldhcm5pbmcoYEtleWJvYXJkIGNvZGUgb2YgJHtldmVudC5jb2RlfSBpcyBub3Qgc3VwcG9ydGVkIGluIG91ciBtYXBwaW5nLCBpZ25vcmluZyB0aGlzIGtleS5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBtYWRlIGl0IGhlcmUgS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGlzIHN0aWxsIHN1cHBvcnRlZCBzbyB3ZSBjYW4gc2FmZWx5IHVzZSBpdC5cbiAgICAgICAgaWYgKGtleWJvYXJkRXZlbnQua2V5Q29kZSA9PT0gU3BlY2lhbEtleUNvZGVzLnNoaWZ0ICYmIGtleWJvYXJkRXZlbnQuY29kZSA9PT0gJ1NoaWZ0UmlnaHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gU3BlY2lhbEtleUNvZGVzLnJpZ2h0U2hpZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5Ym9hcmRFdmVudC5rZXlDb2RlID09PSBTcGVjaWFsS2V5Q29kZXMuY29udHJvbCAmJlxuICAgICAgICAgICAga2V5Ym9hcmRFdmVudC5jb2RlID09PSAnQ29udHJvbFJpZ2h0Jykge1xuICAgICAgICAgICAgcmV0dXJuIFNwZWNpYWxLZXlDb2Rlcy5yaWdodENvbnRyb2w7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5Ym9hcmRFdmVudC5rZXlDb2RlID09PSBTcGVjaWFsS2V5Q29kZXMuYWx0ICYmIGtleWJvYXJkRXZlbnQuY29kZSA9PT0gJ0FsdFJpZ2h0Jykge1xuICAgICAgICAgICAgcmV0dXJuIFNwZWNpYWxLZXlDb2Rlcy5yaWdodEFsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlib2FyZEV2ZW50LmtleUNvZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnJvd3NlciBrZXlzIGRvIG5vdCBoYXZlIGEgY2hhckNvZGUgc28gd2Ugb25seSBuZWVkIHRvIHRlc3Qga2V5Q29kZS5cbiAgICAgKiBAcGFyYW0ga2V5Q29kZSAtIHRoZSBicm93c2VyIGtleWNvZGUgbnVtYmVyXG4gICAgICovXG4gICAgaXNLZXlDb2RlQnJvd3NlcktleShrZXlDb2RlKSB7XG4gICAgICAgIC8vIEZ1bmN0aW9uIGtleXMgb3IgdGFiIGtleSBhcmUgY29uc2lkZXJlZCBcImJyb3dzZXIga2V5c1wiIHRoYXQgd2UgbWF5IHdpc2ggdG8gc3VwcHJlc3MgYnkgcHJldmVudGluZyB0aGVtIGJlaW5nIHByb2Nlc3MgYnkgYnJvd3Nlci5cbiAgICAgICAgcmV0dXJuIChrZXlDb2RlID49IDExMiAmJiBrZXlDb2RlIDw9IDEyMykgfHwga2V5Q29kZSA9PT0gOTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1LZXlib2FyZENvbnRyb2xsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogTW91c2UgQnV0dG9uIERhdGFcbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9idXR0b259XG4gKi9cbmV4cG9ydCBjbGFzcyBNb3VzZUJ1dHRvbiB7XG59XG5Nb3VzZUJ1dHRvbi5tYWluQnV0dG9uID0gMDsgLy8gTGVmdCBidXR0b24uXG5Nb3VzZUJ1dHRvbi5hdXhpbGlhcnlCdXR0b24gPSAxOyAvLyBXaGVlbCBidXR0b24uXG5Nb3VzZUJ1dHRvbi5zZWNvbmRhcnlCdXR0b24gPSAyOyAvLyBSaWdodCBidXR0b24uXG5Nb3VzZUJ1dHRvbi5mb3VydGhCdXR0b24gPSAzOyAvLyBCcm93c2VyIEJhY2sgYnV0dG9uLlxuTW91c2VCdXR0b24uZmlmdGhCdXR0b24gPSA0OyAvLyBCcm93c2VyIEZvcndhcmQgYnV0dG9uLlxuLyoqXG4gKiBNb3VzZSBCdXR0b24gTWFzayBEYXRhXG4gKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvYnV0dG9uc31cbiAqL1xuZXhwb3J0IGNsYXNzIE1vdXNlQnV0dG9uc01hc2sge1xufVxuTW91c2VCdXR0b25zTWFzay5wcmltYXJ5QnV0dG9uID0gMTsgLy8gTGVmdCBidXR0b24uXG5Nb3VzZUJ1dHRvbnNNYXNrLnNlY29uZGFyeUJ1dHRvbiA9IDI7IC8vIFJpZ2h0IGJ1dHRvbi5cbk1vdXNlQnV0dG9uc01hc2suYXV4aWxpYXJ5QnV0dG9uID0gNDsgLy8gV2hlZWwgYnV0dG9uLlxuTW91c2VCdXR0b25zTWFzay5mb3VydGhCdXR0b24gPSA4OyAvLyBCcm93c2VyIEJhY2sgYnV0dG9uLlxuTW91c2VCdXR0b25zTWFzay5maWZ0aEJ1dHRvbiA9IDE2OyAvLyBCcm93c2VyIEZvcndhcmQgYnV0dG9uLlxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TW91c2VCdXR0b25zLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBNb3VzZUJ1dHRvbnNNYXNrLCBNb3VzZUJ1dHRvbiB9IGZyb20gJy4vTW91c2VCdXR0b25zJztcbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIG1vdXNlIGNvbnRyb2xsZXJzLiBTaW5jZSB0aGVyZSBpcyBhIGJ1bmNoIG9mIHNoYXJlZCBiZWhhdmlvdXIgYmV0d2VlbiBsb2NrZWQgYW5kXG4gKiBob3ZlciBtb3VzZSBjb250cm9sbGVycyB0aGlzIGlzIHdoZXJlIHRoYXQgc2hhcmVkIGJlaGF2aW91ciBsaXZlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIE1vdXNlQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3Ioc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIsIHZpZGVvUGxheWVyLCBjb29yZGluYXRlQ29udmVydGVyLCBhY3RpdmVLZXlzKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIgPSBzdHJlYW1NZXNzYWdlQ29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5jb29yZGluYXRlQ29udmVydGVyID0gY29vcmRpbmF0ZUNvbnZlcnRlcjtcbiAgICAgICAgdGhpcy52aWRlb1BsYXllciA9IHZpZGVvUGxheWVyO1xuICAgICAgICB0aGlzLmFjdGl2ZUtleXMgPSBhY3RpdmVLZXlzO1xuICAgICAgICB0aGlzLm9uRW50ZXJMaXN0ZW5lciA9IHRoaXMub25Nb3VzZUVudGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25MZWF2ZUxpc3RlbmVyID0gdGhpcy5vbk1vdXNlTGVhdmUuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJNb3VzZUVudGVyQW5kTGVhdmVFdmVudHMoKTtcbiAgICB9XG4gICAgdW5yZWdpc3RlcigpIHtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyTW91c2VFbnRlckFuZExlYXZlRXZlbnRzKCk7XG4gICAgfVxuICAgIHJlZ2lzdGVyTW91c2VFbnRlckFuZExlYXZlRXZlbnRzKCkge1xuICAgICAgICBjb25zdCB2aWRlb0VsZW1lbnRQYXJlbnQgPSB0aGlzLnZpZGVvUGxheWVyLmdldFZpZGVvUGFyZW50RWxlbWVudCgpO1xuICAgICAgICB2aWRlb0VsZW1lbnRQYXJlbnQgPT09IG51bGwgfHwgdmlkZW9FbGVtZW50UGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25FbnRlckxpc3RlbmVyKTtcbiAgICAgICAgdmlkZW9FbGVtZW50UGFyZW50ID09PSBudWxsIHx8IHZpZGVvRWxlbWVudFBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTGVhdmVMaXN0ZW5lcik7XG4gICAgfVxuICAgIHVucmVnaXN0ZXJNb3VzZUVudGVyQW5kTGVhdmVFdmVudHMoKSB7XG4gICAgICAgIGNvbnN0IHZpZGVvRWxlbWVudFBhcmVudCA9IHRoaXMudmlkZW9QbGF5ZXIuZ2V0VmlkZW9QYXJlbnRFbGVtZW50KCk7XG4gICAgICAgIHZpZGVvRWxlbWVudFBhcmVudCA9PT0gbnVsbCB8fCB2aWRlb0VsZW1lbnRQYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZGVvRWxlbWVudFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbkVudGVyTGlzdGVuZXIpO1xuICAgICAgICB2aWRlb0VsZW1lbnRQYXJlbnQgPT09IG51bGwgfHwgdmlkZW9FbGVtZW50UGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25MZWF2ZUxpc3RlbmVyKTtcbiAgICB9XG4gICAgb25Nb3VzZUVudGVyKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdNb3VzZUVudGVyJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYSgpO1xuICAgICAgICB0aGlzLnByZXNzTW91c2VCdXR0b25zKGV2ZW50LmJ1dHRvbnMsIGV2ZW50LngsIGV2ZW50LnkpO1xuICAgIH1cbiAgICBvbk1vdXNlTGVhdmUoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlTGVhdmUnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKCk7XG4gICAgICAgIHRoaXMucmVsZWFzZU1vdXNlQnV0dG9ucyhldmVudC5idXR0b25zLCBldmVudC54LCBldmVudC55KTtcbiAgICB9XG4gICAgcmVsZWFzZU1vdXNlQnV0dG9ucyhidXR0b25zLCBYLCBZKSB7XG4gICAgICAgIGNvbnN0IGNvb3JkID0gdGhpcy5jb29yZGluYXRlQ29udmVydGVyLnRyYW5zbGF0ZVVuc2lnbmVkKFgsIFkpO1xuICAgICAgICBpZiAoYnV0dG9ucyAmIE1vdXNlQnV0dG9uc01hc2sucHJpbWFyeUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5zZW5kTW91c2VVcChNb3VzZUJ1dHRvbi5tYWluQnV0dG9uLCBjb29yZC54LCBjb29yZC55KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9ucyAmIE1vdXNlQnV0dG9uc01hc2suc2Vjb25kYXJ5QnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRNb3VzZVVwKE1vdXNlQnV0dG9uLnNlY29uZGFyeUJ1dHRvbiwgY29vcmQueCwgY29vcmQueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbnMgJiBNb3VzZUJ1dHRvbnNNYXNrLmF1eGlsaWFyeUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5zZW5kTW91c2VVcChNb3VzZUJ1dHRvbi5hdXhpbGlhcnlCdXR0b24sIGNvb3JkLngsIGNvb3JkLnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25zICYgTW91c2VCdXR0b25zTWFzay5mb3VydGhCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1vdXNlVXAoTW91c2VCdXR0b24uZm91cnRoQnV0dG9uLCBjb29yZC54LCBjb29yZC55KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9ucyAmIE1vdXNlQnV0dG9uc01hc2suZmlmdGhCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1vdXNlVXAoTW91c2VCdXR0b24uZmlmdGhCdXR0b24sIGNvb3JkLngsIGNvb3JkLnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXNzTW91c2VCdXR0b25zKGJ1dHRvbnMsIFgsIFkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoWCwgWSk7XG4gICAgICAgIGlmIChidXR0b25zICYgTW91c2VCdXR0b25zTWFzay5wcmltYXJ5QnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRNb3VzZURvd24oTW91c2VCdXR0b24ubWFpbkJ1dHRvbiwgY29vcmQueCwgY29vcmQueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbnMgJiBNb3VzZUJ1dHRvbnNNYXNrLnNlY29uZGFyeUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5zZW5kTW91c2VEb3duKE1vdXNlQnV0dG9uLnNlY29uZGFyeUJ1dHRvbiwgY29vcmQueCwgY29vcmQueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbnMgJiBNb3VzZUJ1dHRvbnNNYXNrLmF1eGlsaWFyeUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5zZW5kTW91c2VEb3duKE1vdXNlQnV0dG9uLmF1eGlsaWFyeUJ1dHRvbiwgY29vcmQueCwgY29vcmQueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbnMgJiBNb3VzZUJ1dHRvbnNNYXNrLmZvdXJ0aEJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5zZW5kTW91c2VEb3duKE1vdXNlQnV0dG9uLmZvdXJ0aEJ1dHRvbiwgY29vcmQueCwgY29vcmQueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbnMgJiBNb3VzZUJ1dHRvbnNNYXNrLmZpZnRoQnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRNb3VzZURvd24oTW91c2VCdXR0b24uZmlmdGhCdXR0b24sIGNvb3JkLngsIGNvb3JkLnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRNb3VzZURvd24oYnV0dG9uLCBYLCBZKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdNb3VzZURvd24nKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKFtidXR0b24sIFgsIFldKTtcbiAgICB9XG4gICAgc2VuZE1vdXNlVXAoYnV0dG9uLCBYLCBZKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoWCwgWSk7XG4gICAgICAgIChfYSA9IHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VVcCcpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoW2J1dHRvbiwgY29vcmQueCwgY29vcmQueV0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1vdXNlQ29udHJvbGxlci5qcy5tYXAiLCJpbXBvcnQgeyBNb3VzZUNvbnRyb2xsZXIgfSBmcm9tICcuL01vdXNlQ29udHJvbGxlcic7XG4vKipcbiAqIEEgbW91c2UgY29udHJvbGxlciB0aGF0IGFsbG93cyB0aGUgbW91c2UgdG8gZnJlZWx5IGZsb2F0IG92ZXIgdGhlIHZpZGVvIGRvY3VtZW50LlxuICovXG5leHBvcnQgY2xhc3MgTW91c2VDb250cm9sbGVySG92ZXJpbmcgZXh0ZW5kcyBNb3VzZUNvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLCB2aWRlb1BsYXllciwgY29vcmRpbmF0ZUNvbnZlcnRlciwgYWN0aXZlS2V5cykge1xuICAgICAgICBzdXBlcihzdHJlYW1NZXNzYWdlQ29udHJvbGxlciwgdmlkZW9QbGF5ZXIsIGNvb3JkaW5hdGVDb252ZXJ0ZXIsIGFjdGl2ZUtleXMpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudCA9IHZpZGVvUGxheWVyLmdldFZpZGVvUGFyZW50RWxlbWVudCgpO1xuICAgICAgICB0aGlzLm9uTW91c2VVcExpc3RlbmVyID0gdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bkxpc3RlbmVyID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VEYmxDbGlja0xpc3RlbmVyID0gdGhpcy5vbk1vdXNlRGJsQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlV2hlZWxMaXN0ZW5lciA9IHRoaXMub25Nb3VzZVdoZWVsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmVMaXN0ZW5lciA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkNvbnRleHRNZW51TGlzdGVuZXIgPSB0aGlzLm9uQ29udGV4dE1lbnUuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoKSB7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyKCk7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd25MaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLm9uQ29udGV4dE1lbnVMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbk1vdXNlV2hlZWxMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5vbk1vdXNlRGJsQ2xpY2tMaXN0ZW5lcik7XG4gICAgfVxuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd25MaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLm9uQ29udGV4dE1lbnVMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbk1vdXNlV2hlZWxMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5vbk1vdXNlRGJsQ2xpY2tMaXN0ZW5lcik7XG4gICAgICAgIHN1cGVyLnVucmVnaXN0ZXIoKTtcbiAgICB9XG4gICAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VEb3duJykoW2V2ZW50LmJ1dHRvbiwgY29vcmQueCwgY29vcmQueV0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VVcCcpKFtldmVudC5idXR0b24sIGNvb3JkLngsIGNvb3JkLnldKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgb25Db250ZXh0TWVudShldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb29yZCA9IHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlci50cmFuc2xhdGVVbnNpZ25lZChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlU2lnbmVkKGV2ZW50Lm1vdmVtZW50WCwgZXZlbnQubW92ZW1lbnRZKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdNb3VzZU1vdmUnKShbXG4gICAgICAgICAgICBjb29yZC54LFxuICAgICAgICAgICAgY29vcmQueSxcbiAgICAgICAgICAgIGRlbHRhLngsXG4gICAgICAgICAgICBkZWx0YS55XG4gICAgICAgIF0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBvbk1vdXNlV2hlZWwoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VXaGVlbCcpKFtcbiAgICAgICAgICAgIGV2ZW50LndoZWVsRGVsdGEsXG4gICAgICAgICAgICBjb29yZC54LFxuICAgICAgICAgICAgY29vcmQueVxuICAgICAgICBdKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgb25Nb3VzZURibENsaWNrKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvb3JkID0gdGhpcy5jb29yZGluYXRlQ29udmVydGVyLnRyYW5zbGF0ZVVuc2lnbmVkKGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlRG91YmxlJykoW2V2ZW50LmJ1dHRvbiwgY29vcmQueCwgY29vcmQueV0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1vdXNlQ29udHJvbGxlckhvdmVyaW5nLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG5pbXBvcnQgeyBNb3VzZUNvbnRyb2xsZXIgfSBmcm9tICcuL01vdXNlQ29udHJvbGxlcic7XG4vKipcbiAqIEEgbW91c2UgY29udHJvbGxlciB0aGF0IGxvY2tzIHRoZSBtb3VzZSB0byB0aGUgdmlkZW8gZG9jdW1lbnQgYW5kIHByZXZlbnRzIGl0IGZyb20gbGVhdmluZyB0aGUgd2luZG93XG4gKi9cbmV4cG9ydCBjbGFzcyBNb3VzZUNvbnRyb2xsZXJMb2NrZWQgZXh0ZW5kcyBNb3VzZUNvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLCB2aWRlb1BsYXllciwgY29vcmRpbmF0ZUNvbnZlcnRlciwgYWN0aXZlS2V5cykge1xuICAgICAgICBzdXBlcihzdHJlYW1NZXNzYWdlQ29udHJvbGxlciwgdmlkZW9QbGF5ZXIsIGNvb3JkaW5hdGVDb252ZXJ0ZXIsIGFjdGl2ZUtleXMpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudCA9IHZpZGVvUGxheWVyLmdldFZpZGVvUGFyZW50RWxlbWVudCgpO1xuICAgICAgICB0aGlzLnggPSB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMueSA9IHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCAvIDI7XG4gICAgICAgIHRoaXMubm9ybWFsaXplZENvb3JkID0gdGhpcy5jb29yZGluYXRlQ29udmVydGVyLnRyYW5zbGF0ZVVuc2lnbmVkKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgdGhpcy5vblJlcXVlc3RMb2NrTGlzdGVuZXIgPSB0aGlzLm9uUmVxdWVzdExvY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkxvY2tTdGF0ZUNoYW5nZUxpc3RlbmVyID0gdGhpcy5vbkxvY2tTdGF0ZUNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VVcExpc3RlbmVyID0gdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bkxpc3RlbmVyID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VEYmxDbGlja0xpc3RlbmVyID0gdGhpcy5vbk1vdXNlRGJsQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlV2hlZWxMaXN0ZW5lciA9IHRoaXMub25Nb3VzZVdoZWVsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmVMaXN0ZW5lciA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoKSB7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyKCk7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlcXVlc3RQb2ludGVyTG9jayA9XG4gICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5yZXF1ZXN0UG9pbnRlckxvY2sgfHwgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQubW96UmVxdWVzdFBvaW50ZXJMb2NrO1xuICAgICAgICBkb2N1bWVudC5leGl0UG9pbnRlckxvY2sgPSBkb2N1bWVudC5leGl0UG9pbnRlckxvY2sgfHwgZG9jdW1lbnQubW96RXhpdFBvaW50ZXJMb2NrO1xuICAgICAgICBpZiAodGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVxdWVzdFBvaW50ZXJMb2NrKSB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25SZXF1ZXN0TG9ja0xpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybG9ja2NoYW5nZScsIHRoaXMub25Mb2NrU3RhdGVDaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21venBvaW50ZXJsb2NrY2hhbmdlJywgdGhpcy5vbkxvY2tTdGF0ZUNoYW5nZUxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bkxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMub25Nb3VzZVdoZWVsTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMub25Nb3VzZURibENsaWNrTGlzdGVuZXIpO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBjb25zdCBwb2ludGVyTG9ja0VsZW1lbnQgPSBkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQgfHwgZG9jdW1lbnQubW96UG9pbnRlckxvY2tFbGVtZW50O1xuICAgICAgICBpZiAoZG9jdW1lbnQuZXhpdFBvaW50ZXJMb2NrICYmIHBvaW50ZXJMb2NrRWxlbWVudCA9PT0gdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4aXRQb2ludGVyTG9jaygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vblJlcXVlc3RMb2NrTGlzdGVuZXIpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybG9ja2NoYW5nZScsIHRoaXMub25Mb2NrU3RhdGVDaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21venBvaW50ZXJsb2NrY2hhbmdlJywgdGhpcy5vbkxvY2tTdGF0ZUNoYW5nZUxpc3RlbmVyKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZUxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bkxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMub25Nb3VzZVdoZWVsTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMub25Nb3VzZURibENsaWNrTGlzdGVuZXIpO1xuICAgICAgICBzdXBlci51bnJlZ2lzdGVyKCk7XG4gICAgfVxuICAgIG9uUmVxdWVzdExvY2soKSB7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlcXVlc3RQb2ludGVyTG9jaygpO1xuICAgIH1cbiAgICBvbkxvY2tTdGF0ZUNoYW5nZSgpIHtcbiAgICAgICAgY29uc3QgcG9pbnRlckxvY2tFbGVtZW50ID0gZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50IHx8IGRvY3VtZW50Lm1velBvaW50ZXJMb2NrRWxlbWVudDtcbiAgICAgICAgaWYgKHBvaW50ZXJMb2NrRWxlbWVudCA9PT0gdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQpIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdQb2ludGVyIGxvY2tlZCcpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdUaGUgcG9pbnRlciBsb2NrIHN0YXR1cyBpcyBub3cgdW5sb2NrZWQnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICAvLyBJZiBtb3VzZSBsb3NlcyBmb2N1cywgc2VuZCBhIGtleSB1cCBmb3IgYWxsIG9mIHRoZSBjdXJyZW50bHkgaGVsZC1kb3duIGtleXNcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGFzIHdoZW4gdGhlIG1vdXNlIGxvc2VzIGZvY3VzLCB0aGUgd2luZG93cyBzdG9wcyBsaXN0ZW5pbmcgZm9yIGV2ZW50cyBhbmQgYXMgc3VjaFxuICAgICAgICAgICAgLy8gdGhlIGtleXVwIGxpc3RlbmVyIHdvbid0IGdldCBmaXJlZFxuICAgICAgICAgICAgY29uc3QgYWN0aXZlS2V5cyA9IHRoaXMuYWN0aXZlS2V5cy5nZXRBY3RpdmVLZXlzKCk7XG4gICAgICAgICAgICBhY3RpdmVLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnS2V5VXAnKShba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlRG93bicpKFtcbiAgICAgICAgICAgIGV2ZW50LmJ1dHRvbixcbiAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgc3RvcmUgdmFsdWUgb2YgdGhpcy5jb29yZCBhcyBvcHBvc2VkIHRvIHRoZSBtb3VzZUV2ZW50LngveSBhcyB0aGUgbW91c2VFdmVudCBsb2NhdGlvblxuICAgICAgICAgICAgLy8gdXNlcyB0aGUgc3lzdGVtIGN1cnNvciBsb2NhdGlvbiB3aGljaCBoYXNuJ3QgbW92ZWRcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZENvb3JkLngsXG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWRDb29yZC55XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdNb3VzZVVwJykoW1xuICAgICAgICAgICAgZXZlbnQuYnV0dG9uLFxuICAgICAgICAgICAgLy8gV2UgdXNlIHRoZSBzdG9yZSB2YWx1ZSBvZiB0aGlzLmNvb3JkIGFzIG9wcG9zZWQgdG8gdGhlIG1vdXNlRXZlbnQueC95IGFzIHRoZSBtb3VzZUV2ZW50IGxvY2F0aW9uXG4gICAgICAgICAgICAvLyB1c2VzIHRoZSBzeXN0ZW0gY3Vyc29yIGxvY2F0aW9uIHdoaWNoIGhhc24ndCBtb3ZlZFxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkQ29vcmQueCxcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZENvb3JkLnlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0eWxlV2lkdGggPSB0aGlzLnZpZGVvUGxheWVyLmdldFZpZGVvUGFyZW50RWxlbWVudCgpLmNsaWVudFdpZHRoO1xuICAgICAgICBjb25zdCBzdHlsZUhlaWdodCA9IHRoaXMudmlkZW9QbGF5ZXIuZ2V0VmlkZW9QYXJlbnRFbGVtZW50KCkuY2xpZW50SGVpZ2h0O1xuICAgICAgICB0aGlzLnggKz0gZXZlbnQubW92ZW1lbnRYO1xuICAgICAgICB0aGlzLnkgKz0gZXZlbnQubW92ZW1lbnRZO1xuICAgICAgICB3aGlsZSAodGhpcy54ID4gc3R5bGVXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy54IC09IHN0eWxlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMueSA+IHN0eWxlSGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnkgLT0gc3R5bGVIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMueCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMueCArPSBzdHlsZVdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnkgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnkgKz0gc3R5bGVIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3JtYWxpemVkQ29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlci50cmFuc2xhdGVTaWduZWQoZXZlbnQubW92ZW1lbnRYLCBldmVudC5tb3ZlbWVudFkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlTW92ZScpKFtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZENvb3JkLngsXG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWRDb29yZC55LFxuICAgICAgICAgICAgZGVsdGEueCxcbiAgICAgICAgICAgIGRlbHRhLnlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIG9uTW91c2VXaGVlbChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlV2hlZWwnKShbXG4gICAgICAgICAgICBldmVudC53aGVlbERlbHRhLFxuICAgICAgICAgICAgLy8gV2UgdXNlIHRoZSBzdG9yZSB2YWx1ZSBvZiB0aGlzLmNvb3JkIGFzIG9wcG9zZWQgdG8gdGhlIG1vdXNlRXZlbnQueC95IGFzIHRoZSBtb3VzZUV2ZW50IGxvY2F0aW9uXG4gICAgICAgICAgICAvLyB1c2VzIHRoZSBzeXN0ZW0gY3Vyc29yIGxvY2F0aW9uIHdoaWNoIGhhc24ndCBtb3ZlZFxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkQ29vcmQueCxcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZENvb3JkLnlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIG9uTW91c2VEYmxDbGljayhldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlRG91YmxlJykoW1xuICAgICAgICAgICAgZXZlbnQuYnV0dG9uLFxuICAgICAgICAgICAgLy8gV2UgdXNlIHRoZSBzdG9yZSB2YWx1ZSBvZiB0aGlzLmNvb3JkIGFzIG9wcG9zZWQgdG8gdGhlIG1vdXNlRXZlbnQueC95IGFzIHRoZSBtb3VzZUV2ZW50IGxvY2F0aW9uXG4gICAgICAgICAgICAvLyB1c2VzIHRoZSBzeXN0ZW0gY3Vyc29yIGxvY2F0aW9uIHdoaWNoIGhhc24ndCBtb3ZlZFxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkQ29vcmQueCxcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZENvb3JkLnlcbiAgICAgICAgXSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TW91c2VDb250cm9sbGVyTG9ja2VkLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIFJlZ2lzdGVycyB0aGUgU3BlY2lhbCBLZXkgY29kZXNcbiAqICBNdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIEphdmFTY3JpcHRLZXlDb2RlVG9GS2V5IEMrKyBhcnJheS5cbiAqIFRoZSBpbmRleCBvZiB0aGUgZW50cnkgaW4gdGhlIGFycmF5IGlzIHRoZSBzcGVjaWFsIGtleSBjb2RlIGdpdmVuIGJlbG93LlxuICovXG5leHBvcnQgY2xhc3MgU3BlY2lhbEtleUNvZGVzIHtcbn1cblNwZWNpYWxLZXlDb2Rlcy5iYWNrU3BhY2UgPSA4O1xuU3BlY2lhbEtleUNvZGVzLnNoaWZ0ID0gMTY7XG5TcGVjaWFsS2V5Q29kZXMuY29udHJvbCA9IDE3O1xuU3BlY2lhbEtleUNvZGVzLmFsdCA9IDE4O1xuU3BlY2lhbEtleUNvZGVzLnJpZ2h0U2hpZnQgPSAyNTM7XG5TcGVjaWFsS2V5Q29kZXMucmlnaHRDb250cm9sID0gMjU0O1xuU3BlY2lhbEtleUNvZGVzLnJpZ2h0QWx0ID0gMjU1O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3BlY2lhbEtleUNvZGVzLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG4vKipcbiAqIFRoZSBiYXNpYyB0b3VjaCBjb250cm9sbGVyIHRoYXQgaGFuZGxlcyB0aGUgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRvdWNoQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3Ioc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIsIHZpZGVvUGxheWVyLCBjb29yZGluYXRlQ29udmVydGVyKSB7XG4gICAgICAgIHRoaXMuZmluZ2VycyA9IFs5LCA4LCA3LCA2LCA1LCA0LCAzLCAyLCAxLCAwXTtcbiAgICAgICAgdGhpcy5maW5nZXJJZHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubWF4Qnl0ZVZhbHVlID0gMjU1O1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyID0gc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMudmlkZW9QbGF5ZXIgPSB2aWRlb1BsYXllcjtcbiAgICAgICAgdGhpcy5jb29yZGluYXRlQ29udmVydGVyID0gY29vcmRpbmF0ZUNvbnZlcnRlcjtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQgPSB2aWRlb1BsYXllci5nZXRWaWRlb0VsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5vblRvdWNoU3RhcnRMaXN0ZW5lciA9IHRoaXMub25Ub3VjaFN0YXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Ub3VjaEVuZExpc3RlbmVyID0gdGhpcy5vblRvdWNoRW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Ub3VjaE1vdmVMaXN0ZW5lciA9IHRoaXMub25Ub3VjaE1vdmUuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoKSB7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmRMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmVMaXN0ZW5lcik7XG4gICAgfVxuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmRMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmVMaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlbWVtYmVyVG91Y2godG91Y2gpIHtcbiAgICAgICAgY29uc3QgZmluZ2VyID0gdGhpcy5maW5nZXJzLnBvcCgpO1xuICAgICAgICBpZiAoZmluZ2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdleGhhdXN0ZWQgdG91Y2ggaWRlbnRpZmllcnMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmdlcklkcy5zZXQodG91Y2guaWRlbnRpZmllciwgZmluZ2VyKTtcbiAgICB9XG4gICAgZm9yZ2V0VG91Y2godG91Y2gpIHtcbiAgICAgICAgdGhpcy5maW5nZXJzLnB1c2godGhpcy5maW5nZXJJZHMuZ2V0KHRvdWNoLmlkZW50aWZpZXIpKTtcbiAgICAgICAgLy8gU29ydCBhcnJheSBiYWNrIGludG8gZGVzY2VuZGluZyBvcmRlci4gVGhpcyBtZWFucyBpZiBmaW5nZXIgJzEnIHdlcmUgdG8gbGlmdCBhZnRlciBmaW5nZXIgJzAnLCB3ZSB3b3VsZCBlbnN1cmUgdGhhdCAwIHdpbGwgYmUgdGhlIGZpcnN0IGluZGV4IHRvIHBvcFxuICAgICAgICB0aGlzLmZpbmdlcnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIgLSBhO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5maW5nZXJJZHMuZGVsZXRlKHRvdWNoLmlkZW50aWZpZXIpO1xuICAgIH1cbiAgICBvblRvdWNoU3RhcnQodG91Y2hFdmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIHRoaXMucmVtZW1iZXJUb3VjaCh0b3VjaEV2ZW50LmNoYW5nZWRUb3VjaGVzW3RdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXRUb3VjaERhdGEoJ1RvdWNoU3RhcnQnLCB0b3VjaEV2ZW50LmNoYW5nZWRUb3VjaGVzKTtcbiAgICAgICAgdG91Y2hFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBvblRvdWNoRW5kKHRvdWNoRXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0VG91Y2hEYXRhKCdUb3VjaEVuZCcsIHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXMpO1xuICAgICAgICAvLyBSZS1jeWNsZSB1bmlxdWUgaWRlbnRpZmllcnMgcHJldmlvdXNseSBhc3NpZ25lZCB0byBlYWNoIHRvdWNoLlxuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIHRoaXMuZm9yZ2V0VG91Y2godG91Y2hFdmVudC5jaGFuZ2VkVG91Y2hlc1t0XSk7XG4gICAgICAgIH1cbiAgICAgICAgdG91Y2hFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBvblRvdWNoTW92ZSh0b3VjaEV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdFRvdWNoRGF0YSgnVG91Y2hNb3ZlJywgdG91Y2hFdmVudC50b3VjaGVzKTtcbiAgICAgICAgdG91Y2hFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBlbWl0VG91Y2hEYXRhKHR5cGUsIHRvdWNoZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy52aWRlb1BsYXllci5nZXRWaWRlb1BhcmVudEVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgdG9TdHJlYW1lckhhbmRsZXJzID0gdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnM7XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdG91Y2hlcy5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgY29uc3QgbnVtVG91Y2hlcyA9IDE7IC8vIHRoZSBudW1iZXIgb2YgdG91Y2hlcyB0byBiZSBzZW50IHRoaXMgbWVzc2FnZVxuICAgICAgICAgICAgY29uc3QgdG91Y2ggPSB0b3VjaGVzW3RdO1xuICAgICAgICAgICAgY29uc3QgeCA9IHRvdWNoLmNsaWVudFggLSBvZmZzZXQubGVmdDtcbiAgICAgICAgICAgIGNvbnN0IHkgPSB0b3VjaC5jbGllbnRZIC0gb2Zmc2V0LnRvcDtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKGBGJHt0aGlzLmZpbmdlcklkcy5nZXQodG91Y2guaWRlbnRpZmllcil9PSgke3h9LCAke3l9KWApO1xuICAgICAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoeCwgeSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdUb3VjaFN0YXJ0JzpcbiAgICAgICAgICAgICAgICAgICAgdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnVG91Y2hTdGFydCcpKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVRvdWNoZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmQueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZ2VySWRzLmdldCh0b3VjaC5pZGVudGlmaWVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF4Qnl0ZVZhbHVlICogKHRvdWNoLmZvcmNlID4gMCA/IHRvdWNoLmZvcmNlIDogMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZC5pblJhbmdlID8gMSA6IDBcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RvdWNoRW5kJzpcbiAgICAgICAgICAgICAgICAgICAgdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnVG91Y2hFbmQnKShbXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1Ub3VjaGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmdlcklkcy5nZXQodG91Y2guaWRlbnRpZmllciksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1heEJ5dGVWYWx1ZSAqIHRvdWNoLmZvcmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmQuaW5SYW5nZSA/IDEgOiAwXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUb3VjaE1vdmUnOlxuICAgICAgICAgICAgICAgICAgICB0b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdUb3VjaE1vdmUnKShbXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1Ub3VjaGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmdlcklkcy5nZXQodG91Y2guaWRlbnRpZmllciksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1heEJ5dGVWYWx1ZSAqICh0b3VjaC5mb3JjZSA+IDAgPyB0b3VjaC5mb3JjZSA6IDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmQuaW5SYW5nZSA/IDEgOiAwXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRvdWNoQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTW91c2VCdXR0b24gfSBmcm9tICcuL01vdXNlQnV0dG9ucyc7XG4vKipcbiAqIEFsbG93cyBmb3IgdGhlIHVzYWdlIG9mIGZha2UgdG91Y2ggZXZlbnRzXG4gKi9cbmV4cG9ydCBjbGFzcyBUb3VjaENvbnRyb2xsZXJGYWtlIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJlYW1NZXNzYWdlQ29udHJvbGxlciwgdmlkZW9QbGF5ZXIsIGNvb3JkaW5hdGVDb252ZXJ0ZXIpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlciA9IHN0cmVhbU1lc3NhZ2VDb250cm9sbGVyO1xuICAgICAgICB0aGlzLnZpZGVvUGxheWVyID0gdmlkZW9QbGF5ZXI7XG4gICAgICAgIHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlciA9IGNvb3JkaW5hdGVDb252ZXJ0ZXI7XG4gICAgICAgIHRoaXMub25Ub3VjaFN0YXJ0TGlzdGVuZXIgPSB0aGlzLm9uVG91Y2hTdGFydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uVG91Y2hFbmRMaXN0ZW5lciA9IHRoaXMub25Ub3VjaEVuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uVG91Y2hNb3ZlTGlzdGVuZXIgPSB0aGlzLm9uVG91Y2hNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50Q2xpZW50UmVjdCA9IHRoaXMudmlkZW9QbGF5ZXIuZ2V0VmlkZW9QYXJlbnRFbGVtZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICAgIHJlZ2lzdGVyKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnRMaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kTGlzdGVuZXIpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlTGlzdGVuZXIpO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnRMaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kTGlzdGVuZXIpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlTGlzdGVuZXIpO1xuICAgIH1cbiAgICBvblRvdWNoU3RhcnQodG91Y2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpIHx8IHRvdWNoLnRhcmdldCAhPT0gdGhpcy52aWRlb1BsYXllci5nZXRWaWRlb0VsZW1lbnQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZha2VUb3VjaEZpbmdlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdF90b3VjaCA9IHRvdWNoLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgdGhpcy5mYWtlVG91Y2hGaW5nZXIgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGZpcnN0X3RvdWNoLmlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgeDogZmlyc3RfdG91Y2guY2xpZW50WCAtIHRoaXMudmlkZW9FbGVtZW50UGFyZW50Q2xpZW50UmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgIHk6IGZpcnN0X3RvdWNoLmNsaWVudFkgLSB0aGlzLnZpZGVvRWxlbWVudFBhcmVudENsaWVudFJlY3QudG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50UGFyZW50ID0gdGhpcy52aWRlb1BsYXllci5nZXRWaWRlb1BhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlRXZlbnQgPSBuZXcgTW91c2VFdmVudCgnbW91c2VlbnRlcicsIGZpcnN0X3RvdWNoKTtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudFBhcmVudC5kaXNwYXRjaEV2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQodGhpcy5mYWtlVG91Y2hGaW5nZXIueCwgdGhpcy5mYWtlVG91Y2hGaW5nZXIueSk7XG4gICAgICAgICAgICBjb25zdCB0b1N0cmVhbWVySGFuZGxlcnMgPSB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycztcbiAgICAgICAgICAgIHRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlRG93bicpKFtNb3VzZUJ1dHRvbi5tYWluQnV0dG9uLCBjb29yZC54LCBjb29yZC55XSk7XG4gICAgICAgIH1cbiAgICAgICAgdG91Y2gucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgb25Ub3VjaEVuZCh0b3VjaEV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSB8fCB0aGlzLmZha2VUb3VjaEZpbmdlciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50UGFyZW50ID0gdGhpcy52aWRlb1BsYXllci5nZXRWaWRlb1BhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgY29uc3QgdG9TdHJlYW1lckhhbmRsZXJzID0gdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnM7XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdG91Y2hFdmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgY29uc3QgdG91Y2ggPSB0b3VjaEV2ZW50LmNoYW5nZWRUb3VjaGVzW3RdO1xuICAgICAgICAgICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMuZmFrZVRvdWNoRmluZ2VyLmlkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHRvdWNoLmNsaWVudFggLSB0aGlzLnZpZGVvRWxlbWVudFBhcmVudENsaWVudFJlY3QubGVmdDtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gdG91Y2guY2xpZW50WSAtIHRoaXMudmlkZW9FbGVtZW50UGFyZW50Q2xpZW50UmVjdC50b3A7XG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoeCwgeSk7XG4gICAgICAgICAgICAgICAgdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VVcCcpKFtNb3VzZUJ1dHRvbi5tYWluQnV0dG9uLCBjb29yZC54LCBjb29yZC55XSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbW91c2VFdmVudCA9IG5ldyBNb3VzZUV2ZW50KCdtb3VzZWxlYXZlJywgdG91Y2gpO1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudFBhcmVudC5kaXNwYXRjaEV2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmFrZVRvdWNoRmluZ2VyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b3VjaEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIG9uVG91Y2hNb3ZlKHRvdWNoRXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpIHx8IHRoaXMuZmFrZVRvdWNoRmluZ2VyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b1N0cmVhbWVySGFuZGxlcnMgPSB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycztcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0b3VjaEV2ZW50LnRvdWNoZXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRvdWNoID0gdG91Y2hFdmVudC50b3VjaGVzW3RdO1xuICAgICAgICAgICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMuZmFrZVRvdWNoRmluZ2VyLmlkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHRvdWNoLmNsaWVudFggLSB0aGlzLnZpZGVvRWxlbWVudFBhcmVudENsaWVudFJlY3QubGVmdDtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gdG91Y2guY2xpZW50WSAtIHRoaXMudmlkZW9FbGVtZW50UGFyZW50Q2xpZW50UmVjdC50b3A7XG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoeCwgeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlU2lnbmVkKHggLSB0aGlzLmZha2VUb3VjaEZpbmdlci54LCB5IC0gdGhpcy5mYWtlVG91Y2hGaW5nZXIueSk7XG4gICAgICAgICAgICAgICAgdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VNb3ZlJykoW2Nvb3JkLngsIGNvb3JkLnksIGRlbHRhLngsIGRlbHRhLnldKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZha2VUb3VjaEZpbmdlci54ID0geDtcbiAgICAgICAgICAgICAgICB0aGlzLmZha2VUb3VjaEZpbmdlci55ID0geTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b3VjaEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG91Y2hDb250cm9sbGVyRmFrZS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgZGVlcENvcHlHYW1lcGFkIH0gZnJvbSAnLi9HYW1lcGFkVHlwZXMnO1xuLyoqXG4gKiBUaGUgY2xhc3MgdGhhdCBoYW5kbGVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIFhSIGdhbWVwYWRzIGFuZCBjb250cm9sbGVycy5cbiAqL1xuZXhwb3J0IGNsYXNzIFhSR2FtZXBhZENvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB0b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlciAtIFN0cmVhbSBtZXNzYWdlIGluc3RhbmNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlciA9IHRvU3RyZWFtZXJNZXNzYWdlc1Byb3ZpZGVyO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXJzID0gW107XG4gICAgfVxuICAgIHVwZGF0ZVN0YXR1cyhzb3VyY2UsIGZyYW1lLCByZWZTcGFjZSkge1xuICAgICAgICBpZiAoc291cmNlLmdhbWVwYWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGdhbWVwYWRQb3NlID0gZnJhbWUuZ2V0UG9zZShzb3VyY2UuZ3JpcFNwYWNlLCByZWZTcGFjZSk7XG4gICAgICAgICAgICBpZiAoIWdhbWVwYWRQb3NlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN5c3RlbSA9IDA7XG4gICAgICAgICAgICBpZiAoc291cmNlLnByb2ZpbGVzLmluY2x1ZGVzKCdodGMtdml2ZScpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZS5wcm9maWxlcy5pbmNsdWRlcygnb2N1bHVzLXRvdWNoJykpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETyAod2lsbGlhbS5iZWxjaGVyKTogQWRkIG90aGVyIHByb2ZpbGVzIChRdWVzdCwgTWljcm9zb2Z0IE1peGVkIFJlYWxpdHksIGV0YylcbiAgICAgICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnWFJTeXN0ZW0nKShbc3lzdGVtXSk7XG4gICAgICAgICAgICAvLyBEZWZhdWx0OiBBbnlIYW5kICgyKVxuICAgICAgICAgICAgbGV0IGhhbmRlZG5lc3MgPSAyO1xuICAgICAgICAgICAgc3dpdGNoIChzb3VyY2UuaGFuZGVkbmVzcykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICBoYW5kZWRuZXNzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICBoYW5kZWRuZXNzID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZW5kIGNvbnRyb2xsZXIgdHJhbnNmb3JtXG4gICAgICAgICAgICBjb25zdCBtYXRyaXggPSBnYW1lcGFkUG9zZS50cmFuc2Zvcm0ubWF0cml4O1xuICAgICAgICAgICAgY29uc3QgbWF0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBtYXRbaV0gPSBuZXcgRmxvYXQzMkFycmF5KFttYXRyaXhbaV1dKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdYUkNvbnRyb2xsZXJUcmFuc2Zvcm0nKShbXG4gICAgICAgICAgICAgICAgbWF0WzBdLCBtYXRbNF0sIG1hdFs4XSwgbWF0WzEyXSxcbiAgICAgICAgICAgICAgICBtYXRbMV0sIG1hdFs1XSwgbWF0WzldLCBtYXRbMTNdLFxuICAgICAgICAgICAgICAgIG1hdFsyXSwgbWF0WzZdLCBtYXRbMTBdLCBtYXRbMTRdLFxuICAgICAgICAgICAgICAgIG1hdFszXSwgbWF0WzddLCBtYXRbMTFdLCBtYXRbMTVdLFxuICAgICAgICAgICAgICAgIGhhbmRlZG5lc3NcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gSGFuZGxlIGNvbnRyb2xsZXIgYnV0dG9ucyBhbmQgYXhlc1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbGxlcnNbaGFuZGVkbmVzc10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcnNbaGFuZGVkbmVzc10gPSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZTdGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyc1toYW5kZWRuZXNzXS5wcmV2U3RhdGUgPSBkZWVwQ29weUdhbWVwYWQoc291cmNlLmdhbWVwYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyc1toYW5kZWRuZXNzXS5jdXJyZW50U3RhdGUgPSBkZWVwQ29weUdhbWVwYWQoc291cmNlLmdhbWVwYWQpO1xuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY29udHJvbGxlcnNbaGFuZGVkbmVzc107XG4gICAgICAgICAgICBjb25zdCBjdXJyU3RhdGUgPSBjb250cm9sbGVyLmN1cnJlbnRTdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZTdGF0ZSA9IGNvbnRyb2xsZXIucHJldlN0YXRlO1xuICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGJ1dHRvbnNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyclN0YXRlLmJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyQnV0dG9uID0gY3VyclN0YXRlLmJ1dHRvbnNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkJ1dHRvbiA9IHByZXZTdGF0ZS5idXR0b25zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyQnV0dG9uLnByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJlc3NcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNSZXBlYXQgPSBwcmV2QnV0dG9uLnByZXNzZWQgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdYUkJ1dHRvblByZXNzZWQnKShbXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kZWRuZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVwZWF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyckJ1dHRvbi52YWx1ZVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJldkJ1dHRvbi5wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnWFJCdXR0b25SZWxlYXNlZCcpKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRlZG5lc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJCdXR0b24udG91Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0b3VjaGVkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVwZWF0ID0gcHJldkJ1dHRvbi50b3VjaGVkID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnWFJCdXR0b25Ub3VjaGVkJykoW1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGVkbmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1JlcGVhdFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJldkJ1dHRvbi50b3VjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnWFJCdXR0b25Ub3VjaFJlbGVhc2VkJykoW1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGVkbmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBnYW1lcGFkIGF4ZXNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyclN0YXRlLmF4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJBeGlzVmFsdWUgPSBjdXJyU3RhdGUuYXhlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2QXhpc1ZhbHVlID0gcHJldlN0YXRlLmF4ZXNbaV07XG4gICAgICAgICAgICAgICAgLy8gT25seSBzZW5kIGF4aXMgdXBkYXRlIGlmIHRoZXJlIGlzIGEgY2hhbmdlXG4gICAgICAgICAgICAgICAgaWYgKGN1ckF4aXNWYWx1ZSAhPSBwcmV2QXhpc1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnWFJBbmFsb2cnKShbXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kZWRuZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckF4aXNWYWx1ZVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJzW2hhbmRlZG5lc3NdLnByZXZTdGF0ZSA9IGN1cnJTdGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVhSR2FtZXBhZENvbnRyb2xsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IEluYm91bmRWaWRlb1N0YXRzLCBJbmJvdW5kQXVkaW9TdGF0cyB9IGZyb20gJy4vSW5ib3VuZFJUUFN0YXRzJztcbmltcG9ydCB7IERhdGFDaGFubmVsU3RhdHMgfSBmcm9tICcuL0RhdGFDaGFubmVsU3RhdHMnO1xuaW1wb3J0IHsgQ2FuZGlkYXRlU3RhdCB9IGZyb20gJy4vQ2FuZGlkYXRlU3RhdCc7XG5pbXBvcnQgeyBSZW1vdGVPdXRib3VuZFJUUFN0YXRzLCBPdXRib3VuZFJUUFN0YXRzIH0gZnJvbSAnLi9PdXRCb3VuZFJUUFN0YXRzJztcbmltcG9ydCB7IFNlc3Npb25TdGF0cyB9IGZyb20gJy4vU2Vzc2lvblN0YXRzJztcbmltcG9ydCB7IFN0cmVhbVN0YXRzIH0gZnJvbSAnLi9TdHJlYW1TdGF0cyc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG4vKipcbiAqIFRoZSBBZ2dyZWdhdGVkIFN0YXRzIHRoYXQgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIFJUQyBTdGF0cyBSZXBvcnRcbiAqL1xuZXhwb3J0IGNsYXNzIEFnZ3JlZ2F0ZWRTdGF0cyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaW5ib3VuZFZpZGVvU3RhdHMgPSBuZXcgSW5ib3VuZFZpZGVvU3RhdHMoKTtcbiAgICAgICAgdGhpcy5pbmJvdW5kQXVkaW9TdGF0cyA9IG5ldyBJbmJvdW5kQXVkaW9TdGF0cygpO1xuICAgICAgICB0aGlzLmNhbmRpZGF0ZVBhaXJzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuZGF0YWNoYW5uZWxTdGF0cyA9IG5ldyBEYXRhQ2hhbm5lbFN0YXRzKCk7XG4gICAgICAgIHRoaXMubG9jYWxDYW5kaWRhdGVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMucmVtb3RlQ2FuZGlkYXRlcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLm91dGJvdW5kVmlkZW9TdGF0cyA9IG5ldyBPdXRib3VuZFJUUFN0YXRzKCk7XG4gICAgICAgIHRoaXMub3V0Ym91bmRBdWRpb1N0YXRzID0gbmV3IE91dGJvdW5kUlRQU3RhdHMoKTtcbiAgICAgICAgdGhpcy5yZW1vdGVPdXRib3VuZEF1ZGlvU3RhdHMgPSBuZXcgUmVtb3RlT3V0Ym91bmRSVFBTdGF0cygpO1xuICAgICAgICB0aGlzLnJlbW90ZU91dGJvdW5kVmlkZW9TdGF0cyA9IG5ldyBSZW1vdGVPdXRib3VuZFJUUFN0YXRzKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvblN0YXRzID0gbmV3IFNlc3Npb25TdGF0cygpO1xuICAgICAgICB0aGlzLnN0cmVhbVN0YXRzID0gbmV3IFN0cmVhbVN0YXRzKCk7XG4gICAgICAgIHRoaXMuY29kZWNzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHYXRoZXIgYWxsIHRoZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBSVEMgUGVlciBDb25uZWN0aW9uIFJlcG9ydFxuICAgICAqIEBwYXJhbSBydGNTdGF0c1JlcG9ydCAtIFJUQyBTdGF0cyBSZXBvcnRcbiAgICAgKi9cbiAgICBwcm9jZXNzU3RhdHMocnRjU3RhdHNSZXBvcnQpIHtcbiAgICAgICAgdGhpcy5sb2NhbENhbmRpZGF0ZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5yZW1vdGVDYW5kaWRhdGVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuY2FuZGlkYXRlUGFpcnMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgcnRjU3RhdHNSZXBvcnQuZm9yRWFjaCgoc3RhdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHN0YXQudHlwZTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NhbmRpZGF0ZS1wYWlyJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDYW5kaWRhdGVQYWlyKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjZXJ0aWZpY2F0ZSc6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvZGVjJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDb2RlYyhzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF0YS1jaGFubmVsJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW5ib3VuZC1ydHAnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUluYm91bmRSVFAoc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xvY2FsLWNhbmRpZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTG9jYWxDYW5kaWRhdGUoc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21lZGlhLXNvdXJjZSc6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21lZGlhLXBsYXlvdXQnOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdvdXRib3VuZC1ydHAnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUxvY2FsT3V0Ym91bmQoc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BlZXItY29ubmVjdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JlbW90ZS1jYW5kaWRhdGUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlbW90ZUNhbmRpZGF0ZShzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVtb3RlLWluYm91bmQtcnRwJzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVtb3RlLW91dGJvdW5kLXJ0cCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVtb3RlT3V0Ym91bmQoc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYWNrJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFjayhzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndHJhbnNwb3J0JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFuc3BvcnQoc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmVhbSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU3RyZWFtKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoJ3VuaGFuZGxlZCBTdGF0IFR5cGUnKTtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkluZm8oc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBzdHJlYW0gc3RhdHMgZGF0YSBmcm9tIHdlYnJ0Y1xuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXQgLSB0aGUgc3RhdHMgY29taW5nIGluIGZyb20gd2VicnRjXG4gICAgICovXG4gICAgaGFuZGxlU3RyZWFtKHN0YXQpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1TdGF0cyA9IHN0YXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIEljZSBDYW5kaWRhdGUgUGFpciBEYXRhXG4gICAgICogQHBhcmFtIHN0YXQgLSB0aGUgc3RhdHMgY29taW5nIGluIGZyb20gaWNlIGNhbmRpZGF0ZXNcbiAgICAgKi9cbiAgICBoYW5kbGVDYW5kaWRhdGVQYWlyKHN0YXQpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBjYW5kaWRhdGUgcGFpciB0byB0aGUgY2FuZGlkYXRlIHBhaXIgYXJyYXlcbiAgICAgICAgdGhpcy5jYW5kaWRhdGVQYWlycy5wdXNoKHN0YXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBEYXRhIENoYW5uZWwgRGF0YVxuICAgICAqIEBwYXJhbSBzdGF0IC0gdGhlIHN0YXRzIGNvbWluZyBpbiBmcm9tIHRoZSBkYXRhIGNoYW5uZWxcbiAgICAgKi9cbiAgICBoYW5kbGVEYXRhQ2hhbm5lbChzdGF0KSB7XG4gICAgICAgIHRoaXMuZGF0YWNoYW5uZWxTdGF0cy5ieXRlc1JlY2VpdmVkID0gc3RhdC5ieXRlc1JlY2VpdmVkO1xuICAgICAgICB0aGlzLmRhdGFjaGFubmVsU3RhdHMuYnl0ZXNTZW50ID0gc3RhdC5ieXRlc1NlbnQ7XG4gICAgICAgIHRoaXMuZGF0YWNoYW5uZWxTdGF0cy5kYXRhQ2hhbm5lbElkZW50aWZpZXIgPSBzdGF0LmRhdGFDaGFubmVsSWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbFN0YXRzLmlkID0gc3RhdC5pZDtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbFN0YXRzLmxhYmVsID0gc3RhdC5sYWJlbDtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbFN0YXRzLm1lc3NhZ2VzUmVjZWl2ZWQgPSBzdGF0Lm1lc3NhZ2VzUmVjZWl2ZWQ7XG4gICAgICAgIHRoaXMuZGF0YWNoYW5uZWxTdGF0cy5tZXNzYWdlc1NlbnQgPSBzdGF0Lm1lc3NhZ2VzU2VudDtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbFN0YXRzLnByb3RvY29sID0gc3RhdC5wcm90b2NvbDtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbFN0YXRzLnN0YXRlID0gc3RhdC5zdGF0ZTtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbFN0YXRzLnRpbWVzdGFtcCA9IHN0YXQudGltZXN0YW1wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBMb2NhbCBJY2UgQ2FuZGlkYXRlIERhdGFcbiAgICAgKiBAcGFyYW0gc3RhdCAtIGxvY2FsIHN0YXRzXG4gICAgICovXG4gICAgaGFuZGxlTG9jYWxDYW5kaWRhdGUoc3RhdCkge1xuICAgICAgICBjb25zdCBsb2NhbENhbmRpZGF0ZSA9IG5ldyBDYW5kaWRhdGVTdGF0KCk7XG4gICAgICAgIGxvY2FsQ2FuZGlkYXRlLmxhYmVsID0gJ2xvY2FsLWNhbmRpZGF0ZSc7XG4gICAgICAgIGxvY2FsQ2FuZGlkYXRlLmFkZHJlc3MgPSBzdGF0LmFkZHJlc3M7XG4gICAgICAgIGxvY2FsQ2FuZGlkYXRlLnBvcnQgPSBzdGF0LnBvcnQ7XG4gICAgICAgIGxvY2FsQ2FuZGlkYXRlLnByb3RvY29sID0gc3RhdC5wcm90b2NvbDtcbiAgICAgICAgbG9jYWxDYW5kaWRhdGUuY2FuZGlkYXRlVHlwZSA9IHN0YXQuY2FuZGlkYXRlVHlwZTtcbiAgICAgICAgbG9jYWxDYW5kaWRhdGUuaWQgPSBzdGF0LmlkO1xuICAgICAgICBsb2NhbENhbmRpZGF0ZS5yZWxheVByb3RvY29sID0gc3RhdC5yZWxheVByb3RvY29sO1xuICAgICAgICBsb2NhbENhbmRpZGF0ZS50cmFuc3BvcnRJZCA9IHN0YXQudHJhbnNwb3J0SWQ7XG4gICAgICAgIHRoaXMubG9jYWxDYW5kaWRhdGVzLnB1c2gobG9jYWxDYW5kaWRhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBSZW1vdGUgSWNlIENhbmRpZGF0ZSBEYXRhXG4gICAgICogQHBhcmFtIHN0YXQgLSBpY2UgY2FuZGlkYXRlIHN0YXRzXG4gICAgICovXG4gICAgaGFuZGxlUmVtb3RlQ2FuZGlkYXRlKHN0YXQpIHtcbiAgICAgICAgY29uc3QgcmVtb3RlQ2FuZGlkYXRlID0gbmV3IENhbmRpZGF0ZVN0YXQoKTtcbiAgICAgICAgcmVtb3RlQ2FuZGlkYXRlLmxhYmVsID0gJ3JlbW90ZS1jYW5kaWRhdGUnO1xuICAgICAgICByZW1vdGVDYW5kaWRhdGUuYWRkcmVzcyA9IHN0YXQuYWRkcmVzcztcbiAgICAgICAgcmVtb3RlQ2FuZGlkYXRlLnBvcnQgPSBzdGF0LnBvcnQ7XG4gICAgICAgIHJlbW90ZUNhbmRpZGF0ZS5wcm90b2NvbCA9IHN0YXQucHJvdG9jb2w7XG4gICAgICAgIHJlbW90ZUNhbmRpZGF0ZS5pZCA9IHN0YXQuaWQ7XG4gICAgICAgIHJlbW90ZUNhbmRpZGF0ZS5jYW5kaWRhdGVUeXBlID0gc3RhdC5jYW5kaWRhdGVUeXBlO1xuICAgICAgICByZW1vdGVDYW5kaWRhdGUucmVsYXlQcm90b2NvbCA9IHN0YXQucmVsYXlQcm90b2NvbDtcbiAgICAgICAgcmVtb3RlQ2FuZGlkYXRlLnRyYW5zcG9ydElkID0gc3RhdC50cmFuc3BvcnRJZDtcbiAgICAgICAgdGhpcy5yZW1vdGVDYW5kaWRhdGVzLnB1c2gocmVtb3RlQ2FuZGlkYXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgSW5ib3VuZCBSVFAgQXVkaW8gYW5kIFZpZGVvIERhdGFcbiAgICAgKiBAcGFyYW0gc3RhdCAtIGluYm91bmQgcnRwIHN0YXRzXG4gICAgICovXG4gICAgaGFuZGxlSW5ib3VuZFJUUChzdGF0KSB7XG4gICAgICAgIHN3aXRjaCAoc3RhdC5raW5kKSB7XG4gICAgICAgICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGJpdHJhdGUgYmV0d2VlbiBzdGF0IHVwZGF0ZXNcbiAgICAgICAgICAgICAgICBpZiAoc3RhdC5ieXRlc1JlY2VpdmVkID4gdGhpcy5pbmJvdW5kVmlkZW9TdGF0cy5ieXRlc1JlY2VpdmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHN0YXQudGltZXN0YW1wID4gdGhpcy5pbmJvdW5kVmlkZW9TdGF0cy50aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmJvdW5kVmlkZW9TdGF0cy5iaXRyYXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICg4ICogKHN0YXQuYnl0ZXNSZWNlaXZlZCAtIHRoaXMuaW5ib3VuZFZpZGVvU3RhdHMuYnl0ZXNSZWNlaXZlZCkpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3RhdC50aW1lc3RhbXAgLSB0aGlzLmluYm91bmRWaWRlb1N0YXRzLnRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5ib3VuZFZpZGVvU3RhdHMuYml0cmF0ZSA9IE1hdGguZmxvb3IodGhpcy5pbmJvdW5kVmlkZW9TdGF0cy5iaXRyYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29weSBtZW1iZXJzIGZyb20gc3RhdCBpbnRvIGB0aGlzLmluYm91bmRWaWRlb1N0YXRzYFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHN0YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmJvdW5kVmlkZW9TdGF0c1trZXldID0gc3RhdFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgICAgICAgICAgICBpZiAoc3RhdC5ieXRlc1JlY2VpdmVkID4gdGhpcy5pbmJvdW5kQXVkaW9TdGF0cy5ieXRlc1JlY2VpdmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHN0YXQudGltZXN0YW1wID4gdGhpcy5pbmJvdW5kQXVkaW9TdGF0cy50aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmJvdW5kQXVkaW9TdGF0cy5iaXRyYXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICg4ICogKHN0YXQuYnl0ZXNSZWNlaXZlZCAtIHRoaXMuaW5ib3VuZEF1ZGlvU3RhdHMuYnl0ZXNSZWNlaXZlZCkpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3RhdC50aW1lc3RhbXAgLSB0aGlzLmluYm91bmRBdWRpb1N0YXRzLnRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5ib3VuZEF1ZGlvU3RhdHMuYml0cmF0ZSA9IE1hdGguZmxvb3IodGhpcy5pbmJvdW5kQXVkaW9TdGF0cy5iaXRyYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29weSBtZW1iZXJzIGZyb20gc3RhdCBpbnRvIGB0aGlzLmluYm91bmRBdWRpb1N0YXRzYFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHN0YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmJvdW5kQXVkaW9TdGF0c1trZXldID0gc3RhdFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBLaW5kIHNob3VsZCBiZSBhdWRpbyBvciB2aWRlbywgd2UgZ290ICR7c3RhdC5raW5kfSAtIHRoYXQncyB1bnN1cHBvcnRlZC5gKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBcImxvY2FsXCIgb3V0Ym91bmQgUlRQIEF1ZGlvIGFuZCBWaWRlbyBzdGF0cy5cbiAgICAgKiBAcGFyYW0gc3RhdCAtIGxvY2FsIG91dGJvdW5kIHJ0cCBzdGF0c1xuICAgICAqL1xuICAgIGhhbmRsZUxvY2FsT3V0Ym91bmQoc3RhdCkge1xuICAgICAgICBjb25zdCBsb2NhbE91dGJvdW5kU3RhdHMgPSBzdGF0LmtpbmQgPT09ICdhdWRpbycgPyB0aGlzLm91dGJvdW5kQXVkaW9TdGF0cyA6IHRoaXMub3V0Ym91bmRWaWRlb1N0YXRzO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMuYWN0aXZlID0gc3RhdC5hY3RpdmU7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5jb2RlY0lkID0gc3RhdC5jb2RlY0lkO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMuYnl0ZXNTZW50ID0gc3RhdC5ieXRlc1NlbnQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5mcmFtZUhlaWdodCA9IHN0YXQuZnJhbWVIZWlnaHQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5mcmFtZVdpZHRoID0gc3RhdC5mcmFtZVdpZHRoO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMuZnJhbWVzRW5jb2RlZCA9IHN0YXQuZnJhbWVzRW5jb2RlZDtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLmZyYW1lc1BlclNlY29uZCA9IHN0YXQuZnJhbWVzUGVyU2Vjb25kO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMuaGVhZGVyQnl0ZXNTZW50ID0gc3RhdC5oZWFkZXJCeXRlc1NlbnQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5pZCA9IHN0YXQuaWQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5rZXlGcmFtZXNFbmNvZGVkID0gc3RhdC5rZXlGcmFtZXNFbmNvZGVkO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMua2luZCA9IHN0YXQua2luZDtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLm1lZGlhU291cmNlSWQgPSBzdGF0Lm1lZGlhU291cmNlSWQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5taWQgPSBzdGF0Lm1pZDtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLm5hY2tDb3VudCA9IHN0YXQubmFja0NvdW50O1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMucGFja2V0c1NlbnQgPSBzdGF0LnBhY2tldHNTZW50O1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMucXBTdW0gPSBzdGF0LnFwU3VtO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMgPSBzdGF0LnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMucXVhbGl0eUxpbWl0YXRpb25SZWFzb24gPSBzdGF0LnF1YWxpdHlMaW1pdGF0aW9uUmVhc29uO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMucmVtb3RlSWQgPSBzdGF0LnJlbW90ZUlkO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMucmV0cmFuc21pdHRlZEJ5dGVzU2VudCA9IHN0YXQucmV0cmFuc21pdHRlZEJ5dGVzU2VudDtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLnJpZCA9IHN0YXQucmlkO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMuc2NhbGFiaWxpdHlNb2RlID0gc3RhdC5zY2FsYWJpbGl0eU1vZGU7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5zc3JjID0gc3RhdC5zc3JjO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMudGFyZ2V0Qml0cmF0ZSA9IHN0YXQudGFyZ2V0Qml0cmF0ZTtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLnRpbWVzdGFtcCA9IHN0YXQudGltZXN0YW1wO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMudG90YWxFbmNvZGVUaW1lID0gc3RhdC50b3RhbEVuY29kZVRpbWU7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy50b3RhbEVuY29kZUJ5dGVzVGFyZ2V0ID0gc3RhdC50b3RhbEVuY29kZUJ5dGVzVGFyZ2V0O1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMudG90YWxQYWNrZXRTZW5kRGVsYXkgPSBzdGF0LnRvdGFsUGFja2V0U2VuZERlbGF5O1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMudHJhbnNwb3J0SWQgPSBzdGF0LnRyYW5zcG9ydElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBcInJlbW90ZVwiIG91dGJvdW5kIFJUUCBBdWRpbyBhbmQgVmlkZW8gc3RhdHMuXG4gICAgICogQHBhcmFtIHN0YXQgLSByZW1vdGUgb3V0Ym91bmQgcnRwIHN0YXRzXG4gICAgICovXG4gICAgaGFuZGxlUmVtb3RlT3V0Ym91bmQoc3RhdCkge1xuICAgICAgICBjb25zdCByZW1vdGVPdXRib3VuZFN0YXRzID0gc3RhdC5raW5kID09PSAnYXVkaW8nID8gdGhpcy5yZW1vdGVPdXRib3VuZEF1ZGlvU3RhdHMgOiB0aGlzLnJlbW90ZU91dGJvdW5kVmlkZW9TdGF0cztcbiAgICAgICAgcmVtb3RlT3V0Ym91bmRTdGF0cy5ieXRlc1NlbnQgPSBzdGF0LmJ5dGVzU2VudDtcbiAgICAgICAgcmVtb3RlT3V0Ym91bmRTdGF0cy5jb2RlY0lkID0gc3RhdC5jb2RlY0lkO1xuICAgICAgICByZW1vdGVPdXRib3VuZFN0YXRzLmlkID0gc3RhdC5pZDtcbiAgICAgICAgcmVtb3RlT3V0Ym91bmRTdGF0cy5raW5kID0gc3RhdC5raW5kO1xuICAgICAgICByZW1vdGVPdXRib3VuZFN0YXRzLmxvY2FsSWQgPSBzdGF0LmxvY2FsSWQ7XG4gICAgICAgIHJlbW90ZU91dGJvdW5kU3RhdHMucGFja2V0c1NlbnQgPSBzdGF0LnBhY2tldHNTZW50O1xuICAgICAgICByZW1vdGVPdXRib3VuZFN0YXRzLnJlbW90ZVRpbWVzdGFtcCA9IHN0YXQucmVtb3RlVGltZXN0YW1wO1xuICAgICAgICByZW1vdGVPdXRib3VuZFN0YXRzLnJlcG9ydHNTZW50ID0gc3RhdC5yZXBvcnRzU2VudDtcbiAgICAgICAgcmVtb3RlT3V0Ym91bmRTdGF0cy5yb3VuZFRyaXBUaW1lTWVhc3VyZW1lbnRzID0gc3RhdC5yb3VuZFRyaXBUaW1lTWVhc3VyZW1lbnRzO1xuICAgICAgICByZW1vdGVPdXRib3VuZFN0YXRzLnNzcmMgPSBzdGF0LnNzcmM7XG4gICAgICAgIHJlbW90ZU91dGJvdW5kU3RhdHMudGltZXN0YW1wID0gc3RhdC50aW1lc3RhbXA7XG4gICAgICAgIHJlbW90ZU91dGJvdW5kU3RhdHMudG90YWxSb3VuZFRyaXBUaW1lID0gc3RhdC50b3RhbFJvdW5kVHJpcFRpbWU7XG4gICAgICAgIHJlbW90ZU91dGJvdW5kU3RhdHMudHJhbnNwb3J0SWQgPSBzdGF0LnRyYW5zcG9ydElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBJbmJvdW5kIFZpZGVvIFRyYWNrIERhdGFcbiAgICAgKiBAcGFyYW0gc3RhdCAtIHZpZGVvIHRyYWNrIHN0YXRzXG4gICAgICovXG4gICAgaGFuZGxlVHJhY2soc3RhdCkge1xuICAgICAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gZXh0cmFjdCBzdGF0cyBmcm9tIHRoZSB2aWRlbyB0cmFja1xuICAgICAgICBpZiAoc3RhdC50eXBlID09PSAndHJhY2snICYmIChzdGF0LnRyYWNrSWRlbnRpZmllciA9PT0gJ3ZpZGVvX2xhYmVsJyB8fCBzdGF0LmtpbmQgPT09ICd2aWRlbycpKSB7XG4gICAgICAgICAgICB0aGlzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lc0Ryb3BwZWQgPSBzdGF0LmZyYW1lc0Ryb3BwZWQ7XG4gICAgICAgICAgICB0aGlzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lc1JlY2VpdmVkID0gc3RhdC5mcmFtZXNSZWNlaXZlZDtcbiAgICAgICAgICAgIHRoaXMuaW5ib3VuZFZpZGVvU3RhdHMuZnJhbWVIZWlnaHQgPSBzdGF0LmZyYW1lSGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZVdpZHRoID0gc3RhdC5mcmFtZVdpZHRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVRyYW5zcG9ydChzdGF0KSB7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0U3RhdHMgPSBzdGF0O1xuICAgIH1cbiAgICBoYW5kbGVDb2RlYyhzdGF0KSB7XG4gICAgICAgIGNvbnN0IGNvZGVjSWQgPSBzdGF0LmlkO1xuICAgICAgICB0aGlzLmNvZGVjcy5zZXQoY29kZWNJZCwgc3RhdCk7XG4gICAgfVxuICAgIGhhbmRsZVNlc3Npb25TdGF0aXN0aWNzKHZpZGVvU3RhcnRUaW1lLCBpbnB1dENvbnRyb2xsZXIsIHZpZGVvRW5jb2RlckF2Z1FQKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhVGltZSA9IERhdGUubm93KCkgLSB2aWRlb1N0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5zZXNzaW9uU3RhdHMucnVuVGltZSA9IG5ldyBEYXRlKGRlbHRhVGltZSkudG9JU09TdHJpbmcoKS5zdWJzdHIoMTEsIDgpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xzU3RyZWFtSW5wdXQgPSBpbnB1dENvbnRyb2xsZXIgPT09IG51bGwgPyAnTm90IHNlbnQgeWV0JyA6IGlucHV0Q29udHJvbGxlciA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgICAgIHRoaXMuc2Vzc2lvblN0YXRzLmNvbnRyb2xzU3RyZWFtSW5wdXQgPSBjb250cm9sc1N0cmVhbUlucHV0O1xuICAgICAgICB0aGlzLnNlc3Npb25TdGF0cy52aWRlb0VuY29kZXJBdmdRUCA9IHZpZGVvRW5jb2RlckF2Z1FQO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHZhbHVlIGNvbWluZyBpbiBmcm9tIG91ciBzdGF0cyBpcyBhY3R1YWxseSBhIG51bWJlclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSBudW1iZXIgdG8gYmUgY2hlY2tlZFxuICAgICAqL1xuICAgIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIHJldHVybiB0aGUgYWN0aXZlIGNhbmRpZGF0ZSBwYWlyXG4gICAgICogQHJldHVybnMgVGhlIGNhbmRpZGF0ZSBwYWlyIHRoYXQgaXMgY3VycmVudGx5IHJlY2VpdmluZyBkYXRhXG4gICAgICovXG4gICAgZ2V0QWN0aXZlQ2FuZGlkYXRlUGFpcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlUGFpcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIFJUQ1RyYW5zcG9ydCBzdGF0IGlzIG5vdCB1bmRlZmluZWRcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0U3RhdHMpIHtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY2FuZGlkYXRlIHBhaXIgdGhhdCBtYXRjaGVzIHRoZSB0cmFuc3BvcnQgY2FuZGlkYXRlIHBhaXIgaWRcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkUGFpciA9IHRoaXMuY2FuZGlkYXRlUGFpcnMuZmluZCgoY2FuZGlkYXRlUGFpcikgPT4gY2FuZGlkYXRlUGFpci5pZCA9PT0gdGhpcy50cmFuc3BvcnRTdGF0cy5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRQYWlyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZFBhaXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBgLnNlbGVjdGVkYCBtZW1iZXIgb2YgdGhlIGNhbmRpZGF0ZSBwYWlyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUGFpciA9IHRoaXMuY2FuZGlkYXRlUGFpcnMuZmluZCgoY2FuZGlkYXRlUGFpcikgPT4gY2FuZGlkYXRlUGFpci5zZWxlY3RlZCk7XG4gICAgICAgIGlmIChzZWxlY3RlZFBhaXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRQYWlyO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWdncmVnYXRlZFN0YXRzLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIElDRSBDYW5kaWRhdGUgU3RhdCBjb2xsZWN0ZWQgZnJvbSB0aGUgUlRDIFN0YXRzIFJlcG9ydFxuICovXG5leHBvcnQgY2xhc3MgQ2FuZGlkYXRlU3RhdCB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW5kaWRhdGVTdGF0LmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIERhdGEgQ2hhbm5lbCBTdGF0cyBjb2xsZWN0ZWQgZnJvbSB0aGUgUlRDIFN0YXRzIFJlcG9ydFxuICovXG5leHBvcnQgY2xhc3MgRGF0YUNoYW5uZWxTdGF0cyB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhQ2hhbm5lbFN0YXRzLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIEluYm91bmQgQXVkaW8gU3RhdHMgY29sbGVjdGVkIGZyb20gdGhlIFJUQyBTdGF0cyBSZXBvcnRcbiAqL1xuZXhwb3J0IGNsYXNzIEluYm91bmRBdWRpb1N0YXRzIHtcbn1cbi8qKlxuICogSW5ib3VuZCBWaWRlbyBTdGF0cyBjb2xsZWN0ZWQgZnJvbSB0aGUgUlRDIFN0YXRzIFJlcG9ydFxuICovXG5leHBvcnQgY2xhc3MgSW5ib3VuZFZpZGVvU3RhdHMge1xufVxuLyoqXG4gKiBJbmJvdW5kIFN0YXRzIGNvbGxlY3RlZCBmcm9tIHRoZSBSVEMgU3RhdHMgUmVwb3J0XG4gKi9cbmV4cG9ydCBjbGFzcyBJbmJvdW5kUlRQU3RhdHMge1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5ib3VuZFJUUFN0YXRzLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIFJlcHJlc2VudHMgZWl0aGVyIGE6XG4gKiAtIHN5bmNocm9uaXphdGlvbiBzb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENSdHBSZWNlaXZlci9nZXRTeW5jaHJvbml6YXRpb25Tb3VyY2VzXG4gKiAtIGNvbnRyaWJ1dGluZyBzb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENSdHBSZWNlaXZlci9nZXRDb250cmlidXRpbmdTb3VyY2VzXG4gKiBXaGljaCBhbHNvIChpZiBicm93c2VyIHN1cHBvcnRzIGl0KSBtYXkgb3B0aW9uYWxsIGNvbnRhaW4gZmllbGRzIGZvciBjYXB0dXJlVGltZXN0YW1wICsgc2VuZGVyQ2FwdHVyZVRpbWVPZmZzZXRcbiAqIGlmIHRoZSBhYnMtY2FwdHVyZS10aW1lIFJUUCBoZWFkZXIgZXh0ZW5zaW9uIGlzIGVuYWJsZWQgKGN1cnJlbnRseSB0aGlzIG9ubHkgd29ya3MgaW4gQ2hyb21pdW0gYmFzZWQgYnJvd3NlcnMpLlxuICovXG5jbGFzcyBSVENSdHBDYXB0dXJlU291cmNlIHtcbn1cbi8qKlxuICogRnJhbWVUaW1pbmdJbmZvIGlzIGEgQ2hyb21pdW0tc3BlY2lmaWMgc2V0IG9mIFdlYlJUQyBzdGF0cyB1c2VmdWwgZm9yIGxhdGVuY3kgY2FsY3VsYXRpb24uIEl0IGlzIHN0b3JlZCBpbiBXZWJSVEMgc3RhdHMgYXMgYGdvb2dUaW1pbmdGcmFtZUluZm9gLlxuICogSXQgaXMgZGVmaW5lZCBhcyBhbiBSVFAgaGVhZGVyIGV4dGVuc2lvbiBoZXJlOiBodHRwczovL3dlYnJ0Yy5nb29nbGVzb3VyY2UuY29tL3NyYy8rL3JlZnMvaGVhZHMvbWFpbi9kb2NzL25hdGl2ZS1jb2RlL3J0cC1oZHJleHQvdmlkZW8tdGltaW5nL1JFQURNRS5tZFxuICogSXQgaXMgZGVmaW5lZCBpbiBzb3VyY2UgY29kZSBoZXJlOiBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFpbjp0aGlyZF9wYXJ0eS93ZWJydGMvYXBpL3ZpZGVvL3ZpZGVvX3RpbWluZy5jYztsPTgyO2RyYz04ZDM5OTgxNzI4MmUzYzEyZWQ1NGViMjNlYzQyYTVlNDE4Mjk4ZWM2XG4gKiBJdCBpcyBkaXNjdXNzZWQgYnkgaXRzIGF1dGhvciBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdzNjL3dlYnJ0Yy1wcm92aXNpb25hbC1zdGF0cy9pc3N1ZXMvNDAjaXNzdWVjb21tZW50LTEyNzI5MTY2OTJcbiAqIEluIHN1bW1hcnkgaXQgYSBjb21tYS1kZWxpbWl0ZWQgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIGZvbGxvd2luZyAoaW4gdGhpcyBvcmRlcik6XG4gKiAxKSAgUlRQIHRpbWVzdGFtcDogdGhlIFJUUCB0aW1lc3RhbXAgb2YgdGhlIGZyYW1lXG4gKiAyKSAgQ2FwdHVyZSB0aW1lOiB0aW1lc3RhbXAgd2hlbiB0aGlzIGZyYW1lIHdhcyBjYXB0dXJlZFxuICogMykgIEVuY29kZSBzdGFydDogdGltZXN0YW1wIHdoZW4gdGhpcyBmcmFtZSBzdGFydGVkIHRvIGJlIGVuY29kZWRcbiAqIDQpICBFbmNvZGUgZmluaXNoOiB0aW1lc3RhbXAgd2hlbiB0aGlzIGZyYW1lIGZpbmlzaGVkIGVuY29kaW5nXG4gKiA1KSAgUGFja2V0aXphdGlvbiBmaW5pc2g6IHRpbWVzdGFtcCB3aGVuIHRoaXMgZnJhbWUgd2FzIHNwbGl0IGludG8gcGFja2V0cyBhbmQgd2FzIHJlYWR5IHRvIGJlIHNlbnQgb3ZlciB0aGUgbmV0d29ya1xuICogNikgIFBhY2VyIGV4aXQ6IHRpbWVzdGFtcCB3aGVuIGxhc3QgcGFja2V0IG9mIHRoaXMgZnJhbWUgd2FzIHNlbnQgb3ZlciB0aGUgbmV0d29yayBieSB0aGUgc2VuZGVyIGF0IHRoaXMgdGltZXN0YW1wXG4gKiA3KSAgTmV0d29yayB0aW1lc3RhbXAxOiBwbGFjZSBmb3IgdGhlIFNGVSB0byBtYXJrIHdoZW4gdGhlIGZyYW1lIHN0YXJ0ZWQgYmVpbmcgZm9yd2FyZGVkLiBBcHBsaWNhdGlvbiBzcGVjaWZpYy5cbiAqIDgpICBOZXR3b3JrIHRpbWVzdGFtcDI6IHBsYWNlIGZvciB0aGUgU0ZVIHRvIG1hcmsgd2hlbiB0aGUgZnJhbWUgZmluaXNoZWQgYmVpbmcgZm9yd2FyZGVkLiBBcHBsaWNhdGlvbiBzcGVjaWZpYy5cbiAqIDkpICBSZWNlaXZlIHN0YXJ0OiB0aW1lc3RhbXAgd2hlbiB0aGUgZmlyc3QgcGFja2V0IG9mIHRoaXMgZnJhbWUgd2FzIHJlY2VpdmVkXG4gKiAxMCkgUmVjZWl2ZSBmaW5pc2g6IHRpbWVzdGFtcCB3aGVuIHRoZSBsYXN0IHBhY2tldCBvZiB0aGlzIGZyYW1lIHdhcyByZWNlaXZlZFxuICogMTEpIERlY29kZSBzdGFydDogIHRpbWVzdGFtcCB3aGVuIHRoZSBmcmFtZSB3YXMgcGFzc2VkIHRvIGRlY29kZXJcbiAqIDEyKSBEZWNvZGUgZmluaXNoOiAgdGltZXN0YW1wIHdoZW4gdGhlIGZyYW1lIHdhcyBkZWNvZGVkXG4gKiAxMykgUmVuZGVyIHRpbWU6ICB0aW1lc3RhbXAgb2YgdGhlIHByb2plY3RlZCByZW5kZXIgdGltZSBmb3IgdGhpcyBmcmFtZVxuICogMTQpIFwiaXMgb3V0bGllclwiOiBhIGZsYWcgZm9yIGlmIHRoaXMgZnJhbWUgaXMgYmlnZ2VyIGluIGVuY29kZWQgc2l6ZSB0aGFuIHRoZSBhdmVyYWdlIGZyYW1lIGJ5IGF0IGxlYXN0IDV4LlxuICogMTUpIFwidHJpZ2dlcmVkIGJ5IHRpbWVyXCI6IGEgZmxhZyBmb3IgaWYgdGhpcyByZXBvcnQgd2FzIHRyaWdnZXJlZCBieSB0aGUgdGltZXIgKFRoZSByZXBvcnQgaXMgc2VudCBldmVyeSAyMDBtcylcbiAqL1xuZXhwb3J0IGNsYXNzIEZyYW1lVGltaW5nSW5mbyB7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgYSBjb21iaW5hdGlvbiBvZiBsYXRlbmN5IHN0YXRpc3RpY3MgdXNpbmcgcHVyZWx5IFdlYlJUQyBBUEkuXG4gKi9cbmV4cG9ydCBjbGFzcyBMYXRlbmN5Q2FsY3VsYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qIENsb2NrIG9mZnNldCBiZXR3ZWVuIHBlZXIgY2xvY2tzIGNhbm5vdCBhbHdheXMgYmUgY2FsY3VsYXRlZCBhcyBpdCByZWxpZXMgb2YgbGF0ZXN0IHNlbmRlciByZXBvcnRzLlxuICAgICAgICAgKiBzbyB3ZSBzdG9yZSB0aGUgbGFzdCB0aW1lIHdlIGhhZCBhIHZhbGlkIGNsb2NrIG9mZnNldCBpbiB0aGUgYXNzdW1wdGlvbiB0aGF0IGNsb2NrcyBoYXZlbid0IGRyaWZ0ZWQgdG9vIG11Y2ggc2luY2UgdGhlbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGF0ZXN0U2VuZGVyUmVjdkNsb2NrT2Zmc2V0ID0gbnVsbDtcbiAgICB9XG4gICAgY2FsY3VsYXRlKHN0YXRzLCByZWNlaXZlcnMpIHtcbiAgICAgICAgY29uc3QgbGF0ZW5jeUluZm8gPSBuZXcgTGF0ZW5jeUluZm8oKTtcbiAgICAgICAgY29uc3QgcnR0TVMgPSB0aGlzLmdldFJUVE1zKHN0YXRzKTtcbiAgICAgICAgaWYgKHJ0dE1TICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLnJ0dE1zID0gcnR0TVM7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgc2VuZGVyIGxhdGVuY3kgdXNpbmcgdGhlIGZpcnN0IHZhbGlkIHZpZGVvIHNzcmMvY3NyY1xuICAgICAgICAgICAgY29uc3QgY2FwdHVyZVNvdXJjZSA9IHRoaXMuZ2V0Q2FwdHVyZVNvdXJjZShyZWNlaXZlcnMpO1xuICAgICAgICAgICAgaWYgKGNhcHR1cmVTb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbmRlckxhdGVuY3lNcyA9IHRoaXMuY2FsY3VsYXRlU2VuZGVyTGF0ZW5jeShzdGF0cywgY2FwdHVyZVNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbmRlckxhdGVuY3lNcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsYXRlbmN5SW5mby5zZW5kZXJMYXRlbmN5TXMgPSBzZW5kZXJMYXRlbmN5TXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJydGMtc3RhdHMvI2RvbS1ydGNpbmJvdW5kcnRwc3RyZWFtc3RhdHMtdG90YWxwcm9jZXNzaW5nZGVsYXlcbiAgICAgICAgaWYgKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLnRvdGFsUHJvY2Vzc2luZ0RlbGF5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lc0RlY29kZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGF0ZW5jeUluZm8uYXZlcmFnZVByb2Nlc3NpbmdEZWxheU1zID1cbiAgICAgICAgICAgICAgICAoc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMudG90YWxQcm9jZXNzaW5nRGVsYXkgLyBzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZXNEZWNvZGVkKSAqIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1zdGF0cy8jZG9tLXJ0Y2luYm91bmRydHBzdHJlYW1zdGF0cy1qaXR0ZXJidWZmZXJtaW5pbXVtZGVsYXlcbiAgICAgICAgaWYgKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmppdHRlckJ1ZmZlckRlbGF5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmppdHRlckJ1ZmZlckVtaXR0ZWRDb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYXRlbmN5SW5mby5hdmVyYWdlSml0dGVyQnVmZmVyRGVsYXlNcyA9XG4gICAgICAgICAgICAgICAgKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmppdHRlckJ1ZmZlckRlbGF5IC9cbiAgICAgICAgICAgICAgICAgICAgc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuaml0dGVyQnVmZmVyRW1pdHRlZENvdW50KSAqXG4gICAgICAgICAgICAgICAgICAgIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1zdGF0cy8jZG9tLXJ0Y2luYm91bmRydHBzdHJlYW1zdGF0cy10b3RhbGRlY29kZXRpbWVcbiAgICAgICAgaWYgKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lc0RlY29kZWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMudG90YWxEZWNvZGVUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLmF2ZXJhZ2VEZWNvZGVMYXRlbmN5TXMgPVxuICAgICAgICAgICAgICAgIChzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy50b3RhbERlY29kZVRpbWUgLyBzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZXNEZWNvZGVkKSAqIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1zdGF0cy8jZG9tLXJ0Y2luYm91bmRydHBzdHJlYW1zdGF0cy1mcmFtZXNhc3NlbWJsZWRmcm9tbXVsdGlwbGVwYWNrZXRzXG4gICAgICAgIGlmIChzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy50b3RhbEFzc2VtYmx5VGltZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZXNBc3NlbWJsZWRGcm9tTXVsdGlwbGVQYWNrZXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLmF2ZXJhZ2VBc3NlbWJseURlbGF5TXMgPVxuICAgICAgICAgICAgICAgIChzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy50b3RhbEFzc2VtYmx5VGltZSAvXG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lc0Fzc2VtYmxlZEZyb21NdWx0aXBsZVBhY2tldHMpICpcbiAgICAgICAgICAgICAgICAgICAgMTAwMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRyYWN0IGV4dHJhIENocm9tZS1zcGVjaWZpYyBzdGF0cyBsaWtlIGVuY29kaW5nIGxhdGVuY3lcbiAgICAgICAgaWYgKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmdvb2dUaW1pbmdGcmFtZUluZm8gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuZ29vZ1RpbWluZ0ZyYW1lSW5mby5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsYXRlbmN5SW5mby5mcmFtZVRpbWluZyA9IHRoaXMuZXh0cmFjdEZyYW1lVGltaW5nSW5mbyhzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5nb29nVGltaW5nRnJhbWVJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgRTJFIGxhdGVuY3kgdXNpbmcgdmlkZW8tdGltaW5nIGNhcHR1cmUgdG8gc2VuZCB0aW1lICsgb25lIHdheSBuZXR3b3JrIGxhdGVuY3kgKyByZWNlaXZlci1zaWRlIGxhdGVuY3lcbiAgICAgICAgaWYgKGxhdGVuY3lJbmZvLmZyYW1lVGltaW5nICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLmZyYW1lVGltaW5nLmNhcHR1cmVUb1NlbmRMYXRlbmN5TXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgbGF0ZW5jeUluZm8uYXZlcmFnZVByb2Nlc3NpbmdEZWxheU1zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLnJ0dE1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLmF2ZXJhZ2VFMkVMYXRlbmN5ID1cbiAgICAgICAgICAgICAgICBsYXRlbmN5SW5mby5mcmFtZVRpbWluZy5jYXB0dXJlVG9TZW5kTGF0ZW5jeU1zICtcbiAgICAgICAgICAgICAgICAgICAgbGF0ZW5jeUluZm8ucnR0TXMgKiAwLjUgK1xuICAgICAgICAgICAgICAgICAgICBsYXRlbmN5SW5mby5hdmVyYWdlUHJvY2Vzc2luZ0RlbGF5TXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIEUyRSBsYXRlbmN5IGFzIGFicy1jYXB0dXJlLXRpbWUgY2FwdHVyZSB0byBzZW5kIGxhdGVuY3kgKyBvbmUgd2F5IG5ldHdvcmsgbGF0ZW5jeSArIHJlY2VpdmVyLXNpZGUgbGF0ZW5jeVxuICAgICAgICBpZiAobGF0ZW5jeUluZm8uc2VuZGVyTGF0ZW5jeU1zICE9IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgbGF0ZW5jeUluZm8uYXZlcmFnZVByb2Nlc3NpbmdEZWxheU1zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLnJ0dE1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLmF2ZXJhZ2VFMkVMYXRlbmN5ID1cbiAgICAgICAgICAgICAgICBsYXRlbmN5SW5mby5zZW5kZXJMYXRlbmN5TXMgKyBsYXRlbmN5SW5mby5ydHRNcyAqIDAuNSArIGxhdGVuY3lJbmZvLmF2ZXJhZ2VQcm9jZXNzaW5nRGVsYXlNcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF0ZW5jeUluZm87XG4gICAgfVxuICAgIGV4dHJhY3RGcmFtZVRpbWluZ0luZm8oZ29vZ1RpbWluZ0ZyYW1lSW5mbykge1xuICAgICAgICBjb25zdCB0aW1pbmdJbmZvID0gbmV3IEZyYW1lVGltaW5nSW5mbygpO1xuICAgICAgICBjb25zdCB0aW1pbmdJbmZvQXJyID0gZ29vZ1RpbWluZ0ZyYW1lSW5mby5zcGxpdCgnLCcpO1xuICAgICAgICAvLyBTaG91bGQgaGF2ZSBleGFjdGx5IDE1IGVsZW1lbnRzIGFjY29yZGluZyB0bzpcbiAgICAgICAgLy8gaHR0cHM6Ly9zb3VyY2UuY2hyb21pdW0ub3JnL2Nocm9taXVtL2Nocm9taXVtL3NyYy8rL21haW46dGhpcmRfcGFydHkvd2VicnRjL2FwaS92aWRlby92aWRlb190aW1pbmcuY2M7bD04MjtkcmM9OGQzOTk4MTcyODJlM2MxMmVkNTRlYjIzZWM0MmE1ZTQxODI5OGVjNlxuICAgICAgICBpZiAodGltaW5nSW5mb0Fyci5sZW5ndGggPT09IDE1KSB7XG4gICAgICAgICAgICB0aW1pbmdJbmZvLnJ0cFRpbWVzdGFtcCA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzBdKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8uY2FwdHVyZVRpbWVzdGFtcCA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzFdKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8uZW5jb2RlU3RhcnRUaW1lc3RhbXAgPSBOdW1iZXIucGFyc2VJbnQodGltaW5nSW5mb0FyclsyXSk7XG4gICAgICAgICAgICB0aW1pbmdJbmZvLmVuY29kZUZpbmlzaFRpbWVzdGFtcCA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzNdKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8ucGFja2V0aXplckZpbmlzaFRpbWVzdGFtcCA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzRdKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8ucGFjZXJFeGl0VGltZXN0YW1wID0gTnVtYmVyLnBhcnNlSW50KHRpbWluZ0luZm9BcnJbNV0pO1xuICAgICAgICAgICAgdGltaW5nSW5mby5uZXR3b3JrVGltZXN0YW1wMSA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzZdKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8ubmV0d29ya1RpbWVzdGFtcDIgPSBOdW1iZXIucGFyc2VJbnQodGltaW5nSW5mb0Fycls3XSk7XG4gICAgICAgICAgICB0aW1pbmdJbmZvLnJlY2VpdmVTdGFydCA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzhdKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8ucmVjZWl2ZUZpbmlzaCA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzldKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8uZGVjb2RlU3RhcnQgPSBOdW1iZXIucGFyc2VJbnQodGltaW5nSW5mb0FyclsxMF0pO1xuICAgICAgICAgICAgdGltaW5nSW5mby5kZWNvZGVGaW5pc2ggPSBOdW1iZXIucGFyc2VJbnQodGltaW5nSW5mb0FyclsxMV0pO1xuICAgICAgICAgICAgdGltaW5nSW5mby5yZW5kZXJUaW1lID0gTnVtYmVyLnBhcnNlSW50KHRpbWluZ0luZm9BcnJbMTJdKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8uaXNPdXRsaWVyID0gTnVtYmVyLnBhcnNlSW50KHRpbWluZ0luZm9BcnJbMTNdKSA+IDA7XG4gICAgICAgICAgICB0aW1pbmdJbmZvLmlzVHJpZ2dlcmVkQnlUaW1lciA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzE0XSkgPiAwO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHNvbWUgbGF0ZW5jeSBzdGF0c1xuICAgICAgICAgICAgdGltaW5nSW5mby5lbmNvZGVyTGF0ZW5jeU1zID0gdGltaW5nSW5mby5lbmNvZGVGaW5pc2hUaW1lc3RhbXAgLSB0aW1pbmdJbmZvLmVuY29kZVN0YXJ0VGltZXN0YW1wO1xuICAgICAgICAgICAgdGltaW5nSW5mby5wYWNrZXRpemVMYXRlbmN5TXMgPVxuICAgICAgICAgICAgICAgIHRpbWluZ0luZm8ucGFja2V0aXplckZpbmlzaFRpbWVzdGFtcCAtIHRpbWluZ0luZm8uZW5jb2RlRmluaXNoVGltZXN0YW1wO1xuICAgICAgICAgICAgdGltaW5nSW5mby5wYWNlckxhdGVuY3lNcyA9IHRpbWluZ0luZm8ucGFjZXJFeGl0VGltZXN0YW1wIC0gdGltaW5nSW5mby5wYWNrZXRpemVyRmluaXNoVGltZXN0YW1wO1xuICAgICAgICAgICAgdGltaW5nSW5mby5jYXB0dXJlVG9TZW5kTGF0ZW5jeU1zID0gdGltaW5nSW5mby5wYWNlckV4aXRUaW1lc3RhbXAgLSB0aW1pbmdJbmZvLmNhcHR1cmVUaW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbWluZ0luZm87XG4gICAgfVxuICAgIGNhbGN1bGF0ZVNlbmRlckxhdGVuY3koc3RhdHMsIGNhcHR1cmVTb3VyY2UpIHtcbiAgICAgICAgLy8gVGhlIGNhbGN1bGF0aW9uIHBlcmZvcm1lZCBpbiB0aGlzIGZ1bmN0aW9uIGlzIGFzIHBlciB0aGUgcHJvY2VkdXJlIGRlZmluZWQgaGVyZTpcbiAgICAgICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1leHRlbnNpb25zLyNkb20tcnRjcnRwY29udHJpYnV0aW5nc291cmNlLXNlbmRlcmNhcHR1cmV0aW1lb2Zmc2V0XG4gICAgICAgIC8vIEdldCB0aGUgc2VuZGVyIGNhcHR1cmUgaW4gdGhlIHNlbmRlcidzIGNsb2NrXG4gICAgICAgIGNvbnN0IHNlbmRlckNhcHR1cmVUaW1lc3RhbXAgPSBjYXB0dXJlU291cmNlLmNhcHR1cmVUaW1lc3RhbXAgKyBjYXB0dXJlU291cmNlLnNlbmRlckNhcHR1cmVUaW1lT2Zmc2V0O1xuICAgICAgICBsZXQgc2VuZFJlY3ZDbG9ja09mZnNldCA9IHRoaXMuY2FsY3VsYXRlU2VuZGVyUmVjZWl2ZXJDbG9ja09mZnNldChzdGF0cyk7XG4gICAgICAgIC8vIFVzZSBsYXRlc3QgY2xvY2sgb2Zmc2V0IGlmIHdlIGNvdWxkbid0IGNhbGN1bGF0ZSBvbmUgbm93XG4gICAgICAgIGlmIChzZW5kUmVjdkNsb2NrT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhdGVzdFNlbmRlclJlY3ZDbG9ja09mZnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VuZFJlY3ZDbG9ja09mZnNldCA9IHRoaXMubGF0ZXN0U2VuZGVyUmVjdkNsb2NrT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxhdGVzdFNlbmRlclJlY3ZDbG9ja09mZnNldCA9IHNlbmRSZWN2Q2xvY2tPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBicmluZ3Mgc2VuZGVyIGNsb2NrIHJvdWdobHkgaW5saW5lIHdpdGggcmVjdiBjbG9ja1xuICAgICAgICBjb25zdCByZWN2Q2FwdHVyZVRpbWVzdGFtcE5UUCA9IHNlbmRlckNhcHR1cmVUaW1lc3RhbXAgKyBzZW5kUmVjdkNsb2NrT2Zmc2V0O1xuICAgICAgICAvLyBBcyBkZWZpbmVkIGluIENocm9tZSBzb3VyY2U6IGh0dHBzOi8vY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9leHRlcm5hbC93ZWJydGMvKy9tYXN0ZXIvc3lzdGVtX3dyYXBwZXJzL2luY2x1ZGUvY2xvY2suaCMyNlxuICAgICAgICBjb25zdCBudHAxOTcwID0gMjIwODk4ODgwMDAwMDtcbiAgICAgICAgY29uc3QgcmVjdkNhcHR1cmVUaW1lc3RhbXAgPSByZWN2Q2FwdHVyZVRpbWVzdGFtcE5UUCAtIG50cDE5NzA7XG4gICAgICAgIGNvbnN0IHNlbmRlckxhdGVuY3kgPSBjYXB0dXJlU291cmNlLnRpbWVzdGFtcCAtIHJlY3ZDYXB0dXJlVGltZXN0YW1wO1xuICAgICAgICByZXR1cm4gc2VuZGVyTGF0ZW5jeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgZmlyc3QgdmFsaWQgc3NyYyBvciBjc3JjIHRoYXQgaGFzIGNhcHR1cmUgdGltZSBmaWVsZHMgcHJlc2VudCBmcm9tIGFicy1jYXB0dXJlLXRpbWUgaGVhZGVyIGV4dGVuc2lvbi5cbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXJzIFRoZSBSVFAgcmVjZXZpZXJzIHRoaXMgcGVlciBjb25uZWN0aW9uIGhhcy5cbiAgICAgKiBAcmV0dXJucyBBIHNpbmdsZSB2YWxpZCBzc3JjIG9yIGNzcmMgdGhhdCBoYXMgY2FwdHVyZSB0aW1lIGZpZWxkcyBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUgKGUuZy4gaW4gbm9uLWNocm9taXVtIGJyb3dzZXJzIGl0IHdpbGwgYmUgbnVsbCkuXG4gICAgICovXG4gICAgZ2V0Q2FwdHVyZVNvdXJjZShyZWNlaXZlcnMpIHtcbiAgICAgICAgLy8gV2Ugb25seSB3YW50IHZpZGVvIHJlY2VpdmVyc1xuICAgICAgICByZWNlaXZlcnMgPSByZWNlaXZlcnMuZmlsdGVyKChyZWNlaXZlcikgPT4gcmVjZWl2ZXIudHJhY2sua2luZCA9PT0gJ3ZpZGVvJyk7XG4gICAgICAgIGZvciAoY29uc3QgcmVjZWl2ZXIgb2YgcmVjZWl2ZXJzKSB7XG4gICAgICAgICAgICAvLyBHbyB0aHJvdWdoIGFsbCBzc3JjIGFuZCBjc3JjIHRvIGNoZWNrIGZvciBjYXB0dXJlIHRpbWVzdGFtcFxuICAgICAgICAgICAgLy8gTm90ZTogQ29udmVyc2lvbiB0byBgYW55YCBoZXJlIGlzIGJlY2F1c2UgVFMgZG9lcyBub3QgaGF2ZSBjYXB0dXJlVGltZXN0YW1wIGV0YyBkZWZpbmVkIGluIHRoZSB0eXBlc1xuICAgICAgICAgICAgLy8gdGhlc2UgZmllbGRzIG9ubHkgZXhpc3QgaW4gQ2hyb21pdW0gY3VycmVudGx5LlxuICAgICAgICAgICAgY29uc3Qgc291cmNlcyA9IHJlY2VpdmVyXG4gICAgICAgICAgICAgICAgLmdldFN5bmNocm9uaXphdGlvblNvdXJjZXMoKVxuICAgICAgICAgICAgICAgIC5jb25jYXQocmVjZWl2ZXIuZ2V0Q29udHJpYnV0aW5nU291cmNlcygpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3JjIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3JjLmNhcHR1cmVUaW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBzcmMuc2VuZGVyQ2FwdHVyZVRpbWVPZmZzZXQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBzcmMudGltZXN0YW1wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FwdHVyZVNyYyA9IG5ldyBSVENSdHBDYXB0dXJlU291cmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhcHR1cmVTcmMudGltZXN0YW1wID0gc3JjLnRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgY2FwdHVyZVNyYy5jYXB0dXJlVGltZXN0YW1wID0gc3JjLmNhcHR1cmVUaW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgICAgIGNhcHR1cmVTcmMuc2VuZGVyQ2FwdHVyZVRpbWVPZmZzZXQgPSBzcmMuc2VuZGVyQ2FwdHVyZVRpbWVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYXB0dXJlU3JjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY2FsY3VsYXRlU2VuZGVyUmVjZWl2ZXJDbG9ja09mZnNldChzdGF0cykge1xuICAgICAgICAvLyBUaGUgY2FsY3VsYXRpb24gcGVyZm9ybWVkIGluIHRoaXMgZnVuY3Rpb24gaXMgYXMgcGVyIHRoZSBwcm9jZWR1cmUgZGVmaW5lZCBoZXJlOlxuICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLWV4dGVuc2lvbnMvI2RvbS1ydGNydHBjb250cmlidXRpbmdzb3VyY2Utc2VuZGVyY2FwdHVyZXRpbWVvZmZzZXRcbiAgICAgICAgY29uc3QgaGFzUmVtb3RlT3V0Ym91bmRWaWRlb1N0YXRzID0gc3RhdHMucmVtb3RlT3V0Ym91bmRWaWRlb1N0YXRzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHN0YXRzLnJlbW90ZU91dGJvdW5kVmlkZW9TdGF0cy50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgc3RhdHMucmVtb3RlT3V0Ym91bmRWaWRlb1N0YXRzLnJlbW90ZVRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBOb3RlOiBBcyBvZiBDaHJvbWUgMTMyLCByZW1vdGUtb3V0Ym91bmQtcnRwIHN0YXRzIGZvciB2aWRlbyBhcmUgbm90IHlldCBpbXBsZW1lbnRlZCAoYXVkaW8gd29ya3MpLlxuICAgICAgICAvLyBUaGlzIGNvZGVwYXRoIHNob3VsZCBhY3RpdmF0ZSBvbmNlIHRoZXkgZG8gYmVnaW4gdG8gd29yay5cbiAgICAgICAgaWYgKCFoYXNSZW1vdGVPdXRib3VuZFZpZGVvU3RhdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbW90ZVN0YXRzQXJyaXZlZFRpbWVzdGFtcCA9IHN0YXRzLnJlbW90ZU91dGJvdW5kVmlkZW9TdGF0cy50aW1lc3RhbXA7XG4gICAgICAgIGNvbnN0IHJlbW90ZVN0YXRzU2VudFRpbWVzdGFtcCA9IHN0YXRzLnJlbW90ZU91dGJvdW5kVmlkZW9TdGF0cy5yZW1vdGVUaW1lc3RhbXA7XG4gICAgICAgIGNvbnN0IHJ0dE1zID0gdGhpcy5nZXRSVFRNcyhzdGF0cyk7XG4gICAgICAgIGlmIChyZW1vdGVTdGF0c0Fycml2ZWRUaW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgcmVtb3RlU3RhdHNTZW50VGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHJ0dE1zICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBvbmV3YXlEZWxheSA9IHJ0dE1zICogMC41O1xuICAgICAgICAgICAgcmV0dXJuIHJlbW90ZVN0YXRzQXJyaXZlZFRpbWVzdGFtcCAtIChyZW1vdGVTdGF0c1NlbnRUaW1lc3RhbXAgKyBvbmV3YXlEZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ291bGQgbm90IGdldCBzdGF0cyB0byBjYWxjdWxhdGUgc2VuZGVyL3JlY2VpdmVyIGNsb2NrIG9mZnNldFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJUVE1zKHN0YXRzKSB7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgaXQgZnJvbSB0aGUgYWN0aXZlIGNhbmRpZGF0ZSBwYWlyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUNhbmRpZGF0ZVBhaXIgPSBzdGF0cy5nZXRBY3RpdmVDYW5kaWRhdGVQYWlyKCk7XG4gICAgICAgIGlmICghIWFjdGl2ZUNhbmRpZGF0ZVBhaXIgJiYgYWN0aXZlQ2FuZGlkYXRlUGFpci5jdXJyZW50Um91bmRUcmlwVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJSVFRTZWNvbmRzID0gYWN0aXZlQ2FuZGlkYXRlUGFpci5jdXJyZW50Um91bmRUcmlwVGltZTtcbiAgICAgICAgICAgIHJldHVybiBjdXJSVFRTZWNvbmRzICogMTAwMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZXh0IHRyeSB0byBnZXQgaXQgZnJvbSByZW1vdGUtb3V0Ym91bmQtcnRwIHZpZGVvIHN0YXRzXG4gICAgICAgIGlmICghIXN0YXRzLnJlbW90ZU91dGJvdW5kVmlkZW9TdGF0cyAmJlxuICAgICAgICAgICAgc3RhdHMucmVtb3RlT3V0Ym91bmRWaWRlb1N0YXRzLnRvdGFsUm91bmRUcmlwVGltZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzdGF0cy5yZW1vdGVPdXRib3VuZFZpZGVvU3RhdHMucm91bmRUcmlwVGltZU1lYXN1cmVtZW50cyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzdGF0cy5yZW1vdGVPdXRib3VuZFZpZGVvU3RhdHMucm91bmRUcmlwVGltZU1lYXN1cmVtZW50cyA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGF2Z1J0dFNlY29uZHMgPSBzdGF0cy5yZW1vdGVPdXRib3VuZFZpZGVvU3RhdHMudG90YWxSb3VuZFRyaXBUaW1lIC9cbiAgICAgICAgICAgICAgICBzdGF0cy5yZW1vdGVPdXRib3VuZFZpZGVvU3RhdHMucm91bmRUcmlwVGltZU1lYXN1cmVtZW50cztcbiAgICAgICAgICAgIHJldHVybiBhdmdSdHRTZWNvbmRzICogMTAwMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZXh0IHRyeSB0byBnZXQgaXQgZnJvbSByZW1vdGUtb3V0Ym91bmQtcnRwIGF1ZGlvIHN0YXRzXG4gICAgICAgIGlmICghIXN0YXRzLnJlbW90ZU91dGJvdW5kQXVkaW9TdGF0cyAmJlxuICAgICAgICAgICAgc3RhdHMucmVtb3RlT3V0Ym91bmRBdWRpb1N0YXRzLnRvdGFsUm91bmRUcmlwVGltZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzdGF0cy5yZW1vdGVPdXRib3VuZEF1ZGlvU3RhdHMucm91bmRUcmlwVGltZU1lYXN1cmVtZW50cyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzdGF0cy5yZW1vdGVPdXRib3VuZEF1ZGlvU3RhdHMucm91bmRUcmlwVGltZU1lYXN1cmVtZW50cyA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGF2Z1J0dFNlY29uZHMgPSBzdGF0cy5yZW1vdGVPdXRib3VuZEF1ZGlvU3RhdHMudG90YWxSb3VuZFRyaXBUaW1lIC9cbiAgICAgICAgICAgICAgICBzdGF0cy5yZW1vdGVPdXRib3VuZEF1ZGlvU3RhdHMucm91bmRUcmlwVGltZU1lYXN1cmVtZW50cztcbiAgICAgICAgICAgIHJldHVybiBhdmdSdHRTZWNvbmRzICogMTAwMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBsYXRlbmN5IGluZm9ybWF0aW9uIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIFdlYlJUQyBBUEkuXG4gKiBNb3N0IHN0YXRzIGFyZSBjYWxjdWxhdGVkIGZvbGxvd2luZyB0aGUgc3BlYzpcbiAqIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJydGMtc3RhdHMvI2RpY3Rpb25hcnktcnRjaW5ib3VuZHJ0cHN0cmVhbXN0YXRzLW1lbWJlcnNcbiAqL1xuZXhwb3J0IGNsYXNzIExhdGVuY3lJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHRha2VuIGZyb20gdGhlIG1vbWVudCBhIGZyYW1lIGlzIGRvbmUgY2FwdHVyaW5nIHRvIHRoZSBtb21lbnQgaXQgaXMgc2VudCBvdmVyIHRoZSBuZXR3b3JrLlxuICAgICAgICAgKiBOb3RlOiBUaGlzIGNhbiBvbmx5IGJlIGNhbGN1bGF0ZWQgaWYgYm90aCBvZmZlciBhbmQgYW5zd2VyIGNvbnRhaW4gdGhlXG4gICAgICAgICAqIHRoZSBSVFAgaGVhZGVyIGV4dGVuc2lvbiBmb3IgYHZpZGVvLXRpbWluZ2AgKENocm9tZSBvbmx5IGZvciBub3cpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbmRlckxhdGVuY3lNcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHRha2VuIGZyb20gdGhlIG1vbWVudCBhIGZyYW1lIGlzIGRvbmUgY2FwdHVyaW5nIHRvIHRoZSBtb21lbnQgaXQgaXMgc2VudCBvdmVyIHRoZSBuZXR3b3JrLlxuICAgICAgICAgKiBOb3RlOiBUaGlzIGNhbiBvbmx5IGJlIGNhbGN1bGF0ZWQgaWYgYm90aCBvZmZlciBhbmQgYW5zd2VyIGNvbnRhaW4gdGhlXG4gICAgICAgICAqIHRoZSBSVFAgaGVhZGVyIGV4dGVuc2lvbiBmb3IgYGFicy1jYXB0dXJlLXRpbWVgIChDaHJvbWUgb25seSBmb3Igbm93KVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZW5kZXJMYXRlbmN5QWJzQ2FwdHVyZVRpbWVNcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyogVGhlIHJvdW5kIHRyaXAgdGltZSAobWlsbGlzZWNvbmRzKSBiZXR3ZWVuIGVhY2ggc2VuZGVyLT5yZWNlaXZlci0+c2VuZGVyICovXG4gICAgICAgIHRoaXMucnR0TXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qIEF2ZXJhZ2UgdGltZSB0YWtlbiAobWlsbGlzZWNvbmRzKSBmcm9tIHZpZGVvIHBhY2tldCByZWNlaXB0IHRvIHBvc3QtZGVjb2RlLiAqL1xuICAgICAgICB0aGlzLmF2ZXJhZ2VQcm9jZXNzaW5nRGVsYXlNcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyogQXZlcmFnZSB0aW1lIHRha2VuIChtaWxsaXNlY29uZHMpIGluc2lkZSB0aGUgaml0dGVyIGJ1ZmZlciAod2hpY2ggaXMgcG9zdC1yZWNlaXB0IGJ1dCBwcmUtZGVjb2RlKS4gKi9cbiAgICAgICAgdGhpcy5hdmVyYWdlSml0dGVyQnVmZmVyRGVsYXlNcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyogQXZlcmFnZSB0aW1lIHRha2VuIChtaWxsaXNlY29uZHMpIHRvIGRlY29kZSBhIHZpZGVvIGZyYW1lLiAqL1xuICAgICAgICB0aGlzLmF2ZXJhZ2VEZWNvZGVMYXRlbmN5TXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qIEF2ZXJhZ2UgdGltZSB0YWtlbiAobWlsbGlzZWNvbmRzKSB0byBiZXR3ZWVuIHJlY2VpcHQgb2YgdGhlIGZpcnN0IGFuZCBsYXN0IHZpZGVvIHBhY2tldCBvZiBhLiAqL1xuICAgICAgICB0aGlzLmF2ZXJhZ2VBc3NlbWJseURlbGF5TXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qIFRoZSBzZW5kZXIgbGF0ZW5jeSArIFJUVC8yICsgcHJvY2Vzc2luZyBkZWxheSAqL1xuICAgICAgICB0aGlzLmF2ZXJhZ2VFMkVMYXRlbmN5ID0gdW5kZWZpbmVkO1xuICAgICAgICAvKiBUaW1pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHdvcnN0IHBlcmZvcm1pbmcgZnJhbWUgc2luY2UgdGhlIGxhc3QgZ2V0U3RhdHMgY2FsbCAob25seSB3b3JrcyBvbiBDaHJvbWUpICovXG4gICAgICAgIHRoaXMuZnJhbWVUaW1pbmcgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGF0ZW5jeUNhbGN1bGF0b3IuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogT3V0Ym91bmQgUlRQIHN0YXRzIGNvbGxlY3RlZCBmcm9tIHRoZSBSVEMgU3RhdHMgUmVwb3J0IHVuZGVyIGBvdXRib3VuZC1ydHBgLlxuICogV3JhcHBlciBhcm91bmQ6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENPdXRib3VuZFJ0cFN0cmVhbVN0YXRzXG4gKiBUaGVzZSBhcmUgc3RhdHMgZm9yIHZpZGVvIHdlIGFyZSBzZW5kaW5nIHRvIGEgcmVtb3RlIHBlZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBPdXRib3VuZFJUUFN0YXRzIHtcbn1cbi8qKlxuICogUmVtb3RlIG91dGJvdW5kIHN0YXRzIGNvbGxlY3RlZCBmcm9tIHRoZSBSVEMgU3RhdHMgUmVwb3J0IHVuZGVyIGByZW1vdGUtb3V0Ym91bmQtcnRwYC5cbiAqIFdyYXBwZXIgYXJvdW5kOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUlRDUmVtb3RlT3V0Ym91bmRSdHBTdHJlYW1TdGF0c1xuICogVGhlc2UgYXJlIHN0YXRzIGZvciBtZWRpYSB3ZSBhcmUgcmVjZWl2aW5nIGZyb20gYSByZW1vdGUgcGVlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlbW90ZU91dGJvdW5kUlRQU3RhdHMge1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3V0Qm91bmRSVFBTdGF0cy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG5pbXBvcnQgeyBPcHRpb25QYXJhbWV0ZXJzLCBGbGFncyB9IGZyb20gJy4uL0NvbmZpZy9Db25maWcnO1xuaW1wb3J0IHsgQWdncmVnYXRlZFN0YXRzIH0gZnJvbSAnLi9BZ2dyZWdhdGVkU3RhdHMnO1xuaW1wb3J0IHsgcGFyc2VSdHBQYXJhbWV0ZXJzLCBzcGxpdFNlY3Rpb25zIH0gZnJvbSAnc2RwJztcbmltcG9ydCB7IFJUQ1V0aWxzIH0gZnJvbSAnLi4vVXRpbC9SVENVdGlscyc7XG5pbXBvcnQgeyBTRFBVdGlscyB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42JztcbmltcG9ydCB7IExhdGVuY3lDYWxjdWxhdG9yIH0gZnJvbSAnLi9MYXRlbmN5Q2FsY3VsYXRvcic7XG5leHBvcnQgY29uc3Qga0Fic0NhcHR1cmVUaW1lID0gJ2h0dHA6Ly93d3cud2VicnRjLm9yZy9leHBlcmltZW50cy9ydHAtaGRyZXh0L2Ficy1jYXB0dXJlLXRpbWUnO1xuLyoqXG4gKiBIYW5kbGVzIHRoZSBQZWVyIENvbm5lY3Rpb25cbiAqL1xuZXhwb3J0IGNsYXNzIFBlZXJDb25uZWN0aW9uQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFJUQyBQZWVyIENvbm5lY3Rpb24gY2xpZW50XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQZWVyIGNvbm5lY3Rpb24gT3B0aW9uc1xuICAgICAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlnIGZvciBvdXIgUFMgZXhwZXJpZW5jZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjb25maWcsIHByZWZlcnJlZENvZGVjKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmNyZWF0ZVBlZXJDb25uZWN0aW9uKG9wdGlvbnMsIHByZWZlcnJlZENvZGVjKTtcbiAgICAgICAgdGhpcy5sYXRlbmN5Q2FsY3VsYXRvciA9IG5ldyBMYXRlbmN5Q2FsY3VsYXRvcigpO1xuICAgIH1cbiAgICBjcmVhdGVQZWVyQ29ubmVjdGlvbihvcHRpb25zLCBwcmVmZXJyZWRDb2RlYykge1xuICAgICAgICAvLyBTZXQgdGhlIElDRSB0cmFuc3BvcnQgdG8gcmVsYXkgaWYgVFVSTiBlbmFibGVkXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkZvcmNlVFVSTikpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaWNlVHJhbnNwb3J0UG9saWN5ID0gJ3JlbGF5JztcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdGb3JjaW5nIFRVUk4gdXNhZ2UgYnkgc2V0dGluZyBJQ0UgVHJhbnNwb3J0IFBvbGljeSBpbiBwZWVyIGNvbm5lY3Rpb24gY29uZmlnLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1aWxkIGEgbmV3IHBlZXIgY29ubmVjdGlvbiB3aXRoIHRoZSBvcHRpb25zXG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24gPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24ob3B0aW9ucyk7XG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IChldikgPT4gdGhpcy5oYW5kbGVTaWduYWxTdGF0ZUNoYW5nZShldik7XG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoZXYpID0+IHRoaXMuaGFuZGxlSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKGV2KTtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlID0gKGV2KSA9PiB0aGlzLmhhbmRsZUljZUdhdGhlcmluZ1N0YXRlQ2hhbmdlKGV2KTtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbnRyYWNrID0gKGV2KSA9PiB0aGlzLmhhbmRsZU9uVHJhY2soZXYpO1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gKGV2KSA9PiB0aGlzLmhhbmRsZUljZUNhbmRpZGF0ZShldik7XG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25kYXRhY2hhbm5lbCA9IChldikgPT4gdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbChldik7XG4gICAgICAgIHRoaXMuYWdncmVnYXRlZFN0YXRzID0gbmV3IEFnZ3JlZ2F0ZWRTdGF0cygpO1xuICAgICAgICB0aGlzLnByZWZlcnJlZENvZGVjID0gcHJlZmVycmVkQ29kZWM7XG4gICAgICAgIHRoaXMudXBkYXRlQ29kZWNTZWxlY3Rpb24gPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gb2ZmZXIgZm9yIHRoZSBXZWIgUlRDIGhhbmRzaGFrZSBhbmQgc2VuZCB0aGUgb2ZmZXIgdG8gdGhlIHNpZ25hbGluZyBzZXJ2ZXIgdmlhIHdlYnNvY2tldFxuICAgICAqIEBwYXJhbSBvZmZlck9wdGlvbnMgLSBSVEMgT2ZmZXIgT3B0aW9uc1xuICAgICAqL1xuICAgIGNyZWF0ZU9mZmVyKG9mZmVyT3B0aW9ucywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnQ3JlYXRlIE9mZmVyJyk7XG4gICAgICAgICAgICBjb25zdCBpc0xvY2FsaG9zdENvbm5lY3Rpb24gPSBsb2NhdGlvbi5ob3N0bmFtZSA9PT0gJ2xvY2FsaG9zdCcgfHwgbG9jYXRpb24uaG9zdG5hbWUgPT09ICcxMjcuMC4wLjEnO1xuICAgICAgICAgICAgY29uc3QgaXNIdHRwc0Nvbm5lY3Rpb24gPSBsb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gICAgICAgICAgICBsZXQgdXNlTWljID0gY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuVXNlTWljKTtcbiAgICAgICAgICAgIGxldCB1c2VDYW1lcmEgPSBjb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5Vc2VDYW1lcmEpO1xuICAgICAgICAgICAgaWYgKCh1c2VNaWMgfHwgdXNlQ2FtZXJhKSAmJiAhKGlzTG9jYWxob3N0Q29ubmVjdGlvbiB8fCBpc0h0dHBzQ29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB1c2VNaWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB1c2VDYW1lcmEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoJ01pY3JvcGhvbmUgYW5kIFdlYmNhbSBhY2Nlc3MgaW4gdGhlIGJyb3dzZXIgd2lsbCBub3Qgd29yayBpZiB5b3UgYXJlIG5vdCBvbiBIVFRQUyBvciBsb2NhbGhvc3QuIERpc2FibGluZyBtaWMgYW5kIHdlYmNhbSBhY2Nlc3MuJyk7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKFwiRm9yIHRlc3RpbmcgeW91IGNhbiBlbmFibGUgSFRUUCBtaWNyb3Bob25lIGFjY2VzcyBDaHJvbWUgYnkgdmlzaXRpbmcgY2hyb21lOi8vZmxhZ3MvIGFuZCBlbmFibGluZyAndW5zYWZlbHktdHJlYXQtaW5zZWN1cmUtb3JpZ2luLWFzLXNlY3VyZSdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldHVwVHJhbnNjZWl2ZXJzQXN5bmModXNlTWljLCB1c2VDYW1lcmEpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3JlYXRlT2ZmZXIob2ZmZXJPcHRpb25zKS50aGVuKChvZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1RleHRPdmVybGF5Q29ubmVjdGluZygpO1xuICAgICAgICAgICAgICAgICAgICBvZmZlci5zZHAgPSB0aGlzLm11bmdlU0RQKG9mZmVyLnNkcCwgdXNlTWljKTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2VuZFdlYlJUQ09mZmVyKG9mZmVyKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1RleHRPdmVybGF5U2V0dXBGYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY2VpdmUgb2ZmZXIgZnJvbSBVRSBzaWRlIGFuZCBwcm9jZXNzIGl0IGFzIHRoZSByZW1vdGUgZGVzY3JpcHRpb24gb2YgdGhpcyBwZWVyIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICByZWNlaXZlT2ZmZXIob2ZmZXIsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ1JlY2VpdmUgT2ZmZXInKTtcbiAgICAgICAgICAgIC8vIElmIFVFIG9yIEpTU3RyZWFtZXIgZGlkIHNlbmQgYWJzLWNhcHR1cmUtdGltZSBSVFAgaGVhZGVyIGV4dGVuc2lvbiB0byBhIG5vbi1DaHJvbWUgYnJvd3NlclxuICAgICAgICAgICAgLy8gdGhlbiByZW1vdmUgaXQgZnJvbSB0aGUgU0RQIGJlY2F1c2UgaWYgRmlyZWZveCBkZXRlY3RzIGl0IGluIG9mZmVyIG9yIGFuc3dlciBpdCB3aWxsIGZhaWwgdG8gY29ubmVjdFxuICAgICAgICAgICAgLy8gZHVlIGhhdmluZyAxNSBvciBtb3JlIGhlYWRlciBleHRlbnNpb25zOiBodHRwczovL21haWxhcmNoaXZlLmlldGYub3JnL2FyY2gvbXNnL3J0Y3dlYi9RUm5XTnVXekd1TFJvdldkSGtvZE5QNlZPZ2cvXG4gICAgICAgICAgICBpZiAodGhpcy5pc0ZpcmVmb3goKSkge1xuICAgICAgICAgICAgICAgIC8vIGV4YW1wbGU6IGE9ZXh0bWFwOjE1IGh0dHA6Ly93d3cud2VicnRjLm9yZy9leHBlcmltZW50cy9ydHAtaGRyZXh0L2Ficy1jYXB0dXJlLXRpbWVcbiAgICAgICAgICAgICAgICBvZmZlci5zZHAgPSBvZmZlci5zZHAucmVwbGFjZSgvXmE9ZXh0bWFwOlxcZCsgaHR0cDpcXC9cXC93d3dcXC53ZWJydGNcXC5vcmdcXC9leHBlcmltZW50c1xcL3J0cC1oZHJleHRcXC9hYnMtY2FwdHVyZS10aW1lXFxyXFxuL2dtLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEZpcmUgZXZlbnQgZm9yIHdoZW4gcmVtb3RlIG9mZmVyIGRlc2NyaXB0aW9uIGlzIHNldFxuICAgICAgICAgICAgICAgIHRoaXMub25TZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNMb2NhbGhvc3RDb25uZWN0aW9uID0gbG9jYXRpb24uaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnIHx8IGxvY2F0aW9uLmhvc3RuYW1lID09PSAnMTI3LjAuMC4xJztcbiAgICAgICAgICAgICAgICBjb25zdCBpc0h0dHBzQ29ubmVjdGlvbiA9IGxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgICAgICAgICAgICAgICBsZXQgdXNlTWljID0gY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuVXNlTWljKTtcbiAgICAgICAgICAgICAgICBsZXQgdXNlQ2FtZXJhID0gY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuVXNlQ2FtZXJhKTtcbiAgICAgICAgICAgICAgICBpZiAoKHVzZU1pYyB8fCB1c2VDYW1lcmEpICYmICEoaXNMb2NhbGhvc3RDb25uZWN0aW9uIHx8IGlzSHR0cHNDb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICB1c2VNaWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdXNlQ2FtZXJhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcignTWljcm9waG9uZSBhbmQgV2ViY2FtIGFjY2VzcyBpbiB0aGUgYnJvd3NlciB3aWxsIG5vdCB3b3JrIGlmIHlvdSBhcmUgbm90IG9uIEhUVFBTIG9yIGxvY2FsaG9zdC4gRGlzYWJsaW5nIG1pYyBhbmQgd2ViY2FtIGFjY2Vzcy4nKTtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKFwiRm9yIHRlc3RpbmcgeW91IGNhbiBlbmFibGUgSFRUUCBtaWNyb3Bob25lIGFjY2VzcyBDaHJvbWUgYnkgdmlzaXRpbmcgY2hyb21lOi8vZmxhZ3MvIGFuZCBlbmFibGluZyAndW5zYWZlbHktdHJlYXQtaW5zZWN1cmUtb3JpZ2luLWFzLXNlY3VyZSdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCBvdXIgbGlzdCBvZiBwcmVmZXJyZWQgY29kZWNzLCBpbiBvcmRlciBvZiBwcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0T3B0aW9uU2V0dGluZ09wdGlvbnMoT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRDb2RlYywgdGhpcy5mdXp6eUludGVyc2VjdFVFQW5kQnJvd3NlckNvZGVjcyhvZmZlcikpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBUcmFuc2NlaXZlcnNBc3luYyh1c2VNaWMsIHVzZUNhbWVyYSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNyZWF0ZUFuc3dlcigpLnRoZW4oKEFuc3dlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgQW5zd2VyLnNkcCA9IHRoaXMubXVuZ2VTRFAoQW5zd2VyLnNkcCwgdXNlTWljKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0TG9jYWxEZXNjcmlwdGlvbihBbnN3ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25TZXRMb2NhbERlc2NyaXB0aW9uKChfYSA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbERlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBjcmVhdGVBbnN3ZXIoKSBmYWlsZWQgLSAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgUmVtb3RlIERlc2NyaXB0b3IgZnJvbSB0aGUgc2lnbmFsaW5nIHNlcnZlciB0byB0aGUgUlRDIFBlZXIgQ29ubmVjdGlvblxuICAgICAqIEBwYXJhbSBhbnN3ZXIgLSBSVEMgU2Vzc2lvbiBEZXNjcmlwdG9yIGZyb20gdGhlIFNpZ25hbGluZyBTZXJ2ZXJcbiAgICAgKi9cbiAgICByZWNlaXZlQW5zd2VyKGFuc3dlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAvLyBBZGQgb3VyIGxpc3Qgb2YgcHJlZmVycmVkIGNvZGVjcywgaW4gb3JkZXIgb2YgcHJlZmVyZW5jZVxuICAgICAgICB0aGlzLmNvbmZpZy5zZXRPcHRpb25TZXR0aW5nT3B0aW9ucyhPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZENvZGVjLCB0aGlzLmZ1enp5SW50ZXJzZWN0VUVBbmRCcm93c2VyQ29kZWNzKGFuc3dlcikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBBZ2dyZWdhdGVkIFN0YXRzIGFuZCB0aGVuIGZpcmUgYSBvblZpZGVvIFN0YXRzIGV2ZW50XG4gICAgICovXG4gICAgZ2VuZXJhdGVTdGF0cygpIHtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5nZXRTdGF0cygpLnRoZW4oKHN0YXRzRGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZ2dyZWdhdGVkU3RhdHMucHJvY2Vzc1N0YXRzKHN0YXRzRGF0YSk7XG4gICAgICAgICAgICB0aGlzLm9uVmlkZW9TdGF0cyh0aGlzLmFnZ3JlZ2F0ZWRTdGF0cyk7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgbGF0ZW5jeSB1c2luZyBzdGF0cyBhbmQgdmlkZW8gcmVjZWl2ZXJzIGFuZCB0aGVuIGNhbGwgdGhlIGhhbmRsaW5nIGZ1bmN0aW9uXG4gICAgICAgICAgICBjb25zdCBsYXRlbmN5SW5mbyA9IHRoaXMubGF0ZW5jeUNhbGN1bGF0b3IuY2FsY3VsYXRlKHRoaXMuYWdncmVnYXRlZFN0YXRzLCB0aGlzLnBlZXJDb25uZWN0aW9uLmdldFJlY2VpdmVycygpKTtcbiAgICAgICAgICAgIHRoaXMub25MYXRlbmN5Q2FsY3VsYXRlZChsYXRlbmN5SW5mbyk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByZWZlcnJlZCBjb2RlYyBzZWxlY3Rpb24gYmFzZWQgb24gd2hhdCB3YXMgYWN0dWFsbHkgbmVnb3RpYXRlZFxuICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlQ29kZWNTZWxlY3Rpb24gJiYgISF0aGlzLmFnZ3JlZ2F0ZWRTdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5jb2RlY0lkKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBxdWFsaWZpZWQgY29kZWMgbmFtZSBmcm9tIHRoZSBtaW1ldHlwZSBhbmQgZm10cFxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVjU3RhdHMgPSB0aGlzLmFnZ3JlZ2F0ZWRTdGF0cy5jb2RlY3MuZ2V0KHRoaXMuYWdncmVnYXRlZFN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmNvZGVjSWQpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlY1N0YXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlY1Nob3J0bmFtZSA9IGNvZGVjU3RhdHMubWltZVR5cGUucmVwbGFjZSgndmlkZW8vJywgJycpO1xuICAgICAgICAgICAgICAgIGxldCBmdWxsQ29kZWNOYW1lID0gY29kZWNTaG9ydG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVjU3RhdHMuc2RwRm10cExpbmUgJiYgY29kZWNTdGF0cy5zZHBGbXRwTGluZS50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxDb2RlY05hbWUgPSBgJHtjb2RlY1Nob3J0bmFtZX0gJHtjb2RlY1N0YXRzLnNkcEZtdHBMaW5lLnRyaW0oKX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhbGxCcm93c2VyQ29kZWNzID0gdGhpcy5jb25maWcuZ2V0U2V0dGluZ09wdGlvbihPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZENvZGVjKS5vcHRpb25zO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBsaXN0IG9mIGNvZGVjcyBkaXJlY3RseSBjb250YWlucyB0aGUgb25lIHRoYXQgd2FzIG5lZ290aWF0ZWQsIHNlbGVjdCB0aGF0XG4gICAgICAgICAgICAgICAgaWYgKGFsbEJyb3dzZXJDb2RlY3MuaW5jbHVkZXMoZnVsbENvZGVjTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0T3B0aW9uU2V0dGluZ1ZhbHVlKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkQ29kZWMsIGZ1bGxDb2RlY05hbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkbid0IG1hdGNoIG9uIHRoZSBmdWxsIG5hbWUsIHRyeSB0byBtYXRjaCBvbiBqdXN0IHRoZSBjb2RlYyBzaG9ydG5hbWVcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZExpc3QgPSBhbGxCcm93c2VyQ29kZWNzLmZpbHRlcigob3B0aW9uKSA9PiBvcHRpb24uaW5kZXhPZihjb2RlY1Nob3J0bmFtZSkgIT09IC0xKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWRMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0T3B0aW9uU2V0dGluZ1ZhbHVlKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkQ29kZWMsIGZpbHRlcmVkTGlzdFswXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSBUaGUgUGVlciBDb25uZWN0aW9uXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgdGhlIFNlc3Npb24gRGVzY3JpcHRvclxuICAgICAqIEBwYXJhbSBzZHAgLSBTZXNzaW9uIERlc2NyaXB0b3IgYXMgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gdXNlTWljIC0gSXMgdGhlIG1pY3JvcGhvbmUgaW4gdXNlXG4gICAgICogQHJldHVybnMgQSBtb2RpZmllZCBTZXNzaW9uIERlc2NyaXB0b3JcbiAgICAgKi9cbiAgICBtdW5nZVNEUChzZHAsIHVzZU1pYykge1xuICAgICAgICBsZXQgbXVuZ2VkU0RQID0gc2RwLnJlcGxhY2UoLyhhPWZtdHA6XFxkKyAuKmxldmVsLWFzeW1tZXRyeS1hbGxvd2VkPS4qKVxcclxcbi9nbSwgJyQxO3gtZ29vZ2xlLXN0YXJ0LWJpdHJhdGU9MTAwMDA7eC1nb29nbGUtbWF4LWJpdHJhdGU9MTAwMDAwXFxyXFxuJyk7XG4gICAgICAgIC8vIHNldCBtYXggYml0cmF0ZSB0byBoaWdoZXN0IGJpdHJhdGUgT3B1cyBzdXBwb3J0c1xuICAgICAgICBsZXQgYXVkaW9TRFAgPSAnbWF4YXZlcmFnZWJpdHJhdGU9NTEwMDAwOyc7XG4gICAgICAgIGlmICh1c2VNaWMpIHtcbiAgICAgICAgICAgIC8vIHNldCB0aGUgbWF4IGNhcHR1cmUgcmF0ZSB0byA0OGtoeiAoc28gd2UgY2FuIHNlbmQgaGlnaCBxdWFsaXR5IGF1ZGlvIGZyb20gbWljKVxuICAgICAgICAgICAgYXVkaW9TRFAgKz0gJ3Nwcm9wLW1heGNhcHR1cmVyYXRlPTQ4MDAwOyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yY2UgbW9ubyBvciBzdGVyZW8gYmFzZWQgb24gd2hldGhlciA/Zm9yY2VNb25vIHdhcyBwYXNzZWQgb3Igbm90XG4gICAgICAgIGF1ZGlvU0RQICs9IHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuRm9yY2VNb25vQXVkaW8pID8gJ3N0ZXJlbz0wOycgOiAnc3RlcmVvPTE7JztcbiAgICAgICAgLy8gZW5hYmxlIGluLWJhbmQgZm9yd2FyZCBlcnJvciBjb3JyZWN0aW9uIGZvciBvcHVzIGF1ZGlvXG4gICAgICAgIGF1ZGlvU0RQICs9ICd1c2VpbmJhbmRmZWM9MSc7XG4gICAgICAgIC8vIFdlIHVzZSB0aGUgbGluZSAndXNlaW5iYW5kZmVjPTEnICh3aGljaCBPcHVzIHVzZXMpIHRvIHNldCBvdXIgT3B1cyBzcGVjaWZpYyBhdWRpbyBwYXJhbWV0ZXJzLlxuICAgICAgICBtdW5nZWRTRFAgPSBtdW5nZWRTRFAucmVwbGFjZSgndXNlaW5iYW5kZmVjPTEnLCBhdWRpb1NEUCk7XG4gICAgICAgIC8vIEFkZCBhYnMtY2FwdHVyZS10aW1lIFJUUCBoZWFkZXIgZXh0ZW5zaW9uIGlmIHdlIGhhdmUgZW5hYmxlZCB0aGUgc2V0dGluZy5cbiAgICAgICAgLy8gTm90ZTogQXMgYXQgRmViIDIwMjUsIENocm9taXVtIGJhc2VkIGJyb3dzZXJzIGFyZSB0aGUgb25seSBvbmVzIHRoYXQgc3VwcG9ydCB0aGlzIGFuZFxuICAgICAgICAvLyBtdW5naW5nIGl0IGludG8gdGhlIGFuc3dlciBpbiBGaXJlZm94IHdpbGwgY2F1c2UgdGhlIGNvbm5lY3Rpb24gdG8gZmFpbC5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuRW5hYmxlQ2FwdHVyZVRpbWVFeHQpICYmICF0aGlzLmlzRmlyZWZveCgpKSB7XG4gICAgICAgICAgICBtdW5nZWRTRFAgPSBTRFBVdGlscy5hZGRWaWRlb0hlYWRlckV4dGVuc2lvblRvU2RwKG11bmdlZFNEUCwga0Fic0NhcHR1cmVUaW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXVuZ2VkU0RQO1xuICAgIH1cbiAgICBpc0ZpcmVmb3goKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gYSBJY2UgQ2FuZGlkYXRlIGlzIHJlY2VpdmVkIGFkZCB0byB0aGUgUlRDIFBlZXIgQ29ubmVjdGlvblxuICAgICAqIEBwYXJhbSBpY2VDYW5kaWRhdGUgLSBSVEMgSWNlIENhbmRpZGF0ZSBmcm9tIHRoZSBTaWduYWxpbmcgU2VydmVyXG4gICAgICovXG4gICAgaGFuZGxlT25JY2UoaWNlQ2FuZGlkYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ3BlZXJjb25uZWN0aW9uIGhhbmRsZU9uSWNlJyk7XG4gICAgICAgIC8vIC8vIGlmIGZvcmNpbmcgVFVSTiwgcmVqZWN0IGFueSBjYW5kaWRhdGVzIG5vdCByZWxheVxuICAgICAgICBpZiAodGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5Gb3JjZVRVUk4pKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBubyByZWxheSBhZGRyZXNzIGlzIGZvdW5kLCBpZiBzbywgd2UgYXJlIGFzc3VtaW5nIGl0IG1lYW5zIG5vIFRVUk4gc2VydmVyXG4gICAgICAgICAgICBpZiAoaWNlQ2FuZGlkYXRlLmNhbmRpZGF0ZS5pbmRleE9mKCdyZWxheScpIDwgMCkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5JbmZvKGBEcm9wcGluZyBjYW5kaWRhdGUgYmVjYXVzZSBpdCB3YXMgbm90IFRVUk4gcmVsYXkuIHwgVHlwZT0gJHtpY2VDYW5kaWRhdGUudHlwZX0gfCBQcm90b2NvbD0gJHtpY2VDYW5kaWRhdGUucHJvdG9jb2x9IHwgQWRkcmVzcz0ke2ljZUNhbmRpZGF0ZS5hZGRyZXNzfSB8IFBvcnQ9JHtpY2VDYW5kaWRhdGUucG9ydH0gfGApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkSWNlQ2FuZGlkYXRlKGljZUNhbmRpZGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIFJUQyBQZWVyIENvbm5lY3Rpb24gU2lnbmFsaW5nIHNlcnZlciBzdGF0ZSBDaGFuZ2VzXG4gICAgICogQHBhcmFtIHN0YXRlIC0gU2lnbmFsaW5nIFNlcnZlciBTdGF0ZSBDaGFuZ2UgRXZlbnRcbiAgICAgKi9cbiAgICBoYW5kbGVTaWduYWxTdGF0ZUNoYW5nZShzdGF0ZSkge1xuICAgICAgICBMb2dnZXIuSW5mbygnc2lnbmFsaW5nIHN0YXRlIGNoYW5nZTogJyArIHN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHdoZW4gdGhlIEljZSBDb25uZWN0aW9uIFN0YXRlIENoYW5nZXNcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJY2UgQ29ubmVjdGlvbiBTdGF0ZVxuICAgICAqL1xuICAgIGhhbmRsZUljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZShzdGF0ZSkge1xuICAgICAgICBMb2dnZXIuSW5mbygnaWNlIGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlOiAnICsgc3RhdGUpO1xuICAgICAgICB0aGlzLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHdoZW4gdGhlIEljZSBHYXRoZXJpbmcgU3RhdGUgQ2hhbmdlc1xuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEljZSBHYXRoZXJpbmcgU3RhdGUgQ2hhbmdlXG4gICAgICovXG4gICAgaGFuZGxlSWNlR2F0aGVyaW5nU3RhdGVDaGFuZ2Uoc3RhdGUpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ2ljZSBnYXRoZXJpbmcgc3RhdGUgY2hhbmdlOiAnICsgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIHRoZSBvblRyYWNrIG1ldGhvZFxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSB3ZWJSdGMgdHJhY2sgZXZlbnRcbiAgICAgKi9cbiAgICBoYW5kbGVPblRyYWNrKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5zdHJlYW1zLmxlbmd0aCA8IDEgfHwgZXZlbnQuc3RyZWFtc1swXS5pZCA9PSAncHJvYmF0b3InKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LnRyYWNrLmtpbmQgPT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgdGhpcy52aWRlb1RyYWNrID0gZXZlbnQudHJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LnRyYWNrLmtpbmQgPT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgdGhpcy5hdWRpb1RyYWNrID0gZXZlbnQudHJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblRyYWNrKGV2ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIHRoZSBvblBlZXJJY2VDYW5kaWRhdGVcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgcGVlciBpY2UgY2FuZGlkYXRlXG4gICAgICovXG4gICAgaGFuZGxlSWNlQ2FuZGlkYXRlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMub25QZWVySWNlQ2FuZGlkYXRlKGV2ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIHRoZSBvbkRhdGFDaGFubmVsXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIHBlZXIncyBkYXRhIGNoYW5uZWxcbiAgICAgKi9cbiAgICBoYW5kbGVEYXRhQ2hhbm5lbChldmVudCkge1xuICAgICAgICB0aGlzLm9uRGF0YUNoYW5uZWwoZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBvdmVycmlkZSBtZXRob2QgZm9yIG9uVHJhY2sgZm9yIHVzZSBvdXRzaWRlIG9mIHRoZSBQZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gdHJhY2tFdmVudCAtIFRoZSB3ZWJSdGMgdHJhY2sgZXZlbnRcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb25UcmFjayh0cmFja0V2ZW50KSB7XG4gICAgICAgIC8vIERlZmF1bHQgRnVuY3Rpb25hbGl0eTogRG8gTm90aGluZ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBvdmVycmlkZSBtZXRob2QgZm9yIG9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlIGZvciB1c2Ugb3V0c2lkZSBvZiB0aGUgUGVlckNvbm5lY3Rpb25Db250cm9sbGVyXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIHdlYlJ0YyBpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgZXZlbnRcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBGdW5jdGlvbmFsaXR5OiBEbyBOb3RoaW5nXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIG92ZXJyaWRlIG1ldGhvZCBmb3Igb25QZWVySWNlQ2FuZGlkYXRlIGZvciB1c2Ugb3V0c2lkZSBvZiB0aGUgUGVlckNvbm5lY3Rpb25Db250cm9sbGVyXG4gICAgICogQHBhcmFtIHBlZXJDb25uZWN0aW9uSWNlRXZlbnQgLSBUaGUgcGVlciBpY2UgY2FuZGlkYXRlXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIG9uUGVlckljZUNhbmRpZGF0ZShwZWVyQ29ubmVjdGlvbkljZUV2ZW50KSB7XG4gICAgICAgIC8vIERlZmF1bHQgRnVuY3Rpb25hbGl0eTogRG8gTm90aGluZ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBvdmVycmlkZSBtZXRob2QgZm9yIG9uRGF0YUNoYW5uZWwgZm9yIHVzZSBvdXRzaWRlIG9mIHRoZSBQZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gZGF0YWNoYW5uZWxFdmVudCAtIFRoZSBwZWVyJ3MgZGF0YSBjaGFubmVsXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIG9uRGF0YUNoYW5uZWwoZGF0YWNoYW5uZWxFdmVudCkge1xuICAgICAgICAvLyBEZWZhdWx0IEZ1bmN0aW9uYWxpdHk6IERvIE5vdGhpbmdcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gVUUgYW5kIGJyb3dzZXIgY29kZWNzLCB3aXRoIGZ1enp5IG1hdGNoaW5nIGlmIHNvbWUgcGFyYW1ldGVycyBhcmUgbWlzbWF0Y2hlZC5cbiAgICAgKiBAcGFyYW0gc2RwIFRoZSByZW1vdGUgc2RwXG4gICAgICogQHJldHVybnMgVGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIGJyb3dzZXIgc3VwcG9ydGVkIGNvZGVjcyBhbmQgdWUgc3VwcG9ydGVkIGNvZGVjcy5cbiAgICAgKi9cbiAgICBmdXp6eUludGVyc2VjdFVFQW5kQnJvd3NlckNvZGVjcyhzZHApIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBidWlsZCBhbiBhcnJheSBvZiBhbGwgc3VwcG9ydGVkIGNvZGVjcyBvbiBib3RoIHNpZGVzXG4gICAgICAgIGNvbnN0IGFsbFN1cHBvcnRlZENvZGVjcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICBjb25zdCBhbGxVRUNvZGVjcyA9IHRoaXMucGFyc2VBdmFpbGFibGVDb2RlY3Moc2RwKTtcbiAgICAgICAgY29uc3QgYWxsQnJvd3NlckNvZGVjcyA9IHRoaXMuY29uZmlnLmdldFNldHRpbmdPcHRpb24oT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRDb2RlYykub3B0aW9ucztcbiAgICAgICAgZm9yIChjb25zdCB1ZUNvZGVjIG9mIGFsbFVFQ29kZWNzKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBicm93c2VyIGNvZGVjcyBkaXJlY3RseSBtYXRjaGVzIFVFIGNvZGVjICh3aXRoIHBhcmFtZXRlcnMgYW5kIGV2ZXJ5dGhpbmcpXG4gICAgICAgICAgICBpZiAoYWxsQnJvd3NlckNvZGVjcy5pbmNsdWRlcyh1ZUNvZGVjKSkge1xuICAgICAgICAgICAgICAgIGFsbFN1cHBvcnRlZENvZGVjcy5wdXNoKHVlQ29kZWMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGNoZWNrIGlmIGJyb3dzZXIgY29kZWMgYXQgbGVhc3QgY29udGFpbnMgYSBtYXRjaCBmb3IgdGhlIFVFIGNvZGVjIG5hbWUgKHdpdGhvdXQgcGFyYW1ldGVycykuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1ZUNvZGVjTmFtZUFuZFBhcmFtcyA9IHVlQ29kZWMuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1ZUNvZGVjTmFtZSA9IHVlQ29kZWNOYW1lQW5kUGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYnJvd3NlckNvZGVjIG9mIGFsbEJyb3dzZXJDb2RlY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyb3dzZXJDb2RlYy5pbmNsdWRlcyh1ZUNvZGVjTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHBhc3MgYnJvd3NlciBjb2RlYyBoZXJlIGFzIHRoZXkgb3B0aW9uIGNvbnRhaW4gZXh0cmEgcGFyYW1ldGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbFN1cHBvcnRlZENvZGVjcy5wdXNoKGJyb3dzZXJDb2RlYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxsU3VwcG9ydGVkQ29kZWNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXR1cCB0cmFja3Mgb24gdGhlIFJUQyBQZWVyIENvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0gdXNlTWljIC0gaXMgbWljIGluIHVzZVxuICAgICAqIEBwYXJhbSB1c2VDYW1lcmEgLSBpcyB3ZWJjYW0gaW4gdXNlXG4gICAgICovXG4gICAgc2V0dXBUcmFuc2NlaXZlcnNBc3luYyh1c2VNaWMsIHVzZUNhbWVyYSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgICAgIGxldCBoYXNWaWRlb1JlY2VpdmVyID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zY2VpdmVyIG9mIChfYiA9IChfYSA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRUcmFuc2NlaXZlcnMoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNjZWl2ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIucmVjZWl2ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sgJiZcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sua2luZCA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICAgICAgICBoYXNWaWRlb1JlY2VpdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0dXAgYSB0cmFuc2NlaXZlciBmb3Igc2VuZGluZyB3ZWJjYW0gdmlkZW8gdG8gVUUgYW5kIHJlY2VpdmluZyB2aWRlbyBmcm9tIFVFXG4gICAgICAgICAgICBpZiAoIXVzZUNhbWVyYSkge1xuICAgICAgICAgICAgICAgIGlmICghaGFzVmlkZW9SZWNlaXZlcikge1xuICAgICAgICAgICAgICAgICAgICAoX2MgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJywgeyBkaXJlY3Rpb246ICdyZWN2b25seScgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5zZXR1cFZpZGVvU2VuZGVyKGhhc1ZpZGVvUmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFJUQ1J0cFJlY2VpdmVyLmdldENhcGFiaWxpdGllcyAmJiB0aGlzLnByZWZlcnJlZENvZGVjICE9ICcnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0cmFuc2NlaXZlciBvZiAoX2UgPSAoX2QgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZ2V0VHJhbnNjZWl2ZXJzKCkpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIucmVjZWl2ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAndmlkZW8nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5zZXRDb2RlY1ByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgb3VyIHByZWZlcnJlZCBjb2RlYyBmcm9tIHRoZSBjb2RlY3Mgb3B0aW9ucyBkcm9wIGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZlcnJlZFJUUENvZGVjID0gdGhpcy5wcmVmZXJyZWRDb2RlYy5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZmVycmVkUlRDUnRwQ29kZWNDYXBhYmlsaXR5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiAndmlkZW8vJyArIHByZWZlcnJlZFJUUENvZGVjWzBdIC8qIE5hbWUgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvY2tSYXRlOiA5MDAwMCAvKiBBbGwgY3VycmVudCB2aWRlbyBmb3JtYXRzIGluIGJyb3dzZXJzIGhhdmUgOTBraHogY2xvY2sgcmF0ZSAqLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZHBGbXRwTGluZTogcHJlZmVycmVkUlRQQ29kZWNbMV0gPyBwcmVmZXJyZWRSVFBDb2RlY1sxXSA6ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgYSBsaXN0IG9mIGNvZGVjcyB3ZSB3aWxsIHN1cHBvcnQgd2l0aCBvdXIgcHJlZmVycmVkIG9uZSBpbiB0aGUgZmlyc3QgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG91clN1cHBvcnRlZENvZGVjcyA9IFtwcmVmZXJyZWRSVENSdHBDb2RlY0NhcGFiaWxpdHldO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBhbGwgY29kZWNzIHRoZSBicm93c2VyIHN1cHBvcnRzIGFuZCBhZGQgdGhlbSB0byB0aGUgbGlzdCAoaW4gYW55IG9yZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgUlRDUnRwUmVjZWl2ZXIuZ2V0Q2FwYWJpbGl0aWVzKCd2aWRlbycpLmNvZGVjcy5mb3JFYWNoKChicm93c2VyU3VwcG9ydGVkQ29kZWMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBhZGQgb3VyIHByZWZlcnJlZCBjb2RlYyBhZ2FpbiwgYnV0IGFkZCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnJvd3NlclN1cHBvcnRlZENvZGVjLm1pbWVUeXBlICE9IHByZWZlcnJlZFJUQ1J0cENvZGVjQ2FwYWJpbGl0eS5taW1lVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXJTdXBwb3J0ZWRDb2RlY3MucHVzaChicm93c2VyU3VwcG9ydGVkQ29kZWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoYnJvd3NlclN1cHBvcnRlZENvZGVjID09PSBudWxsIHx8IGJyb3dzZXJTdXBwb3J0ZWRDb2RlYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3NlclN1cHBvcnRlZENvZGVjLnNkcEZtdHBMaW5lKSAhPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocHJlZmVycmVkUlRDUnRwQ29kZWNDYXBhYmlsaXR5ID09PSBudWxsIHx8IHByZWZlcnJlZFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlZmVycmVkUlRDUnRwQ29kZWNDYXBhYmlsaXR5LnNkcEZtdHBMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXJTdXBwb3J0ZWRDb2RlY3MucHVzaChicm93c2VyU3VwcG9ydGVkQ29kZWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb2RlYyBvZiBvdXJTdXBwb3J0ZWRDb2RlY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvZGVjID09PSBudWxsIHx8IGNvZGVjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2RlYy5zZHBGbXRwTGluZSkgPT09IHVuZGVmaW5lZCB8fCBjb2RlYy5zZHBGbXRwTGluZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgZHluYW1pY2FsbHkgYWRkIG1lbWJlcnMgdG8gdGhlIGNvZGVjLCBzbyBpbnN0ZWFkIHJlbW92ZSB0aGUgZmllbGQgaWYgaXQncyBlbXB0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29kZWMuc2RwRm10cExpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuc2V0Q29kZWNQcmVmZXJlbmNlcyhvdXJTdXBwb3J0ZWRDb2RlY3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhhc0F1ZGlvUmVjZWl2ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNjZWl2ZXIgb2YgKF9nID0gKF9mID0gdGhpcy5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmdldFRyYW5zY2VpdmVycygpKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBbXSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlciAmJlxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlciAmJlxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjayAmJlxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0F1ZGlvUmVjZWl2ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXR1cCBhIHRyYW5zY2VpdmVyIGZvciBzZW5kaW5nIG1pYyBhdWRpbyB0byBVRSBhbmQgcmVjZWl2aW5nIGF1ZGlvIGZyb20gVUVcbiAgICAgICAgICAgIGlmICghdXNlTWljKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNBdWRpb1JlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIChfaCA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5hZGRUcmFuc2NlaXZlcignYXVkaW8nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdyZWN2b25seSdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5zZXR1cEF1ZGlvU2VuZGVyKGhhc0F1ZGlvUmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0dXBWaWRlb1NlbmRlcihoYXNWaWRlb1JlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIG1lZGlhIHNlbmQgb3B0aW9uc1xuICAgICAgICAgICAgY29uc3QgbWVkaWFTZW5kT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB2aWRlbzogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIE5vdGUgdXNpbmcgd2ViY2FtIG9uIGFuZHJvaWQgY2hyb21lIHJlcXVpcmVzIFNTTCBvciBjaHJvbWU6Ly9mbGFncy8gXCJ1bnNhZmVseS10cmVhdC1pbnNlY3VyZS1vcmlnaW4tYXMtc2VjdXJlXCJcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKG1lZGlhU2VuZE9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNWaWRlb1JlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNjZWl2ZXIgb2YgKF9iID0gKF9hID0gdGhpcy5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRyYW5zY2VpdmVycygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJUQ1V0aWxzLmNhblRyYW5zY2VpdmVyUmVjZWl2ZVZpZGVvKHRyYW5zY2VpdmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHJhY2sgb2Ygc3RyZWFtLmdldFRyYWNrcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFjay5raW5kICYmIHRyYWNrLmtpbmQgPT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayh0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnc2VuZHJlY3YnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRyYWNrIG9mIHN0cmVhbS5nZXRUcmFja3MoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrLmtpbmQgJiYgdHJhY2sua2luZCA9PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9jID0gdGhpcy5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFkZFRyYW5zY2VpdmVyKHRyYWNrLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ3NlbmRyZWN2J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNWaWRlb1JlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIChfZCA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hZGRUcmFuc2NlaXZlcigndmlkZW8nLCB7IGRpcmVjdGlvbjogJ3JlY3Zvbmx5JyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXR1cEF1ZGlvU2VuZGVyKGhhc0F1ZGlvUmVjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIC8vIHNldCB0aGUgYXVkaW8gb3B0aW9ucyBiYXNlZCBvbiBtaWMgdXNhZ2VcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBhdXRvR2FpbkNvbnRyb2w6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgICAgICAgICBlY2hvQ2FuY2VsbGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYXRlbmN5OiAwLFxuICAgICAgICAgICAgICAgIG5vaXNlU3VwcHJlc3Npb246IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNhbXBsZVJhdGU6IDQ4MDAwLFxuICAgICAgICAgICAgICAgIHNhbXBsZVNpemU6IDE2LFxuICAgICAgICAgICAgICAgIHZvbHVtZTogMS4wXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gc2V0IHRoZSBtZWRpYSBzZW5kIG9wdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IG1lZGlhU2VuZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdmlkZW86IGZhbHNlLFxuICAgICAgICAgICAgICAgIGF1ZGlvOiBhdWRpb09wdGlvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBOb3RlIHVzaW5nIG1pYyBvbiBhbmRyb2lkIGNocm9tZSByZXF1aXJlcyBTU0wgb3IgY2hyb21lOi8vZmxhZ3MvIFwidW5zYWZlbHktdHJlYXQtaW5zZWN1cmUtb3JpZ2luLWFzLXNlY3VyZVwiXG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShtZWRpYVNlbmRPcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzQXVkaW9SZWNlaXZlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zY2VpdmVyIG9mIChfYiA9IChfYSA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRUcmFuc2NlaXZlcnMoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSVENVdGlscy5jYW5UcmFuc2NlaXZlclJlY2VpdmVBdWRpbyh0cmFuc2NlaXZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRyYWNrIG9mIHN0cmVhbS5nZXRUcmFja3MoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2sua2luZCAmJiB0cmFjay5raW5kID09ICdhdWRpbycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRlci5yZXBsYWNlVHJhY2sodHJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRyZWN2JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0cmFjayBvZiBzdHJlYW0uZ2V0VHJhY2tzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFjay5raW5kICYmIHRyYWNrLmtpbmQgPT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYyA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hZGRUcmFuc2NlaXZlcih0cmFjaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdzZW5kcmVjdidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghaGFzQXVkaW9SZWNlaXZlcikge1xuICAgICAgICAgICAgICAgICAgICAoX2QgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAncmVjdm9ubHknXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuZCBvdmVycmlkZSBldmVudCBmb3Igd2hlbiB0aGUgdmlkZW8gc3RhdHMgYXJlIGZpcmVkXG4gICAgICogQHBhcmFtIGV2ZW50IC0gQWdncmVnYXRlZCBTdGF0c1xuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBvblZpZGVvU3RhdHMoZXZlbnQpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBGdW5jdGlvbmFsaXR5OiBEbyBOb3RoaW5nXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuZCBvdmVycmlkZSBldmVudCBmb3Igd2hlbiBsYXRlbmN5IGluZm8gaXMgY2FsY3VsYXRlZFxuICAgICAqIEBwYXJhbSBsYXRlbmN5SW5mbyAtIENhbGN1bGF0ZWQgbGF0ZW5jeSBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb25MYXRlbmN5Q2FsY3VsYXRlZChsYXRlbmN5SW5mbykge1xuICAgICAgICAvLyBEZWZhdWx0IEZ1bmN0aW9uYWxpdHk6IERvIE5vdGhpbmdcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZlbnQgdG8gc2VuZCB0aGUgUlRDIG9mZmVyIHRvIHRoZSBTaWduYWxpbmcgc2VydmVyXG4gICAgICogQHBhcmFtIG9mZmVyIC0gUlRDIE9mZmVyXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIG9uU2VuZFdlYlJUQ09mZmVyKG9mZmVyKSB7XG4gICAgICAgIC8vIERlZmF1bHQgRnVuY3Rpb25hbGl0eTogRG8gTm90aGluZ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHJlbW90ZSBvZmZlciBkZXNjcmlwdGlvbiBpcyBzZXQuXG4gICAgICogQHBhcmFtIG9mZmVyIC0gUlRDIE9mZmVyXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIG9uU2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBGdW5jdGlvbmFsaXR5OiBEbyBOb3RoaW5nXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmUgd2hlbiBsb2NhbCBkZXNjcmlwdGlvbiBhbnN3ZXIgaXMgc2V0LlxuICAgICAqIEBwYXJhbSBhbnN3ZXIgLSBSVEMgQW5zd2VyXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIG9uU2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBGdW5jdGlvbmFsaXR5OiBEbyBOb3RoaW5nXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIG92ZXJyaWRlIGZvciBzaG93aW5nIHRoZSBQZWVyIGNvbm5lY3Rpb24gY29ubmVjdGluZyBPdmVybGF5XG4gICAgICovXG4gICAgc2hvd1RleHRPdmVybGF5Q29ubmVjdGluZygpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBGdW5jdGlvbmFsaXR5OiBEbyBOb3RoaW5nXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIG92ZXJyaWRlIGZvciBzaG93aW5nIHRoZSBQZWVyIGNvbm5lY3Rpb24gRmFpbGVkIG92ZXJsYXlcbiAgICAgKi9cbiAgICBzaG93VGV4dE92ZXJsYXlTZXR1cEZhaWx1cmUoKSB7XG4gICAgICAgIC8vIERlZmF1bHQgRnVuY3Rpb25hbGl0eTogRG8gTm90aGluZ1xuICAgIH1cbiAgICBwYXJzZUF2YWlsYWJsZUNvZGVjcyhydGNTZXNzaW9uRGVzY3JpcHRpb24pIHtcbiAgICAgICAgLy8gTm8gcG9pbnQgaW4gdXBkYXRpbmcgdGhlIGF2YWlsYWJsZSBjb2RlY3MgaWYgb24gRkZcbiAgICAgICAgaWYgKCFSVENSdHBSZWNlaXZlci5nZXRDYXBhYmlsaXRpZXMpXG4gICAgICAgICAgICByZXR1cm4gWydPbmx5IGF2YWlsYWJsZSBvbiBDaHJvbWUnXTtcbiAgICAgICAgY29uc3QgdWVTdXBwb3J0ZWRDb2RlY3MgPSBbXTtcbiAgICAgICAgY29uc3Qgc2VjdGlvbnMgPSBzcGxpdFNlY3Rpb25zKHJ0Y1Nlc3Npb25EZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAvLyBkaXNjYXJkIHRoZSBzZXNzaW9uIGluZm9ybWF0aW9uIGFzIHdlIG9ubHkgd2FudCBtZWRpYSByZWxhdGVkIGluZm9cbiAgICAgICAgc2VjdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgc2VjdGlvbnMuZm9yRWFjaCgobWVkaWFTZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNvZGVjcyB9ID0gcGFyc2VSdHBQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbik7XG4gICAgICAgICAgICAvLyBGaWx0ZXIgb25seSBmb3IgVlBYIC8gSDI2WCAvIEFWMVxuICAgICAgICAgICAgY29uc3QgbWF0Y2hlciA9IC8oVlBcXGR8SDI2XFxkfEFWMSkuKi87XG4gICAgICAgICAgICBjb2RlY3MuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ciA9IGMubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGMucGFyYW1ldGVycyB8fCB7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKHApID0+IHAgKyAnPScgKyBjLnBhcmFtZXRlcnNbcF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignOycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlci5leGVjKHN0cik7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjLm5hbWUgPT0gJ1ZQOScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVFIGFuc3dlcnMgZG9uJ3Qgc3BlY2lmeSBwcm9maWxlIGJ1dCB3ZSBrbm93IHdlIHdhbnQgcHJvZmlsZSAwXG4gICAgICAgICAgICAgICAgICAgICAgICBjLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb2ZpbGUtaWQnOiAnMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZWNTdHIgPSBjLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGMucGFyYW1ldGVycyB8fCB7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKChwKSA9PiBwICsgJz0nICsgYy5wYXJhbWV0ZXJzW3BdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCc7Jyk7XG4gICAgICAgICAgICAgICAgICAgIHVlU3VwcG9ydGVkQ29kZWNzLnB1c2goY29kZWNTdHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVlU3VwcG9ydGVkQ29kZWNzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBTZXNzaW9uIHN0YXRpc3RpY3NcbiAqL1xuZXhwb3J0IGNsYXNzIFNlc3Npb25TdGF0cyB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXNzaW9uU3RhdHMuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogQ2xhc3MgdG8gaG9sZCB0aGUgc3RyZWFtIHN0YXRzIGRhdGEgY29taW5nIGluIGZyb20gd2ViUnRjXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1TdGF0cyB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdHJlYW1TdGF0cy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgT3B0aW9uUGFyYW1ldGVycyB9IGZyb20gJy4uL0NvbmZpZy9Db25maWcnO1xuaW1wb3J0IHsgV2ViUnRjUGxheWVyQ29udHJvbGxlciB9IGZyb20gJy4uL1dlYlJ0Y1BsYXllci9XZWJSdGNQbGF5ZXJDb250cm9sbGVyJztcbmltcG9ydCB7IEZsYWdzLCBOdW1lcmljUGFyYW1ldGVycyB9IGZyb20gJy4uL0NvbmZpZy9Db25maWcnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuaW1wb3J0IHsgUGl4ZWxTdHJlYW1pbmdFdmVudEVtaXR0ZXIsIEluaXRpYWxTZXR0aW5nc0V2ZW50LCBMYXRlbmN5Q2FsY3VsYXRlZEV2ZW50LCBMYXRlbmN5VGVzdFJlc3VsdEV2ZW50LCBTdGF0c1JlY2VpdmVkRXZlbnQsIFN0cmVhbUxvYWRpbmdFdmVudCwgU3RyZWFtUHJlQ29ubmVjdEV2ZW50LCBTdHJlYW1SZWNvbm5lY3RFdmVudCwgU3RyZWFtUHJlRGlzY29ubmVjdEV2ZW50LCBWaWRlb0VuY29kZXJBdmdRUEV2ZW50LCBWaWRlb0luaXRpYWxpemVkRXZlbnQsIFdlYlJ0Y0F1dG9Db25uZWN0RXZlbnQsIFdlYlJ0Y0Nvbm5lY3RlZEV2ZW50LCBXZWJSdGNDb25uZWN0aW5nRXZlbnQsIFdlYlJ0Y0Rpc2Nvbm5lY3RlZEV2ZW50LCBXZWJSdGNGYWlsZWRFdmVudCwgV2ViUnRjU2RwRXZlbnQsIERhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXNwb25zZUV2ZW50LCBEYXRhQ2hhbm5lbExhdGVuY3lUZXN0UmVzdWx0RXZlbnQsIFBsYXllckNvdW50RXZlbnQsIFdlYlJ0Y1RDUFJlbGF5RGV0ZWN0ZWRFdmVudCwgU3Vic2NyaWJlRmFpbGVkRXZlbnQsIFdlYlJ0Y1NkcE9mZmVyRXZlbnQsIFdlYlJ0Y1NkcEFuc3dlckV2ZW50IH0gZnJvbSAnLi4vVXRpbC9FdmVudEVtaXR0ZXInO1xuaW1wb3J0IHsgV2ViWFJDb250cm9sbGVyIH0gZnJvbSAnLi4vV2ViWFIvV2ViWFJDb250cm9sbGVyJztcbmltcG9ydCB7IE1lc3NhZ2VEaXJlY3Rpb24gfSBmcm9tICcuLi9VZUluc3RhbmNlTWVzc2FnZS9TdHJlYW1NZXNzYWdlQ29udHJvbGxlcic7XG5pbXBvcnQgeyBEYXRhQ2hhbm5lbExhdGVuY3lUZXN0Q29udHJvbGxlciB9IGZyb20gJy4uL0RhdGFDaGFubmVsL0RhdGFDaGFubmVsTGF0ZW5jeVRlc3RDb250cm9sbGVyJztcbmltcG9ydCB7IFJUQ1V0aWxzIH0gZnJvbSAnLi4vVXRpbC9SVENVdGlscyc7XG5pbXBvcnQgeyBJVVJMU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vVXRpbC9JVVJMU2VhcmNoUGFyYW1zJztcbi8qKlxuICogVGhlIGtleSBjbGFzcyBmb3IgdGhlIGJyb3dzZXIgc2lkZSBvZiBhIFBpeGVsIFN0cmVhbWluZyBhcHBsaWNhdGlvbiwgaXQgaW5jbHVkZXM6XG4gKiBXZWJSVEMgaGFuZGxpbmcsIFhSIHN1cHBvcnQsIGlucHV0IGhhbmRsaW5nLCBhbmQgZW1pdHRlcnMgZm9yIGxpZmV0aW1lIGFuZCBzdGF0ZSBjaGFuZ2UgZXZlbnRzLlxuICogVXNlcnMgYXJlIGVuY291cmFnZWQgdG8gdXNlIHRoaXMgY2xhc3MgYXMgaXMsIHRocm91Z2ggY29tcG9zaXRpb24sIG9yIGV4dGVuZCBpdC4gSW4gYW55IGNhc2UsXG4gKiB0aGlzIHdpbGwgbGlrZWx5IGJlIHRoZSBjb3JlIG9mIHlvdXIgUGl4ZWwgU3RyZWFtaW5nIGV4cGVyaWVuY2UgaW4gdGVybXMgb2YgZnVuY3Rpb25hbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBpeGVsU3RyZWFtaW5nIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gQSBuZXdseSBpbnN0YW50aWF0ZWQgY29uZmlnIG9iamVjdFxuICAgICAqIEBwYXJhbSBvdmVycmlkZXMgLSBQYXJhbWV0ZXJzIHRvIG92ZXJyaWRlIGRlZmF1bHQgYmVoYXZpb3VyXG4gICAgICogcmV0dXJucyB0aGUgYmFzZSBQaXhlbCBzdHJlYW1pbmcgb2JqZWN0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBvdmVycmlkZXMpIHtcbiAgICAgICAgdGhpcy5hbGxvd0NvbnNvbGVDb21tYW5kcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgaWYgKG92ZXJyaWRlcyA9PT0gbnVsbCB8fCBvdmVycmlkZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG92ZXJyaWRlcy52aWRlb0VsZW1lbnRQYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvRWxlbWVudFBhcmVudCA9IG92ZXJyaWRlcy52aWRlb0VsZW1lbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyID0gbmV3IFBpeGVsU3RyZWFtaW5nRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJlU2V0dGluZ3MoKTtcbiAgICAgICAgLy8gc2V0dXAgV2ViUlRDXG4gICAgICAgIHRoaXMuc2V0V2ViUnRjUGxheWVyQ29udHJvbGxlcihuZXcgV2ViUnRjUGxheWVyQ29udHJvbGxlcih0aGlzLmNvbmZpZywgdGhpcykpO1xuICAgICAgICB0aGlzLl93ZWJYckNvbnRyb2xsZXIgPSBuZXcgV2ViWFJDb250cm9sbGVyKHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLl9zZXR1cFdlYlJ0Y1RDUFJlbGF5RGV0ZWN0aW9uID0gdGhpcy5fc2V0dXBXZWJSdGNUQ1BSZWxheURldGVjdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSB3ZWJSdGNDb25uZWN0ZWQgZXZlbnRcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYlJ0Y0Nvbm5lY3RlZCcsIChfKSA9PiB7XG4gICAgICAgICAgICAvLyBCaW5kIHRvIHRoZSBzdGF0cyByZWNlaXZlZCBldmVudFxuICAgICAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3N0YXRzUmVjZWl2ZWQnLCB0aGlzLl9zZXR1cFdlYlJ0Y1RDUFJlbGF5RGV0ZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdmlkZW8gc3RyZWFtIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0IHZpZGVvRWxlbWVudFBhcmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl92aWRlb0VsZW1lbnRQYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvRWxlbWVudFBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fdmlkZW9FbGVtZW50UGFyZW50LmlkID0gJ3ZpZGVvRWxlbWVudFBhcmVudCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZGVvRWxlbWVudFBhcmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIHRoZSBzZXR0aW5ncyB3aXRoIG9uIGNoYW5nZSBsaXN0ZW5lcnMgYW5kIGFueSBhZGRpdGlvbmFsIHBlciBleHBlcmllbmNlIHNldHRpbmdzLlxuICAgICAqL1xuICAgIGNvbmZpZ3VyZVNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25TZXR0aW5nQ2hhbmdlZExpc3RlbmVyKEZsYWdzLklzUXVhbGl0eUNvbnRyb2xsZXIsICh3YW50c1F1YWxpdHlDb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2V0dGluZyBoYXMgYmVlbiBzZXQgdG8gdHJ1ZSAoZWl0aGVyIHByb2dyYW1tYXRpY2FsbHkgb3IgdGhlIHVzZXIgaGFzIGZsaWNrZWQgdGhlIHRvZ2dsZSlcbiAgICAgICAgICAgIC8vIGFuZCB3ZSBhcmVuJ3QgY3VycmVudGx5IHF1YWxpdHkgY29udHJvbGxlciwgc2VuZCB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgaWYgKHdhbnRzUXVhbGl0eUNvbnRyb2xsZXIgPT09IHRydWUgJiYgIXRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuaXNRdWFsaXR5Q29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZFJlcXVlc3RRdWFsaXR5Q29udHJvbE93bmVyc2hpcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihGbGFncy5BRktEZXRlY3Rpb24sIChpc0FGS0VuYWJsZWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2V0QWZrRW5hYmxlZChpc0FGS0VuYWJsZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihGbGFncy5NYXRjaFZpZXdwb3J0UmVzb2x1dGlvbiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci51cGRhdGVWaWRlb1N0cmVhbVNpemUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPblNldHRpbmdDaGFuZ2VkTGlzdGVuZXIoRmxhZ3MuSG92ZXJpbmdNb3VzZU1vZGUsIChpc0hvdmVyaW5nTW91c2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldEZsYWdMYWJlbChGbGFncy5Ib3ZlcmluZ01vdXNlTW9kZSwgYENvbnRyb2wgU2NoZW1lOiAke2lzSG92ZXJpbmdNb3VzZSA/ICdIb3ZlcmluZycgOiAnTG9ja2VkJ30gTW91c2VgKTtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2V0TW91c2VJbnB1dEVuYWJsZWQodGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5Nb3VzZUlucHV0KSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB1c2VyIGlucHV0XG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPblNldHRpbmdDaGFuZ2VkTGlzdGVuZXIoRmxhZ3MuS2V5Ym9hcmRJbnB1dCwgKGlzRW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZXRLZXlib2FyZElucHV0RW5hYmxlZChpc0VuYWJsZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihGbGFncy5Nb3VzZUlucHV0LCAoaXNFbmFibGVkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnNldE1vdXNlSW5wdXRFbmFibGVkKGlzRW5hYmxlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25TZXR0aW5nQ2hhbmdlZExpc3RlbmVyKEZsYWdzLkZha2VNb3VzZVdpdGhUb3VjaGVzLCAoX2lzRmFrZU1vdXNlRW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZXRUb3VjaElucHV0RW5hYmxlZCh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLlRvdWNoSW5wdXQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPblNldHRpbmdDaGFuZ2VkTGlzdGVuZXIoRmxhZ3MuVG91Y2hJbnB1dCwgKGlzRW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZXRUb3VjaElucHV0RW5hYmxlZChpc0VuYWJsZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihGbGFncy5HYW1lcGFkSW5wdXQsIChpc0VuYWJsZWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2V0R2FtZVBhZElucHV0RW5hYmxlZChpc0VuYWJsZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZGlyZWN0IHFwIHNldHRpbmdzXG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPbk51bWVyaWNTZXR0aW5nQ2hhbmdlZExpc3RlbmVyKE51bWVyaWNQYXJhbWV0ZXJzLk1pblFQLCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCctLS0tLS0tLSAgU2VuZGluZyBNaW5RUCAgLS0tLS0tLS0nKTtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZEVuY29kZXJNaW5RUChuZXdWYWx1ZSk7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgICAgICAgICAgY29uc3QgcXVhbGl0eSA9IE1hdGgudHJ1bmMoMTAwICogKDEgLSBuZXdWYWx1ZSAvIDUxKSk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXROdW1lcmljU2V0dGluZyhOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWF4LCBxdWFsaXR5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPbk51bWVyaWNTZXR0aW5nQ2hhbmdlZExpc3RlbmVyKE51bWVyaWNQYXJhbWV0ZXJzLk1heFFQLCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCctLS0tLS0tLSAgU2VuZGluZyBNYXhRUCAgLS0tLS0tLS0nKTtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZEVuY29kZXJNYXhRUChuZXdWYWx1ZSk7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgICAgICAgICAgY29uc3QgcXVhbGl0eSA9IE1hdGgudHJ1bmMoMTAwICogKDEgLSBuZXdWYWx1ZSAvIDUxKSk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXROdW1lcmljU2V0dGluZyhOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWluLCBxdWFsaXR5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGRpcmVjdCBxdWFsaXR5IGZhY3RvciBzZXR0aW5nc1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25OdW1lcmljU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihOdW1lcmljUGFyYW1ldGVycy5NaW5RdWFsaXR5LCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCctLS0tLS0tLSAgU2VuZGluZyBNaW5RdWFsaXR5ICAtLS0tLS0tLScpO1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZW5kRW5jb2Rlck1pblF1YWxpdHkobmV3VmFsdWUpO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nKTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldE51bWVyaWNTZXR0aW5nKE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNaW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPbk51bWVyaWNTZXR0aW5nQ2hhbmdlZExpc3RlbmVyKE51bWVyaWNQYXJhbWV0ZXJzLk1heFF1YWxpdHksIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tICBTZW5kaW5nIE1heFF1YWxpdHkgIC0tLS0tLS0tJyk7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnNlbmRFbmNvZGVyTWF4UXVhbGl0eShuZXdWYWx1ZSk7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0TnVtZXJpY1NldHRpbmcoTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1heCwgbmV3VmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gbmV3IHF1YWxpdHkgdmFsdWUgdGhhdCBnZXRzIHNjYWxlZCB0byBxcCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uTnVtZXJpY1NldHRpbmdDaGFuZ2VkTGlzdGVuZXIoTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1pbiwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IDUxIC0gKG5ld1ZhbHVlIC8gMTAwKSAqIDUxO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tICBTZW5kaW5nIE1pblFQIGZyb20gcXVhbGl0eSB2YWx1ZSAgLS0tLS0tLS0nKTtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZEVuY29kZXJNYXhRUChuZXdWYWx1ZSk7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uTnVtZXJpY1NldHRpbmdDaGFuZ2VkTGlzdGVuZXIoTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1heCwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IDUxIC0gKG5ld1ZhbHVlIC8gMTAwKSAqIDUxO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tICBTZW5kaW5nIE1heFFQIGZyb20gcXVhbGl0eSB2YWx1ZSAgLS0tLS0tLS0nKTtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZEVuY29kZXJNaW5RUChuZXdWYWx1ZSk7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2ViUlRDIHNldHRpbmdzXG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPbk51bWVyaWNTZXR0aW5nQ2hhbmdlZExpc3RlbmVyKE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01pbkJpdHJhdGUsIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tICBTZW5kaW5nIHdlYiBydGMgc2V0dGluZ3MgIC0tLS0tLS0tJyk7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnNlbmRXZWJSVENNaW5CaXRyYXRlKG5ld1ZhbHVlICogMTAwMCAvKiBrYnBzIHRvIGJwcyAqLyk7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uTnVtZXJpY1NldHRpbmdDaGFuZ2VkTGlzdGVuZXIoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWF4Qml0cmF0ZSwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0gIFNlbmRpbmcgd2ViIHJ0YyBzZXR0aW5ncyAgLS0tLS0tLS0nKTtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZFdlYlJUQ01heEJpdHJhdGUobmV3VmFsdWUgKiAxMDAwIC8qIGticHMgdG8gYnBzICovKTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25OdW1lcmljU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihOdW1lcmljUGFyYW1ldGVycy5XZWJSVENGUFMsIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tICBTZW5kaW5nIHdlYiBydGMgc2V0dGluZ3MgIC0tLS0tLS0tJyk7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnNlbmRXZWJSVENGcHMobmV3VmFsdWUpO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPbk9wdGlvblNldHRpbmdDaGFuZ2VkTGlzdGVuZXIoT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRDb2RlYywgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fd2ViUnRjQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2V0UHJlZmVycmVkQ29kZWMobmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX3JlZ2lzdGVyT25DaGFuZ2VFdmVudHModGhpcy5fZXZlbnRFbWl0dGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBpbnB1dCBjb250cm9sIG93bmVyc2hpcFxuICAgICAqIEBwYXJhbSBpbnB1dENvbnRyb2xPd25lcnNoaXAgLSBkb2VzIHRoZSB1c2VyIGhhdmUgaW5wdXQgY29udHJvbCBvd25lcnNoaXBcbiAgICAgKi9cbiAgICBfb25JbnB1dENvbnRyb2xPd25lcnNoaXAoaW5wdXRDb250cm9sT3duZXJzaGlwKSB7XG4gICAgICAgIHRoaXMuX2lucHV0Q29udHJvbGxlciA9IGlucHV0Q29udHJvbE93bmVyc2hpcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgdGhlIFdlYlJUQ1BsYXllckNvbnRyb2xsZXIgaW50ZXJmYWNlIHRvIHByb3ZpZGUgV2ViUlRDUGxheWVyQ29udHJvbGxlciBmdW5jdGlvbmFsaXR5IHdpdGhpbiB0aGlzIGNsYXNzIGFuZCBzZXQgdXAgYW55dGhpbmcgdGhhdCByZXF1aXJlcyBpdFxuICAgICAqIEBwYXJhbSB3ZWJSdGNQbGF5ZXJDb250cm9sbGVyIC0gYSBXZWJSdGNQbGF5ZXJDb250cm9sbGVyIGNvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzZXRXZWJSdGNQbGF5ZXJDb250cm9sbGVyKHdlYlJ0Y1BsYXllckNvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlciA9IHdlYlJ0Y1BsYXllckNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2V0UHJlZmVycmVkQ29kZWModGhpcy5jb25maWcuZ2V0U2V0dGluZ09wdGlvbihPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZENvZGVjKS5zZWxlY3RlZCk7XG4gICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIucmVzaXplUGxheWVyU3R5bGUoKTtcbiAgICAgICAgLy8gY29ubmVjdCBpZiBhdXRvIGNvbm5lY3QgZmxhZyBpcyBlbmFibGVkXG4gICAgICAgIHRoaXMuY2hlY2tGb3JBdXRvQ29ubmVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRvIHNpZ25hbGluZyBzZXJ2ZXIuXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFN0cmVhbVByZUNvbm5lY3RFdmVudCgpKTtcbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5jb25uZWN0VG9TaWduYWxsaW5nU2VydmVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29ubmVjdHMgdG8gdGhlIHNpZ25hbGluZyBzZXJ2ZXIuIElmIGNvbm5lY3Rpb24gaXMgdXAsIGRpc2Nvbm5lY3RzIGZpcnN0XG4gICAgICogYmVmb3JlIGVzdGFibGlzaGluZyBhIG5ldyBjb25uZWN0aW9uXG4gICAgICovXG4gICAgcmVjb25uZWN0KCkge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgU3RyZWFtUmVjb25uZWN0RXZlbnQoKSk7XG4gICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIudHJ5UmVjb25uZWN0KCdSZWNvbm5lY3RpbmcuLi4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCBmcm9tIHRoZSBzaWduYWxpbmcgc2VydmVyIGFuZCBjbG9zZSBvcGVuIHBlZXIgY29ubmVjdGlvbnMuXG4gICAgICovXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFN0cmVhbVByZURpc2Nvbm5lY3RFdmVudCgpKTtcbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGF5IHRoZSBzdHJlYW0uIENhbiBiZSBjYWxsZWQgb25seSBhZnRlciBhIHBlZXIgY29ubmVjdGlvbiBoYXMgYmVlbiBlc3RhYmxpc2hlZC5cbiAgICAgKi9cbiAgICBwbGF5KCkge1xuICAgICAgICB0aGlzLl9vblN0cmVhbUxvYWRpbmcoKTtcbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5wbGF5U3RyZWFtKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF1dG8gY29ubmVjdCBpZiBBdXRvQ29ubmVjdCBmbGFnIGlzIGVuYWJsZWRcbiAgICAgKi9cbiAgICBjaGVja0ZvckF1dG9Db25uZWN0KCkge1xuICAgICAgICAvLyBzZXQgdXAgaWYgdGhlIGF1dG8gcGxheSB3aWxsIGJlIHVzZWQgb3IgcmVndWxhciBjbGljayB0byBzdGFydFxuICAgICAgICBpZiAodGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5BdXRvQ29ubmVjdCkpIHtcbiAgICAgICAgICAgIC8vIGlmIGF1dG9wbGF5aW5nIHNob3cgYW4gaW5mbyBvdmVybGF5IHdoaWxlIHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBjb25uZWN0aW9uIHRvIGJlZ2luXG4gICAgICAgICAgICB0aGlzLl9vbldlYlJ0Y0F1dG9Db25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLmNvbm5lY3RUb1NpZ25hbGxpbmdTZXJ2ZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHVubXV0ZSB0aGUgbWljcm9waG9uZSB0cmFjayB3aGljaCBpcyBzZW50IHRvIFVucmVhbCBFbmdpbmUuXG4gICAgICogQnkgZGVmYXVsdCwgd2lsbCBvbmx5IHVubXV0ZSBhbiBleGlzdGluZyBtaWMgdHJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9yY2VFbmFibGUgQ2FuIGJlIHVzZWQgZm9yIGNhc2VzIHdoZW4gdGhpcyBvYmplY3Qgd2Fzbid0IGluaXRpYWxpemVkIHdpdGggYSBtaWMgdHJhY2suXG4gICAgICogSWYgdGhpcyBwYXJhbWV0ZXIgaXMgdHJ1ZSwgdGhlIGNvbm5lY3Rpb24gd2lsbCBiZSByZXN0YXJ0ZWQgd2l0aCBhIG1pY3JvcGhvbmUuXG4gICAgICogV2FybmluZzogdGhpcyB0YWtlcyBzb21lIHRpbWUsIGFzIGEgZnVsbCByZW5lZ290aWF0aW9uIGFuZCByZWNvbm5lY3Rpb24gd2lsbCBoYXBwZW4uXG4gICAgICovXG4gICAgdW5tdXRlTWljcm9waG9uZShmb3JjZUVuYWJsZSA9IGZhbHNlKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYW4gZXhpc3RpbmcgbWljIHRyYWNrLCB3ZSBqdXN0IHNldCBtdXRlZCBzdGF0ZVxuICAgICAgICBpZiAodGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZCgnVXNlTWljJykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TWljcm9waG9uZU11dGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHByZS1leGlzdGluZyBtaWMgdHJhY2ssIGFuZCBjYWxsZXIgaXMgb2sgd2l0aCBmdWxsIHJlc2V0LCB3ZSBlbmFibGUgYW5kIHJlc2V0XG4gICAgICAgIGlmIChmb3JjZUVuYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0RmxhZ0VuYWJsZWQoJ1VzZU1pYycsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBwcmVmZXIgbm90IHRvIGZvcmNlIGEgcmVjb25uZWN0aW9uLCBqdXN0IHdhcm4gdGhlIHVzZXIgdGhhdCB0aGlzIG9wZXJhdGlvbiBkaWRuJ3QgaGFwcGVuXG4gICAgICAgIExvZ2dlci5XYXJuaW5nKCdUcnlpbmcgdG8gdW5tdXRlIG1pYywgYnV0IFBpeGVsU3RyZWFtaW5nIHdhcyBpbml0aWFsaXplZCB3aXRoIG5vIG1pY3JvcGhvbmUgdHJhY2suIENhbGwgd2l0aCBmb3JjZUVuYWJsZSA9PSB0cnVlIHRvIHJlLWNvbm5lY3Qgd2l0aCBhIG1pYyB0cmFjay4nKTtcbiAgICB9XG4gICAgbXV0ZU1pY3JvcGhvbmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKCdVc2VNaWMnKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRNaWNyb3Bob25lTXV0ZWQodHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgd2Fzbid0IGEgbWljIHRyYWNrLCBqdXN0IGxldCB1c2VyIGtub3cgdGhlcmUncyBub3RoaW5nIHRvIG11dGVcbiAgICAgICAgTG9nZ2VyLkluZm8oJ1RyeWluZyB0byBtdXRlIG1pYywgYnV0IFBpeGVsU3RyZWFtaW5nIGhhcyBubyBtaWNyb3Bob25lIHRyYWNrLCBzbyBzZW5kaW5nIHNvdW5kIGlzIGFscmVhZHkgZGlzYWJsZWQuJyk7XG4gICAgfVxuICAgIHNldE1pY3JvcGhvbmVNdXRlZChtdXRlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgZm9yIChjb25zdCB0cmFuc2NlaXZlciBvZiAoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLl93ZWJSdGNDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGVlckNvbm5lY3Rpb25Db250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRUcmFuc2NlaXZlcnMoKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogW10pIHtcbiAgICAgICAgICAgIGlmIChSVENVdGlscy5jYW5UcmFuc2NlaXZlclNlbmRBdWRpbyh0cmFuc2NlaXZlcikpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2suZW5hYmxlZCA9ICFtdXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgdW5tdXRlIHRoZSB2aWRlbyB0cmFjayB3aGljaCBpcyBzZW50IHRvIFVucmVhbCBFbmdpbmUuXG4gICAgICogQnkgZGVmYXVsdCwgd2lsbCBvbmx5IHVubXV0ZSBhbiBleGlzdGluZyB2aWRlbyB0cmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JjZUVuYWJsZSBDYW4gYmUgdXNlZCBmb3IgY2FzZXMgd2hlbiB0aGlzIG9iamVjdCB3YXNuJ3QgaW5pdGlhbGl6ZWQgd2l0aCBhIHZpZGVvIHRyYWNrLlxuICAgICAqIElmIHRoaXMgcGFyYW1ldGVyIGlzIHRydWUsIHRoZSBjb25uZWN0aW9uIHdpbGwgYmUgcmVzdGFydGVkIHdpdGggYSBjYW1lcmEuXG4gICAgICogV2FybmluZzogdGhpcyB0YWtlcyBzb21lIHRpbWUsIGFzIGEgZnVsbCByZW5lZ290aWF0aW9uIGFuZCByZWNvbm5lY3Rpb24gd2lsbCBoYXBwZW4uXG4gICAgICovXG4gICAgdW5tdXRlQ2FtZXJhKGZvcmNlRW5hYmxlID0gZmFsc2UpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBhbiBleGlzdGluZyB2aWRlbyB0cmFjaywgd2UganVzdCBzZXQgbXV0ZWQgc3RhdGVcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoJ1VzZUNhbWVyYScpKSB7XG4gICAgICAgICAgICB0aGlzLnNldENhbWVyYU11dGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHByZS1leGlzdGluZyB2aWRlbyB0cmFjaywgYW5kIGNhbGxlciBpcyBvayB3aXRoIGZ1bGwgcmVzZXQsIHdlIGVuYWJsZSBhbmQgcmVzZXRcbiAgICAgICAgaWYgKGZvcmNlRW5hYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXRGbGFnRW5hYmxlZCgnVXNlQ2FtZXJhJywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIHByZWZlciBub3QgdG8gZm9yY2UgYSByZWNvbm5lY3Rpb24sIGp1c3Qgd2FybiB0aGUgdXNlciB0aGF0IHRoaXMgb3BlcmF0aW9uIGRpZG4ndCBoYXBwZW5cbiAgICAgICAgTG9nZ2VyLldhcm5pbmcoJ1RyeWluZyB0byB1bm11dGUgdmlkZW8sIGJ1dCBQaXhlbFN0cmVhbWluZyB3YXMgaW5pdGlhbGl6ZWQgd2l0aCBubyB2aWRlbyB0cmFjay4gQ2FsbCB3aXRoIGZvcmNlRW5hYmxlID09IHRydWUgdG8gcmUtY29ubmVjdCB3aXRoIGEgdmlkZW8gdHJhY2suJyk7XG4gICAgfVxuICAgIG11dGVDYW1lcmEoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKCdVc2VDYW1lcmEnKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDYW1lcmFNdXRlZCh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSB3YXNuJ3QgYSBtaWMgdHJhY2ssIGp1c3QgbGV0IHVzZXIga25vdyB0aGVyZSdzIG5vdGhpbmcgdG8gbXV0ZVxuICAgICAgICBMb2dnZXIuSW5mbygnVHJ5aW5nIHRvIG11dGUgY2FtZXJhLCBidXQgUGl4ZWxTdHJlYW1pbmcgaGFzIG5vIHZpZGVvIHRyYWNrLCBzbyBzZW5kaW5nIHZpZGVvIGlzIGFscmVhZHkgZGlzYWJsZWQuJyk7XG4gICAgfVxuICAgIHNldENhbWVyYU11dGVkKG11dGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBmb3IgKGNvbnN0IHRyYW5zY2VpdmVyIG9mIChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdldFRyYW5zY2VpdmVycygpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBbXSkge1xuICAgICAgICAgICAgaWYgKFJUQ1V0aWxzLmNhblRyYW5zY2VpdmVyU2VuZFZpZGVvKHRyYW5zY2VpdmVyKSkge1xuICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRlci50cmFjay5lbmFibGVkID0gIW11dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZW1pdCBhbiBldmVudCB3aGVuIGF1dG8gY29ubmVjdGluZyBvY2N1cnNcbiAgICAgKi9cbiAgICBfb25XZWJSdGNBdXRvQ29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFdlYlJ0Y0F1dG9Db25uZWN0RXZlbnQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGVtaXQgYW4gZXZlbnQgZm9yIHdoZW4gU0RQIG5lZ290aWF0aW9uIGlzIGZ1bGx5IGZpbmlzaGVkLlxuICAgICAqL1xuICAgIF9vbldlYlJ0Y1NkcCgpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFdlYlJ0Y1NkcEV2ZW50KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBlbWl0IGFuIFNEUCBvZmZlciBhZnRlciBpdCBoYXMgYmVlbiBzZXQuXG4gICAgICovXG4gICAgX29uV2ViUnRjU2RwT2ZmZXIob2ZmZXIpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFdlYlJ0Y1NkcE9mZmVyRXZlbnQoeyBzZHA6IG9mZmVyIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZW1pdCBhbiBTRFAgYW5zd2VyIGFmdGVyIGl0IGhhcyBiZWVuIHNldC5cbiAgICAgKi9cbiAgICBfb25XZWJSdGNTZHBBbnN3ZXIoYW5zd2VyKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBXZWJSdGNTZHBBbnN3ZXJFdmVudCh7IHNkcDogYW5zd2VyIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gY2FsbCB0byBlbWl0IGEgYGxhdGVuY3lDYWxjdWxhdGVkYCBldmVudC5cbiAgICAgKi9cbiAgICBfb25MYXRlbmN5Q2FsY3VsYXRlZChsYXRlbmN5SW5mbykge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgTGF0ZW5jeUNhbGN1bGF0ZWRFdmVudCh7IGxhdGVuY3lJbmZvIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZW1pdHMgYSBTdHJlYW1Mb2FkaW5nIGV2ZW50XG4gICAgICovXG4gICAgX29uU3RyZWFtTG9hZGluZygpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFN0cmVhbUxvYWRpbmdFdmVudCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB0aGUgdmlkZW8gaXMgZGlzY29ubmVjdGVkIC0gZW1pdHMgZ2l2ZW4gZXZlbnRTdHJpbmcgb3IgYW4gb3ZlcnJpZGVcbiAgICAgKiBtZXNzYWdlIGZyb20gd2ViUnRjQ29udHJvbGxlciBpZiBvbmUgaGFzIGJlZW4gc2V0XG4gICAgICogQHBhcmFtIGV2ZW50U3RyaW5nIC0gYSBzdHJpbmcgZGVzY3JpYmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gY2xvc2VkXG4gICAgICogQHBhcmFtIGFsbG93Q2xpY2tUb1JlY29ubmVjdCAtIHRydWUgaWYgd2Ugd2FudCB0byBhbGxvdyB0aGUgdXNlciB0byByZXRyeSB0aGUgY29ubmVjdGlvbiB3aXRoIGEgY2xpY2tcbiAgICAgKi9cbiAgICBfb25EaXNjb25uZWN0KGV2ZW50U3RyaW5nLCBhbGxvd0NsaWNrVG9SZWNvbm5lY3QpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFdlYlJ0Y0Rpc2Nvbm5lY3RlZEV2ZW50KHtcbiAgICAgICAgICAgIGV2ZW50U3RyaW5nOiBldmVudFN0cmluZyxcbiAgICAgICAgICAgIGFsbG93Q2xpY2tUb1JlY29ubmVjdDogYWxsb3dDbGlja1RvUmVjb25uZWN0XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIFdlYiBSdGMgaXMgY29ubmVjdGluZ1xuICAgICAqL1xuICAgIF9vbldlYlJ0Y0Nvbm5lY3RpbmcoKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBXZWJSdGNDb25uZWN0aW5nRXZlbnQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hlbiBXZWIgUnRjIGhhcyBjb25uZWN0ZWRcbiAgICAgKi9cbiAgICBfb25XZWJSdGNDb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBXZWJSdGNDb25uZWN0ZWRFdmVudCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIFdlYiBSdGMgZmFpbHMgdG8gY29ubmVjdFxuICAgICAqL1xuICAgIF9vbldlYlJ0Y0ZhaWxlZCgpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFdlYlJ0Y0ZhaWxlZEV2ZW50KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgd2hlbiB0aGUgVmlkZW8gaGFzIGJlZW4gSW5pdGlhbGl6ZWRcbiAgICAgKi9cbiAgICBfb25WaWRlb0luaXRpYWxpemVkKCkge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgVmlkZW9Jbml0aWFsaXplZEV2ZW50KCkpO1xuICAgICAgICB0aGlzLl92aWRlb1N0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB1cCBmdW5jdGlvbmFsaXR5IHRvIGhhcHBlbiB3aGVuIHJlY2VpdmluZyBsYXRlbmN5IHRlc3QgcmVzdWx0c1xuICAgICAqIEBwYXJhbSBsYXRlbmN5IC0gbGF0ZW5jeSB0ZXN0IHJlc3VsdHMgb2JqZWN0XG4gICAgICovXG4gICAgX29uTGF0ZW5jeVRlc3RSZXN1bHQobGF0ZW5jeVRpbWluZ3MpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IExhdGVuY3lUZXN0UmVzdWx0RXZlbnQoeyBsYXRlbmN5VGltaW5ncyB9KSk7XG4gICAgfVxuICAgIF9vbkRhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgRGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlc3BvbnNlRXZlbnQoeyByZXNwb25zZSB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB1cCBmdW5jdGlvbmFsaXR5IHRvIGhhcHBlbiB3aGVuIHJlY2VpdmluZyB2aWRlbyBzdGF0aXN0aWNzXG4gICAgICogQHBhcmFtIHZpZGVvU3RhdHMgLSB2aWRlbyBzdGF0aXN0aWNzIGFzIGEgYWdncmVnYXRlIHN0YXRzIG9iamVjdFxuICAgICAqL1xuICAgIF9vblZpZGVvU3RhdHModmlkZW9TdGF0cykge1xuICAgICAgICAvLyBEdXJhdGlvblxuICAgICAgICBpZiAoIXRoaXMuX3ZpZGVvU3RhcnRUaW1lIHx8IHRoaXMuX3ZpZGVvU3RhcnRUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICB2aWRlb1N0YXRzLmhhbmRsZVNlc3Npb25TdGF0aXN0aWNzKHRoaXMuX3ZpZGVvU3RhcnRUaW1lLCB0aGlzLl9pbnB1dENvbnRyb2xsZXIsIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIudmlkZW9BdmdRcCk7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBTdGF0c1JlY2VpdmVkRXZlbnQoeyBhZ2dyZWdhdGVkU3RhdHM6IHZpZGVvU3RhdHMgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgZnVuY3Rpb25hbGl0eSB0byBoYXBwZW4gd2hlbiBjYWxjdWxhdGluZyB0aGUgYXZlcmFnZSB2aWRlbyBlbmNvZGVyIHFwXG4gICAgICogQHBhcmFtIFFQIC0gdGhlIHF1YWxpdHkgbnVtYmVyIG9mIHRoZSBzdHJlYW1cbiAgICAgKi9cbiAgICBfb25WaWRlb0VuY29kZXJBdmdRUChRUCkge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgVmlkZW9FbmNvZGVyQXZnUVBFdmVudCh7IGF2Z1FQOiBRUCB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB1cCBmdW5jdGlvbmFsaXR5IHRvIGhhcHBlbiB3aGVuIHJlY2VpdmluZyBhbmQgaGFuZGxpbmcgaW5pdGlhbCBzZXR0aW5ncyBmb3IgdGhlIFVFIGFwcFxuICAgICAqIEBwYXJhbSBzZXR0aW5ncyAtIGluaXRpYWwgVUUgYXBwIHNldHRpbmdzXG4gICAgICovXG4gICAgX29uSW5pdGlhbFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IEluaXRpYWxTZXR0aW5nc0V2ZW50KHsgc2V0dGluZ3MgfSkpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuUGl4ZWxTdHJlYW1pbmdTZXR0aW5ncykge1xuICAgICAgICAgICAgdGhpcy5hbGxvd0NvbnNvbGVDb21tYW5kcyA9IChfYSA9IHNldHRpbmdzLlBpeGVsU3RyZWFtaW5nU2V0dGluZ3MuQWxsb3dQaXhlbFN0cmVhbWluZ0NvbW1hbmRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93Q29uc29sZUNvbW1hbmRzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5JbmZvKCctQWxsb3dQaXhlbFN0cmVhbWluZ0NvbW1hbmRzPWZhbHNlLCBzZW5kaW5nIGFyYml0cmFyeSBjb25zb2xlIGNvbW1hbmRzIGZyb20gYnJvd3NlciB0byBVRSBpcyBkaXNhYmxlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VVcmxQYXJhbXMgPSB0aGlzLmNvbmZpZy51c2VVcmxQYXJhbXM7XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBJVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgICAgICBMb2dnZXIuSW5mbyhgdXNpbmcgVVJMIHBhcmFtZXRlcnMgJHt1c2VVcmxQYXJhbXN9YCk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5FbmNvZGVyU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIC8vIGhlcmUgd2Ugc2hvdWxkIGVpdGhlciBnZXQgTWluL01heFFQIGZyb20gUFMxXG4gICAgICAgICAgICAvLyBvciBNaW4vTWF4UXVhbGl0eSBmcm9tIFBTMlxuICAgICAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIHNldCBvbmUgc2V0IG9yIHRoZSBvdGhlciBhcyB0aGV5IGNvbnZlcmdlIGluIENvbXBhdFF1YWxpdHlNaW4vTWF4IGFuZFxuICAgICAgICAgICAgLy8gd2UgZG9udCB3YW50IHRvIGhhdmUgdGhlbSBjb25mbGljdCB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLkVuY29kZXJTZXR0aW5ncy5NaW5RUCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldE51bWVyaWNTZXR0aW5nKE51bWVyaWNQYXJhbWV0ZXJzLk1pblFQLCBcbiAgICAgICAgICAgICAgICAvLyBJZiBhIHNldHRpbmcgaXMgc2V0IGluIHRoZSBVUkwsIG1ha2Ugc3VyZSB3ZSByZXNwZWN0IHRoYXQgdmFsdWUgYXMgb3Bwb3NlZCB0byB3aGF0IHRoZSBhcHBsaWNhdGlvbiBzZW5kcyB1c1xuICAgICAgICAgICAgICAgIHVzZVVybFBhcmFtcyAmJiB1cmxQYXJhbXMuaGFzKE51bWVyaWNQYXJhbWV0ZXJzLk1pblFQKVxuICAgICAgICAgICAgICAgICAgICA/IE51bWJlci5wYXJzZUZsb2F0KHVybFBhcmFtcy5nZXQoTnVtZXJpY1BhcmFtZXRlcnMuTWluUVApKVxuICAgICAgICAgICAgICAgICAgICA6IHNldHRpbmdzLkVuY29kZXJTZXR0aW5ncy5NaW5RUCB8fCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXROdW1lcmljU2V0dGluZyhOdW1lcmljUGFyYW1ldGVycy5NYXhRUCwgdXNlVXJsUGFyYW1zICYmIHVybFBhcmFtcy5oYXMoTnVtZXJpY1BhcmFtZXRlcnMuTWF4UVApXG4gICAgICAgICAgICAgICAgICAgID8gTnVtYmVyLnBhcnNlRmxvYXQodXJsUGFyYW1zLmdldChOdW1lcmljUGFyYW1ldGVycy5NYXhRUCkpXG4gICAgICAgICAgICAgICAgICAgIDogc2V0dGluZ3MuRW5jb2RlclNldHRpbmdzLk1heFFQIHx8IDUxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5FbmNvZGVyU2V0dGluZ3MuTWluUXVhbGl0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldE51bWVyaWNTZXR0aW5nKE51bWVyaWNQYXJhbWV0ZXJzLk1pblF1YWxpdHksIFxuICAgICAgICAgICAgICAgIC8vIElmIGEgc2V0dGluZyBpcyBzZXQgaW4gdGhlIFVSTCwgbWFrZSBzdXJlIHdlIHJlc3BlY3QgdGhhdCB2YWx1ZSBhcyBvcHBvc2VkIHRvIHdoYXQgdGhlIGFwcGxpY2F0aW9uIHNlbmRzIHVzXG4gICAgICAgICAgICAgICAgdXNlVXJsUGFyYW1zICYmIHVybFBhcmFtcy5oYXMoTnVtZXJpY1BhcmFtZXRlcnMuTWluUXVhbGl0eSlcbiAgICAgICAgICAgICAgICAgICAgPyBOdW1iZXIucGFyc2VGbG9hdCh1cmxQYXJhbXMuZ2V0KE51bWVyaWNQYXJhbWV0ZXJzLk1pblF1YWxpdHkpKVxuICAgICAgICAgICAgICAgICAgICA6IHNldHRpbmdzLkVuY29kZXJTZXR0aW5ncy5NaW5RdWFsaXR5IHx8IDApO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldE51bWVyaWNTZXR0aW5nKE51bWVyaWNQYXJhbWV0ZXJzLk1heFF1YWxpdHksIHVzZVVybFBhcmFtcyAmJiB1cmxQYXJhbXMuaGFzKE51bWVyaWNQYXJhbWV0ZXJzLk1heFF1YWxpdHkpXG4gICAgICAgICAgICAgICAgICAgID8gTnVtYmVyLnBhcnNlRmxvYXQodXJsUGFyYW1zLmdldChOdW1lcmljUGFyYW1ldGVycy5NYXhRdWFsaXR5KSlcbiAgICAgICAgICAgICAgICAgICAgOiBzZXR0aW5ncy5FbmNvZGVyU2V0dGluZ3MuTWF4UXVhbGl0eSB8fCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlc2UgdHdvIGFyZSBqdXN0IHVzZWQgdG8gY29udmVyZ2UgcXVhbGl0eSBhbmQgcXAgYW5kIGJlaGF2ZSBzbGlnaHRseSBkaWZmZXJlbnRseSBzaW5jZSB0aGV5XG4gICAgICAgICAgICAvLyBzaG91bGRudCBleGlzdCBpbiBFbmNvZGVyU2V0dGluZ3NcbiAgICAgICAgICAgIGlmICh1c2VVcmxQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodXJsUGFyYW1zLmhhcyhOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWluKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXROdW1lcmljU2V0dGluZyhOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWluLCBOdW1iZXIucGFyc2VGbG9hdCh1cmxQYXJhbXMuZ2V0KE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNaW4pKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1cmxQYXJhbXMuaGFzKE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNYXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldE51bWVyaWNTZXR0aW5nKE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNYXgsIE51bWJlci5wYXJzZUZsb2F0KHVybFBhcmFtcy5nZXQoTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1heCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLldlYlJUQ1NldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXROdW1lcmljU2V0dGluZyhOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNaW5CaXRyYXRlLCB1c2VVcmxQYXJhbXMgJiYgdXJsUGFyYW1zLmhhcyhOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNaW5CaXRyYXRlKVxuICAgICAgICAgICAgICAgID8gTnVtYmVyLnBhcnNlRmxvYXQodXJsUGFyYW1zLmdldChOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNaW5CaXRyYXRlKSlcbiAgICAgICAgICAgICAgICA6IHNldHRpbmdzLldlYlJUQ1NldHRpbmdzLk1pbkJpdHJhdGUgLyAxMDAwIC8qIGJwcyB0byBrYnBzICovKTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldE51bWVyaWNTZXR0aW5nKE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01heEJpdHJhdGUsIHVzZVVybFBhcmFtcyAmJiB1cmxQYXJhbXMuaGFzKE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01heEJpdHJhdGUpXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIucGFyc2VGbG9hdCh1cmxQYXJhbXMuZ2V0KE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01heEJpdHJhdGUpKVxuICAgICAgICAgICAgICAgIDogc2V0dGluZ3MuV2ViUlRDU2V0dGluZ3MuTWF4Qml0cmF0ZSAvIDEwMDAgLyogYnBzIHRvIGticHMgKi8pO1xuICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0TnVtZXJpY1NldHRpbmcoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDRlBTLCB1c2VVcmxQYXJhbXMgJiYgdXJsUGFyYW1zLmhhcyhOdW1lcmljUGFyYW1ldGVycy5XZWJSVENGUFMpXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIucGFyc2VGbG9hdCh1cmxQYXJhbXMuZ2V0KE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ0ZQUykpXG4gICAgICAgICAgICAgICAgOiBzZXR0aW5ncy5XZWJSVENTZXR0aW5ncy5GUFMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB1cCBmdW5jdGlvbmFsaXR5IHRvIGhhcHBlbiB3aGVuIHNldHRpbmcgcXVhbGl0eSBjb250cm9sIG93bmVyc2hpcCBvZiBhIHN0cmVhbVxuICAgICAqIEBwYXJhbSBoYXNRdWFsaXR5T3duZXJzaGlwIC0gZG9lcyB0aGlzIHVzZXIgaGF2ZSBxdWFsaXR5IG93bmVyc2hpcCBvZiB0aGUgc3RyZWFtIHRydWUgLyBmYWxzZVxuICAgICAqL1xuICAgIF9vblF1YWxpdHlDb250cm9sT3duZXJzaGlwKGhhc1F1YWxpdHlPd25lcnNoaXApIHtcbiAgICAgICAgdGhpcy5jb25maWcuc2V0RmxhZ0VuYWJsZWQoRmxhZ3MuSXNRdWFsaXR5Q29udHJvbGxlciwgaGFzUXVhbGl0eU93bmVyc2hpcCk7XG4gICAgfVxuICAgIF9vblBsYXllckNvdW50KHBsYXllckNvdW50KSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBQbGF5ZXJDb3VudEV2ZW50KHsgY291bnQ6IHBsYXllckNvdW50IH0pKTtcbiAgICB9XG4gICAgX29uU3Vic2NyaWJlRmFpbGVkKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFN1YnNjcmliZUZhaWxlZEV2ZW50KHsgbWVzc2FnZTogbWVzc2FnZSB9KSk7XG4gICAgfVxuICAgIC8vIFNldHMgdXAgdG8gZW1pdCB0aGUgd2VicnRjIHRjcCByZWxheSBkZXRlY3QgZXZlbnRcbiAgICBfc2V0dXBXZWJSdGNUQ1BSZWxheURldGVjdGlvbihzdGF0c1JlY2VpdmVkRXZlbnQpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBhY3RpdmUgY2FuZGlkYXRlIHBhaXJcbiAgICAgICAgY29uc3QgYWN0aXZlQ2FuZGlkYXRlUGFpciA9IHN0YXRzUmVjZWl2ZWRFdmVudC5kYXRhLmFnZ3JlZ2F0ZWRTdGF0cy5nZXRBY3RpdmVDYW5kaWRhdGVQYWlyKCk7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBhY3RpdmUgY2FuZGlkYXRlIHBhaXIgaXMgbm90IG51bGxcbiAgICAgICAgaWYgKGFjdGl2ZUNhbmRpZGF0ZVBhaXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBsb2NhbCBjYW5kaWRhdGUgYXNzaWduZWQgdG8gdGhlIGFjdGl2ZSBjYW5kaWRhdGUgcGFpclxuICAgICAgICAgICAgY29uc3QgbG9jYWxDYW5kaWRhdGUgPSBzdGF0c1JlY2VpdmVkRXZlbnQuZGF0YS5hZ2dyZWdhdGVkU3RhdHMubG9jYWxDYW5kaWRhdGVzLmZpbmQoKGNhbmRpZGF0ZSkgPT4gY2FuZGlkYXRlLmlkID09IGFjdGl2ZUNhbmRpZGF0ZVBhaXIubG9jYWxDYW5kaWRhdGVJZCwgbnVsbCk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbG9jYWwgY2FuZGlkYXRlIGlzIG5vdCBudWxsLCBjYW5kaWRhdGUgdHlwZSBpcyByZWxheSBhbmQgdGhlIHJlbGF5IHByb3RvY29sIGlzIHRjcFxuICAgICAgICAgICAgaWYgKGxvY2FsQ2FuZGlkYXRlICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBsb2NhbENhbmRpZGF0ZS5jYW5kaWRhdGVUeXBlID09ICdyZWxheScgJiZcbiAgICAgICAgICAgICAgICBsb2NhbENhbmRpZGF0ZS5yZWxheVByb3RvY29sID09ICd0Y3AnKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgd2ViIHJ0YyB0Y3AgcmVsYXkgZGV0ZWN0ZWQgZXZlbnRcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgV2ViUnRjVENQUmVsYXlEZXRlY3RlZEV2ZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGNoZWNrIGlzIGNvbXBsZXRlZCBhbmQgdGhlIHN0YXRzIGxpc3RlbiBldmVudCBjYW4gYmUgcmVtb3ZlZFxuICAgICAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0YXRzUmVjZWl2ZWQnLCB0aGlzLl9zZXR1cFdlYlJ0Y1RDUFJlbGF5RGV0ZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGEgY29ubmVjdGlvbiBsYXRlbmN5IHRlc3QuXG4gICAgICogTk9URTogVGhlcmUgYXJlIHBsYW5zIHRvIHJlZmFjdG9yIGFsbCByZXF1ZXN0KiBmdW5jdGlvbnMuIEV4cGVjdCBjaGFuZ2VzIGlmIHlvdSB1c2UgdGhpcyFcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHJlcXVlc3RMYXRlbmN5VGVzdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWJSdGNDb250cm9sbGVyLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZW5kTGF0ZW5jeVRlc3QoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgYSBkYXRhIGNoYW5uZWwgbGF0ZW5jeSB0ZXN0LlxuICAgICAqIE5PVEU6IFRoZXJlIGFyZSBwbGFucyB0byByZWZhY3RvciBhbGwgcmVxdWVzdCogZnVuY3Rpb25zLiBFeHBlY3QgY2hhbmdlcyBpZiB5b3UgdXNlIHRoaXMhXG4gICAgICovXG4gICAgcmVxdWVzdERhdGFDaGFubmVsTGF0ZW5jeVRlc3QoY29uZmlnKSB7XG4gICAgICAgIGlmICghdGhpcy5fd2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZGF0YUNoYW5uZWxMYXRlbmN5VGVzdENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFDaGFubmVsTGF0ZW5jeVRlc3RDb250cm9sbGVyID0gbmV3IERhdGFDaGFubmVsTGF0ZW5jeVRlc3RDb250cm9sbGVyKHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZERhdGFDaGFubmVsTGF0ZW5jeVRlc3QuYmluZCh0aGlzLl93ZWJSdGNDb250cm9sbGVyKSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBEYXRhQ2hhbm5lbExhdGVuY3lUZXN0UmVzdWx0RXZlbnQoeyByZXN1bHQgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXNwb25zZScsICh7IGRhdGE6IHsgcmVzcG9uc2UgfSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWxMYXRlbmN5VGVzdENvbnRyb2xsZXIucmVjZWl2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNoYW5uZWxMYXRlbmN5VGVzdENvbnRyb2xsZXIuc3RhcnQoY29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBmb3IgdGhlIFVFIGFwcGxpY2F0aW9uIHRvIHNob3cgRlBTIGNvdW50ZXIuXG4gICAgICogTk9URTogVGhlcmUgYXJlIHBsYW5zIHRvIHJlZmFjdG9yIGFsbCByZXF1ZXN0KiBmdW5jdGlvbnMuIEV4cGVjdCBjaGFuZ2VzIGlmIHlvdSB1c2UgdGhpcyFcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHJlcXVlc3RTaG93RnBzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnNlbmRTaG93RnBzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGZvciBhIG5ldyBJRnJhbWUgZnJvbSB0aGUgVUUgYXBwbGljYXRpb24uXG4gICAgICogTk9URTogVGhlcmUgYXJlIHBsYW5zIHRvIHJlZmFjdG9yIGFsbCByZXF1ZXN0KiBmdW5jdGlvbnMuIEV4cGVjdCBjaGFuZ2VzIGlmIHlvdSB1c2UgdGhpcyFcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHJlcXVlc3RJZnJhbWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fd2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZElmcmFtZVJlcXVlc3QoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSB0byBVRSBhcHBsaWNhdGlvbi4gVGhlIGRhdGEgd2lsbCBiZSBydW4gdGhyb3VnaCBKU09OLnN0cmluZ2lmeSgpIHNvIGUuZy4gc3RyaW5nc1xuICAgICAqIGFuZCBhbnkgc2VyaWFsaXphYmxlIHBsYWluIEpTT04gb2JqZWN0cyB3aXRoIG5vIHJlY3VycmVuY2UgY2FuIGJlIHNlbnQuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBzdWNjZWVkZWQsIGZhbHNlIGlmIHJlamVjdGVkXG4gICAgICovXG4gICAgZW1pdFVJSW50ZXJhY3Rpb24oZGVzY3JpcHRvcikge1xuICAgICAgICBpZiAoIXRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLmVtaXRVSUludGVyYWN0aW9uKGRlc2NyaXB0b3IpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIGNvbW1hbmQgdG8gVUUgYXBwbGljYXRpb24uIEJsb2NrcyBDb25zb2xlQ29tbWFuZCBkZXNjcmlwdG9ycyB1bmxlc3MgVUVcbiAgICAgKiBoYXMgc2lnbmFsZWQgdGhhdCBpdCBhbGxvd3MgY29uc29sZSBjb21tYW5kcy5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHN1Y2NlZWRlZCwgZmFsc2UgaWYgcmVqZWN0ZWRcbiAgICAgKi9cbiAgICBlbWl0Q29tbWFuZChkZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmICghdGhpcy5fd2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5hbGxvd0NvbnNvbGVDb21tYW5kcyAmJiAnQ29uc29sZUNvbW1hbmQnIGluIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLmVtaXRDb21tYW5kKGRlc2NyaXB0b3IpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIGNvbnNvbGUgY29tbWFuZCB0byBVRSBhcHBsaWNhdGlvbi4gT25seSBhbGxvd2VkIGlmIFVFIGhhcyBzaWduYWxlZCB0aGF0IGl0IGFsbG93c1xuICAgICAqIGNvbnNvbGUgY29tbWFuZHMuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBzdWNjZWVkZWQsIGZhbHNlIGlmIHJlamVjdGVkXG4gICAgICovXG4gICAgZW1pdENvbnNvbGVDb21tYW5kKGNvbW1hbmQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93Q29uc29sZUNvbW1hbmRzIHx8ICF0aGlzLl93ZWJSdGNDb250cm9sbGVyLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5lbWl0Q29uc29sZUNvbW1hbmQoY29tbWFuZCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBVRSB0ZXh0IGJveCB3aWRnZXQuXG4gICAgICogQHBhcmFtIGNvbnRlbnRzIFRoZSBuZXcgY29udGVudHMgb2YgdGhlIFVFIHRleHQgYm94LlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG1lc3NhZ2UgY291bGQgYmUgc2VudC5cbiAgICAgKi9cbiAgICBzZW5kVGV4dGJveEVudHJ5KGNvbnRlbnRzKSB7XG4gICAgICAgIGlmICghdGhpcy5fd2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZFRleHRib3hFbnRyeShjb250ZW50cyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBVRSAtPiBicm93c2VyIHJlc3BvbnNlIGV2ZW50IGxpc3RlbmVyXG4gICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcmVzcG9uc2UgaGFuZGxlclxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIFRoZSBtZXRob2QgdG8gYmUgYWN0aXZhdGVkIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkXG4gICAgICovXG4gICAgYWRkUmVzcG9uc2VFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIucmVzcG9uc2VDb250cm9sbGVyLmFkZFJlc3BvbnNlRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIFVFIC0+IGJyb3dzZXIgcmVzcG9uc2UgZXZlbnQgbGlzdGVuZXJcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSByZXNwb25zZSBoYW5kbGVyXG4gICAgICovXG4gICAgcmVtb3ZlUmVzcG9uc2VFdmVudExpc3RlbmVyKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5yZXNwb25zZUNvbnRyb2xsZXIucmVtb3ZlUmVzcG9uc2VFdmVudExpc3RlbmVyKG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBhIG5ldyBldmVudC5cbiAgICAgKiBAcGFyYW0gZSBldmVudFxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYW4gZXZlbnQgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0gdHlwZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXIuXG4gICAgICogQHBhcmFtIHR5cGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZS9kaXNhYmxlIFhSIG1vZGUuXG4gICAgICovXG4gICAgdG9nZ2xlWFIoKSB7XG4gICAgICAgIHRoaXMud2ViWHJDb250cm9sbGVyLnhyQ2xpY2tlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXNzIGluIGEgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBzaWduYWxsaW5nIHNlcnZlciBVUkwuXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgaWYgeW91IG5lZWQgdG8gcHJvZ3JhbW1hdGljYWxseSBjb25zdHJ1Y3QgeW91ciBzaWduYWxsaW5nIHNlcnZlciBVUkwuXG4gICAgICogQHBhcmFtIHNpZ25hbGxpbmdVcmxCdWlsZGVyRnVuYyBBIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzIGEgc2lnbmFsbGluZyBzZXJ2ZXIgdXJsLlxuICAgICAqL1xuICAgIHNldFNpZ25hbGxpbmdVcmxCdWlsZGVyKHNpZ25hbGxpbmdVcmxCdWlsZGVyRnVuYykge1xuICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnNpZ25hbGxpbmdVcmxCdWlsZGVyID0gc2lnbmFsbGluZ1VybEJ1aWxkZXJGdW5jO1xuICAgIH1cbiAgICBnZXQgd2ViUnRjQ29udHJvbGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBnZXR0ZXIgZm9yIHRoZSB3ZWJzb2NrZXQgY29udHJvbGxlci4gQWNjZXNzIHRvIHRoaXMgcHJvcGVydHkgYWxsb3dzIHlvdSB0byBzZW5kXG4gICAgICogY3VzdG9tIHdlYnNvY2tldCBtZXNzYWdlcy5cbiAgICAgKi9cbiAgICBnZXQgc2lnbmFsbGluZ1Byb3RvY29sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2ViUnRjQ29udHJvbGxlci5wcm90b2NvbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIGdldHRlciBmb3IgdGhlIHdlYlhyQ29udHJvbGxlciBjb250cm9sbGVyLiBVc2VkIGZvciBhbGwgWFIgZmVhdHVyZXMuXG4gICAgICovXG4gICAgZ2V0IHdlYlhyQ29udHJvbGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlYlhyQ29udHJvbGxlcjtcbiAgICB9XG4gICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihuYW1lLCBkaXJlY3Rpb24sIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIgJiYgdHlwZW9mIGhhbmRsZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBMb2dnZXIuV2FybmluZyhgVW5hYmxlIHRvIHJlZ2lzdGVyIGFuIHVuZGVmaW5lZCBoYW5kbGVyIGZvciAke25hbWV9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyICYmIHR5cGVvZiBoYW5kbGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKGRpcmVjdGlvbiwgbmFtZSwgKGRhdGEpID0+IHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcihuYW1lLCBkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoZGlyZWN0aW9uLCBuYW1lLCAoZGF0YSkgPT4gaGFuZGxlcihkYXRhKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRvU3RyZWFtZXJIYW5kbGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzO1xuICAgIH1cbiAgICBpc1JlY29ubmVjdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuaXNSZWNvbm5lY3Rpbmc7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGl4ZWxTdHJlYW1pbmcuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42JztcbmV4cG9ydCBjbGFzcyBSZXNwb25zZUNvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJlc3BvbnNlRXZlbnRMaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIHJlc3BvbnNlIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSByZXNwb25zZSBtYXBcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSByZXNwb25zZVxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIFRoZSBtZXRob2QgdG8gYmUgYWN0aXZhdGVkIHdoZW4gdGhlIHJlc3BvbnNlIGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgYWRkUmVzcG9uc2VFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2VFdmVudExpc3RlbmVycy5zZXQobmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSByZXNwb25zZSBldmVudCBsaXN0ZW5lciB0byB0aGUgcmVzcG9uc2UgbWFwXG4gICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcmVzcG9uc2VcbiAgICAgKi9cbiAgICByZW1vdmVSZXNwb25zZUV2ZW50TGlzdGVuZXIobmFtZSkge1xuICAgICAgICB0aGlzLnJlc3BvbnNlRXZlbnRMaXN0ZW5lcnMuZGVsZXRlKG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYSByZXNwb25zZSB3aGVuIHJlY2VpdmluZyBvbmUgZm9ybSB0aGUgc3RyZWFtZXJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIERhdGEgcmVjZWl2ZWQgZnJvbSB0aGUgZGF0YSBjaGFubmVsIHdpdGggdGhlIGNvbW1hbmQgaW4gcXVlc3Rpb25cbiAgICAgKi9cbiAgICBvblJlc3BvbnNlKG1lc3NhZ2UpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ0RhdGFDaGFubmVsUmVjZWl2ZU1lc3NhZ2VUeXBlLlJlc3BvbnNlJyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTE2JykuZGVjb2RlKG1lc3NhZ2Uuc2xpY2UoMSkpO1xuICAgICAgICBMb2dnZXIuSW5mbyhyZXNwb25zZXMpO1xuICAgICAgICB0aGlzLnJlc3BvbnNlRXZlbnRMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyKHJlc3BvbnNlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlc3BvbnNlQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuZXhwb3J0IGNsYXNzIFNlbmRNZXNzYWdlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGFDaGFubmVsU2VuZGVyIC0gRGF0YSBjaGFubmVsIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHRvU3RyZWFtZXJNZXNzYWdlc01hcFByb3ZpZGVyIC0gU3RyZWFtIE1lc3NhZ2VzIGluc3RhbmNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGF0YUNoYW5uZWxTZW5kZXIsIHRvU3RyZWFtZXJNZXNzYWdlc01hcFByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWxTZW5kZXIgPSBkYXRhQ2hhbm5lbFNlbmRlcjtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNNYXBQcm92aWRlciA9IHRvU3RyZWFtZXJNZXNzYWdlc01hcFByb3ZpZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgbWVzc2FnZSB0byB0aGUgc3RyZWFtZXIgdGhyb3VnaCB0aGUgZGF0YSBjaGFubmVsXG4gICAgICogQHBhcmFtIG1lc3NhZ2VUeXBlIC0gdGhlIHR5cGUgb2YgbWVzc2FnZSB3ZSBhcmUgc2VuZGluZ1xuICAgICAqIEBwYXJhbSBtZXNzYWdlRGF0YSAtIHRoZSBtZXNzYWdlIGRhdGEgd2UgYXJlIHNlbmRpbmcgb3ZlciB0aGUgZGF0YSBjaGFubmVsXG4gICAgICogQHJldHVybnMgLSBuaWxcbiAgICAgKi9cbiAgICBzZW5kTWVzc2FnZVRvU3RyZWFtZXIobWVzc2FnZVR5cGUsIG1lc3NhZ2VEYXRhKSB7XG4gICAgICAgIGlmIChtZXNzYWdlRGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtZXNzYWdlRGF0YSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvU3RyZWFtZXJNZXNzYWdlcyA9IHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzTWFwUHJvdmlkZXIudG9TdHJlYW1lck1lc3NhZ2VzO1xuICAgICAgICBjb25zdCBtZXNzYWdlRm9ybWF0ID0gdG9TdHJlYW1lck1lc3NhZ2VzLmdldChtZXNzYWdlVHlwZSk7XG4gICAgICAgIGlmIChtZXNzYWdlRm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihgQXR0ZW1wdGVkIHRvIHNlbmQgYSBtZXNzYWdlIHRvIHRoZSBzdHJlYW1lciB3aXRoIG1lc3NhZ2UgdHlwZTogJHttZXNzYWdlVHlwZX0sIGJ1dCB0aGUgZnJvbnRlbmQgaGFzbid0IGJlZW4gY29uZmlndXJlZCB0byBzZW5kIHN1Y2ggYSBtZXNzYWdlLiBDaGVjayB5b3UndmUgYWRkZWQgdGhlIG1lc3NhZ2UgdHlwZSBpbiB5b3VyIGNwcGApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlRm9ybWF0LnN0cnVjdHVyZSAmJiBtZXNzYWdlRGF0YSAmJiBtZXNzYWdlRm9ybWF0LnN0cnVjdHVyZS5sZW5ndGggIT09IG1lc3NhZ2VEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBQcm92aWRlZCBtZXNzYWdlIGRhdGEgZG9lc24ndCBtYXRjaCBleHBlY3RlZCBsYXlvdXQuIEV4cGVjdGVkIFsgJHttZXNzYWdlRm9ybWF0LnN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIC5tYXAoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndWludDgnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50b1N0cmluZygpfSBdIGJ1dCByZWNlaXZlZCBbICR7bWVzc2FnZURhdGEubWFwKChlbGVtZW50KSA9PiB0eXBlb2YgZWxlbWVudCkudG9TdHJpbmcoKX0gXWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBieXRlTGVuZ3RoID0gMDtcbiAgICAgICAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgLy8gT25lIGxvb3AgdG8gY2FsY3VsYXRlIHRoZSBsZW5ndGggaW4gYnl0ZXMgb2YgYWxsIG9mIHRoZSBwcm92aWRlZCBkYXRhXG4gICAgICAgIG1lc3NhZ2VEYXRhLmZvckVhY2goKGVsZW1lbnQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2VGb3JtYXQuc3RydWN0dXJlW2lkeF07XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgICAgICAgICAgICAgYnl0ZUxlbmd0aCArPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGggKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGggKz0gODtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gMiBieXRlcyBmb3Igc3RyaW5nIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIC8vIDIgYnl0ZXMgcGVyIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgICAgYnl0ZUxlbmd0aCArPSAyICogdGV4dEVuY29kZXIuZW5jb2RlKGVsZW1lbnQpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcihieXRlTGVuZ3RoICsgMSkpO1xuICAgICAgICBkYXRhLnNldFVpbnQ4KDAsIG1lc3NhZ2VGb3JtYXQuaWQpO1xuICAgICAgICBsZXQgYnl0ZU9mZnNldCA9IDE7XG4gICAgICAgIG1lc3NhZ2VEYXRhLmZvckVhY2goKGVsZW1lbnQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2VGb3JtYXQuc3RydWN0dXJlW2lkeF07XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0VWludDgoYnl0ZU9mZnNldCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRVaW50MTYoYnl0ZU9mZnNldCwgZWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEludDE2KGJ5dGVPZmZzZXQsIGVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIGVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0RmxvYXQ2NChieXRlT2Zmc2V0LCBlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldCArPSA4O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNldFVpbnQxNihieXRlT2Zmc2V0LCBlbGVtZW50Lmxlbmd0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldFVpbnQxNihieXRlT2Zmc2V0LCBlbGVtZW50LmNoYXJDb2RlQXQoaSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGFDaGFubmVsU2VuZGVyLmNhblNlbmQoKSkge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oYERhdGEgY2hhbm5lbCBjYW5ub3Qgc2VuZCB5ZXQsIHNraXBwaW5nIHNlbmRpbmcgbWVzc2FnZTogJHttZXNzYWdlVHlwZX0gLSAke25ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyKX1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFDaGFubmVsU2VuZGVyLnNlbmREYXRhKGRhdGEuYnVmZmVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZW5kTWVzc2FnZUNvbnRyb2xsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42JztcbmV4cG9ydCBjbGFzcyBUb1N0cmVhbWVyTWVzc2FnZSB7XG59XG5leHBvcnQgY2xhc3MgU3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZnJvbVN0cmVhbWVyTWVzc2FnZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlIHRoZSBEZWZhdWx0IG1lc3NhZ2UgcHJvdG9jb2xcbiAgICAgKi9cbiAgICBwb3B1bGF0ZURlZmF1bHRQcm90b2NvbCgpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogQ29udHJvbCBNZXNzYWdlcy4gUmFuZ2UgPSAwLi40OS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnSUZyYW1lUmVxdWVzdCcsIHtcbiAgICAgICAgICAgIGlkOiAwLFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdSZXF1ZXN0UXVhbGl0eUNvbnRyb2wnLCB7XG4gICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgIHN0cnVjdHVyZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnRnBzUmVxdWVzdCcsIHtcbiAgICAgICAgICAgIGlkOiAyLFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdBdmVyYWdlQml0cmF0ZVJlcXVlc3QnLCB7XG4gICAgICAgICAgICBpZDogMyxcbiAgICAgICAgICAgIHN0cnVjdHVyZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnU3RhcnRTdHJlYW1pbmcnLCB7XG4gICAgICAgICAgICBpZDogNCxcbiAgICAgICAgICAgIHN0cnVjdHVyZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnU3RvcFN0cmVhbWluZycsIHtcbiAgICAgICAgICAgIGlkOiA1LFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdMYXRlbmN5VGVzdCcsIHtcbiAgICAgICAgICAgIGlkOiA2LFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3N0cmluZyddXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ1JlcXVlc3RJbml0aWFsU2V0dGluZ3MnLCB7XG4gICAgICAgICAgICBpZDogNyxcbiAgICAgICAgICAgIHN0cnVjdHVyZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnVGVzdEVjaG8nLCB7XG4gICAgICAgICAgICBpZDogOCxcbiAgICAgICAgICAgIHN0cnVjdHVyZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnRGF0YUNoYW5uZWxMYXRlbmN5VGVzdCcsIHtcbiAgICAgICAgICAgIGlkOiA5LFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgLypcbiAgICAgICAgICogSW5wdXQgTWVzc2FnZXMuIFJhbmdlID0gNTAuLjg5LlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gR2VuZXJpYyBJbnB1dCBNZXNzYWdlcy4gUmFuZ2UgPSA1MC4uNTkuXG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnVUlJbnRlcmFjdGlvbicsIHtcbiAgICAgICAgICAgIGlkOiA1MCxcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWydzdHJpbmcnXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdDb21tYW5kJywge1xuICAgICAgICAgICAgaWQ6IDUxLFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3N0cmluZyddXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ1RleHRib3hFbnRyeScsIHtcbiAgICAgICAgICAgIGlkOiA1MixcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWydzdHJpbmcnXVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gS2V5Ym9hcmQgSW5wdXQgTWVzc2FnZS4gUmFuZ2UgPSA2MC4uNjkuXG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnS2V5RG93bicsIHtcbiAgICAgICAgICAgIGlkOiA2MCxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAga2V5Q29kZSAgaXNSZXBlYXRcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWyd1aW50OCcsICd1aW50OCddXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ0tleVVwJywge1xuICAgICAgICAgICAgaWQ6IDYxLFxuICAgICAgICAgICAgLy8gICAgICAgICAgICBrZXlDb2RlXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsndWludDgnXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdLZXlQcmVzcycsIHtcbiAgICAgICAgICAgIGlkOiA2MixcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgY2hhcmNvZGVcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWyd1aW50MTYnXVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTW91c2UgSW5wdXQgTWVzc2FnZXMuIFJhbmdlID0gNzAuLjc5LlxuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ01vdXNlRW50ZXInLCB7XG4gICAgICAgICAgICBpZDogNzAsXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ01vdXNlTGVhdmUnLCB7XG4gICAgICAgICAgICBpZDogNzEsXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ01vdXNlRG93bicsIHtcbiAgICAgICAgICAgIGlkOiA3MixcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICBidXR0b24gICAgIHggICAgICAgICB5XG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsndWludDgnLCAndWludDE2JywgJ3VpbnQxNiddXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ01vdXNlVXAnLCB7XG4gICAgICAgICAgICBpZDogNzMsXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgYnV0dG9uICAgICB4ICAgICAgICAgeVxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3VpbnQ4JywgJ3VpbnQxNicsICd1aW50MTYnXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdNb3VzZU1vdmUnLCB7XG4gICAgICAgICAgICBpZDogNzQsXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgeCAgICAgICAgICAgeSAgICAgIGRlbHRhWCAgICBkZWx0YVlcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWyd1aW50MTYnLCAndWludDE2JywgJ2ludDE2JywgJ2ludDE2J11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnTW91c2VXaGVlbCcsIHtcbiAgICAgICAgICAgIGlkOiA3NSxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICBkZWx0YSAgICAgICB4ICAgICAgICB5XG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsnaW50MTYnLCAndWludDE2JywgJ3VpbnQxNiddXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ01vdXNlRG91YmxlJywge1xuICAgICAgICAgICAgaWQ6IDc2LFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGJ1dHRvbiAgICAgeCAgICAgICAgIHlcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWyd1aW50OCcsICd1aW50MTYnLCAndWludDE2J11cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRvdWNoIElucHV0IE1lc3NhZ2VzLiBSYW5nZSA9IDgwLi44OS5cbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdUb3VjaFN0YXJ0Jywge1xuICAgICAgICAgICAgaWQ6IDgwLFxuICAgICAgICAgICAgLy8gICAgICAgICAgbnVtdG91Y2hlcygxKSAgIHggICAgICAgeSAgICAgICAgaWR4ICAgICBmb3JjZSAgICAgdmFsaWRcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWyd1aW50OCcsICd1aW50MTYnLCAndWludDE2JywgJ3VpbnQ4JywgJ3VpbnQ4JywgJ3VpbnQ4J11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnVG91Y2hFbmQnLCB7XG4gICAgICAgICAgICBpZDogODEsXG4gICAgICAgICAgICAvLyAgICAgICAgICBudW10b3VjaGVzKDEpICAgeCAgICAgICB5ICAgICAgICBpZHggICAgIGZvcmNlICAgICB2YWxpZFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3VpbnQ4JywgJ3VpbnQxNicsICd1aW50MTYnLCAndWludDgnLCAndWludDgnLCAndWludDgnXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdUb3VjaE1vdmUnLCB7XG4gICAgICAgICAgICBpZDogODIsXG4gICAgICAgICAgICAvLyAgICAgICAgICBudW10b3VjaGVzKDEpICAgeCAgICAgICB5ICAgICAgIGlkeCAgICAgIGZvcmNlICAgICB2YWxpZFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3VpbnQ4JywgJ3VpbnQxNicsICd1aW50MTYnLCAndWludDgnLCAndWludDgnLCAndWludDgnXVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gR2FtZXBhZCBJbnB1dCBNZXNzYWdlcy4gUmFuZ2UgPSA5MC4uOTlcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdHYW1lcGFkQ29ubmVjdGVkJywge1xuICAgICAgICAgICAgaWQ6IDkzLFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdHYW1lcGFkQnV0dG9uUHJlc3NlZCcsIHtcbiAgICAgICAgICAgIGlkOiA5MCxcbiAgICAgICAgICAgIC8vICAgICAgICAgY3RybGVySWQgICBidXR0b24gIGlzUmVwZWF0XG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsndWludDgnLCAndWludDgnLCAndWludDgnXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdHYW1lcGFkQnV0dG9uUmVsZWFzZWQnLCB7XG4gICAgICAgICAgICBpZDogOTEsXG4gICAgICAgICAgICAvLyAgICAgICAgIGN0cmxlcklkICAgYnV0dG9uICBpc1JlcGVhdCgwKVxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3VpbnQ4JywgJ3VpbnQ4JywgJ3VpbnQ4J11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnR2FtZXBhZEFuYWxvZycsIHtcbiAgICAgICAgICAgIGlkOiA5MixcbiAgICAgICAgICAgIC8vICAgICAgICAgY3RybGVySWQgICBidXR0b24gIGFuYWxvZ1ZhbHVlXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsndWludDgnLCAndWludDgnLCAnZG91YmxlJ11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnR2FtZXBhZERpc2Nvbm5lY3RlZCcsIHtcbiAgICAgICAgICAgIGlkOiA5NCxcbiAgICAgICAgICAgIC8vICAgICAgICAgIGN0cmxlcklkXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsndWludDgnXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJNZXNzYWdlcy5zZXQoMCwgJ1F1YWxpdHlDb250cm9sT3duZXJzaGlwJyk7XG4gICAgICAgIHRoaXMuZnJvbVN0cmVhbWVyTWVzc2FnZXMuc2V0KDEsICdSZXNwb25zZScpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCgyLCAnQ29tbWFuZCcpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCgzLCAnRnJlZXplRnJhbWUnKTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJNZXNzYWdlcy5zZXQoNCwgJ1VuZnJlZXplRnJhbWUnKTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJNZXNzYWdlcy5zZXQoNSwgJ1ZpZGVvRW5jb2RlckF2Z1FQJyk7XG4gICAgICAgIHRoaXMuZnJvbVN0cmVhbWVyTWVzc2FnZXMuc2V0KDYsICdMYXRlbmN5VGVzdCcpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCg3LCAnSW5pdGlhbFNldHRpbmdzJyk7XG4gICAgICAgIHRoaXMuZnJvbVN0cmVhbWVyTWVzc2FnZXMuc2V0KDgsICdGaWxlRXh0ZW5zaW9uJyk7XG4gICAgICAgIHRoaXMuZnJvbVN0cmVhbWVyTWVzc2FnZXMuc2V0KDksICdGaWxlTWltZVR5cGUnKTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJNZXNzYWdlcy5zZXQoMTAsICdGaWxlQ29udGVudHMnKTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJNZXNzYWdlcy5zZXQoMTEsICdUZXN0RWNobycpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCgxMiwgJ0lucHV0Q29udHJvbE93bmVyc2hpcCcpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCgxMywgJ0dhbWVwYWRSZXNwb25zZScpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCgxNCwgJ0RhdGFDaGFubmVsTGF0ZW5jeVRlc3QnKTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJNZXNzYWdlcy5zZXQoMjU1LCAnUHJvdG9jb2wnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBtZXNzYWdlIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZURpcmVjdGlvbiAtIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG1lc3NhZ2U7IHRvU3RyZWFtZXIgb3IgZnJvbVN0cmVhbWVyXG4gICAgICogQHBhcmFtIG1lc3NhZ2VUeXBlIC0gdGhlIHR5cGUgb2YgdGhlIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gbWVzc2FnZUhhbmRsZXIgLSB0aGUgZnVuY3Rpb24gb3IgbWV0aG9kIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhpcyBoYW5kbGVyIGlzIGNhbGxlZFxuICAgICAqL1xuICAgIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIobWVzc2FnZURpcmVjdGlvbiwgbWVzc2FnZVR5cGUsIG1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZURpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXI6XG4gICAgICAgICAgICAgICAgdGhpcy50b1N0cmVhbWVySGFuZGxlcnMuc2V0KG1lc3NhZ2VUeXBlLCBtZXNzYWdlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyOlxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbVN0cmVhbWVySGFuZGxlcnMuc2V0KG1lc3NhZ2VUeXBlLCBtZXNzYWdlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIExvZ2dlci5JbmZvKGBVbmtub3duIG1lc3NhZ2UgZGlyZWN0aW9uICR7bWVzc2FnZURpcmVjdGlvbn1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVGhlIGVudW0gZm9yIG1lc3NhZ2UgZGlyZWN0aW9uc1xuICovXG5leHBvcnQgdmFyIE1lc3NhZ2VEaXJlY3Rpb247XG4oZnVuY3Rpb24gKE1lc3NhZ2VEaXJlY3Rpb24pIHtcbiAgICBNZXNzYWdlRGlyZWN0aW9uW01lc3NhZ2VEaXJlY3Rpb25bXCJUb1N0cmVhbWVyXCJdID0gMF0gPSBcIlRvU3RyZWFtZXJcIjtcbiAgICBNZXNzYWdlRGlyZWN0aW9uW01lc3NhZ2VEaXJlY3Rpb25bXCJGcm9tU3RyZWFtZXJcIl0gPSAxXSA9IFwiRnJvbVN0cmVhbWVyXCI7XG59KShNZXNzYWdlRGlyZWN0aW9uIHx8IChNZXNzYWdlRGlyZWN0aW9uID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5leHBvcnQgY2xhc3MgVG9TdHJlYW1lck1lc3NhZ2VzQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHNlbmRNZXNzYWdlQ29udHJvbGxlciAtIFN0cmVhbSBtZXNzYWdlIGNvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZW5kTWVzc2FnZUNvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIgPSBzZW5kTWVzc2FnZUNvbnRyb2xsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgUmVxdWVzdCB0byBUYWtlIFF1YWxpdHkgQ29udHJvbCB0byB0aGUgVUUgSW5zdGFuY2VcbiAgICAgKi9cbiAgICBTZW5kUmVxdWVzdFF1YWxpdHlDb250cm9sKCkge1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1JlcXVlc3RRdWFsaXR5Q29udHJvbCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIE1heCBGUFMgUmVxdWVzdCB0byB0aGUgVUUgSW5zdGFuY2VcbiAgICAgKi9cbiAgICBTZW5kTWF4RnBzUmVxdWVzdCgpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdGcHNSZXF1ZXN0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgQXZlcmFnZSBCaXRyYXRlIFJlcXVlc3QgdG8gdGhlIFVFIEluc3RhbmNlXG4gICAgICovXG4gICAgU2VuZEF2ZXJhZ2VCaXRyYXRlUmVxdWVzdCgpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdBdmVyYWdlQml0cmF0ZVJlcXVlc3QnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIFN0YXJ0IFN0cmVhbWluZyBNZXNzYWdlIHRvIHRoZSBVRSBJbnN0YW5jZVxuICAgICAqL1xuICAgIFNlbmRTdGFydFN0cmVhbWluZygpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdTdGFydFN0cmVhbWluZycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgU3RvcCBTdHJlYW1pbmcgTWVzc2FnZSB0byB0aGUgVUUgSW5zdGFuY2VcbiAgICAgKi9cbiAgICBTZW5kU3RvcFN0cmVhbWluZygpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdTdG9wU3RyZWFtaW5nJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBSZXF1ZXN0IEluaXRpYWwgU2V0dGluZ3MgdG8gdGhlIFVFIEluc3RhbmNlXG4gICAgICovXG4gICAgU2VuZFJlcXVlc3RJbml0aWFsU2V0dGluZ3MoKSB7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignUmVxdWVzdEluaXRpYWxTZXR0aW5ncycpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRvU3RyZWFtZXJNZXNzYWdlc0NvbnRyb2xsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42JztcbmV4cG9ydCBjbGFzcyBCcm93c2VyVXRpbHMge1xuICAgIHN0YXRpYyBnZXRTdXBwb3J0ZWRWaWRlb0NvZGVjcygpIHtcbiAgICAgICAgY29uc3QgYnJvd3NlclN1cHBvcnRlZENvZGVjcyA9IFtdO1xuICAgICAgICAvLyBUcnkgZ2V0IHRoZSBpbmZvIG5lZWRlZCBmcm9tIHRoZSBSVENSdHBSZWNlaXZlci4gVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBvbiBjaHJvbWVcbiAgICAgICAgaWYgKCFSVENSdHBSZWNlaXZlci5nZXRDYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgICAgIExvZ2dlci5XYXJuaW5nKCdSVENSdHBSZWNlaXZlci5nZXRDYXBhYmlsaXRpZXMgQVBJIGlzIG5vdCBhdmFpbGFibGUgaW4geW91ciBicm93c2VyLCBkZWZhdWx0aW5nIHRvIGd1ZXNzIHRoYXQgd2Ugc3VwcG9ydCBILjI2NC4nKTtcbiAgICAgICAgICAgIGJyb3dzZXJTdXBwb3J0ZWRDb2RlY3MucHVzaCgnSDI2NCBsZXZlbC1hc3ltbWV0cnktYWxsb3dlZD0xO3BhY2tldGl6YXRpb24tbW9kZT0xO3Byb2ZpbGUtbGV2ZWwtaWQ9NDJlMDFmJyk7XG4gICAgICAgICAgICByZXR1cm4gYnJvd3NlclN1cHBvcnRlZENvZGVjcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaGVyID0gLyhWUFxcZHxIMjZcXGR8QVYxKS4qLztcbiAgICAgICAgY29uc3QgY2FwYWJpbGl0aWVzID0gUlRDUnRwUmVjZWl2ZXIuZ2V0Q2FwYWJpbGl0aWVzKCd2aWRlbycpO1xuICAgICAgICBpZiAoIWNhcGFiaWxpdGllcykge1xuICAgICAgICAgICAgYnJvd3NlclN1cHBvcnRlZENvZGVjcy5wdXNoKCdIMjY0IGxldmVsLWFzeW1tZXRyeS1hbGxvd2VkPTE7cGFja2V0aXphdGlvbi1tb2RlPTE7cHJvZmlsZS1sZXZlbC1pZD00MmUwMWYnKTtcbiAgICAgICAgICAgIHJldHVybiBicm93c2VyU3VwcG9ydGVkQ29kZWNzO1xuICAgICAgICB9XG4gICAgICAgIGNhcGFiaWxpdGllcy5jb2RlY3MuZm9yRWFjaCgoY29kZWMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0ciA9IGNvZGVjLm1pbWVUeXBlLnNwbGl0KCcvJylbMV0gKyAnICcgKyAoY29kZWMuc2RwRm10cExpbmUgfHwgJycpO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaGVyLmV4ZWMoc3RyKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJyb3dzZXJTdXBwb3J0ZWRDb2RlY3MucHVzaChzdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJyb3dzZXJTdXBwb3J0ZWRDb2RlY3M7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnJvd3NlclV0aWxzLmpzLm1hcCIsIi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gQUZLIGRpc2Nvbm5lY3QgaXMgYWJvdXQgdG8gaGFwcGVuLlxuICogQ2FuIGJlIGNhbmNlbGxlZCBieSBjYWxsaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBwcm92aWRlZCBhcyBwYXJ0IG9mIHRoZSBldmVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIEFma1dhcm5pbmdBY3RpdmF0ZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ2Fma1dhcm5pbmdBY3RpdmF0ZScpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gdGhlIEFGSyBkaXNjb25uZWN0IGNvdW50ZG93biBpcyB1cGRhdGVkLlxuICovXG5leHBvcnQgY2xhc3MgQWZrV2FybmluZ1VwZGF0ZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ2Fma1dhcm5pbmdVcGRhdGUnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIEFGSyB3YXJuaW5nIGlzIGRlYWN0aXZhdGVkLlxuICovXG5leHBvcnQgY2xhc3MgQWZrV2FybmluZ0RlYWN0aXZhdGVFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ2Fma1dhcm5pbmdEZWFjdGl2YXRlJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBBRksgY291bnRkb3duIHJlYWNoZXMgMCBhbmQgdGhlIHVzZXIgaXMgZGlzY29ubmVjdGVkLlxuICovXG5leHBvcnQgY2xhc3MgQWZrVGltZWRPdXRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ2Fma1RpbWVkT3V0Jyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB3ZSByZWNlaXZlIG5ldyB2aWRlbyBxdWFsaXR5IHZhbHVlLlxuICovXG5leHBvcnQgY2xhc3MgVmlkZW9FbmNvZGVyQXZnUVBFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCd2aWRlb0VuY29kZXJBdmdRUCcpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIGFmdGVyIGEgV2ViUnRjIGNvbm5lY3Rpb24gaGFzIGJlZW4gbmVnb3RpYXRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYlJ0Y1NkcEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignd2ViUnRjU2RwJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXIgdGhlIFNEUCBhbnN3ZXIgaXMgc2V0LlxuICovXG5leHBvcnQgY2xhc3MgV2ViUnRjU2RwQW5zd2VyRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignd2ViUnRjU2RwQW5zd2VyJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXIgdGhlIFNEUCBvZmZlciBpcyBzZXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJSdGNTZHBPZmZlckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ3dlYlJ0Y1NkcE9mZmVyJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBhdXRvIGNvbm5lY3RpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJSdGNBdXRvQ29ubmVjdEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignd2ViUnRjQXV0b0Nvbm5lY3QnKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHNlbmRpbmcgYSBXZWJSdGMgb2ZmZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJSdGNDb25uZWN0aW5nRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCd3ZWJSdGNDb25uZWN0aW5nJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBXZWJSdGMgY29ubmVjdGlvbiBoYXMgYmVlbiBlc3RhYmxpc2hlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYlJ0Y0Nvbm5lY3RlZEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignd2ViUnRjQ29ubmVjdGVkJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgaWYgV2ViUnRjIGNvbm5lY3Rpb24gaGFzIGZhaWxlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYlJ0Y0ZhaWxlZEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignd2ViUnRjRmFpbGVkJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgaWYgV2ViUnRjIGNvbm5lY3Rpb24gaXMgZGlzY29ubmVjdGVkLlxuICovXG5leHBvcnQgY2xhc3MgV2ViUnRjRGlzY29ubmVjdGVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignd2ViUnRjRGlzY29ubmVjdGVkJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBSVENEYXRhQ2hhbm5lbCBpcyBvcGVuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhQ2hhbm5lbE9wZW5FdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdkYXRhQ2hhbm5lbE9wZW4nKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIFJUQ0RhdGFDaGFubmVsIGlzIGNsb3NlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFDaGFubmVsQ2xvc2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdkYXRhQ2hhbm5lbENsb3NlJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgb24gUlRDRGF0YUNoYW5uZWwgZXJyb3JzLlxuICovXG5leHBvcnQgY2xhc3MgRGF0YUNoYW5uZWxFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ2RhdGFDaGFubmVsRXJyb3InKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHRoZSB2aWRlbyBzdHJlYW0gaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBWaWRlb0luaXRpYWxpemVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCd2aWRlb0luaXRpYWxpemVkJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB2aWRlbyBzdHJlYW0gbG9hZGluZyBzdGFydHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1Mb2FkaW5nRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW1Mb2FkaW5nJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB2aWRlbyBzdHJlYW0gbG9hZGluZyBoYXMgZmluaXNoZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1QcmVDb25uZWN0RXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW1Db25uZWN0Jyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB2aWRlbyBzdHJlYW0gaGFzIHN0b3BwZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1QcmVEaXNjb25uZWN0RXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW1EaXNjb25uZWN0Jyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB2aWRlbyBzdHJlYW0gaXMgcmVjb25uZWN0aW5nLlxuICovXG5leHBvcnQgY2xhc3MgU3RyZWFtUmVjb25uZWN0RXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW1SZWNvbm5lY3QnKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBpZiB0aGVyZSBhcmUgZXJyb3JzIGxvYWRpbmcgdGhlIHZpZGVvIHN0cmVhbS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBsYXlTdHJlYW1FcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ3BsYXlTdHJlYW1FcnJvcicpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIGJlZm9yZSB0cnlpbmcgdG8gc3RhcnQgdmlkZW8gcGxheWJhY2suXG4gKi9cbmV4cG9ydCBjbGFzcyBQbGF5U3RyZWFtRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdwbGF5U3RyZWFtJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgaWYgdGhlIGJyb3dzZXIgcmVqZWN0cyB2aWRlbyBwbGF5YmFjay4gQ2FuIGhhcHBlbiBmb3IgZXhhbXBsZSBpZlxuICogdmlkZW8gYXV0by1wbGF5IHdpdGhvdXQgdXNlciBpbnRlcmFjdGlvbiBpcyByZWZ1c2VkIGJ5IHRoZSBicm93c2VyLlxuICovXG5leHBvcnQgY2xhc3MgUGxheVN0cmVhbVJlamVjdGVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigncGxheVN0cmVhbVJlamVjdGVkJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiByZWNlaXZpbmcgYSBmdWxsIEZyZWV6ZUZyYW1lIGltYWdlIGZyb20gVUUuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2FkRnJlZXplRnJhbWVFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdsb2FkRnJlZXplRnJhbWUnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHJlY2VpdmluZyBVbmZyZWV6ZUZyYW1lIG1lc3NhZ2UgZnJvbSBVRSBhbmQgdmlkZW8gcGxheWJhY2sgaXMgYWJvdXQgdG8gYmUgcmVzdW1lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEhpZGVGcmVlemVGcmFtZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignaGlkZUZyZWV6ZUZyYW1lJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiByZWNlaXZpbmcgV2ViUlRDIHN0YXRpc3RpY3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGF0c1JlY2VpdmVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignc3RhdHNSZWNlaXZlZCcpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gc3RyZWFtZXIgbGlzdCBjaGFuZ2VzLlxuICovXG5leHBvcnQgY2xhc3MgU3RyZWFtZXJMaXN0TWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbWVyTGlzdE1lc3NhZ2UnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIGEgc3Vic2NyaWJlZCB0byBzdHJlYW1lcidzIGlkIGNoYW5nZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1lcklEQ2hhbmdlZE1lc3NhZ2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdTdHJlYW1lcklEQ2hhbmdlZE1lc3NhZ2UnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHJlY2VpdmluZyBsYXRlbmN5IHRlc3QgcmVzdWx0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIExhdGVuY3lUZXN0UmVzdWx0RXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignbGF0ZW5jeVRlc3RSZXN1bHQnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBldmVyeXRpbWUgbGF0ZW5jeSBpcyBjYWxjdWxhdGVkIHVzaW5nIHRoZSBXZWJSVEMgc3RhdHMgQVBJLlxuICovXG5leHBvcnQgY2xhc3MgTGF0ZW5jeUNhbGN1bGF0ZWRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdsYXRlbmN5Q2FsY3VsYXRlZCcpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gd2UgcmVjZWl2ZSB0aGUgXCJvblNjcmVlbktleWJvYXJkXCIgY29tbWFuZCBmcm9tIFVFLlxuICovXG5leHBvcnQgY2xhc3MgU2hvd09uU2NyZWVuS2V5Ym9hcmRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdzaG93T25TY3JlZW5LZXlib2FyZCcpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gcmVjZWl2aW5nIGRhdGEgY2hhbm5lbCBsYXRlbmN5IHRlc3QgcmVzcG9uc2UgZnJvbSBzZXJ2ZXIuXG4gKiBUaGlzIGV2ZW50IGlzIGhhbmRsZWQgYnkgRGF0YUNoYW5uZWxMYXRlbmN5VGVzdENvbnRyb2xsZXJcbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXNwb25zZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ2RhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXNwb25zZScpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gZGF0YSBjaGFubmVsIGxhdGVuY3kgdGVzdCByZXN1bHRzIGFyZSByZWFkeS5cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXN1bHRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdkYXRhQ2hhbm5lbExhdGVuY3lUZXN0UmVzdWx0Jyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFN1YnNjcmliZUZhaWxlZEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ3N1YnNjcmliZUZhaWxlZCcpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gcmVjZWl2aW5nIGluaXRpYWwgc2V0dGluZ3MgZnJvbSBVRS5cbiAqL1xuZXhwb3J0IGNsYXNzIEluaXRpYWxTZXR0aW5nc0V2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ2luaXRpYWxTZXR0aW5ncycpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gUGl4ZWxTdHJlYW1pbmcgc2V0dGluZ3MgY2hhbmdlLlxuICovXG5leHBvcnQgY2xhc3MgU2V0dGluZ3NDaGFuZ2VkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignc2V0dGluZ3NDaGFuZ2VkJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBFdmVudCBlbWl0dGVkIHdoZW4gYW4gWFIgU2Vzc2lvbiBzdGFydHNcbiAqL1xuZXhwb3J0IGNsYXNzIFhyU2Vzc2lvblN0YXJ0ZWRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3hyU2Vzc2lvblN0YXJ0ZWQnKTtcbiAgICB9XG59XG4vKipcbiAqIEV2ZW50IGVtaXR0ZWQgd2hlbiBhbiBYUiBTZXNzaW9uIGVuZHNcbiAqL1xuZXhwb3J0IGNsYXNzIFhyU2Vzc2lvbkVuZGVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCd4clNlc3Npb25FbmRlZCcpO1xuICAgIH1cbn1cbi8qKlxuICogRXZlbnQgZW1pdHRlZCB3aGVuIGFuIFhSIEZyYW1lIGlzIGNvbXBsZXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBYckZyYW1lRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigneHJGcmFtZScpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gcmVjZWl2aW5nIGEgcGxheWVyIGNvdW50IGZyb20gdGhlIHNpZ25hbGxpbmcgc2VydmVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQbGF5ZXJDb3VudEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ3BsYXllckNvdW50Jyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB0aGUgd2ViUlRDIGNvbm5lY3Rpb25zIGlzIHJlbGF5ZWQgb3ZlciBUQ1AuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJSdGNUQ1BSZWxheURldGVjdGVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCd3ZWJSdGNUQ1BSZWxheURldGVjdGVkJyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFBpeGVsU3RyZWFtaW5nRXZlbnRFbWl0dGVyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGEgbmV3IGV2ZW50LlxuICAgICAqIEBwYXJhbSBlIGV2ZW50XG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBkaXNwYXRjaEV2ZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGhhbmRsZXIuXG4gICAgICogQHBhcmFtIHR5cGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXIuXG4gICAgICogQHBhcmFtIHR5cGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudEVtaXR0ZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42Jztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcG9wdWxhdGUgZmlsZSBpbmZvcm1hdGlvbiBmcm9tIGJ5dGUgYnVmZmVycy5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVVdGlsIHtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgYSBmaWxlcyBleHRlbnNpb24gd2hlbiByZWNlaXZlZCBvdmVyIGRhdGEgY2hhbm5lbFxuICAgICAqIEBwYXJhbSB2aWV3IC0gdGhlIGZpbGUgZXh0ZW5zaW9uIGRhdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0RXh0ZW5zaW9uRnJvbUJ5dGVzKHZpZXcsIGZpbGUpIHtcbiAgICAgICAgLy8gUmVzZXQgZmlsZSBpZiB3ZSBnb3QgYSBmaWxlIG1lc3NhZ2UgYW5kIHdlIGFyZSBub3QgXCJyZWNlaXZpbmdcIiBpdCB5ZXRcbiAgICAgICAgaWYgKCFmaWxlLnJlY2VpdmluZykge1xuICAgICAgICAgICAgZmlsZS5taW1ldHlwZSA9ICcnO1xuICAgICAgICAgICAgZmlsZS5leHRlbnNpb24gPSAnJztcbiAgICAgICAgICAgIGZpbGUucmVjZWl2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGZpbGUudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZpbGUuY2h1bmtzID0gMDtcbiAgICAgICAgICAgIGZpbGUuZGF0YSA9IFtdO1xuICAgICAgICAgICAgZmlsZS50aW1lc3RhbXBTdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ1JlY2VpdmVkIGZpcnN0IGNodW5rIG9mIGZpbGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHRlbnNpb25Bc1N0cmluZyA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTE2JykuZGVjb2RlKHZpZXcuc2xpY2UoMSkpO1xuICAgICAgICBMb2dnZXIuSW5mbyhleHRlbnNpb25Bc1N0cmluZyk7XG4gICAgICAgIGZpbGUuZXh0ZW5zaW9uID0gZXh0ZW5zaW9uQXNTdHJpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBhIGZpbGVzIG1pbWUgdHlwZSB3aGVuIHJlY2VpdmVkIG92ZXIgZGF0YSBjaGFubmVsXG4gICAgICogQHBhcmFtIHZpZXcgLSB0aGUgZmlsZSBtaW1lIHR5cGUgZGF0YVxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRNaW1lVHlwZUZyb21CeXRlcyh2aWV3LCBmaWxlKSB7XG4gICAgICAgIC8vIFJlc2V0IGZpbGUgaWYgd2UgZ290IGEgZmlsZSBtZXNzYWdlIGFuZCB3ZSBhcmUgbm90IFwicmVjZWl2aW5nXCIgaXQgeWV0XG4gICAgICAgIGlmICghZmlsZS5yZWNlaXZpbmcpIHtcbiAgICAgICAgICAgIGZpbGUubWltZXR5cGUgPSAnJztcbiAgICAgICAgICAgIGZpbGUuZXh0ZW5zaW9uID0gJyc7XG4gICAgICAgICAgICBmaWxlLnJlY2VpdmluZyA9IHRydWU7XG4gICAgICAgICAgICBmaWxlLnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICBmaWxlLmNodW5rcyA9IDA7XG4gICAgICAgICAgICBmaWxlLmRhdGEgPSBbXTtcbiAgICAgICAgICAgIGZpbGUudGltZXN0YW1wU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdSZWNlaXZlZCBmaXJzdCBjaHVuayBvZiBmaWxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWltZUFzU3RyaW5nID0gbmV3IFRleHREZWNvZGVyKCd1dGYtMTYnKS5kZWNvZGUodmlldy5zbGljZSgxKSk7XG4gICAgICAgIExvZ2dlci5JbmZvKG1pbWVBc1N0cmluZyk7XG4gICAgICAgIGZpbGUubWltZXR5cGUgPSBtaW1lQXNTdHJpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBhIGZpbGVzIGNvbnRlbnRzIHdoZW4gcmVjZWl2ZWQgb3ZlciBkYXRhIGNoYW5uZWxcbiAgICAgKiBAcGFyYW0gdmlldyAtIHRoZSBmaWxlIGNvbnRlbnRzIGRhdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0Q29udGVudHNGcm9tQnl0ZXModmlldywgZmlsZSkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IHJlY2VpdmVkIHRoZSBpbml0aWFsIHNldHVwIGluc3RydWN0aW9ucywgcmV0dXJuXG4gICAgICAgIGlmICghZmlsZS5yZWNlaXZpbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHR5cGVTaXplID0gMTtcbiAgICAgICAgY29uc3QgaW50U2l6ZSA9IDQ7XG4gICAgICAgIGNvbnN0IG1heE1lc3NhZ2VTaXplID0gMTYgKiAxMDI0O1xuICAgICAgICBjb25zdCBoZWFkZXJTaXplID0gdHlwZVNpemUgKyBpbnRTaXplO1xuICAgICAgICBjb25zdCBtYXhQYXlsb2FkU2l6ZSA9IG1heE1lc3NhZ2VTaXplIC0gaGVhZGVyU2l6ZTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRvdGFsIG51bWJlciBvZiBjaHVua3MgZnJvbSB0aGUgdG90YWwgZmlsZSBzaXplXG4gICAgICAgIGZpbGUuY2h1bmtzID0gTWF0aC5jZWlsKG5ldyBEYXRhVmlldyh2aWV3LnNsaWNlKHR5cGVTaXplLCBoZWFkZXJTaXplKS5idWZmZXIpLmdldEludDMyKDAsIHRydWUpIC8gbWF4UGF5bG9hZFNpemUpO1xuICAgICAgICAvLyBHZXQgdGhlIGZpbGUgcGFydCBvZiB0aGUgcGF5bG9hZFxuICAgICAgICBjb25zdCBmaWxlQnl0ZXMgPSB2aWV3LnNsaWNlKGhlYWRlclNpemUpO1xuICAgICAgICAvLyBBcHBlbmQgdG8gZXhpc3RpbmcgZGF0YSB0aGF0IGhvbGRzIHRoZSBmaWxlXG4gICAgICAgIGZpbGUuZGF0YS5wdXNoKGZpbGVCeXRlcyk7XG4gICAgICAgIC8vIFVuY29tbWVudCBmb3IgZGVidWdcbiAgICAgICAgTG9nZ2VyLkluZm8oYFJlY2VpdmVkIGZpbGUgY2h1bms6ICR7ZmlsZS5kYXRhLmxlbmd0aH0vJHtmaWxlLmNodW5rc31gKTtcbiAgICAgICAgaWYgKGZpbGUuZGF0YS5sZW5ndGggPT09IGZpbGUuY2h1bmtzKSB7XG4gICAgICAgICAgICBmaWxlLnJlY2VpdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgZmlsZS52YWxpZCA9IHRydWU7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnUmVjZWl2ZWQgY29tcGxldGUgZmlsZScpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmZXJEdXJhdGlvbiA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gZmlsZS50aW1lc3RhbXBTdGFydDtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZmVyQml0cmF0ZSA9IE1hdGgucm91bmQoKGZpbGUuY2h1bmtzICogbWF4TWVzc2FnZVNpemUpIC8gdHJhbnNmZXJEdXJhdGlvbik7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbyhgQXZlcmFnZSB0cmFuc2ZlciBiaXRyYXRlOiAke3RyYW5zZmVyQml0cmF0ZX1rYi9zIG92ZXIgJHt0cmFuc2ZlckR1cmF0aW9uIC8gMTAwMH0gc2Vjb25kc2ApO1xuICAgICAgICAgICAgLy8gRmlsZSByZWNvbnN0cnVjdGlvblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFeGFtcGxlIGNvZGUgdG8gcmVjb25zdHJ1Y3QgdGhlIGZpbGVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGlzIGNvZGUgcmVjb25zdHJ1Y3RzIHRoZSByZWNlaXZlZCBkYXRhIGludG8gdGhlIG9yaWdpbmFsIGZpbGUgYmFzZWQgb24gdGhlIG1pbWUgdHlwZSBhbmQgZXh0ZW5zaW9uIHByb3ZpZGVkIGFuZCB0aGVuIGRvd25sb2FkcyB0aGUgcmVjb25zdHJ1Y3RlZCBmaWxlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHJlY2VpdmVkID0gbmV3IEJsb2IoZmlsZS5kYXRhLCB7IHR5cGU6IGZpbGUubWltZXR5cGUgfSk7XG4gICAgICAgICAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBVUkwuY3JlYXRlT2JqZWN0VVJMKHJlY2VpdmVkKSk7XG4gICAgICAgICAgICBhLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBgdHJhbnNmZXIuJHtmaWxlLmV4dGVuc2lvbn1gKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGEpO1xuICAgICAgICAgICAgLy8gaWYgeW91IGFyZSBzbyBpbmNsaW5lZCB0byBtYWtlIGl0IGF1dG8tZG93bmxvYWQsIGRvIHNvbWV0aGluZyBsaWtlOiBhLmNsaWNrKCk7XG4gICAgICAgICAgICBhLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbGUuZGF0YS5sZW5ndGggPiBmaWxlLmNodW5rcykge1xuICAgICAgICAgICAgZmlsZS5yZWNlaXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihgUmVjZWl2ZWQgYmlnZ2VyIGZpbGUgdGhhbiBhZHZlcnRpc2VkOiAke2ZpbGUuZGF0YS5sZW5ndGh9LyR7ZmlsZS5jaHVua3N9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgdGVtcGxhdGUgZm9yIGEgZG93bmxvYWRlZCBmaWxlXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWxlVGVtcGxhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1pbWV0eXBlID0gJyc7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gJyc7XG4gICAgICAgIHRoaXMucmVjZWl2aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gMDtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWxlVXRpbC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBBIGNhc2UgaW5zZW5zaXRpdmUsIHBhcnRpYWwgaW1wbGVtZW50YXRpb24gb2YgVVJMU2VhcmNoUGFyYW1zXG4gKi9cbmV4cG9ydCBjbGFzcyBJVVJMU2VhcmNoUGFyYW1zIHtcbiAgICBjb25zdHJ1Y3RvcihzZWFyY2gpIHtcbiAgICAgICAgdGhpcy5fdXJsUGFyYW1zID0ge307XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKTtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIHVybFBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5fdXJsUGFyYW1zW25hbWUudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXMobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpIGluIHRoaXMuX3VybFBhcmFtcztcbiAgICB9XG4gICAgZ2V0KG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXJsUGFyYW1zW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SVVSTFNlYXJjaFBhcmFtcy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBDb252ZXJ0cyBjb29yZGluYXRlcyBmcm9tIGVsZW1lbnQgcmVsYXRpdmUgY29vcmRpbmF0ZXMgdG8gdmFsdWVzIG5vcm1hbGl6ZWQgd2l0aGluIHRoZSB2YWx1ZSByYW5nZSBvZiBhIHNob3J0IChhbmQgYmFjayBhZ2FpbilcbiAqL1xuZXhwb3J0IGNsYXNzIElucHV0Q29vcmRUcmFuc2xhdG9yIHtcbiAgICAvLyB3ZSBkb250IHVzZSBhIGNvbnN0cnVjdG9yIGhlcmUgYmVjYXVzZSB0aGUgb2JqZWN0IGlzIGNyZWF0ZWQgYW5kIHBhc3NlZCBhcm91bmQgdG8gdmFyaW91cyBsb2NhdGlvbnNcbiAgICAvLyBwb3NzaWJseSBiZWZvcmUgdGhpcyBtZXRob2QgaXMgY2FsbGVkLlxuICAgIHJlY29uZmlndXJlKHBsYXllclNpemUsIHZpZGVvU2l6ZSkge1xuICAgICAgICBjb25zdCBwbGF5ZXJBc3BlY3RSYXRpbyA9IHBsYXllclNpemUuaGVpZ2h0IC8gcGxheWVyU2l6ZS53aWR0aDtcbiAgICAgICAgY29uc3QgdmlkZW9Bc3BlY3RSYXRpbyA9IHZpZGVvU2l6ZS5oZWlnaHQgLyB2aWRlb1NpemUud2lkdGg7XG4gICAgICAgIHRoaXMucGxheWVySXNMYXJnZXIgPSBwbGF5ZXJBc3BlY3RSYXRpbyA+IHZpZGVvQXNwZWN0UmF0aW87XG4gICAgICAgIHRoaXMucGxheWVyU2l6ZSA9IHBsYXllclNpemU7XG4gICAgICAgIHRoaXMucmF0aW8gPSB0aGlzLnBsYXllcklzTGFyZ2VyXG4gICAgICAgICAgICA/IHBsYXllckFzcGVjdFJhdGlvIC8gdmlkZW9Bc3BlY3RSYXRpb1xuICAgICAgICAgICAgOiB2aWRlb0FzcGVjdFJhdGlvIC8gcGxheWVyQXNwZWN0UmF0aW87XG4gICAgfVxuICAgIHRyYW5zbGF0ZVVuc2lnbmVkKHgsIHkpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFggPSB0aGlzLnBsYXllcklzTGFyZ2VyXG4gICAgICAgICAgICA/IHggLyB0aGlzLnBsYXllclNpemUud2lkdGhcbiAgICAgICAgICAgIDogdGhpcy5yYXRpbyAqICh4IC8gdGhpcy5wbGF5ZXJTaXplLndpZHRoIC0gMC41KSArIDAuNTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFkgPSB0aGlzLnBsYXllcklzTGFyZ2VyXG4gICAgICAgICAgICA/IHRoaXMucmF0aW8gKiAoeSAvIHRoaXMucGxheWVyU2l6ZS5oZWlnaHQgLSAwLjUpICsgMC41XG4gICAgICAgICAgICA6IHkgLyB0aGlzLnBsYXllclNpemUuaGVpZ2h0O1xuICAgICAgICBpZiAobm9ybWFsaXplZFggPCAwLjAgfHwgbm9ybWFsaXplZFggPiAxLjAgfHwgbm9ybWFsaXplZFkgPCAwLjAgfHwgbm9ybWFsaXplZFkgPiAxLjApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGluUmFuZ2U6IGZhbHNlLCB4OiA2NTUzNSwgeTogNjU1MzUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGluUmFuZ2U6IHRydWUsIHg6IG5vcm1hbGl6ZWRYICogNjU1MzYsIHk6IG5vcm1hbGl6ZWRZICogNjU1MzYgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFuc2xhdGVTaWduZWQoeCwgeSkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkWCA9IHRoaXMucGxheWVySXNMYXJnZXJcbiAgICAgICAgICAgID8geCAvICgwLjUgKiB0aGlzLnBsYXllclNpemUud2lkdGgpXG4gICAgICAgICAgICA6ICh0aGlzLnJhdGlvICogeCkgLyAoMC41ICogdGhpcy5wbGF5ZXJTaXplLndpZHRoKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFkgPSB0aGlzLnBsYXllcklzTGFyZ2VyXG4gICAgICAgICAgICA/ICh0aGlzLnJhdGlvICogeSkgLyAoMC41ICogdGhpcy5wbGF5ZXJTaXplLmhlaWdodClcbiAgICAgICAgICAgIDogeSAvICgwLjUgKiB0aGlzLnBsYXllclNpemUuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHsgeDogbm9ybWFsaXplZFggKiAzMjc2NywgeTogbm9ybWFsaXplZFkgKiAzMjc2NyB9O1xuICAgIH1cbiAgICB1bnRyYW5zbGF0ZVVuc2lnbmVkKHgsIHkpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFggPSB0aGlzLnBsYXllcklzTGFyZ2VyID8geCAvIDY1NTM2IDogKHggLyA2NTUzNiAtIDAuNSkgLyB0aGlzLnJhdGlvICsgMC41O1xuICAgICAgICBjb25zdCBub3JtYWxpemVkWSA9IHRoaXMucGxheWVySXNMYXJnZXIgPyAoeSAvIDY1NTM2IC0gMC41KSAvIHRoaXMucmF0aW8gKyAwLjUgOiB5IC8gNjU1MzY7XG4gICAgICAgIHJldHVybiB7IHg6IG5vcm1hbGl6ZWRYICogdGhpcy5wbGF5ZXJTaXplLndpZHRoLCB5OiBub3JtYWxpemVkWSAqIHRoaXMucGxheWVyU2l6ZS5oZWlnaHQgfTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnB1dENvb3JkVHJhbnNsYXRvci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuZXhwb3J0IGNsYXNzIFJUQ1V0aWxzIHtcbiAgICBzdGF0aWMgaXNWaWRlb1RyYW5zY2VpdmVyKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhblRyYW5zY2VpdmVyUmVjZWl2ZVZpZGVvKHRyYW5zY2VpdmVyKSB8fCB0aGlzLmNhblRyYW5zY2VpdmVyU2VuZFZpZGVvKHRyYW5zY2VpdmVyKTtcbiAgICB9XG4gICAgc3RhdGljIGNhblRyYW5zY2VpdmVyUmVjZWl2ZVZpZGVvKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiAoISF0cmFuc2NlaXZlciAmJlxuICAgICAgICAgICAgKHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2JyB8fCB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdyZWN2b25seScpICYmXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlciAmJlxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09ICd2aWRlbycpO1xuICAgIH1cbiAgICBzdGF0aWMgY2FuVHJhbnNjZWl2ZXJTZW5kVmlkZW8odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuICghIXRyYW5zY2VpdmVyICYmXG4gICAgICAgICAgICAodHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnIHx8IHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3NlbmRvbmx5JykgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRlciAmJlxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrICYmXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2sua2luZCA9PT0gJ3ZpZGVvJyk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0F1ZGlvVHJhbnNjZWl2ZXIodHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuVHJhbnNjZWl2ZXJSZWNlaXZlQXVkaW8odHJhbnNjZWl2ZXIpIHx8IHRoaXMuY2FuVHJhbnNjZWl2ZXJTZW5kQXVkaW8odHJhbnNjZWl2ZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgY2FuVHJhbnNjZWl2ZXJSZWNlaXZlQXVkaW8odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuICghIXRyYW5zY2VpdmVyICYmXG4gICAgICAgICAgICAodHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnIHx8IHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3JlY3Zvbmx5JykgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY2VpdmVyICYmXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjayAmJlxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sua2luZCA9PT0gJ2F1ZGlvJyk7XG4gICAgfVxuICAgIHN0YXRpYyBjYW5UcmFuc2NlaXZlclNlbmRBdWRpbyh0cmFuc2NlaXZlcikge1xuICAgICAgICByZXR1cm4gKCEhdHJhbnNjZWl2ZXIgJiZcbiAgICAgICAgICAgICh0cmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdzZW5kcmVjdicgfHwgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZG9ubHknKSAmJlxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZGVyICYmXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2sgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRlci50cmFjay5raW5kID09PSAnYXVkaW8nKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SVENVdGlscy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuLyoqXG4gKiBWaWRlbyBQbGF5ZXIgQ29udHJvbGxlciBoYW5kbGVzIHRoZSBjcmVhdGlvbiBvZiB0aGUgdmlkZW8gSFRNTCBlbGVtZW50IGFuZCBhbGwgaGFuZGxlcnNcbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2aWRlb0VsZW1lbnRQcm92aWRlciBWaWRlbyBQbGF5ZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2aWRlb0VsZW1lbnRQcm92aWRlcikge1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFByb3ZpZGVyID0gdmlkZW9FbGVtZW50UHJvdmlkZXI7XG4gICAgICAgIHRoaXMuYXVkaW9FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQXVkaW8nKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQcm92aWRlci5zZXRBdWRpb0VsZW1lbnQodGhpcy5hdWRpb0VsZW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gdGhlIFBlZXIgY29ubmVjdGlvbiBoYXMgYSB0cmFjayBldmVudFxuICAgICAqIEBwYXJhbSBydGNUcmFja0V2ZW50IC0gUlRDIFRyYWNrIEV2ZW50XG4gICAgICovXG4gICAgaGFuZGxlT25UcmFjayhydGNUcmFja0V2ZW50KSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCdoYW5kbGVPblRyYWNrICcgKyBKU09OLnN0cmluZ2lmeShydGNUcmFja0V2ZW50LnN0cmVhbXMpKTtcbiAgICAgICAgLy8gRG8gbm90IGFkZCB0aGUgdHJhY2sgaWYgdGhlIElEIGlzIGBwcm9iYXRvcmAgYXMgdGhpcyBpcyBzcGVjaWFsIHRyYWNrIGNyZWF0ZWQgYnkgbWVkaWFzb3VwIGZvciBiaXRyYXRlIHByb2JpbmcuXG4gICAgICAgIC8vIFJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9FcGljR2FtZXNFeHQvUGl4ZWxTdHJlYW1pbmdJbmZyYXN0cnVjdHVyZS9wdWxsLzg2IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIGlmIChydGNUcmFja0V2ZW50LnN0cmVhbXMubGVuZ3RoIDwgMSB8fCBydGNUcmFja0V2ZW50LnN0cmVhbXNbMF0uaWQgPT0gJ3Byb2JhdG9yJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZGVvRWxlbWVudCA9IHRoaXMudmlkZW9FbGVtZW50UHJvdmlkZXIuZ2V0VmlkZW9FbGVtZW50KCk7XG4gICAgICAgIGlmIChydGNUcmFja0V2ZW50LnRyYWNrKSB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnR290IHRyYWNrIC0gJyArXG4gICAgICAgICAgICAgICAgcnRjVHJhY2tFdmVudC50cmFjay5raW5kICtcbiAgICAgICAgICAgICAgICAnIGlkPScgK1xuICAgICAgICAgICAgICAgIHJ0Y1RyYWNrRXZlbnQudHJhY2suaWQgK1xuICAgICAgICAgICAgICAgICcgcmVhZHlTdGF0ZT0nICtcbiAgICAgICAgICAgICAgICBydGNUcmFja0V2ZW50LnRyYWNrLnJlYWR5U3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydGNUcmFja0V2ZW50LnRyYWNrLmtpbmQgPT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgdGhpcy5DcmVhdGVBdWRpb1RyYWNrKHJ0Y1RyYWNrRXZlbnQuc3RyZWFtc1swXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnRjVHJhY2tFdmVudC50cmFjay5raW5kID09ICd2aWRlbycgJiZcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zcmNPYmplY3QgIT09IHJ0Y1RyYWNrRXZlbnQuc3RyZWFtc1swXSkge1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNyY09iamVjdCA9IHJ0Y1RyYWNrRXZlbnQuc3RyZWFtc1swXTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdTZXQgdmlkZW8gc291cmNlIGZyb20gdmlkZW8gdHJhY2sgb250cmFjay4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBhdWRpbyBkZXZpY2Ugd2hlbiByZWNlaXZpbmcgYW4gUlRDVHJhY2tFdmVudCB3aXRoIHRoZSBraW5kIG9mIFwiYXVkaW9cIlxuICAgICAqIEBwYXJhbSBhdWRpb01lZGlhU3RyZWFtIC0gQXVkaW8gTWVkaWEgc3RyZWFtIHRyYWNrXG4gICAgICovXG4gICAgQ3JlYXRlQXVkaW9UcmFjayhhdWRpb01lZGlhU3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHZpZGVvRWxlbWVudCA9IHRoaXMudmlkZW9FbGVtZW50UHJvdmlkZXIuZ2V0VmlkZW9FbGVtZW50KCk7XG4gICAgICAgIC8vIGRvIG5vdGhpbmcgdGhlIHZpZGVvIGhhcyB0aGUgc2FtZSBtZWRpYSBzdHJlYW0gYXMgdGhlIGF1ZGlvIHRyYWNrIHdlIGhhdmUgaGVyZSAodGhleSBhcmUgbGlua2VkKVxuICAgICAgICBpZiAodmlkZW9FbGVtZW50LnNyY09iamVjdCA9PSBhdWRpb01lZGlhU3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gdmlkZW8gZWxlbWVudCBoYXMgc29tZSBvdGhlciBtZWRpYSBzdHJlYW0gdGhhdCBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYXVkaW8gdHJhY2tcbiAgICAgICAgZWxzZSBpZiAodmlkZW9FbGVtZW50LnNyY09iamVjdCAmJiB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ICE9PSBhdWRpb01lZGlhU3RyZWFtKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgYXVkaW8gZWxlbWVudFxuICAgICAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnQuc3JjT2JqZWN0ID0gYXVkaW9NZWRpYVN0cmVhbTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdDcmVhdGVkIG5ldyBhdWRpbyBlbGVtZW50IHRvIHBsYXkgc2VwYXJhdGUgYXVkaW8gc3RyZWFtLicpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RyZWFtQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgRmxhZ3MgfSBmcm9tICcuLi9Db25maWcvQ29uZmlnJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42Jztcbi8qKlxuICogVGhlIHZpZGVvIHBsYXllciBodG1sIGVsZW1lbnRcbiAqL1xuZXhwb3J0IGNsYXNzIFZpZGVvUGxheWVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmlkZW9FbGVtZW50UGFyZW50IHRoZSBodG1sIGRpdiB0aGUgdGhlIHZpZGVvIHBsYXllciB3aWxsIGJlIGluamVjdGVkIGludG9cbiAgICAgKiBAcGFyYW0gY29uZmlnIHRoZSBhcHBsaWNhdGlvbnMgY29uZmlndXJhdGlvbi4gV2UncmUgaW50ZXJlc3RlZCBpbiB0aGUgc3RhcnRWaWRlb011dGVkIGZsYWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2aWRlb0VsZW1lbnRQYXJlbnQsIGNvbmZpZykge1xuICAgICAgICB0aGlzLmxhc3RUaW1lUmVzaXplZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5pZCA9ICdzdHJlYW1pbmdWaWRlbyc7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LmRpc2FibGVQaWN0dXJlSW5QaWN0dXJlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQucGxheXNJbmxpbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYWxsJztcbiAgICAgICAgdmlkZW9FbGVtZW50UGFyZW50LmFwcGVuZENoaWxkKHRoaXMudmlkZW9FbGVtZW50KTtcbiAgICAgICAgdGhpcy5vblJlc2l6ZVBsYXllckNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1Jlc29sdXRpb24gY2hhbmdlZCwgcmVzdHlsaW5nIHBsYXllciwgZGlkIHlvdSBmb3JnZXQgdG8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbj8nKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbk1hdGNoVmlld3BvcnRSZXNvbHV0aW9uQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmVzb2x1dGlvbiBjaGFuZ2VkIGFuZCBtYXRjaCB2aWV3cG9ydCByZXNvbHV0aW9uIGlzIHR1cm5lZCBvbiwgZGlkIHlvdSBmb3JnZXQgdG8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbj8nKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gc2V0IHBsYXkgZm9yIHZpZGVvIChhbmQgYXVkaW8pXG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50Lm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5hdWRpb0VsZW1lbnQgIT0gdW5kZWZpbmVkICYmIHRoaXMuYXVkaW9FbGVtZW50LnBhdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50LnBsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnZpZGVvRWxlbWVudC5wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5wbGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50Lm9ubG9hZGVkbWV0YWRhdGEgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uVmlkZW9Jbml0aWFsaXplZCgpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBzZXQgcmVzaXplIGV2ZW50cyB0byB0aGUgd2luZG93cyBpZiBpdCBpcyByZXNpemVkIG9yIGl0cyBvcmllbnRhdGlvbiBpcyBjaGFuZ2VkXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB0aGlzLnJlc2l6ZVBsYXllclN0eWxlKCksIHRydWUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCAoKSA9PiB0aGlzLm9uT3JpZW50YXRpb25DaGFuZ2UoKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnNyYyA9ICcnO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9FbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudC5zcmMgPSAnJztcbiAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50LnNyY09iamVjdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRBdWRpb0VsZW1lbnQoYXVkaW9FbGVtZW50KSB7XG4gICAgICAgIHRoaXMuYXVkaW9FbGVtZW50ID0gYXVkaW9FbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSB2aWRlbyBlbGVtZW50IHdpdGggYW55IGFwcGxpY2F0aW9uIGNvbmZpZyBhbmQgcGxheXMgdGhlIHZpZGVvIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIGZvciBpZiBwbGF5aW5nIHRoZSB2aWRlbyB3YXMgc3VjY2Vzc2Z1bCBvciBub3QuXG4gICAgICovXG4gICAgcGxheSgpIHtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQubXV0ZWQgPSB0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLlN0YXJ0VmlkZW9NdXRlZCk7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LmF1dG9wbGF5ID0gdGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5BdXRvUGxheVZpZGVvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9FbGVtZW50LnBsYXkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmlkZW8gZWxlbWVudCBpcyBwYXVzZWQuXG4gICAgICovXG4gICAgaXNQYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZGVvRWxlbWVudC5wYXVzZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIC0gd2hldGhlciB0aGUgdmlkZW8gZWxlbWVudCBpcyBwbGF5aW5nLlxuICAgICAqL1xuICAgIGlzVmlkZW9SZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9FbGVtZW50LnJlYWR5U3RhdGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZpZGVvRWxlbWVudC5yZWFkeVN0YXRlID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmlkZW8gZWxlbWVudCBoYXMgYSB2YWxpZCB2aWRlbyBzb3VyY2UgKHNyY09iamVjdCkuXG4gICAgICovXG4gICAgaGFzVmlkZW9Tb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZGVvRWxlbWVudC5zcmNPYmplY3QgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZpZGVvRWxlbWVudC5zcmNPYmplY3QgIT09IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBjb250ZXh0IG9mIHRoZSBodG1sIHZpZGVvIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyAtIHRoZSBjdXJyZW50IGNvbnRleHQgb2YgdGhlIHZpZGVvIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRWaWRlb0VsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZGVvRWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGNvbnRleHQgb2YgdGhlIGh0bWwgdmlkZW8gZWxlbWVudHMgcGFyZW50XG4gICAgICogQHJldHVybnMgLSB0aGUgY3VycmVudCBjb250ZXh0IG9mIHRoZSB2aWRlbyBlbGVtZW50cyBwYXJlbnRcbiAgICAgKi9cbiAgICBnZXRWaWRlb1BhcmVudEVsZW1lbnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMudmlkZW9FbGVtZW50LnBhcmVudEVsZW1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBWaWRlbyBFbGVtZW50cyBzcmMgb2JqZWN0IHRyYWNrcyB0byBlbmFibGVcbiAgICAgKiBAcGFyYW0gZW5hYmxlZCAtIEVuYWJsZSBUcmFja3Mgb24gdGhlIFNyYyBPYmplY3RcbiAgICAgKi9cbiAgICBzZXRWaWRlb0VuYWJsZWQoZW5hYmxlZCkge1xuICAgICAgICAvLyB0aGlzIGlzIGEgdGVtcG9yYXJ5IGhhY2sgdW50aWwgdHlwZSBzY3JpcHRzIHZpZGVvIGVsZW1lbnQgaXMgdXBkYXRlZCB0byByZWZsZWN0IHRoZSBuZWVkIGZvciB0cmFja3Mgb24gYSBodG1sIHZpZGVvIGVsZW1lbnRcbiAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50ID0gdGhpcy52aWRlb0VsZW1lbnQ7XG4gICAgICAgIHZpZGVvRWxlbWVudC5zcmNPYmplY3RcbiAgICAgICAgICAgIC5nZXRUcmFja3MoKVxuICAgICAgICAgICAgLmZvckVhY2goKHRyYWNrKSA9PiAodHJhY2suZW5hYmxlZCA9IGVuYWJsZWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gb3ZlcnJpZGUgZm9yIHdoZW4gdGhlIHZpZGVvIGhhcyBiZWVuIGluaXRpYWxpemVkIHdpdGggYSBzcmNPYmplY3RcbiAgICAgKi9cbiAgICBvblZpZGVvSW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIC8vIERlZmF1bHQgRnVuY3Rpb25hbGl0eTogRG8gTm90aGluZ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbiB0aGUgb3JpZW50YXRpb24gY2hhbmdlIG9mIGEgd2luZG93IGNsZWFyIHRoZSB0aW1lb3V0XG4gICAgICovXG4gICAgb25PcmllbnRhdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMub3JpZW50YXRpb25DaGFuZ2VUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbkNoYW5nZVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVBsYXllclN0eWxlKCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIHBsYXllciBzdHlsZSBiYXNlZCBvbiB0aGUgd2luZG93IGhlaWdodCBhbmQgd2lkdGhcbiAgICAgKiBAcmV0dXJucyAtIG5pbCBpZiByZXF1aXJlbWVudHMgYXJlIHNhdGlzZmllZFxuICAgICAqL1xuICAgIHJlc2l6ZVBsYXllclN0eWxlKCkge1xuICAgICAgICBjb25zdCB2aWRlb0VsZW1lbnRQYXJlbnQgPSB0aGlzLmdldFZpZGVvUGFyZW50RWxlbWVudCgpO1xuICAgICAgICBpZiAoIXZpZGVvRWxlbWVudFBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlVmlkZW9TdHJlYW1TaXplKCk7XG4gICAgICAgIGlmICh2aWRlb0VsZW1lbnRQYXJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmaXhlZC1zaXplJykpIHtcbiAgICAgICAgICAgIHRoaXMub25SZXNpemVQbGF5ZXJDYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnRyb2xzIGZvciByZXNpemluZyB0aGUgcGxheWVyXG4gICAgICAgIHRoaXMucmVzaXplUGxheWVyU3R5bGVUb0ZpbGxQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgIHRoaXMub25SZXNpemVQbGF5ZXJDYWxsYmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNpemVzIHRoZSBwbGF5ZXIgZWxlbWVudCB0byBmaWxsIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAqL1xuICAgIHJlc2l6ZVBsYXllclN0eWxlVG9GaWxsUGFyZW50RWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50UGFyZW50ID0gdGhpcy5nZXRWaWRlb1BhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgLy9WaWRlbyBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0IHNvIHNldCB2aWRlb0VsZW1lbnRQYXJlbnQgdG8gc2l6ZSBvZiBwYXJlbnQgZWxlbWVudFxuICAgICAgICBjb25zdCBzdHlsZVdpZHRoID0gJzEwMCUnO1xuICAgICAgICBjb25zdCBzdHlsZUhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgY29uc3Qgc3R5bGVUb3AgPSAwO1xuICAgICAgICBjb25zdCBzdHlsZUxlZnQgPSAwO1xuICAgICAgICB2aWRlb0VsZW1lbnRQYXJlbnQuc2V0QXR0cmlidXRlKCdzdHlsZScsICd0b3A6ICcgK1xuICAgICAgICAgICAgc3R5bGVUb3AgK1xuICAgICAgICAgICAgJ3B4OyBsZWZ0OiAnICtcbiAgICAgICAgICAgIHN0eWxlTGVmdCArXG4gICAgICAgICAgICAncHg7IHdpZHRoOiAnICtcbiAgICAgICAgICAgIHN0eWxlV2lkdGggK1xuICAgICAgICAgICAgJzsgaGVpZ2h0OiAnICtcbiAgICAgICAgICAgIHN0eWxlSGVpZ2h0ICtcbiAgICAgICAgICAgICc7IGN1cnNvcjogZGVmYXVsdDsnKTtcbiAgICB9XG4gICAgdXBkYXRlVmlkZW9TdHJlYW1TaXplKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuTWF0Y2hWaWV3cG9ydFJlc29sdXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIGlmIChub3cgLSB0aGlzLmxhc3RUaW1lUmVzaXplZCA+IDMwMCkge1xuICAgICAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50UGFyZW50ID0gdGhpcy5nZXRWaWRlb1BhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmICghdmlkZW9FbGVtZW50UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vbk1hdGNoVmlld3BvcnRSZXNvbHV0aW9uQ2FsbGJhY2sodmlkZW9FbGVtZW50UGFyZW50LmNsaWVudFdpZHRoLCB2aWRlb0VsZW1lbnRQYXJlbnQuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMubGFzdFRpbWVSZXNpemVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnUmVzaXppbmcgdG9vIG9mdGVuIC0gc2tpcHBpbmcnKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVvdXRIYW5kbGUpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0SGFuZGxlID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGVWaWRlb1N0cmVhbVNpemUoKSwgMTAwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpZGVvUGxheWVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBXZWJTb2NrZXRUcmFuc3BvcnQsIExvZ2dlciwgU2lnbmFsbGluZ1Byb3RvY29sLCBNZXNzYWdlcywgTWVzc2FnZUhlbHBlcnMsIEtlZXBhbGl2ZU1vbml0b3IgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG5pbXBvcnQgeyBTdHJlYW1Db250cm9sbGVyIH0gZnJvbSAnLi4vVmlkZW9QbGF5ZXIvU3RyZWFtQ29udHJvbGxlcic7XG5pbXBvcnQgeyBGcmVlemVGcmFtZUNvbnRyb2xsZXIgfSBmcm9tICcuLi9GcmVlemVGcmFtZS9GcmVlemVGcmFtZUNvbnRyb2xsZXInO1xuaW1wb3J0IHsgQUZLQ29udHJvbGxlciB9IGZyb20gJy4uL0FGSy9BRktDb250cm9sbGVyJztcbmltcG9ydCB7IERhdGFDaGFubmVsQ29udHJvbGxlciB9IGZyb20gJy4uL0RhdGFDaGFubmVsL0RhdGFDaGFubmVsQ29udHJvbGxlcic7XG5pbXBvcnQgeyBQZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIgfSBmcm9tICcuLi9QZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIvUGVlckNvbm5lY3Rpb25Db250cm9sbGVyJztcbmltcG9ydCB7IEZsYWdzLCBDb250cm9sU2NoZW1lVHlwZSwgVGV4dFBhcmFtZXRlcnMsIE9wdGlvblBhcmFtZXRlcnMsIE51bWVyaWNQYXJhbWV0ZXJzIH0gZnJvbSAnLi4vQ29uZmlnL0NvbmZpZyc7XG5pbXBvcnQgeyBJbml0aWFsU2V0dGluZ3MgfSBmcm9tICcuLi9EYXRhQ2hhbm5lbC9Jbml0aWFsU2V0dGluZ3MnO1xuaW1wb3J0IHsgTGF0ZW5jeVRlc3RSZXN1bHRzIH0gZnJvbSAnLi4vRGF0YUNoYW5uZWwvTGF0ZW5jeVRlc3RSZXN1bHRzJztcbmltcG9ydCB7IEZpbGVUZW1wbGF0ZSwgRmlsZVV0aWwgfSBmcm9tICcuLi9VdGlsL0ZpbGVVdGlsJztcbmltcG9ydCB7IElucHV0Q2xhc3Nlc0ZhY3RvcnkgfSBmcm9tICcuLi9JbnB1dHMvSW5wdXRDbGFzc2VzRmFjdG9yeSc7XG5pbXBvcnQgeyBWaWRlb1BsYXllciB9IGZyb20gJy4uL1ZpZGVvUGxheWVyL1ZpZGVvUGxheWVyJztcbmltcG9ydCB7IFN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLCBNZXNzYWdlRGlyZWN0aW9uIH0gZnJvbSAnLi4vVWVJbnN0YW5jZU1lc3NhZ2UvU3RyZWFtTWVzc2FnZUNvbnRyb2xsZXInO1xuaW1wb3J0IHsgUmVzcG9uc2VDb250cm9sbGVyIH0gZnJvbSAnLi4vVWVJbnN0YW5jZU1lc3NhZ2UvUmVzcG9uc2VDb250cm9sbGVyJztcbmltcG9ydCB7IFNlbmRNZXNzYWdlQ29udHJvbGxlciB9IGZyb20gJy4uL1VlSW5zdGFuY2VNZXNzYWdlL1NlbmRNZXNzYWdlQ29udHJvbGxlcic7XG5pbXBvcnQgeyBUb1N0cmVhbWVyTWVzc2FnZXNDb250cm9sbGVyIH0gZnJvbSAnLi4vVWVJbnN0YW5jZU1lc3NhZ2UvVG9TdHJlYW1lck1lc3NhZ2VzQ29udHJvbGxlcic7XG5pbXBvcnQgeyBEYXRhQ2hhbm5lbFNlbmRlciB9IGZyb20gJy4uL0RhdGFDaGFubmVsL0RhdGFDaGFubmVsU2VuZGVyJztcbmltcG9ydCB7IElucHV0Q29vcmRUcmFuc2xhdG9yIH0gZnJvbSAnLi4vVXRpbC9JbnB1dENvb3JkVHJhbnNsYXRvcic7XG5pbXBvcnQgeyBEYXRhQ2hhbm5lbENsb3NlRXZlbnQsIERhdGFDaGFubmVsRXJyb3JFdmVudCwgRGF0YUNoYW5uZWxPcGVuRXZlbnQsIEhpZGVGcmVlemVGcmFtZUV2ZW50LCBMb2FkRnJlZXplRnJhbWVFdmVudCwgUGxheVN0cmVhbUVycm9yRXZlbnQsIFBsYXlTdHJlYW1FdmVudCwgUGxheVN0cmVhbVJlamVjdGVkRXZlbnQsIFNob3dPblNjcmVlbktleWJvYXJkRXZlbnQsIFN0cmVhbWVyTGlzdE1lc3NhZ2VFdmVudCwgU3RyZWFtZXJJRENoYW5nZWRNZXNzYWdlRXZlbnQgfSBmcm9tICcuLi9VdGlsL0V2ZW50RW1pdHRlcic7XG5pbXBvcnQgeyBJVVJMU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vVXRpbC9JVVJMU2VhcmNoUGFyYW1zJztcbmltcG9ydCB7IEJyb3dzZXJVdGlscyB9IGZyb20gJy4uL1V0aWwvQnJvd3NlclV0aWxzJztcbi8qKlxuICogRW50cnkgcG9pbnQgZm9yIHRoZSBXZWJSVEMgUGxheWVyXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJSdGNQbGF5ZXJDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSB0aGUgZnJvbnRlbmQgY29uZmlnIG9iamVjdFxuICAgICAqIEBwYXJhbSBwaXhlbFN0cmVhbWluZyAtIHRoZSBQaXhlbFN0cmVhbWluZyBvYmplY3RcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHBpeGVsU3RyZWFtaW5nKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkU2hvd1BsYXlPdmVybGF5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hdXRvSm9pblRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZyA9IHBpeGVsU3RyZWFtaW5nO1xuICAgICAgICB0aGlzLnJlc3BvbnNlQ29udHJvbGxlciA9IG5ldyBSZXNwb25zZUNvbnRyb2xsZXIoKTtcbiAgICAgICAgdGhpcy5maWxlID0gbmV3IEZpbGVUZW1wbGF0ZSgpO1xuICAgICAgICB0aGlzLnNkcENvbnN0cmFpbnRzID0ge1xuICAgICAgICAgICAgb2ZmZXJUb1JlY2VpdmVBdWRpbzogdHJ1ZSxcbiAgICAgICAgICAgIG9mZmVyVG9SZWNlaXZlVmlkZW86IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgLy8gc2V0IHVwIHRoZSBhZmsgbG9naWMgY2xhc3MgYW5kIGNvbm5lY3QgdXAgaXRzIG1ldGhvZCBmb3IgY2xvc2luZyB0aGUgc2lnbmFsaW5nIHNlcnZlclxuICAgICAgICB0aGlzLmFma0NvbnRyb2xsZXIgPSBuZXcgQUZLQ29udHJvbGxlcih0aGlzLmNvbmZpZywgdGhpcy5waXhlbFN0cmVhbWluZywgdGhpcy5vbkFma1RyaWdnZXJlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZmtDb250cm9sbGVyLm9uQUZLVGltZWRPdXRDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VTaWduYWxpbmdTZXJ2ZXIoJ1lvdSBoYXZlIGJlZW4gZGlzY29ubmVjdGVkIGR1ZSB0byBpbmFjdGl2aXR5LicsIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mcmVlemVGcmFtZUNvbnRyb2xsZXIgPSBuZXcgRnJlZXplRnJhbWVDb250cm9sbGVyKHRoaXMucGl4ZWxTdHJlYW1pbmcudmlkZW9FbGVtZW50UGFyZW50KTtcbiAgICAgICAgdGhpcy52aWRlb1BsYXllciA9IG5ldyBWaWRlb1BsYXllcih0aGlzLnBpeGVsU3RyZWFtaW5nLnZpZGVvRWxlbWVudFBhcmVudCwgdGhpcy5jb25maWcpO1xuICAgICAgICB0aGlzLnZpZGVvUGxheWVyLm9uVmlkZW9Jbml0aWFsaXplZCA9ICgpID0+IHRoaXMuaGFuZGxlVmlkZW9Jbml0aWFsaXplZCgpO1xuICAgICAgICAvLyBXaGVuIGluIG1hdGNoIHZpZXdwb3J0IHJlc29sdXRpb24gbW9kZSwgd2hlbiB0aGUgYnJvd3NlciB2aWV3cG9ydCBpcyByZXNpemVkIHdlIHNlbmQgYSByZXNpemUgY29tbWFuZCBiYWNrIHRvIFVFLlxuICAgICAgICB0aGlzLnZpZGVvUGxheWVyLm9uTWF0Y2hWaWV3cG9ydFJlc29sdXRpb25DYWxsYmFjayA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgICdSZXNvbHV0aW9uLldpZHRoJzogd2lkdGgsXG4gICAgICAgICAgICAgICAgJ1Jlc29sdXRpb24uSGVpZ2h0JzogaGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdDb21tYW5kJykoW0pTT04uc3RyaW5naWZ5KGRlc2NyaXB0b3IpXSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEV2ZXJ5IHRpbWUgdmlkZW8gcGxheWVyIGlzIHJlc2l6ZWQgaW4gYnJvd3NlciB3ZSBuZWVkIHRvIHJlaW5pdGlhbGl6ZSB0aGUgbW91c2UgY29vcmRpbmF0ZSBjb252ZXJzaW9uIGFuZCBmcmVlemUgZnJhbWUgc2l6aW5nIGxvZ2ljLlxuICAgICAgICB0aGlzLnZpZGVvUGxheWVyLm9uUmVzaXplUGxheWVyQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFVwTW91c2VBbmRGcmVlemVGcmFtZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBuZXcgU3RyZWFtQ29udHJvbGxlcih0aGlzLnZpZGVvUGxheWVyKTtcbiAgICAgICAgdGhpcy5jb29yZGluYXRlQ29udmVydGVyID0gbmV3IElucHV0Q29vcmRUcmFuc2xhdG9yKCk7XG4gICAgICAgIHRoaXMuc2VuZHJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIgPSBuZXcgRGF0YUNoYW5uZWxDb250cm9sbGVyKCk7XG4gICAgICAgIHRoaXMucmVjdkRhdGFDaGFubmVsQ29udHJvbGxlciA9IG5ldyBEYXRhQ2hhbm5lbENvbnRyb2xsZXIoKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckRhdGFDaGFubmVsRXZlbnRFbWl0dGVycyh0aGlzLnNlbmRyZWN2RGF0YUNoYW5uZWxDb250cm9sbGVyKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckRhdGFDaGFubmVsRXZlbnRFbWl0dGVycyh0aGlzLnJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsU2VuZGVyID0gbmV3IERhdGFDaGFubmVsU2VuZGVyKHRoaXMuc2VuZHJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsU2VuZGVyLnJlc2V0QWZrV2FybmluZ1RpbWVyT25EYXRhU2VuZCA9ICgpID0+IHRoaXMuYWZrQ29udHJvbGxlci5yZXNldEFma1dhcm5pbmdUaW1lcigpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyID0gbmV3IFN0cmVhbU1lc3NhZ2VDb250cm9sbGVyKCk7XG4gICAgICAgIC8vIHNldCB1cCB3ZWJzb2NrZXQgbWV0aG9kc1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG5ldyBXZWJTb2NrZXRUcmFuc3BvcnQoY29uZmlnLndlYlNvY2tldFByb3RvY29scyk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSBuZXcgU2lnbmFsbGluZ1Byb3RvY29sKHRoaXMudHJhbnNwb3J0KTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC5hZGRMaXN0ZW5lcihNZXNzYWdlcy5jb25maWcudHlwZU5hbWUsIChtc2cpID0+IHRoaXMuaGFuZGxlT25Db25maWdNZXNzYWdlKG1zZykpO1xuICAgICAgICB0aGlzLnByb3RvY29sLmFkZExpc3RlbmVyKE1lc3NhZ2VzLnBpbmcudHlwZU5hbWUsIChtc2cpID0+IHRoaXMuaGFuZGxlUGluZ01lc3NhZ2UobXNnKSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wuYWRkTGlzdGVuZXIoTWVzc2FnZXMuc3RyZWFtZXJMaXN0LnR5cGVOYW1lLCAobXNnKSA9PiB0aGlzLmhhbmRsZVN0cmVhbWVyTGlzdE1lc3NhZ2UobXNnKSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wuYWRkTGlzdGVuZXIoTWVzc2FnZXMuc3Vic2NyaWJlRmFpbGVkLnR5cGVOYW1lLCAobXNnKSA9PiB0aGlzLmhhbmRsZVN1YnNjcmliZUZhaWxlZE1lc3NhZ2UobXNnKSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wuYWRkTGlzdGVuZXIoTWVzc2FnZXMuc3RyZWFtZXJJZENoYW5nZWQudHlwZU5hbWUsIChtc2cpID0+IHRoaXMuaGFuZGxlU3RyZWFtZXJJRENoYW5nZWRNZXNzYWdlKG1zZykpO1xuICAgICAgICB0aGlzLnByb3RvY29sLmFkZExpc3RlbmVyKE1lc3NhZ2VzLnBsYXllckNvdW50LnR5cGVOYW1lLCAobXNnKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwbGF5ZXJDb3VudE1lc3NhZ2UgPSBtc2c7XG4gICAgICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vblBsYXllckNvdW50KHBsYXllckNvdW50TWVzc2FnZS5jb3VudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3RvY29sLmFkZExpc3RlbmVyKE1lc3NhZ2VzLmFuc3dlci50eXBlTmFtZSwgKG1zZykgPT4gdGhpcy5oYW5kbGVXZWJSdGNBbnN3ZXIobXNnKSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wuYWRkTGlzdGVuZXIoTWVzc2FnZXMub2ZmZXIudHlwZU5hbWUsIChtc2cpID0+IHRoaXMuaGFuZGxlV2ViUnRjT2ZmZXIobXNnKSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wuYWRkTGlzdGVuZXIoTWVzc2FnZXMucGVlckRhdGFDaGFubmVscy50eXBlTmFtZSwgKG1zZykgPT4gdGhpcy5oYW5kbGVXZWJSdGNTRlVQZWVyRGF0YWNoYW5uZWxzKG1zZykpO1xuICAgICAgICB0aGlzLnByb3RvY29sLmFkZExpc3RlbmVyKE1lc3NhZ2VzLmljZUNhbmRpZGF0ZS50eXBlTmFtZSwgKG1zZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgaWNlQ2FuZGlkYXRlTWVzc2FnZSA9IG1zZztcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSWNlQ2FuZGlkYXRlKGljZUNhbmRpZGF0ZU1lc3NhZ2UuY2FuZGlkYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wudHJhbnNwb3J0LmFkZExpc3RlbmVyKCdvcGVuJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgQnJvd3NlclNlbmRPZmZlciA9IHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuQnJvd3NlclNlbmRPZmZlcik7XG4gICAgICAgICAgICBpZiAoIUJyb3dzZXJTZW5kT2ZmZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gTWVzc2FnZUhlbHBlcnMuY3JlYXRlTWVzc2FnZShNZXNzYWdlcy5saXN0U3RyZWFtZXJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RvY29sLnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0ID0gMDtcbiAgICAgICAgICAgIHRoaXMuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wudHJhbnNwb3J0LmFkZExpc3RlbmVyKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbnQgcmVhbGx5IG5lZWQgdG8gZG8gYW55dGhpbmcgaGVyZSBzaW5jZSB0aGUgY2xvc2UgZXZlbnQgc2hvdWxkIGZvbGxvdy5cbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihgR290IGEgdHJhbnNwb3J0IGVycm9yLmApO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC50cmFuc3BvcnQuYWRkTGlzdGVuZXIoJ2Nsb3NlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvLyB3aGVuIHdlIHJlZnJlc2ggdGhlIHBhZ2UgZHVyaW5nIGEgc3RyZWFtIHdlIGdldCB0aGUgZ29pbmcgYXdheSBjb2RlLlxuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGRvbid0IHdhbnQgdG8gcmVjb25uZWN0IHNpbmNlIHdlJ3JlIG5hdmlnYXRpbmcgYXdheS5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50L2NvZGVcbiAgICAgICAgICAgIC8vIGxpc3RzIGFsbCB0aGUgY29kZXMuXG4gICAgICAgICAgICBjb25zdCBDT0RFX0dPSU5HX0FXQVkgPSAxMDAxO1xuICAgICAgICAgICAgY29uc3QgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSB0aGlzLmNvbmZpZy5nZXROdW1lcmljU2V0dGluZ1ZhbHVlKE51bWVyaWNQYXJhbWV0ZXJzLk1heFJlY29ubmVjdEF0dGVtcHRzKTtcbiAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRzTGVmdCA9IHRoaXMucmVjb25uZWN0QXR0ZW1wdCA8IG1heFJlY29ubmVjdEF0dGVtcHRzO1xuICAgICAgICAgICAgY29uc3QgcmVjb25uZWN0RW5hYmxlZCA9IHRoaXMuZm9yY2VSZWNvbm5lY3QgfHwgKHRoaXMuZW5hYmxlQXV0b1JlY29ubmVjdCAmJiBtYXhSZWNvbm5lY3RBdHRlbXB0cyA+IDAgJiYgYXR0ZW1wdHNMZWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IHdpbGxUcnlSZWNvbm5lY3QgPSByZWNvbm5lY3RFbmFibGVkICYmIGV2ZW50LmNvZGUgIT0gQ09ERV9HT0lOR19BV0FZO1xuICAgICAgICAgICAgY29uc3QgYWxsb3dDbGlja1RvUmVjb25uZWN0ID0gIXdpbGxUcnlSZWNvbm5lY3Q7XG4gICAgICAgICAgICBjb25zdCBkaXNjb25uZWN0TWVzc2FnZSA9IHRoaXMuZGlzY29ubmVjdE1lc3NhZ2UgPyB0aGlzLmRpc2Nvbm5lY3RNZXNzYWdlIDogZXZlbnQucmVhc29uO1xuICAgICAgICAgICAgdGhpcy5mb3JjZVJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGxpc3Qgb2YgYWxsIHBvc3NpYmxlIGNvZGVjcyBvbiBkaXNjb25uZWN0IHNvIHRoYXQgaWYgdGhlIG5leHQgY29ubmVjdGlvbiBoYXMgXCJOZWdvdGlhdGVDb2RlY3NcIiBvblxuICAgICAgICAgICAgLy8gdGhlbiBhbGwgY29kZWNzIGNhbiBiZSBuZWdvdGlhdGVkXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5nZXRTZXR0aW5nT3B0aW9uKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkQ29kZWMpLm9wdGlvbnMgPVxuICAgICAgICAgICAgICAgIEJyb3dzZXJVdGlscy5nZXRTdXBwb3J0ZWRWaWRlb0NvZGVjcygpO1xuICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25EaXNjb25uZWN0KGRpc2Nvbm5lY3RNZXNzYWdlLCBhbGxvd0NsaWNrVG9SZWNvbm5lY3QpO1xuICAgICAgICAgICAgdGhpcy5hZmtDb250cm9sbGVyLnN0b3BBZmtXYXJuaW5nVGltZXIoKTtcbiAgICAgICAgICAgIC8vIHN0b3Agc2VuZGluZyBzdGF0cyBvbiBpbnRlcnZhbCBpZiB3ZSBoYXZlIGNsb3NlZCBvdXIgY29ubmVjdGlvblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHNUaW1lckhhbmRsZSAmJiB0aGlzLnN0YXRzVGltZXJIYW5kbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuc3RhdHNUaW1lckhhbmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXNldCB0aGUgc3RyZWFtIHF1YWxpdHkgaWNvbi5cbiAgICAgICAgICAgIHRoaXMuc2V0VmlkZW9FbmNvZGVyQXZnUVAoMCk7XG4gICAgICAgICAgICAvLyB1bnJlZ2lzdGVyIGFsbCBpbnB1dCBkZXZpY2UgZXZlbnQgaGFuZGxlcnMgb24gZGlzY29ubmVjdFxuICAgICAgICAgICAgdGhpcy5zZXRUb3VjaElucHV0RW5hYmxlZChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnNldE1vdXNlSW5wdXRFbmFibGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuc2V0S2V5Ym9hcmRJbnB1dEVuYWJsZWQoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5zZXRHYW1lUGFkSW5wdXRFbmFibGVkKGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh3aWxsVHJ5UmVjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gbmVlZCBhIHNtYWxsIGRlbGF5IGhlcmUgdG8gcHJldmVudCByZWNvbm5lY3Qgc3BhbW1pbmdcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0Kys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9SZWNvbm5lY3QoZXZlbnQucmVhc29uKTtcbiAgICAgICAgICAgICAgICB9LCAyMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHNldCB1cCB0aGUgZmluYWwgd2ViUnRjIHBsYXllciBjb250cm9sbGVyIG1ldGhvZHMgZnJvbSB3aXRoaW4gb3VyIGFwcGxpY2F0aW9uIHNvIGEgY29ubmVjdGlvbiBjYW4gYmUgYWN0aXZhdGVkXG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyID0gbmV3IFNlbmRNZXNzYWdlQ29udHJvbGxlcih0aGlzLmRhdGFDaGFubmVsU2VuZGVyLCB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyKTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNDb250cm9sbGVyID0gbmV3IFRvU3RyZWFtZXJNZXNzYWdlc0NvbnRyb2xsZXIodGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucG9wdWxhdGVEZWZhdWx0UHJvdG9jb2woKTtcbiAgICAgICAgdGhpcy5pbnB1dENsYXNzZXNGYWN0b3J5ID0gbmV3IElucHV0Q2xhc3Nlc0ZhY3RvcnkodGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlciwgdGhpcy52aWRlb1BsYXllciwgdGhpcy5jb29yZGluYXRlQ29udmVydGVyKTtcbiAgICAgICAgdGhpcy5pc1VzaW5nU0ZVID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNVc2luZ1NWQyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUXVhbGl0eUNvbnRyb2xsZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmVmZXJyZWRDb2RlYyA9ICcnO1xuICAgICAgICB0aGlzLmVuYWJsZUF1dG9SZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICB0aGlzLmZvcmNlUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdCA9IDA7XG4gICAgICAgIHRoaXMuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uT3B0aW9uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihPcHRpb25QYXJhbWV0ZXJzLlN0cmVhbWVySWQsIChzdHJlYW1lcmlkKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtZXJpZCA9PT0gdW5kZWZpbmVkIHx8IHN0cmVhbWVyaWQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xvc2UgdGhlIGN1cnJlbnQgcGVlciBjb25uZWN0aW9uIGFuZCBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5wZWVyQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIuY3JlYXRlUGVlckNvbm5lY3Rpb24odGhpcy5wZWVyQ29uZmlnLCB0aGlzLnByZWZlcnJlZENvZGVjKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlZFN0cmVhbSA9IHN0cmVhbWVyaWQ7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gTWVzc2FnZUhlbHBlcnMuY3JlYXRlTWVzc2FnZShNZXNzYWdlcy5zdWJzY3JpYmUsIHsgc3RyZWFtZXJJZDogc3RyZWFtZXJpZCB9KTtcbiAgICAgICAgICAgIHRoaXMucHJvdG9jb2wuc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25PcHRpb25TZXR0aW5nQ2hhbmdlZExpc3RlbmVyKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkUXVhbGl0eSwgKHByZWZlcnJlZFF1YWxpdHkpID0+IHtcbiAgICAgICAgICAgIGlmIChwcmVmZXJyZWRRdWFsaXR5ID09PSB1bmRlZmluZWQgfHwgcHJlZmVycmVkUXVhbGl0eSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVXNpbmdTVkMpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2VyIGlzIHVzaW5nIFNWQyBzbyBzZWxlY3RlZCBxdWFsaXR5IHdpbGwgYmUgb2YgdGhlIGZvcm0gU3hUeShoKS4gSnVzdCBleHRyYWN0IHRoZSB4IGFuZCB5IG51bWJlcnNcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZUhlbHBlcnMuY3JlYXRlTWVzc2FnZShNZXNzYWdlcy5sYXllclByZWZlcmVuY2UsIHtcbiAgICAgICAgICAgICAgICAgICAgc3BhdGlhbExheWVyOiArcHJlZmVycmVkUXVhbGl0eVsxXSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBvcmFsTGF5ZXI6ICtwcmVmZXJyZWRRdWFsaXR5WzNdIC0gMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlciBpcyBub3QgdXNpbmcgU1ZDIHNvIHRoZSBzZWxlY3RlZCBxdWFsaXR5IHdpbGwgYmUgZWl0aGVyIExvdywgTWVkaXVtIG9yIEhpZ2ggc28gd2UgZXh0cmFjdCB0aGUgYXBwcm9wcmlhdGUgc3BhdGlhbCBsYXllciBpbmRleFxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbFF1YWxpdGllcyA9IHRoaXMuY29uZmlnLmdldFNldHRpbmdPcHRpb24oT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRRdWFsaXR5KS5vcHRpb25zO1xuICAgICAgICAgICAgICAgIGNvbnN0IHF1YWxpdHlJbmRleCA9IGFsbFF1YWxpdGllcy5pbmRleE9mKHByZWZlcnJlZFF1YWxpdHkpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlSGVscGVycy5jcmVhdGVNZXNzYWdlKE1lc3NhZ2VzLmxheWVyUHJlZmVyZW5jZSwge1xuICAgICAgICAgICAgICAgICAgICBzcGF0aWFsTGF5ZXI6IHF1YWxpdHlJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdGVtcG9yYWxMYXllcjogMFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcm90b2NvbC5zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0VmlkZW9FbmNvZGVyQXZnUVAoLTEpO1xuICAgICAgICB0aGlzLnNpZ25hbGxpbmdVcmxCdWlsZGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsbGluZ1NlcnZlclVybCA9IHRoaXMuY29uZmlnLmdldFRleHRTZXR0aW5nVmFsdWUoVGV4dFBhcmFtZXRlcnMuU2lnbmFsbGluZ1NlcnZlclVybCk7XG4gICAgICAgICAgICByZXR1cm4gc2lnbmFsbGluZ1NlcnZlclVybDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIHZpZGVvIHBsYXllciBhbmQgbWFrZXMgc3VyZSByZXNvdXJjZXMgYXJlIGZyZWVkLiBUaGlzIGhlbHBzIHRvIHByZXZlbnQgdGhlIGlzc3VlIGluIGNocm9tZVxuICAgICAqIHdoZXJlIGl0IHJlZnVzZXMgdG8gbWFrZSBuZXcgdmlkZW8gcGxheWVycy5cbiAgICAgKi9cbiAgICBkZXN0cm95VmlkZW9QbGF5ZXIoKSB7XG4gICAgICAgIHRoaXMudmlkZW9QbGF5ZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkXG4gICAgICogQHBhcmFtIGV2ZW50IC0gTWVzc2FnZSBFdmVudFxuICAgICAqL1xuICAgIGhhbmRsZU9uTWVzc2FnZShldmVudCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkoZXZlbnQuZGF0YSk7XG4gICAgICAgIExvZ2dlci5JbmZvKCdNZXNzYWdlIGluY29taW5nOicgKyBtZXNzYWdlKTtcbiAgICAgICAgLy90cnkge1xuICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIuZnJvbVN0cmVhbWVyTWVzc2FnZXMuZ2V0KG1lc3NhZ2VbMF0pO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLmZyb21TdHJlYW1lckhhbmRsZXJzLmdldChtZXNzYWdlVHlwZSkoZXZlbnQuZGF0YSk7XG4gICAgICAgIC8vfSBjYXRjaCAoZSkge1xuICAgICAgICAvL0xvZ2dlci5FcnJvcihMb2dnZXIuR2V0U3RhY2tUcmFjZSgpLCBgQ3VzdG9tIGRhdGEgY2hhbm5lbCBtZXNzYWdlIHdpdGggbWVzc2FnZSB0eXBlIHRoYXQgaXMgdW5rbm93biB0byB0aGUgUGl4ZWwgU3RyZWFtaW5nIHByb3RvY29sLiBEb2VzIHlvdXIgUGl4ZWxTdHJlYW1pbmdQcm90b2NvbCBuZWVkIHVwZGF0aW5nPyBUaGUgbWVzc2FnZSB0eXBlIHdhczogJHttZXNzYWdlWzBdfWApO1xuICAgICAgICAvL31cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgbWVzc2FnZSBhbGwgaGFuZGxlcnNcbiAgICAgKi9cbiAgICByZWdpc3Rlck1lc3NhZ2VIYW5kbGVycygpIHtcbiAgICAgICAgLy8gRnJvbSBTdHJlYW1lclxuICAgICAgICAvLyBNZXNzYWdlIGV2ZW50cyBmcm9tIHRoZSBzdHJlYW1lciBoYXZlIGEgZGF0YSB0eXBlIG9mIEFycmF5QnVmZmVyIGFzIHdlIGZvcmNlIHRoaXMgdHlwZSBpbiB0aGUgRGF0YWNoYW5uZWxDb250cm9sbGVyXG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ1F1YWxpdHlDb250cm9sT3duZXJzaGlwJywgKGRhdGEpID0+IHRoaXMub25RdWFsaXR5Q29udHJvbE93bmVyc2hpcChkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ1Jlc3BvbnNlJywgKGRhdGEpID0+IHRoaXMucmVzcG9uc2VDb250cm9sbGVyLm9uUmVzcG9uc2UoZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsICdDb21tYW5kJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25Db21tYW5kKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCAnRnJlZXplRnJhbWUnLCAoZGF0YSkgPT4gdGhpcy5vbkZyZWV6ZUZyYW1lTWVzc2FnZShkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ1VuZnJlZXplRnJhbWUnLCAoKSA9PiB0aGlzLmludmFsaWRhdGVGcmVlemVGcmFtZUFuZEVuYWJsZVZpZGVvKCkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsICdWaWRlb0VuY29kZXJBdmdRUCcsIChkYXRhKSA9PiB0aGlzLmhhbmRsZVZpZGVvRW5jb2RlckF2Z1FQKGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCAnTGF0ZW5jeVRlc3QnLCAoZGF0YSkgPT4gdGhpcy5oYW5kbGVMYXRlbmN5VGVzdFJlc3VsdChkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ0RhdGFDaGFubmVsTGF0ZW5jeVRlc3QnLCAoZGF0YSkgPT4gdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbExhdGVuY3lUZXN0UmVzcG9uc2UoZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsICdJbml0aWFsU2V0dGluZ3MnLCAoZGF0YSkgPT4gdGhpcy5oYW5kbGVJbml0aWFsU2V0dGluZ3MoZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsICdGaWxlRXh0ZW5zaW9uJywgKGRhdGEpID0+IHRoaXMub25GaWxlRXh0ZW5zaW9uKGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCAnRmlsZU1pbWVUeXBlJywgKGRhdGEpID0+IHRoaXMub25GaWxlTWltZVR5cGUoZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsICdGaWxlQ29udGVudHMnLCAoZGF0YSkgPT4gdGhpcy5vbkZpbGVDb250ZW50cyhkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ1Rlc3RFY2hvJywgKCkgPT4ge1xuICAgICAgICAgICAgLyogRG8gbm90aGluZyAqL1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCAnSW5wdXRDb250cm9sT3duZXJzaGlwJywgKGRhdGEpID0+IHRoaXMub25JbnB1dENvbnRyb2xPd25lcnNoaXAoZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsICdHYW1lcGFkUmVzcG9uc2UnLCAoZGF0YSkgPT4gdGhpcy5vbkdhbWVwYWRSZXNwb25zZShkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ011bHRpcGxleGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgLyogRG8gbm90aGluZyBhcyB0aGlzIG1lc3NhZ2UgdHlwZSBpcyB1c2VkIG9ubHkgYnkgdGhlIFNGVSAqL1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCAnUHJvdG9jb2wnLCAoZGF0YSkgPT4gdGhpcy5vblByb3RvY29sTWVzc2FnZShkYXRhKSk7XG4gICAgICAgIC8vIFRvIFN0cmVhbWVyXG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdJRnJhbWVSZXF1ZXN0JywgKCkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdJRnJhbWVSZXF1ZXN0JykpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnUmVxdWVzdFF1YWxpdHlDb250cm9sJywgKCkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdSZXF1ZXN0UXVhbGl0eUNvbnRyb2wnKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdGcHNSZXF1ZXN0JywgKCkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdGcHNSZXF1ZXN0JykpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnQXZlcmFnZUJpdHJhdGVSZXF1ZXN0JywgKCkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdBdmVyYWdlQml0cmF0ZVJlcXVlc3QnKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdTdGFydFN0cmVhbWluZycsICgpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignU3RhcnRTdHJlYW1pbmcnKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdTdG9wU3RyZWFtaW5nJywgKCkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdTdG9wU3RyZWFtaW5nJykpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnTGF0ZW5jeVRlc3QnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdMYXRlbmN5VGVzdCcsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1JlcXVlc3RJbml0aWFsU2V0dGluZ3MnLCAoKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1JlcXVlc3RJbml0aWFsU2V0dGluZ3MnKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdUZXN0RWNobycsICgpID0+IHtcbiAgICAgICAgICAgIC8qIERvIG5vdGhpbmcgKi9cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdVSUludGVyYWN0aW9uJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignVUlJbnRlcmFjdGlvbicsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ0NvbW1hbmQnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdDb21tYW5kJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnVGV4dGJveEVudHJ5JywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignVGV4dGJveEVudHJ5JywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnS2V5RG93bicsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0tleURvd24nLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdLZXlVcCcsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0tleVVwJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnS2V5UHJlc3MnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdLZXlQcmVzcycsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ01vdXNlRW50ZXInLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdNb3VzZUVudGVyJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnTW91c2VMZWF2ZScsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ01vdXNlTGVhdmUnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdNb3VzZURvd24nLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdNb3VzZURvd24nLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdNb3VzZVVwJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignTW91c2VVcCcsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ01vdXNlTW92ZScsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ01vdXNlTW92ZScsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ01vdXNlV2hlZWwnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdNb3VzZVdoZWVsJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnTW91c2VEb3VibGUnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdNb3VzZURvdWJsZScsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1RvdWNoU3RhcnQnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdUb3VjaFN0YXJ0JywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnVG91Y2hFbmQnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdUb3VjaEVuZCcsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1RvdWNoTW92ZScsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1RvdWNoTW92ZScsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ0dhbWVwYWRDb25uZWN0ZWQnLCAoKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0dhbWVwYWRDb25uZWN0ZWQnKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdHYW1lcGFkQnV0dG9uUHJlc3NlZCcsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0dhbWVwYWRCdXR0b25QcmVzc2VkJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnR2FtZXBhZEJ1dHRvblJlbGVhc2VkJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignR2FtZXBhZEJ1dHRvblJlbGVhc2VkJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnR2FtZXBhZEFuYWxvZycsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0dhbWVwYWRBbmFsb2cnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdHYW1lcGFkRGlzY29ubmVjdGVkJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignR2FtZXBhZERpc2Nvbm5lY3RlZCcsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1hSRXllVmlld3MnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdYUkV5ZVZpZXdzJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnWFJITURUcmFuc2Zvcm0nLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdYUkhNRFRyYW5zZm9ybScsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1hSQ29udHJvbGxlclRyYW5zZm9ybScsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1hSQ29udHJvbGxlclRyYW5zZm9ybScsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1hSU3lzdGVtJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignWFJTeXN0ZW0nLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdYUkJ1dHRvblRvdWNoZWQnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdYUkJ1dHRvblRvdWNoZWQnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdYUkJ1dHRvblRvdWNoUmVsZWFzZWQnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdYUkJ1dHRvblRvdWNoUmVsZWFzZWQnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdYUkJ1dHRvblByZXNzZWQnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdYUkJ1dHRvblByZXNzZWQnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdYUkJ1dHRvblJlbGVhc2VkJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignWFJCdXR0b25SZWxlYXNlZCcsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1hSQW5hbG9nJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignWFJBbmFsb2cnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdDaGFubmVsUmVsYXlTdGF0dXMnLCAoKSA9PiB7XG4gICAgICAgICAgICAvKiBEbyBub3RoaW5nIGFzIHRoaXMgbWVzc2FnZSB0eXBlIGlzIHVzZWQgb25seSBieSB0aGUgU0ZVICovXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnTXVsdGlwbGV4ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAvKiBEbyBub3RoaW5nIGFzIHRoaXMgbWVzc2FnZSB0eXBlIGlzIHVzZWQgb25seSBieSB0aGUgU0ZVICovXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZSB0aGUgbG9naWMgYXNzb2NpYXRlZCB3aXRoIGEgY29tbWFuZCBmcm9tIFVFXG4gICAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBvbkNvbW1hbmQobWVzc2FnZSkge1xuICAgICAgICBMb2dnZXIuSW5mbygnRGF0YUNoYW5uZWxSZWNlaXZlTWVzc2FnZVR5cGUuQ29tbWFuZCcpO1xuICAgICAgICBjb25zdCBjb21tYW5kQXNTdHJpbmcgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi0xNicpLmRlY29kZShtZXNzYWdlLnNsaWNlKDEpKTtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ0RhdGEgQ2hhbm5lbCBDb21tYW5kOiAnICsgY29tbWFuZEFzU3RyaW5nKTtcbiAgICAgICAgY29uc3QgY29tbWFuZCA9IEpTT04ucGFyc2UoY29tbWFuZEFzU3RyaW5nKTtcbiAgICAgICAgLy8gSGFuZGxlIFwib25TY3JlZW5LZXlib2FyZFwiIGV2ZW50XG4gICAgICAgIGlmIChjb21tYW5kLmNvbW1hbmQgPT09ICdvblNjcmVlbktleWJvYXJkJykge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVPblNjcmVlbktleWJvYXJkQ29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVPblNjcmVlbktleWJvYXJkQ29tbWFuZChjb21tYW5kKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHNob3dPblNjcmVlbktleWJvYXJkOiAoX2EgPSBjb21tYW5kLnNob3dPblNjcmVlbktleWJvYXJkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlLFxuICAgICAgICAgICAgeDogKF9iID0gY29tbWFuZC54KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwLFxuICAgICAgICAgICAgeTogKF9jID0gY29tbWFuZC55KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwLFxuICAgICAgICAgICAgY29udGVudHM6IChfZCA9IGNvbW1hbmQuY29udGVudHMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICcnXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuZGlzcGF0Y2hFdmVudChuZXcgU2hvd09uU2NyZWVuS2V5Ym9hcmRFdmVudChkYXRhKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSBwcm90b2NvbCBtZXNzYWdlIHJlY2VpdmVkIGZyb20gdGhlIHN0cmVhbWVyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgdGhlIG1lc3NhZ2UgZGF0YSBmcm9tIHRoZSBzdHJlYW1lclxuICAgICAqL1xuICAgIG9uUHJvdG9jb2xNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sU3RyaW5nID0gbmV3IFRleHREZWNvZGVyKCd1dGYtMTYnKS5kZWNvZGUobWVzc2FnZS5zbGljZSgxKSk7XG4gICAgICAgICAgICBjb25zdCBwcm90b2NvbEpTT04gPSBKU09OLnBhcnNlKHByb3RvY29sU3RyaW5nKTtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvY29sSlNPTiwgJ0RpcmVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKCdNYWxmb3JtZWQgcHJvdG9jb2wgcmVjZWl2ZWQuIEVuc3VyZSB0aGUgcHJvdG9jb2wgbWVzc2FnZSBjb250YWlucyBhIGRpcmVjdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gcHJvdG9jb2xKU09OLkRpcmVjdGlvbjtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm90b2NvbEpTT04uRGlyZWN0aW9uO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oYFJlY2VpdmVkIG5ldyAke2RpcmVjdGlvbiA9PSBNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciA/ICdGcm9tU3RyZWFtZXInIDogJ1RvU3RyZWFtZXInfSBwcm90b2NvbC4gVXBkYXRpbmcgZXhpc3RpbmcgcHJvdG9jb2wuLi5gKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb3RvY29sSlNPTikuZm9yRWFjaCgobWVzc2FnZVR5cGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gcHJvdG9jb2xKU09OW21lc3NhZ2VUeXBlXTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIG1lc3NhZ2UgY29udGFpbnMgYWxsIHRoZSByZWxldmFudCBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdpZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBUb1N0cmVhbWVyLT4ke21lc3NhZ2VUeXBlfSBwcm90b2NvbCBkZWZpbml0aW9uIHdhcyBtYWxmb3JtZWQgYXMgaXQgZGlkbid0IGNvbnRhaW4gYXQgbGVhc3QgYW4gaWRcXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZpbml0aW9uIHdhczogJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlLCBudWxsLCAyKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gaW4gYSBmb3JFYWNoIGlzIGVxdWl2YWxlbnQgdG8gYSBjb250aW51ZSBpbiBhIG5vcm1hbCBmb3IgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVFNS4xIGFuZCBVRTUuMiBkb24ndCBzZW5kIGEgc3RydWN0dXJlIGZvciB0aGVzZSBtZXNzYWdlIHR5cGVzLCBidXQgdGhleSBhY3R1YWxseSBkbyBoYXZlIGEgc3RydWN0dXJlIHNvIGlnbm9yZSB1cGRhdGluZyB0aGVtXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVR5cGUgPT09ICdVSUludGVyYWN0aW9uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VUeXBlID09PSAnQ29tbWFuZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlVHlwZSA9PT0gJ0xhdGVuY3lUZXN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQobWVzc2FnZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgcmVnaXN0ZXJlZCBhIGhhbmRsZXIgZm9yIHRoaXMgbWVzc2FnZSB0eXBlIHdlIGNhbiBhZGQgaXQgdG8gb3VyIHN1cHBvcnRlZCBtZXNzYWdlcy4gaWUgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlciguLi4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KG1lc3NhZ2VUeXBlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihgVGhlcmUgd2FzIG5vIHJlZ2lzdGVyZWQgaGFuZGxlciBmb3IgXCIke21lc3NhZ2VUeXBlfVwiIC0gdHJ5IGFkZGluZyBvbmUgdXNpbmcgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsIFwiJHttZXNzYWdlVHlwZX1cIiwgbXlIYW5kbGVyKWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXI6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBtZXNzYWdlIGNvbnRhaW5zIGFsbCB0aGUgcmVsZXZhbnQgcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnaWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihgRnJvbVN0cmVhbWVyLT4ke21lc3NhZ2VUeXBlfSBwcm90b2NvbCBkZWZpbml0aW9uIHdhcyBtYWxmb3JtZWQgYXMgaXQgZGlkbid0IGNvbnRhaW4gYXQgbGVhc3QgYW4gaWRcXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZpbml0aW9uIHdhczogJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlLCBudWxsLCAyKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gaW4gYSBmb3JFYWNoIGlzIGVxdWl2YWxlbnQgdG8gYSBjb250aW51ZSBpbiBhIG5vcm1hbCBmb3IgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLmZyb21TdHJlYW1lckhhbmRsZXJzLmdldChtZXNzYWdlVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSByZWdpc3RlcmVkIGEgaGFuZGxlciBmb3IgdGhpcyBtZXNzYWdlIHR5cGUuIGllIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoLi4uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIuZnJvbVN0cmVhbWVyTWVzc2FnZXMuc2V0KG1lc3NhZ2UuaWQsIG1lc3NhZ2VUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihgVGhlcmUgd2FzIG5vIHJlZ2lzdGVyZWQgaGFuZGxlciBmb3IgXCIke21lc3NhZ2V9XCIgLSB0cnkgYWRkaW5nIG9uZSB1c2luZyByZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCBcIiR7bWVzc2FnZVR5cGV9XCIsIG15SGFuZGxlcilgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBVbmtub3duIGRpcmVjdGlvbjogJHtkaXJlY3Rpb259YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBPbmNlIHRoZSBwcm90b2NvbCBoYXMgYmVlbiByZWNlaXZlZCwgd2UgY2FuIHNlbmQgb3VyIGNvbnRyb2wgbWVzc2FnZXNcbiAgICAgICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzQ29udHJvbGxlci5TZW5kUmVxdWVzdEluaXRpYWxTZXR0aW5ncygpO1xuICAgICAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNDb250cm9sbGVyLlNlbmRSZXF1ZXN0UXVhbGl0eUNvbnRyb2woKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhbiBpbnB1dCBjb250cm9sIG1lc3NhZ2Ugd2hlbiBpdCBpcyByZWNlaXZlZCBmcm9tIHRoZSBzdHJlYW1lclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBpbnB1dCBjb250cm9sIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBvbklucHV0Q29udHJvbE93bmVyc2hpcChtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ0RhdGFDaGFubmVsUmVjZWl2ZU1lc3NhZ2VUeXBlLklucHV0Q29udHJvbE93bmVyc2hpcCcpO1xuICAgICAgICBjb25zdCBpbnB1dENvbnRyb2xPd25lcnNoaXAgPSBuZXcgQm9vbGVhbih2aWV3WzFdKS52YWx1ZU9mKCk7XG4gICAgICAgIExvZ2dlci5JbmZvKGBSZWNlaXZlZCBpbnB1dCBjb250cm9sbGVyIG1lc3NhZ2UgLSB3aWxsIHlvdXIgaW5wdXQgY29udHJvbCB0aGUgc3RyZWFtOiAke2lucHV0Q29udHJvbE93bmVyc2hpcH1gKTtcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25JbnB1dENvbnRyb2xPd25lcnNoaXAoaW5wdXRDb250cm9sT3duZXJzaGlwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgICAqL1xuICAgIG9uR2FtZXBhZFJlc3BvbnNlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VTdHJpbmcgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi0xNicpLmRlY29kZShtZXNzYWdlLnNsaWNlKDEpKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VKU09OID0gSlNPTi5wYXJzZShyZXNwb25zZVN0cmluZyk7XG4gICAgICAgIHRoaXMuZ2FtZVBhZENvbnRyb2xsZXIub25HYW1lcGFkUmVzcG9uc2VSZWNlaXZlZChyZXNwb25zZUpTT04uY29udHJvbGxlcklkKTtcbiAgICB9XG4gICAgb25BZmtUcmlnZ2VyZWQoKSB7XG4gICAgICAgIHRoaXMuYWZrQ29udHJvbGxlci5vbkFma0NsaWNrKCk7XG4gICAgICAgIC8vIGlmIHRoZSBzdHJlYW0gaXMgcGF1c2VkIHBsYXkgaXQsIGlmIHdlIGNhblxuICAgICAgICBpZiAodGhpcy52aWRlb1BsYXllci5pc1BhdXNlZCgpICYmIHRoaXMudmlkZW9QbGF5ZXIuaGFzVmlkZW9Tb3VyY2UoKSkge1xuICAgICAgICAgICAgdGhpcy5wbGF5U3RyZWFtKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgd2Ugc2hvdWxkIHRpbWVvdXQgd2hlbiBhZmsuXG4gICAgICogQHBhcmFtIGFma0VuYWJsZWQgSWYgdHJ1ZSB3ZSB0aW1lb3V0IHdoZW4gaWRsZSBmb3Igc29tZSBnaXZlbiBhbW91bnQgb2YgdGltZS5cbiAgICAgKi9cbiAgICBzZXRBZmtFbmFibGVkKGFma0VuYWJsZWQpIHtcbiAgICAgICAgaWYgKGFma0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25BZmtUcmlnZ2VyZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWZrQ29udHJvbGxlci5zdG9wQWZrV2FybmluZ1RpbWVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbiB0byB0aGUgc2lnbmFsbGluZyBzZXJ2ZXIuIE1hbnVhbCB0cmlnZ2VyXG4gICAgICovXG4gICAgdHJ5UmVjb25uZWN0KG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5mb3JjZVJlY29ubmVjdCA9IHRydWU7XG4gICAgICAgIHRoaXMuZG9SZWNvbm5lY3QobWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIGFjdHVhbCByZWNvbm5lY3Qgd29yay4gVXNlZCBieSB0aGUgYXV0byByZWNvbm5lY3QgZmVhdHVyZSB0byBza2lwIHRoZSBtYW51YWwgZmxhZy5cbiAgICAgKi9cbiAgICBkb1JlY29ubmVjdChtZXNzYWdlKSB7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIHdlYlNvY2tldENvbnRyb2xsZXIgcmV0dXJuIGltbWVkaWF0ZWx5IG9yIHRoaXMgd2lsbCBub3Qgd29ya1xuICAgICAgICBpZiAoIXRoaXMucHJvdG9jb2wpIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdUaGlzIHBsYXllciBoYXMgbm8gcHJvdG9jb2wgY29ubmVjdGlvbi4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUmVjb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgdGhlIGNvbm5lY3Rpb24gaXMgb3BlbiwgZmlyc3QgY2xvc2UgaXQgYW5kIGZvcmNlIGEgcmVjb25uZWN0LlxuICAgICAgICBpZiAodGhpcy5wcm90b2NvbC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9yY2VSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RNZXNzYWdlID0gYCR7bWVzc2FnZX0gUmVjb25uZWN0aW5nLmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsb3NlU2lnbmFsaW5nU2VydmVyKG1lc3NhZ2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25XZWJSdGNBdXRvQ29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VG9TaWduYWxsaW5nU2VydmVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBmcmVlemUgZnJhbWUgaWYgaXQgaXMgcmVxdWlyZWQgb3RoZXJ3aXNlIHNob3dzIHRoZSBwbGF5IG92ZXJsYXlcbiAgICAgKi9cbiAgICBsb2FkRnJlZXplRnJhbWVPclNob3dQbGF5T3ZlcmxheSgpIHtcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBMb2FkRnJlZXplRnJhbWVFdmVudCh7XG4gICAgICAgICAgICBzaG91bGRTaG93UGxheU92ZXJsYXk6IHRoaXMuc2hvdWxkU2hvd1BsYXlPdmVybGF5LFxuICAgICAgICAgICAgaXNWYWxpZDogdGhpcy5mcmVlemVGcmFtZUNvbnRyb2xsZXIudmFsaWQsXG4gICAgICAgICAgICBqcGVnRGF0YTogdGhpcy5mcmVlemVGcmFtZUNvbnRyb2xsZXIuanBlZ1xuICAgICAgICB9KSk7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFNob3dQbGF5T3ZlcmxheSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ3Nob3dpbmcgcGxheSBvdmVybGF5Jyk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVBsYXllclN0eWxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnc2hvd2luZyBmcmVlemUgZnJhbWUnKTtcbiAgICAgICAgICAgIHRoaXMuZnJlZXplRnJhbWVDb250cm9sbGVyLnNob3dGcmVlemVGcmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWRlb1BsYXllci5zZXRWaWRlb0VuYWJsZWQoZmFsc2UpO1xuICAgICAgICB9LCB0aGlzLmZyZWV6ZUZyYW1lQ29udHJvbGxlci5mcmVlemVGcmFtZURlbGF5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgZnJlZXplIGZyYW1lIGFuZCBsb2FkIGl0XG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIGZyZWV6ZSBmcmFtZSBkYXRhIGluIGJ5dGVzXG4gICAgICovXG4gICAgb25GcmVlemVGcmFtZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBMb2dnZXIuSW5mbygnRGF0YUNoYW5uZWxSZWNlaXZlTWVzc2FnZVR5cGUuRnJlZXplRnJhbWUnKTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lQ29udHJvbGxlci5wcm9jZXNzRnJlZXplRnJhbWVNZXNzYWdlKHZpZXcsICgpID0+IHRoaXMubG9hZEZyZWV6ZUZyYW1lT3JTaG93UGxheU92ZXJsYXkoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0aGUgdmlkZW8gYWZ0ZXIgaGlkaW5nIGEgZnJlZXplIGZyYW1lXG4gICAgICovXG4gICAgaW52YWxpZGF0ZUZyZWV6ZUZyYW1lQW5kRW5hYmxlVmlkZW8oKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCdEYXRhQ2hhbm5lbFJlY2VpdmVNZXNzYWdlVHlwZS5GcmVlemVGcmFtZScpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuZGlzcGF0Y2hFdmVudChuZXcgSGlkZUZyZWV6ZUZyYW1lRXZlbnQoKSk7XG4gICAgICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lQ29udHJvbGxlci5oaWRlRnJlZXplRnJhbWUoKTtcbiAgICAgICAgfSwgdGhpcy5mcmVlemVGcmFtZUNvbnRyb2xsZXIuZnJlZXplRnJhbWVEZWxheSk7XG4gICAgICAgIGlmICh0aGlzLnZpZGVvUGxheWVyLmdldFZpZGVvRWxlbWVudCgpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvUGxheWVyLnNldFZpZGVvRW5hYmxlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwIGRhdGFjaGFubmVsIGRhdGEgZm9yIHByb2Nlc3NpbmcgZmlsZSBleHRlbnNpb25cbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgZmlsZSBleHRlbnNpb24gZGF0YVxuICAgICAqL1xuICAgIG9uRmlsZUV4dGVuc2lvbihkYXRhKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgRmlsZVV0aWwuc2V0RXh0ZW5zaW9uRnJvbUJ5dGVzKHZpZXcsIHRoaXMuZmlsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXAgZGF0YWNoYW5uZWwgZGF0YSBmb3IgcHJvY2Vzc2luZyB0aGUgZmlsZSBtaW1lIHR5cGVcbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgZmlsZSBtaW1lIHR5cGUgZGF0YVxuICAgICAqL1xuICAgIG9uRmlsZU1pbWVUeXBlKGRhdGEpIHtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICBGaWxlVXRpbC5zZXRNaW1lVHlwZUZyb21CeXRlcyh2aWV3LCB0aGlzLmZpbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwIGRhdGFjaGFubmVsIGRhdGEgZm9yIHByb2Nlc3NpbmcgdGhlIGZpbGUgY29udGVudHNcbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgZmlsZSBjb250ZW50cyBkYXRhXG4gICAgICovXG4gICAgb25GaWxlQ29udGVudHMoZGF0YSkge1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgIEZpbGVVdGlsLnNldENvbnRlbnRzRnJvbUJ5dGVzKHZpZXcsIHRoaXMuZmlsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBsYXlzIHRoZSBzdHJlYW0gYXVkaW8gYW5kIHZpZGVvIHNvdXJjZSBhbmQgc2V0cyB1cCBvdGhlciBwaWVjZXMgd2hpbGUgdGhlIHN0cmVhbSBzdGFydHNcbiAgICAgKi9cbiAgICBwbGF5U3RyZWFtKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuZ2V0VmlkZW9FbGVtZW50KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQ291bGQgbm90IHBsYXkgdmlkZW8gc3RyZWFtIGJlY2F1c2UgdGhlIHZpZGVvIHBsYXllciB3YXMgbm90IGluaXRpYWxpemVkIGNvcnJlY3RseS4nO1xuICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBQbGF5U3RyZWFtRXJyb3JFdmVudCh7IG1lc3NhZ2UgfSkpO1xuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gY2xvc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgIHRoaXMuY2xvc2VTaWduYWxpbmdTZXJ2ZXIoJ1N0cmVhbSBub3QgaW5pdGlhbGl6ZWQgY29ycmVjdGx5JywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5oYXNWaWRlb1NvdXJjZSgpKSB7XG4gICAgICAgICAgICBMb2dnZXIuV2FybmluZygnQ2Fubm90IHBsYXkgc3RyZWFtLCB0aGUgdmlkZW8gZWxlbWVudCBoYXMgbm8gc3JjT2JqZWN0IHRvIHBsYXkuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRUb3VjaElucHV0RW5hYmxlZCh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLlRvdWNoSW5wdXQpKTtcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBQbGF5U3RyZWFtRXZlbnQoKSk7XG4gICAgICAgIGlmICh0aGlzLnN0cmVhbUNvbnRyb2xsZXIuYXVkaW9FbGVtZW50LnNyY09iamVjdCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRNdXRlZCA9IHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuU3RhcnRWaWRlb011dGVkKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5hdWRpb0VsZW1lbnQubXV0ZWQgPSBzdGFydE11dGVkO1xuICAgICAgICAgICAgaWYgKHN0YXJ0TXV0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlWaWRlbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLmF1ZGlvRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAucGxheSgpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5VmlkZW8oKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKG9uUmVqZWN0ZWRSZWFzb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkluZm8ob25SZWplY3RlZFJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5JbmZvKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYXV0b3BsYXlpbmcgdmlkZW8gd2l0aG91dCBpbnRlcmFjdGlvbiAtIHRvIHJlc29sdmUgdGhpcyB3ZSBhcmUgZ29pbmcgdG8gc2hvdyB0aGUgcGxheSBidXR0b24gb3ZlcmxheS4nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBQbGF5U3RyZWFtUmVqZWN0ZWRFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IG9uUmVqZWN0ZWRSZWFzb25cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wbGF5VmlkZW8oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNob3VsZFNob3dQbGF5T3ZlcmxheSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lQ29udHJvbGxlci5zaG93RnJlZXplRnJhbWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGxheXMgdGhlIHZpZGVvIHN0cmVhbVxuICAgICAqL1xuICAgIHBsYXlWaWRlbygpIHtcbiAgICAgICAgLy8gaGFuZGxlIHBsYXkoKSB3aXRoIHByb21pc2UgYXMgaXQgaXMgYW4gYXN5bmNocm9ub3VzIGNhbGxcbiAgICAgICAgdGhpcy52aWRlb1BsYXllci5wbGF5KCkuY2F0Y2goKG9uUmVqZWN0ZWRSZWFzb24pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbUNvbnRyb2xsZXIuYXVkaW9FbGVtZW50LnNyY09iamVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5hdWRpb0VsZW1lbnQucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIExvZ2dlci5JbmZvKG9uUmVqZWN0ZWRSZWFzb24pO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ0Jyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhdXRvcGxheWluZyB2aWRlbyB3aXRob3V0IGludGVyYWN0aW9uIC0gdG8gcmVzb2x2ZSB0aGlzIHdlIGFyZSBnb2luZyB0byBzaG93IHRoZSBwbGF5IGJ1dHRvbiBvdmVybGF5LicpO1xuICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBQbGF5U3RyZWFtUmVqZWN0ZWRFdmVudCh7IHJlYXNvbjogb25SZWplY3RlZFJlYXNvbiB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdGhlIHZpZGVvIHRvIHBsYXkgYXV0b21hdGljYWxseSBpZiBlbmFibGVBdXRvcGxheSBpcyB0cnVlXG4gICAgICovXG4gICAgYXV0b1BsYXlWaWRlb09yU2V0VXBQbGF5T3ZlcmxheSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuQXV0b1BsYXlWaWRlbykpIHtcbiAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gcGxheSB0aGUgdmlkZW9cbiAgICAgICAgICAgIHRoaXMucGxheVN0cmVhbSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzaXplUGxheWVyU3R5bGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byB0aGUgU2lnbmFsaW5nIHNlcnZlclxuICAgICAqL1xuICAgIGNvbm5lY3RUb1NpZ25hbGxpbmdTZXJ2ZXIoKSB7XG4gICAgICAgIHRoaXMubG9jYWxseUNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuYWJsZUF1dG9SZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc2lnbmFsbGluZ1VybCA9IHRoaXMuc2lnbmFsbGluZ1VybEJ1aWxkZXIoKTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC5jb25uZWN0KHNpZ25hbGxpbmdVcmwpO1xuICAgICAgICBjb25zdCBrZWVwYWxpdmVEZWxheSA9IHRoaXMuY29uZmlnLmdldE51bWVyaWNTZXR0aW5nVmFsdWUoTnVtZXJpY1BhcmFtZXRlcnMuS2VlcGFsaXZlRGVsYXkpO1xuICAgICAgICBpZiAoa2VlcGFsaXZlRGVsYXkgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZSA9IG5ldyBLZWVwYWxpdmVNb25pdG9yKHRoaXMucHJvdG9jb2wsIGtlZXBhbGl2ZURlbGF5KTtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlLm9uVGltZW91dCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcGluZyBmYWlscyBqdXN0IGRpc2Nvbm5lY3RcbiAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoYFByb3RvY29sIHRpbWVvdXRgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RvY29sLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyB3aWxsIHN0YXJ0IHRoZSBoYW5kc2hha2UgdG8gdGhlIHNpZ25hbGxpbmcgc2VydmVyXG4gICAgICogQHBhcmFtIHBlZXJDb25maWcgIC0gUlRDIENvbmZpZ3VyYXRpb24gT3B0aW9ucyBmcm9tIHRoZSBTaWduYWxpbmcgc2VydmVyXG4gICAgICogQHJlbWFyayBSVEMgUGVlciBDb25uZWN0aW9uIG9uIEljZSBDYW5kaWRhdGUgZXZlbnQgaGF2ZSBpdCBoYW5kbGVkIGJ5IGhhbmRsZSBTZW5kIEljZSBDYW5kaWRhdGVcbiAgICAgKi9cbiAgICBzdGFydFNlc3Npb24ocGVlckNvbmZpZykge1xuICAgICAgICB0aGlzLnBlZXJDb25maWcgPSBwZWVyQ29uZmlnO1xuICAgICAgICAvLyBjaGVjayBmb3IgZm9yY2luZyB0dXJuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkZvcmNlVFVSTikpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBhIHR1cm4gc2VydmVyXG4gICAgICAgICAgICBjb25zdCBoYXNUdXJuU2VydmVyID0gdGhpcy5jaGVja1R1cm5TZXJ2ZXJBdmFpbGFiaWxpdHkocGVlckNvbmZpZyk7XG4gICAgICAgICAgICAvLyBjbG9zZSBhbmQgZXJyb3IgaWYgdHVybiBpcyBmb3JjZWQgYW5kIHRoZXJlIGlzIG5vIHR1cm4gc2VydmVyXG4gICAgICAgICAgICBpZiAoIWhhc1R1cm5TZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuSW5mbygnTm8gdHVybiBzZXJ2ZXIgd2FzIGZvdW5kIGluIHRoZSBQZWVyIENvbm5lY3Rpb24gT3B0aW9ucy4gVFVSTiBjYW5ub3QgYmUgZm9yY2VkLCBjbG9zaW5nIGNvbm5lY3Rpb24uIFBsZWFzZSB1c2UgU1RVTiBpbnN0ZWFkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVNpZ25hbGluZ1NlcnZlcignVFVSTiBjYW5ub3QgYmUgZm9yY2VkLCBjbG9zaW5nIGNvbm5lY3Rpb24uIFBsZWFzZSB1c2UgU1RVTiBpbnN0ZWFkLicsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHVwIHRoZSBwZWVyIGNvbm5lY3Rpb24gY29udHJvbGxlclxuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlciA9IG5ldyBQZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIodGhpcy5wZWVyQ29uZmlnLCB0aGlzLmNvbmZpZywgdGhpcy5wcmVmZXJyZWRDb2RlYyk7XG4gICAgICAgIC8vIHNldCB1cCBwZWVyIGNvbm5lY3Rpb24gY29udHJvbGxlciB2aWRlbyBzdGF0c1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5vblZpZGVvU3RhdHMgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVmlkZW9TdGF0cyhldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qIFNldCBldmVudCBoYW5kbGVyIGZvciBsYXRlbmN5IGluZm9ybWF0aW9uIGlzIGNhbGN1bGF0ZWQsIGhhbmRsZSB0aGUgZXZlbnQgYnkgcHJvcG9nYXRpbmcgdG8gdGhlIFBpeGVsU3RyZWFtaW5nIEFQSSAqL1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5vbkxhdGVuY3lDYWxjdWxhdGVkID0gKGxhdGVuY3lJbmZvKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbkxhdGVuY3lDYWxjdWxhdGVkKGxhdGVuY3lJbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyogV2hlbiBvdXIgUGVlckNvbm5lY3Rpb24gd2FudHMgdG8gc2VuZCBhbiBvZmZlciBjYWxsIG91ciBoYW5kbGVyICovXG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLm9uU2VuZFdlYlJUQ09mZmVyID0gKG9mZmVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNlbmRXZWJSVENPZmZlcihvZmZlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qIFNldCBldmVudCBoYW5kbGVyIGZvciB3aGVuIGxvY2FsIGRlc2NyaXB0aW9uIGlzIHNldCAqL1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5vblNldExvY2FsRGVzY3JpcHRpb24gPSAoc2RwKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2RwLnR5cGUgPT09ICdvZmZlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNlbmRXZWJSVENPZmZlcihzZHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2RwLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTZW5kV2ViUlRDQW5zd2VyKHNkcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoYFBlZXJDb25uZWN0aW9uQ29udHJvbGxlciBvblNldExvY2FsRGVzY3JpcHRpb24gd2FzIGNhbGxlZCB3aXRoIHVuZXhwZWN0ZWQgdHlwZSAke3NkcC50eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBFdmVudCBoYW5kbGVyIGZvciB3aGVuIFBlZXJDb25uZWN0aW9uJ3MgcmVtb3RlIGRlc2NyaXB0aW9uIGlzIHNldCAqL1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5vblNldFJlbW90ZURlc2NyaXB0aW9uID0gKHNkcCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNkcC50eXBlID09PSAnb2ZmZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25XZWJSdGNTZHBPZmZlcihzZHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2RwLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25XZWJSdGNTZHBBbnN3ZXIoc2RwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihgUGVlckNvbm5lY3Rpb25Db250cm9sbGVyIG9uU2V0UmVtb3RlRGVzY3JpcHRpb24gd2FzIGNhbGxlZCB3aXRoIHVuZXhwZWN0ZWQgdHlwZSAke3NkcC50eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBXaGVuIHRoZSBQZWVyIENvbm5lY3Rpb24gaWNlIGNhbmRpZGF0ZSBpcyBhZGRlZCBoYXZlIGl0IGhhbmRsZWQgKi9cbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIub25QZWVySWNlQ2FuZGlkYXRlID0gKHBlZXJDb25uZWN0aW9uSWNlRXZlbnQpID0+IHRoaXMuaGFuZGxlU2VuZEljZUNhbmRpZGF0ZShwZWVyQ29ubmVjdGlvbkljZUV2ZW50KTtcbiAgICAgICAgLyogV2hlbiB0aGUgUGVlciBDb25uZWN0aW9uIGhhcyBhIGRhdGEgY2hhbm5lbCBjcmVhdGVkIGZvciBpdCBieSB0aGUgYnJvd3NlciwgaGFuZGxlIGl0ICovXG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLm9uRGF0YUNoYW5uZWwgPSAoZGF0YWNoYW5uZWxFdmVudCkgPT4gdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbChkYXRhY2hhbm5lbEV2ZW50KTtcbiAgICAgICAgLy8gc2V0IHVwIHdlYlJ0YyB0ZXh0IG92ZXJsYXlzXG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLnNob3dUZXh0T3ZlcmxheUNvbm5lY3RpbmcgPSAoKSA9PiB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbldlYlJ0Y0Nvbm5lY3RpbmcoKTtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIuc2hvd1RleHRPdmVybGF5U2V0dXBGYWlsdXJlID0gKCkgPT4gdGhpcy5waXhlbFN0cmVhbWluZy5fb25XZWJSdGNGYWlsZWQoKTtcbiAgICAgICAgbGV0IHdlYlJ0Y0Nvbm5lY3RlZFNlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIub25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBCcm93c2VycyBlbWl0IFwiY29ubmVjdGVkXCIgd2hlbiBnZXR0aW5nIGZpcnN0IGNvbm5lY3Rpb24gYW5kIFwiY29tcGxldGVkXCIgd2hlbiBmaW5pc2hpbmdcbiAgICAgICAgICAgIC8vIGNhbmRpZGF0ZSBjaGVja2luZy4gSG93ZXZlciwgc29tZXRpbWVzIGJyb3dzZXJzIGNhbiBza2lwIFwiY29ubmVjdGVkXCIgYW5kIG9ubHkgZW1pdCBcImNvbXBsZXRlZFwiLlxuICAgICAgICAgICAgLy8gVGhlcmVmb3JlIG5lZWQgdG8gY2hlY2sgYm90aCBjYXNlcyBhbmQgZW1pdCBvbldlYlJ0Y0Nvbm5lY3RlZCBvbmx5IG9uY2Ugb24gdGhlIGZpcnN0IGhpdC5cbiAgICAgICAgICAgIGlmICghd2ViUnRjQ29ubmVjdGVkU2VudCAmJlxuICAgICAgICAgICAgICAgIFsnY29ubmVjdGVkJywgJ2NvbXBsZXRlZCddLmluY2x1ZGVzKHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLnBlZXJDb25uZWN0aW9uLmljZUNvbm5lY3Rpb25TdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbldlYlJ0Y0Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgICAgIHdlYlJ0Y0Nvbm5lY3RlZFNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBSVEMgUGVlciBDb25uZWN0aW9uIG9uIFRyYWNrIGV2ZW50IC0+IGhhbmRsZSBvbiB0cmFjayAqL1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5vblRyYWNrID0gKHRyYWNrRXZlbnQpID0+IHRoaXMuc3RyZWFtQ29udHJvbGxlci5oYW5kbGVPblRyYWNrKHRyYWNrRXZlbnQpO1xuICAgICAgICBjb25zdCBCcm93c2VyU2VuZE9mZmVyID0gdGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5Ccm93c2VyU2VuZE9mZmVyKTtcbiAgICAgICAgaWYgKEJyb3dzZXJTZW5kT2ZmZXIpIHtcbiAgICAgICAgICAgIC8vIElmIGJyb3dzZXIgaXMgc2VuZGluZyB0aGUgb2ZmZXIsIGNyZWF0ZSBhbiBvZmZlciBhbmQgc2VuZCBpdCB0byB0aGUgc3RyZWFtZXJcbiAgICAgICAgICAgIHRoaXMuc2VuZHJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIuY3JlYXRlRGF0YUNoYW5uZWwodGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIucGVlckNvbm5lY3Rpb24sICdjaXJydXMnLCB0aGlzLmRhdGFjaGFubmVsT3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNlbmRyZWN2RGF0YUNoYW5uZWxDb250cm9sbGVyLmhhbmRsZU9uTWVzc2FnZSA9IChldikgPT4gdGhpcy5oYW5kbGVPbk1lc3NhZ2UoZXYpO1xuICAgICAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIuY3JlYXRlT2ZmZXIodGhpcy5zZHBDb25zdHJhaW50cywgdGhpcy5jb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgcGVlciBjb25uZWN0aW9uIG9wdGlvbnMgZm9yIGEgdHVybiBzZXJ2ZXIgYW5kIHJldHVybnMgdHJ1ZSBvciBmYWxzZVxuICAgICAqL1xuICAgIGNoZWNrVHVyblNlcnZlckF2YWlsYWJpbGl0eShvcHRpb25zKSB7XG4gICAgICAgIC8vIGlmIGljZVNlcnZlcnMgaXMgZW1wdHkgcmV0dXJuIGZhbHNlIHRoaXMgc2hvdWxkIG5vdCBiZSB0aGUgZ2VuZXJhbCB1c2UgY2FzZSBidXQgaXMgaGVyZSBpbmNhc2VcbiAgICAgICAgaWYgKCFvcHRpb25zLmljZVNlcnZlcnMpIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdBIHR1cm4gc2V2ZXIgd2FzIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgaWNlIHNlcnZlcnMgdG8gY2hlY2sgZm9yIGEgdHVybiB1cmxcbiAgICAgICAgZm9yIChjb25zdCBpY2VTZXJ2ZXIgb2Ygb3B0aW9ucy5pY2VTZXJ2ZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVybCBvZiBpY2VTZXJ2ZXIudXJscykge1xuICAgICAgICAgICAgICAgIGlmICh1cmwuaW5jbHVkZXMoJ3R1cm4nKSkge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuSW5mbyhgQSB0dXJuIHNldmVyIHdhcyBmb3VuZCBhdCAke3VybH1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIExvZ2dlci5JbmZvKCdBIHR1cm4gc2V2ZXIgd2FzIG5vdCBmb3VuZCcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hlbiBhIENvbmZpZyBNZXNzYWdlIGlzIHJlY2VpdmVkIGNvbnRhaW5zIHRoZSBQZWVyIENvbm5lY3Rpb24gT3B0aW9ucyByZXF1aXJlZCAoU1RVTiBhbmQgVFVSTiBTZXJ2ZXIgSW5mbylcbiAgICAgKiBAcGFyYW0gbWVzc2FnZUNvbmZpZyAtIENvbmZpZyBNZXNzYWdlIHJlY2VpdmVkIGZyb20gdGhlIHNpZ25hbGluZyBzZXJ2ZXJcbiAgICAgKi9cbiAgICBoYW5kbGVPbkNvbmZpZ01lc3NhZ2UobWVzc2FnZUNvbmZpZykge1xuICAgICAgICB0aGlzLnJlc2l6ZVBsYXllclN0eWxlKCk7XG4gICAgICAgIC8vIFRlbGwgdGhlIFdlYlJ0Y0NvbnRyb2xsZXIgdG8gc3RhcnQgYSBzZXNzaW9uIHdpdGggdGhlIHBlZXIgb3B0aW9ucyBzZW50IGZyb20gdGhlIHNpZ25hbGluZyBzZXJ2ZXJcbiAgICAgICAgdGhpcy5zdGFydFNlc3Npb24obWVzc2FnZUNvbmZpZy5wZWVyQ29ubmVjdGlvbk9wdGlvbnMpO1xuICAgIH1cbiAgICBoYW5kbGVQaW5nTWVzc2FnZShwaW5nTWVzc2FnZSkge1xuICAgICAgICB0aGlzLnByb3RvY29sLnNlbmRNZXNzYWdlKE1lc3NhZ2VIZWxwZXJzLmNyZWF0ZU1lc3NhZ2UoTWVzc2FnZXMucG9uZywgeyB0aW1lOiBwaW5nTWVzc2FnZS50aW1lIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIHRoZSBzaWduYWxsaW5nIHNlcnZlciBnaXZlcyB1cyB0aGUgbGlzdCBvZiBzdHJlYW1lciBpZHMuXG4gICAgICovXG4gICAgaGFuZGxlU3RyZWFtZXJMaXN0TWVzc2FnZShtZXNzYWdlU3RyZWFtZXJMaXN0KSB7XG4gICAgICAgIExvZ2dlci5JbmZvKGBHb3Qgc3RyZWFtZXIgbGlzdCAke21lc3NhZ2VTdHJlYW1lckxpc3QuaWRzfWApO1xuICAgICAgICBsZXQgd2FudGVkU3RyZWFtZXJJZCA9ICcnO1xuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgc3RyZWFtZXIgaWQgb3B0aW9uXG4gICAgICAgIGNvbnN0IHN0cmVhbWVySURPcHRpb24gPSB0aGlzLmNvbmZpZy5nZXRTZXR0aW5nT3B0aW9uKE9wdGlvblBhcmFtZXRlcnMuU3RyZWFtZXJJZCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nU2VsZWN0aW9uID0gc3RyZWFtZXJJRE9wdGlvbi5zZWxlY3RlZC50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0IHRvIHNlbGVjdGVkIG9wdGlvbiBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgIHdhbnRlZFN0cmVhbWVySWQgPSBzdHJlYW1lcklET3B0aW9uLnNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgc3RyZWFtZXJzIHRvIHRoZSBVSVxuICAgICAgICBjb25zdCBzZXR0aW5nT3B0aW9ucyA9IFsuLi5tZXNzYWdlU3RyZWFtZXJMaXN0Lmlkc107IC8vIGNvcHkgdGhlIG9yaWdpbmFsIG1lc3NhZ2VTdHJlYW1lckxpc3QuaWRzXG4gICAgICAgIHNldHRpbmdPcHRpb25zLnVuc2hpZnQoJycpOyAvLyBhZGQgYW4gZW1wdHkgb3B0aW9uIGF0IHRoZSB0b3BcbiAgICAgICAgdGhpcy5jb25maWcuc2V0T3B0aW9uU2V0dGluZ09wdGlvbnMoT3B0aW9uUGFyYW1ldGVycy5TdHJlYW1lcklkLCBzZXR0aW5nT3B0aW9ucyk7XG4gICAgICAgIGxldCBhdXRvU2VsZWN0ZWRTdHJlYW1lcklkID0gJyc7XG4gICAgICAgIGNvbnN0IHdhaXRGb3JTdHJlYW1lciA9IHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuV2FpdEZvclN0cmVhbWVyKTtcbiAgICAgICAgY29uc3QgcmVjb25uZWN0TGltaXQgPSB0aGlzLmNvbmZpZy5nZXROdW1lcmljU2V0dGluZ1ZhbHVlKE51bWVyaWNQYXJhbWV0ZXJzLk1heFJlY29ubmVjdEF0dGVtcHRzKTtcbiAgICAgICAgY29uc3QgcmVjb25uZWN0RGVsYXkgPSB0aGlzLmNvbmZpZy5nZXROdW1lcmljU2V0dGluZ1ZhbHVlKE51bWVyaWNQYXJhbWV0ZXJzLlN0cmVhbWVyQXV0b0pvaW5JbnRlcnZhbCk7XG4gICAgICAgIC8vIGZpcnN0IHdlIGZpZ3VyZSBvdXQgYSB3YW50ZWQgc3RyZWFtZXIgaWQgdGhyb3VnaCB2YXJpb3VzIG1lYW5zXG4gICAgICAgIGNvbnN0IHVzZVVybFBhcmFtcyA9IHRoaXMuY29uZmlnLnVzZVVybFBhcmFtcztcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IElVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgICAgIGlmICh1c2VVcmxQYXJhbXMgJiYgdXJsUGFyYW1zLmhhcyhPcHRpb25QYXJhbWV0ZXJzLlN0cmVhbWVySWQpKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSd2ZSBzZXQgdGhlIHN0cmVhbWVyIGlkIG9uIHRoZSB1cmwgd2Ugb25seSB3YW50IHRoYXQgc3RyZWFtZXIgaWRcbiAgICAgICAgICAgIHdhbnRlZFN0cmVhbWVySWQgPSB1cmxQYXJhbXMuZ2V0KE9wdGlvblBhcmFtZXRlcnMuU3RyZWFtZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdWJzY3JpYmVkU3RyZWFtKSB7XG4gICAgICAgICAgICAvLyB3ZSB3ZXJlIHByZXZpb3VzbHkgc3Vic2NyaWJlZCB0byBhIHN0cmVhbWVyLCB3ZSB3YW50IHRoYXRcbiAgICAgICAgICAgIHdhbnRlZFN0cmVhbWVySWQgPSB0aGlzLnN1YnNjcmliZWRTdHJlYW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IGxldHMgc2VlIGlmIHdlIGNhbiBwaWNrIGl0LlxuICAgICAgICBpZiAod2FudGVkU3RyZWFtZXJJZCAmJiBtZXNzYWdlU3RyZWFtZXJMaXN0Lmlkcy5pbmNsdWRlcyh3YW50ZWRTdHJlYW1lcklkKSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHdhbnRlZCBzdHJlYW0gaXMgaW4gdGhlIGxpc3QuIHdlIHBpY2sgdGhhdFxuICAgICAgICAgICAgYXV0b1NlbGVjdGVkU3RyZWFtZXJJZCA9IHdhbnRlZFN0cmVhbWVySWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKCF3YW50ZWRTdHJlYW1lcklkIHx8ICF3YWl0Rm9yU3RyZWFtZXIpICYmIG1lc3NhZ2VTdHJlYW1lckxpc3QuaWRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIGlmIHdlJ3JlIG5vdCB3YWl0aW5nIGZvciB0aGUgd2FudGVkIHN0cmVhbWVyIGFuZCB0aGVyZSdzIG9ubHkgb25lIHN0cmVhbWVyLCBjb25uZWN0IHRvIGl0XG4gICAgICAgICAgICBhdXRvU2VsZWN0ZWRTdHJlYW1lcklkID0gbWVzc2FnZVN0cmVhbWVyTGlzdC5pZHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgZm91bmQgYSBzdHJlYW1lciBpZCB0byBhdXRvIHNlbGVjdCwgc2VsZWN0IGl0XG4gICAgICAgIGlmIChhdXRvU2VsZWN0ZWRTdHJlYW1lcklkKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHQgPSAwO1xuICAgICAgICAgICAgdGhpcy5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0T3B0aW9uU2V0dGluZ1ZhbHVlKE9wdGlvblBhcmFtZXRlcnMuU3RyZWFtZXJJZCwgYXV0b1NlbGVjdGVkU3RyZWFtZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBhdXRvIHNlbGVjdGVkIHN0cmVhbWVyLlxuICAgICAgICAgICAgLy8gaWYgd2UncmUgd2FpdGluZyBmb3IgYSBzdHJlYW1lciB0aGVuIHRyeSByZWNvbm5lY3RpbmdcbiAgICAgICAgICAgIGlmICh3YWl0Rm9yU3RyZWFtZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3RBdHRlbXB0IDwgcmVjb25uZWN0TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RpbGwgcmVjb25uZWN0cyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0Kys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNSZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdG9jb2wuc2VuZE1lc3NhZ2UoTWVzc2FnZUhlbHBlcnMuY3JlYXRlTWVzc2FnZShNZXNzYWdlcy5saXN0U3RyZWFtZXJzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHJlY29ubmVjdERlbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGV4aGF1c3RlZCBvdXIgcmVjb25uZWN0IGF0dGVtcHRzLCByZXR1cm4gdG8gbWFpbiBzY3JlZW5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZUF1dG9SZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlzcGF0Y2ggdGhpcyBldmVudCBmaW5hbGx5XG4gICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuZGlzcGF0Y2hFdmVudChuZXcgU3RyZWFtZXJMaXN0TWVzc2FnZUV2ZW50KHtcbiAgICAgICAgICAgIG1lc3NhZ2VTdHJlYW1lckxpc3QsXG4gICAgICAgICAgICBhdXRvU2VsZWN0ZWRTdHJlYW1lcklkLFxuICAgICAgICAgICAgd2FudGVkU3RyZWFtZXJJZFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGhhbmRsZVN1YnNjcmliZUZhaWxlZE1lc3NhZ2Uoc3Vic2NyaWJlRmFpbGVkTWVzc2FnZSkge1xuICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHQgPSAwO1xuICAgICAgICB0aGlzLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5hYmxlQXV0b1JlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vblN1YnNjcmliZUZhaWxlZChzdWJzY3JpYmVGYWlsZWRNZXNzYWdlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBoYW5kbGVTdHJlYW1lcklEQ2hhbmdlZE1lc3NhZ2Uoc3RyZWFtZXJJRENoYW5nZWRNZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG5ld0lEID0gc3RyZWFtZXJJRENoYW5nZWRNZXNzYWdlLm5ld0lEO1xuICAgICAgICAvLyBuZWVkIHRvIGVkaXQgdGhlIHNlbGVjdGVkIHN0cmVhbWVyIGluIHRoZSBzZXR0aW5ncyBsaXN0XG4gICAgICAgIGNvbnN0IHN0cmVhbWVyTGlzdE9wdGlvbnMgPSB0aGlzLmNvbmZpZy5nZXRTZXR0aW5nT3B0aW9uKE9wdGlvblBhcmFtZXRlcnMuU3RyZWFtZXJJZCk7XG4gICAgICAgIC8vIHRlbXBvcmFyaWx5IHByZXZlbnQgb25DaGFuZ2UgZnJvbSBmaXJpbmcgKGl0IHdvdWxkIHRyeSB0byBzdWJzY3JpYmUgdG8gdGhlIHN0cmVhbWVyIGFnYWluKVxuICAgICAgICBjb25zdCBvbGRPbkNoYW5nZSA9IHN0cmVhbWVyTGlzdE9wdGlvbnMub25DaGFuZ2U7XG4gICAgICAgIHN0cmVhbWVyTGlzdE9wdGlvbnMub25DaGFuZ2UgPSAoKSA9PiB7IH07XG4gICAgICAgIC8vIGNoYW5nZSB0aGUgc2VsZWN0ZWQgZW50cnkuXG4gICAgICAgIGNvbnN0IHN0cmVhbWVyTGlzdCA9IHN0cmVhbWVyTGlzdE9wdGlvbnMub3B0aW9ucztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJlYW1lckxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChzdHJlYW1lckxpc3RbaV0gPT0gdGhpcy5zdWJzY3JpYmVkU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtZXJMaXN0W2ldID0gbmV3SUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBsaXN0XG4gICAgICAgIHN0cmVhbWVyTGlzdE9wdGlvbnMub3B0aW9ucyA9IHN0cmVhbWVyTGlzdDtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzZWxlY3RlZCBlbnRyeVxuICAgICAgICBzdHJlYW1lckxpc3RPcHRpb25zLnNlbGVjdGVkID0gbmV3SUQ7XG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIG9sZCBjaGFuZ2Ugbm90aWZpZXIuXG4gICAgICAgIHN0cmVhbWVyTGlzdE9wdGlvbnMub25DaGFuZ2UgPSBvbGRPbkNoYW5nZTtcbiAgICAgICAgLy8gcmVtZW1iZXIgd2hpY2ggc3RyZWFtIHdlJ3JlIHN1YnNjcmliZSB0b1xuICAgICAgICB0aGlzLnN1YnNjcmliZWRTdHJlYW0gPSBzdHJlYW1lcklEQ2hhbmdlZE1lc3NhZ2UubmV3SUQ7XG4gICAgICAgIC8vIG5vdGlmeSBhbnkgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuZGlzcGF0Y2hFdmVudChuZXcgU3RyZWFtZXJJRENoYW5nZWRNZXNzYWdlRXZlbnQoe1xuICAgICAgICAgICAgbmV3SURcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIFJUQyBBbnN3ZXIgZnJvbSB0aGUgc2lnbmFsaW5nIHNlcnZlclxuICAgICAqIEBwYXJhbSBBbnN3ZXIgLSBBbnN3ZXIgU0RQIGZyb20gdGhlIHBlZXIuXG4gICAgICovXG4gICAgaGFuZGxlV2ViUnRjQW5zd2VyKEFuc3dlcikge1xuICAgICAgICBMb2dnZXIuSW5mbyhgR290IGFuc3dlciBzZHAgJHtBbnN3ZXIuc2RwfWApO1xuICAgICAgICBjb25zdCBzZHBBbnN3ZXIgPSB7XG4gICAgICAgICAgICBzZHA6IEFuc3dlci5zZHAsXG4gICAgICAgICAgICB0eXBlOiAnYW5zd2VyJ1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5yZWNlaXZlQW5zd2VyKHNkcEFuc3dlcik7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9zdFdlYnJ0Y05lZ290aWF0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgUlRDIG9mZmVyIGZyb20gYSBXZWJSVEMgcGVlciAocmVjZWl2ZWQgdGhyb3VnaCB0aGUgc2lnbmFsbGluZyBzZXJ2ZXIpLlxuICAgICAqIEBwYXJhbSBPZmZlciAtIE9mZmVyIFNEUCBmcm9tIHRoZSBwZWVyLlxuICAgICAqL1xuICAgIGhhbmRsZVdlYlJ0Y09mZmVyKE9mZmVyKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKGBHb3Qgb2ZmZXIgc2RwICR7T2ZmZXIuc2RwfWApO1xuICAgICAgICB0aGlzLmlzVXNpbmdTRlUgPSBPZmZlci5zZnUgPyBPZmZlci5zZnUgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1VzaW5nU1ZDID0gT2ZmZXIuc2NhbGFiaWxpdHlNb2RlID8gT2ZmZXIuc2NhbGFiaWxpdHlNb2RlICE9ICdMMVQxJyA6IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pc1VzaW5nU0ZVIHx8IHRoaXMuaXNVc2luZ1NWQykge1xuICAgICAgICAgICAgLy8gRGlzYWJsZSBuZWdvdGlhdGluZyB3aXRoIHRoZSBzZnUgYXMgdGhlIHNmdSBvbmx5IHN1cHBvcnRzIG9uZSBjb2RlYyBhdCBhIHRpbWVcbiAgICAgICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLnByZWZlcnJlZENvZGVjID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URTogVGhlc2UgdHdvIHNldHRpbmdzIGNvbmZpZ3VyYXRpb25zIGFyZSBkb25lIG91dHNpZGUgb2YgYW4gaWYodGhpcy5pc1VzaW5nU0ZVKSBzbyB0aGF0IHVzZXJzXG4gICAgICAgIC8vIGNhbiBzd2l0Y2ggYmV0d2VlbiBhIGRlZmF1bHQgYW5kIFNGVSBzdHJlYW0gYW5kIGhhdmUgdGhlIHNldHRpbmdzIHJlY29uZmlndXJlIGFwcHJvcHJpYXRlbHlcbiAgICAgICAgY29uc3Qgc2NhbGFiaWxpdHlNb2RlID0gT2ZmZXIuc2NhbGFiaWxpdHlNb2RlID8gT2ZmZXIuc2NhbGFiaWxpdHlNb2RlIDogJ0wxVDEnO1xuICAgICAgICBsZXQgYXZhaWxhYmxlUXVhbGl0aWVzID0gWydEZWZhdWx0J107XG4gICAgICAgIGlmICh0aGlzLmlzVXNpbmdTRlUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1VzaW5nU1ZDKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlciBpcyB1c2luZyBhbiBTRlUgd2l0aG91dCBhbnkgdGVtcG9yYWwgc2NhbGFiaWxpdHkuIEp1c3Qgb2ZmZXIgZWFzaWx5IHJlYWRhYmxlIG5hbWVzXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlUXVhbGl0aWVzID0gWydMb3cnLCAnTWVkaXVtJywgJ0hpZ2gnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFVzZXIgaXMgdXNpbmcgU1ZDLiBHZW5lcmF0ZSBhbGwgYXZhaWxhYmxlIG9wdGlvbnMuXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlUXVhbGl0aWVzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4U3BhdGlhbExheWVycyA9ICtzY2FsYWJpbGl0eU1vZGVbMV07XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4VGVtcG9yYWxMYXllcnMgPSArc2NhbGFiaWxpdHlNb2RlWzNdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHMgPSAxOyBzIDw9IG1heFNwYXRpYWxMYXllcnM7IHMrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0ID0gMTsgdCA8PSBtYXhUZW1wb3JhbExheWVyczsgdCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVRdWFsaXRpZXMucHVzaChgUyR7c31UJHt0fWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcG9zc2libGUgdmlkZW8gcXVhbGl0eSBvcHRpb25zXG4gICAgICAgIHRoaXMuY29uZmlnLnNldE9wdGlvblNldHRpbmdPcHRpb25zKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkUXVhbGl0eSwgYXZhaWxhYmxlUXVhbGl0aWVzKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3RlZCB2aWRlbyBxdWFsaXR5IHdpdGggdGhlIGhpZ2hlc3QgcG9zc2libGUgcmVzb2x1dGlvblxuICAgICAgICB0aGlzLmNvbmZpZy5zZXRPcHRpb25TZXR0aW5nVmFsdWUoT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRRdWFsaXR5LCBhdmFpbGFibGVRdWFsaXRpZXMuc2xpY2UoLTEpWzBdKTtcbiAgICAgICAgY29uc3Qgc2RwT2ZmZXIgPSB7XG4gICAgICAgICAgICBzZHA6IE9mZmVyLnNkcCxcbiAgICAgICAgICAgIHR5cGU6ICdvZmZlcidcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIucmVjZWl2ZU9mZmVyKHNkcE9mZmVyLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9zdFdlYnJ0Y05lZ290aWF0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB3aGVuIHRoZSBTRlUgcHJvdmlkZXMgdGhlIHBlZXIgd2l0aCBpdHMgZGF0YSBjaGFubmVsc1xuICAgICAqIEBwYXJhbSBEYXRhQ2hhbm5lbHMgLSBUaGUgbWVzc2FnZSBmcm9tIHRoZSBTRlUgY29udGFpbmluZyB0aGUgZGF0YSBjaGFubmVscyBpZHNcbiAgICAgKi9cbiAgICBoYW5kbGVXZWJSdGNTRlVQZWVyRGF0YWNoYW5uZWxzKERhdGFDaGFubmVscykge1xuICAgICAgICBjb25zdCBTZW5kT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG9yZGVyZWQ6IHRydWUsXG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IERhdGFDaGFubmVscy5zZW5kU3RyZWFtSWRcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdW5pZGlyZWN0aW9uYWwgPSBEYXRhQ2hhbm5lbHMuc2VuZFN0cmVhbUlkICE9IERhdGFDaGFubmVscy5yZWN2U3RyZWFtSWQ7XG4gICAgICAgIHRoaXMuc2VuZHJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIuY3JlYXRlRGF0YUNoYW5uZWwodGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIucGVlckNvbm5lY3Rpb24sIHVuaWRpcmVjdGlvbmFsID8gJ3NlbmQtZGF0YWNoYW5uZWwnIDogJ2RhdGFjaGFubmVsJywgU2VuZE9wdGlvbnMpO1xuICAgICAgICBpZiAodW5pZGlyZWN0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IFJlY3ZPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG9yZGVyZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpZDogRGF0YUNoYW5uZWxzLnJlY3ZTdHJlYW1JZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucmVjdkRhdGFDaGFubmVsQ29udHJvbGxlci5jcmVhdGVEYXRhQ2hhbm5lbCh0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5wZWVyQ29ubmVjdGlvbiwgJ3JlY3YtZGF0YWNoYW5uZWwnLCBSZWN2T3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIuaGFuZGxlT25PcGVuID0gKCkgPT4gdGhpcy5wcm90b2NvbC5zZW5kTWVzc2FnZShNZXNzYWdlSGVscGVycy5jcmVhdGVNZXNzYWdlKE1lc3NhZ2VzLnBlZXJEYXRhQ2hhbm5lbHNSZWFkeSkpO1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgdW5pLWRpcmVjdGlvbmFsLCBvbmx5IHRoZSByZWN2IGRhdGEgY2hhbm5lbCBzaG91bGQgaGFuZGxlIGluY29taW5nIG1lc3NhZ2VzXG4gICAgICAgICAgICB0aGlzLnJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIuaGFuZGxlT25NZXNzYWdlID0gKGV2KSA9PiB0aGlzLmhhbmRsZU9uTWVzc2FnZShldik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlbHNlIG91ciBwcmltYXJ5IGRhdGFjaGFubmVsIGlzIHNlbmQvcmVjdiBzbyBpdCBjYW4gaGFuZGxlIGluY29taW5nIG1lc3NhZ2VzXG4gICAgICAgICAgICB0aGlzLnNlbmRyZWN2RGF0YUNoYW5uZWxDb250cm9sbGVyLmhhbmRsZU9uTWVzc2FnZSA9IChldikgPT4gdGhpcy5oYW5kbGVPbk1lc3NhZ2UoZXYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVBvc3RXZWJydGNOZWdvdGlhdGlvbigpIHtcbiAgICAgICAgLy8gc3RhcnQgdGhlIGFmayB3YXJuaW5nIHRpbWVyIGFzIFBTIGlzIG5vdyBydW5uaW5nXG4gICAgICAgIHRoaXMuYWZrQ29udHJvbGxlci5zdGFydEFma1dhcm5pbmdUaW1lcigpO1xuICAgICAgICAvLyBzaG93IHRoZSBvdmVybGF5IHRoYXQgd2UgaGF2ZSBuZWdvdGlhdGVkIGEgY29ubmVjdGlvblxuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbldlYlJ0Y1NkcCgpO1xuICAgICAgICBpZiAodGhpcy5zdGF0c1RpbWVySGFuZGxlICYmIHRoaXMuc3RhdHNUaW1lckhhbmRsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLnN0YXRzVGltZXJIYW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdHNUaW1lckhhbmRsZSA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB0aGlzLmdldFN0YXRzKCksIDEwMDApO1xuICAgICAgICAvKiAgKi9cbiAgICAgICAgdGhpcy5zZXRNb3VzZUlucHV0RW5hYmxlZCh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLk1vdXNlSW5wdXQpKTtcbiAgICAgICAgdGhpcy5zZXRLZXlib2FyZElucHV0RW5hYmxlZCh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLktleWJvYXJkSW5wdXQpKTtcbiAgICAgICAgdGhpcy5zZXRHYW1lUGFkSW5wdXRFbmFibGVkKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuR2FtZXBhZElucHV0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIHdoZW4gYSByZW1vdGUgSUNFIGNhbmRpZGF0ZSBpcyByZWNlaXZlZC5cbiAgICAgKiBAcGFyYW0gaWNlQ2FuZGlkYXRlSW5pdCAtIEluaXRpYWxpemF0aW9uIGRhdGEgdXNlZCB0byBtYWtlIHRoZSBhY3R1YWwgSUNFIENhbmRpZGF0ZS5cbiAgICAgKi9cbiAgICBoYW5kbGVJY2VDYW5kaWRhdGUoaWNlQ2FuZGlkYXRlSW5pdCkge1xuICAgICAgICBMb2dnZXIuSW5mbyhgUmVtb3RlIElDRSBjYW5kaWRhdGUgaW5mb3JtYXRpb24gcmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoaWNlQ2FuZGlkYXRlSW5pdCl9YCk7XG4gICAgICAgIC8vIFdlIGFyZSB1c2luZyBcImJ1bmRsZVwiIHBvbGljeSBmb3IgbWVkaWEgbGluZXMgc28gd2UgcmVtb3ZlIHRoZSBzZHBNaWQgYW5kIHNkcE1MaW5lSW5kZXggYXR0cmlidXRlc1xuICAgICAgICAvLyBmcm9tIElDRSBjYW5kaWRhdGVzIGFzIHRoZXNlIGFyZSBsZWdhY3kgYXR0cmlidXRlcyBmb3Igd2hlbiBidW5kbGUgaXMgbm90IHVzZWQuXG4gICAgICAgIC8vIElmIHdlIGRvbid0IGRvIHRoaXMgdGhlIGJyb3dzZXIgbWF5IGJlIHVuYWJsZSB0byBmb3JtIGEgbWVkaWEgY29ubmVjdGlvblxuICAgICAgICAvLyBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgYXJlIGJyaXR0bGUgaWYgdGhlIGJ1bmRsZSBtYXN0ZXIgKGUuZy4gY29tbW9ubHkgbWlkPTApIGRvZXNuJ3QgZ2V0IGEgY2FuZGlkYXRlIGZpcnN0LlxuICAgICAgICBjb25zdCByZW1vdGVJY2VDYW5kaWRhdGUgPSBuZXcgUlRDSWNlQ2FuZGlkYXRlKHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZTogaWNlQ2FuZGlkYXRlSW5pdC5jYW5kaWRhdGUsXG4gICAgICAgICAgICBzZHBNaWQ6ICcnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5oYW5kbGVPbkljZShyZW1vdGVJY2VDYW5kaWRhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSBpY2UgQ2FuZGlkYXRlIHRvIHRoZSBzaWduYWxpbmcgc2VydmVyIHZpYSB3ZWJzb2NrZXRcbiAgICAgKiBAcGFyYW0gaWNlRXZlbnQgLSBSVEMgUGVlciBDb25uZWN0aW9uSWNlRXZlbnQpIHtcbiAgICAgKi9cbiAgICBoYW5kbGVTZW5kSWNlQ2FuZGlkYXRlKGljZUV2ZW50KSB7XG4gICAgICAgIGlmIChpY2VFdmVudC5jYW5kaWRhdGUgJiYgaWNlRXZlbnQuY2FuZGlkYXRlLmNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oYExvY2FsIElDRSBjYW5kaWRhdGUgZ2VuZXJhdGVkOiBgICsgSlNPTi5zdHJpbmdpZnkoaWNlRXZlbnQuY2FuZGlkYXRlKSk7XG4gICAgICAgICAgICB0aGlzLnByb3RvY29sLnNlbmRNZXNzYWdlKE1lc3NhZ2VIZWxwZXJzLmNyZWF0ZU1lc3NhZ2UoTWVzc2FnZXMuaWNlQ2FuZGlkYXRlLCB7IGNhbmRpZGF0ZTogaWNlRXZlbnQuY2FuZGlkYXRlIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSBpY2UgQ2FuZGlkYXRlIHRvIHRoZSBzaWduYWxpbmcgc2VydmVyIHZpYSB3ZWJzb2NrZXRcbiAgICAgKiBAcGFyYW0gaWNlRXZlbnQgLSBSVEMgUGVlciBDb25uZWN0aW9uSWNlRXZlbnQpIHtcbiAgICAgKi9cbiAgICBoYW5kbGVEYXRhQ2hhbm5lbChkYXRhY2hhbm5lbEV2ZW50KSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCdEYXRhIGNoYW5uZWwgY3JlYXRlZCBmb3IgdXMgYnkgYnJvd3NlciBhcyB3ZSBhcmUgYSByZWNlaXZpbmcgcGVlci4nKTtcbiAgICAgICAgdGhpcy5zZW5kcmVjdkRhdGFDaGFubmVsQ29udHJvbGxlci5kYXRhQ2hhbm5lbCA9IGRhdGFjaGFubmVsRXZlbnQuY2hhbm5lbDtcbiAgICAgICAgLy8gRGF0YSBjaGFubmVsIHdhcyBjcmVhdGVkIGZvciB1cywgc28gd2UganVzdCBuZWVkIHRvIHNldHVwIGl0cyBjYWxsYmFja3MgYW5kIGFycmF5IHR5cGVcbiAgICAgICAgdGhpcy5zZW5kcmVjdkRhdGFDaGFubmVsQ29udHJvbGxlci5zZXR1cERhdGFDaGFubmVsKCk7XG4gICAgICAgIHRoaXMuc2VuZHJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIuaGFuZGxlT25NZXNzYWdlID0gKGV2KSA9PiB0aGlzLmhhbmRsZU9uTWVzc2FnZShldik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIFJUQyBPZmZlciBTZXNzaW9uIHRvIHRoZSBTaWduYWxpbmcgc2VydmVyIHZpYSB3ZWJzb2NrZXRcbiAgICAgKiBAcGFyYW0gb2ZmZXIgLSBSVEMgU2Vzc2lvbiBEZXNjcmlwdGlvblxuICAgICAqL1xuICAgIGhhbmRsZVNlbmRXZWJSVENPZmZlcihvZmZlcikge1xuICAgICAgICBpZiAob2ZmZXIudHlwZSAhPT0gJ29mZmVyJykge1xuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBoYW5kbGVTZW5kV2ViUlRDT2ZmZXIgd2FzIGNhbGxlZCB3aXRoIHR5cGUgJHtvZmZlci50eXBlfSAtIGl0IG9ubHkgZXhwZWN0cyBcIm9mZmVyXCJgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBMb2dnZXIuSW5mbygnU2VuZGluZyB0aGUgb2ZmZXIgdG8gdGhlIFNlcnZlcicpO1xuICAgICAgICBjb25zdCBleHRyYVBhcmFtcyA9IHtcbiAgICAgICAgICAgIHNkcDogb2ZmZXIuc2RwLFxuICAgICAgICAgICAgbWluQml0cmF0ZUJwczogMTAwMCAqIHRoaXMuY29uZmlnLmdldE51bWVyaWNTZXR0aW5nVmFsdWUoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWluQml0cmF0ZSksXG4gICAgICAgICAgICBtYXhCaXRyYXRlQnBzOiAxMDAwICogdGhpcy5jb25maWcuZ2V0TnVtZXJpY1NldHRpbmdWYWx1ZShOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNYXhCaXRyYXRlKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb3RvY29sLnNlbmRNZXNzYWdlKE1lc3NhZ2VIZWxwZXJzLmNyZWF0ZU1lc3NhZ2UoTWVzc2FnZXMub2ZmZXIsIGV4dHJhUGFyYW1zKSk7XG4gICAgICAgIC8vIFNlbmQgb2ZmZXIgYmFjayB0byBQaXhlbCBTdHJlYW1pbmcgbWFpbiBjbGFzcyBmb3IgZXZlbnQgZGlzcGF0Y2hcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25XZWJSdGNTZHBPZmZlcihvZmZlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIFJUQyBPZmZlciBTZXNzaW9uIHRvIHRoZSBTaWduYWxpbmcgc2VydmVyIHZpYSB3ZWJzb2NrZXRcbiAgICAgKiBAcGFyYW0gYW5zd2VyIC0gUlRDIFNlc3Npb24gRGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBoYW5kbGVTZW5kV2ViUlRDQW5zd2VyKGFuc3dlcikge1xuICAgICAgICBpZiAoYW5zd2VyLnR5cGUgIT09ICdhbnN3ZXInKSB7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoYGhhbmRsZVNlbmRXZWJSVENBbnN3ZXIgd2FzIGNhbGxlZCB3aXRoIHR5cGUgJHthbnN3ZXIudHlwZX0gLSBpdCBvbmx5IGV4cGVjdHMgXCJhbnN3ZXJcImApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIExvZ2dlci5JbmZvKCdTZW5kaW5nIHRoZSBhbnN3ZXIgdG8gdGhlIFNlcnZlcicpO1xuICAgICAgICBjb25zdCBleHRyYVBhcmFtcyA9IHtcbiAgICAgICAgICAgIHNkcDogYW5zd2VyLnNkcCxcbiAgICAgICAgICAgIG1pbkJpdHJhdGVCcHM6IDEwMDAgKiB0aGlzLmNvbmZpZy5nZXROdW1lcmljU2V0dGluZ1ZhbHVlKE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01pbkJpdHJhdGUpLFxuICAgICAgICAgICAgbWF4Qml0cmF0ZUJwczogMTAwMCAqIHRoaXMuY29uZmlnLmdldE51bWVyaWNTZXR0aW5nVmFsdWUoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWF4Qml0cmF0ZSlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC5zZW5kTWVzc2FnZShNZXNzYWdlSGVscGVycy5jcmVhdGVNZXNzYWdlKE1lc3NhZ2VzLmFuc3dlciwgZXh0cmFQYXJhbXMpKTtcbiAgICAgICAgaWYgKHRoaXMuaXNVc2luZ1NGVSkge1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbC5zZW5kTWVzc2FnZShNZXNzYWdlSGVscGVycy5jcmVhdGVNZXNzYWdlKE1lc3NhZ2VzLmRhdGFDaGFubmVsUmVxdWVzdCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlbmQgYW5zd2VyIGJhY2sgdG8gUGl4ZWwgU3RyZWFtaW5nIG1haW4gY2xhc3MgZm9yIGV2ZW50IGRpc3BhdGNoXG4gICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuX29uV2ViUnRjU2RwQW5zd2VyKGFuc3dlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZnJlZXplIGZyYW1lIG92ZXJsYXkgdG8gdGhlIHBsYXllciBkaXZcbiAgICAgKi9cbiAgICBzZXRVcE1vdXNlQW5kRnJlZXplRnJhbWUoKSB7XG4gICAgICAgIC8vIENhbGN1bGF0aW5nIGFuZCBub3JtYWxpemluZyBwb3NpdGlvbnMgZGVwZW5kcyBvbiB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgcGxheWVyLlxuICAgICAgICBjb25zdCBwbGF5ZXJFbGVtZW50ID0gdGhpcy52aWRlb1BsYXllci5nZXRWaWRlb1BhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50ID0gdGhpcy52aWRlb1BsYXllci5nZXRWaWRlb0VsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5jb29yZGluYXRlQ29udmVydGVyLnJlY29uZmlndXJlKHsgd2lkdGg6IHBsYXllckVsZW1lbnQuY2xpZW50V2lkdGgsIGhlaWdodDogcGxheWVyRWxlbWVudC5jbGllbnRIZWlnaHQgfSwgeyB3aWR0aDogdmlkZW9FbGVtZW50LnZpZGVvV2lkdGgsIGhlaWdodDogdmlkZW9FbGVtZW50LnZpZGVvSGVpZ2h0IH0pO1xuICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lQ29udHJvbGxlci5mcmVlemVGcmFtZS5yZXNpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIENvbm5lY3Rpb24gdG8gdGhlIHNpZ25hbGluZyBzZXJ2ZXJcbiAgICAgKi9cbiAgICBjbG9zZVNpZ25hbGluZ1NlcnZlcihtZXNzYWdlLCBhbGxvd1JlY29ubmVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMubG9jYWxseUNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW5hYmxlQXV0b1JlY29ubmVjdCA9IGFsbG93UmVjb25uZWN0O1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgKF9hID0gdGhpcy5wcm90b2NvbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoMTAwMCwgbWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBwZWVyIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBjbG9zZVBlZXJDb25uZWN0aW9uKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgYWxsIGNvbm5lY3Rpb25zXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VTaWduYWxpbmdTZXJ2ZXIoJycsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jbG9zZVBlZXJDb25uZWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpcmVzIGEgVmlkZW8gU3RhdHMgRXZlbnQgaW4gdGhlIFJUQyBQZWVyIENvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBnZXRTdGF0cygpIHtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIuZ2VuZXJhdGVTdGF0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgTGF0ZW5jeSBUZXN0IFJlcXVlc3QgdG8gdGhlIFVFIEluc3RhbmNlXG4gICAgICovXG4gICAgc2VuZExhdGVuY3lUZXN0KCkge1xuICAgICAgICB0aGlzLmxhdGVuY3lTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0xhdGVuY3lUZXN0JykoW1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIFN0YXJ0VGltZTogdGhpcy5sYXRlbmN5U3RhcnRUaW1lXG4gICAgICAgICAgICB9KVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIERhdGEgQ2hhbm5lbCBMYXRlbmN5IFRlc3QgUmVxdWVzdCB0byB0aGUgVUUgSW5zdGFuY2VcbiAgICAgKi9cbiAgICBzZW5kRGF0YUNoYW5uZWxMYXRlbmN5VGVzdChkZXNjcmlwdG9yKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnRGF0YUNoYW5uZWxMYXRlbmN5VGVzdCcpKFtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGRlc2NyaXB0b3IpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSBNaW5RUCBlbmNvZGVyIHNldHRpbmcgdG8gdGhlIFVFIEluc3RhbmNlLlxuICAgICAqIEBwYXJhbSBtaW5RUCAtIFRoZSBsb3dlciBib3VuZCBmb3IgUVAgd2hlbiBlbmNvZGluZ1xuICAgICAqIHZhbGlkIHZhbHVlcyBhcmUgKDEtNTEpIHdoZXJlOlxuICAgICAqIDEgPSBCZXN0IHF1YWxpdHkgYnV0IGhpZ2hlc3QgYml0cmF0ZS5cbiAgICAgKiA1MSA9IFdvcnN0IHF1YWxpdHkgYnV0IGxvd2VzdCBiaXRyYXRlLlxuICAgICAqIEJ5IGRlZmF1bHQgdGhlIG1pblFQIGlzIDEgbWVhbmluZyB0aGUgZW5jb2RlciBpcyBmcmVlXG4gICAgICogdG8gYWltIGZvciB0aGUgYmVzdCBxdWFsaXR5IGl0IGNhbiBvbiB0aGUgZ2l2ZW4gbmV0d29yayBsaW5rLlxuICAgICAqL1xuICAgIHNlbmRFbmNvZGVyTWluUVAobWluUVApIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oYE1pblFQPSR7bWluUVB9XFxuYCk7XG4gICAgICAgIGlmIChtaW5RUCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0NvbW1hbmQnKShbXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAnRW5jb2Rlci5NaW5RUCc6IG1pblFQXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIE1heFFQIGVuY29kZXIgc2V0dGluZyB0byB0aGUgVUUgSW5zdGFuY2UuXG4gICAgICogQHBhcmFtIG1heFFQIC0gVGhlIHVwcGVyIGJvdW5kIGZvciBRUCB3aGVuIGVuY29kaW5nXG4gICAgICogdmFsaWQgdmFsdWVzIGFyZSAoMS01MSkgd2hlcmU6XG4gICAgICogMSA9IEJlc3QgcXVhbGl0eSBidXQgaGlnaGVzdCBiaXRyYXRlLlxuICAgICAqIDUxID0gV29yc3QgcXVhbGl0eSBidXQgbG93ZXN0IGJpdHJhdGUuXG4gICAgICogQnkgZGVmYXVsdCB0aGUgbWF4UVAgaXMgNTEgbWVhbmluZyB0aGUgZW5jb2RlciBpcyBmcmVlXG4gICAgICogdG8gZHJvcCBxdWFsaXR5IGFzIGxvdyBhcyBuZWVkZWQgb24gdGhlIGdpdmVuIG5ldHdvcmsgbGluay5cbiAgICAgKi9cbiAgICBzZW5kRW5jb2Rlck1heFFQKG1heFFQKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKGBNYXhRUD0ke21heFFQfVxcbmApO1xuICAgICAgICBpZiAobWF4UVAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdDb21tYW5kJykoW1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgJ0VuY29kZXIuTWF4UVAnOiBtYXhRUFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSBNaW5RdWFsaXR5IGVuY29kZXIgc2V0dGluZyB0byB0aGUgVUUgSW5zdGFuY2UuXG4gICAgICogQHBhcmFtIG1pblF1YWxpdHkgLSBUaGUgbG93ZXIgYm91bmQgZm9yIHF1YWxpdHkgd2hlbiBlbmNvZGluZ1xuICAgICAqIHZhbGlkIHZhbHVlcyBhcmUgKDAtMTAwKSB3aGVyZTpcbiAgICAgKiAwID0gV29yc3QgcXVhbGl0eS5cbiAgICAgKiAxMDAgPSBCZXN0IHF1YWxpdHkuXG4gICAgICovXG4gICAgc2VuZEVuY29kZXJNaW5RdWFsaXR5KG1pblF1YWxpdHkpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oYE1pblF1YWxpdHk9JHttaW5RdWFsaXR5fVxcbmApO1xuICAgICAgICBpZiAobWluUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0NvbW1hbmQnKShbXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAnRW5jb2Rlci5NaW5RdWFsaXR5JzogbWluUXVhbGl0eVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSBNYXhRdWFsaXR5IGVuY29kZXIgc2V0dGluZyB0byB0aGUgVUUgSW5zdGFuY2UuXG4gICAgICogQHBhcmFtIG1heFF1YWxpdHkgLSBUaGUgdXBwZXIgYm91bmQgZm9yIHF1YWxpdHkgd2hlbiBlbmNvZGluZ1xuICAgICAqIHZhbGlkIHZhbHVlcyBhcmUgKDAtMTAwKSB3aGVyZTpcbiAgICAgKiAwID0gV29yc3QgcXVhbGl0eS5cbiAgICAgKiAxMDAgPSBCZXN0IHF1YWxpdHkuXG4gICAgICovXG4gICAgc2VuZEVuY29kZXJNYXhRdWFsaXR5KG1heFF1YWxpdHkpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oYE1heFF1YWxpdHk9JHttYXhRdWFsaXR5fVxcbmApO1xuICAgICAgICBpZiAobWF4UXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0NvbW1hbmQnKShbXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAnRW5jb2Rlci5NYXhRdWFsaXR5JzogbWF4UXVhbGl0eVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSB7IFdlYlJUQy5NaW5CaXRyYXRlOiBTb21lTnVtYmVyIH19IGNvbW1hbmQgdG8gVUUgdG8gc2V0XG4gICAgICogdGhlIG1pbmltdW0gYml0cmF0ZSB0aGF0IHdlIGFsbG93IFdlYlJUQyB0byB1c2VcbiAgICAgKiAobm90ZSBzZXR0aW5nIHRoaXMgdG9vIGhpZ2ggaW4gcG9vciBuZXR3b3JrcyBjYW4gYmUgcHJvYmxlbWF0aWMpLlxuICAgICAqIEBwYXJhbSBtaW5CaXRyYXRlIC0gVGhlIG1pbmltdW0gYml0cmF0ZSB3ZSB3b3VsZCBsaWtlIFdlYlJUQyB0byBub3QgZmFsbCBiZWxvdy5cbiAgICAgKi9cbiAgICBzZW5kV2ViUlRDTWluQml0cmF0ZShtaW5CaXRyYXRlKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKGBXZWJSVEMgTWluIEJpdHJhdGU9JHttaW5CaXRyYXRlfWApO1xuICAgICAgICBpZiAobWluQml0cmF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0NvbW1hbmQnKShbXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAnV2ViUlRDLk1pbkJpdHJhdGUnOiBtaW5CaXRyYXRlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIHsgV2ViUlRDLk1heEJpdHJhdGU6IFNvbWVOdW1iZXIgfX0gY29tbWFuZCB0byBVRSB0byBzZXRcbiAgICAgKiB0aGUgbWluaW11bSBiaXRyYXRlIHRoYXQgd2UgYWxsb3cgV2ViUlRDIHRvIHVzZVxuICAgICAqIChub3RlIHNldHRpbmcgdGhpcyB0b28gbG93IGNvdWxkIHJlc3VsdCBpbiBibG9ja3kgdmlkZW8pLlxuICAgICAqIEBwYXJhbSBtaW5CaXRyYXRlIC0gVGhlIG1pbmltdW0gYml0cmF0ZSB3ZSB3b3VsZCBsaWtlIFdlYlJUQyB0byBub3QgZmFsbCBiZWxvdy5cbiAgICAgKi9cbiAgICBzZW5kV2ViUlRDTWF4Qml0cmF0ZShtYXhCaXRyYXRlKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKGBXZWJSVEMgTWF4IEJpdHJhdGU9JHttYXhCaXRyYXRlfWApO1xuICAgICAgICBpZiAobWF4Qml0cmF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0NvbW1hbmQnKShbXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAnV2ViUlRDLk1heEJpdHJhdGUnOiBtYXhCaXRyYXRlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIHsgV2ViUlRDLkZwczogU29tZU51bWJlciB9fSBVRSA1LjArXG4gICAgICogYW5kIHsgV2ViUlRDLk1heEZwcyB9IFVFIDQuMjcgY29tbWFuZCB0byBzZXRcbiAgICAgKiB0aGUgbWF4aW11bSBmcHMgd2Ugd291bGQgbGlrZSBXZWJSVEMgdG8gc3RyZWFtIGF0LlxuICAgICAqIEBwYXJhbSBmcHMgLSBUaGUgbWF4aW11bSBzdHJlYW0gZnBzLlxuICAgICAqL1xuICAgIHNlbmRXZWJSVENGcHMoZnBzKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKGBXZWJSVEMgRlBTPSR7ZnBzfWApO1xuICAgICAgICBpZiAoZnBzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnQ29tbWFuZCcpKFtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7ICdXZWJSVEMuRnBzJzogZnBzIH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIC8qIFRPRE86IFJlbW92ZSB3aGVuIFVFIDQuMjcgdW5zdXBwb3J0ZWQuICovXG4gICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0NvbW1hbmQnKShbXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyAnV2ViUlRDLk1heEZwcyc6IGZwcyB9KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgdGhlIFVJIERlc2NyaXB0b3IgYHN0YXQgZnBzYCB0byB0aGUgVUUgSW5zdGFuY2VcbiAgICAgKi9cbiAgICBzZW5kU2hvd0ZwcygpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0gICBTZW5kaW5nIHNob3cgc3RhdCB0byBVRSAgIC0tLS0nKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdDb21tYW5kJykoW0pTT04uc3RyaW5naWZ5KHsgJ3N0YXQuZnBzJzogJycgfSldKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhbiBJZnJhbWUgcmVxdWVzdCB0byB0aGUgc3RyZWFtZXJcbiAgICAgKi9cbiAgICBzZW5kSWZyYW1lUmVxdWVzdCgpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0gICBTZW5kaW5nIFJlcXVlc3QgZm9yIGFuIElGcmFtZSAgLS0tLScpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0lGcmFtZVJlcXVlc3QnKSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgVUlJbnRlcmFjdGlvbiBtZXNzYWdlXG4gICAgICovXG4gICAgZW1pdFVJSW50ZXJhY3Rpb24oZGVzY3JpcHRvcikge1xuICAgICAgICBMb2dnZXIuSW5mbygnLS0tLSAgIFNlbmRpbmcgY3VzdG9tIFVJSW50ZXJhY3Rpb24gbWVzc2FnZSAgIC0tLS0nKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdVSUludGVyYWN0aW9uJykoW0pTT04uc3RyaW5naWZ5KGRlc2NyaXB0b3IpXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBDb21tYW5kIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBlbWl0Q29tbWFuZChkZXNjcmlwdG9yKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCctLS0tICAgU2VuZGluZyBjdXN0b20gQ29tbWFuZCBtZXNzYWdlICAgLS0tLScpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0NvbW1hbmQnKShbSlNPTi5zdHJpbmdpZnkoZGVzY3JpcHRvcildKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIGNvbnNvbGUgY29tbWFuZCBtZXNzYWdlXG4gICAgICovXG4gICAgZW1pdENvbnNvbGVDb21tYW5kKGNvbW1hbmQpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0gICBTZW5kaW5nIGN1c3RvbSBDb21tYW5kOkNvbnNvbGVDb21tYW5kIG1lc3NhZ2UgICAtLS0tJyk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnQ29tbWFuZCcpKFtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBDb25zb2xlQ29tbWFuZDogY29tbWFuZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcmVxdWVzdCB0byB0aGUgVUUgSW5zdGFuY2UgdG8gaGF2ZSBvd25lcnNoaXAgb2YgUXVhbGl0eVxuICAgICAqL1xuICAgIHNlbmRSZXF1ZXN0UXVhbGl0eUNvbnRyb2xPd25lcnNoaXAoKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCctLS0tICAgU2VuZGluZyBSZXF1ZXN0IHRvIENvbnRyb2wgUXVhbGl0eSAgLS0tLScpO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlc0NvbnRyb2xsZXIuU2VuZFJlcXVlc3RRdWFsaXR5Q29udHJvbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgYFRleHRCb3hFbnRyeWAgbWVzc2FnZSBiYWNrIHRvIFVFLlxuICAgICAqIEBwYXJhbSBjb250ZW50cyBUaGUgbmV3IGNvbnRlbnRzIG9mIHRoZSBVRSBzaWRlIHRleHQgYm94LlxuICAgICAqL1xuICAgIHNlbmRUZXh0Ym94RW50cnkoY29udGVudHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBMb2dnZXIuSW5mbygnLS0tLSAgIFNlbmRpbmcgVGV4dGJveEVudHJ5IG1lc3NhZ2UgIC0tLS0nKTtcbiAgICAgICAgKF9hID0gdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdUZXh0Ym94RW50cnknKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKFtjb250ZW50c10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gYSBMYXRlbmN5IFRlc3QgUmVzdWx0IGFyZSByZWNlaXZlZCBmcm9tIHRoZSBVRSBJbnN0YW5jZVxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gTGF0ZW5jeSBUZXN0IFRpbWluZ3NcbiAgICAgKi9cbiAgICBoYW5kbGVMYXRlbmN5VGVzdFJlc3VsdChtZXNzYWdlKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCdEYXRhQ2hhbm5lbFJlY2VpdmVNZXNzYWdlVHlwZS5sYXRlbmN5VGVzdCcpO1xuICAgICAgICBjb25zdCBsYXRlbmN5QXNTdHJpbmcgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi0xNicpLmRlY29kZShtZXNzYWdlLnNsaWNlKDEpKTtcbiAgICAgICAgY29uc3QgbGF0ZW5jeVRlc3RSZXN1bHRzID0gbmV3IExhdGVuY3lUZXN0UmVzdWx0cygpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGxhdGVuY3lUZXN0UmVzdWx0cywgSlNPTi5wYXJzZShsYXRlbmN5QXNTdHJpbmcpKTtcbiAgICAgICAgbGF0ZW5jeVRlc3RSZXN1bHRzLnByb2Nlc3NGaWVsZHMoKTtcbiAgICAgICAgbGF0ZW5jeVRlc3RSZXN1bHRzLnRlc3RTdGFydFRpbWVNcyA9IHRoaXMubGF0ZW5jeVN0YXJ0VGltZTtcbiAgICAgICAgbGF0ZW5jeVRlc3RSZXN1bHRzLmJyb3dzZXJSZWNlaXB0VGltZU1zID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGF0ZW5jeVRlc3RSZXN1bHRzLmxhdGVuY3lFeGNsdWRpbmdEZWNvZGUgPSB+fihsYXRlbmN5VGVzdFJlc3VsdHMuYnJvd3NlclJlY2VpcHRUaW1lTXMgLSBsYXRlbmN5VGVzdFJlc3VsdHMudGVzdFN0YXJ0VGltZU1zKTtcbiAgICAgICAgbGF0ZW5jeVRlc3RSZXN1bHRzLnRlc3REdXJhdGlvbiA9IH5+KGxhdGVuY3lUZXN0UmVzdWx0cy5UcmFuc21pc3Npb25UaW1lTXMgLSBsYXRlbmN5VGVzdFJlc3VsdHMuUmVjZWlwdFRpbWVNcyk7XG4gICAgICAgIGxhdGVuY3lUZXN0UmVzdWx0cy5uZXR3b3JrTGF0ZW5jeSA9IH5+KGxhdGVuY3lUZXN0UmVzdWx0cy5sYXRlbmN5RXhjbHVkaW5nRGVjb2RlIC0gbGF0ZW5jeVRlc3RSZXN1bHRzLnRlc3REdXJhdGlvbik7XG4gICAgICAgIGlmIChsYXRlbmN5VGVzdFJlc3VsdHMuZnJhbWVEaXNwbGF5RGVsdGFUaW1lTXMgJiYgbGF0ZW5jeVRlc3RSZXN1bHRzLmJyb3dzZXJSZWNlaXB0VGltZU1zKSB7XG4gICAgICAgICAgICBsYXRlbmN5VGVzdFJlc3VsdHMuZW5kVG9FbmRMYXRlbmN5ID0gfn4obGF0ZW5jeVRlc3RSZXN1bHRzLmZyYW1lRGlzcGxheURlbHRhVGltZU1zICtcbiAgICAgICAgICAgICAgICBsYXRlbmN5VGVzdFJlc3VsdHMubmV0d29ya0xhdGVuY3ksXG4gICAgICAgICAgICAgICAgK2xhdGVuY3lUZXN0UmVzdWx0cy5DYXB0dXJlVG9TZW5kTXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuX29uTGF0ZW5jeVRlc3RSZXN1bHQobGF0ZW5jeVRlc3RSZXN1bHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIGEgRGF0YSBDaGFubmVsIExhdGVuY3kgVGVzdCBSZXNwb25zZSBpcyByZWNlaXZlZCBmcm9tIHRoZSBVRSBJbnN0YW5jZVxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gRGF0YSBDaGFubmVsIExhdGVuY3kgVGVzdCBSZXNwb25zZVxuICAgICAqL1xuICAgIGhhbmRsZURhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXNwb25zZShtZXNzYWdlKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCdEYXRhQ2hhbm5lbFJlY2VpdmVNZXNzYWdlVHlwZS5kYXRhQ2hhbm5lbExhdGVuY3lSZXNwb25zZScpO1xuICAgICAgICBjb25zdCByZXNwb25zZUFzU3RyaW5nID0gbmV3IFRleHREZWNvZGVyKCd1dGYtMTYnKS5kZWNvZGUobWVzc2FnZS5zbGljZSgxKSk7XG4gICAgICAgIGNvbnN0IGxhdGVuY3lUZXN0UmVzcG9uc2UgPSBKU09OLnBhcnNlKHJlc3BvbnNlQXNTdHJpbmcpO1xuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbkRhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXNwb25zZShsYXRlbmN5VGVzdFJlc3BvbnNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIHRoZSBFbmNvZGVyIGFuZCBXZWIgUlRDIFNldHRpbmdzIGFyZSByZWNlaXZlZCBmcm9tIHRoZSBVRSBJbnN0YW5jZVxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gSW5pdGlhbCBFbmNvZGVyIGFuZCBXZWIgUlRDIFNldHRpbmdzXG4gICAgICovXG4gICAgaGFuZGxlSW5pdGlhbFNldHRpbmdzKG1lc3NhZ2UpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ0RhdGFDaGFubmVsUmVjZWl2ZU1lc3NhZ2VUeXBlLkluaXRpYWxTZXR0aW5ncycpO1xuICAgICAgICBjb25zdCBwYXlsb2FkQXNTdHJpbmcgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi0xNicpLmRlY29kZShtZXNzYWdlLnNsaWNlKDEpKTtcbiAgICAgICAgY29uc3QgcGFyc2VkSW5pdGlhbFNldHRpbmdzID0gSlNPTi5wYXJzZShwYXlsb2FkQXNTdHJpbmcpO1xuICAgICAgICBjb25zdCBpbml0aWFsU2V0dGluZ3MgPSBuZXcgSW5pdGlhbFNldHRpbmdzKCk7XG4gICAgICAgIGlmIChwYXJzZWRJbml0aWFsU2V0dGluZ3MuRW5jb2Rlcikge1xuICAgICAgICAgICAgaW5pdGlhbFNldHRpbmdzLkVuY29kZXJTZXR0aW5ncyA9IHBhcnNlZEluaXRpYWxTZXR0aW5ncy5FbmNvZGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWRJbml0aWFsU2V0dGluZ3MuV2ViUlRDKSB7XG4gICAgICAgICAgICBpbml0aWFsU2V0dGluZ3MuV2ViUlRDU2V0dGluZ3MgPSBwYXJzZWRJbml0aWFsU2V0dGluZ3MuV2ViUlRDO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWRJbml0aWFsU2V0dGluZ3MuUGl4ZWxTdHJlYW1pbmcpIHtcbiAgICAgICAgICAgIGluaXRpYWxTZXR0aW5ncy5QaXhlbFN0cmVhbWluZ1NldHRpbmdzID0gcGFyc2VkSW5pdGlhbFNldHRpbmdzLlBpeGVsU3RyZWFtaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWRJbml0aWFsU2V0dGluZ3MuQ29uZmlnT3B0aW9ucyAmJlxuICAgICAgICAgICAgcGFyc2VkSW5pdGlhbFNldHRpbmdzLkNvbmZpZ09wdGlvbnMuRGVmYXVsdFRvSG92ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0RmxhZ0VuYWJsZWQoRmxhZ3MuSG92ZXJpbmdNb3VzZU1vZGUsICEhcGFyc2VkSW5pdGlhbFNldHRpbmdzLkNvbmZpZ09wdGlvbnMuRGVmYXVsdFRvSG92ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGluaXRpYWxTZXR0aW5ncy51ZUNvbXBhdGlibGUoKTtcbiAgICAgICAgTG9nZ2VyLkluZm8ocGF5bG9hZEFzU3RyaW5nKTtcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25Jbml0aWFsU2V0dGluZ3MoaW5pdGlhbFNldHRpbmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIHRoZSBRdWFudGl6YXRpb24gUGFyYW1ldGVyIGFyZSByZWNlaXZlZCBmcm9tIHRoZSBVRSBJbnN0YW5jZVxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gRW5jb2RlcnMgUXVhbnRpemF0aW9uIFBhcmFtZXRlclxuICAgICAqL1xuICAgIGhhbmRsZVZpZGVvRW5jb2RlckF2Z1FQKG1lc3NhZ2UpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ0RhdGFDaGFubmVsUmVjZWl2ZU1lc3NhZ2VUeXBlLlZpZGVvRW5jb2RlckF2Z1FQJyk7XG4gICAgICAgIGNvbnN0IEF2Z1FQID0gTnVtYmVyKG5ldyBUZXh0RGVjb2RlcigndXRmLTE2JykuZGVjb2RlKG1lc3NhZ2Uuc2xpY2UoMSkpKTtcbiAgICAgICAgdGhpcy5zZXRWaWRlb0VuY29kZXJBdmdRUChBdmdRUCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hlbiB0aGUgdmlkZW8gZWxlbWVudCBoYXMgYmVlbiBsb2FkZWQgd2l0aCBhIHNyY09iamVjdFxuICAgICAqL1xuICAgIGhhbmRsZVZpZGVvSW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuX29uVmlkZW9Jbml0aWFsaXplZCgpO1xuICAgICAgICAvLyBlaXRoZXIgYXV0b3BsYXkgdGhlIHZpZGVvIG9yIHNldCB1cCB0aGUgcGxheSBvdmVybGF5XG4gICAgICAgIHRoaXMuYXV0b1BsYXlWaWRlb09yU2V0VXBQbGF5T3ZlcmxheSgpO1xuICAgICAgICB0aGlzLnJlc2l6ZVBsYXllclN0eWxlKCk7XG4gICAgICAgIHRoaXMudmlkZW9QbGF5ZXIudXBkYXRlVmlkZW9TdHJlYW1TaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsYWcgc2V0IGlmIHRoZSB1c2VyIGhhcyBRdWFsaXR5IE93bmVyc2hpcFxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gRG9lcyB0aGUgY3VycmVudCBjbGllbnQgaGF2ZSBRdWFsaXR5IE93bmVyc2hpcFxuICAgICAqL1xuICAgIG9uUXVhbGl0eUNvbnRyb2xPd25lcnNoaXAobWVzc2FnZSkge1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSk7XG4gICAgICAgIExvZ2dlci5JbmZvKCdEYXRhQ2hhbm5lbFJlY2VpdmVNZXNzYWdlVHlwZS5RdWFsaXR5Q29udHJvbE93bmVyc2hpcCcpO1xuICAgICAgICB0aGlzLmlzUXVhbGl0eUNvbnRyb2xsZXIgPSBuZXcgQm9vbGVhbih2aWV3WzFdKS52YWx1ZU9mKCk7XG4gICAgICAgIExvZ2dlci5JbmZvKGBSZWNlaXZlZCBxdWFsaXR5IGNvbnRyb2xsZXIgbWVzc2FnZSwgd2lsbCBjb250cm9sIHF1YWxpdHk6ICR7dGhpcy5pc1F1YWxpdHlDb250cm9sbGVyfWApO1xuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vblF1YWxpdHlDb250cm9sT3duZXJzaGlwKHRoaXMuaXNRdWFsaXR5Q29udHJvbGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hlbiB0aGUgQWdncmVnYXRlZCBzdGF0cyBhcmUgQ29sbGVjdGVkXG4gICAgICogQHBhcmFtIHN0YXRzIC0gQWdncmVnYXRlZCBTdGF0c1xuICAgICAqL1xuICAgIGhhbmRsZVZpZGVvU3RhdHMoc3RhdHMpIHtcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25WaWRlb1N0YXRzKHN0YXRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gUmVzaXplIHRoZSBWaWRlbyBQbGF5ZXIgZWxlbWVudFxuICAgICAqL1xuICAgIHJlc2l6ZVBsYXllclN0eWxlKCkge1xuICAgICAgICB0aGlzLnZpZGVvUGxheWVyLnJlc2l6ZVBsYXllclN0eWxlKCk7XG4gICAgfVxuICAgIHNldFByZWZlcnJlZENvZGVjKGNvZGVjKSB7XG4gICAgICAgIHRoaXMucHJlZmVycmVkQ29kZWMgPSBjb2RlYztcbiAgICAgICAgaWYgKHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyKSB7XG4gICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5wcmVmZXJyZWRDb2RlYyA9IGNvZGVjO1xuICAgICAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIudXBkYXRlQ29kZWNTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRWaWRlb0VuY29kZXJBdmdRUChhdmdRUCkge1xuICAgICAgICB0aGlzLnZpZGVvQXZnUXAgPSBhdmdRUDtcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25WaWRlb0VuY29kZXJBdmdRUCh0aGlzLnZpZGVvQXZnUXApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBlbmFibGVzL2Rpc2FibGVzIGtleWJvYXJkIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIHNldEtleWJvYXJkSW5wdXRFbmFibGVkKGlzRW5hYmxlZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMua2V5Ym9hcmRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudW5yZWdpc3RlcigpO1xuICAgICAgICBpZiAoaXNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmtleWJvYXJkQ29udHJvbGxlciA9IHRoaXMuaW5wdXRDbGFzc2VzRmFjdG9yeS5yZWdpc3RlcktleUJvYXJkKHRoaXMuY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBlbmFibGVzL2Rpc2FibGVzIG1vdXNlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIHNldE1vdXNlSW5wdXRFbmFibGVkKGlzRW5hYmxlZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMubW91c2VDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudW5yZWdpc3RlcigpO1xuICAgICAgICBpZiAoaXNFbmFibGVkKSB7XG4gICAgICAgICAgICBjb25zdCBtb3VzZU1vZGUgPSB0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkhvdmVyaW5nTW91c2VNb2RlKVxuICAgICAgICAgICAgICAgID8gQ29udHJvbFNjaGVtZVR5cGUuSG92ZXJpbmdNb3VzZVxuICAgICAgICAgICAgICAgIDogQ29udHJvbFNjaGVtZVR5cGUuTG9ja2VkTW91c2U7XG4gICAgICAgICAgICB0aGlzLm1vdXNlQ29udHJvbGxlciA9IHRoaXMuaW5wdXRDbGFzc2VzRmFjdG9yeS5yZWdpc3Rlck1vdXNlKG1vdXNlTW9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogZW5hYmxlcy9kaXNhYmxlcyB0b3VjaCBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBzZXRUb3VjaElucHV0RW5hYmxlZChpc0VuYWJsZWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnRvdWNoQ29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVucmVnaXN0ZXIoKTtcbiAgICAgICAgaWYgKGlzRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50b3VjaENvbnRyb2xsZXIgPSB0aGlzLmlucHV0Q2xhc3Nlc0ZhY3RvcnkucmVnaXN0ZXJUb3VjaCh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkZha2VNb3VzZVdpdGhUb3VjaGVzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogZW5hYmxlcy9kaXNhYmxlcyBnYW1lIHBhZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBzZXRHYW1lUGFkSW5wdXRFbmFibGVkKGlzRW5hYmxlZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuZ2FtZVBhZENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bnJlZ2lzdGVyKCk7XG4gICAgICAgIGlmIChpc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2FtZVBhZENvbnRyb2xsZXIgPSB0aGlzLmlucHV0Q2xhc3Nlc0ZhY3RvcnkucmVnaXN0ZXJHYW1lUGFkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJEYXRhQ2hhbm5lbEV2ZW50RW1pdHRlcnMoZGF0YUNoYW5uZWwpIHtcbiAgICAgICAgZGF0YUNoYW5uZWwub25PcGVuID0gKGxhYmVsLCBldmVudCkgPT4gdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBEYXRhQ2hhbm5lbE9wZW5FdmVudCh7IGxhYmVsLCBldmVudCB9KSk7XG4gICAgICAgIGRhdGFDaGFubmVsLm9uQ2xvc2UgPSAobGFiZWwsIGV2ZW50KSA9PiB0aGlzLnBpeGVsU3RyZWFtaW5nLmRpc3BhdGNoRXZlbnQobmV3IERhdGFDaGFubmVsQ2xvc2VFdmVudCh7IGxhYmVsLCBldmVudCB9KSk7XG4gICAgICAgIGRhdGFDaGFubmVsLm9uRXJyb3IgPSAobGFiZWwsIGV2ZW50KSA9PiB0aGlzLnBpeGVsU3RyZWFtaW5nLmRpc3BhdGNoRXZlbnQobmV3IERhdGFDaGFubmVsRXJyb3JFdmVudCh7IGxhYmVsLCBldmVudCB9KSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIobmFtZSwgZGlyZWN0aW9uLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyICYmIHR5cGVvZiBoYW5kbGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgTG9nZ2VyLldhcm5pbmcoYFVuYWJsZSB0byByZWdpc3RlciBoYW5kbGVyIGZvciAke25hbWV9IGFzIG5vIGhhbmRsZXIgd2FzIHBhc3NlZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihkaXJlY3Rpb24sIG5hbWUsIChkYXRhKSA9PiB0eXBlb2YgaGFuZGxlciA9PT0gJ3VuZGVmaW5lZCcgJiYgZGlyZWN0aW9uID09PSBNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXJcbiAgICAgICAgICAgID8gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKG5hbWUsIGRhdGEpXG4gICAgICAgICAgICA6IGhhbmRsZXIoZGF0YSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdlYlJ0Y1BsYXllckNvbnRyb2xsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42JztcbmltcG9ydCB7IFhSR2FtZXBhZENvbnRyb2xsZXIgfSBmcm9tICcuLi9JbnB1dHMvWFJHYW1lcGFkQ29udHJvbGxlcic7XG5pbXBvcnQgeyBYckZyYW1lRXZlbnQgfSBmcm9tICcuLi9VdGlsL0V2ZW50RW1pdHRlcic7XG5pbXBvcnQgeyBGbGFncyB9IGZyb20gJy4uL0NvbmZpZy9Db25maWcnO1xuZXhwb3J0IGNsYXNzIFdlYlhSQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3Iod2ViUnRjUGxheWVyQ29udHJvbGxlcikge1xuICAgICAgICB0aGlzLnhyVmlld2VyUG9zZSA9IG51bGw7XG4gICAgICAgIC8vIFVzZWQgZm9yIGNvbXBhcmlzb25zIHRvIGVuc3VyZSB0d28gbnVtYmVycyBhcmUgY2xvc2UgZW5vdWdoLlxuICAgICAgICB0aGlzLkVQU0lMT04gPSAwLjAwMDAwMDE7XG4gICAgICAgIHRoaXMudmlkZW9UZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2VmlkZW9XaWR0aCA9IDA7XG4gICAgICAgIHRoaXMucHJldlZpZGVvSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5sZWZ0VmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMucmlnaHRWaWV3ID0gbnVsbDtcbiAgICAgICAgLy8gU3RvcmUgdGhlIEhNRCBkYXRhIHdlIGhhdmUgbGFzdCBzZW50IChub3QgYWxsIG9mIGl0IGlzIG5lZWRlZCBldmVyeSBmcmFtZSB1bmxlc3MgaXQgY2hhbmdlcylcbiAgICAgICAgdGhpcy5sYXN0U2VudExlZnRFeWVQcm9qID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VudFJpZ2h0RXllUHJvaiA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFNlbnRSZWxhdGl2ZUxlZnRFeWVQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RTZW50UmVsYXRpdmVSaWdodEV5ZVBvcyA9IG51bGw7XG4gICAgICAgIHRoaXMueHJTZXNzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy53ZWJSdGNDb250cm9sbGVyID0gd2ViUnRjUGxheWVyQ29udHJvbGxlcjtcbiAgICAgICAgdGhpcy54ckdhbWVwYWRDb250cm9sbGVyID0gbmV3IFhSR2FtZXBhZENvbnRyb2xsZXIodGhpcy53ZWJSdGNDb250cm9sbGVyLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyKTtcbiAgICAgICAgdGhpcy5vblNlc3Npb25FbmRlZCA9IG5ldyBFdmVudFRhcmdldCgpO1xuICAgICAgICB0aGlzLm9uU2Vzc2lvblN0YXJ0ZWQgPSBuZXcgRXZlbnRUYXJnZXQoKTtcbiAgICAgICAgdGhpcy5vbkZyYW1lID0gbmV3IEV2ZW50VGFyZ2V0KCk7XG4gICAgfVxuICAgIHhyQ2xpY2tlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnhyU2Vzc2lvbikge1xuICAgICAgICAgICAgaWYgKCFuYXZpZ2F0b3IueHIpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFhSLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hdmlnYXRvci54clxuICAgICAgICAgICAgICAgIC8qIFJlcXVlc3QgaW1tZXJzaXZlLXZyIHNlc3Npb24gd2l0aG91dCBhbnkgb3B0aW9uYWwgZmVhdHVyZXMuICovXG4gICAgICAgICAgICAgICAgLnJlcXVlc3RTZXNzaW9uKCdpbW1lcnNpdmUtdnInLCB7IG9wdGlvbmFsRmVhdHVyZXM6IFtdIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHNlc3Npb24pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uWHJTZXNzaW9uU3RhcnRlZChzZXNzaW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54clNlc3Npb24uZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25YclNlc3Npb25FbmRlZCgpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ1hSIFNlc3Npb24gZW5kZWQnKTtcbiAgICAgICAgdGhpcy54clNlc3Npb24gPSBudWxsO1xuICAgICAgICB0aGlzLm9uU2Vzc2lvbkVuZGVkLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCd4clNlc3Npb25FbmRlZCcpKTtcbiAgICB9XG4gICAgaW5pdEdMKCkge1xuICAgICAgICBpZiAodGhpcy5nbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLmdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIHtcbiAgICAgICAgICAgIHhyQ29tcGF0aWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IG91ciBjbGVhciBjb2xvclxuICAgICAgICB0aGlzLmdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMSk7XG4gICAgfVxuICAgIGluaXRTaGFkZXJzKCkge1xuICAgICAgICAvLyBzaGFkZXIgc291cmNlIGNvZGVcbiAgICAgICAgY29uc3QgdmVydGV4U2hhZGVyU291cmNlID0gYFxuICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xuICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkO1xuXG4gICAgICAgIC8vIHZhcnlpbmdzXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xuXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24ueCwgYV9wb3NpdGlvbi55LCAwLCAxKTtcbiAgICAgICAgICAgLy8gcGFzcyB0aGUgdGV4Q29vcmQgdG8gdGhlIGZyYWdtZW50IHNoYWRlclxuICAgICAgICAgICAvLyBUaGUgR1BVIHdpbGwgaW50ZXJwb2xhdGUgdGhpcyB2YWx1ZSBiZXR3ZWVuIHBvaW50cy5cbiAgICAgICAgICAgdl90ZXhDb29yZCA9IGFfdGV4Q29vcmQ7XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gICAgICAgIC8vIG91ciB0ZXh0dXJlXG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XG5cbiAgICAgICAgLy8gdGhlIHRleENvb3JkcyBwYXNzZWQgaW4gZnJvbSB0aGUgdmVydGV4IHNoYWRlci5cbiAgICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XG5cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgICAgLy8gc2V0dXAgdmVydGV4IHNoYWRlclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSB0aGlzLmdsLmNyZWF0ZVNoYWRlcih0aGlzLmdsLlZFUlRFWF9TSEFERVIpO1xuICAgICAgICB0aGlzLmdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNoYWRlclNvdXJjZSk7XG4gICAgICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgICAgICAvLyBzZXR1cCBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmdsLmNyZWF0ZVNoYWRlcih0aGlzLmdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgICAgIHRoaXMuZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgICAgIC8vIHNldHVwIEdMU0wgcHJvZ3JhbVxuICAgICAgICBjb25zdCBzaGFkZXJQcm9ncmFtID0gdGhpcy5nbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgICAgICAgdGhpcy5nbC5saW5rUHJvZ3JhbShzaGFkZXJQcm9ncmFtKTtcbiAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHNoYWRlclByb2dyYW0pO1xuICAgICAgICAvLyBsb29rIHVwIHdoZXJlIHZlcnRleCBkYXRhIG5lZWRzIHRvIGdvXG4gICAgICAgIHRoaXMucG9zaXRpb25Mb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgJ2FfcG9zaXRpb24nKTtcbiAgICAgICAgdGhpcy50ZXhjb29yZExvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbihzaGFkZXJQcm9ncmFtLCAnYV90ZXhDb29yZCcpO1xuICAgIH1cbiAgICB1cGRhdGVWaWRlb1RleHR1cmUoKSB7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1RleHR1cmUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBvdXIgdGV4dHVyZSB0aGF0IHdlIHVzZSBpbiBvdXIgc2hhZGVyXG4gICAgICAgICAgICAvLyBhbmQgYmluZCBpdCBvbmNlIGJlY2F1c2Ugd2UgbmV2ZXIgdXNlIGFueSBvdGhlciB0ZXh0dXJlLlxuICAgICAgICAgICAgdGhpcy52aWRlb1RleHR1cmUgPSB0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLnZpZGVvVGV4dHVyZSk7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIHBhcmFtZXRlcnMgc28gd2UgY2FuIHJlbmRlciBhbnkgc2l6ZSBpbWFnZS5cbiAgICAgICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuZ2wuTElORUFSKTtcbiAgICAgICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLmdsLkxJTkVBUik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlkZW9IZWlnaHQgPSB0aGlzLndlYlJ0Y0NvbnRyb2xsZXIudmlkZW9QbGF5ZXIuZ2V0VmlkZW9FbGVtZW50KCkudmlkZW9IZWlnaHQ7XG4gICAgICAgIGNvbnN0IHZpZGVvV2lkdGggPSB0aGlzLndlYlJ0Y0NvbnRyb2xsZXIudmlkZW9QbGF5ZXIuZ2V0VmlkZW9FbGVtZW50KCkudmlkZW9XaWR0aDtcbiAgICAgICAgaWYgKHRoaXMucHJldlZpZGVvSGVpZ2h0ICE9IHZpZGVvSGVpZ2h0IHx8IHRoaXMucHJldlZpZGVvV2lkdGggIT0gdmlkZW9XaWR0aCkge1xuICAgICAgICAgICAgLy8gRG8gZnVsbCB1cGRhdGUgb2YgdGV4dHVyZSBpZiBkaW1lbnNpb25zIGRvIG5vdCBtYXRjaFxuICAgICAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB2aWRlb1dpZHRoLCB2aWRlb0hlaWdodCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsIHRoaXMud2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci5nZXRWaWRlb0VsZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBkaW1lbnNpb25zIG1hdGNoIGp1c3QgdXBkYXRlIHRoZSBzdWIgcmVnaW9uXG4gICAgICAgICAgICB0aGlzLmdsLnRleFN1YkltYWdlMkQodGhpcy5nbC5URVhUVVJFXzJELCAwLCAwLCAwLCB2aWRlb1dpZHRoLCB2aWRlb0hlaWdodCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsIHRoaXMud2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci5nZXRWaWRlb0VsZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHByZXYgdmlkZW8gd2lkdGgvaGVpZ2h0XG4gICAgICAgIHRoaXMucHJldlZpZGVvSGVpZ2h0ID0gdmlkZW9IZWlnaHQ7XG4gICAgICAgIHRoaXMucHJldlZpZGVvV2lkdGggPSB2aWRlb1dpZHRoO1xuICAgIH1cbiAgICBpbml0QnVmZmVycygpIHtcbiAgICAgICAgLy8gQ3JlYXRlIG91dCBwb3NpdGlvbiBidWZmZXIgYW5kIGl0cyB2ZXJ0ZXggc2hhZGVyIGF0dHJpYnV0ZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBidWZmZXIgdG8gcHV0IHRoZSB0aGUgdmVydGljZXMgb2YgdGhlIHBsYW5lIHdlIHdpbGwgZHJhdyB0aGUgdmlkZW8gc3RyZWFtIG9udG9cbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25CdWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgLy8gQmluZCB0aGUgcG9zaXRpb24gYnVmZmVyXG4gICAgICAgICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMucG9zaXRpb25CdWZmZXIpO1xuICAgICAgICAgICAgLy8gRW5hYmxlIGBwb3NpdGlvbkxvY2F0aW9uYCB0byBiZSB1c2VkIGFzIHZlcnRleCBzaGFkZXIgYXR0cmlidXRlXG4gICAgICAgICAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMucG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICAgICAgICAvLyBOb3RlOiBwb3NpdGlvbnMgYXJlIHBhc3NlZCBpbiBjbGlwLXNwYWNlIGNvb3JkaW5hdGVzIFstMS4uMV0gc28gbm8gbmVlZCB0byBjb252ZXJ0IGluLXNoYWRlclxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICB0aGlzLmdsLmJ1ZmZlckRhdGEodGhpcy5nbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAgICAgICAgIC0xLjAsIDEuMCxcbiAgICAgICAgICAgICAgICAxLjAsIDEuMCxcbiAgICAgICAgICAgICAgICAtMS4wLCAtMS4wLFxuICAgICAgICAgICAgICAgIC0xLjAsIC0xLjAsXG4gICAgICAgICAgICAgICAgMS4wLCAxLjAsXG4gICAgICAgICAgICAgICAgMS4wLCAtMS4wXG4gICAgICAgICAgICBdKSwgdGhpcy5nbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgICAgICAvLyBUZWxsIHBvc2l0aW9uIGF0dHJpYnV0ZSBvZiB0aGUgdmVydGV4IHNoYWRlciBob3cgdG8gZ2V0IGRhdGEgb3V0IG9mIHRoZSBib3VuZCBidWZmZXIgKHRoZSBwb3NpdGlvbkJ1ZmZlcilcbiAgICAgICAgICAgIHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnBvc2l0aW9uTG9jYXRpb24sIDIgLypzaXplKi8sIHRoaXMuZ2wuRkxPQVQgLyp0eXBlKi8sIGZhbHNlIC8qbm9ybWFsaXplKi8sIDAgLypzdHJpZGUqLywgMCAvKm9mZnNldCovKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgb3VyIHRleHR1cmUgY29vcmRpbmF0ZSBidWZmZXJzIGZvciBhY2Nlc3Npbmcgb3VyIHRleHR1cmVcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy50ZXhjb29yZEJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICAvLyBCaW5kIHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGUgYnVmZmVyXG4gICAgICAgICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMudGV4Y29vcmRCdWZmZXIpO1xuICAgICAgICAgICAgLy8gRW5hYmxlIGB0ZXhjb29yZExvY2F0aW9uYCB0byBiZSB1c2VkIGFzIGEgdmVydGV4IHNoYWRlciBhdHRyaWJ1dGVcbiAgICAgICAgICAgIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy50ZXhjb29yZExvY2F0aW9uKTtcbiAgICAgICAgICAgIC8vIFRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIHRvIGFwcGx5IGZvciByZWN0YW5nbGUgd2UgYXJlIGRyYXdpbmdcbiAgICAgICAgICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbMC4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIDEuMCwgMC4wLCAxLjAsIDEuMCwgMC4wLCAxLjAsIDEuMF0pLCB0aGlzLmdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgICAgIC8vIFRlbGwgdGV4dHVyZSBjb29yZGluYXRlIGF0dHJpYnV0ZSBvZiB0aGUgdmVydGV4IHNoYWRlciBob3cgdG8gZ2V0IGRhdGEgb3V0IG9mIHRoZSBib3VuZCBidWZmZXIgKHRoZSB0ZXhjb29yZEJ1ZmZlcilcbiAgICAgICAgICAgIHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnRleGNvb3JkTG9jYXRpb24sIDIgLypzaXplKi8sIHRoaXMuZ2wuRkxPQVQgLyp0eXBlKi8sIGZhbHNlIC8qbm9ybWFsaXplKi8sIDAgLypzdHJpZGUqLywgMCAvKm9mZnNldCovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblhyU2Vzc2lvblN0YXJ0ZWQoc2Vzc2lvbikge1xuICAgICAgICBMb2dnZXIuSW5mbygnWFIgU2Vzc2lvbiBzdGFydGVkJyk7XG4gICAgICAgIHRoaXMueHJTZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy54clNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vblhyU2Vzc2lvbkVuZGVkKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJbml0aWFsaXphdGlvblxuICAgICAgICB0aGlzLmluaXRHTCgpO1xuICAgICAgICB0aGlzLmluaXRTaGFkZXJzKCk7XG4gICAgICAgIHRoaXMuaW5pdEJ1ZmZlcnMoKTtcbiAgICAgICAgc2Vzc2lvbi5yZXF1ZXN0UmVmZXJlbmNlU3BhY2UoJ2xvY2FsJykudGhlbigocmVmU3BhY2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMueHJSZWZTcGFjZSA9IHJlZlNwYWNlO1xuICAgICAgICAgICAgLy8gU2V0IHVwIG91ciBiYXNlIGxheWVyIChpLmUuIGEgcHJvamVjdGlvbiBsYXllciB0aGF0IGZpbGxzIHRoZSBlbnRpcmUgWFIgdmlld3BvcnQpLlxuICAgICAgICAgICAgdGhpcy54clNlc3Npb24udXBkYXRlUmVuZGVyU3RhdGUoe1xuICAgICAgICAgICAgICAgIGJhc2VMYXllcjogbmV3IFhSV2ViR0xMYXllcih0aGlzLnhyU2Vzc2lvbiwgdGhpcy5nbClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRhcmdldCBmcmFtZXJhdGUgdG8gOTAgZnBzIGlmIDkwIGZwcyBpcyBzdXBwb3J0ZWQgaW4gdGhpcyBYUiBkZXZpY2VcbiAgICAgICAgICAgIGlmICh0aGlzLnhyU2Vzc2lvbi5zdXBwb3J0ZWRGcmFtZVJhdGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmcmFtZVJhdGUgb2YgdGhpcy54clNlc3Npb24uc3VwcG9ydGVkRnJhbWVSYXRlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVSYXRlID09IDkwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnVwZGF0ZVRhcmdldEZyYW1lUmF0ZSg5MCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCaW5kaW5nIHRvIGVhY2ggbmV3IGZyYW1lIHRvIGdldCBsYXRlc3QgWFIgdXBkYXRlc1xuICAgICAgICAgICAgdGhpcy54clNlc3Npb24ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMub25YckZyYW1lLmJpbmQodGhpcykpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblNlc3Npb25TdGFydGVkLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCd4clNlc3Npb25TdGFydGVkJykpO1xuICAgIH1cbiAgICBhcmVBcnJheXNFcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGVsZW1lbnQsIGluZGV4KSA9PiBNYXRoLmFicyhlbGVtZW50IC0gYltpbmRleF0pIDw9IHRoaXMuRVBTSUxPTikpO1xuICAgIH1cbiAgICBhcmVQb2ludHNFcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5hYnMoYS54IC0gYi54KSA+PSB0aGlzLkVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEueSAtIGIueSkgPj0gdGhpcy5FUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhLnogLSBiLnopID49IHRoaXMuRVBTSUxPTik7XG4gICAgfVxuICAgIHNlbmRYUkRhdGFUb1VFKCkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0VmlldyA9PSBudWxsIHx8IHRoaXMucmlnaHRWaWV3ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBzZWxlY3RpdmVseSBzZW5kIGVpdGhlciB0aGUgYFhSRXllVmlld3NgIG9yIGBYUkhNRFRyYW5zZm9ybWBcbiAgICAgICAgLy8gbWVzc2FnZXMgb3ZlciB0aGUgZGF0YWNoYW5uZWwuIFRoZSByZWFzb24gZm9yIHRoaXMgc2VsZWN0aXZlIHNlbmRpbmcgaXMgdGhhdFxuICAgICAgICAvLyB0aGUgYFhSRXllVmlld3NgIGlzIGEgbXVjaCBsYXJnZXIgbWVzc2FnZSBhbmQgY2hhbmdlcyBpbmZyZXF1ZW50bHkgKGUuZy4gb25seSB3aGVuIHVzZXIgY2hhbmdlcyBoZWFkc2V0IElQRCkuXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgd2Ugb25seSBuZWVkIHRvIHNlbmQgaXQgb25jZSBvbiBzdGFydHVwIGFuZCB0aGVuIGFueSB0aW1lIGl0IGNoYW5nZXMuXG4gICAgICAgIC8vIFRoZSByZXN0IG9mIHRoZSB0aW1lIHdlIGNhbiBzZW5kIHRoZSBgWFJITURUcmFuc2Zvcm1gIG1lc3NhZ2UuXG4gICAgICAgIGxldCBzaG91bGRTZW5kRXllVmlld3MgPSB0aGlzLmxhc3RTZW50TGVmdEV5ZVByb2ogPT0gbnVsbCB8fFxuICAgICAgICAgICAgdGhpcy5sYXN0U2VudFJpZ2h0RXllUHJvaiA9PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLmxhc3RTZW50UmVsYXRpdmVMZWZ0RXllUG9zID09IG51bGwgfHxcbiAgICAgICAgICAgIHRoaXMubGFzdFNlbnRSZWxhdGl2ZVJpZ2h0RXllUG9zID09IG51bGw7XG4gICAgICAgIGNvbnN0IGxlZnRFeWVUcmFucyA9IHRoaXMubGVmdFZpZXcudHJhbnNmb3JtLm1hdHJpeDtcbiAgICAgICAgY29uc3QgbGVmdEV5ZVByb2ogPSB0aGlzLmxlZnRWaWV3LnByb2plY3Rpb25NYXRyaXg7XG4gICAgICAgIGNvbnN0IHJpZ2h0RXllVHJhbnMgPSB0aGlzLnJpZ2h0Vmlldy50cmFuc2Zvcm0ubWF0cml4O1xuICAgICAgICBjb25zdCByaWdodEV5ZVByb2ogPSB0aGlzLnJpZ2h0Vmlldy5wcm9qZWN0aW9uTWF0cml4O1xuICAgICAgICBjb25zdCBobWRUcmFucyA9IHRoaXMueHJWaWV3ZXJQb3NlLnRyYW5zZm9ybS5tYXRyaXg7XG4gICAgICAgIC8vIENoZWNrIGlmIHByb2plY3Rpb24gbWF0cmljZXMgaGF2ZSBjaGFuZ2VkXG4gICAgICAgIGlmICghc2hvdWxkU2VuZEV5ZVZpZXdzICYmIHRoaXMubGFzdFNlbnRMZWZ0RXllUHJvaiAhPSBudWxsICYmIHRoaXMubGFzdFNlbnRSaWdodEV5ZVByb2ogIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbGVmdEV5ZVByb2pVbmNoYW5nZWQgPSB0aGlzLmFyZUFycmF5c0VxdWFsKGxlZnRFeWVQcm9qLCB0aGlzLmxhc3RTZW50TGVmdEV5ZVByb2opO1xuICAgICAgICAgICAgY29uc3QgcmlnaHRFeWVQcm9qVW5jaGFuZ2VkID0gdGhpcy5hcmVBcnJheXNFcXVhbChyaWdodEV5ZVByb2osIHRoaXMubGFzdFNlbnRSaWdodEV5ZVByb2opO1xuICAgICAgICAgICAgc2hvdWxkU2VuZEV5ZVZpZXdzID0gbGVmdEV5ZVByb2pVbmNoYW5nZWQgPT0gZmFsc2UgfHwgcmlnaHRFeWVQcm9qVW5jaGFuZ2VkID09IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlZnRFeWVSZWxhdGl2ZVBvcyA9IG5ldyBET01Qb2ludFJlYWRPbmx5KHRoaXMubGVmdFZpZXcudHJhbnNmb3JtLnBvc2l0aW9uLnggLSB0aGlzLnhyVmlld2VyUG9zZS50cmFuc2Zvcm0ucG9zaXRpb24ueCwgdGhpcy5sZWZ0Vmlldy50cmFuc2Zvcm0ucG9zaXRpb24ueSAtIHRoaXMueHJWaWV3ZXJQb3NlLnRyYW5zZm9ybS5wb3NpdGlvbi55LCB0aGlzLmxlZnRWaWV3LnRyYW5zZm9ybS5wb3NpdGlvbi56IC0gdGhpcy54clZpZXdlclBvc2UudHJhbnNmb3JtLnBvc2l0aW9uLnosIDEuMCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0RXllUmVsYXRpdmVQb3MgPSBuZXcgRE9NUG9pbnRSZWFkT25seSh0aGlzLmxlZnRWaWV3LnRyYW5zZm9ybS5wb3NpdGlvbi54IC0gdGhpcy54clZpZXdlclBvc2UudHJhbnNmb3JtLnBvc2l0aW9uLngsIHRoaXMubGVmdFZpZXcudHJhbnNmb3JtLnBvc2l0aW9uLnkgLSB0aGlzLnhyVmlld2VyUG9zZS50cmFuc2Zvcm0ucG9zaXRpb24ueSwgdGhpcy5sZWZ0Vmlldy50cmFuc2Zvcm0ucG9zaXRpb24ueiAtIHRoaXMueHJWaWV3ZXJQb3NlLnRyYW5zZm9ybS5wb3NpdGlvbi56LCAxLjApO1xuICAgICAgICAvLyBDaGVjayBpZiByZWxhdGl2ZSBleWUgcG9zIGhhcyBjaGFuZ2VkIChlLmcgSVBEIGNoYW5nZWQpXG4gICAgICAgIGlmICghc2hvdWxkU2VuZEV5ZVZpZXdzICYmXG4gICAgICAgICAgICB0aGlzLmxhc3RTZW50UmVsYXRpdmVMZWZ0RXllUG9zICE9IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMubGFzdFNlbnRSZWxhdGl2ZVJpZ2h0RXllUG9zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRFeWVQb3NVbmNoYW5nZWQgPSB0aGlzLmFyZVBvaW50c0VxdWFsKGxlZnRFeWVSZWxhdGl2ZVBvcywgdGhpcy5sYXN0U2VudFJlbGF0aXZlTGVmdEV5ZVBvcyk7XG4gICAgICAgICAgICBjb25zdCByaWdodEV5ZVBvc1VuY2hhbmdlZCA9IHRoaXMuYXJlUG9pbnRzRXF1YWwocmlnaHRFeWVSZWxhdGl2ZVBvcywgdGhpcy5sYXN0U2VudFJlbGF0aXZlUmlnaHRFeWVQb3MpO1xuICAgICAgICAgICAgc2hvdWxkU2VuZEV5ZVZpZXdzID0gbGVmdEV5ZVBvc1VuY2hhbmdlZCA9PSBmYWxzZSB8fCByaWdodEV5ZVBvc1VuY2hhbmdlZCA9PSBmYWxzZTtcbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIGFyZSBub3QgY2hlY2tpbmcgaWYgRXllVmlldyByb3RhdGlvbiBjaGFuZ2VzIChhcyBmYXIgYXMgSSBrbm93IG5vIEhNRCBzdXBwb3J0cyBjaGFuZ2luZyB0aGlzIHZhbHVlIGF0IHJ1bnRpbWUpLlxuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRTZW5kRXllVmlld3MpIHtcbiAgICAgICAgICAgIC8vIHNlbmQgdHJhbnNmb3JtICg0eDQpIGFuZCBwcm9qZWN0aW9uIG1hdHJpeCAoNHg0KSBkYXRhIGZvciBlYWNoIGV5ZSAobGVmdCBmaXJzdCwgdGhlbiByaWdodClcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy53ZWJSdGNDb250cm9sbGVyLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ1hSRXllVmlld3MnKShbXG4gICAgICAgICAgICAgICAgLy8gTGVmdCBleWUgNHg0IHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgICAgICAgICAgICBsZWZ0RXllVHJhbnNbMF0sIGxlZnRFeWVUcmFuc1s0XSwgbGVmdEV5ZVRyYW5zWzhdLCBsZWZ0RXllVHJhbnNbMTJdLFxuICAgICAgICAgICAgICAgIGxlZnRFeWVUcmFuc1sxXSwgbGVmdEV5ZVRyYW5zWzVdLCBsZWZ0RXllVHJhbnNbOV0sIGxlZnRFeWVUcmFuc1sxM10sXG4gICAgICAgICAgICAgICAgbGVmdEV5ZVRyYW5zWzJdLCBsZWZ0RXllVHJhbnNbNl0sIGxlZnRFeWVUcmFuc1sxMF0sIGxlZnRFeWVUcmFuc1sxNF0sXG4gICAgICAgICAgICAgICAgbGVmdEV5ZVRyYW5zWzNdLCBsZWZ0RXllVHJhbnNbN10sIGxlZnRFeWVUcmFuc1sxMV0sIGxlZnRFeWVUcmFuc1sxNV0sXG4gICAgICAgICAgICAgICAgLy8gTGVmdCBleWUgNHg0IHByb2plY3Rpb24gbWF0cml4XG4gICAgICAgICAgICAgICAgbGVmdEV5ZVByb2pbMF0sIGxlZnRFeWVQcm9qWzRdLCBsZWZ0RXllUHJvals4XSwgbGVmdEV5ZVByb2pbMTJdLFxuICAgICAgICAgICAgICAgIGxlZnRFeWVQcm9qWzFdLCBsZWZ0RXllUHJvals1XSwgbGVmdEV5ZVByb2pbOV0sIGxlZnRFeWVQcm9qWzEzXSxcbiAgICAgICAgICAgICAgICBsZWZ0RXllUHJvalsyXSwgbGVmdEV5ZVByb2pbNl0sIGxlZnRFeWVQcm9qWzEwXSwgbGVmdEV5ZVByb2pbMTRdLFxuICAgICAgICAgICAgICAgIGxlZnRFeWVQcm9qWzNdLCBsZWZ0RXllUHJvals3XSwgbGVmdEV5ZVByb2pbMTFdLCBsZWZ0RXllUHJvalsxNV0sXG4gICAgICAgICAgICAgICAgLy8gUmlnaHQgZXllIDR4NCB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICAgICAgICAgICAgcmlnaHRFeWVUcmFuc1swXSwgcmlnaHRFeWVUcmFuc1s0XSwgcmlnaHRFeWVUcmFuc1s4XSwgcmlnaHRFeWVUcmFuc1sxMl0sXG4gICAgICAgICAgICAgICAgcmlnaHRFeWVUcmFuc1sxXSwgcmlnaHRFeWVUcmFuc1s1XSwgcmlnaHRFeWVUcmFuc1s5XSwgcmlnaHRFeWVUcmFuc1sxM10sXG4gICAgICAgICAgICAgICAgcmlnaHRFeWVUcmFuc1syXSwgcmlnaHRFeWVUcmFuc1s2XSwgcmlnaHRFeWVUcmFuc1sxMF0sIHJpZ2h0RXllVHJhbnNbMTRdLFxuICAgICAgICAgICAgICAgIHJpZ2h0RXllVHJhbnNbM10sIHJpZ2h0RXllVHJhbnNbN10sIHJpZ2h0RXllVHJhbnNbMTFdLCByaWdodEV5ZVRyYW5zWzE1XSxcbiAgICAgICAgICAgICAgICAvLyByaWdodCBleWUgNHg0IHByb2plY3Rpb24gbWF0cml4XG4gICAgICAgICAgICAgICAgcmlnaHRFeWVQcm9qWzBdLCByaWdodEV5ZVByb2pbNF0sIHJpZ2h0RXllUHJvals4XSwgcmlnaHRFeWVQcm9qWzEyXSxcbiAgICAgICAgICAgICAgICByaWdodEV5ZVByb2pbMV0sIHJpZ2h0RXllUHJvals1XSwgcmlnaHRFeWVQcm9qWzldLCByaWdodEV5ZVByb2pbMTNdLFxuICAgICAgICAgICAgICAgIHJpZ2h0RXllUHJvalsyXSwgcmlnaHRFeWVQcm9qWzZdLCByaWdodEV5ZVByb2pbMTBdLCByaWdodEV5ZVByb2pbMTRdLFxuICAgICAgICAgICAgICAgIHJpZ2h0RXllUHJvalszXSwgcmlnaHRFeWVQcm9qWzddLCByaWdodEV5ZVByb2pbMTFdLCByaWdodEV5ZVByb2pbMTVdLFxuICAgICAgICAgICAgICAgIC8vIEhNRCA0eDQgdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbMF0sIGhtZFRyYW5zWzRdLCBobWRUcmFuc1s4XSwgaG1kVHJhbnNbMTJdLFxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzFdLCBobWRUcmFuc1s1XSwgaG1kVHJhbnNbOV0sIGhtZFRyYW5zWzEzXSxcbiAgICAgICAgICAgICAgICBobWRUcmFuc1syXSwgaG1kVHJhbnNbNl0sIGhtZFRyYW5zWzEwXSwgaG1kVHJhbnNbMTRdLFxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzNdLCBobWRUcmFuc1s3XSwgaG1kVHJhbnNbMTFdLCBobWRUcmFuc1sxNV0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFNlbnRMZWZ0RXllUHJvaiA9IGxlZnRFeWVQcm9qO1xuICAgICAgICAgICAgdGhpcy5sYXN0U2VudFJpZ2h0RXllUHJvaiA9IHJpZ2h0RXllUHJvajtcbiAgICAgICAgICAgIHRoaXMubGFzdFNlbnRSZWxhdGl2ZUxlZnRFeWVQb3MgPSBsZWZ0RXllUmVsYXRpdmVQb3M7XG4gICAgICAgICAgICB0aGlzLmxhc3RTZW50UmVsYXRpdmVSaWdodEV5ZVBvcyA9IHJpZ2h0RXllUmVsYXRpdmVQb3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBuZWVkIHRvIHRoZSBlbnRpcmUgZXllIHZpZXdzIGJlaW5nIHNlbnQganVzdCBzZW5kIHRoZSBITUQgdHJhbnNmb3JtXG4gICAgICAgICAgICB0aGlzLndlYlJ0Y0NvbnRyb2xsZXIuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnWFJITURUcmFuc2Zvcm0nKShbXG4gICAgICAgICAgICAgICAgLy8gSE1EIDR4NCB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICBobWRUcmFuc1swXSxcbiAgICAgICAgICAgICAgICBobWRUcmFuc1s0XSxcbiAgICAgICAgICAgICAgICBobWRUcmFuc1s4XSxcbiAgICAgICAgICAgICAgICBobWRUcmFuc1sxMl0sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbMV0sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbNV0sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbOV0sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbMTNdLFxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzJdLFxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzZdLFxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzEwXSxcbiAgICAgICAgICAgICAgICBobWRUcmFuc1sxNF0sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbM10sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbN10sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbMTFdLFxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzE1XVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25YckZyYW1lKHRpbWUsIGZyYW1lKSB7XG4gICAgICAgIHRoaXMueHJWaWV3ZXJQb3NlID0gZnJhbWUuZ2V0Vmlld2VyUG9zZSh0aGlzLnhyUmVmU3BhY2UpO1xuICAgICAgICBpZiAodGhpcy54clZpZXdlclBvc2UpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3MoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnRWaWV3ID09IG51bGwgfHwgdGhpcy5yaWdodFZpZXcgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VuZFhSRGF0YVRvVUUoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlkZW9UZXh0dXJlKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndlYlJ0Y0NvbnRyb2xsZXIuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuWFJDb250cm9sbGVySW5wdXQpKSB7XG4gICAgICAgICAgICB0aGlzLnhyU2Vzc2lvbi5pbnB1dFNvdXJjZXMuZm9yRWFjaCgoc291cmNlLCBfaW5kZXgsIF9hcnJheSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMueHJHYW1lcGFkQ29udHJvbGxlci51cGRhdGVTdGF0dXMoc291cmNlLCBmcmFtZSwgdGhpcy54clJlZlNwYWNlKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueHJTZXNzaW9uLnJlcXVlc3RBbmltYXRpb25GcmFtZSgodGltZSwgZnJhbWUpID0+IHRoaXMub25YckZyYW1lKHRpbWUsIGZyYW1lKSk7XG4gICAgICAgIHRoaXMub25GcmFtZS5kaXNwYXRjaEV2ZW50KG5ldyBYckZyYW1lRXZlbnQoeyB0aW1lLCBmcmFtZSB9KSk7XG4gICAgfVxuICAgIHVwZGF0ZVZpZXdzKCkge1xuICAgICAgICBpZiAoIXRoaXMueHJWaWV3ZXJQb3NlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2aWV3IG9mIHRoaXMueHJWaWV3ZXJQb3NlLnZpZXdzKSB7XG4gICAgICAgICAgICBpZiAodmlldy5leWUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMubGVmdFZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmlldy5leWUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0VmlldyA9IHZpZXc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2wpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBCaW5kIHRoZSBmcmFtZWJ1ZmZlciB0byB0aGUgYmFzZSBsYXllcidzIGZyYW1lYnVmZmVyXG4gICAgICAgIGNvbnN0IGdsTGF5ZXIgPSB0aGlzLnhyU2Vzc2lvbi5yZW5kZXJTdGF0ZS5iYXNlTGF5ZXI7XG4gICAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIGdsTGF5ZXIuZnJhbWVidWZmZXIpO1xuICAgICAgICAvLyBTZXQgdGhlIHJlbGV2YW50IHBvcnRpb24gb2YgY2xpcCBzcGFjZVxuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIGdsTGF5ZXIuZnJhbWVidWZmZXJXaWR0aCwgZ2xMYXllci5mcmFtZWJ1ZmZlckhlaWdodCk7XG4gICAgICAgIC8vIERyYXcgdGhlIHJlY3RhbmdsZSB3ZSB3aWxsIHNob3cgdGhlIHZpZGVvIHN0cmVhbSB0ZXh0dXJlIG9uXG4gICAgICAgIHRoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLlRSSUFOR0xFUyAvKnByaW1pdGl2ZVR5cGUqLywgMCAvKm9mZnNldCovLCA2IC8qY291bnQqLyk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1Nlc3Npb25TdXBwb3J0ZWQobW9kZSkge1xuICAgICAgICBpZiAobG9jYXRpb24ucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnV2ViWFIgcmVxdWlyZXMgaHR0cHMsIGlmIHlvdSB3YW50IFdlYlhSIHVzZSBodHRwcy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmF2aWdhdG9yLnhyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLnhyLmlzU2Vzc2lvblN1cHBvcnRlZChtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XZWJYUkNvbnRyb2xsZXIuanMubWFwIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbmltcG9ydCB7IENvbmZpZywgUGl4ZWxTdHJlYW1pbmcgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2Zyb250ZW5kLXVlNS42JztcblxuZG9jdW1lbnQuYm9keS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblxuXHQvLyBDcmVhdGUgYSBjb25maWcgb2JqZWN0XG5cdGNvbnN0IGNvbmZpZyA9IG5ldyBDb25maWcoe1xuXHRcdGluaXRpYWxTZXR0aW5nczoge1xuXHRcdFx0QXV0b1BsYXlWaWRlbzogdHJ1ZSxcblx0XHRcdEF1dG9Db25uZWN0OiB0cnVlLFxuXHRcdFx0U3RhcnRWaWRlb011dGVkOiB0cnVlLFxuXHRcdFx0V2FpdEZvclN0cmVhbWVyOiB0cnVlLFxuXHRcdH1cblx0fSk7XG5cblx0Ly8gQ3JlYXRlIGEgUGl4ZWxTdHJlYW1pbmcgaW5zdGFuY2UgYW5kIGF0dGFjaCB0aGUgdmlkZW8gZWxlbWVudCB0byBhbiBleGlzdGluZyBwYXJlbnQgZGl2XG5cdGNvbnN0IHBpeGVsU3RyZWFtaW5nID0gbmV3IFBpeGVsU3RyZWFtaW5nKGNvbmZpZywgeyB2aWRlb0VsZW1lbnRQYXJlbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidmlkZW9QYXJlbnRFbGVtZW50XCIpfSk7XG5cblx0Ly8gSWYgYnJvd3NlciBkZW5pZXMgYXV0b3BsYXksIHNob3cgXCJDbGljayB0byBwbGF5XCIgYW5kIHJlZ2lzdGVyIGEgY2xpY2stdG8tcGxheSBoYW5kbGVyXG5cdHBpeGVsU3RyZWFtaW5nLmFkZEV2ZW50TGlzdGVuZXIoXCJwbGF5U3RyZWFtUmVqZWN0ZWRcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGNsaWNrVG9QbGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjbGlja1RvUGxheUVsZW1lbnRcIik7XG5cdFx0Y2xpY2tUb1BsYXkuY2xhc3NOYW1lID0gXCJ2aXNpYmxlXCI7XG5cdFx0Y2xpY2tUb1BsYXkub25jbGljayA9ICgpID0+IHtcblx0XHRcdHBpeGVsU3RyZWFtaW5nLnBsYXkoKTtcblx0XHRcdGNsaWNrVG9QbGF5LmNsYXNzTmFtZSA9IFwiXCI7XG5cdFx0XHRjbGlja1RvUGxheS5vbmNsaWNrID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fSlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==