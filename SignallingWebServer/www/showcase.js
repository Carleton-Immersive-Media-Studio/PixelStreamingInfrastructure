(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["epicgames-frontend"] = factory();
	else
		root["epicgames-frontend"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../../../Common/dist/esm/Event/EventEmitter.js":
/*!******************************************************!*\
  !*** ../../../Common/dist/esm/Event/EventEmitter.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
// To match NodeJS' EventEmitter syntax without downstream code changes we need to use `any`.
// This means we need to disable linting `any` checks on this file.
//
/* eslint-disable @typescript-eslint/no-unsafe-argument */
class PixelStreamingEventListener {
    constructor(callback) {
        this._args = [];
        this._callback = callback;
    }
    handleEvent(_evt) {
        this._callback(...this._args);
        // Reset storage of args.
        this._args = [];
    }
    setArgs(...args) {
        this._args = args;
    }
}
/**
 * A feature-limited, but _mostly_ drop-in replacement for Node's EventEmitter type that is implemented using EventTarget.
 *
 * For those unfamiliar with Node's EventEmitter, here is some info from the official docs:
 *
 * [In NodeJS] all objects that emit events are instances of the `EventEmitter` class. These
 * objects expose an `eventEmitter.on()` function that allows one or more
 * functions to be attached to named events emitted by the object. Typically,
 * event names are camel-cased strings but any valid JavaScript property key
 * can be used.
 *
 * When the `EventEmitter` object emits an event, all of the functions attached
 * to that specific event are called _synchronously_. Any values returned by the
 * called listeners are _ignored_ and discarded.
 *
 * The following example shows a simple `EventEmitter` instance with a single
 * listener. The `eventEmitter.on()` method is used to register listeners, while
 * the `eventEmitter.emit()` method is used to trigger the event.
 *
 * ```js
 * import { EventEmitter } from 'node:events';
 *
 * class MyEmitter extends EventEmitter {}
 *
 * const myEmitter = new MyEmitter();
 * myEmitter.on('event', () => {
 *   console.log('an event occurred!');
 * });
 * myEmitter.emit('event');
 * ```
 */
class EventEmitter extends EventTarget {
    constructor() {
        super();
        this._eventListeners = new Map();
    }
    removeListenerInternal(eventName, listener) {
        if (this._eventListeners.has(eventName)) {
            const listeners = this._eventListeners.get(eventName);
            if (listeners === undefined) {
                return this;
            }
            for (let i = 0; i < listeners.length; ++i) {
                const eventPair = listeners[i];
                if (eventPair.callback === listener) {
                    // Remove from event target
                    super.removeEventListener(eventName, eventPair.eventListenerWrapper);
                    // Remove from our internal map
                    listeners.splice(i, 1);
                    break;
                }
            }
        }
        return this;
    }
    /**
     * Alias for `emitter.on(eventName, listener)`.
     */
    addListener(eventName, listener) {
        return this.on(eventName, listener);
    }
    /**
     * Adds the `listener` function to the end of the listeners array for the event
     * named `eventName`.
     *
     * ```js
     * server.on('connection', (stream) => {
     *   console.log('someone connected!');
     * });
     * ```
     *
     * Returns a reference to the `EventEmitter`, so that calls can be chained.
     *
     * @param eventName - The name of the event.
     * @param listener - The callback function
     */
    on(eventName, listener) {
        var _a;
        // Wrap our normal JS function in a event listener interface
        // so we can use it with event target.
        const eventListenerWrapper = new PixelStreamingEventListener(listener);
        super.addEventListener(eventName, eventListenerWrapper);
        // Store the event listener/function pair for later removal.
        if (!this._eventListeners.has(eventName)) {
            this._eventListeners.set(eventName, new Array());
        }
        (_a = this._eventListeners
            .get(eventName)) === null || _a === void 0 ? void 0 : _a.push({ callback: listener, eventListenerWrapper: eventListenerWrapper });
        return this;
    }
    /**
     * Adds a **one-time** `listener` function for the event named `eventName`. The
     * next time `eventName` is triggered, this listener is removed and then invoked.
     *
     * ```js
     * server.once('connection', (stream) => {
     *   console.log('Ah, we have our first user!');
     * });
     * ```
     *
     * Returns a reference to the `EventEmitter`, so that calls can be chained.
     * @param eventName - The name of the event.
     * @param listener - The callback function
     */
    once(eventName, listener) {
        var _a;
        // Pass options so this event callback is only called once
        const eventListenerOpts = { once: true };
        // Wrap our normal JS function in a event listener interface
        // so we can use it with event target and remove it from event target when this function completes.
        const eventListenerWrapper = new PixelStreamingEventListener((...args) => {
            listener(args);
            this.removeListenerInternal(eventName, listener);
        });
        super.addEventListener(eventName, eventListenerWrapper, eventListenerOpts);
        // Store the event listener/function pair for later removal.
        if (!this._eventListeners.has(eventName)) {
            this._eventListeners.set(eventName, new Array());
        }
        (_a = this._eventListeners
            .get(eventName)) === null || _a === void 0 ? void 0 : _a.push({ callback: listener, eventListenerWrapper: eventListenerWrapper });
        return this;
    }
    /**
     * Removes the specified `listener` from this EventEmitter.
     *
     * ```js
     * const callback = (stream) => {
     *   console.log('someone connected!');
     * };
     * server.on('connection', callback);
     * // ...
     * server.removeListener('connection', callback);
     * ```
     * Returns a reference to the `EventEmitter`, so that calls can be chained.
     */
    removeListener(eventName, listener) {
        this.removeListenerInternal(eventName, listener);
        return this;
    }
    /**
     * Alias for `emitter.removeListener()`.
     */
    off(eventName, listener) {
        return this.removeListener(eventName, listener);
    }
    /**
     * Removes all listeners, or those of the specified `eventName`.
     * Returns a reference to the `EventEmitter`, so that calls can be chained.
     */
    removeAllListeners(eventName) {
        if (this._eventListeners.has(eventName)) {
            const listeners = this._eventListeners.get(eventName);
            if (listeners === undefined) {
                return this;
            }
            // Remove each event listener from the event target
            for (const listenerPair of listeners) {
                this.removeEventListener(eventName, listenerPair.eventListenerWrapper);
            }
            // Remove all event listeners mapped to this event from our internal map
            this._eventListeners.delete(eventName);
        }
        return this;
    }
    /**
     * Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments
     * to each.
     *
     * Returns `true` if the event had listeners, `false` otherwise.
     *
     * ```js
     * import { EventEmitter } from 'node:events';
     * const myEmitter = new EventEmitter();
     *
     * // First listener
     * myEmitter.on('event', function firstListener() {
     *   console.log('Helloooo! first listener');
     * });
     * // Second listener
     * myEmitter.on('event', function secondListener(arg1, arg2) {
     *   console.log(`event with parameters ${arg1}, ${arg2} in second listener`);
     * });
     * // Third listener
     * myEmitter.on('event', function thirdListener(...args) {
     *   const parameters = args.join(', ');
     *   console.log(`event with parameters ${parameters} in third listener`);
     * });
     *
     * console.log(myEmitter.listeners('event'));
     *
     * myEmitter.emit('event', 1, 2, 3, 4, 5);
     *
     * // Prints:
     * // [
     * //   [Function: firstListener],
     * //   [Function: secondListener],
     * //   [Function: thirdListener]
     * // ]
     * // Helloooo! first listener
     * // event with parameters 1, 2 in second listener
     * // event with parameters 1, 2, 3, 4, 5 in third listener
     * ```
     */
    emit(eventName, ...args) {
        if (this._eventListeners.has(eventName)) {
            const listeners = this._eventListeners.get(eventName);
            if (listeners === undefined) {
                return false;
            }
            // Ensure each of our listeners have the args the callback injected
            for (const listenerPair of listeners) {
                listenerPair.eventListenerWrapper.setArgs(...args);
            }
            // Fire off the actual event
            super.dispatchEvent(new Event(eventName));
            return true;
        }
        return false;
    }
}
//# sourceMappingURL=EventEmitter.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Logger/Logger.js":
/*!*************************************************!*\
  !*** ../../../Common/dist/esm/Logger/Logger.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LogLevel: () => (/* binding */ LogLevel),
/* harmony export */   Logger: () => (/* binding */ Logger),
/* harmony export */   LoggerContext: () => (/* binding */ LoggerContext),
/* harmony export */   LoggerType: () => (/* binding */ LoggerType),
/* harmony export */   overrideLogger: () => (/* binding */ overrideLogger)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Disabled"] = 0] = "Disabled";
    LogLevel[LogLevel["Error"] = 1] = "Error";
    LogLevel[LogLevel["Warning"] = 2] = "Warning";
    LogLevel[LogLevel["Info"] = 3] = "Info";
    LogLevel[LogLevel["Debug"] = 4] = "Debug";
})(LogLevel || (LogLevel = {}));
/**
 * The global context for the logger configuration.
 * This cannot be stored statically in the Logger class because we sometimes have multiple execution
 * contexts, such as stats reporting. Instead we store the logger config context on the window object
 * to be shared with any Logger instances.
 */
class LoggerContext {
    constructor() {
        this.logLevel = LogLevel.Debug;
        this.includeStack = true;
    }
}
function overrideLogger(logger) {
    Logger = logger;
}
/**
 * A basic console logger utilized by the Pixel Streaming frontend to allow
 * logging to the browser console.
 */
class LoggerType {
    /**
     * Set the log verbosity level
     */
    InitLogging(logLevel, includeStack) {
        this.ValidateContext();
        this.context.logLevel = logLevel;
        this.context.includeStack = includeStack;
    }
    /**
     * Logging output for debugging
     * @param message - the message to be logged
     */
    Debug(message) {
        this.ValidateContext();
        if (this.context.logLevel >= LogLevel.Debug) {
            this.CommonLog('Debug', message);
        }
    }
    /**
     * Basic logging output for standard messages
     * @param message - the message to be logged
     */
    Info(message) {
        this.ValidateContext();
        if (this.context.logLevel >= LogLevel.Info) {
            this.CommonLog('Info', message);
        }
    }
    /**
     * Logging for warnings
     * @param message - the message to be logged
     */
    Warning(message) {
        this.ValidateContext();
        if (this.context.logLevel >= LogLevel.Warning) {
            this.CommonLog('Warning', message);
        }
    }
    /**
     * Error logging
     * @param message - the message to be logged
     */
    Error(message) {
        this.ValidateContext();
        if (this.context.logLevel >= LogLevel.Error) {
            this.CommonLog('Error', message);
        }
    }
    /**
     * The common log function that all other log functions call to.
     * @param level - the level of this log message.
     * @param stack - an optional stack trace string from where the log message was called.
     * @param message - the message to be logged.
     */
    CommonLog(level, message) {
        let logMessage = `[${level}] - ${message}`;
        if (this.context.includeStack) {
            logMessage += `\nStack: ${this.GetStackTrace()}`;
        }
        if (level === 'Error') {
            console.error(logMessage);
        }
        else if (level === 'Warning') {
            console.warn(logMessage);
        }
        else {
            console.log(logMessage);
        }
    }
    /**
     * Captures the stack and returns it
     * @returns the current stack
     */
    GetStackTrace() {
        const error = new Error();
        let formattedStack = 'No Stack Available for this browser';
        // format the error
        if (error.stack) {
            formattedStack = error.stack.toString().replace(/Error/g, '');
        }
        return formattedStack;
    }
    /**
     * Since there can be multiple execution contexts, (stats reporting and some webxr logging comes from
     * different execution contexts we can end up with multiple static Logger instances. Here we try to
     * work around it by storing the context on the window object.
     */
    ValidateContext() {
        if (!this.context) {
            if (typeof window == 'undefined' || !window) {
                // no window object so we can only store a local context.
                this.context = new LoggerContext();
            }
            else if (!window.loggerContext) {
                this.context = new LoggerContext();
                window.loggerContext = this.context;
            }
            else {
                this.context = window.loggerContext;
            }
        }
    }
}
let Logger = new LoggerType();
//# sourceMappingURL=Logger.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Messages/message_helpers.js":
/*!************************************************************!*\
  !*** ../../../Common/dist/esm/Messages/message_helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createMessage: () => (/* binding */ createMessage),
/* harmony export */   validateMessage: () => (/* binding */ validateMessage)
/* harmony export */ });
/* harmony import */ var _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Logger/Logger */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _message_registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./message_registry */ "../../../Common/dist/esm/Messages/message_registry.js");


/**
 * A helper for creating signalling messages. Takes in optional given parameters and
 * includes them in a message object with the 'type' field set properly for the message
 * type supplied.
 * @param messageType - A message type from MessageRegistry that indicates the type of message to create.
 * @param params - An optional object whose fields are added to the newly created message.
 * @returns The resulting message object.
 */
function createMessage(messageType, params) {
    const message = messageType.create();
    message.type = messageType.typeName;
    if (params) {
        messageType.mergePartial(message, params);
    }
    return message;
}
/**
 * Tests that the supplied message is valid. That is contains all expected fields and
 * doesn't contain any unknown fields.
 * @param msg - The message object to test.
 * @returns The message type from MessageRegistry of the supplied message object if it's valid, or null if invalid.
 */
function validateMessage(msg) {
    let valid = true;
    if (!msg.type) {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Parsed message has no type. Rejected. ${JSON.stringify(msg)}`);
        return null;
    }
    const messageType = _message_registry__WEBPACK_IMPORTED_MODULE_1__.MessageRegistry[msg.type];
    if (!messageType) {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Message is of an unknown type: "${msg.type}". Rejected.`);
        return null;
    }
    if (messageType.fields) {
        for (const field of messageType.fields) {
            if (!field.opt) {
                if (!Object.prototype.hasOwnProperty.call(msg, field.name)) {
                    _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Message "${msg.type}"" is missing required field "${field.name}". Rejected.`);
                    valid = false;
                }
            }
        }
    }
    for (const fieldName in msg) {
        const found = messageType.fields.find((field) => field.name === fieldName);
        if (!found) {
            _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Message "${msg.type}" contains unknown field "${fieldName}". Rejected.`);
            valid = false;
        }
    }
    return valid ? messageType : null;
}
//# sourceMappingURL=message_helpers.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Messages/message_registry.js":
/*!*************************************************************!*\
  !*** ../../../Common/dist/esm/Messages/message_registry.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MessageRegistry: () => (/* binding */ MessageRegistry)
/* harmony export */ });
/* harmony import */ var _signalling_messages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signalling_messages */ "../../../Common/dist/esm/Messages/signalling_messages.js");

/**
 * A map of all the supported signalling messages in the Pixel Streaming
 * signalling protocol. This allows mapping of signalling message names
 * to actual message types.
 */
const MessageRegistry = {
    answer: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.answer,
    config: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.config,
    disconnectPlayer: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.disconnectPlayer,
    endpointId: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.endpointId,
    endpointIdConfirm: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.endpointIdConfirm,
    iceCandidate: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.iceCandidate,
    identify: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.identify,
    listStreamers: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.listStreamers,
    offer: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.offer,
    ping: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.ping,
    playerConnected: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.playerConnected,
    playerCount: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.playerCount,
    playerDisconnected: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.playerDisconnected,
    pong: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.pong,
    stats: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.stats,
    streamerDisconnected: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.streamerDisconnected,
    streamerList: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.streamerList,
    subscribe: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.subscribe,
    unsubscribe: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.unsubscribe,
    layerPreference: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.layerPreference,
    dataChannelRequest: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.dataChannelRequest,
    peerDataChannels: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.peerDataChannels,
    peerDataChannelsReady: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.peerDataChannelsReady,
    streamerDataChannels: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.streamerDataChannels,
    startStreaming: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.startStreaming,
    stopStreaming: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.stopStreaming
};
//# sourceMappingURL=message_registry.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Messages/signalling_messages.js":
/*!****************************************************************!*\
  !*** ../../../Common/dist/esm/Messages/signalling_messages.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   answer: () => (/* binding */ answer),
/* harmony export */   base_message: () => (/* binding */ base_message),
/* harmony export */   config: () => (/* binding */ config),
/* harmony export */   dataChannelRequest: () => (/* binding */ dataChannelRequest),
/* harmony export */   disconnectPlayer: () => (/* binding */ disconnectPlayer),
/* harmony export */   endpointId: () => (/* binding */ endpointId),
/* harmony export */   endpointIdConfirm: () => (/* binding */ endpointIdConfirm),
/* harmony export */   iceCandidate: () => (/* binding */ iceCandidate),
/* harmony export */   iceCandidateData: () => (/* binding */ iceCandidateData),
/* harmony export */   identify: () => (/* binding */ identify),
/* harmony export */   layerPreference: () => (/* binding */ layerPreference),
/* harmony export */   listStreamers: () => (/* binding */ listStreamers),
/* harmony export */   offer: () => (/* binding */ offer),
/* harmony export */   peerConnectionOptions: () => (/* binding */ peerConnectionOptions),
/* harmony export */   peerDataChannels: () => (/* binding */ peerDataChannels),
/* harmony export */   peerDataChannelsReady: () => (/* binding */ peerDataChannelsReady),
/* harmony export */   ping: () => (/* binding */ ping),
/* harmony export */   playerConnected: () => (/* binding */ playerConnected),
/* harmony export */   playerCount: () => (/* binding */ playerCount),
/* harmony export */   playerDisconnected: () => (/* binding */ playerDisconnected),
/* harmony export */   pong: () => (/* binding */ pong),
/* harmony export */   startStreaming: () => (/* binding */ startStreaming),
/* harmony export */   stats: () => (/* binding */ stats),
/* harmony export */   stopStreaming: () => (/* binding */ stopStreaming),
/* harmony export */   streamerDataChannels: () => (/* binding */ streamerDataChannels),
/* harmony export */   streamerDisconnected: () => (/* binding */ streamerDisconnected),
/* harmony export */   streamerIdChanged: () => (/* binding */ streamerIdChanged),
/* harmony export */   streamerList: () => (/* binding */ streamerList),
/* harmony export */   subscribe: () => (/* binding */ subscribe),
/* harmony export */   subscribeFailed: () => (/* binding */ subscribeFailed),
/* harmony export */   unsubscribe: () => (/* binding */ unsubscribe)
/* harmony export */ });
/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @protobuf-ts/runtime */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js");
/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @protobuf-ts/runtime */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js");
/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @protobuf-ts/runtime */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type.js");




// @generated message type with reflection information, may provide speed optimized methods
class base_message$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("base_message", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base_message
 */
const base_message = new base_message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class peerConnectionOptions$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("peerConnectionOptions", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message peerConnectionOptions
 */
const peerConnectionOptions = new peerConnectionOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class config$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("config", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "peerConnectionOptions", kind: "message", T: () => peerConnectionOptions },
            { no: 3, name: "protocolVersion", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* peerConnectionOptions peerConnectionOptions */ 2:
                    message.peerConnectionOptions = peerConnectionOptions.internalBinaryRead(reader, reader.uint32(), options, message.peerConnectionOptions);
                    break;
                case /* optional string protocolVersion */ 3:
                    message.protocolVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* peerConnectionOptions peerConnectionOptions = 2; */
        if (message.peerConnectionOptions)
            peerConnectionOptions.internalBinaryWrite(message.peerConnectionOptions, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).fork(), options).join();
        /* optional string protocolVersion = 3; */
        if (message.protocolVersion !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.protocolVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message config
 */
const config = new config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class identify$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("identify", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message identify
 */
const identify = new identify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class endpointId$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("endpointId", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "protocolVersion", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.id = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* optional string protocolVersion */ 3:
                    message.protocolVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.id);
        /* optional string protocolVersion = 3; */
        if (message.protocolVersion !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.protocolVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message endpointId
 */
const endpointId = new endpointId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class endpointIdConfirm$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("endpointIdConfirm", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "committedId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.committedId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string committedId */ 2:
                    message.committedId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string committedId = 2; */
        if (message.committedId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.committedId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message endpointIdConfirm
 */
const endpointIdConfirm = new endpointIdConfirm$Type();
// @generated message type with reflection information, may provide speed optimized methods
class streamerIdChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("streamerIdChanged", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "newID", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.newID = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string newID */ 2:
                    message.newID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string newID = 2; */
        if (message.newID !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.newID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message streamerIdChanged
 */
const streamerIdChanged = new streamerIdChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class listStreamers$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("listStreamers", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message listStreamers
 */
const listStreamers = new listStreamers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class streamerList$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("streamerList", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.ids = [];
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* repeated string ids */ 2:
                    message.ids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* repeated string ids = 2; */
        for (let i = 0; i < message.ids.length; i++)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message streamerList
 */
const streamerList = new streamerList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class subscribe$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("subscribe", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "streamerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.streamerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string streamerId */ 2:
                    message.streamerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string streamerId = 2; */
        if (message.streamerId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.streamerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message subscribe
 */
const subscribe = new subscribe$Type();
// @generated message type with reflection information, may provide speed optimized methods
class unsubscribe$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("unsubscribe", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message unsubscribe
 */
const unsubscribe = new unsubscribe$Type();
// @generated message type with reflection information, may provide speed optimized methods
class subscribeFailed$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("subscribeFailed", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.message = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message subscribeFailed
 */
const subscribeFailed = new subscribeFailed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class playerConnected$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("playerConnected", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dataChannel", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "sfu", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.dataChannel = false;
        message.sfu = false;
        message.playerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* bool dataChannel */ 2:
                    message.dataChannel = reader.bool();
                    break;
                case /* bool sfu */ 3:
                    message.sfu = reader.bool();
                    break;
                case /* string playerId */ 5:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* bool dataChannel = 2; */
        if (message.dataChannel !== false)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).bool(message.dataChannel);
        /* bool sfu = 3; */
        if (message.sfu !== false)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).bool(message.sfu);
        /* string playerId = 5; */
        if (message.playerId !== "")
            writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message playerConnected
 */
const playerConnected = new playerConnected$Type();
// @generated message type with reflection information, may provide speed optimized methods
class playerDisconnected$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("playerDisconnected", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.playerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string playerId */ 2:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string playerId = 2; */
        if (message.playerId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message playerDisconnected
 */
const playerDisconnected = new playerDisconnected$Type();
// @generated message type with reflection information, may provide speed optimized methods
class offer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("offer", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sdp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "playerId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "sfu", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "multiplex", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "scalabilityMode", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.sdp = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string sdp */ 2:
                    message.sdp = reader.string();
                    break;
                case /* optional string playerId */ 3:
                    message.playerId = reader.string();
                    break;
                case /* optional bool sfu */ 4:
                    message.sfu = reader.bool();
                    break;
                case /* optional bool multiplex */ 5:
                    message.multiplex = reader.bool();
                    break;
                case /* optional string scalabilityMode */ 6:
                    message.scalabilityMode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string sdp = 2; */
        if (message.sdp !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.sdp);
        /* optional string playerId = 3; */
        if (message.playerId !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        /* optional bool sfu = 4; */
        if (message.sfu !== undefined)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).bool(message.sfu);
        /* optional bool multiplex = 5; */
        if (message.multiplex !== undefined)
            writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).bool(message.multiplex);
        /* optional string scalabilityMode = 6; */
        if (message.scalabilityMode !== undefined)
            writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.scalabilityMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offer
 */
const offer = new offer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class answer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("answer", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sdp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "playerId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "minBitrateBps", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "maxBitrateBps", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.sdp = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string sdp */ 2:
                    message.sdp = reader.string();
                    break;
                case /* optional string playerId */ 3:
                    message.playerId = reader.string();
                    break;
                case /* optional int32 minBitrateBps */ 4:
                    message.minBitrateBps = reader.int32();
                    break;
                case /* optional int32 maxBitrateBps */ 5:
                    message.maxBitrateBps = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string sdp = 2; */
        if (message.sdp !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.sdp);
        /* optional string playerId = 3; */
        if (message.playerId !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        /* optional int32 minBitrateBps = 4; */
        if (message.minBitrateBps !== undefined)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.minBitrateBps);
        /* optional int32 maxBitrateBps = 5; */
        if (message.maxBitrateBps !== undefined)
            writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.maxBitrateBps);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message answer
 */
const answer = new answer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class iceCandidateData$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("iceCandidateData", [
            { no: 1, name: "candidate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sdpMid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sdpMLineIndex", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "usernameFragment", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.candidate = "";
        message.sdpMid = "";
        message.sdpMLineIndex = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string candidate */ 1:
                    message.candidate = reader.string();
                    break;
                case /* string sdpMid */ 2:
                    message.sdpMid = reader.string();
                    break;
                case /* int32 sdpMLineIndex */ 3:
                    message.sdpMLineIndex = reader.int32();
                    break;
                case /* optional string usernameFragment */ 4:
                    message.usernameFragment = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string candidate = 1; */
        if (message.candidate !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.candidate);
        /* string sdpMid = 2; */
        if (message.sdpMid !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.sdpMid);
        /* int32 sdpMLineIndex = 3; */
        if (message.sdpMLineIndex !== 0)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.sdpMLineIndex);
        /* optional string usernameFragment = 4; */
        if (message.usernameFragment !== undefined)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.usernameFragment);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message iceCandidateData
 */
const iceCandidateData = new iceCandidateData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class iceCandidate$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("iceCandidate", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "candidate", kind: "message", T: () => iceCandidateData },
            { no: 3, name: "playerId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* iceCandidateData candidate */ 2:
                    message.candidate = iceCandidateData.internalBinaryRead(reader, reader.uint32(), options, message.candidate);
                    break;
                case /* optional string playerId */ 3:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* iceCandidateData candidate = 2; */
        if (message.candidate)
            iceCandidateData.internalBinaryWrite(message.candidate, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).fork(), options).join();
        /* optional string playerId = 3; */
        if (message.playerId !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message iceCandidate
 */
const iceCandidate = new iceCandidate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class disconnectPlayer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("disconnectPlayer", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reason", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.playerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string playerId */ 2:
                    message.playerId = reader.string();
                    break;
                case /* optional string reason */ 3:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string playerId = 2; */
        if (message.playerId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        /* optional string reason = 3; */
        if (message.reason !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message disconnectPlayer
 */
const disconnectPlayer = new disconnectPlayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ping$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("ping", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "time", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.time = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 time */ 2:
                    message.time = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* int32 time = 2; */
        if (message.time !== 0)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.time);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ping
 */
const ping = new ping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class pong$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("pong", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "time", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.time = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 time */ 2:
                    message.time = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* int32 time = 2; */
        if (message.time !== 0)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.time);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pong
 */
const pong = new pong$Type();
// @generated message type with reflection information, may provide speed optimized methods
class streamerDisconnected$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("streamerDisconnected", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message streamerDisconnected
 */
const streamerDisconnected = new streamerDisconnected$Type();
// @generated message type with reflection information, may provide speed optimized methods
class layerPreference$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("layerPreference", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "spatialLayer", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "temporalLayer", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.spatialLayer = 0;
        message.temporalLayer = 0;
        message.playerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 spatialLayer */ 2:
                    message.spatialLayer = reader.int32();
                    break;
                case /* int32 temporalLayer */ 3:
                    message.temporalLayer = reader.int32();
                    break;
                case /* string playerId */ 4:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* int32 spatialLayer = 2; */
        if (message.spatialLayer !== 0)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.spatialLayer);
        /* int32 temporalLayer = 3; */
        if (message.temporalLayer !== 0)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.temporalLayer);
        /* string playerId = 4; */
        if (message.playerId !== "")
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message layerPreference
 */
const layerPreference = new layerPreference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class dataChannelRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("dataChannelRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message dataChannelRequest
 */
const dataChannelRequest = new dataChannelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class peerDataChannels$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("peerDataChannels", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sendStreamId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "recvStreamId", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.playerId = "";
        message.sendStreamId = 0;
        message.recvStreamId = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string playerId */ 2:
                    message.playerId = reader.string();
                    break;
                case /* int32 sendStreamId */ 3:
                    message.sendStreamId = reader.int32();
                    break;
                case /* int32 recvStreamId */ 4:
                    message.recvStreamId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string playerId = 2; */
        if (message.playerId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        /* int32 sendStreamId = 3; */
        if (message.sendStreamId !== 0)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.sendStreamId);
        /* int32 recvStreamId = 4; */
        if (message.recvStreamId !== 0)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.recvStreamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message peerDataChannels
 */
const peerDataChannels = new peerDataChannels$Type();
// @generated message type with reflection information, may provide speed optimized methods
class peerDataChannelsReady$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("peerDataChannelsReady", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message peerDataChannelsReady
 */
const peerDataChannelsReady = new peerDataChannelsReady$Type();
// @generated message type with reflection information, may provide speed optimized methods
class streamerDataChannels$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("streamerDataChannels", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sfuId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sendStreamId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "recvStreamId", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.sfuId = "";
        message.sendStreamId = 0;
        message.recvStreamId = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string sfuId */ 2:
                    message.sfuId = reader.string();
                    break;
                case /* int32 sendStreamId */ 3:
                    message.sendStreamId = reader.int32();
                    break;
                case /* int32 recvStreamId */ 4:
                    message.recvStreamId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string sfuId = 2; */
        if (message.sfuId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.sfuId);
        /* int32 sendStreamId = 3; */
        if (message.sendStreamId !== 0)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.sendStreamId);
        /* int32 recvStreamId = 4; */
        if (message.recvStreamId !== 0)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.recvStreamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message streamerDataChannels
 */
const streamerDataChannels = new streamerDataChannels$Type();
// @generated message type with reflection information, may provide speed optimized methods
class startStreaming$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("startStreaming", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message startStreaming
 */
const startStreaming = new startStreaming$Type();
// @generated message type with reflection information, may provide speed optimized methods
class stopStreaming$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("stopStreaming", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stopStreaming
 */
const stopStreaming = new stopStreaming$Type();
// @generated message type with reflection information, may provide speed optimized methods
class playerCount$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("playerCount", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.count = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 count */ 2:
                    message.count = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* int32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message playerCount
 */
const playerCount = new playerCount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class stats$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("stats", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.data = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string data */ 2:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string data = 2; */
        if (message.data !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stats
 */
const stats = new stats$Type();
//# sourceMappingURL=signalling_messages.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Protocol/KeepaliveMonitor.js":
/*!*************************************************************!*\
  !*** ../../../Common/dist/esm/Protocol/KeepaliveMonitor.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeepaliveMonitor: () => (/* binding */ KeepaliveMonitor)
/* harmony export */ });
/* harmony import */ var _Messages_signalling_messages__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Messages/signalling_messages */ "../../../Common/dist/esm/Messages/signalling_messages.js");
/* harmony import */ var _Messages_message_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Messages/message_helpers */ "../../../Common/dist/esm/Messages/message_helpers.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * Used to regularly ping a protocol connection to make sure the connection is still good and open.
 * When the pong doesn't come in response to a ping in time a callback is fired that can be handed
 * by the owner.
 */
class KeepaliveMonitor {
    /**
     * Gets the Round Trip Time of the current connection in milliseconds.
     */
    get RTT() {
        return this.rtt;
    }
    /**
     * Creates a new monitor and starts the ping timer. If a pong does not come back by the time we want
     * to send a second ping then the connection is considered dead and the onTimeout callback is fired.
     * @param protocol - The connection that we want to monitor.
     * @param timeout - The time in milliseconds between ping messages.
     */
    constructor(protocol, timeout) {
        this.alive = false;
        this.rtt = 0;
        this.protocol = protocol;
        this.timeout = timeout;
        this.onResponse = this.onHeartbeatResponse.bind(this);
        this.protocol.transport.on('close', this.stop.bind(this));
        this.start();
    }
    start() {
        this.alive = true;
        this.protocol.on('pong', this.onResponse);
        this.keepalive = setInterval(this.sendHeartbeat.bind(this), this.timeout);
    }
    stop() {
        clearInterval(this.keepalive);
        this.protocol.off('pong', this.onResponse);
    }
    sendHeartbeat() {
        var _a;
        // if we never got a response from the last heartbeat, assume the connection is dead and timeout
        if (this.alive === false) {
            (_a = this.onTimeout) === null || _a === void 0 ? void 0 : _a.call(this);
            return;
        }
        // mark the connection as temporarily dead until we get a response from the ping
        this.alive = false;
        this.protocol.sendMessage(_Messages_message_helpers__WEBPACK_IMPORTED_MODULE_0__.createMessage(_Messages_signalling_messages__WEBPACK_IMPORTED_MODULE_1__.ping, { time: new Date().getTime() }));
    }
    onHeartbeatResponse(pongMsg) {
        // we got a pong response from the other side, the connection is good.
        // we also store the round trip time if anyone is curious
        this.rtt = new Date().getTime() - pongMsg.time;
        this.alive = true;
    }
}
//# sourceMappingURL=KeepaliveMonitor.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Protocol/SignallingProtocol.js":
/*!***************************************************************!*\
  !*** ../../../Common/dist/esm/Protocol/SignallingProtocol.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SignallingProtocol: () => (/* binding */ SignallingProtocol)
/* harmony export */ });
/* harmony import */ var _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Event/EventEmitter */ "../../../Common/dist/esm/Event/EventEmitter.js");
/* harmony import */ var _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Logger/Logger */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * Signalling protocol for handling messages from the signalling server.
 *
 * Listen on this emitter for messages. Message type is the name of the event to listen for.
 * Example:
 *      signallingProtocol.on('config', (message: Messages.config) =\> console.log(`Got a config message: ${message}`)));
 *
 * The transport in this class will also emit on message events.
 *
 * Events emitted on transport:
 *   message:
 *      Emitted any time a message is received by the transport. Listen on this if
 *      you wish to capture all messages, rather than specific messages on
 *      'messageHandlers'.
 *
 *   out:
 *      Emitted when sending a message out on the transport. Similar to 'message' but
 *      only for when messages are sent from this endpoint. Useful for debugging.
 */
class SignallingProtocol extends _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    static get SIGNALLING_VERSION() {
        return '1.3.0';
    }
    constructor(transport) {
        super();
        this.transport = transport;
        transport.onMessage = (msg) => {
            let parsedMessage;
            try {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                const parsedData = JSON.parse(msg);
                _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Debug('Protocol received => \n' + JSON.stringify(parsedData, undefined, 4));
                parsedMessage = parsedData;
            }
            catch (e) {
                if (e instanceof Error) {
                    _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`Error parsing message string ${msg}.\n${e.message}`);
                }
                else {
                    _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`Unknown error while parsing message data in handleOnMessage`);
                }
                return;
            }
            // call the handlers
            transport.emit('message', parsedMessage); // emit this for listeners listening to any message
            if (!this.emit(parsedMessage.type, parsedMessage)) {
                // emit this for listeners listening for specific messages
                // no listeners
                this.emit('unhandled', parsedMessage);
            }
        };
    }
    /**
     * Asks the transport to connect to the given URL.
     * @param url - The url to connect to.
     * @returns True if the connection call succeeded.
     */
    connect(url) {
        return this.transport.connect(url);
    }
    /**
     * Asks the transport to disconnect from any connection it might have.
     * @param code - An optional disconnection code.
     * @param reason - An optional descriptive string for the disconnect reason.
     */
    disconnect(code, reason) {
        this.transport.disconnect(code, reason);
    }
    /**
     * Returns true if the transport is connected and ready to send/receive messages.
     * @returns True if the protocol is connected.
     */
    isConnected() {
        return this.transport.isConnected();
    }
    /**
     * Passes a message to the transport to send to the other end.
     * @param msg - The message to send.
     */
    sendMessage(msg) {
        this.transport.sendMessage(JSON.stringify(msg));
        this.transport.emit('out', msg); // emit this for listeners listening to outgoing messages
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Debug('Protocol sent => \n' + JSON.stringify(msg, undefined, 4));
    }
}
//# sourceMappingURL=SignallingProtocol.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Transport/WebSocketTransport.js":
/*!****************************************************************!*\
  !*** ../../../Common/dist/esm/Transport/WebSocketTransport.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebSocketTransport: () => (/* binding */ WebSocketTransport)
/* harmony export */ });
/* harmony import */ var _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Logger/Logger */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Event/EventEmitter */ "../../../Common/dist/esm/Event/EventEmitter.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * The controller for the WebSocket and all associated methods
 */
class WebSocketTransport extends _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    /**
     * Constructs a new WebSocketTransport for browser contexts.
     * @param protocols - An optional string or list of strings to pass to the new websocket protocols param
     */
    constructor(protocols) {
        super();
        this.WS_OPEN_STATE = 1;
        this.protocols = protocols;
    }
    /**
     * Sends a message over the websocket.
     * @param msg - The message to send.
     */
    sendMessage(msg) {
        if (this.webSocket) {
            this.webSocket.send(msg);
        }
    }
    /**
     * Connect to the signaling server
     * @param connectionURL - The Address of the signaling server
     * @returns If there is a connection
     */
    connect(connectionURL) {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(connectionURL);
        try {
            this.webSocket = new WebSocket(connectionURL, this.protocols);
            this.webSocket.onopen = (_) => this.handleOnOpen();
            this.webSocket.onerror = (_) => this.handleOnError();
            this.webSocket.onclose = (event) => this.handleOnClose(event);
            this.webSocket.onmessage = (event) => this.handleOnMessage(event);
            this.webSocket.onmessagebinary = (event) => this.handleOnMessageBinary(event);
            return true;
        }
        catch (error) {
            _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(error);
            return false;
        }
    }
    /**
     * Disconnect this transport.
     * @param code - An optional disconnect code.
     * @param reason - A descriptive string for the disconnect reason.
     */
    disconnect(code, reason) {
        if (this.webSocket) {
            this.webSocket.close(code, reason);
        }
    }
    /**
     * Should return true when the transport is connected and ready to send/receive messages.
     * @returns True if the transport is connected.
     */
    isConnected() {
        return !!this.webSocket && this.webSocket.readyState != WebSocket.CLOSED;
    }
    /**
     * Handles what happens when a message is received in binary form
     * @param event - Message Received
     */
    handleOnMessageBinary(event) {
        // if the event is empty return
        if (!event || !event.data) {
            return;
        }
        // handle the binary and then handle the message
        event.data
            .text()
            .then((messageString) => {
            // build a new message
            const constructedMessage = new MessageEvent('messageFromBinary', {
                data: messageString
            });
            // send the new stringified event back into `onmessage`
            this.handleOnMessage(constructedMessage);
        })
            .catch((error) => {
            _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`Failed to parse binary blob from websocket, reason: ${error.message}`);
        });
    }
    /**
     * Handles what happens when a message is received
     * @param event - Message Received
     */
    handleOnMessage(event) {
        // Check if websocket message is binary, if so, stringify it.
        if (event.data && event.data instanceof Blob) {
            this.handleOnMessageBinary(event);
            return;
        }
        if (this.onMessage) {
            this.onMessage(event.data);
        }
    }
    /**
     * Handles when the Websocket is opened
     */
    handleOnOpen() {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Connected to the signalling server via WebSocket');
        this.emit('open');
    }
    /**
     * Handles when there is an error on the websocket
     */
    handleOnError() {
        //Logger.Error(Logger.GetStackTrace(), 'WebSocket error');
        this.emit('error');
    }
    /**
     * Handles when the Websocket is closed
     * @param event - Close Event
     */
    handleOnClose(event) {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Disconnected to the signalling server via WebSocket: ' +
            JSON.stringify(event.code) +
            ' - ' +
            event.reason);
        this.emit('close', event);
    }
}
//# sourceMappingURL=WebSocketTransport.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Util/SdpUtils.js":
/*!*************************************************!*\
  !*** ../../../Common/dist/esm/Util/SdpUtils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SDPUtils: () => (/* binding */ SDPUtils)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class SDPUtils {
    static addVideoHeaderExtensionToSdp(sdp, uri) {
        // Find the highest used header extension id by sorting the extension ids used,
        // eliminating duplicates and adding one.
        // Todo: Update this when WebRTC in Chrome supports the header extension API.
        const usedIds = sdp
            .split('\n')
            .filter((line) => line.startsWith('a=extmap:'))
            .map((line) => parseInt(line.split(' ')[0].substring(9), 10))
            .sort((a, b) => a - b)
            .filter((item, index, array) => array.indexOf(item) === index);
        const nextId = usedIds[usedIds.length - 1] + 1;
        const extmapLine = 'a=extmap:' + nextId + ' ' + uri + '\r\n';
        const sections = sdp.split('\nm=').map((part, index) => {
            return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
        });
        const sessionPart = sections.shift();
        // Only add extension to m=video media section
        return (sessionPart +
            sections
                .map((mediaSection) => mediaSection.startsWith('m=video') ? mediaSection + extmapLine : mediaSection)
                .join(''));
    }
}
//# sourceMappingURL=SdpUtils.js.map

/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!*********************************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _assertThisInitialized)
/* harmony export */ });
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}


/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!***********************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _createClass)
/* harmony export */ });
/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ "../../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js");

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}


/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/extends.js":
/*!*******************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _extends)
/* harmony export */ });
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}


/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _inheritsLoose)
/* harmony export */ });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ "../../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(t, o);
}


/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!****************************************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _objectWithoutPropertiesLoose)
/* harmony export */ });
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}


/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _setPrototypeOf)
/* harmony export */ });
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}


/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js":
/*!***********************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toPrimitive)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "../../../node_modules/@babel/runtime/helpers/esm/typeof.js");

function toPrimitive(t, r) {
  if ("object" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}


/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toPropertyKey)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "../../../node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPrimitive.js */ "../../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js");


function toPropertyKey(t) {
  var i = (0,_toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__["default"])(t, "string");
  return "symbol" == (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(i) ? i : i + "";
}


/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _typeof)
/* harmony export */ });
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assert: () => (/* binding */ assert),
/* harmony export */   assertFloat32: () => (/* binding */ assertFloat32),
/* harmony export */   assertInt32: () => (/* binding */ assertInt32),
/* harmony export */   assertNever: () => (/* binding */ assertNever),
/* harmony export */   assertUInt32: () => (/* binding */ assertUInt32)
/* harmony export */ });
/**
 * assert that condition is true or throw error (with message)
 */
function assert(condition, msg) {
    if (!condition) {
        throw new Error(msg);
    }
}
/**
 * assert that value cannot exist = type `never`. throw runtime error if it does.
 */
function assertNever(value, msg) {
    throw new Error(msg !== null && msg !== void 0 ? msg : 'Unexpected object: ' + value);
}
const FLOAT32_MAX = 3.4028234663852886e+38, FLOAT32_MIN = -3.4028234663852886e+38, UINT32_MAX = 0xFFFFFFFF, INT32_MAX = 0X7FFFFFFF, INT32_MIN = -0X80000000;
function assertInt32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid int 32: ' + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
        throw new Error('invalid int 32: ' + arg);
}
function assertUInt32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid uint 32: ' + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
        throw new Error('invalid uint 32: ' + arg);
}
function assertFloat32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid float 32: ' + typeof arg);
    if (!Number.isFinite(arg))
        return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
        throw new Error('invalid float 32: ' + arg);
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/base64.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/base64.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base64decode: () => (/* binding */ base64decode),
/* harmony export */   base64encode: () => (/* binding */ base64encode)
/* harmony export */ });
// lookup table from base64 character to byte
let encTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
// lookup table from base64 character *code* to byte because lookup by number is fast
let decTable = [];
for (let i = 0; i < encTable.length; i++)
    decTable[encTable[i].charCodeAt(0)] = i;
// support base64url variants
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
/**
 * Decodes a base64 string to a byte array.
 *
 * - ignores white-space, including line breaks and tabs
 * - allows inner padding (can decode concatenated base64 strings)
 * - does not require padding
 * - understands base64url encoding:
 *   "-" instead of "+",
 *   "_" instead of "/",
 *   no padding
 */
function base64decode(base64Str) {
    // estimate byte size, not accounting for inner padding and whitespace
    let es = base64Str.length * 3 / 4;
    // if (es % 3 !== 0)
    // throw new Error('invalid base64 string');
    if (base64Str[base64Str.length - 2] == '=')
        es -= 2;
    else if (base64Str[base64Str.length - 1] == '=')
        es -= 1;
    let bytes = new Uint8Array(es), bytePos = 0, // position in byte array
    groupPos = 0, // position in base64 group
    b, // current byte
    p = 0 // previous byte
    ;
    for (let i = 0; i < base64Str.length; i++) {
        b = decTable[base64Str.charCodeAt(i)];
        if (b === undefined) {
            // noinspection FallThroughInSwitchStatementJS
            switch (base64Str[i]) {
                case '=':
                    groupPos = 0; // reset state when padding found
                case '\n':
                case '\r':
                case '\t':
                case ' ':
                    continue; // skip white-space, and padding
                default:
                    throw Error(`invalid base64 string.`);
            }
        }
        switch (groupPos) {
            case 0:
                p = b;
                groupPos = 1;
                break;
            case 1:
                bytes[bytePos++] = p << 2 | (b & 48) >> 4;
                p = b;
                groupPos = 2;
                break;
            case 2:
                bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
                p = b;
                groupPos = 3;
                break;
            case 3:
                bytes[bytePos++] = (p & 3) << 6 | b;
                groupPos = 0;
                break;
        }
    }
    if (groupPos == 1)
        throw Error(`invalid base64 string.`);
    return bytes.subarray(0, bytePos);
}
/**
 * Encodes a byte array to a base64 string.
 * Adds padding at the end.
 * Does not insert newlines.
 */
function base64encode(bytes) {
    let base64 = '', groupPos = 0, // position in base64 group
    b, // current byte
    p = 0; // carry over from previous byte
    for (let i = 0; i < bytes.length; i++) {
        b = bytes[i];
        switch (groupPos) {
            case 0:
                base64 += encTable[b >> 2];
                p = (b & 3) << 4;
                groupPos = 1;
                break;
            case 1:
                base64 += encTable[p | b >> 4];
                p = (b & 15) << 2;
                groupPos = 2;
                break;
            case 2:
                base64 += encTable[p | b >> 6];
                base64 += encTable[b & 63];
                groupPos = 0;
                break;
        }
    }
    // padding required?
    if (groupPos) {
        base64 += encTable[p];
        base64 += '=';
        if (groupPos == 1)
            base64 += '=';
    }
    return base64;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnknownFieldHandler: () => (/* binding */ UnknownFieldHandler),
/* harmony export */   WireType: () => (/* binding */ WireType),
/* harmony export */   mergeBinaryOptions: () => (/* binding */ mergeBinaryOptions)
/* harmony export */ });
/**
 * This handler implements the default behaviour for unknown fields.
 * When reading data, unknown fields are stored on the message, in a
 * symbol property.
 * When writing data, the symbol property is queried and unknown fields
 * are serialized into the output again.
 */
var UnknownFieldHandler;
(function (UnknownFieldHandler) {
    /**
     * The symbol used to store unknown fields for a message.
     * The property must conform to `UnknownFieldContainer`.
     */
    UnknownFieldHandler.symbol = Symbol.for("protobuf-ts/unknown");
    /**
     * Store an unknown field during binary read directly on the message.
     * This method is compatible with `BinaryReadOptions.readUnknownField`.
     */
    UnknownFieldHandler.onRead = (typeName, message, fieldNo, wireType, data) => {
        let container = is(message) ? message[UnknownFieldHandler.symbol] : message[UnknownFieldHandler.symbol] = [];
        container.push({ no: fieldNo, wireType, data });
    };
    /**
     * Write unknown fields stored for the message to the writer.
     * This method is compatible with `BinaryWriteOptions.writeUnknownFields`.
     */
    UnknownFieldHandler.onWrite = (typeName, message, writer) => {
        for (let { no, wireType, data } of UnknownFieldHandler.list(message))
            writer.tag(no, wireType).raw(data);
    };
    /**
     * List unknown fields stored for the message.
     * Note that there may be multiples fields with the same number.
     */
    UnknownFieldHandler.list = (message, fieldNo) => {
        if (is(message)) {
            let all = message[UnknownFieldHandler.symbol];
            return fieldNo ? all.filter(uf => uf.no == fieldNo) : all;
        }
        return [];
    };
    /**
     * Returns the last unknown field by field number.
     */
    UnknownFieldHandler.last = (message, fieldNo) => UnknownFieldHandler.list(message, fieldNo).slice(-1)[0];
    const is = (message) => message && Array.isArray(message[UnknownFieldHandler.symbol]);
})(UnknownFieldHandler || (UnknownFieldHandler = {}));
/**
 * Merges binary write or read options. Later values override earlier values.
 */
function mergeBinaryOptions(a, b) {
    return Object.assign(Object.assign({}, a), b);
}
/**
 * Protobuf binary format wire types.
 *
 * A wire type provides just enough information to find the length of the
 * following value.
 *
 * See https://developers.google.com/protocol-buffers/docs/encoding#structure
 */
var WireType;
(function (WireType) {
    /**
     * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum
     */
    WireType[WireType["Varint"] = 0] = "Varint";
    /**
     * Used for fixed64, sfixed64, double.
     * Always 8 bytes with little-endian byte order.
     */
    WireType[WireType["Bit64"] = 1] = "Bit64";
    /**
     * Used for string, bytes, embedded messages, packed repeated fields
     *
     * Only repeated numeric types (types which use the varint, 32-bit,
     * or 64-bit wire types) can be packed. In proto3, such fields are
     * packed by default.
     */
    WireType[WireType["LengthDelimited"] = 2] = "LengthDelimited";
    /**
     * Used for groups
     * @deprecated
     */
    WireType[WireType["StartGroup"] = 3] = "StartGroup";
    /**
     * Used for groups
     * @deprecated
     */
    WireType[WireType["EndGroup"] = 4] = "EndGroup";
    /**
     * Used for fixed32, sfixed32, float.
     * Always 4 bytes with little-endian byte order.
     */
    WireType[WireType["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js":
/*!********************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BinaryReader: () => (/* binding */ BinaryReader),
/* harmony export */   binaryReadOptions: () => (/* binding */ binaryReadOptions)
/* harmony export */ });
/* harmony import */ var _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binary-format-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js");
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");
/* harmony import */ var _goog_varint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./goog-varint */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js");



const defaultsRead = {
    readUnknownField: true,
    readerFactory: bytes => new BinaryReader(bytes),
};
/**
 * Make options for reading binary data form partial options.
 */
function binaryReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
class BinaryReader {
    constructor(buf, textDecoder) {
        this.varint64 = _goog_varint__WEBPACK_IMPORTED_MODULE_0__.varint64read; // dirty cast for `this`
        /**
         * Read a `uint32` field, an unsigned 32 bit varint.
         */
        this.uint32 = _goog_varint__WEBPACK_IMPORTED_MODULE_0__.varint32read; // dirty cast for `this` and access to protected `buf`
        this.buf = buf;
        this.len = buf.length;
        this.pos = 0;
        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
            fatal: true,
            ignoreBOM: true,
        });
    }
    /**
     * Reads a tag - field number and wire type.
     */
    tag() {
        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5)
            throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [fieldNo, wireType];
    }
    /**
     * Skip one element on the wire and return the skipped data.
     * Supports WireType.StartGroup since v2.0.0-alpha.23.
     */
    skip(wireType) {
        let start = this.pos;
        // noinspection FallThroughInSwitchStatementJS
        switch (wireType) {
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.Varint:
                while (this.buf[this.pos++] & 0x80) {
                    // ignore
                }
                break;
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.Bit64:
                this.pos += 4;
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.Bit32:
                this.pos += 4;
                break;
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.LengthDelimited:
                let len = this.uint32();
                this.pos += len;
                break;
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.StartGroup:
                // From descriptor.proto: Group type is deprecated, not supported in proto3.
                // But we must still be able to parse and treat as unknown.
                let t;
                while ((t = this.tag()[1]) !== _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.EndGroup) {
                    this.skip(t);
                }
                break;
            default:
                throw new Error("cant skip wire type " + wireType);
        }
        this.assertBounds();
        return this.buf.subarray(start, this.pos);
    }
    /**
     * Throws error if position in byte array is out of range.
     */
    assertBounds() {
        if (this.pos > this.len)
            throw new RangeError("premature EOF");
    }
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */
    int32() {
        return this.uint32() | 0;
    }
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
    sint32() {
        let zze = this.uint32();
        // decode zigzag
        return (zze >>> 1) ^ -(zze & 1);
    }
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */
    int64() {
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong(...this.varint64());
    }
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */
    uint64() {
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong(...this.varint64());
    }
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64() {
        let [lo, hi] = this.varint64();
        // decode zig zag
        let s = -(lo & 1);
        lo = ((lo >>> 1 | (hi & 1) << 31) ^ s);
        hi = (hi >>> 1 ^ s);
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong(lo, hi);
    }
    /**
     * Read a `bool` field, a variant.
     */
    bool() {
        let [lo, hi] = this.varint64();
        return lo !== 0 || hi !== 0;
    }
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */
    fixed32() {
        return this.view.getUint32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */
    sfixed32() {
        return this.view.getInt32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */
    fixed64() {
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */
    sfixed64() {
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `float` field, 32-bit floating point number.
     */
    float() {
        return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `double` field, a 64-bit floating point number.
     */
    double() {
        return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */
    bytes() {
        let len = this.uint32();
        let start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
    }
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */
    string() {
        return this.textDecoder.decode(this.bytes());
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js":
/*!********************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BinaryWriter: () => (/* binding */ BinaryWriter),
/* harmony export */   binaryWriteOptions: () => (/* binding */ binaryWriteOptions)
/* harmony export */ });
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");
/* harmony import */ var _goog_varint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./goog-varint */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js");



const defaultsWrite = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter(),
};
/**
 * Make options for writing binary data form partial options.
 */
function binaryWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
class BinaryWriter {
    constructor(textEncoder) {
        /**
         * Previous fork states.
         */
        this.stack = [];
        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
        this.chunks = [];
        this.buf = [];
    }
    /**
     * Return all bytes written and reset this writer.
     */
    finish() {
        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer
        let len = 0;
        for (let i = 0; i < this.chunks.length; i++)
            len += this.chunks[i].length;
        let bytes = new Uint8Array(len);
        let offset = 0;
        for (let i = 0; i < this.chunks.length; i++) {
            bytes.set(this.chunks[i], offset);
            offset += this.chunks[i].length;
        }
        this.chunks = [];
        return bytes;
    }
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */
    fork() {
        this.stack.push({ chunks: this.chunks, buf: this.buf });
        this.chunks = [];
        this.buf = [];
        return this;
    }
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */
    join() {
        // get chunk of fork
        let chunk = this.finish();
        // restore previous state
        let prev = this.stack.pop();
        if (!prev)
            throw new Error('invalid state, fork stack empty');
        this.chunks = prev.chunks;
        this.buf = prev.buf;
        // write length of chunk as varint
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
    }
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */
    tag(fieldNo, type) {
        return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    /**
     * Write a chunk of raw bytes.
     */
    raw(chunk) {
        if (this.buf.length) {
            this.chunks.push(new Uint8Array(this.buf));
            this.buf = [];
        }
        this.chunks.push(chunk);
        return this;
    }
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */
    uint32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertUInt32)(value);
        // write value as varint 32, inlined for speed
        while (value > 0x7f) {
            this.buf.push((value & 0x7f) | 0x80);
            value = value >>> 7;
        }
        this.buf.push(value);
        return this;
    }
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */
    int32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertInt32)(value);
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint32write)(value, this.buf);
        return this;
    }
    /**
     * Write a `bool` value, a variant.
     */
    bool(value) {
        this.buf.push(value ? 1 : 0);
        return this;
    }
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */
    bytes(value) {
        this.uint32(value.byteLength); // write length of chunk as varint
        return this.raw(value);
    }
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */
    string(value) {
        let chunk = this.textEncoder.encode(value);
        this.uint32(chunk.byteLength); // write length of chunk as varint
        return this.raw(chunk);
    }
    /**
     * Write a `float` value, 32-bit floating point number.
     */
    float(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertFloat32)(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setFloat32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `double` value, a 64-bit floating point number.
     */
    double(value) {
        let chunk = new Uint8Array(8);
        new DataView(chunk.buffer).setFloat64(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */
    fixed32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertUInt32)(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setUint32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */
    sfixed32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertInt32)(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setInt32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */
    sint32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertInt32)(value);
        // zigzag encode
        value = ((value << 1) ^ (value >> 31)) >>> 0;
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint32write)(value, this.buf);
        return this;
    }
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */
    sfixed64(value) {
        let chunk = new Uint8Array(8);
        let view = new DataView(chunk.buffer);
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk);
    }
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */
    fixed64(value) {
        let chunk = new Uint8Array(8);
        let view = new DataView(chunk.buffer);
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong.from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk);
    }
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */
    int64(value) {
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.from(value);
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint64write)(long.lo, long.hi, this.buf);
        return this;
    }
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64(value) {
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.from(value), 
        // zigzag encode
        sign = long.hi >> 31, lo = (long.lo << 1) ^ sign, hi = ((long.hi << 1) | (long.lo >>> 31)) ^ sign;
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint64write)(lo, hi, this.buf);
        return this;
    }
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */
    uint64(value) {
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong.from(value);
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint64write)(long.lo, long.hi, this.buf);
        return this;
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   int64fromString: () => (/* binding */ int64fromString),
/* harmony export */   int64toString: () => (/* binding */ int64toString),
/* harmony export */   varint32read: () => (/* binding */ varint32read),
/* harmony export */   varint32write: () => (/* binding */ varint32write),
/* harmony export */   varint64read: () => (/* binding */ varint64read),
/* harmony export */   varint64write: () => (/* binding */ varint64write)
/* harmony export */ });
// Copyright 2008 Google Inc.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Code generated by the Protocol Buffer compiler is owned by the owner
// of the input file used when generating it.  This code is not
// standalone and requires a support library to be linked with it.  This
// support library is itself covered by the above license.
/**
 * Read a 64 bit varint as two JS numbers.
 *
 * Returns tuple:
 * [0]: low bits
 * [0]: high bits
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175
 */
function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
        let b = this.buf[this.pos++];
        lowBits |= (b & 0x7F) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [lowBits, highBits];
        }
    }
    let middleByte = this.buf[this.pos++];
    // last four bits of the first 32 bit number
    lowBits |= (middleByte & 0x0F) << 28;
    // 3 upper bits are part of the next 32 bit number
    highBits = (middleByte & 0x70) >> 4;
    if ((middleByte & 0x80) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
        let b = this.buf[this.pos++];
        highBits |= (b & 0x7F) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [lowBits, highBits];
        }
    }
    throw new Error('invalid varint');
}
/**
 * Write a 64 bit varint, given as two JS numbers, to the given bytes array.
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344
 */
function varint64write(lo, hi, bytes) {
    for (let i = 0; i < 28; i = i + 7) {
        const shift = lo >>> i;
        const hasNext = !((shift >>> 7) == 0 && hi == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    const splitBits = ((lo >>> 28) & 0x0F) | ((hi & 0x07) << 4);
    const hasMoreBits = !((hi >> 3) == 0);
    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xFF);
    if (!hasMoreBits) {
        return;
    }
    for (let i = 3; i < 31; i = i + 7) {
        const shift = hi >>> i;
        const hasNext = !((shift >>> 7) == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    bytes.push((hi >>> 31) & 0x01);
}
// constants for binary math
const TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
/**
 * Parse decimal string of 64 bit integer value as two JS numbers.
 *
 * Returns tuple:
 * [0]: minus sign?
 * [1]: low bits
 * [2]: high bits
 *
 * Copyright 2008 Google Inc.
 */
function int64fromString(dec) {
    // Check for minus sign.
    let minus = dec[0] == '-';
    if (minus)
        dec = dec.slice(1);
    // Work 6 decimal digits at a time, acting like we're converting base 1e6
    // digits to binary. This is safe to do with floating point math because
    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
        // Note: Number('') is 0.
        const digit1e6 = Number(dec.slice(begin, end));
        highBits *= base;
        lowBits = lowBits * base + digit1e6;
        // Carry bits from lowBits to highBits
        if (lowBits >= TWO_PWR_32_DBL) {
            highBits = highBits + ((lowBits / TWO_PWR_32_DBL) | 0);
            lowBits = lowBits % TWO_PWR_32_DBL;
        }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return [minus, lowBits, highBits];
}
/**
 * Format 64 bit integer value (as two JS numbers) to decimal string.
 *
 * Copyright 2008 Google Inc.
 */
function int64toString(bitsLow, bitsHigh) {
    // Skip the expensive conversion if the number is small enough to use the
    // built-in conversions.
    if ((bitsHigh >>> 0) <= 0x1FFFFF) {
        return '' + (TWO_PWR_32_DBL * bitsHigh + (bitsLow >>> 0));
    }
    // What this code is doing is essentially converting the input number from
    // base-2 to base-1e7, which allows us to represent the 64-bit range with
    // only 3 (very large) digits. Those digits are then trivial to convert to
    // a base-10 string.
    // The magic numbers used here are -
    // 2^24 = 16777216 = (1,6777216) in base-1e7.
    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.
    // Split 32:32 representation into 16:24:24 representation so our
    // intermediate digits don't overflow.
    let low = bitsLow & 0xFFFFFF;
    let mid = (((bitsLow >>> 24) | (bitsHigh << 8)) >>> 0) & 0xFFFFFF;
    let high = (bitsHigh >> 16) & 0xFFFF;
    // Assemble our three base-1e7 digits, ignoring carries. The maximum
    // value in a digit at this step is representable as a 48-bit integer, which
    // can be stored in a 64-bit floating point number.
    let digitA = low + (mid * 6777216) + (high * 6710656);
    let digitB = mid + (high * 8147497);
    let digitC = (high * 2);
    // Apply carries from A to B and from B to C.
    let base = 10000000;
    if (digitA >= base) {
        digitB += Math.floor(digitA / base);
        digitA %= base;
    }
    if (digitB >= base) {
        digitC += Math.floor(digitB / base);
        digitB %= base;
    }
    // Convert base-1e7 digits to base-10, with optional leading zeroes.
    function decimalFrom1e7(digit1e7, needLeadingZeros) {
        let partial = digit1e7 ? String(digit1e7) : '';
        if (needLeadingZeros) {
            return '0000000'.slice(partial.length) + partial;
        }
        return partial;
    }
    return decimalFrom1e7(digitC, /*needLeadingZeros=*/ 0) +
        decimalFrom1e7(digitB, /*needLeadingZeros=*/ digitC) +
        // If the final 1e7 digit didn't need leading zeros, we would have
        // returned via the trivial code path at the top.
        decimalFrom1e7(digitA, /*needLeadingZeros=*/ 1);
}
/**
 * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144
 */
function varint32write(value, bytes) {
    if (value >= 0) {
        // write value as varint 32
        while (value > 0x7f) {
            bytes.push((value & 0x7f) | 0x80);
            value = value >>> 7;
        }
        bytes.push(value);
    }
    else {
        for (let i = 0; i < 9; i++) {
            bytes.push(value & 127 | 128);
            value = value >> 7;
        }
        bytes.push(1);
    }
}
/**
 * Read an unsigned 32 bit varint.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220
 */
function varint32read() {
    let b = this.buf[this.pos++];
    let result = b & 0x7F;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 7;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 14;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 21;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    // Extract only last 4 bits
    b = this.buf[this.pos++];
    result |= (b & 0x0F) << 28;
    for (let readBytes = 5; ((b & 0x80) !== 0) && readBytes < 10; readBytes++)
        b = this.buf[this.pos++];
    if ((b & 0x80) != 0)
        throw new Error('invalid varint');
    this.assertBounds();
    // Result can have 32 bits, convert it to unsigned
    return result >>> 0;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js":
/*!***************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   jsonReadOptions: () => (/* binding */ jsonReadOptions),
/* harmony export */   jsonWriteOptions: () => (/* binding */ jsonWriteOptions),
/* harmony export */   mergeJsonOptions: () => (/* binding */ mergeJsonOptions)
/* harmony export */ });
const defaultsWrite = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0,
}, defaultsRead = {
    ignoreUnknownFields: false,
};
/**
 * Make options for reading JSON data from partial options.
 */
function jsonReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
/**
 * Make options for writing JSON data from partial options.
 */
function jsonWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
/**
 * Merges JSON write or read options. Later values override earlier values. Type registries are merged.
 */
function mergeJsonOptions(a, b) {
    var _a, _b;
    let c = Object.assign(Object.assign({}, a), b);
    c.typeRegistry = [...((_a = a === null || a === void 0 ? void 0 : a.typeRegistry) !== null && _a !== void 0 ? _a : []), ...((_b = b === null || b === void 0 ? void 0 : b.typeRegistry) !== null && _b !== void 0 ? _b : [])];
    return c;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js":
/*!*******************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),
/* harmony export */   typeofJsonValue: () => (/* binding */ typeofJsonValue)
/* harmony export */ });
/**
 * Get the type of a JSON value.
 * Distinguishes between array, null and object.
 */
function typeofJsonValue(value) {
    let t = typeof value;
    if (t == "object") {
        if (Array.isArray(value))
            return "array";
        if (value === null)
            return "null";
    }
    return t;
}
/**
 * Is this a JSON object (instead of an array or null)?
 */
function isJsonObject(value) {
    return value !== null && typeof value == "object" && !Array.isArray(value);
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lowerCamelCase: () => (/* binding */ lowerCamelCase)
/* harmony export */ });
/**
 * Converts snake_case to lowerCamelCase.
 *
 * Should behave like protoc:
 * https://github.com/protocolbuffers/protobuf/blob/e8ae137c96444ea313485ed1118c5e43b2099cf1/src/google/protobuf/compiler/java/java_helpers.cc#L118
 */
function lowerCamelCase(snakeCase) {
    let capNext = false;
    const sb = [];
    for (let i = 0; i < snakeCase.length; i++) {
        let next = snakeCase.charAt(i);
        if (next == '_') {
            capNext = true;
        }
        else if (/\d/.test(next)) {
            sb.push(next);
            capNext = true;
        }
        else if (capNext) {
            sb.push(next.toUpperCase());
            capNext = false;
        }
        else if (i == 0) {
            sb.push(next.toLowerCase());
        }
        else {
            sb.push(next);
        }
    }
    return sb.join('');
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js":
/*!****************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MESSAGE_TYPE: () => (/* binding */ MESSAGE_TYPE)
/* harmony export */ });
/**
 * The symbol used as a key on message objects to store the message type.
 *
 * Note that this is an experimental feature - it is here to stay, but
 * implementation details may change without notice.
 */
const MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type.js":
/*!*******************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MessageType: () => (/* binding */ MessageType)
/* harmony export */ });
/* harmony import */ var _message_type_contract__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./message-type-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js");
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _reflection_type_check__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reflection-type-check */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js");
/* harmony import */ var _reflection_json_reader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reflection-json-reader */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js");
/* harmony import */ var _reflection_json_writer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reflection-json-writer */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js");
/* harmony import */ var _reflection_binary_reader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./reflection-binary-reader */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js");
/* harmony import */ var _reflection_binary_writer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./reflection-binary-writer */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js");
/* harmony import */ var _reflection_create__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./reflection-create */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js");
/* harmony import */ var _reflection_merge_partial__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./reflection-merge-partial */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js");
/* harmony import */ var _json_typings__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./json-typings */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js");
/* harmony import */ var _json_format_contract__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./json-format-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js");
/* harmony import */ var _reflection_equals__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./reflection-equals */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js");
/* harmony import */ var _binary_writer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./binary-writer */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js");
/* harmony import */ var _binary_reader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./binary-reader */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js");














const baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
/**
 * This standard message type provides reflection-based
 * operations to work with a message.
 */
class MessageType {
    constructor(name, fields, options) {
        this.defaultCheckDepth = 16;
        this.typeName = name;
        this.fields = fields.map(_reflection_info__WEBPACK_IMPORTED_MODULE_0__.normalizeFieldInfo);
        this.options = options !== null && options !== void 0 ? options : {};
        this.messagePrototype = Object.create(null, Object.assign(Object.assign({}, baseDescriptors), { [_message_type_contract__WEBPACK_IMPORTED_MODULE_1__.MESSAGE_TYPE]: { value: this } }));
        this.refTypeCheck = new _reflection_type_check__WEBPACK_IMPORTED_MODULE_2__.ReflectionTypeCheck(this);
        this.refJsonReader = new _reflection_json_reader__WEBPACK_IMPORTED_MODULE_3__.ReflectionJsonReader(this);
        this.refJsonWriter = new _reflection_json_writer__WEBPACK_IMPORTED_MODULE_4__.ReflectionJsonWriter(this);
        this.refBinReader = new _reflection_binary_reader__WEBPACK_IMPORTED_MODULE_5__.ReflectionBinaryReader(this);
        this.refBinWriter = new _reflection_binary_writer__WEBPACK_IMPORTED_MODULE_6__.ReflectionBinaryWriter(this);
    }
    create(value) {
        let message = (0,_reflection_create__WEBPACK_IMPORTED_MODULE_7__.reflectionCreate)(this);
        if (value !== undefined) {
            (0,_reflection_merge_partial__WEBPACK_IMPORTED_MODULE_8__.reflectionMergePartial)(this, message, value);
        }
        return message;
    }
    /**
     * Clone the message.
     *
     * Unknown fields are discarded.
     */
    clone(message) {
        let copy = this.create();
        (0,_reflection_merge_partial__WEBPACK_IMPORTED_MODULE_8__.reflectionMergePartial)(this, copy, message);
        return copy;
    }
    /**
     * Determines whether two message of the same type have the same field values.
     * Checks for deep equality, traversing repeated fields, oneof groups, maps
     * and messages recursively.
     * Will also return true if both messages are `undefined`.
     */
    equals(a, b) {
        return (0,_reflection_equals__WEBPACK_IMPORTED_MODULE_9__.reflectionEquals)(this, a, b);
    }
    /**
     * Is the given value assignable to our message type
     * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */
    is(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, false);
    }
    /**
     * Is the given value assignable to our message type,
     * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */
    isAssignable(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, true);
    }
    /**
     * Copy partial data into the target message.
     */
    mergePartial(target, source) {
        (0,_reflection_merge_partial__WEBPACK_IMPORTED_MODULE_8__.reflectionMergePartial)(this, target, source);
    }
    /**
     * Create a new message from binary format.
     */
    fromBinary(data, options) {
        let opt = (0,_binary_reader__WEBPACK_IMPORTED_MODULE_10__.binaryReadOptions)(options);
        return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
    }
    /**
     * Read a new message from a JSON value.
     */
    fromJson(json, options) {
        return this.internalJsonRead(json, (0,_json_format_contract__WEBPACK_IMPORTED_MODULE_11__.jsonReadOptions)(options));
    }
    /**
     * Read a new message from a JSON string.
     * This is equivalent to `T.fromJson(JSON.parse(json))`.
     */
    fromJsonString(json, options) {
        let value = JSON.parse(json);
        return this.fromJson(value, options);
    }
    /**
     * Write the message to canonical JSON value.
     */
    toJson(message, options) {
        return this.internalJsonWrite(message, (0,_json_format_contract__WEBPACK_IMPORTED_MODULE_11__.jsonWriteOptions)(options));
    }
    /**
     * Convert the message to canonical JSON string.
     * This is equivalent to `JSON.stringify(T.toJson(t))`
     */
    toJsonString(message, options) {
        var _a;
        let value = this.toJson(message, options);
        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
    }
    /**
     * Write the message to binary format.
     */
    toBinary(message, options) {
        let opt = (0,_binary_writer__WEBPACK_IMPORTED_MODULE_12__.binaryWriteOptions)(options);
        return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
    }
    /**
     * This is an internal method. If you just want to read a message from
     * JSON, use `fromJson()` or `fromJsonString()`.
     *
     * Reads JSON value and merges the fields into the target
     * according to protobuf rules. If the target is omitted,
     * a new instance is created first.
     */
    internalJsonRead(json, options, target) {
        if (json !== null && typeof json == "object" && !Array.isArray(json)) {
            let message = target !== null && target !== void 0 ? target : this.create();
            this.refJsonReader.read(json, message, options);
            return message;
        }
        throw new Error(`Unable to parse message ${this.typeName} from JSON ${(0,_json_typings__WEBPACK_IMPORTED_MODULE_13__.typeofJsonValue)(json)}.`);
    }
    /**
     * This is an internal method. If you just want to write a message
     * to JSON, use `toJson()` or `toJsonString().
     *
     * Writes JSON value and returns it.
     */
    internalJsonWrite(message, options) {
        return this.refJsonWriter.write(message, options);
    }
    /**
     * This is an internal method. If you just want to write a message
     * in binary format, use `toBinary()`.
     *
     * Serializes the message in binary format and appends it to the given
     * writer. Returns passed writer.
     */
    internalBinaryWrite(message, writer, options) {
        this.refBinWriter.write(message, writer, options);
        return writer;
    }
    /**
     * This is an internal method. If you just want to read a message from
     * binary data, use `fromBinary()`.
     *
     * Reads data from binary format and merges the fields into
     * the target according to protobuf rules. If the target is
     * omitted, a new instance is created first.
     */
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create();
        this.refBinReader.read(reader, message, options, length);
        return message;
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/oneof.js":
/*!************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/oneof.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clearOneofValue: () => (/* binding */ clearOneofValue),
/* harmony export */   getOneofValue: () => (/* binding */ getOneofValue),
/* harmony export */   getSelectedOneofValue: () => (/* binding */ getSelectedOneofValue),
/* harmony export */   isOneofGroup: () => (/* binding */ isOneofGroup),
/* harmony export */   setOneofValue: () => (/* binding */ setOneofValue),
/* harmony export */   setUnknownOneofValue: () => (/* binding */ setUnknownOneofValue)
/* harmony export */ });
/**
 * Is the given value a valid oneof group?
 *
 * We represent protobuf `oneof` as algebraic data types (ADT) in generated
 * code. But when working with messages of unknown type, the ADT does not
 * help us.
 *
 * This type guard checks if the given object adheres to the ADT rules, which
 * are as follows:
 *
 * 1) Must be an object.
 *
 * 2) Must have a "oneofKind" discriminator property.
 *
 * 3) If "oneofKind" is `undefined`, no member field is selected. The object
 * must not have any other properties.
 *
 * 4) If "oneofKind" is a `string`, the member field with this name is
 * selected.
 *
 * 5) If a member field is selected, the object must have a second property
 * with this name. The property must not be `undefined`.
 *
 * 6) No extra properties are allowed. The object has either one property
 * (no selection) or two properties (selection).
 *
 */
function isOneofGroup(any) {
    if (typeof any != 'object' || any === null || !any.hasOwnProperty('oneofKind')) {
        return false;
    }
    switch (typeof any.oneofKind) {
        case "string":
            if (any[any.oneofKind] === undefined)
                return false;
            return Object.keys(any).length == 2;
        case "undefined":
            return Object.keys(any).length == 1;
        default:
            return false;
    }
}
/**
 * Returns the value of the given field in a oneof group.
 */
function getOneofValue(oneof, kind) {
    return oneof[kind];
}
function setOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== undefined) {
        delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = kind;
    if (value !== undefined) {
        oneof[kind] = value;
    }
}
function setUnknownOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== undefined) {
        delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = kind;
    if (value !== undefined && kind !== undefined) {
        oneof[kind] = value;
    }
}
/**
 * Removes the selected field in a oneof group.
 *
 * Note that the recommended way to modify a oneof group is to set
 * a new object:
 *
 * ```ts
 * message.result = { oneofKind: undefined };
 * ```
 */
function clearOneofValue(oneof) {
    if (oneof.oneofKind !== undefined) {
        delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = undefined;
}
/**
 * Returns the selected value of the given oneof group.
 *
 * Not that the recommended way to access a oneof group is to check
 * the "oneofKind" property and let TypeScript narrow down the union
 * type for you:
 *
 * ```ts
 * if (message.result.oneofKind === "error") {
 *   message.result.error; // string
 * }
 * ```
 *
 * In the rare case you just need the value, and do not care about
 * which protobuf field is selected, you can use this function
 * for convenience.
 */
function getSelectedOneofValue(oneof) {
    if (oneof.oneofKind === undefined) {
        return undefined;
    }
    return oneof[oneof.oneofKind];
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PbLong: () => (/* binding */ PbLong),
/* harmony export */   PbULong: () => (/* binding */ PbULong),
/* harmony export */   detectBi: () => (/* binding */ detectBi)
/* harmony export */ });
/* harmony import */ var _goog_varint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./goog-varint */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js");

let BI;
function detectBi() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = globalThis.BigInt !== undefined
        && typeof dv.getBigInt64 === "function"
        && typeof dv.getBigUint64 === "function"
        && typeof dv.setBigInt64 === "function"
        && typeof dv.setBigUint64 === "function";
    BI = ok ? {
        MIN: BigInt("-9223372036854775808"),
        MAX: BigInt("9223372036854775807"),
        UMIN: BigInt("0"),
        UMAX: BigInt("18446744073709551615"),
        C: BigInt,
        V: dv,
    } : undefined;
}
detectBi();
function assertBi(bi) {
    if (!bi)
        throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
// used to validate from(string) input (when bigint is unavailable)
const RE_DECIMAL_STR = /^-?[0-9]+$/;
// constants for binary math
const TWO_PWR_32_DBL = 0x100000000;
const HALF_2_PWR_32 = 0x080000000;
// base class for PbLong and PbULong provides shared code
class SharedPbLong {
    /**
     * Create a new instance with the given bits.
     */
    constructor(lo, hi) {
        this.lo = lo | 0;
        this.hi = hi | 0;
    }
    /**
     * Is this instance equal to 0?
     */
    isZero() {
        return this.lo == 0 && this.hi == 0;
    }
    /**
     * Convert to a native number.
     */
    toNumber() {
        let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);
        if (!Number.isSafeInteger(result))
            throw new Error("cannot convert to safe number");
        return result;
    }
}
/**
 * 64-bit unsigned integer as two 32-bit values.
 * Converts between `string`, `number` and `bigint` representations.
 */
class PbULong extends SharedPbLong {
    /**
     * Create instance from a `string`, `number` or `bigint`.
     */
    static from(value) {
        if (BI)
            // noinspection FallThroughInSwitchStatementJS
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    if (value == "")
                        throw new Error('string is no integer');
                    value = BI.C(value);
                case "number":
                    if (value === 0)
                        return this.ZERO;
                    value = BI.C(value);
                case "bigint":
                    if (!value)
                        return this.ZERO;
                    if (value < BI.UMIN)
                        throw new Error('signed value for ulong');
                    if (value > BI.UMAX)
                        throw new Error('ulong too large');
                    BI.V.setBigUint64(0, value, true);
                    return new PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
            }
        else
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    value = value.trim();
                    if (!RE_DECIMAL_STR.test(value))
                        throw new Error('string is no integer');
                    let [minus, lo, hi] = (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64fromString)(value);
                    if (minus)
                        throw new Error('signed value for ulong');
                    return new PbULong(lo, hi);
                case "number":
                    if (value == 0)
                        return this.ZERO;
                    if (!Number.isSafeInteger(value))
                        throw new Error('number is no integer');
                    if (value < 0)
                        throw new Error('signed value for ulong');
                    return new PbULong(value, value / TWO_PWR_32_DBL);
            }
        throw new Error('unknown value ' + typeof value);
    }
    /**
     * Convert to decimal string.
     */
    toString() {
        return BI ? this.toBigInt().toString() : (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64toString)(this.lo, this.hi);
    }
    /**
     * Convert to native bigint.
     */
    toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigUint64(0, true);
    }
}
/**
 * ulong 0 singleton.
 */
PbULong.ZERO = new PbULong(0, 0);
/**
 * 64-bit signed integer as two 32-bit values.
 * Converts between `string`, `number` and `bigint` representations.
 */
class PbLong extends SharedPbLong {
    /**
     * Create instance from a `string`, `number` or `bigint`.
     */
    static from(value) {
        if (BI)
            // noinspection FallThroughInSwitchStatementJS
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    if (value == "")
                        throw new Error('string is no integer');
                    value = BI.C(value);
                case "number":
                    if (value === 0)
                        return this.ZERO;
                    value = BI.C(value);
                case "bigint":
                    if (!value)
                        return this.ZERO;
                    if (value < BI.MIN)
                        throw new Error('signed long too small');
                    if (value > BI.MAX)
                        throw new Error('signed long too large');
                    BI.V.setBigInt64(0, value, true);
                    return new PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
            }
        else
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    value = value.trim();
                    if (!RE_DECIMAL_STR.test(value))
                        throw new Error('string is no integer');
                    let [minus, lo, hi] = (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64fromString)(value);
                    if (minus) {
                        if (hi > HALF_2_PWR_32 || (hi == HALF_2_PWR_32 && lo != 0))
                            throw new Error('signed long too small');
                    }
                    else if (hi >= HALF_2_PWR_32)
                        throw new Error('signed long too large');
                    let pbl = new PbLong(lo, hi);
                    return minus ? pbl.negate() : pbl;
                case "number":
                    if (value == 0)
                        return this.ZERO;
                    if (!Number.isSafeInteger(value))
                        throw new Error('number is no integer');
                    return value > 0
                        ? new PbLong(value, value / TWO_PWR_32_DBL)
                        : new PbLong(-value, -value / TWO_PWR_32_DBL).negate();
            }
        throw new Error('unknown value ' + typeof value);
    }
    /**
     * Do we have a minus sign?
     */
    isNegative() {
        return (this.hi & HALF_2_PWR_32) !== 0;
    }
    /**
     * Negate two's complement.
     * Invert all the bits and add one to the result.
     */
    negate() {
        let hi = ~this.hi, lo = this.lo;
        if (lo)
            lo = ~lo + 1;
        else
            hi += 1;
        return new PbLong(lo, hi);
    }
    /**
     * Convert to decimal string.
     */
    toString() {
        if (BI)
            return this.toBigInt().toString();
        if (this.isNegative()) {
            let n = this.negate();
            return '-' + (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64toString)(n.lo, n.hi);
        }
        return (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64toString)(this.lo, this.hi);
    }
    /**
     * Convert to native bigint.
     */
    toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigInt64(0, true);
    }
}
/**
 * long 0 singleton.
 */
PbLong.ZERO = new PbLong(0, 0);


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReflectionBinaryReader: () => (/* binding */ ReflectionBinaryReader)
/* harmony export */ });
/* harmony import */ var _binary_format_contract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binary-format-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js");
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reflection-long-convert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js");
/* harmony import */ var _reflection_scalar_default__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reflection-scalar-default */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js");




/**
 * Reads proto3 messages in binary format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/encoding
 */
class ReflectionBinaryReader {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        var _a;
        if (!this.fieldNoToField) {
            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
            this.fieldNoToField = new Map(fieldsInput.map(field => [field.no, field]));
        }
    }
    /**
     * Reads a message from binary format into the target message.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    read(reader, message, options, length) {
        this.prepare();
        const end = length === undefined ? reader.len : reader.pos + length;
        while (reader.pos < end) {
            // read the tag and find the field
            const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
            if (!field) {
                let u = options.readUnknownField;
                if (u == "throw")
                    throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
                let d = reader.skip(wireType);
                if (u !== false)
                    (u === true ? _binary_format_contract__WEBPACK_IMPORTED_MODULE_0__.UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);
                continue;
            }
            // target object for the field we are reading
            let target = message, repeated = field.repeat, localName = field.localName;
            // if field is member of oneof ADT, use ADT as target
            if (field.oneof) {
                target = target[field.oneof];
                // if other oneof member selected, set new ADT
                if (target.oneofKind !== localName)
                    target = message[field.oneof] = {
                        oneofKind: localName
                    };
            }
            // we have handled oneof above, we just have read the value into `target[localName]`
            switch (field.kind) {
                case "scalar":
                case "enum":
                    let T = field.kind == "enum" ? _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32 : field.T;
                    let L = field.kind == "scalar" ? field.L : undefined;
                    if (repeated) {
                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                        if (wireType == _binary_format_contract__WEBPACK_IMPORTED_MODULE_0__.WireType.LengthDelimited && T != _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING && T != _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES) {
                            let e = reader.uint32() + reader.pos;
                            while (reader.pos < e)
                                arr.push(this.scalar(reader, T, L));
                        }
                        else
                            arr.push(this.scalar(reader, T, L));
                    }
                    else
                        target[localName] = this.scalar(reader, T, L);
                    break;
                case "message":
                    if (repeated) {
                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                        let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
                        arr.push(msg);
                    }
                    else
                        target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
                    break;
                case "map":
                    let [mapKey, mapVal] = this.mapEntry(field, reader, options);
                    // safe to assume presence of map object, oneof cannot contain repeated values
                    target[localName][mapKey] = mapVal;
                    break;
            }
        }
    }
    /**
     * Read a map field, expecting key field = 1, value field = 2
     */
    mapEntry(field, reader, options) {
        let length = reader.uint32();
        let end = reader.pos + length;
        let key = undefined; // javascript only allows number or string for object properties
        let val = undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    if (field.K == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL)
                        key = reader.bool().toString();
                    else
                        // long types are read as string, number types are okay as number
                        key = this.scalar(reader, field.K, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.STRING);
                    break;
                case 2:
                    switch (field.V.kind) {
                        case "scalar":
                            val = this.scalar(reader, field.V.T, field.V.L);
                            break;
                        case "enum":
                            val = reader.int32();
                            break;
                        case "message":
                            val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
                            break;
                    }
                    break;
                default:
                    throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
            }
        }
        if (key === undefined) {
            let keyRaw = (0,_reflection_scalar_default__WEBPACK_IMPORTED_MODULE_2__.reflectionScalarDefault)(field.K);
            key = field.K == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL ? keyRaw.toString() : keyRaw;
        }
        if (val === undefined)
            switch (field.V.kind) {
                case "scalar":
                    val = (0,_reflection_scalar_default__WEBPACK_IMPORTED_MODULE_2__.reflectionScalarDefault)(field.V.T, field.V.L);
                    break;
                case "enum":
                    val = 0;
                    break;
                case "message":
                    val = field.V.T().create();
                    break;
            }
        return [key, val];
    }
    scalar(reader, type, longType) {
        switch (type) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32:
                return reader.int32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING:
                return reader.string();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                return reader.bool();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.DOUBLE:
                return reader.double();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT:
                return reader.float();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.int64(), longType);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.uint64(), longType);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.fixed64(), longType);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED32:
                return reader.fixed32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES:
                return reader.bytes();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32:
                return reader.uint32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED32:
                return reader.sfixed32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.sfixed64(), longType);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT32:
                return reader.sint32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.sint64(), longType);
        }
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReflectionBinaryWriter: () => (/* binding */ ReflectionBinaryWriter)
/* harmony export */ });
/* harmony import */ var _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./binary-format-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js");
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js");
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");




/**
 * Writes proto3 messages in binary format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/encoding
 */
class ReflectionBinaryWriter {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        if (!this.fields) {
            const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
            this.fields = fieldsInput.sort((a, b) => a.no - b.no);
        }
    }
    /**
     * Writes the message to binary format.
     */
    write(message, writer, options) {
        this.prepare();
        for (const field of this.fields) {
            let value, // this will be our field value, whether it is member of a oneof or not
            emitDefault, // whether we emit the default value (only true for oneof members)
            repeated = field.repeat, localName = field.localName;
            // handle oneof ADT
            if (field.oneof) {
                const group = message[field.oneof];
                if (group.oneofKind !== localName)
                    continue; // if field is not selected, skip
                value = group[localName];
                emitDefault = true;
            }
            else {
                value = message[localName];
                emitDefault = false;
            }
            // we have handled oneof above. we just have to honor `emitDefault`.
            switch (field.kind) {
                case "scalar":
                case "enum":
                    let T = field.kind == "enum" ? _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32 : field.T;
                    if (repeated) {
                        (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(Array.isArray(value));
                        if (repeated == _reflection_info__WEBPACK_IMPORTED_MODULE_0__.RepeatType.PACKED)
                            this.packed(writer, T, field.no, value);
                        else
                            for (const item of value)
                                this.scalar(writer, T, field.no, item, true);
                    }
                    else if (value === undefined)
                        (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(field.opt);
                    else
                        this.scalar(writer, T, field.no, value, emitDefault || field.opt);
                    break;
                case "message":
                    if (repeated) {
                        (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(Array.isArray(value));
                        for (const item of value)
                            this.message(writer, options, field.T(), field.no, item);
                    }
                    else {
                        this.message(writer, options, field.T(), field.no, value);
                    }
                    break;
                case "map":
                    (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof value == 'object' && value !== null);
                    for (const [key, val] of Object.entries(value))
                        this.mapEntry(writer, options, field, key, val);
                    break;
            }
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);
    }
    mapEntry(writer, options, field, key, value) {
        writer.tag(field.no, _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited);
        writer.fork();
        // javascript only allows number or string for object properties
        // we convert from our representation to the protobuf type
        let keyValue = key;
        switch (field.K) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.UINT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SFIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SINT32:
                keyValue = Number.parseInt(key);
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BOOL:
                (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(key == 'true' || key == 'false');
                keyValue = key == 'true';
                break;
        }
        // write key, expecting key field number = 1
        this.scalar(writer, field.K, 1, keyValue, true);
        // write value, expecting value field number = 2
        switch (field.V.kind) {
            case 'scalar':
                this.scalar(writer, field.V.T, 2, value, true);
                break;
            case 'enum':
                this.scalar(writer, _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32, 2, value, true);
                break;
            case 'message':
                this.message(writer, options, field.V.T(), 2, value);
                break;
        }
        writer.join();
    }
    message(writer, options, handler, fieldNo, value) {
        if (value === undefined)
            return;
        handler.internalBinaryWrite(value, writer.tag(fieldNo, _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).fork(), options);
        writer.join();
    }
    /**
     * Write a single scalar value.
     */
    scalar(writer, type, fieldNo, value, emitDefault) {
        let [wireType, method, isDefault] = this.scalarInfo(type, value);
        if (!isDefault || emitDefault) {
            writer.tag(fieldNo, wireType);
            writer[method](value);
        }
    }
    /**
     * Write an array of scalar values in packed format.
     */
    packed(writer, type, fieldNo, value) {
        if (!value.length)
            return;
        (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(type !== _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BYTES && type !== _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.STRING);
        // write tag
        writer.tag(fieldNo, _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited);
        // begin length-delimited
        writer.fork();
        // write values without tags
        let [, method,] = this.scalarInfo(type);
        for (let i = 0; i < value.length; i++)
            writer[method](value[i]);
        // end length delimited
        writer.join();
    }
    /**
     * Get information for writing a scalar value.
     *
     * Returns tuple:
     * [0]: appropriate WireType
     * [1]: name of the appropriate method of IBinaryWriter
     * [2]: whether the given value is a default value
     *
     * If argument `value` is omitted, [2] is always false.
     */
    scalarInfo(type, value) {
        let t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint;
        let m;
        let i = value === undefined;
        let d = value === 0;
        switch (type) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32:
                m = "int32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.STRING:
                d = i || !value.length;
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited;
                m = "string";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BOOL:
                d = value === false;
                m = "bool";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.UINT32:
                m = "uint32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.DOUBLE:
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit64;
                m = "double";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FLOAT:
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit32;
                m = "float";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbLong.from(value).isZero();
                m = "int64";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.UINT64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbULong.from(value).isZero();
                m = "uint64";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FIXED64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbULong.from(value).isZero();
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit64;
                m = "fixed64";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BYTES:
                d = i || !value.byteLength;
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited;
                m = "bytes";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FIXED32:
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit32;
                m = "fixed32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SFIXED32:
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit32;
                m = "sfixed32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SFIXED64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbLong.from(value).isZero();
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit64;
                m = "sfixed64";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SINT32:
                m = "sint32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SINT64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbLong.from(value).isZero();
                m = "sint64";
                break;
        }
        return [t, m, i || d];
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reflectionCreate: () => (/* binding */ reflectionCreate)
/* harmony export */ });
/* harmony import */ var _reflection_scalar_default__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-scalar-default */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js");
/* harmony import */ var _message_type_contract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./message-type-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js");


/**
 * Creates an instance of the generic message, using the field
 * information.
 */
function reflectionCreate(type) {
    /**
     * This ternary can be removed in the next major version.
     * The `Object.create()` code path utilizes a new `messagePrototype`
     * property on the `IMessageType` which has this same `MESSAGE_TYPE`
     * non-enumerable property on it. Doing it this way means that we only
     * pay the cost of `Object.defineProperty()` once per `IMessageType`
     * class of once per "instance". The falsy code path is only provided
     * for backwards compatibility in cases where the runtime library is
     * updated without also updating the generated code.
     */
    const msg = type.messagePrototype
        ? Object.create(type.messagePrototype)
        : Object.defineProperty({}, _message_type_contract__WEBPACK_IMPORTED_MODULE_0__.MESSAGE_TYPE, { value: type });
    for (let field of type.fields) {
        let name = field.localName;
        if (field.opt)
            continue;
        if (field.oneof)
            msg[field.oneof] = { oneofKind: undefined };
        else if (field.repeat)
            msg[name] = [];
        else
            switch (field.kind) {
                case "scalar":
                    msg[name] = (0,_reflection_scalar_default__WEBPACK_IMPORTED_MODULE_1__.reflectionScalarDefault)(field.T, field.L);
                    break;
                case "enum":
                    // we require 0 to be default value for all enums
                    msg[name] = 0;
                    break;
                case "map":
                    msg[name] = {};
                    break;
            }
    }
    return msg;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reflectionEquals: () => (/* binding */ reflectionEquals)
/* harmony export */ });
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");

/**
 * Determines whether two message of the same type have the same field values.
 * Checks for deep equality, traversing repeated fields, oneof groups, maps
 * and messages recursively.
 * Will also return true if both messages are `undefined`.
 */
function reflectionEquals(info, a, b) {
    if (a === b)
        return true;
    if (!a || !b)
        return false;
    for (let field of info.fields) {
        let localName = field.localName;
        let val_a = field.oneof ? a[field.oneof][localName] : a[localName];
        let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
        switch (field.kind) {
            case "enum":
            case "scalar":
                let t = field.kind == "enum" ? _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32 : field.T;
                if (!(field.repeat
                    ? repeatedPrimitiveEq(t, val_a, val_b)
                    : primitiveEq(t, val_a, val_b)))
                    return false;
                break;
            case "map":
                if (!(field.V.kind == "message"
                    ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b))
                    : repeatedPrimitiveEq(field.V.kind == "enum" ? _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
                    return false;
                break;
            case "message":
                let T = field.T();
                if (!(field.repeat
                    ? repeatedMsgEq(T, val_a, val_b)
                    : T.equals(val_a, val_b)))
                    return false;
                break;
        }
    }
    return true;
}
const objectValues = Object.values;
function primitiveEq(type, a, b) {
    if (a === b)
        return true;
    if (type !== _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BYTES)
        return false;
    let ba = a;
    let bb = b;
    if (ba.length !== bb.length)
        return false;
    for (let i = 0; i < ba.length; i++)
        if (ba[i] != bb[i])
            return false;
    return true;
}
function repeatedPrimitiveEq(type, a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!primitiveEq(type, a[i], b[i]))
            return false;
    return true;
}
function repeatedMsgEq(type, a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!type.equals(a[i], b[i]))
            return false;
    return true;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LongType: () => (/* binding */ LongType),
/* harmony export */   RepeatType: () => (/* binding */ RepeatType),
/* harmony export */   ScalarType: () => (/* binding */ ScalarType),
/* harmony export */   normalizeFieldInfo: () => (/* binding */ normalizeFieldInfo),
/* harmony export */   readFieldOption: () => (/* binding */ readFieldOption),
/* harmony export */   readFieldOptions: () => (/* binding */ readFieldOptions),
/* harmony export */   readMessageOption: () => (/* binding */ readMessageOption)
/* harmony export */ });
/* harmony import */ var _lower_camel_case__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lower-camel-case */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js");

/**
 * Scalar value types. This is a subset of field types declared by protobuf
 * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE
 * are omitted, but the numerical values are identical.
 */
var ScalarType;
(function (ScalarType) {
    // 0 is reserved for errors.
    // Order is weird for historical reasons.
    ScalarType[ScalarType["DOUBLE"] = 1] = "DOUBLE";
    ScalarType[ScalarType["FLOAT"] = 2] = "FLOAT";
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
    // negative values are likely.
    ScalarType[ScalarType["INT64"] = 3] = "INT64";
    ScalarType[ScalarType["UINT64"] = 4] = "UINT64";
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
    // negative values are likely.
    ScalarType[ScalarType["INT32"] = 5] = "INT32";
    ScalarType[ScalarType["FIXED64"] = 6] = "FIXED64";
    ScalarType[ScalarType["FIXED32"] = 7] = "FIXED32";
    ScalarType[ScalarType["BOOL"] = 8] = "BOOL";
    ScalarType[ScalarType["STRING"] = 9] = "STRING";
    // Tag-delimited aggregate.
    // Group type is deprecated and not supported in proto3. However, Proto3
    // implementations should still be able to parse the group wire format and
    // treat group fields as unknown fields.
    // TYPE_GROUP = 10,
    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.
    // New in version 2.
    ScalarType[ScalarType["BYTES"] = 12] = "BYTES";
    ScalarType[ScalarType["UINT32"] = 13] = "UINT32";
    // TYPE_ENUM = 14,
    ScalarType[ScalarType["SFIXED32"] = 15] = "SFIXED32";
    ScalarType[ScalarType["SFIXED64"] = 16] = "SFIXED64";
    ScalarType[ScalarType["SINT32"] = 17] = "SINT32";
    ScalarType[ScalarType["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
/**
 * JavaScript representation of 64 bit integral types. Equivalent to the
 * field option "jstype".
 *
 * By default, protobuf-ts represents 64 bit types as `bigint`.
 *
 * You can change the default behaviour by enabling the plugin parameter
 * `long_type_string`, which will represent 64 bit types as `string`.
 *
 * Alternatively, you can change the behaviour for individual fields
 * with the field option "jstype":
 *
 * ```protobuf
 * uint64 my_field = 1 [jstype = JS_STRING];
 * uint64 other_field = 2 [jstype = JS_NUMBER];
 * ```
 */
var LongType;
(function (LongType) {
    /**
     * Use JavaScript `bigint`.
     *
     * Field option `[jstype = JS_NORMAL]`.
     */
    LongType[LongType["BIGINT"] = 0] = "BIGINT";
    /**
     * Use JavaScript `string`.
     *
     * Field option `[jstype = JS_STRING]`.
     */
    LongType[LongType["STRING"] = 1] = "STRING";
    /**
     * Use JavaScript `number`.
     *
     * Large values will loose precision.
     *
     * Field option `[jstype = JS_NUMBER]`.
     */
    LongType[LongType["NUMBER"] = 2] = "NUMBER";
})(LongType || (LongType = {}));
/**
 * Protobuf 2.1.0 introduced packed repeated fields.
 * Setting the field option `[packed = true]` enables packing.
 *
 * In proto3, all repeated fields are packed by default.
 * Setting the field option `[packed = false]` disables packing.
 *
 * Packed repeated fields are encoded with a single tag,
 * then a length-delimiter, then the element values.
 *
 * Unpacked repeated fields are encoded with a tag and
 * value for each element.
 *
 * `bytes` and `string` cannot be packed.
 */
var RepeatType;
(function (RepeatType) {
    /**
     * The field is not repeated.
     */
    RepeatType[RepeatType["NO"] = 0] = "NO";
    /**
     * The field is repeated and should be packed.
     * Invalid for `bytes` and `string`, they cannot be packed.
     */
    RepeatType[RepeatType["PACKED"] = 1] = "PACKED";
    /**
     * The field is repeated but should not be packed.
     * The only valid repeat type for repeated `bytes` and `string`.
     */
    RepeatType[RepeatType["UNPACKED"] = 2] = "UNPACKED";
})(RepeatType || (RepeatType = {}));
/**
 * Turns PartialFieldInfo into FieldInfo.
 */
function normalizeFieldInfo(field) {
    var _a, _b, _c, _d;
    field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : (0,_lower_camel_case__WEBPACK_IMPORTED_MODULE_0__.lowerCamelCase)(field.name);
    field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : (0,_lower_camel_case__WEBPACK_IMPORTED_MODULE_0__.lowerCamelCase)(field.name);
    field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;
    field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : (field.repeat ? false : field.oneof ? false : field.kind == "message");
    return field;
}
/**
 * Read custom field options from a generated message type.
 *
 * @deprecated use readFieldOption()
 */
function readFieldOptions(messageType, fieldName, extensionName, extensionType) {
    var _a;
    const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
    return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : undefined;
}
function readFieldOption(messageType, fieldName, extensionName, extensionType) {
    var _a;
    const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
    if (!options) {
        return undefined;
    }
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
        return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
function readMessageOption(messageType, extensionName, extensionType) {
    const options = messageType.options;
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
        return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReflectionJsonReader: () => (/* binding */ ReflectionJsonReader)
/* harmony export */ });
/* harmony import */ var _json_typings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./json-typings */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js");
/* harmony import */ var _base64__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base64 */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/base64.js");
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js");
/* harmony import */ var _reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reflection-long-convert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js");






/**
 * Reads proto3 messages in canonical JSON format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/proto3#json
 */
class ReflectionJsonReader {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        var _a;
        if (this.fMap === undefined) {
            this.fMap = {};
            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
            for (const field of fieldsInput) {
                this.fMap[field.name] = field;
                this.fMap[field.jsonName] = field;
                this.fMap[field.localName] = field;
            }
        }
    }
    // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
    assert(condition, fieldName, jsonValue) {
        if (!condition) {
            let what = (0,_json_typings__WEBPACK_IMPORTED_MODULE_0__.typeofJsonValue)(jsonValue);
            if (what == "number" || what == "boolean")
                what = jsonValue.toString();
            throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
        }
    }
    /**
     * Reads a message from canonical JSON format into the target message.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    read(input, message, options) {
        this.prepare();
        const oneofsHandled = [];
        for (const [jsonKey, jsonValue] of Object.entries(input)) {
            const field = this.fMap[jsonKey];
            if (!field) {
                if (!options.ignoreUnknownFields)
                    throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
                continue;
            }
            const localName = field.localName;
            // handle oneof ADT
            let target; // this will be the target for the field value, whether it is member of a oneof or not
            if (field.oneof) {
                if (jsonValue === null && (field.kind !== 'enum' || field.T()[0] !== 'google.protobuf.NullValue')) {
                    continue;
                }
                // since json objects are unordered by specification, it is not possible to take the last of multiple oneofs
                if (oneofsHandled.includes(field.oneof))
                    throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
                oneofsHandled.push(field.oneof);
                target = message[field.oneof] = {
                    oneofKind: localName
                };
            }
            else {
                target = message;
            }
            // we have handled oneof above. we just have read the value into `target`.
            if (field.kind == 'map') {
                if (jsonValue === null) {
                    continue;
                }
                // check input
                this.assert((0,_json_typings__WEBPACK_IMPORTED_MODULE_0__.isJsonObject)(jsonValue), field.name, jsonValue);
                // our target to put map entries into
                const fieldObj = target[localName];
                // read entries
                for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
                    this.assert(jsonObjValue !== null, field.name + " map value", null);
                    // read value
                    let val;
                    switch (field.V.kind) {
                        case "message":
                            val = field.V.T().internalJsonRead(jsonObjValue, options);
                            break;
                        case "enum":
                            val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
                            if (val === false)
                                continue;
                            break;
                        case "scalar":
                            val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
                            break;
                    }
                    this.assert(val !== undefined, field.name + " map value", jsonObjValue);
                    // read key
                    let key = jsonObjKey;
                    if (field.K == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL)
                        key = key == "true" ? true : key == "false" ? false : key;
                    key = this.scalar(key, field.K, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.STRING, field.name).toString();
                    fieldObj[key] = val;
                }
            }
            else if (field.repeat) {
                if (jsonValue === null)
                    continue;
                // check input
                this.assert(Array.isArray(jsonValue), field.name, jsonValue);
                // our target to put array entries into
                const fieldArr = target[localName];
                // read array entries
                for (const jsonItem of jsonValue) {
                    this.assert(jsonItem !== null, field.name, null);
                    let val;
                    switch (field.kind) {
                        case "message":
                            val = field.T().internalJsonRead(jsonItem, options);
                            break;
                        case "enum":
                            val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
                            if (val === false)
                                continue;
                            break;
                        case "scalar":
                            val = this.scalar(jsonItem, field.T, field.L, field.name);
                            break;
                    }
                    this.assert(val !== undefined, field.name, jsonValue);
                    fieldArr.push(val);
                }
            }
            else {
                switch (field.kind) {
                    case "message":
                        if (jsonValue === null && field.T().typeName != 'google.protobuf.Value') {
                            this.assert(field.oneof === undefined, field.name + " (oneof member)", null);
                            continue;
                        }
                        target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
                        break;
                    case "enum":
                        if (jsonValue === null)
                            continue;
                        let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
                        if (val === false)
                            continue;
                        target[localName] = val;
                        break;
                    case "scalar":
                        if (jsonValue === null)
                            continue;
                        target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
                        break;
                }
            }
        }
    }
    /**
     * Returns `false` for unrecognized string representations.
     *
     * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
     */
    enum(type, json, fieldName, ignoreUnknownFields) {
        if (type[0] == 'google.protobuf.NullValue')
            (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assert)(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
        if (json === null)
            // we require 0 to be default value for all enums
            return 0;
        switch (typeof json) {
            case "number":
                (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assert)(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
                return json;
            case "string":
                let localEnumName = json;
                if (type[2] && json.substring(0, type[2].length) === type[2])
                    // lookup without the shared prefix
                    localEnumName = json.substring(type[2].length);
                let enumNumber = type[1][localEnumName];
                if (typeof enumNumber === 'undefined' && ignoreUnknownFields) {
                    return false;
                }
                (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
                return enumNumber;
        }
        (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assert)(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
    }
    scalar(json, type, longType, fieldName) {
        let e;
        try {
            switch (type) {
                // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
                // Either numbers or strings are accepted. Exponent notation is also accepted.
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.DOUBLE:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT:
                    if (json === null)
                        return .0;
                    if (json === "NaN")
                        return Number.NaN;
                    if (json === "Infinity")
                        return Number.POSITIVE_INFINITY;
                    if (json === "-Infinity")
                        return Number.NEGATIVE_INFINITY;
                    if (json === "") {
                        e = "empty string";
                        break;
                    }
                    if (typeof json == "string" && json.trim().length !== json.length) {
                        e = "extra whitespace";
                        break;
                    }
                    if (typeof json != "string" && typeof json != "number") {
                        break;
                    }
                    let float = Number(json);
                    if (Number.isNaN(float)) {
                        e = "not a number";
                        break;
                    }
                    if (!Number.isFinite(float)) {
                        // infinity and -infinity are handled by string representation above, so this is an error
                        e = "too large or small";
                        break;
                    }
                    if (type == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT)
                        (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assertFloat32)(float);
                    return float;
                // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED32:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED32:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT32:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32:
                    if (json === null)
                        return 0;
                    let int32;
                    if (typeof json == "number")
                        int32 = json;
                    else if (json === "")
                        e = "empty string";
                    else if (typeof json == "string") {
                        if (json.trim().length !== json.length)
                            e = "extra whitespace";
                        else
                            int32 = Number(json);
                    }
                    if (int32 === undefined)
                        break;
                    if (type == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32)
                        (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assertUInt32)(int32);
                    else
                        (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assertInt32)(int32);
                    return int32;
                // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT64:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED64:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT64:
                    if (json === null)
                        return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_4__.PbLong.ZERO, longType);
                    if (typeof json != "number" && typeof json != "string")
                        break;
                    return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_4__.PbLong.from(json), longType);
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED64:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT64:
                    if (json === null)
                        return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_4__.PbULong.ZERO, longType);
                    if (typeof json != "number" && typeof json != "string")
                        break;
                    return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_4__.PbULong.from(json), longType);
                // bool:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                    if (json === null)
                        return false;
                    if (typeof json !== "boolean")
                        break;
                    return json;
                // string:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING:
                    if (json === null)
                        return "";
                    if (typeof json !== "string") {
                        e = "extra whitespace";
                        break;
                    }
                    try {
                        encodeURIComponent(json);
                    }
                    catch (e) {
                        e = "invalid UTF8";
                        break;
                    }
                    return json;
                // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
                // Either standard or URL-safe base64 encoding with/without paddings are accepted.
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES:
                    if (json === null || json === "")
                        return new Uint8Array(0);
                    if (typeof json !== 'string')
                        break;
                    return (0,_base64__WEBPACK_IMPORTED_MODULE_5__.base64decode)(json);
            }
        }
        catch (error) {
            e = error.message;
        }
        this.assert(false, fieldName + (e ? " - " + e : ""), json);
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReflectionJsonWriter: () => (/* binding */ ReflectionJsonWriter)
/* harmony export */ });
/* harmony import */ var _base64__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base64 */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/base64.js");
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js");




/**
 * Writes proto3 messages in canonical JSON format using reflection
 * information.
 *
 * https://developers.google.com/protocol-buffers/docs/proto3#json
 */
class ReflectionJsonWriter {
    constructor(info) {
        var _a;
        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
    }
    /**
     * Converts the message to a JSON object, based on the field descriptors.
     */
    write(message, options) {
        const json = {}, source = message;
        for (const field of this.fields) {
            // field is not part of a oneof, simply write as is
            if (!field.oneof) {
                let jsonValue = this.field(field, source[field.localName], options);
                if (jsonValue !== undefined)
                    json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
                continue;
            }
            // field is part of a oneof
            const group = source[field.oneof];
            if (group.oneofKind !== field.localName)
                continue; // not selected, skip
            const opt = field.kind == 'scalar' || field.kind == 'enum'
                ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
            let jsonValue = this.field(field, group[field.localName], opt);
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(jsonValue !== undefined);
            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
        }
        return json;
    }
    field(field, value, options) {
        let jsonValue = undefined;
        if (field.kind == 'map') {
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == "object" && value !== null);
            const jsonObj = {};
            switch (field.V.kind) {
                case "scalar":
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        const val = this.scalar(field.V.T, entryValue, field.name, false, true);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
                case "message":
                    const messageType = field.V.T();
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        const val = this.message(messageType, entryValue, field.name, options);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
                case "enum":
                    const enumInfo = field.V.T();
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(entryValue === undefined || typeof entryValue == 'number');
                        const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
            }
            if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
                jsonValue = jsonObj;
        }
        else if (field.repeat) {
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(Array.isArray(value));
            const jsonArr = [];
            switch (field.kind) {
                case "scalar":
                    for (let i = 0; i < value.length; i++) {
                        const val = this.scalar(field.T, value[i], field.name, field.opt, true);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
                case "enum":
                    const enumInfo = field.T();
                    for (let i = 0; i < value.length; i++) {
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(value[i] === undefined || typeof value[i] == 'number');
                        const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
                case "message":
                    const messageType = field.T();
                    for (let i = 0; i < value.length; i++) {
                        const val = this.message(messageType, value[i], field.name, options);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
            }
            // add converted array to json output
            if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
                jsonValue = jsonArr;
        }
        else {
            switch (field.kind) {
                case "scalar":
                    jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
                    break;
                case "enum":
                    jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
                    break;
                case "message":
                    jsonValue = this.message(field.T(), value, field.name, options);
                    break;
            }
        }
        return jsonValue;
    }
    /**
     * Returns `null` as the default for google.protobuf.NullValue.
     */
    enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
        if (type[0] == 'google.protobuf.NullValue')
            return !emitDefaultValues && !optional ? undefined : null;
        if (value === undefined) {
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(optional);
            return undefined;
        }
        if (value === 0 && !emitDefaultValues && !optional)
            // we require 0 to be default value for all enums
            return undefined;
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'number');
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(Number.isInteger(value));
        if (enumAsInteger || !type[1].hasOwnProperty(value))
            // if we don't now the enum value, just return the number
            return value;
        if (type[2])
            // restore the dropped prefix
            return type[2] + type[1][value];
        return type[1][value];
    }
    message(type, value, fieldName, options) {
        if (value === undefined)
            return options.emitDefaultValues ? null : undefined;
        return type.internalJsonWrite(value, options);
    }
    scalar(type, value, fieldName, optional, emitDefaultValues) {
        if (value === undefined) {
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(optional);
            return undefined;
        }
        const ed = emitDefaultValues || optional;
        // noinspection FallThroughInSwitchStatementJS
        switch (type) {
            // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT32:
                if (value === 0)
                    return ed ? 0 : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertInt32)(value);
                return value;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32:
                if (value === 0)
                    return ed ? 0 : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertUInt32)(value);
                return value;
            // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
            // Either numbers or strings are accepted. Exponent notation is also accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT:
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertFloat32)(value);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.DOUBLE:
                if (value === 0)
                    return ed ? 0 : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'number');
                if (Number.isNaN(value))
                    return 'NaN';
                if (value === Number.POSITIVE_INFINITY)
                    return 'Infinity';
                if (value === Number.NEGATIVE_INFINITY)
                    return '-Infinity';
                return value;
            // string:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING:
                if (value === "")
                    return ed ? '' : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'string');
                return value;
            // bool:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                if (value === false)
                    return ed ? false : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'boolean');
                return value;
            // JSON value will be a decimal string. Either numbers or strings are accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED64:
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                let ulong = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong.from(value);
                if (ulong.isZero() && !ed)
                    return undefined;
                return ulong.toString();
            // JSON value will be a decimal string. Either numbers or strings are accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT64:
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.from(value);
                if (long.isZero() && !ed)
                    return undefined;
                return long.toString();
            // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
            // Either standard or URL-safe base64 encoding with/without paddings are accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES:
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(value instanceof Uint8Array);
                if (!value.byteLength)
                    return ed ? "" : undefined;
                return (0,_base64__WEBPACK_IMPORTED_MODULE_3__.base64encode)(value);
        }
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reflectionLongConvert: () => (/* binding */ reflectionLongConvert)
/* harmony export */ });
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");

/**
 * Utility method to convert a PbLong or PbUlong to a JavaScript
 * representation during runtime.
 *
 * Works with generated field information, `undefined` is equivalent
 * to `STRING`.
 */
function reflectionLongConvert(long, type) {
    switch (type) {
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.LongType.BIGINT:
            return long.toBigInt();
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.LongType.NUMBER:
            return long.toNumber();
        default:
            // case undefined:
            // case LongType.STRING:
            return long.toString();
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reflectionMergePartial: () => (/* binding */ reflectionMergePartial)
/* harmony export */ });
/**
 * Copy partial data into the target message.
 *
 * If a singular scalar or enum field is present in the source, it
 * replaces the field in the target.
 *
 * If a singular message field is present in the source, it is merged
 * with the target field by calling mergePartial() of the responsible
 * message type.
 *
 * If a repeated field is present in the source, its values replace
 * all values in the target array, removing extraneous values.
 * Repeated message fields are copied, not merged.
 *
 * If a map field is present in the source, entries are added to the
 * target map, replacing entries with the same key. Entries that only
 * exist in the target remain. Entries with message values are copied,
 * not merged.
 *
 * Note that this function differs from protobuf merge semantics,
 * which appends repeated fields.
 */
function reflectionMergePartial(info, target, source) {
    let fieldValue, // the field value we are working with
    input = source, output; // where we want our field value to go
    for (let field of info.fields) {
        let name = field.localName;
        if (field.oneof) {
            const group = input[field.oneof]; // this is the oneof`s group in the source
            if ((group === null || group === void 0 ? void 0 : group.oneofKind) == undefined) { // the user is free to omit
                continue; // we skip this field, and all other members too
            }
            fieldValue = group[name]; // our value comes from the the oneof group of the source
            output = target[field.oneof]; // and our output is the oneof group of the target
            output.oneofKind = group.oneofKind; // always update discriminator
            if (fieldValue == undefined) {
                delete output[name]; // remove any existing value
                continue; // skip further work on field
            }
        }
        else {
            fieldValue = input[name]; // we are using the source directly
            output = target; // we want our field value to go directly into the target
            if (fieldValue == undefined) {
                continue; // skip further work on field, existing value is used as is
            }
        }
        if (field.repeat)
            output[name].length = fieldValue.length; // resize target array to match source array
        // now we just work with `fieldValue` and `output` to merge the value
        switch (field.kind) {
            case "scalar":
            case "enum":
                if (field.repeat)
                    for (let i = 0; i < fieldValue.length; i++)
                        output[name][i] = fieldValue[i]; // not a reference type
                else
                    output[name] = fieldValue; // not a reference type
                break;
            case "message":
                let T = field.T();
                if (field.repeat)
                    for (let i = 0; i < fieldValue.length; i++)
                        output[name][i] = T.create(fieldValue[i]);
                else if (output[name] === undefined)
                    output[name] = T.create(fieldValue); // nothing to merge with
                else
                    T.mergePartial(output[name], fieldValue);
                break;
            case "map":
                // Map and repeated fields are simply overwritten, not appended or merged
                switch (field.V.kind) {
                    case "scalar":
                    case "enum":
                        Object.assign(output[name], fieldValue); // elements are not reference types
                        break;
                    case "message":
                        let T = field.V.T();
                        for (let k of Object.keys(fieldValue))
                            output[name][k] = T.create(fieldValue[k]);
                        break;
                }
                break;
        }
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js":
/*!********************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reflectionScalarDefault: () => (/* binding */ reflectionScalarDefault)
/* harmony export */ });
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _reflection_long_convert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-long-convert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js");
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");



/**
 * Creates the default value for a scalar type.
 */
function reflectionScalarDefault(type, longType = _reflection_info__WEBPACK_IMPORTED_MODULE_0__.LongType.STRING) {
    switch (type) {
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BOOL:
            return false;
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.UINT64:
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FIXED64:
            return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_1__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong.ZERO, longType);
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT64:
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SFIXED64:
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SINT64:
            return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_1__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.ZERO, longType);
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.DOUBLE:
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FLOAT:
            return 0.0;
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BYTES:
            return new Uint8Array(0);
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.STRING:
            return "";
        default:
            // case ScalarType.INT32:
            // case ScalarType.UINT32:
            // case ScalarType.SINT32:
            // case ScalarType.FIXED32:
            // case ScalarType.SFIXED32:
            return 0;
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js":
/*!****************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReflectionTypeCheck: () => (/* binding */ ReflectionTypeCheck)
/* harmony export */ });
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _oneof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./oneof */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/oneof.js");


// noinspection JSMethodCanBeStatic
class ReflectionTypeCheck {
    constructor(info) {
        var _a;
        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
    }
    prepare() {
        if (this.data)
            return;
        const req = [], known = [], oneofs = [];
        for (let field of this.fields) {
            if (field.oneof) {
                if (!oneofs.includes(field.oneof)) {
                    oneofs.push(field.oneof);
                    req.push(field.oneof);
                    known.push(field.oneof);
                }
            }
            else {
                known.push(field.localName);
                switch (field.kind) {
                    case "scalar":
                    case "enum":
                        if (!field.opt || field.repeat)
                            req.push(field.localName);
                        break;
                    case "message":
                        if (field.repeat)
                            req.push(field.localName);
                        break;
                    case "map":
                        req.push(field.localName);
                        break;
                }
            }
        }
        this.data = { req, known, oneofs: Object.values(oneofs) };
    }
    /**
     * Is the argument a valid message as specified by the
     * reflection information?
     *
     * Checks all field types recursively. The `depth`
     * specifies how deep into the structure the check will be.
     *
     * With a depth of 0, only the presence of fields
     * is checked.
     *
     * With a depth of 1 or more, the field types are checked.
     *
     * With a depth of 2 or more, the members of map, repeated
     * and message fields are checked.
     *
     * Message fields will be checked recursively with depth - 1.
     *
     * The number of map entries / repeated values being checked
     * is < depth.
     */
    is(message, depth, allowExcessProperties = false) {
        if (depth < 0)
            return true;
        if (message === null || message === undefined || typeof message != 'object')
            return false;
        this.prepare();
        let keys = Object.keys(message), data = this.data;
        // if a required field is missing in arg, this cannot be a T
        if (keys.length < data.req.length || data.req.some(n => !keys.includes(n)))
            return false;
        if (!allowExcessProperties) {
            // if the arg contains a key we dont know, this is not a literal T
            if (keys.some(k => !data.known.includes(k)))
                return false;
        }
        // "With a depth of 0, only the presence and absence of fields is checked."
        // "With a depth of 1 or more, the field types are checked."
        if (depth < 1) {
            return true;
        }
        // check oneof group
        for (const name of data.oneofs) {
            const group = message[name];
            if (!(0,_oneof__WEBPACK_IMPORTED_MODULE_0__.isOneofGroup)(group))
                return false;
            if (group.oneofKind === undefined)
                continue;
            const field = this.fields.find(f => f.localName === group.oneofKind);
            if (!field)
                return false; // we found no field, but have a kind, something is wrong
            if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
                return false;
        }
        // check types
        for (const field of this.fields) {
            if (field.oneof !== undefined)
                continue;
            if (!this.field(message[field.localName], field, allowExcessProperties, depth))
                return false;
        }
        return true;
    }
    field(arg, field, allowExcessProperties, depth) {
        let repeated = field.repeat;
        switch (field.kind) {
            case "scalar":
                if (arg === undefined)
                    return field.opt;
                if (repeated)
                    return this.scalars(arg, field.T, depth, field.L);
                return this.scalar(arg, field.T, field.L);
            case "enum":
                if (arg === undefined)
                    return field.opt;
                if (repeated)
                    return this.scalars(arg, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32, depth);
                return this.scalar(arg, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32);
            case "message":
                if (arg === undefined)
                    return true;
                if (repeated)
                    return this.messages(arg, field.T(), allowExcessProperties, depth);
                return this.message(arg, field.T(), allowExcessProperties, depth);
            case "map":
                if (typeof arg != 'object' || arg === null)
                    return false;
                if (depth < 2)
                    return true;
                if (!this.mapKeys(arg, field.K, depth))
                    return false;
                switch (field.V.kind) {
                    case "scalar":
                        return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
                    case "enum":
                        return this.scalars(Object.values(arg), _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32, depth);
                    case "message":
                        return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
                }
                break;
        }
        return true;
    }
    message(arg, type, allowExcessProperties, depth) {
        if (allowExcessProperties) {
            return type.isAssignable(arg, depth);
        }
        return type.is(arg, depth);
    }
    messages(arg, type, allowExcessProperties, depth) {
        if (!Array.isArray(arg))
            return false;
        if (depth < 2)
            return true;
        if (allowExcessProperties) {
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!type.isAssignable(arg[i], depth - 1))
                    return false;
        }
        else {
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!type.is(arg[i], depth - 1))
                    return false;
        }
        return true;
    }
    scalar(arg, type, longType) {
        let argType = typeof arg;
        switch (type) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT64:
                switch (longType) {
                    case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.BIGINT:
                        return argType == "bigint";
                    case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.NUMBER:
                        return argType == "number" && !isNaN(arg);
                    default:
                        return argType == "string";
                }
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                return argType == 'boolean';
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING:
                return argType == 'string';
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES:
                return arg instanceof Uint8Array;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.DOUBLE:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT:
                return argType == 'number' && !isNaN(arg);
            default:
                // case ScalarType.UINT32:
                // case ScalarType.FIXED32:
                // case ScalarType.INT32:
                // case ScalarType.SINT32:
                // case ScalarType.SFIXED32:
                return argType == 'number' && Number.isInteger(arg);
        }
    }
    scalars(arg, type, depth, longType) {
        if (!Array.isArray(arg))
            return false;
        if (depth < 2)
            return true;
        if (Array.isArray(arg))
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!this.scalar(arg[i], type, longType))
                    return false;
        return true;
    }
    mapKeys(map, type, depth) {
        let keys = Object.keys(map);
        switch (type) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32:
                return this.scalars(keys.slice(0, depth).map(k => parseInt(k)), type, depth);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                return this.scalars(keys.slice(0, depth).map(k => k == 'true' ? true : k == 'false' ? false : k), type, depth);
            default:
                return this.scalars(keys, type, depth, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.STRING);
        }
    }
}


/***/ }),

/***/ "../../../node_modules/hyphenate-style-name/index.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/hyphenate-style-name/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* eslint-disable no-var, prefer-template */
var uppercasePattern = /[A-Z]/g
var msPattern = /^ms-/
var cache = {}

function toHyphenLower(match) {
  return '-' + match.toLowerCase()
}

function hyphenateStyleName(name) {
  if (cache.hasOwnProperty(name)) {
    return cache[name]
  }

  var hName = name.replace(uppercasePattern, toHyphenLower)
  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hyphenateStyleName);


/***/ }),

/***/ "../../../node_modules/is-in-browser/dist/module.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/is-in-browser/dist/module.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   isBrowser: () => (/* binding */ isBrowser)
/* harmony export */ });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isBrowser);


/***/ }),

/***/ "../../../node_modules/jss-plugin-camel-case/dist/jss-plugin-camel-case.esm.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/jss-plugin-camel-case/dist/jss-plugin-camel-case.esm.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var hyphenate_style_name__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hyphenate-style-name */ "../../../node_modules/hyphenate-style-name/index.js");


/**
 * Convert camel cased property names to dash separated.
 */

function convertCase(style) {
  var converted = {};

  for (var prop in style) {
    var key = prop.indexOf('--') === 0 ? prop : (0,hyphenate_style_name__WEBPACK_IMPORTED_MODULE_0__["default"])(prop);
    converted[key] = style[prop];
  }

  if (style.fallbacks) {
    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
  }

  return converted;
}
/**
 * Allow camel cased property names by converting them back to dasherized.
 */


function camelCase() {
  function onProcessStyle(style) {
    if (Array.isArray(style)) {
      // Handle rules like @font-face, which can have multiple styles in an array
      for (var index = 0; index < style.length; index++) {
        style[index] = convertCase(style[index]);
      }

      return style;
    }

    return convertCase(style);
  }

  function onChangeValue(value, prop, rule) {
    if (prop.indexOf('--') === 0) {
      return value;
    }

    var hyphenatedProp = (0,hyphenate_style_name__WEBPACK_IMPORTED_MODULE_0__["default"])(prop); // There was no camel case in place

    if (prop === hyphenatedProp) return value;
    rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.

    return null;
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (camelCase);


/***/ }),

/***/ "../../../node_modules/jss-plugin-global/dist/jss-plugin-global.esm.js":
/*!*****************************************************************************!*\
  !*** ../../../node_modules/jss-plugin-global/dist/jss-plugin-global.esm.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "../../../node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jss */ "../../../node_modules/jss/dist/jss.esm.js");



var at = '@global';
var atPrefix = '@global ';

var GlobalContainerRule =
/*#__PURE__*/
function () {
  function GlobalContainerRule(key, styles, options) {
    this.type = 'global';
    this.at = at;
    this.isProcessed = false;
    this.key = key;
    this.options = options;
    this.rules = new jss__WEBPACK_IMPORTED_MODULE_1__.RuleList((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      parent: this
    }));

    for (var selector in styles) {
      this.rules.add(selector, styles[selector]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = GlobalContainerRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (rule) this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Replace rule, run plugins.
   */
  ;

  _proto.replaceRule = function replaceRule(name, style, options) {
    var newRule = this.rules.replace(name, style, options);
    if (newRule) this.options.jss.plugins.onProcessRule(newRule);
    return newRule;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    return this.rules.toString(options);
  };

  return GlobalContainerRule;
}();

var GlobalPrefixedRule =
/*#__PURE__*/
function () {
  function GlobalPrefixedRule(key, style, options) {
    this.type = 'global';
    this.at = at;
    this.isProcessed = false;
    this.key = key;
    this.options = options;
    var selector = key.substr(atPrefix.length);
    this.rule = options.jss.createRule(selector, style, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      parent: this
    }));
  }

  var _proto2 = GlobalPrefixedRule.prototype;

  _proto2.toString = function toString(options) {
    return this.rule ? this.rule.toString(options) : '';
  };

  return GlobalPrefixedRule;
}();

var separatorRegExp = /\s*,\s*/g;

function addScope(selector, scope) {
  var parts = selector.split(separatorRegExp);
  var scoped = '';

  for (var i = 0; i < parts.length; i++) {
    scoped += scope + " " + parts[i].trim();
    if (parts[i + 1]) scoped += ', ';
  }

  return scoped;
}

function handleNestedGlobalContainerRule(rule, sheet) {
  var options = rule.options,
      style = rule.style;
  var rules = style ? style[at] : null;
  if (!rules) return;

  for (var name in rules) {
    sheet.addRule(name, rules[name], (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      selector: addScope(name, rule.selector)
    }));
  }

  delete style[at];
}

function handlePrefixedGlobalRule(rule, sheet) {
  var options = rule.options,
      style = rule.style;

  for (var prop in style) {
    if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;
    var selector = addScope(prop.substr(at.length), rule.selector);
    sheet.addRule(selector, style[prop], (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      selector: selector
    }));
    delete style[prop];
  }
}
/**
 * Convert nested rules to separate, remove them from original styles.
 */


function jssGlobal() {
  function onCreateRule(name, styles, options) {
    if (!name) return null;

    if (name === at) {
      return new GlobalContainerRule(name, styles, options);
    }

    if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {
      return new GlobalPrefixedRule(name, styles, options);
    }

    var parent = options.parent;

    if (parent) {
      if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {
        options.scoped = false;
      }
    }

    if (!options.selector && options.scoped === false) {
      options.selector = name;
    }

    return null;
  }

  function onProcessRule(rule, sheet) {
    if (rule.type !== 'style' || !sheet) return;
    handleNestedGlobalContainerRule(rule, sheet);
    handlePrefixedGlobalRule(rule, sheet);
  }

  return {
    onCreateRule: onCreateRule,
    onProcessRule: onProcessRule
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (jssGlobal);


/***/ }),

/***/ "../../../node_modules/jss/dist/jss.esm.js":
/*!*************************************************!*\
  !*** ../../../node_modules/jss/dist/jss.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RuleList: () => (/* binding */ RuleList),
/* harmony export */   SheetsManager: () => (/* binding */ SheetsManager),
/* harmony export */   SheetsRegistry: () => (/* binding */ SheetsRegistry),
/* harmony export */   create: () => (/* binding */ createJss),
/* harmony export */   createGenerateId: () => (/* binding */ createGenerateId),
/* harmony export */   createRule: () => (/* binding */ createRule),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getDynamicStyles: () => (/* binding */ getDynamicStyles),
/* harmony export */   hasCSSTOMSupport: () => (/* binding */ hasCSSTOMSupport),
/* harmony export */   sheets: () => (/* binding */ sheets),
/* harmony export */   toCssValue: () => (/* binding */ toCssValue)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "../../../node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var is_in_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-in-browser */ "../../../node_modules/is-in-browser/dist/module.js");
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tiny-warning */ "../../../node_modules/tiny-warning/dist/tiny-warning.esm.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ "../../../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");








var plainObjectConstrurctor = {}.constructor;
function cloneStyle(style) {
  if (style == null || typeof style !== 'object') return style;
  if (Array.isArray(style)) return style.map(cloneStyle);
  if (style.constructor !== plainObjectConstrurctor) return style;
  var newStyle = {};

  for (var name in style) {
    newStyle[name] = cloneStyle(style[name]);
  }

  return newStyle;
}

/**
 * Create a rule instance.
 */

function createRule(name, decl, options) {
  if (name === void 0) {
    name = 'unnamed';
  }

  var jss = options.jss;
  var declCopy = cloneStyle(decl);
  var rule = jss.plugins.onCreateRule(name, declCopy, options);
  if (rule) return rule; // It is an at-rule and it has no instance.

  if (name[0] === '@') {
     true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] Unknown rule " + name) : 0;
  }

  return null;
}

var join = function join(value, by) {
  var result = '';

  for (var i = 0; i < value.length; i++) {
    // Remove !important from the value, it will be readded later.
    if (value[i] === '!important') break;
    if (result) result += by;
    result += value[i];
  }

  return result;
};
/**
 * Converts JSS array value to a CSS string.
 *
 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
 * `border: ['1px', '2px']` > `border: 1px, 2px;`
 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
 * `color: ['red', !important]` > `color: red !important;`
 */


var toCssValue = function toCssValue(value) {
  if (!Array.isArray(value)) return value;
  var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.

  if (Array.isArray(value[0])) {
    for (var i = 0; i < value.length; i++) {
      if (value[i] === '!important') break;
      if (cssValue) cssValue += ', ';
      cssValue += join(value[i], ' ');
    }
  } else cssValue = join(value, ', '); // Add !important, because it was ignored.


  if (value[value.length - 1] === '!important') {
    cssValue += ' !important';
  }

  return cssValue;
};

function getWhitespaceSymbols(options) {
  if (options && options.format === false) {
    return {
      linebreak: '',
      space: ''
    };
  }

  return {
    linebreak: '\n',
    space: ' '
  };
}

/**
 * Indent a string.
 * http://jsperf.com/array-join-vs-for
 */

function indentStr(str, indent) {
  var result = '';

  for (var index = 0; index < indent; index++) {
    result += '  ';
  }

  return result + str;
}
/**
 * Converts a Rule to CSS string.
 */


function toCss(selector, style, options) {
  if (options === void 0) {
    options = {};
  }

  var result = '';
  if (!style) return result;
  var _options = options,
      _options$indent = _options.indent,
      indent = _options$indent === void 0 ? 0 : _options$indent;
  var fallbacks = style.fallbacks;

  if (options.format === false) {
    indent = -Infinity;
  }

  var _getWhitespaceSymbols = getWhitespaceSymbols(options),
      linebreak = _getWhitespaceSymbols.linebreak,
      space = _getWhitespaceSymbols.space;

  if (selector) indent++; // Apply fallbacks first.

  if (fallbacks) {
    // Array syntax {fallbacks: [{prop: value}]}
    if (Array.isArray(fallbacks)) {
      for (var index = 0; index < fallbacks.length; index++) {
        var fallback = fallbacks[index];

        for (var prop in fallback) {
          var value = fallback[prop];

          if (value != null) {
            if (result) result += linebreak;
            result += indentStr(prop + ":" + space + toCssValue(value) + ";", indent);
          }
        }
      }
    } else {
      // Object syntax {fallbacks: {prop: value}}
      for (var _prop in fallbacks) {
        var _value = fallbacks[_prop];

        if (_value != null) {
          if (result) result += linebreak;
          result += indentStr(_prop + ":" + space + toCssValue(_value) + ";", indent);
        }
      }
    }
  }

  for (var _prop2 in style) {
    var _value2 = style[_prop2];

    if (_value2 != null && _prop2 !== 'fallbacks') {
      if (result) result += linebreak;
      result += indentStr(_prop2 + ":" + space + toCssValue(_value2) + ";", indent);
    }
  } // Allow empty style in this case, because properties will be added dynamically.


  if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.

  if (!selector) return result;
  indent--;
  if (result) result = "" + linebreak + result + linebreak;
  return indentStr("" + selector + space + "{" + result, indent) + indentStr('}', indent);
}

var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
var nativeEscape = typeof CSS !== 'undefined' && CSS.escape;
var escape = (function (str) {
  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\$1');
});

var BaseStyleRule =
/*#__PURE__*/
function () {
  function BaseStyleRule(key, style, options) {
    this.type = 'style';
    this.isProcessed = false;
    var sheet = options.sheet,
        Renderer = options.Renderer;
    this.key = key;
    this.options = options;
    this.style = style;
    if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();
  }
  /**
   * Get or set a style property.
   */


  var _proto = BaseStyleRule.prototype;

  _proto.prop = function prop(name, value, options) {
    // It's a getter.
    if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.

    var force = options ? options.force : false;
    if (!force && this.style[name] === value) return this;
    var newValue = value;

    if (!options || options.process !== false) {
      newValue = this.options.jss.plugins.onChangeValue(value, name, this);
    }

    var isEmpty = newValue == null || newValue === false;
    var isDefined = name in this.style; // Value is empty and wasn't defined before.

    if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.

    var remove = isEmpty && isDefined;
    if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.

    if (this.renderable && this.renderer) {
      if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);
      return this;
    }

    var sheet = this.options.sheet;

    if (sheet && sheet.attached) {
       true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, '[JSS] Rule is not linked. Missing sheet option "link: true".') : 0;
    }

    return this;
  };

  return BaseStyleRule;
}();
var StyleRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__["default"])(StyleRule, _BaseStyleRule);

  function StyleRule(key, style, options) {
    var _this;

    _this = _BaseStyleRule.call(this, key, style, options) || this;
    var selector = options.selector,
        scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;

    if (selector) {
      _this.selectorText = selector;
    } else if (scoped !== false) {
      _this.id = generateId((0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__["default"])((0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__["default"])(_this)), sheet);
      _this.selectorText = "." + escape(_this.id);
    }

    return _this;
  }
  /**
   * Set selector string.
   * Attention: use this with caution. Most browsers didn't implement
   * selectorText setter, so this may result in rerendering of entire Style Sheet.
   */


  var _proto2 = StyleRule.prototype;

  /**
   * Apply rule to an element inline.
   */
  _proto2.applyTo = function applyTo(renderable) {
    var renderer = this.renderer;

    if (renderer) {
      var json = this.toJSON();

      for (var prop in json) {
        renderer.setProperty(renderable, prop, json[prop]);
      }
    }

    return this;
  }
  /**
   * Returns JSON representation of the rule.
   * Fallbacks are not supported.
   * Useful for inline styles.
   */
  ;

  _proto2.toJSON = function toJSON() {
    var json = {};

    for (var prop in this.style) {
      var value = this.style[prop];
      if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);
    }

    return json;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto2.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.selectorText, this.style, opts);
  };

  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(StyleRule, [{
    key: "selector",
    set: function set(selector) {
      if (selector === this.selectorText) return;
      this.selectorText = selector;
      var renderer = this.renderer,
          renderable = this.renderable;
      if (!renderable || !renderer) return;
      var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.

      if (!hasChanged) {
        renderer.replaceRule(renderable, this);
      }
    }
    /**
     * Get selector string.
     */
    ,
    get: function get() {
      return this.selectorText;
    }
  }]);

  return StyleRule;
}(BaseStyleRule);
var pluginStyleRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    if (key[0] === '@' || options.parent && options.parent.type === 'keyframes') {
      return null;
    }

    return new StyleRule(key, style, options);
  }
};

var defaultToStringOptions = {
  indent: 1,
  children: true
};
var atRegExp = /@([\w-]+)/;
/**
 * Conditional rule for @media, @supports
 */

var ConditionalRule =
/*#__PURE__*/
function () {
  function ConditionalRule(key, styles, options) {
    this.type = 'conditional';
    this.isProcessed = false;
    this.key = key;
    var atMatch = key.match(atRegExp);
    this.at = atMatch ? atMatch[1] : 'unknown'; // Key might contain a unique suffix in case the `name` passed by user was duplicate.

    this.query = options.name || "@" + this.at;
    this.options = options;
    this.rules = new RuleList((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      parent: this
    }));

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = ConditionalRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Replace rule, run plugins.
   */
  ;

  _proto.replaceRule = function replaceRule(name, style, options) {
    var newRule = this.rules.replace(name, style, options);
    if (newRule) this.options.jss.plugins.onProcessRule(newRule);
    return newRule;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions;
    }

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (options.indent == null) options.indent = defaultToStringOptions.indent;
    if (options.children == null) options.children = defaultToStringOptions.children;

    if (options.children === false) {
      return this.query + " {}";
    }

    var children = this.rules.toString(options);
    return children ? this.query + " {" + linebreak + children + linebreak + "}" : '';
  };

  return ConditionalRule;
}();
var keyRegExp = /@container|@media|@supports\s+/;
var pluginConditionalRule = {
  onCreateRule: function onCreateRule(key, styles, options) {
    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;
  }
};

var defaultToStringOptions$1 = {
  indent: 1,
  children: true
};
var nameRegExp = /@keyframes\s+([\w-]+)/;
/**
 * Rule for @keyframes
 */

var KeyframesRule =
/*#__PURE__*/
function () {
  function KeyframesRule(key, frames, options) {
    this.type = 'keyframes';
    this.at = '@keyframes';
    this.isProcessed = false;
    var nameMatch = key.match(nameRegExp);

    if (nameMatch && nameMatch[1]) {
      this.name = nameMatch[1];
    } else {
      this.name = 'noname';
       true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] Bad keyframes name " + key) : 0;
    }

    this.key = this.type + "-" + this.name;
    this.options = options;
    var scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;
    this.id = scoped === false ? this.name : escape(generateId(this, sheet));
    this.rules = new RuleList((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      parent: this
    }));

    for (var name in frames) {
      this.rules.add(name, frames[name], (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
        parent: this
      }));
    }

    this.rules.process();
  }
  /**
   * Generates a CSS string.
   */


  var _proto = KeyframesRule.prototype;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions$1;
    }

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (options.indent == null) options.indent = defaultToStringOptions$1.indent;
    if (options.children == null) options.children = defaultToStringOptions$1.children;

    if (options.children === false) {
      return this.at + " " + this.id + " {}";
    }

    var children = this.rules.toString(options);
    if (children) children = "" + linebreak + children + linebreak;
    return this.at + " " + this.id + " {" + children + "}";
  };

  return KeyframesRule;
}();
var keyRegExp$1 = /@keyframes\s+/;
var refRegExp = /\$([\w-]+)/g;

var findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {
  if (typeof val === 'string') {
    return val.replace(refRegExp, function (match, name) {
      if (name in keyframes) {
        return keyframes[name];
      }

       true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] Referenced keyframes rule \"" + name + "\" is not defined.") : 0;
      return match;
    });
  }

  return val;
};
/**
 * Replace the reference for a animation name.
 */


var replaceRef = function replaceRef(style, prop, keyframes) {
  var value = style[prop];
  var refKeyframe = findReferencedKeyframe(value, keyframes);

  if (refKeyframe !== value) {
    style[prop] = refKeyframe;
  }
};

var pluginKeyframesRule = {
  onCreateRule: function onCreateRule(key, frames, options) {
    return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;
  },
  // Animation name ref replacer.
  onProcessStyle: function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style' || !sheet) return style;
    if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);
    if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);
    return style;
  },
  onChangeValue: function onChangeValue(val, prop, rule) {
    var sheet = rule.options.sheet;

    if (!sheet) {
      return val;
    }

    switch (prop) {
      case 'animation':
        return findReferencedKeyframe(val, sheet.keyframes);

      case 'animation-name':
        return findReferencedKeyframe(val, sheet.keyframes);

      default:
        return val;
    }
  }
};

var KeyframeRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__["default"])(KeyframeRule, _BaseStyleRule);

  function KeyframeRule() {
    return _BaseStyleRule.apply(this, arguments) || this;
  }

  var _proto = KeyframeRule.prototype;

  /**
   * Generates a CSS string.
   */
  _proto.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.key, this.style, opts);
  };

  return KeyframeRule;
}(BaseStyleRule);
var pluginKeyframeRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    if (options.parent && options.parent.type === 'keyframes') {
      return new KeyframeRule(key, style, options);
    }

    return null;
  }
};

var FontFaceRule =
/*#__PURE__*/
function () {
  function FontFaceRule(key, style, options) {
    this.type = 'font-face';
    this.at = '@font-face';
    this.isProcessed = false;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = FontFaceRule.prototype;

  _proto.toString = function toString(options) {
    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (Array.isArray(this.style)) {
      var str = '';

      for (var index = 0; index < this.style.length; index++) {
        str += toCss(this.at, this.style[index]);
        if (this.style[index + 1]) str += linebreak;
      }

      return str;
    }

    return toCss(this.at, this.style, options);
  };

  return FontFaceRule;
}();
var keyRegExp$2 = /@font-face/;
var pluginFontFaceRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;
  }
};

var ViewportRule =
/*#__PURE__*/
function () {
  function ViewportRule(key, style, options) {
    this.type = 'viewport';
    this.at = '@viewport';
    this.isProcessed = false;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = ViewportRule.prototype;

  _proto.toString = function toString(options) {
    return toCss(this.key, this.style, options);
  };

  return ViewportRule;
}();
var pluginViewportRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;
  }
};

var SimpleRule =
/*#__PURE__*/
function () {
  function SimpleRule(key, value, options) {
    this.type = 'simple';
    this.isProcessed = false;
    this.key = key;
    this.value = value;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */
  // eslint-disable-next-line no-unused-vars


  var _proto = SimpleRule.prototype;

  _proto.toString = function toString(options) {
    if (Array.isArray(this.value)) {
      var str = '';

      for (var index = 0; index < this.value.length; index++) {
        str += this.key + " " + this.value[index] + ";";
        if (this.value[index + 1]) str += '\n';
      }

      return str;
    }

    return this.key + " " + this.value + ";";
  };

  return SimpleRule;
}();
var keysMap = {
  '@charset': true,
  '@import': true,
  '@namespace': true
};
var pluginSimpleRule = {
  onCreateRule: function onCreateRule(key, value, options) {
    return key in keysMap ? new SimpleRule(key, value, options) : null;
  }
};

var plugins = [pluginStyleRule, pluginConditionalRule, pluginKeyframesRule, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];

var defaultUpdateOptions = {
  process: true
};
var forceUpdateOptions = {
  force: true,
  process: true
  /**
   * Contains rules objects and allows adding/removing etc.
   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
   */

};

var RuleList =
/*#__PURE__*/
function () {
  // Rules registry for access by .get() method.
  // It contains the same rule registered by name and by selector.
  // Original styles object.
  // Used to ensure correct rules order.
  function RuleList(options) {
    this.map = {};
    this.raw = {};
    this.index = [];
    this.counter = 0;
    this.options = options;
    this.classes = options.classes;
    this.keyframes = options.keyframes;
  }
  /**
   * Create and register rule.
   *
   * Will not render after Style Sheet was rendered the first time.
   */


  var _proto = RuleList.prototype;

  _proto.add = function add(name, decl, ruleOptions) {
    var _this$options = this.options,
        parent = _this$options.parent,
        sheet = _this$options.sheet,
        jss = _this$options.jss,
        Renderer = _this$options.Renderer,
        generateId = _this$options.generateId,
        scoped = _this$options.scoped;

    var options = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
      classes: this.classes,
      parent: parent,
      sheet: sheet,
      jss: jss,
      Renderer: Renderer,
      generateId: generateId,
      scoped: scoped,
      name: name,
      keyframes: this.keyframes,
      selector: undefined
    }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
    // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
    // we need to make the key unique within this RuleList instance scope.


    var key = name;

    if (name in this.raw) {
      key = name + "-d" + this.counter++;
    } // We need to save the original decl before creating the rule
    // because cache plugin needs to use it as a key to return a cached rule.


    this.raw[key] = decl;

    if (key in this.classes) {
      // E.g. rules inside of @media container
      options.selector = "." + escape(this.classes[key]);
    }

    var rule = createRule(key, decl, options);
    if (!rule) return null;
    this.register(rule);
    var index = options.index === undefined ? this.index.length : options.index;
    this.index.splice(index, 0, rule);
    return rule;
  }
  /**
   * Replace rule.
   * Create a new rule and remove old one instead of overwriting
   * because we want to invoke onCreateRule hook to make plugins work.
   */
  ;

  _proto.replace = function replace(name, decl, ruleOptions) {
    var oldRule = this.get(name);
    var oldIndex = this.index.indexOf(oldRule);

    if (oldRule) {
      this.remove(oldRule);
    }

    var options = ruleOptions;
    if (oldIndex !== -1) options = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, ruleOptions, {
      index: oldIndex
    });
    return this.add(name, decl, options);
  }
  /**
   * Get a rule by name or selector.
   */
  ;

  _proto.get = function get(nameOrSelector) {
    return this.map[nameOrSelector];
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.remove = function remove(rule) {
    this.unregister(rule);
    delete this.raw[rule.key];
    this.index.splice(this.index.indexOf(rule), 1);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.index.indexOf(rule);
  }
  /**
   * Run `onProcessRule()` plugins on every rule.
   */
  ;

  _proto.process = function process() {
    var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
    // we end up with very hard-to-track-down side effects.

    this.index.slice(0).forEach(plugins.onProcessRule, plugins);
  }
  /**
   * Register a rule in `.map`, `.classes` and `.keyframes` maps.
   */
  ;

  _proto.register = function register(rule) {
    this.map[rule.key] = rule;

    if (rule instanceof StyleRule) {
      this.map[rule.selector] = rule;
      if (rule.id) this.classes[rule.key] = rule.id;
    } else if (rule instanceof KeyframesRule && this.keyframes) {
      this.keyframes[rule.name] = rule.id;
    }
  }
  /**
   * Unregister a rule.
   */
  ;

  _proto.unregister = function unregister(rule) {
    delete this.map[rule.key];

    if (rule instanceof StyleRule) {
      delete this.map[rule.selector];
      delete this.classes[rule.key];
    } else if (rule instanceof KeyframesRule) {
      delete this.keyframes[rule.name];
    }
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var name;
    var data;
    var options;

    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
      name = arguments.length <= 0 ? undefined : arguments[0];
      data = arguments.length <= 1 ? undefined : arguments[1];
      options = arguments.length <= 2 ? undefined : arguments[2];
    } else {
      data = arguments.length <= 0 ? undefined : arguments[0];
      options = arguments.length <= 1 ? undefined : arguments[1];
      name = null;
    }

    if (name) {
      this.updateOne(this.get(name), data, options);
    } else {
      for (var index = 0; index < this.index.length; index++) {
        this.updateOne(this.index[index], data, options);
      }
    }
  }
  /**
   * Execute plugins, update rule props.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    if (options === void 0) {
      options = defaultUpdateOptions;
    }

    var _this$options2 = this.options,
        plugins = _this$options2.jss.plugins,
        sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.

    if (rule.rules instanceof RuleList) {
      rule.rules.update(data, options);
      return;
    }

    var style = rule.style;
    plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.

    if (options.process && style && style !== rule.style) {
      // We need to run the plugins in case new `style` relies on syntax plugins.
      plugins.onProcessStyle(rule.style, rule, sheet); // Update and add props.

      for (var prop in rule.style) {
        var nextValue = rule.style[prop];
        var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (nextValue !== prevValue) {
          rule.prop(prop, nextValue, forceUpdateOptions);
        }
      } // Remove props.


      for (var _prop in style) {
        var _nextValue = rule.style[_prop];
        var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (_nextValue == null && _nextValue !== _prevValue) {
          rule.prop(_prop, null, forceUpdateOptions);
        }
      }
    }
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    var str = '';
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    for (var index = 0; index < this.index.length; index++) {
      var rule = this.index[index];
      var css = rule.toString(options); // No need to render an empty rule.

      if (!css && !link) continue;
      if (str) str += linebreak;
      str += css;
    }

    return str;
  };

  return RuleList;
}();

var StyleSheet =
/*#__PURE__*/
function () {
  function StyleSheet(styles, options) {
    this.attached = false;
    this.deployed = false;
    this.classes = {};
    this.keyframes = {};
    this.options = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    });

    if (options.Renderer) {
      this.renderer = new options.Renderer(this);
    }

    this.rules = new RuleList(this.options);

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Attach renderable to the render tree.
   */


  var _proto = StyleSheet.prototype;

  _proto.attach = function attach() {
    if (this.attached) return this;
    if (this.renderer) this.renderer.attach();
    this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.

    if (!this.deployed) this.deploy();
    return this;
  }
  /**
   * Remove renderable from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.attached) return this;
    if (this.renderer) this.renderer.detach();
    this.attached = false;
    return this;
  }
  /**
   * Add a rule to the current stylesheet.
   * Will insert a rule also after the stylesheet has been rendered first time.
   */
  ;

  _proto.addRule = function addRule(name, decl, options) {
    var queue = this.queue; // Plugins can create rules.
    // In order to preserve the right order, we need to queue all `.addRule` calls,
    // which happen after the first `rules.add()` call.

    if (this.attached && !queue) this.queue = [];
    var rule = this.rules.add(name, decl, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);

    if (this.attached) {
      if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
      // It will be inserted all together when .attach is called.

      if (queue) queue.push(rule);else {
        this.insertRule(rule);

        if (this.queue) {
          this.queue.forEach(this.insertRule, this);
          this.queue = undefined;
        }
      }
      return rule;
    } // We can't add rules to a detached style node.
    // We will redeploy the sheet once user will attach it.


    this.deployed = false;
    return rule;
  }
  /**
   * Replace a rule in the current stylesheet.
   */
  ;

  _proto.replaceRule = function replaceRule(nameOrSelector, decl, options) {
    var oldRule = this.rules.get(nameOrSelector);
    if (!oldRule) return this.addRule(nameOrSelector, decl, options);
    var newRule = this.rules.replace(nameOrSelector, decl, options);

    if (newRule) {
      this.options.jss.plugins.onProcessRule(newRule);
    }

    if (this.attached) {
      if (!this.deployed) return newRule; // Don't replace / delete rule directly if there is no stringified version yet.
      // It will be inserted all together when .attach is called.

      if (this.renderer) {
        if (!newRule) {
          this.renderer.deleteRule(oldRule);
        } else if (oldRule.renderable) {
          this.renderer.replaceRule(oldRule.renderable, newRule);
        }
      }

      return newRule;
    } // We can't replace rules to a detached style node.
    // We will redeploy the sheet once user will attach it.


    this.deployed = false;
    return newRule;
  }
  /**
   * Insert rule into the StyleSheet
   */
  ;

  _proto.insertRule = function insertRule(rule) {
    if (this.renderer) {
      this.renderer.insertRule(rule);
    }
  }
  /**
   * Create and add rules.
   * Will render also after Style Sheet was rendered the first time.
   */
  ;

  _proto.addRules = function addRules(styles, options) {
    var added = [];

    for (var name in styles) {
      var rule = this.addRule(name, styles[name], options);
      if (rule) added.push(rule);
    }

    return added;
  }
  /**
   * Get a rule by name or selector.
   */
  ;

  _proto.getRule = function getRule(nameOrSelector) {
    return this.rules.get(nameOrSelector);
  }
  /**
   * Delete a rule by name.
   * Returns `true`: if rule has been deleted from the DOM.
   */
  ;

  _proto.deleteRule = function deleteRule(name) {
    var rule = typeof name === 'object' ? name : this.rules.get(name);

    if (!rule || // Style sheet was created without link: true and attached, in this case we
    // won't be able to remove the CSS rule from the DOM.
    this.attached && !rule.renderable) {
      return false;
    }

    this.rules.remove(rule);

    if (this.attached && rule.renderable && this.renderer) {
      return this.renderer.deleteRule(rule.renderable);
    }

    return true;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Deploy pure CSS string to a renderable.
   */
  ;

  _proto.deploy = function deploy() {
    if (this.renderer) this.renderer.deploy();
    this.deployed = true;
    return this;
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var _this$rules;

    (_this$rules = this.rules).update.apply(_this$rules, arguments);

    return this;
  }
  /**
   * Updates a single rule.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    this.rules.updateOne(rule, data, options);
    return this;
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    return this.rules.toString(options);
  };

  return StyleSheet;
}();

var PluginsRegistry =
/*#__PURE__*/
function () {
  function PluginsRegistry() {
    this.plugins = {
      internal: [],
      external: []
    };
    this.registry = {};
  }

  var _proto = PluginsRegistry.prototype;

  /**
   * Call `onCreateRule` hooks and return an object if returned by a hook.
   */
  _proto.onCreateRule = function onCreateRule(name, decl, options) {
    for (var i = 0; i < this.registry.onCreateRule.length; i++) {
      var rule = this.registry.onCreateRule[i](name, decl, options);
      if (rule) return rule;
    }

    return null;
  }
  /**
   * Call `onProcessRule` hooks.
   */
  ;

  _proto.onProcessRule = function onProcessRule(rule) {
    if (rule.isProcessed) return;
    var sheet = rule.options.sheet;

    for (var i = 0; i < this.registry.onProcessRule.length; i++) {
      this.registry.onProcessRule[i](rule, sheet);
    }

    if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
    rule.isProcessed = true;
  }
  /**
   * Call `onProcessStyle` hooks.
   */
  ;

  _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
    for (var i = 0; i < this.registry.onProcessStyle.length; i++) {
      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
    }
  }
  /**
   * Call `onProcessSheet` hooks.
   */
  ;

  _proto.onProcessSheet = function onProcessSheet(sheet) {
    for (var i = 0; i < this.registry.onProcessSheet.length; i++) {
      this.registry.onProcessSheet[i](sheet);
    }
  }
  /**
   * Call `onUpdate` hooks.
   */
  ;

  _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
    for (var i = 0; i < this.registry.onUpdate.length; i++) {
      this.registry.onUpdate[i](data, rule, sheet, options);
    }
  }
  /**
   * Call `onChangeValue` hooks.
   */
  ;

  _proto.onChangeValue = function onChangeValue(value, prop, rule) {
    var processedValue = value;

    for (var i = 0; i < this.registry.onChangeValue.length; i++) {
      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
    }

    return processedValue;
  }
  /**
   * Register a plugin.
   */
  ;

  _proto.use = function use(newPlugin, options) {
    if (options === void 0) {
      options = {
        queue: 'external'
      };
    }

    var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.

    if (plugins.indexOf(newPlugin) !== -1) {
      return;
    }

    plugins.push(newPlugin);
    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {
      for (var name in plugin) {
        if (name in registry) {
          registry[name].push(plugin[name]);
        } else {
           true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] Unknown hook \"" + name + "\".") : 0;
        }
      }

      return registry;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    });
  };

  return PluginsRegistry;
}();

/**
 * Sheets registry to access all instances in one place.
 */

var SheetsRegistry =
/*#__PURE__*/
function () {
  function SheetsRegistry() {
    this.registry = [];
  }

  var _proto = SheetsRegistry.prototype;

  /**
   * Register a Style Sheet.
   */
  _proto.add = function add(sheet) {
    var registry = this.registry;
    var index = sheet.options.index;
    if (registry.indexOf(sheet) !== -1) return;

    if (registry.length === 0 || index >= this.index) {
      registry.push(sheet);
      return;
    } // Find a position.


    for (var i = 0; i < registry.length; i++) {
      if (registry[i].options.index > index) {
        registry.splice(i, 0, sheet);
        return;
      }
    }
  }
  /**
   * Reset the registry.
   */
  ;

  _proto.reset = function reset() {
    this.registry = [];
  }
  /**
   * Remove a Style Sheet.
   */
  ;

  _proto.remove = function remove(sheet) {
    var index = this.registry.indexOf(sheet);
    this.registry.splice(index, 1);
  }
  /**
   * Convert all attached sheets to a CSS string.
   */
  ;

  _proto.toString = function toString(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        attached = _ref.attached,
        options = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_5__["default"])(_ref, ["attached"]);

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    var css = '';

    for (var i = 0; i < this.registry.length; i++) {
      var sheet = this.registry[i];

      if (attached != null && sheet.attached !== attached) {
        continue;
      }

      if (css) css += linebreak;
      css += sheet.toString(options);
    }

    return css;
  };

  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(SheetsRegistry, [{
    key: "index",

    /**
     * Current highest index number.
     */
    get: function get() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]);

  return SheetsRegistry;
}();

/**
 * This is a global sheets registry. Only DomRenderer will add sheets to it.
 * On the server one should use an own SheetsRegistry instance and add the
 * sheets to it, because you need to make sure to create a new registry for
 * each request in order to not leak sheets across requests.
 */

var sheets = new SheetsRegistry();

/* eslint-disable */

/**
 * Now that `globalThis` is available on most platforms
 * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)
 * we check for `globalThis` first. `globalThis` is necessary for jss
 * to run in Agoric's secure version of JavaScript (SES). Under SES,
 * `globalThis` exists, but `window`, `self`, and `Function('return
 * this')()` are all undefined for security reasons.
 *
 * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
 */
var globalThis$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();

var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
if (globalThis$1[ns] == null) globalThis$1[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
// the current version with just one short number and use it for classes generation
// we use a counter. Also it is more accurate, because user can manually reevaluate
// the module.

var moduleId = globalThis$1[ns]++;

var maxRules = 1e10;
/**
 * Returns a function which generates unique class names based on counters.
 * When new generator function is created, rule counter is reseted.
 * We need to reset the rule counter for SSR for each request.
 */

var createGenerateId = function createGenerateId(options) {
  if (options === void 0) {
    options = {};
  }

  var ruleCounter = 0;

  var generateId = function generateId(rule, sheet) {
    ruleCounter += 1;

    if (ruleCounter > maxRules) {
       true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] You might have a memory leak. Rule counter is at " + ruleCounter + ".") : 0;
    }

    var jssId = '';
    var prefix = '';

    if (sheet) {
      if (sheet.options.classNamePrefix) {
        prefix = sheet.options.classNamePrefix;
      }

      if (sheet.options.jss.id != null) {
        jssId = String(sheet.options.jss.id);
      }
    }

    if (options.minify) {
      // Using "c" because a number can't be the first char in a class name.
      return "" + (prefix || 'c') + moduleId + jssId + ruleCounter;
    }

    return prefix + rule.key + "-" + moduleId + (jssId ? "-" + jssId : '') + "-" + ruleCounter;
  };

  return generateId;
};

/**
 * Cache the value from the first time a function is called.
 */

var memoize = function memoize(fn) {
  var value;
  return function () {
    if (!value) value = fn();
    return value;
  };
};
/**
 * Get a style property value.
 */


var getPropertyValue = function getPropertyValue(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      return cssRule.attributeStyleMap.get(prop);
    }

    return cssRule.style.getPropertyValue(prop);
  } catch (err) {
    // IE may throw if property is unknown.
    return '';
  }
};
/**
 * Set a style property.
 */


var setProperty = function setProperty(cssRule, prop, value) {
  try {
    var cssValue = value;

    if (Array.isArray(value)) {
      cssValue = toCssValue(value);
    } // Support CSSTOM.


    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.set(prop, cssValue);
    } else {
      var indexOfImportantFlag = cssValue ? cssValue.indexOf('!important') : -1;
      var cssValueWithoutImportantFlag = indexOfImportantFlag > -1 ? cssValue.substr(0, indexOfImportantFlag - 1) : cssValue;
      cssRule.style.setProperty(prop, cssValueWithoutImportantFlag, indexOfImportantFlag > -1 ? 'important' : '');
    }
  } catch (err) {
    // IE may throw if property is unknown.
    return false;
  }

  return true;
};
/**
 * Remove a style property.
 */


var removeProperty = function removeProperty(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.delete(prop);
    } else {
      cssRule.style.removeProperty(prop);
    }
  } catch (err) {
     true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] DOMException \"" + err.message + "\" was thrown. Tried to remove property \"" + prop + "\".") : 0;
  }
};
/**
 * Set the selector.
 */


var setSelector = function setSelector(cssRule, selectorText) {
  cssRule.selectorText = selectorText; // Return false if setter was not successful.
  // Currently works in chrome only.

  return cssRule.selectorText === selectorText;
};
/**
 * Gets the `head` element upon the first call and caches it.
 * We assume it can't be null.
 */


var getHead = memoize(function () {
  return document.querySelector('head');
});
/**
 * Find attached sheet with an index higher than the passed one.
 */

function findHigherSheet(registry, options) {
  for (var i = 0; i < registry.length; i++) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find attached sheet with the highest index.
 */


function findHighestSheet(registry, options) {
  for (var i = registry.length - 1; i >= 0; i--) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find a comment with "jss" inside.
 */


function findCommentNode(text) {
  var head = getHead();

  for (var i = 0; i < head.childNodes.length; i++) {
    var node = head.childNodes[i];

    if (node.nodeType === 8 && node.nodeValue.trim() === text) {
      return node;
    }
  }

  return null;
}
/**
 * Find a node before which we can insert the sheet.
 */


function findPrevNode(options) {
  var registry = sheets.registry;

  if (registry.length > 0) {
    // Try to insert before the next higher sheet.
    var sheet = findHigherSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element
      };
    } // Otherwise insert after the last attached.


    sheet = findHighestSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element.nextSibling
      };
    }
  } // Try to find a comment placeholder if registry is empty.


  var insertionPoint = options.insertionPoint;

  if (insertionPoint && typeof insertionPoint === 'string') {
    var comment = findCommentNode(insertionPoint);

    if (comment) {
      return {
        parent: comment.parentNode,
        node: comment.nextSibling
      };
    } // If user specifies an insertion point and it can't be found in the document -
    // bad specificity issues may appear.


     true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] Insertion point \"" + insertionPoint + "\" not found.") : 0;
  }

  return false;
}
/**
 * Insert style element into the DOM.
 */


function insertStyle(style, options) {
  var insertionPoint = options.insertionPoint;
  var nextNode = findPrevNode(options);

  if (nextNode !== false && nextNode.parent) {
    nextNode.parent.insertBefore(style, nextNode.node);
    return;
  } // Works with iframes and any node types.


  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
    var insertionPointElement = insertionPoint;
    var parentNode = insertionPointElement.parentNode;
    if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);else  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, '[JSS] Insertion point is not in the DOM.') : 0;
    return;
  }

  getHead().appendChild(style);
}
/**
 * Read jss nonce setting from the page if the user has set it.
 */


var getNonce = memoize(function () {
  var node = document.querySelector('meta[property="csp-nonce"]');
  return node ? node.getAttribute('content') : null;
});

var _insertRule = function insertRule(container, rule, index) {
  try {
    if ('insertRule' in container) {
      container.insertRule(rule, index);
    } // Keyframes rule.
    else if ('appendRule' in container) {
        container.appendRule(rule);
      }
  } catch (err) {
     true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] " + err.message) : 0;
    return false;
  }

  return container.cssRules[index];
};

var getValidRuleInsertionIndex = function getValidRuleInsertionIndex(container, index) {
  var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong

  if (index === undefined || index > maxIndex) {
    // eslint-disable-next-line no-param-reassign
    return maxIndex;
  }

  return index;
};

var createStyle = function createStyle() {
  var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we
  // insert rules after we insert the style tag.
  // It seems to kick-off the source order specificity algorithm.

  el.textContent = '\n';
  return el;
};

var DomRenderer =
/*#__PURE__*/
function () {
  // Will be empty if link: true option is not set, because
  // it is only for use together with insertRule API.
  function DomRenderer(sheet) {
    this.getPropertyValue = getPropertyValue;
    this.setProperty = setProperty;
    this.removeProperty = removeProperty;
    this.setSelector = setSelector;
    this.hasInsertedRules = false;
    this.cssRules = [];
    // There is no sheet when the renderer is used from a standalone StyleRule.
    if (sheet) sheets.add(sheet);
    this.sheet = sheet;

    var _ref = this.sheet ? this.sheet.options : {},
        media = _ref.media,
        meta = _ref.meta,
        element = _ref.element;

    this.element = element || createStyle();
    this.element.setAttribute('data-jss', '');
    if (media) this.element.setAttribute('media', media);
    if (meta) this.element.setAttribute('data-meta', meta);
    var nonce = getNonce();
    if (nonce) this.element.setAttribute('nonce', nonce);
  }
  /**
   * Insert style element into render tree.
   */


  var _proto = DomRenderer.prototype;

  _proto.attach = function attach() {
    // In the case the element node is external and it is already in the DOM.
    if (this.element.parentNode || !this.sheet) return;
    insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
    // most browsers create a new CSSStyleSheet, except of all IEs.

    var deployed = Boolean(this.sheet && this.sheet.deployed);

    if (this.hasInsertedRules && deployed) {
      this.hasInsertedRules = false;
      this.deploy();
    }
  }
  /**
   * Remove style element from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.sheet) return;
    var parentNode = this.element.parentNode;
    if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.
    // Though IE will keep them and we need a consistent behavior.

    if (this.sheet.options.link) {
      this.cssRules = [];
      this.element.textContent = '\n';
    }
  }
  /**
   * Inject CSS string into element.
   */
  ;

  _proto.deploy = function deploy() {
    var sheet = this.sheet;
    if (!sheet) return;

    if (sheet.options.link) {
      this.insertRules(sheet.rules);
      return;
    }

    this.element.textContent = "\n" + sheet.toString() + "\n";
  }
  /**
   * Insert RuleList into an element.
   */
  ;

  _proto.insertRules = function insertRules(rules, nativeParent) {
    for (var i = 0; i < rules.index.length; i++) {
      this.insertRule(rules.index[i], i, nativeParent);
    }
  }
  /**
   * Insert a rule into element.
   */
  ;

  _proto.insertRule = function insertRule(rule, index, nativeParent) {
    if (nativeParent === void 0) {
      nativeParent = this.element.sheet;
    }

    if (rule.rules) {
      var parent = rule;
      var latestNativeParent = nativeParent;

      if (rule.type === 'conditional' || rule.type === 'keyframes') {
        var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.


        latestNativeParent = _insertRule(nativeParent, parent.toString({
          children: false
        }), _insertionIndex);

        if (latestNativeParent === false) {
          return false;
        }

        this.refCssRule(rule, _insertionIndex, latestNativeParent);
      }

      this.insertRules(parent.rules, latestNativeParent);
      return latestNativeParent;
    }

    var ruleStr = rule.toString();
    if (!ruleStr) return false;
    var insertionIndex = getValidRuleInsertionIndex(nativeParent, index);

    var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);

    if (nativeRule === false) {
      return false;
    }

    this.hasInsertedRules = true;
    this.refCssRule(rule, insertionIndex, nativeRule);
    return nativeRule;
  };

  _proto.refCssRule = function refCssRule(rule, index, cssRule) {
    rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules
    // like rules inside media queries or keyframes

    if (rule.options.parent instanceof StyleSheet) {
      this.cssRules.splice(index, 0, cssRule);
    }
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.deleteRule = function deleteRule(cssRule) {
    var sheet = this.element.sheet;
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    sheet.deleteRule(index);
    this.cssRules.splice(index, 1);
    return true;
  }
  /**
   * Get index of a CSS Rule.
   */
  ;

  _proto.indexOf = function indexOf(cssRule) {
    return this.cssRules.indexOf(cssRule);
  }
  /**
   * Generate a new CSS rule and replace the existing one.
   */
  ;

  _proto.replaceRule = function replaceRule(cssRule, rule) {
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    this.element.sheet.deleteRule(index);
    this.cssRules.splice(index, 1);
    return this.insertRule(rule, index);
  }
  /**
   * Get all rules elements.
   */
  ;

  _proto.getRules = function getRules() {
    return this.element.sheet.cssRules;
  };

  return DomRenderer;
}();

var instanceCounter = 0;

var Jss =
/*#__PURE__*/
function () {
  function Jss(options) {
    this.id = instanceCounter++;
    this.version = "10.10.0";
    this.plugins = new PluginsRegistry();
    this.options = {
      id: {
        minify: false
      },
      createGenerateId: createGenerateId,
      Renderer: is_in_browser__WEBPACK_IMPORTED_MODULE_1__["default"] ? DomRenderer : null,
      plugins: []
    };
    this.generateId = createGenerateId({
      minify: false
    });

    for (var i = 0; i < plugins.length; i++) {
      this.plugins.use(plugins[i], {
        queue: 'internal'
      });
    }

    this.setup(options);
  }
  /**
   * Prepares various options, applies plugins.
   * Should not be used twice on the same instance, because there is no plugins
   * deduplication logic.
   */


  var _proto = Jss.prototype;

  _proto.setup = function setup(options) {
    if (options === void 0) {
      options = {};
    }

    if (options.createGenerateId) {
      this.options.createGenerateId = options.createGenerateId;
    }

    if (options.id) {
      this.options.id = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, this.options.id, options.id);
    }

    if (options.createGenerateId || options.id) {
      this.generateId = this.options.createGenerateId(this.options.id);
    }

    if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;

    if ('Renderer' in options) {
      this.options.Renderer = options.Renderer;
    } // eslint-disable-next-line prefer-spread


    if (options.plugins) this.use.apply(this, options.plugins);
    return this;
  }
  /**
   * Create a Style Sheet.
   */
  ;

  _proto.createStyleSheet = function createStyleSheet(styles, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        index = _options.index;

    if (typeof index !== 'number') {
      index = sheets.index === 0 ? 0 : sheets.index + 1;
    }

    var sheet = new StyleSheet(styles, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      jss: this,
      generateId: options.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: index
    }));
    this.plugins.onProcessSheet(sheet);
    return sheet;
  }
  /**
   * Detach the Style Sheet and remove it from the registry.
   */
  ;

  _proto.removeStyleSheet = function removeStyleSheet(sheet) {
    sheet.detach();
    sheets.remove(sheet);
    return this;
  }
  /**
   * Create a rule without a Style Sheet.
   * [Deprecated] will be removed in the next major version.
   */
  ;

  _proto.createRule = function createRule$1(name, style, options) {
    if (style === void 0) {
      style = {};
    }

    if (options === void 0) {
      options = {};
    }

    // Enable rule without name for inline styles.
    if (typeof name === 'object') {
      return this.createRule(undefined, name, style);
    }

    var ruleOptions = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      name: name,
      jss: this,
      Renderer: this.options.Renderer
    });

    if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
    if (!ruleOptions.classes) ruleOptions.classes = {};
    if (!ruleOptions.keyframes) ruleOptions.keyframes = {};

    var rule = createRule(name, style, ruleOptions);

    if (rule) this.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Register plugin. Passed function will be invoked with a rule instance.
   */
  ;

  _proto.use = function use() {
    var _this = this;

    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }

    plugins.forEach(function (plugin) {
      _this.plugins.use(plugin);
    });
    return this;
  };

  return Jss;
}();

var createJss = function createJss(options) {
  return new Jss(options);
};

/**
 * SheetsManager is like a WeakMap which is designed to count StyleSheet
 * instances and attach/detach automatically.
 * Used in react-jss.
 */

var SheetsManager =
/*#__PURE__*/
function () {
  function SheetsManager() {
    this.length = 0;
    this.sheets = new WeakMap();
  }

  var _proto = SheetsManager.prototype;

  _proto.get = function get(key) {
    var entry = this.sheets.get(key);
    return entry && entry.sheet;
  };

  _proto.add = function add(key, sheet) {
    if (this.sheets.has(key)) return;
    this.length++;
    this.sheets.set(key, {
      sheet: sheet,
      refs: 0
    });
  };

  _proto.manage = function manage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs === 0) {
        entry.sheet.attach();
      }

      entry.refs++;
      return entry.sheet;
    }

    (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] SheetsManager: can't find sheet to manage");
    return undefined;
  };

  _proto.unmanage = function unmanage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs > 0) {
        entry.refs--;
        if (entry.refs === 0) entry.sheet.detach();
      }
    } else {
      (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "SheetsManager: can't find sheet to unmanage");
    }
  };

  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(SheetsManager, [{
    key: "size",
    get: function get() {
      return this.length;
    }
  }]);

  return SheetsManager;
}();

/**
* Export a constant indicating if this browser has CSSTOM support.
* https://developers.google.com/web/updates/2018/03/cssom
*/
var hasCSSTOMSupport = typeof CSS === 'object' && CSS != null && 'number' in CSS;

/**
 * Extracts a styles object with only props that contain function values.
 */
function getDynamicStyles(styles) {
  var to = null;

  for (var key in styles) {
    var value = styles[key];
    var type = typeof value;

    if (type === 'function') {
      if (!to) to = {};
      to[key] = value;
    } else if (type === 'object' && value !== null && !Array.isArray(value)) {
      var extracted = getDynamicStyles(value);

      if (extracted) {
        if (!to) to = {};
        to[key] = extracted;
      }
    }
  }

  return to;
}

/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */
var index = createJss();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);



/***/ }),

/***/ "../../../node_modules/sdp/sdp.js":
/*!****************************************!*\
  !*** ../../../node_modules/sdp/sdp.js ***!
  \****************************************/
/***/ ((module) => {

/* eslint-env node */


// SDP helpers.
const SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substring(2, 12);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(line => line.trim());
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  const parts = blob.split('\nm=');
  return parts.map((part, index) => (index > 0 ?
    'm=' + part : part).trim() + '\r\n');
};

// Returns the session description.
SDPUtils.getDescription = function(blob) {
  const sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// Returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  const sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
// Input can be prefixed with a=.
SDPUtils.parseCandidate = function(line) {
  let parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  const candidate = {
    foundation: parts[0],
    component: {1: 'rtp', 2: 'rtcp'}[parts[1]] || parts[1],
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    address: parts[4], // address is an alias for ip.
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7],
  };

  for (let i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compatibility.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag. Don't overwrite.
        if (candidate[parts[i]] === undefined) {
          candidate[parts[i]] = parts[i + 1];
        }
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
// This does not include the a= prefix!
SDPUtils.writeCandidate = function(candidate) {
  const sdp = [];
  sdp.push(candidate.foundation);

  const component = candidate.component;
  if (component === 'rtp') {
    sdp.push(1);
  } else if (component === 'rtcp') {
    sdp.push(2);
  } else {
    sdp.push(component);
  }
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.address || candidate.ip);
  sdp.push(candidate.port);

  const type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress);
    sdp.push('rport');
    sdp.push(candidate.relatedPort);
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// Sample input:
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substring(14).split(' ');
};

// Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  let parts = line.substring(9).split(' ');
  const parsed = {
    payloadType: parseInt(parts.shift(), 10), // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  // legacy alias, got renamed back to channels in ORTC.
  parsed.numChannels = parsed.channels;
  return parsed;
};

// Generates a rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  const channels = codec.channels || codec.numChannels || 1;
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (channels !== 1 ? '/' + channels : '') + '\r\n';
};

// Parses a extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  const parts = line.substring(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1],
    attributes: parts.slice(2).join(' '),
  };
};

// Generates an extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
        ? '/' + headerExtension.direction
        : '') +
      ' ' + headerExtension.uri +
      (headerExtension.attributes ? ' ' + headerExtension.attributes : '') +
      '\r\n';
};

// Parses a fmtp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  const parsed = {};
  let kv;
  const parts = line.substring(line.indexOf(' ') + 1).split(';');
  for (let j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  let line = '';
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    const params = [];
    Object.keys(codec.parameters).forEach(param => {
      if (codec.parameters[param] !== undefined) {
        params.push(param + '=' + codec.parameters[param]);
      } else {
        params.push(param);
      }
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  const parts = line.substring(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' '),
  };
};

// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  let lines = '';
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(fb => {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses a RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  const sp = line.indexOf(' ');
  const parts = {
    ssrc: parseInt(line.substring(7, sp), 10),
  };
  const colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substring(sp + 1, colon);
    parts.value = line.substring(colon + 1);
  } else {
    parts.attribute = line.substring(sp + 1);
  }
  return parts;
};

// Parse a ssrc-group line (see RFC 5576). Sample input:
// a=ssrc-group:semantics 12 34
SDPUtils.parseSsrcGroup = function(line) {
  const parts = line.substring(13).split(' ');
  return {
    semantics: parts.shift(),
    ssrcs: parts.map(ssrc => parseInt(ssrc, 10)),
  };
};

// Extracts the MID (RFC 5888) from a media section.
// Returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substring(6);
  }
};

// Parses a fingerprint line for DTLS-SRTP.
SDPUtils.parseFingerprint = function(line) {
  const parts = line.substring(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1].toUpperCase(), // the definition is upper-case in RFC 4572.
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint),
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  let sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(fp => {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};

// Parses a=crypto lines into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members
SDPUtils.parseCryptoLine = function(line) {
  const parts = line.substring(9).split(' ');
  return {
    tag: parseInt(parts[0], 10),
    cryptoSuite: parts[1],
    keyParams: parts[2],
    sessionParams: parts.slice(3),
  };
};

SDPUtils.writeCryptoLine = function(parameters) {
  return 'a=crypto:' + parameters.tag + ' ' +
    parameters.cryptoSuite + ' ' +
    (typeof parameters.keyParams === 'object'
      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)
      : parameters.keyParams) +
    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +
    '\r\n';
};

// Parses the crypto key parameters into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*
SDPUtils.parseCryptoKeyParams = function(keyParams) {
  if (keyParams.indexOf('inline:') !== 0) {
    return null;
  }
  const parts = keyParams.substring(7).split('|');
  return {
    keyMethod: 'inline',
    keySalt: parts[0],
    lifeTime: parts[1],
    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,
    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,
  };
};

SDPUtils.writeCryptoKeyParams = function(keyParams) {
  return keyParams.keyMethod + ':'
    + keyParams.keySalt +
    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +
    (keyParams.mkiValue && keyParams.mkiLength
      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength
      : '');
};

// Extracts all SDES parameters.
SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {
  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=crypto:');
  return lines.map(SDPUtils.parseCryptoLine);
};

// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=ice-ufrag:')[0];
  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=ice-pwd:')[0];
  if (!(ufrag && pwd)) {
    return null;
  }
  return {
    usernameFragment: ufrag.substring(12),
    password: pwd.substring(10),
  };
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
  if (params.iceLite) {
    sdp += 'a=ice-lite\r\n';
  }
  return sdp;
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  const description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: [],
  };
  const lines = SDPUtils.splitLines(mediaSection);
  const mline = lines[0].split(' ');
  description.profile = mline[2];
  for (let i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    const pt = mline[i];
    const rtpmapline = SDPUtils.matchPrefix(
      mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      const codec = SDPUtils.parseRtpMap(rtpmapline);
      const fmtps = SDPUtils.matchPrefix(
        mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
        mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:* ')
    .map(SDPUtils.parseRtcpFb);
  description.codecs.forEach(codec => {
    wildcardRtcpFb.forEach(fb=> {
      const duplicate = codec.rtcpFeedback.find(existingFeedback => {
        return existingFeedback.type === fb.type &&
          existingFeedback.parameter === fb.parameter;
      });
      if (!duplicate) {
        codec.rtcpFeedback.push(fb);
      }
    });
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  let sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' ' + (caps.profile || 'UDP/TLS/RTP/SAVPF') + ' ';
  sdp += caps.codecs.map(codec => {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(codec => {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  let maxptime = 0;
  caps.codecs.forEach(codec => {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }

  if (caps.headerExtensions) {
    caps.headerExtensions.forEach(extension => {
      sdp += SDPUtils.writeExtmap(extension);
    });
  }
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  const encodingParameters = [];
  const description = SDPUtils.parseRtpParameters(mediaSection);
  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(parts => parts.attribute === 'cname');
  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  let secondarySsrc;

  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
    .map(line => {
      const parts = line.substring(17).split(' ');
      return parts.map(part => parseInt(part, 10));
    });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(codec => {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      let encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10),
      };
      if (primarySsrc && secondarySsrc) {
        encParam.rtx = {ssrc: secondarySsrc};
      }
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: primarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red',
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc,
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substring(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(params => {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  const rtcpParameters = {};

  // Gets the first SSRC. Note that with RTX there might be multiple
  // SSRCs.
  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(obj => obj.attribute === 'cname')[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrbute.
  // Note that Edge does not support unmuxed RTCP.
  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

SDPUtils.writeRtcpParameters = function(rtcpParameters) {
  let sdp = '';
  if (rtcpParameters.reducedSize) {
    sdp += 'a=rtcp-rsize\r\n';
  }
  if (rtcpParameters.mux) {
    sdp += 'a=rtcp-mux\r\n';
  }
  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {
    sdp += 'a=ssrc:' + rtcpParameters.ssrc +
      ' cname:' + rtcpParameters.cname + '\r\n';
  }
  return sdp;
};


// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  let parts;
  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substring(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(msidParts => msidParts.attribute === 'msid');
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// SCTP
// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
// to draft-ietf-mmusic-sctp-sdp-05
SDPUtils.parseSctpDescription = function(mediaSection) {
  const mline = SDPUtils.parseMLine(mediaSection);
  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
  let maxMessageSize;
  if (maxSizeLine.length > 0) {
    maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);
  }
  if (isNaN(maxMessageSize)) {
    maxMessageSize = 65536;
  }
  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
  if (sctpPort.length > 0) {
    return {
      port: parseInt(sctpPort[0].substring(12), 10),
      protocol: mline.fmt,
      maxMessageSize,
    };
  }
  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');
  if (sctpMapLines.length > 0) {
    const parts = sctpMapLines[0]
      .substring(10)
      .split(' ');
    return {
      port: parseInt(parts[0], 10),
      protocol: parts[1],
      maxMessageSize,
    };
  }
};

// SCTP
// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
// support by now receiving in this format, unless we originally parsed
// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
// protocol of DTLS/SCTP -- without UDP/ or TCP/)
SDPUtils.writeSctpDescription = function(media, sctp) {
  let output = [];
  if (media.protocol !== 'DTLS/SCTP') {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctp-port:' + sctp.port + '\r\n',
    ];
  } else {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n',
    ];
  }
  if (sctp.maxMessageSize !== undefined) {
    output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
  }
  return output.join('');
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 22);
};

// Write boiler plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
// sessUser is optional and defaults to 'thisisadapterortc'
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
  let sessionId;
  const version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  const user = sessUser || 'thisisadapterortc';
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=' + user + ' ' + sessionId + ' ' + version +
        ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  const lines = SDPUtils.splitLines(mediaSection);
  for (let i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substring(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  const lines = SDPUtils.splitLines(mediaSection);
  const mline = lines[0].split(' ');
  return mline[0].substring(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  const lines = SDPUtils.splitLines(mediaSection);
  const parts = lines[0].substring(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' '),
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  const parts = line.substring(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5],
  };
};

// a very naive interpretation of a valid SDP.
SDPUtils.isValidSDP = function(blob) {
  if (typeof blob !== 'string' || blob.length === 0) {
    return false;
  }
  const lines = SDPUtils.splitLines(blob);
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
      return false;
    }
    // TODO: check the modifier a bit more.
  }
  return true;
};

// Expose public methods.
if (true) {
  module.exports = SDPUtils;
}


/***/ }),

/***/ "../../../node_modules/tiny-warning/dist/tiny-warning.esm.js":
/*!*******************************************************************!*\
  !*** ../../../node_modules/tiny-warning/dist/tiny-warning.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var isProduction = "development" === 'production';
function warning(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }

    var text = "Warning: " + message;

    if (typeof console !== 'undefined') {
      console.warn(text);
    }

    try {
      throw Error(text);
    } catch (x) {}
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (warning);


/***/ }),

/***/ "../../library/dist/esm/AFK/AFKController.js":
/*!***************************************************!*\
  !*** ../../library/dist/esm/AFK/AFKController.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AFKController: () => (/* binding */ AFKController)
/* harmony export */ });
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Util/EventEmitter */ "../../library/dist/esm/Util/EventEmitter.js");
// Copyright Epic Games, Inc. All Rights Reserved.



class AFKController {
    constructor(config, pixelStreaming, onDismissAfk) {
        // time out logic details
        this.active = false;
        this.countdownActive = false;
        this.warnTimer = undefined;
        this.countDown = 0;
        this.countDownTimer = undefined;
        this.config = config;
        this.pixelStreaming = pixelStreaming;
        this.onDismissAfk = onDismissAfk;
        this.onAFKTimedOutCallback = () => {
            console.log('AFK timed out, did you want to override this callback?');
        };
    }
    /**
     * The methods that occur when an afk event listener is clicked
     */
    onAfkClick() {
        clearInterval(this.countDownTimer);
        if (this.active || this.countdownActive) {
            this.startAfkWarningTimer();
            this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkWarningDeactivateEvent());
        }
    }
    /**
     * Start the warning timer if a timeout is set greater that 0 seconds
     */
    startAfkWarningTimer() {
        if (this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.NumericParameters.AFKTimeoutSecs) > 0 &&
            this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.AFKDetection)) {
            this.active = true;
        }
        else {
            this.active = false;
        }
        this.resetAfkWarningTimer();
    }
    /**
     * Stop the afk warning timer
     */
    stopAfkWarningTimer() {
        this.active = false;
        this.countdownActive = false;
        clearTimeout(this.warnTimer);
        clearInterval(this.countDownTimer);
    }
    /**
     * Pause the timer which when elapsed will warn the user they are inactive.
     */
    pauseAfkWarningTimer() {
        this.active = false;
    }
    /**
     * If the user interacts then reset the warning timer.
     */
    resetAfkWarningTimer() {
        if (this.active && this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.AFKDetection)) {
            clearTimeout(this.warnTimer);
            this.warnTimer = setTimeout(() => this.activateAfkEvent(), this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.NumericParameters.AFKTimeoutSecs) * 1000);
        }
    }
    /**
     * Show the AFK overlay and begin the countDown
     */
    activateAfkEvent() {
        // Pause the timer while the user is looking at the inactivity warning overlay
        this.pauseAfkWarningTimer();
        // instantiate a new overlay
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkWarningActivateEvent({
            countDown: this.countDown,
            dismissAfk: this.onDismissAfk
        }));
        // update our countDown timer and overlay contents
        this.countDown = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.NumericParameters.AFKCountdownSecs);
        this.countdownActive = true;
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkWarningUpdateEvent({ countDown: this.countDown }));
        // if we are in locked mouse exit pointerlock
        if (!this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.HoveringMouseMode)) {
            // minor hack to alleviate ios not supporting pointerlock
            if (document.exitPointerLock) {
                document.exitPointerLock();
            }
        }
        // reset our countDown interval accordingly
        this.countDownTimer = setInterval(() => {
            this.countDown--;
            if (this.countDown == 0) {
                // The user failed to click so hide the overlay and disconnect them.
                this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkTimedOutEvent());
                this.onAFKTimedOutCallback();
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_2__.Logger.Info('You have been disconnected due to inactivity');
                // switch off the afk feature as stream has closed
                this.stopAfkWarningTimer();
            }
            else {
                this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkWarningUpdateEvent({ countDown: this.countDown }));
            }
        }, 1000);
    }
}
//# sourceMappingURL=AFKController.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/Config.js":
/*!***********************************************!*\
  !*** ../../library/dist/esm/Config/Config.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Config: () => (/* binding */ Config),
/* harmony export */   ControlSchemeType: () => (/* binding */ ControlSchemeType),
/* harmony export */   Flags: () => (/* binding */ Flags),
/* harmony export */   NumericParameters: () => (/* binding */ NumericParameters),
/* harmony export */   OptionParameters: () => (/* binding */ OptionParameters),
/* harmony export */   TextParameters: () => (/* binding */ TextParameters),
/* harmony export */   isFlagId: () => (/* binding */ isFlagId),
/* harmony export */   isNumericId: () => (/* binding */ isNumericId),
/* harmony export */   isOptionId: () => (/* binding */ isOptionId),
/* harmony export */   isTextId: () => (/* binding */ isTextId)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _SettingFlag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SettingFlag */ "../../library/dist/esm/Config/SettingFlag.js");
/* harmony import */ var _SettingNumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SettingNumber */ "../../library/dist/esm/Config/SettingNumber.js");
/* harmony import */ var _SettingText__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingText */ "../../library/dist/esm/Config/SettingText.js");
/* harmony import */ var _SettingOption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SettingOption */ "../../library/dist/esm/Config/SettingOption.js");
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Util/EventEmitter */ "../../library/dist/esm/Util/EventEmitter.js");
/* harmony import */ var _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util/BrowserUtils */ "../../library/dist/esm/Util/BrowserUtils.js");
// Copyright Epic Games, Inc. All Rights Reserved.







/**
 * A collection of flags that can be toggled and are core to all Pixel Streaming experiences.
 * These are used in the `Config.Flags` map.
 */
class Flags {
}
Flags.AutoConnect = 'AutoConnect';
Flags.AutoPlayVideo = 'AutoPlayVideo';
Flags.AFKDetection = 'TimeoutIfIdle';
Flags.HoveringMouseMode = 'HoveringMouse';
Flags.ForceMonoAudio = 'ForceMonoAudio';
Flags.ForceTURN = 'ForceTURN';
Flags.FakeMouseWithTouches = 'FakeMouseWithTouches';
Flags.IsQualityController = 'ControlsQuality';
Flags.MatchViewportResolution = 'MatchViewportRes';
Flags.StartVideoMuted = 'StartVideoMuted';
Flags.SuppressBrowserKeys = 'SuppressBrowserKeys';
Flags.UseMic = 'UseMic';
Flags.UseModalForTextInput = 'UseModalForTextInput';
Flags.UseCamera = 'UseCamera';
Flags.KeyboardInput = 'KeyboardInput';
Flags.MouseInput = 'MouseInput';
Flags.TouchInput = 'TouchInput';
Flags.GamepadInput = 'GamepadInput';
Flags.XRControllerInput = 'XRControllerInput';
Flags.WaitForStreamer = 'WaitForStreamer';
Flags.HideUI = 'HideUI';
Flags.EnableCaptureTimeExt = 'EnableCaptureTimeExt';
Flags.BrowserSendOffer = 'BrowserSendOffer';
Flags.LatencyCSV = 'LatencyCSV';
const isFlagId = (id) => Object.getOwnPropertyNames(Flags).some((name) => Flags[name] === id);
/**
 * A collection of numeric parameters that are core to all Pixel Streaming experiences.
 *
 */
class NumericParameters {
}
NumericParameters.AFKTimeoutSecs = 'AFKTimeout';
NumericParameters.AFKCountdownSecs = 'AFKCountdown';
NumericParameters.MinQP = 'MinQP';
NumericParameters.MaxQP = 'MaxQP';
NumericParameters.MinQuality = 'MinQuality';
NumericParameters.MaxQuality = 'MaxQuality';
NumericParameters.CompatQualityMin = 'CompatQualityMin';
NumericParameters.CompatQualityMax = 'CompatQualityMax';
NumericParameters.WebRTCFPS = 'WebRTCFPS';
NumericParameters.WebRTCMinBitrate = 'WebRTCMinBitrate';
NumericParameters.WebRTCMaxBitrate = 'WebRTCMaxBitrate';
NumericParameters.MaxReconnectAttempts = 'MaxReconnectAttempts';
NumericParameters.StreamerAutoJoinInterval = 'StreamerAutoJoinInterval';
NumericParameters.KeepaliveDelay = 'KeepaliveDelay';
const isNumericId = (id) => Object.getOwnPropertyNames(NumericParameters).some((name) => NumericParameters[name] === id);
/**
 * A collection of textual parameters that are core to all Pixel Streaming experiences.
 *
 */
class TextParameters {
}
TextParameters.SignallingServerUrl = 'ss';
const isTextId = (id) => Object.getOwnPropertyNames(TextParameters).some((name) => TextParameters[name] === id);
/**
 * A collection of enum based parameters that are core to all Pixel Streaming experiences.
 *
 */
class OptionParameters {
}
OptionParameters.PreferredCodec = 'PreferredCodec';
OptionParameters.StreamerId = 'StreamerId';
OptionParameters.PreferredQuality = 'PreferredQuality';
const isOptionId = (id) => Object.getOwnPropertyNames(OptionParameters).some((name) => OptionParameters[name] === id);
class Config {
    // ------------ Settings -----------------
    constructor(config = {}) {
        /* A map of flags that can be toggled - options that can be set in the application - e.g. Use Mic? */
        this.flags = new Map();
        /* A map of numerical settings - options that can be in the application - e.g. MinBitrate */
        this.numericParameters = new Map();
        /* A map of text settings - e.g. signalling server url */
        this.textParameters = new Map();
        /* A map of enum based settings - e.g. preferred codec */
        this.optionParameters = new Map();
        const { initialSettings, useUrlParams, webSocketProtocols } = config;
        this._useUrlParams = !!useUrlParams;
        this._webSocketProtocols = webSocketProtocols;
        this.populateDefaultSettings(this._useUrlParams, initialSettings);
    }
    /**
     * True if reading configuration initial values from URL parameters, and
     * persisting changes in URL when changed.
     */
    get useUrlParams() {
        return this._useUrlParams;
    }
    /**
     * Gets a protocol or list of protocols to pass to the websocket if set.
     */
    get webSocketProtocols() {
        return this._webSocketProtocols;
    }
    /**
     * Populate the default settings for a Pixel Streaming application
     */
    populateDefaultSettings(useUrlParams, settings) {
        /**
         * Text Parameters
         */
        this.textParameters.set(TextParameters.SignallingServerUrl, new _SettingText__WEBPACK_IMPORTED_MODULE_0__.SettingText(TextParameters.SignallingServerUrl, 'Signalling url', 'Url of the signalling server', settings && Object.prototype.hasOwnProperty.call(settings, TextParameters.SignallingServerUrl)
            ? settings[TextParameters.SignallingServerUrl]
            : (location.protocol === 'https:' ? 'wss://' : 'ws://') +
                window.location.hostname +
                // for readability, we omit the port if it's 80
                (window.location.port === '80' || window.location.port === ''
                    ? ''
                    : `:${window.location.port}`), useUrlParams));
        this.optionParameters.set(OptionParameters.StreamerId, new _SettingOption__WEBPACK_IMPORTED_MODULE_1__.SettingOption(OptionParameters.StreamerId, 'Streamer ID', 'The ID of the streamer to stream.', settings && Object.prototype.hasOwnProperty.call(settings, OptionParameters.StreamerId)
            ? settings[OptionParameters.StreamerId]
            : '', settings && Object.prototype.hasOwnProperty.call(settings, OptionParameters.StreamerId)
            ? [settings[OptionParameters.StreamerId]]
            : undefined, useUrlParams));
        const getDefaultVideoCodec = function () {
            const videoCodecs = _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_2__.BrowserUtils.getSupportedVideoCodecs();
            // If only one option, then select that.
            if (videoCodecs.length == 1) {
                return videoCodecs[0];
            }
            else if (videoCodecs.length > 0) {
                const defaultCodec = videoCodecs[0];
                for (const codec of videoCodecs) {
                    if (codec.startsWith('H264')) {
                        return codec;
                    }
                }
                return defaultCodec;
            }
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error('Could not find any reasonable video codec to assign as a default.');
            return '';
        };
        const matchSpecifiedCodecToClosestSupported = function (specifiedCodec) {
            const browserSupportedCodecs = _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_2__.BrowserUtils.getSupportedVideoCodecs();
            // Codec supplied in url param is an exact match for the browser codec.
            // (e.g. H264 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f)
            if (browserSupportedCodecs.includes(specifiedCodec)) {
                return specifiedCodec;
            }
            // Try to match the start of whatever is passed into the url parameter with what the browser supports
            for (const browserCodec of browserSupportedCodecs) {
                if (browserCodec.startsWith(specifiedCodec)) {
                    return browserCodec;
                }
            }
            // If we weren't able to match, just return the codec as from the URL as-is.
            return specifiedCodec;
        };
        /**
         * Enum Parameters
         */
        this.optionParameters.set(OptionParameters.PreferredCodec, new _SettingOption__WEBPACK_IMPORTED_MODULE_1__.SettingOption(OptionParameters.PreferredCodec, 'Preferred Codec', 'The preferred codec to be used during codec negotiation', settings && Object.prototype.hasOwnProperty.call(settings, OptionParameters.PreferredCodec)
            ? matchSpecifiedCodecToClosestSupported(settings[OptionParameters.PreferredCodec])
            : getDefaultVideoCodec(), _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_2__.BrowserUtils.getSupportedVideoCodecs(), useUrlParams, matchSpecifiedCodecToClosestSupported));
        this.optionParameters.set(OptionParameters.PreferredQuality, new _SettingOption__WEBPACK_IMPORTED_MODULE_1__.SettingOption(OptionParameters.PreferredQuality, 'Preferred Quality', 'The preferred quality of the stream (only applicable when using the SFU)', settings && Object.prototype.hasOwnProperty.call(settings, OptionParameters.PreferredQuality)
            ? settings[OptionParameters.PreferredQuality]
            : 'Default', ['Default'], useUrlParams));
        /**
         * Boolean parameters
         */
        this.flags.set(Flags.AutoConnect, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.AutoConnect, 'Auto connect to stream', 'Whether we should attempt to auto connect to the signalling server or show a click to start prompt.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.AutoConnect)
            ? settings[Flags.AutoConnect]
            : false, useUrlParams));
        this.flags.set(Flags.AutoPlayVideo, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.AutoPlayVideo, 'Auto play video', 'When video is ready automatically start playing it as opposed to showing a play button.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.AutoPlayVideo)
            ? settings[Flags.AutoPlayVideo]
            : true, useUrlParams));
        this.flags.set(Flags.UseMic, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.UseMic, 'Use microphone', 'Make browser request microphone access and open an input audio track.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.UseMic)
            ? settings[Flags.UseMic]
            : false, useUrlParams));
        this.flags.set(Flags.UseModalForTextInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.UseModalForTextInput, 'Use modal for text input', 'When entering input into a streamed UE text widget, use an input modal.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.UseModalForTextInput)
            ? settings[Flags.UseModalForTextInput]
            : true, useUrlParams));
        this.flags.set(Flags.UseCamera, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.UseCamera, 'Use webcam', 'Make browser request webcam access and open a input video track.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.UseCamera)
            ? settings[Flags.UseCamera]
            : false, useUrlParams));
        this.flags.set(Flags.StartVideoMuted, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.StartVideoMuted, 'Start video muted', 'Video will start muted if true.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.StartVideoMuted)
            ? settings[Flags.StartVideoMuted]
            : false, useUrlParams));
        this.flags.set(Flags.SuppressBrowserKeys, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.SuppressBrowserKeys, 'Suppress browser keys', 'Suppress certain browser keys that we use in UE, for example F5 to show shader complexity instead of refresh the page.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.SuppressBrowserKeys)
            ? settings[Flags.SuppressBrowserKeys]
            : true, useUrlParams));
        this.flags.set(Flags.IsQualityController, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.IsQualityController, 'Is quality controller?', 'True if this peer controls stream quality', settings && Object.prototype.hasOwnProperty.call(settings, Flags.IsQualityController)
            ? settings[Flags.IsQualityController]
            : true, useUrlParams));
        this.flags.set(Flags.ForceMonoAudio, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.ForceMonoAudio, 'Force mono audio', 'Force browser to request mono audio in the SDP', settings && Object.prototype.hasOwnProperty.call(settings, Flags.ForceMonoAudio)
            ? settings[Flags.ForceMonoAudio]
            : false, useUrlParams));
        this.flags.set(Flags.ForceTURN, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.ForceTURN, 'Force TURN', 'Only generate TURN/Relayed ICE candidates.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.ForceTURN)
            ? settings[Flags.ForceTURN]
            : false, useUrlParams));
        this.flags.set(Flags.AFKDetection, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.AFKDetection, 'AFK if idle', 'Timeout the experience if user is AFK for a period.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.AFKDetection)
            ? settings[Flags.AFKDetection]
            : false, useUrlParams));
        this.flags.set(Flags.MatchViewportResolution, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.MatchViewportResolution, 'Match viewport resolution', 'Pixel Streaming will be instructed to dynamically resize the video stream to match the size of the video element.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.MatchViewportResolution)
            ? settings[Flags.MatchViewportResolution]
            : false, useUrlParams));
        this.flags.set(Flags.HoveringMouseMode, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.HoveringMouseMode, 'Control Scheme: Locked Mouse', 'Either locked mouse, where the pointer is consumed by the video and locked to it, or hovering mouse, where the mouse is not consumed.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.HoveringMouseMode)
            ? settings[Flags.HoveringMouseMode]
            : false, useUrlParams, (isHoveringMouse, setting) => {
            setting.label = `Control Scheme: ${isHoveringMouse ? 'Hovering' : 'Locked'} Mouse`;
        }));
        this.flags.set(Flags.FakeMouseWithTouches, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.FakeMouseWithTouches, 'Fake mouse with touches', 'A single finger touch is converted into a mouse event. This allows a non-touch application to be controlled partially via a touch device.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.FakeMouseWithTouches)
            ? settings[Flags.FakeMouseWithTouches]
            : false, useUrlParams));
        this.flags.set(Flags.KeyboardInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.KeyboardInput, 'Keyboard input', 'If enabled, send keyboard events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.KeyboardInput)
            ? settings[Flags.KeyboardInput]
            : true, useUrlParams));
        this.flags.set(Flags.MouseInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.MouseInput, 'Mouse input', 'If enabled, send mouse events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.MouseInput)
            ? settings[Flags.MouseInput]
            : true, useUrlParams));
        this.flags.set(Flags.TouchInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.TouchInput, 'Touch input', 'If enabled, send touch events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.TouchInput)
            ? settings[Flags.TouchInput]
            : true, useUrlParams));
        this.flags.set(Flags.GamepadInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.GamepadInput, 'Gamepad input', 'If enabled, send gamepad events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.GamepadInput)
            ? settings[Flags.GamepadInput]
            : true, useUrlParams));
        this.flags.set(Flags.XRControllerInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.XRControllerInput, 'XR controller input', 'If enabled, send XR controller events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.XRControllerInput)
            ? settings[Flags.XRControllerInput]
            : true, useUrlParams));
        this.flags.set(Flags.WaitForStreamer, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.WaitForStreamer, 'Wait for streamer', 'Will continue trying to connect to the first streamer available.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.WaitForStreamer)
            ? settings[Flags.WaitForStreamer]
            : true, useUrlParams));
        this.flags.set(Flags.HideUI, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.HideUI, 'Hide the UI overlay', 'Will hide all UI overlay details', settings && Object.prototype.hasOwnProperty.call(settings, Flags.HideUI)
            ? settings[Flags.HideUI]
            : false, useUrlParams));
        this.flags.set(Flags.EnableCaptureTimeExt, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.EnableCaptureTimeExt, 'Enable abs-capture-time', 'Enables the abs-capture-time RTP header extension', settings && Object.prototype.hasOwnProperty.call(settings, Flags.EnableCaptureTimeExt)
            ? settings[Flags.EnableCaptureTimeExt]
            : false, useUrlParams));
        this.flags.set(Flags.BrowserSendOffer, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.BrowserSendOffer, 'Browser send offer (4.27 ONLY)', 'Browser will initiate the WebRTC handshake by sending the offer to the streamer (4.27 ONLY)', settings && Object.prototype.hasOwnProperty.call(settings, Flags.BrowserSendOffer)
            ? settings[Flags.BrowserSendOffer]
            : false, useUrlParams));
        this.flags.set(Flags.LatencyCSV, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.LatencyCSV, 'Export Latency CSV', 'Shows a button in the stats panel that allows to run a latency test and export the results to a CSV file.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.LatencyCSV)
            ? settings[Flags.LatencyCSV]
            : false, useUrlParams));
        /**
         * Numeric parameters
         */
        this.numericParameters.set(NumericParameters.AFKTimeoutSecs, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.AFKTimeoutSecs, 'AFK timeout', 'The time (in seconds) it takes for the application to time out if AFK timeout is enabled.', 0 /*min*/, null /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.AFKTimeoutSecs)
            ? settings[NumericParameters.AFKTimeoutSecs]
            : 120 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.AFKCountdownSecs, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.AFKCountdownSecs, 'AFK countdown', 'The time (in seconds) for a user to respond before the stream is ended after an AFK timeout.', 10 /*min*/, null /*max*/, 10 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MaxReconnectAttempts, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MaxReconnectAttempts, 'Max Reconnects', 'Maximum number of reconnects the application will attempt when a streamer disconnects.', 0 /*min*/, 999 /*max*/, settings &&
            Object.prototype.hasOwnProperty.call(settings, NumericParameters.MaxReconnectAttempts)
            ? settings[NumericParameters.MaxReconnectAttempts]
            : 3 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MinQP, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MinQP, 'Min QP', 'The lower bound for the quantization parameter (QP) of the encoder. 0 = Best quality, 51 = worst quality.', 0 /*min*/, 51 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.MinQP)
            ? settings[NumericParameters.MinQP]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MaxQP, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MaxQP, 'Max QP', 'The upper bound for the quantization parameter (QP) of the encoder. 0 = Best quality, 51 = worst quality.', 0 /*min*/, 51 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.MaxQP)
            ? settings[NumericParameters.MaxQP]
            : 51 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MinQuality, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MinQuality, 'Min Quality', 'The lower bound for the quality factor of the encoder. 0 = Worst quality, 100 = Best quality.', 0 /*min*/, 100 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.MinQuality)
            ? settings[NumericParameters.MinQuality]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MaxQuality, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MaxQuality, 'Max Quality', 'The upper bound for the quality factor of the encoder. 0 = Worst quality, 100 = Best quality.', 0 /*min*/, 100 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.MaxQuality)
            ? settings[NumericParameters.MaxQuality]
            : 100 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.CompatQualityMin, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.CompatQualityMin, 'Min Quality', 'The lower bound for encoding quality. 0 = Worst, 100 = Best.', 0 /*min*/, 100 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.CompatQualityMin)
            ? settings[NumericParameters.CompatQualityMin]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.CompatQualityMax, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.CompatQualityMax, 'Max Quality', 'The upper bound for encoding quality. 0 = Worst, 100 = Best.', 0 /*min*/, 100 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.CompatQualityMax)
            ? settings[NumericParameters.CompatQualityMax]
            : 100 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.WebRTCFPS, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.WebRTCFPS, 'Max FPS', 'The maximum FPS that WebRTC will try to transmit frames at.', 1 /*min*/, 999 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.WebRTCFPS)
            ? settings[NumericParameters.WebRTCFPS]
            : 60 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.WebRTCMinBitrate, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.WebRTCMinBitrate, 'Min Bitrate (kbps)', 'The minimum bitrate that WebRTC should use.', 0 /*min*/, 500000 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.WebRTCMinBitrate)
            ? settings[NumericParameters.WebRTCMinBitrate]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.WebRTCMaxBitrate, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.WebRTCMaxBitrate, 'Max Bitrate (kbps)', 'The maximum bitrate that WebRTC should use.', 0 /*min*/, 500000 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.WebRTCMaxBitrate)
            ? settings[NumericParameters.WebRTCMaxBitrate]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.StreamerAutoJoinInterval, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.StreamerAutoJoinInterval, 'Streamer Auto Join Interval (ms)', 'Delay between retries when waiting for an available streamer.', 500 /*min*/, 900000 /*max*/, settings &&
            Object.prototype.hasOwnProperty.call(settings, NumericParameters.StreamerAutoJoinInterval)
            ? settings[NumericParameters.StreamerAutoJoinInterval]
            : 3000 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.KeepaliveDelay, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.KeepaliveDelay, 'Connection Keepalive delay', 'Delay between keepalive pings to the signalling server.', 0 /*min*/, 900000 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.KeepaliveDelay)
            ? settings[NumericParameters.KeepaliveDelay]
            : 30000 /*value*/, useUrlParams));
    }
    /**
     * Add a callback to fire when the numeric setting is toggled.
     * @param id The id of the flag.
     * @param onChangedListener The callback to fire when the numeric value changes.
     */
    _addOnNumericSettingChangedListener(id, onChangedListener) {
        if (this.numericParameters.has(id)) {
            this.numericParameters.get(id).addOnChangedListener(onChangedListener);
        }
    }
    _addOnOptionSettingChangedListener(id, onChangedListener) {
        if (this.optionParameters.has(id)) {
            this.optionParameters.get(id).addOnChangedListener(onChangedListener);
        }
    }
    /**
     * @param id The id of the numeric setting we are interested in getting a value for.
     * @returns The numeric value stored in the parameter with the passed id.
     */
    getNumericSettingValue(id) {
        if (this.numericParameters.has(id)) {
            return this.numericParameters.get(id).number;
        }
        else {
            throw new Error(`There is no numeric setting with the id of ${id}`);
        }
    }
    /**
     * @param id The id of the text setting we are interested in getting a value for.
     * @returns The text value stored in the parameter with the passed id.
     */
    getTextSettingValue(id) {
        if (this.textParameters.has(id)) {
            return this.textParameters.get(id).value;
        }
        else {
            throw new Error(`There is no numeric setting with the id of ${id}`);
        }
    }
    /**
     * Set number in the setting.
     * @param id The id of the numeric setting we are interested in.
     * @param value The numeric value to set.
     */
    setNumericSetting(id, value) {
        if (this.numericParameters.has(id)) {
            this.numericParameters.get(id).number = value;
        }
        else {
            throw new Error(`There is no numeric setting with the id of ${id}`);
        }
    }
    /**
     * Add a callback to fire when the flag is toggled.
     * @param id The id of the flag.
     * @param onChangeListener The callback to fire when the value changes.
     */
    _addOnSettingChangedListener(id, onChangeListener) {
        if (this.flags.has(id)) {
            this.flags.get(id).onChange = onChangeListener;
        }
    }
    /**
     * Add a callback to fire when the text is changed.
     * @param id The id of the flag.
     * @param onChangeListener The callback to fire when the value changes.
     */
    _addOnTextSettingChangedListener(id, onChangeListener) {
        if (this.textParameters.has(id)) {
            this.textParameters.get(id).onChange = onChangeListener;
        }
    }
    /**
     * Get the option which has the given id.
     * @param id The id of the option.
     * @returns The SettingOption object matching id
     */
    getSettingOption(id) {
        return this.optionParameters.get(id);
    }
    /**
     * Get the value of the configuration flag which has the given id.
     * @param id The unique id for the flag.
     * @returns True if the flag is enabled.
     */
    isFlagEnabled(id) {
        return this.flags.get(id).flag;
    }
    /**
     * Set flag to be enabled/disabled.
     * @param id The id of the flag to toggle.
     * @param flagEnabled True if the flag should be enabled.
     */
    setFlagEnabled(id, flagEnabled) {
        if (!this.flags.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot toggle flag called ${id} - it does not exist in the Config.flags map.`);
        }
        else {
            this.flags.get(id).flag = flagEnabled;
        }
    }
    /**
     * Set the text setting.
     * @param id The id of the setting
     * @param settingValue The value to set in the setting.
     */
    setTextSetting(id, settingValue) {
        if (!this.textParameters.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot set text setting called ${id} - it does not exist in the Config.textParameters map.`);
        }
        else {
            this.textParameters.get(id).text = settingValue;
        }
    }
    /**
     * Set the option setting list of options.
     * @param id The id of the setting
     * @param settingOptions The values the setting could take
     */
    setOptionSettingOptions(id, settingOptions) {
        if (!this.optionParameters.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot set text setting called ${id} - it does not exist in the Config.optionParameters map.`);
        }
        else {
            this.optionParameters.get(id).options = settingOptions;
        }
    }
    /**
     * Set option enum settings selected option.
     * @param id The id of the setting
     * @param settingOptions The value to select out of all the options
     */
    setOptionSettingValue(id, settingValue) {
        if (!this.optionParameters.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot set text setting called ${id} - it does not exist in the Config.enumParameters map.`);
        }
        else {
            const optionSetting = this.optionParameters.get(id);
            const existingOptions = optionSetting.options;
            if (!existingOptions.includes(settingValue)) {
                existingOptions.push(settingValue);
                optionSetting.options = existingOptions;
            }
            optionSetting.selected = settingValue;
        }
    }
    /**
     * Set the label for the flag.
     * @param id The id of the flag.
     * @param label The new label to use for the flag.
     */
    setFlagLabel(id, label) {
        if (!this.flags.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot set label for flag called ${id} - it does not exist in the Config.flags map.`);
        }
        else {
            this.flags.get(id).label = label;
        }
    }
    /**
     * Set a subset of all settings in one function call.
     *
     * @param settings A (partial) list of settings to set
     */
    setSettings(settings) {
        for (const key of Object.keys(settings)) {
            if (isFlagId(key)) {
                this.setFlagEnabled(key, settings[key]);
            }
            else if (isNumericId(key)) {
                this.setNumericSetting(key, settings[key]);
            }
            else if (isTextId(key)) {
                this.setTextSetting(key, settings[key]);
            }
            else if (isOptionId(key)) {
                this.setOptionSettingValue(key, settings[key]);
            }
        }
    }
    /**
     * Get all settings
     * @returns All setting values as an object with setting ids as keys
     */
    getSettings() {
        const settings = {};
        for (const [key, value] of this.flags.entries()) {
            settings[key] = value.flag;
        }
        for (const [key, value] of this.numericParameters.entries()) {
            settings[key] = value.number;
        }
        for (const [key, value] of this.textParameters.entries()) {
            settings[key] = value.text;
        }
        for (const [key, value] of this.optionParameters.entries()) {
            settings[key] = value.selected;
        }
        return settings;
    }
    /**
     * Get all Flag settings as an array.
     * @returns All SettingFlag objects
     */
    getFlags() {
        return Array.from(this.flags.values());
    }
    /**
     * Get all Text settings as an array.
     * @returns All SettingText objects
     */
    getTextSettings() {
        return Array.from(this.textParameters.values());
    }
    /**
     * Get all Number settings as an array.
     * @returns All SettingNumber objects
     */
    getNumericSettings() {
        return Array.from(this.numericParameters.values());
    }
    /**
     * Get all Option settings as an array.
     * @returns All SettingOption objects
     */
    getOptionSettings() {
        return Array.from(this.optionParameters.values());
    }
    /**
     * Emit events when settings change.
     * @param eventEmitter
     */
    _registerOnChangeEvents(eventEmitter) {
        for (const key of this.flags.keys()) {
            const flag = this.flags.get(key);
            if (flag) {
                flag.onChangeEmit = (newValue) => eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__.SettingsChangedEvent({
                    id: flag.id,
                    type: 'flag',
                    value: newValue,
                    target: flag
                }));
            }
        }
        for (const key of this.numericParameters.keys()) {
            const number = this.numericParameters.get(key);
            if (number) {
                number.onChangeEmit = (newValue) => eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__.SettingsChangedEvent({
                    id: number.id,
                    type: 'number',
                    value: newValue,
                    target: number
                }));
            }
        }
        for (const key of this.textParameters.keys()) {
            const text = this.textParameters.get(key);
            if (text) {
                text.onChangeEmit = (newValue) => eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__.SettingsChangedEvent({
                    id: text.id,
                    type: 'text',
                    value: newValue,
                    target: text
                }));
            }
        }
        for (const key of this.optionParameters.keys()) {
            const option = this.optionParameters.get(key);
            if (option) {
                option.onChangeEmit = (newValue) => eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__.SettingsChangedEvent({
                    id: option.id,
                    type: 'option',
                    value: newValue,
                    target: option
                }));
            }
        }
    }
}
/**
 * The enum associated with the mouse being locked or hovering
 */
var ControlSchemeType;
(function (ControlSchemeType) {
    ControlSchemeType[ControlSchemeType["LockedMouse"] = 0] = "LockedMouse";
    ControlSchemeType[ControlSchemeType["HoveringMouse"] = 1] = "HoveringMouse";
})(ControlSchemeType || (ControlSchemeType = {}));
//# sourceMappingURL=Config.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/SettingBase.js":
/*!****************************************************!*\
  !*** ../../library/dist/esm/Config/SettingBase.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingBase: () => (/* binding */ SettingBase)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Base class for a setting that has a text label and an arbitrary setting value it stores.
 */
class SettingBase {
    constructor(id, label, description, defaultSettingValue, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        this.parseURLParams();
        this.onChange = defaultOnChangeListener;
        this.onChangeEmit = () => {
            /* Do nothing, to be overridden. */
        };
        this.id = id;
        this.description = description;
        this.label = label;
        this.value = defaultSettingValue;
    }
    /**
     * Set the label text for the setting.
     * @param label setting label.
     */
    set label(inLabel) {
        this._label = inLabel;
        this.onChangeEmit(this._value);
    }
    /**
     * @returns The label text for the setting.
     */
    get label() {
        return this._label;
    }
    /**
     * @return The setting's value.
     */
    get value() {
        return this._value;
    }
    /**
     * Update the setting's stored value.
     * @param inValue The new value for the setting.
     */
    set value(inValue) {
        this._value = inValue;
        this.onChange(this._value, this);
        this.onChangeEmit(this._value);
    }
    /**
     * Persist the setting value in URL.
     */
    updateURLParams() {
        if (this.useUrlParams) {
            // set url params
            const urlParams = new URLSearchParams(window.location.search);
            const valueString = this.getValueAsString();
            let set = false;
            for (const [name, _value] of urlParams) {
                if (name.toLowerCase() == this.id.toLowerCase()) {
                    urlParams.set(name, valueString);
                    set = true;
                    break;
                }
            }
            if (!set) {
                urlParams.set(this.id, valueString);
            }
            window.history.replaceState({}, '', urlParams.toString() !== '' ? `${location.pathname}?${urlParams}` : `${location.pathname}`);
        }
    }
    /**
     * Allows sub types to provide their value for the url search params.
     */
    getValueAsString() {
        return '';
    }
    parseURLParams() {
        this._urlParams = {};
        const params = new URLSearchParams(window.location.search);
        for (const [name, value] of params) {
            this._urlParams[name.toLowerCase()] = value;
        }
    }
    hasURLParam(name) {
        return name.toLowerCase() in this._urlParams;
    }
    getURLParam(name) {
        if (this.hasURLParam(name)) {
            return this._urlParams[name.toLowerCase()];
        }
        return '';
    }
}
//# sourceMappingURL=SettingBase.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/SettingFlag.js":
/*!****************************************************!*\
  !*** ../../library/dist/esm/Config/SettingFlag.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingFlag: () => (/* binding */ SettingFlag)
/* harmony export */ });
/* harmony import */ var _SettingBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingBase */ "../../library/dist/esm/Config/SettingBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * A boolean flag setting object with a text label.
 */
class SettingFlag extends _SettingBase__WEBPACK_IMPORTED_MODULE_0__.SettingBase {
    constructor(id, label, description, defaultFlagValue, useUrlParams, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        super(id, label, description, defaultFlagValue, defaultOnChangeListener);
        if (!useUrlParams || !this.hasURLParam(this.id)) {
            this.flag = defaultFlagValue;
        }
        else {
            // parse flag from url parameters
            const urlParamFlag = this.getURLParam(this.id);
            this.flag = urlParamFlag.toLowerCase() != 'false';
        }
        this.useUrlParams = useUrlParams;
    }
    getValueAsString() {
        return this.flag ? 'true' : 'false';
    }
    /**
     * Enables this flag.
     */
    enable() {
        this.flag = true;
    }
    /**
     * @return The setting's value.
     */
    get flag() {
        return !!this.value;
    }
    /**
     * Update the setting's stored value.
     * @param inValue The new value for the setting.
     */
    set flag(inValue) {
        this.value = inValue;
    }
}
//# sourceMappingURL=SettingFlag.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/SettingNumber.js":
/*!******************************************************!*\
  !*** ../../library/dist/esm/Config/SettingNumber.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingNumber: () => (/* binding */ SettingNumber)
/* harmony export */ });
/* harmony import */ var _SettingBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingBase */ "../../library/dist/esm/Config/SettingBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * A number setting object with a text label. Min and max limit the range of allowed values.
 */
class SettingNumber extends _SettingBase__WEBPACK_IMPORTED_MODULE_0__.SettingBase {
    constructor(id, label, description, min, max, defaultNumber, useUrlParams, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        super(id, label, description, defaultNumber, defaultOnChangeListener);
        this._min = min;
        this._max = max;
        // attempt to read the number from the url params
        if (!useUrlParams || !this.hasURLParam(this.id)) {
            this.number = defaultNumber;
        }
        else {
            const parsedValue = Number.parseFloat(this.getURLParam(this.id));
            this.number = Number.isNaN(parsedValue) ? defaultNumber : parsedValue;
        }
        this.useUrlParams = useUrlParams;
    }
    getValueAsString() {
        return this.number.toString();
    }
    /**
     * Set the number value (will be clamped within range).
     */
    set number(newNumber) {
        this.value = this.clamp(newNumber);
    }
    /**
     * @returns The number stored.
     */
    get number() {
        return this.value;
    }
    /**
     * Clamps a number between the min and max values (inclusive).
     * @param inNumber The number to clamp.
     * @returns The clamped number.
     */
    clamp(inNumber) {
        if (this._min == null && this._max == null) {
            return inNumber;
        }
        else if (this._min == null) {
            return Math.min(this._max, inNumber);
        }
        else if (this._max == null) {
            return Math.max(this._min, inNumber);
        }
        else {
            return Math.max(Math.min(this._max, inNumber), this._min);
        }
    }
    /**
     * Returns the minimum value
     * @returns The minimum value
     */
    get min() {
        return this._min;
    }
    /**
     * Returns the maximum value
     * @returns The maximum value
     */
    get max() {
        return this._max;
    }
    /**
     * Add a change listener to the number object.
     */
    addOnChangedListener(onChangedFunc) {
        this.onChange = onChangedFunc;
    }
}
//# sourceMappingURL=SettingNumber.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/SettingOption.js":
/*!******************************************************!*\
  !*** ../../library/dist/esm/Config/SettingOption.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingOption: () => (/* binding */ SettingOption)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _SettingBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingBase */ "../../library/dist/esm/Config/SettingBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * An Option setting object with a text label. Allows you to specify an array of options and select one of them.
 */
class SettingOption extends _SettingBase__WEBPACK_IMPORTED_MODULE_0__.SettingBase {
    constructor(id, label, description, defaultTextValue, options, useUrlParams, defaultUrlParamResolver = function (value) {
        /* Return the string as-is by default */
        return value;
    }, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        super(id, label, description, defaultTextValue, defaultOnChangeListener);
        this._urlParamResolver = defaultUrlParamResolver;
        const stringToMatch = this.hasURLParam(this.id)
            ? this._urlParamResolver(this.getURLParam(this.id))
            : defaultTextValue;
        this.options = options !== null && options !== void 0 ? options : [stringToMatch];
        this.selected = stringToMatch;
        this.useUrlParams = useUrlParams;
    }
    getValueAsString() {
        return this.selected;
    }
    /**
     * Add a change listener to the select element.
     */
    addOnChangedListener(onChangedFunc) {
        this.onChange = onChangedFunc;
    }
    /**
     * @returns All available options as an array
     */
    get options() {
        return this._options;
    }
    /**
     * Set options
     * @param values Array of options
     */
    set options(values) {
        this._options = values;
        this.onChangeEmit(this.selected);
    }
    /**
     * @returns Selected option as a string
     */
    get selected() {
        return this.value;
    }
    /**
     * Set selected option if it matches one of the available options
     * @param value Selected option
     */
    set selected(value) {
        if (value === undefined) {
            return;
        }
        // If options contains the value, then set that as selected
        if (this.options.includes(value)) {
            this.value = value;
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`Could not set "${value}" as the selected option for ${this.id} because it wasn't one of the options.`);
        }
    }
    /**
     * Set the url parameter resolver to do some transformation to the string value
     * that is extracted from the url parameters.
     * @param urlParam A function that transforms the extracted url parameter string for this setting to something else.
     */
    set urlParamResolver(value) {
        this._urlParamResolver = value;
    }
}
//# sourceMappingURL=SettingOption.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/SettingText.js":
/*!****************************************************!*\
  !*** ../../library/dist/esm/Config/SettingText.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingText: () => (/* binding */ SettingText)
/* harmony export */ });
/* harmony import */ var _SettingBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingBase */ "../../library/dist/esm/Config/SettingBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * A text setting object with a text label.
 */
class SettingText extends _SettingBase__WEBPACK_IMPORTED_MODULE_0__.SettingBase {
    constructor(id, label, description, defaultTextValue, useUrlParams, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        super(id, label, description, defaultTextValue, defaultOnChangeListener);
        if (!useUrlParams || !this.hasURLParam(this.id)) {
            this.text = defaultTextValue;
        }
        else {
            // parse flag from url parameters
            this.text = this.getURLParam(this.id);
        }
        this.useUrlParams = useUrlParams;
    }
    getValueAsString() {
        return this.text;
    }
    /**
     * @return The setting's value.
     */
    get text() {
        return this.value;
    }
    /**
     * Update the setting's stored value.
     * @param inValue The new value for the setting.
     */
    set text(inValue) {
        this.value = inValue;
    }
}
//# sourceMappingURL=SettingText.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/DataChannelController.js":
/*!*******************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/DataChannelController.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataChannelController: () => (/* binding */ DataChannelController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Handles the Sending and Receiving of messages to the UE Instance via the Data Channel
 */
class DataChannelController {
    constructor() {
        this.isReceivingFreezeFrame = false;
    }
    /**
     * return the current state of a datachannel controller instance
     * @returns the current DataChannelController instance
     */
    getDataChannelInstance() {
        return this;
    }
    /**
     * To Create and Set up a Data Channel
     * @param peerConnection - The RTC Peer Connection
     * @param label - Label of the Data Channel
     * @param datachannelOptions - Optional RTC DataChannel options
     */
    createDataChannel(peerConnection, label, datachannelOptions) {
        this.peerConnection = peerConnection;
        this.label = label;
        this.datachannelOptions = datachannelOptions;
        if (datachannelOptions == null) {
            this.datachannelOptions = {};
            this.datachannelOptions.ordered = true;
        }
        this.dataChannel = this.peerConnection.createDataChannel(this.label, this.datachannelOptions);
        this.setupDataChannel();
    }
    setupDataChannel() {
        //We Want an Array Buffer not a blob
        this.dataChannel.binaryType = 'arraybuffer';
        this.dataChannel.onopen = (ev) => this.handleOnOpen(ev);
        this.dataChannel.onclose = (ev) => this.handleOnClose(ev);
        this.dataChannel.onmessage = (ev) => this.handleOnMessage(ev);
        this.dataChannel.onerror = (ev) => this.handleOnError(ev);
    }
    /**
     * Handles when the Data Channel is opened
     */
    handleOnOpen(ev) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data Channel (${this.label}) opened.`);
        this.onOpen((_a = this.dataChannel) === null || _a === void 0 ? void 0 : _a.label, ev);
    }
    /**
     * Handles when the Data Channel is closed
     */
    handleOnClose(ev) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data Channel (${this.label}) closed.`);
        this.onClose((_a = this.dataChannel) === null || _a === void 0 ? void 0 : _a.label, ev);
    }
    /**
     * Handles when a message is received
     * @param event - Message Event
     */
    handleOnMessage(event) {
        // Higher log level to prevent log spam with messages received
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data Channel (${this.label}) message: ${event}`);
    }
    /**
     * Handles when an error is thrown
     * @param event - Error Event
     */
    handleOnError(event) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data Channel (${this.label}) error: ${event}`);
        this.onError((_a = this.dataChannel) === null || _a === void 0 ? void 0 : _a.label, event);
    }
    /**
     * Override to register onOpen handler
     * @param label Data channel label ("datachannel", "send-datachannel", "recv-datachannel")
     * @param ev event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onOpen(label, ev) {
        // empty default implementation
    }
    /**
     * Override to register onClose handler
     * @param label Data channel label ("datachannel", "send-datachannel", "recv-datachannel")
     * @param ev event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onClose(label, ev) {
        // empty default implementation
    }
    /**
     * Override to register onError handler
     * @param label Data channel label ("datachannel", "send-datachannel", "recv-datachannel")
     * @param ev event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onError(label, ev) {
        // empty default implementation
    }
}
//# sourceMappingURL=DataChannelController.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/DataChannelLatencyTestController.js":
/*!******************************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/DataChannelLatencyTestController.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataChannelLatencyTestController: () => (/* binding */ DataChannelLatencyTestController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _DataChannelLatencyTestResults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DataChannelLatencyTestResults */ "../../library/dist/esm/DataChannel/DataChannelLatencyTestResults.js");
// Copyright Epic Games, Inc. All Rights Reserved.


class DataChannelLatencyTestController {
    constructor(sink, callback) {
        this.intervalHandle = undefined;
        this.sink = sink;
        this.callback = callback;
        this.records = new Map();
        this.seq = 0;
    }
    start(config) {
        if (this.isRunning()) {
            return false;
        }
        this.startTime = Date.now();
        this.records.clear();
        this.intervalHandle = window.setInterval((() => {
            if (Date.now() - this.startTime >= config.duration) {
                this.stop();
            }
            else {
                this.sendRequest(config.requestSize, config.responseSize);
            }
        }).bind(this), Math.floor(1000 / config.rps));
        return true;
    }
    stop() {
        if (this.intervalHandle) {
            window.clearInterval(this.intervalHandle);
            this.intervalHandle = undefined;
            this.callback(this.produceResult());
        }
    }
    produceResult() {
        const resultRecords = new Map(this.records);
        return {
            records: resultRecords,
            dataChannelRtt: Math.ceil(Array.from(this.records.values()).reduce((acc, next) => {
                return acc + (next.playerReceivedTimestamp - next.playerSentTimestamp);
            }, 0) / this.records.size),
            playerToStreamerTime: Math.ceil(Array.from(this.records.values()).reduce((acc, next) => {
                return acc + (next.streamerReceivedTimestamp - next.playerSentTimestamp);
            }, 0) / this.records.size),
            streamerToPlayerTime: Math.ceil(Array.from(this.records.values()).reduce((acc, next) => {
                return acc + (next.playerReceivedTimestamp - next.streamerSentTimestamp);
            }, 0) / this.records.size),
            exportLatencyAsCSV: () => {
                let csv = 'Timestamp;RTT;PlayerToStreamer;StreamerToPlayer;\n';
                resultRecords.forEach((record) => {
                    csv += record.playerSentTimestamp + ';';
                    csv += record.playerReceivedTimestamp - record.playerSentTimestamp + ';';
                    csv += record.streamerReceivedTimestamp - record.playerSentTimestamp + ';';
                    csv += record.playerReceivedTimestamp - record.streamerSentTimestamp + ';';
                    csv += '\n';
                });
                return csv;
            }
        };
    }
    isRunning() {
        return !!this.intervalHandle;
    }
    receive(response) {
        if (!this.isRunning()) {
            return;
        }
        if (!response) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Error('Undefined response from server');
            return;
        }
        const record = this.records.get(response.Seq);
        if (record) {
            record.update(response);
        }
    }
    sendRequest(requestSize, responseSize) {
        const request = this.createRequest(requestSize, responseSize);
        const record = new _DataChannelLatencyTestResults__WEBPACK_IMPORTED_MODULE_1__.DataChannelLatencyTestRecord(request);
        this.records.set(record.seq, record);
        this.sink(request);
    }
    createRequest(requestSize, responseSize) {
        return {
            Seq: this.seq++,
            FillResponseSize: responseSize,
            Filler: requestSize ? 'A'.repeat(requestSize) : ''
        };
    }
}
//# sourceMappingURL=DataChannelLatencyTestController.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/DataChannelLatencyTestResults.js":
/*!***************************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/DataChannelLatencyTestResults.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataChannelLatencyTestRecord: () => (/* binding */ DataChannelLatencyTestRecord)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class DataChannelLatencyTestRecord {
    constructor(request) {
        this.seq = request.Seq;
        this.playerSentTimestamp = Date.now();
        this.requestFillerSize = request.Filler ? request.Filler.length : 0;
    }
    update(response) {
        this.playerReceivedTimestamp = Date.now();
        this.streamerReceivedTimestamp = response.ReceivedTimestamp;
        this.streamerSentTimestamp = response.SentTimestamp;
        this.responseFillerSize = response.Filler ? response.Filler.length : 0;
    }
}
//# sourceMappingURL=DataChannelLatencyTestResults.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/DataChannelSender.js":
/*!***************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/DataChannelSender.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataChannelSender: () => (/* binding */ DataChannelSender)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * A class for sending data channel messages
 */
class DataChannelSender {
    /**
     * @param dataChannelProvider - Data channel object type
     */
    constructor(dataChannelProvider) {
        this.dataChannelProvider = dataChannelProvider;
    }
    canSend() {
        return (this.dataChannelProvider.getDataChannelInstance().dataChannel !== undefined &&
            this.dataChannelProvider.getDataChannelInstance().dataChannel.readyState == 'open');
    }
    /**
     * Send Data over the Data channel to the UE Instance
     * @param data - Message Data Array Buffer
     */
    sendData(data) {
        // reset the afk inactivity
        const dataChannelInstance = this.dataChannelProvider.getDataChannelInstance();
        if (dataChannelInstance.dataChannel.readyState == 'open') {
            dataChannelInstance.dataChannel.send(data);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Message Sent: ${new Uint8Array(data)}`);
            this.resetAfkWarningTimerOnDataSend();
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Message Failed: ${new Uint8Array(data)}`);
        }
    }
    /**
     * An override method for resetting the Afk warning timer when data is sent over the data channel
     */
    resetAfkWarningTimerOnDataSend() {
        // Base Functionality: Do Nothing
    }
}
//# sourceMappingURL=DataChannelSender.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/InitialSettings.js":
/*!*************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/InitialSettings.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EncoderSettings: () => (/* binding */ EncoderSettings),
/* harmony export */   InitialSettings: () => (/* binding */ InitialSettings),
/* harmony export */   PixelStreamingSettings: () => (/* binding */ PixelStreamingSettings),
/* harmony export */   WebRTCSettings: () => (/* binding */ WebRTCSettings)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Latency Test Results Data
 */
class InitialSettings {
    constructor() {
        this.PixelStreamingSettings = new PixelStreamingSettings();
        this.EncoderSettings = new EncoderSettings();
        this.WebRTCSettings = new WebRTCSettings();
    }
    /**
     * Checks for compatibility with the FPS and MaxFPS stats between 4.27 and 5
     */
    ueCompatible() {
        if (this.WebRTCSettings.MaxFPS != null) {
            this.WebRTCSettings.FPS = this.WebRTCSettings.MaxFPS;
        }
    }
}
/**
 * A class for handling Pixel Streaming details
 */
class PixelStreamingSettings {
}
/**
 * A class for handling encoder stats
 */
class EncoderSettings {
}
/**
 * A class for handling web rtc stats
 */
class WebRTCSettings {
}
//# sourceMappingURL=InitialSettings.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/LatencyTestResults.js":
/*!****************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/LatencyTestResults.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LatencyTestResults: () => (/* binding */ LatencyTestResults)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Latency Test Results Data
 */
class LatencyTestResults {
    constructor() {
        //Fields Set from the latency payload regardless of version
        this.ReceiptTimeMs = null;
        this.TransmissionTimeMs = null;
        //Fields Set from the latency payload from 4.27.2
        this.PreCaptureTimeMs = null;
        this.PostCaptureTimeMs = null;
        this.PreEncodeTimeMs = null;
        this.PostEncodeTimeMs = null;
        //Fields Set from the latency payload from 5.0
        this.EncodeMs = null;
        this.CaptureToSendMs = null;
        //Fields Set when processed
        this.testStartTimeMs = 0;
        this.browserReceiptTimeMs = 0;
        //Fields set from calculations
        this.latencyExcludingDecode = 0;
        this.testDuration = 0;
        //ueLatency: number = 0;
        this.networkLatency = 0;
        this.browserSendLatency = 0;
        this.frameDisplayDeltaTimeMs = 0;
        this.endToEndLatency = 0;
        //uePixelStreamLatency: number = 0;
        this.encodeLatency = 0;
    }
    /**
     * Sets the Delta Time Milliseconds
     * @param DeltaTimeMs - Delta Time Milliseconds
     */
    setFrameDisplayDeltaTime(DeltaTimeMs) {
        if (this.frameDisplayDeltaTimeMs == 0) {
            this.frameDisplayDeltaTimeMs = Math.round(DeltaTimeMs);
        }
    }
    /**
     * Process the encoder times and set them
     */
    processFields() {
        if (this.EncodeMs == null && (this.PreEncodeTimeMs != null || this.PostEncodeTimeMs != null)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Setting Encode Ms \n ${this.PostEncodeTimeMs} \n ${this.PreEncodeTimeMs}`);
            this.EncodeMs = this.PostEncodeTimeMs - this.PreEncodeTimeMs;
        }
        if (this.CaptureToSendMs == null &&
            (this.PreCaptureTimeMs != null || this.PostCaptureTimeMs != null)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Setting CaptureToSendMs Ms \n ${this.PostCaptureTimeMs} \n ${this.PreCaptureTimeMs}`);
            this.CaptureToSendMs = this.PostCaptureTimeMs - this.PreCaptureTimeMs;
        }
    }
}
//# sourceMappingURL=LatencyTestResults.js.map

/***/ }),

/***/ "../../library/dist/esm/FreezeFrame/FreezeFrame.js":
/*!*********************************************************!*\
  !*** ../../library/dist/esm/FreezeFrame/FreezeFrame.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FreezeFrame: () => (/* binding */ FreezeFrame)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * A class for managing the freeze frame object
 */
class FreezeFrame {
    /**
     * Construct a freeze frame
     * @param rootDiv the div that a freeze frame element will be injected into
     */
    constructor(rootDiv) {
        this.freezeFrameHeight = 0;
        this.freezeFrameWidth = 0;
        this.rootDiv = rootDiv;
        // create the overlay
        this.rootElement = document.createElement('div');
        this.rootElement.id = 'freezeFrame';
        this.rootElement.style.display = 'none';
        this.rootElement.style.pointerEvents = 'none';
        this.rootElement.style.position = 'absolute';
        this.rootElement.style.zIndex = '20';
        // create the image place holder
        this.imageElement = document.createElement('img');
        this.imageElement.style.position = 'absolute';
        // append the image into the root element and append the element to the root div
        this.rootElement.appendChild(this.imageElement);
        this.rootDiv.appendChild(this.rootElement);
    }
    /**
     * Set the freeze frame element for showing
     */
    setElementForShow() {
        this.rootElement.style.display = 'block';
    }
    /**
     * Set the freeze frame element for hiding
     */
    setElementForHide() {
        this.rootElement.style.display = 'none';
    }
    /**
     * Update the freeze frames image source
     * @param jpeg - the freeze frame image as a byte array data
     */
    updateImageElementSource(jpeg) {
        const base64 = btoa(jpeg.reduce((data, byte) => data + String.fromCharCode(byte), ''));
        this.imageElement.src = 'data:image/jpeg;base64,' + base64;
    }
    /**
     * Set the dimensions for the freeze frame from the element and resize it
     */
    setDimensionsFromElementAndResize() {
        this.freezeFrameHeight = this.imageElement.naturalHeight;
        this.freezeFrameWidth = this.imageElement.naturalWidth;
        this.resize();
    }
    /**
     * Resize a freeze frame element
     */
    resize() {
        if (this.freezeFrameWidth !== 0 && this.freezeFrameHeight !== 0) {
            let displayWidth = 0;
            let displayHeight = 0;
            let displayTop = 0;
            let displayLeft = 0;
            const parentAspectRatio = this.rootDiv.clientWidth / this.rootDiv.clientHeight;
            const videoAspectRatio = this.freezeFrameWidth / this.freezeFrameHeight;
            if (parentAspectRatio < videoAspectRatio) {
                displayWidth = this.rootDiv.clientWidth;
                displayHeight = Math.floor(this.rootDiv.clientWidth / videoAspectRatio);
                displayTop = Math.floor((this.rootDiv.clientHeight - displayHeight) * 0.5);
                displayLeft = 0;
            }
            else {
                displayWidth = Math.floor(this.rootDiv.clientHeight * videoAspectRatio);
                displayHeight = this.rootDiv.clientHeight;
                displayTop = 0;
                displayLeft = Math.floor((this.rootDiv.clientWidth - displayWidth) * 0.5);
            }
            this.rootElement.style.width = this.rootDiv.offsetWidth + 'px';
            this.rootElement.style.height = this.rootDiv.offsetHeight + 'px';
            this.rootElement.style.left = 0 + 'px';
            this.rootElement.style.top = 0 + 'px';
            this.imageElement.style.width = displayWidth + 'px';
            this.imageElement.style.height = displayHeight + 'px';
            this.imageElement.style.left = displayLeft + 'px';
            this.imageElement.style.top = displayTop + 'px';
        }
    }
}
//# sourceMappingURL=FreezeFrame.js.map

/***/ }),

/***/ "../../library/dist/esm/FreezeFrame/FreezeFrameController.js":
/*!*******************************************************************!*\
  !*** ../../library/dist/esm/FreezeFrame/FreezeFrameController.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FreezeFrameController: () => (/* binding */ FreezeFrameController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _FreezeFrame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FreezeFrame */ "../../library/dist/esm/FreezeFrame/FreezeFrame.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * A class for controlling freeze frame functionality
 */
class FreezeFrameController {
    /**
     * Construct a freeze frame controller
     * @param rootDiv - the div that a freeze frame element will be injected into
     */
    constructor(rootDiv) {
        this.receiving = false;
        this.size = 0;
        this.jpeg = undefined;
        this.valid = false;
        this.freezeFrameDelay = 50;
        this.freezeFrame = new _FreezeFrame__WEBPACK_IMPORTED_MODULE_0__.FreezeFrame(rootDiv);
    }
    /**
     * Show the freeze frame if it is valid
     */
    showFreezeFrame() {
        if (this.valid) {
            this.freezeFrame.setElementForShow();
        }
    }
    /**
     * Hide the freeze frame and set the validity to false
     */
    hideFreezeFrame() {
        this.valid = false;
        this.freezeFrame.setElementForHide();
    }
    /**
     * Update the freeze frames image source and load it
     * @param jpeg - the freeze frame image as a byte array data
     * @param onLoadCallBack - a call back for managing if the play overlay needs to be shown or not
     */
    updateFreezeFrameAndShow(jpeg, onLoadCallBack) {
        this.freezeFrame.updateImageElementSource(jpeg);
        this.freezeFrame.imageElement.onload = () => {
            this.freezeFrame.setDimensionsFromElementAndResize();
            onLoadCallBack();
        };
    }
    /**
     * Process the new freeze frame image and update it
     * @param view - the freeze frame image as a byte array data
     * @param onLoadCallBack - a call back for managing if the play overlay needs to be shown or not
     */
    processFreezeFrameMessage(view, onLoadCallBack) {
        // Reset freeze frame if we got a freeze frame message and we are not "receiving" yet.
        if (!this.receiving) {
            this.receiving = true;
            this.valid = false;
            this.size = 0;
            this.jpeg = undefined;
        }
        // Extract total size of freeze frame (across all chunks)
        this.size = new DataView(view.slice(1, 5).buffer).getInt32(0, true);
        // Get the jpeg part of the payload
        const jpegBytes = view.slice(1 + 4);
        // Append to existing jpeg that holds the freeze frame
        if (this.jpeg) {
            const jpeg = new Uint8Array(this.jpeg.length + jpegBytes.length);
            jpeg.set(this.jpeg, 0);
            jpeg.set(jpegBytes, this.jpeg.length);
            this.jpeg = jpeg;
        }
        // No existing freeze frame jpeg, make one
        else {
            this.jpeg = jpegBytes;
            this.receiving = true;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(`received first chunk of freeze frame: ${this.jpeg.length}/${this.size}`);
        }
        // Finished receiving freeze frame, we can show it now
        if (this.jpeg.length === this.size) {
            this.receiving = false;
            this.valid = true;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(`received complete freeze frame ${this.size}`);
            this.updateFreezeFrameAndShow(this.jpeg, onLoadCallBack);
        }
        // We received more data than the freeze frame payload message indicate (this is an error)
        else if (this.jpeg.length > this.size) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`received bigger freeze frame than advertised: ${this.jpeg.length}/${this.size}`);
            this.jpeg = undefined;
            this.receiving = false;
        }
    }
}
//# sourceMappingURL=FreezeFrameController.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/GamepadController.js":
/*!**********************************************************!*\
  !*** ../../library/dist/esm/Inputs/GamepadController.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GamepadController: () => (/* binding */ GamepadController),
/* harmony export */   GamepadLayout: () => (/* binding */ GamepadLayout)
/* harmony export */ });
/* harmony import */ var _GamepadTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GamepadTypes */ "../../library/dist/esm/Inputs/GamepadTypes.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Gamepad layout codes enum
 */
var GamepadLayout;
(function (GamepadLayout) {
    GamepadLayout[GamepadLayout["RightClusterBottomButton"] = 0] = "RightClusterBottomButton";
    GamepadLayout[GamepadLayout["RightClusterRightButton"] = 1] = "RightClusterRightButton";
    GamepadLayout[GamepadLayout["RightClusterLeftButton"] = 2] = "RightClusterLeftButton";
    GamepadLayout[GamepadLayout["RightClusterTopButton"] = 3] = "RightClusterTopButton";
    GamepadLayout[GamepadLayout["LeftShoulder"] = 4] = "LeftShoulder";
    GamepadLayout[GamepadLayout["RightShoulder"] = 5] = "RightShoulder";
    GamepadLayout[GamepadLayout["LeftTrigger"] = 6] = "LeftTrigger";
    GamepadLayout[GamepadLayout["RightTrigger"] = 7] = "RightTrigger";
    GamepadLayout[GamepadLayout["SelectOrBack"] = 8] = "SelectOrBack";
    GamepadLayout[GamepadLayout["StartOrForward"] = 9] = "StartOrForward";
    GamepadLayout[GamepadLayout["LeftAnalogPress"] = 10] = "LeftAnalogPress";
    GamepadLayout[GamepadLayout["RightAnalogPress"] = 11] = "RightAnalogPress";
    GamepadLayout[GamepadLayout["LeftClusterTopButton"] = 12] = "LeftClusterTopButton";
    GamepadLayout[GamepadLayout["LeftClusterBottomButton"] = 13] = "LeftClusterBottomButton";
    GamepadLayout[GamepadLayout["LeftClusterLeftButton"] = 14] = "LeftClusterLeftButton";
    GamepadLayout[GamepadLayout["LeftClusterRightButton"] = 15] = "LeftClusterRightButton";
    GamepadLayout[GamepadLayout["CentreButton"] = 16] = "CentreButton";
    // Axes
    GamepadLayout[GamepadLayout["LeftStickHorizontal"] = 0] = "LeftStickHorizontal";
    GamepadLayout[GamepadLayout["LeftStickVertical"] = 1] = "LeftStickVertical";
    GamepadLayout[GamepadLayout["RightStickHorizontal"] = 2] = "RightStickHorizontal";
    GamepadLayout[GamepadLayout["RightStickVertical"] = 3] = "RightStickVertical";
})(GamepadLayout || (GamepadLayout = {}));
/**
 * Handles gamepad events from the document to send to the streamer.
 */
class GamepadController {
    constructor(streamMessageController) {
        this.streamMessageController = streamMessageController;
        this.onGamepadConnectedListener = this.onGamepadConnected.bind(this);
        this.onGamepadDisconnectedListener = this.onGamepadDisconnected.bind(this);
        this.beforeUnloadListener = this.onBeforeUnload.bind(this);
        this.requestAnimationFrame = (window.mozRequestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.requestAnimationFrame).bind(window);
    }
    register() {
        window.addEventListener('beforeunload', this.beforeUnloadListener);
        const browserWindow = window;
        if ('GamepadEvent' in browserWindow) {
            window.addEventListener('gamepadconnected', this.onGamepadConnectedListener);
            window.addEventListener('gamepaddisconnected', this.onGamepadDisconnectedListener);
        }
        else if ('WebKitGamepadEvent' in browserWindow) {
            window.addEventListener('webkitgamepadconnected', this.onGamepadConnectedListener);
            window.addEventListener('webkitgamepaddisconnected', this.onGamepadDisconnectedListener);
        }
        this.controllers = [];
        if (navigator.getGamepads) {
            for (const gamepad of navigator.getGamepads()) {
                if (gamepad) {
                    this.onGamepadConnected(new GamepadEvent('gamepadconnected', { gamepad }));
                }
            }
        }
    }
    unregister() {
        window.removeEventListener('gamepadconnected', this.onGamepadConnectedListener);
        window.removeEventListener('gamepaddisconnected', this.onGamepadDisconnectedListener);
        window.removeEventListener('webkitgamepadconnected', this.onGamepadConnectedListener);
        window.removeEventListener('webkitgamepaddisconnected', this.onGamepadDisconnectedListener);
        for (const controller of this.controllers) {
            if (controller && controller.id !== undefined) {
                this.streamMessageController.toStreamerHandlers.get('GamepadDisconnected')([controller.id]);
            }
        }
        this.controllers = [];
    }
    onGamepadResponseReceived(gamepadId) {
        for (const controller of this.controllers) {
            if (controller && controller.id === undefined) {
                controller.id = gamepadId;
                break;
            }
        }
    }
    onGamepadConnected(event) {
        const gamepad = event.gamepad;
        const newController = {
            currentState: (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(gamepad),
            prevState: (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(gamepad),
            id: undefined
        };
        this.controllers[gamepad.index] = newController;
        window.requestAnimationFrame(() => this.updateStatus());
        this.streamMessageController.toStreamerHandlers.get('GamepadConnected')();
    }
    onGamepadDisconnected(event) {
        const gamepad = event.gamepad;
        const deletedController = this.controllers[gamepad.index];
        delete this.controllers[gamepad.index];
        this.controllers = this.controllers.filter((controller) => controller !== undefined);
        if (deletedController.id !== undefined) {
            this.streamMessageController.toStreamerHandlers.get('GamepadDisconnected')([
                deletedController.id
            ]);
        }
    }
    scanGamepads() {
        const gamepads = navigator.getGamepads
            ? navigator.getGamepads()
            : navigator.webkitGetGamepads
                ? navigator.webkitGetGamepads()
                : [];
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i] && this.controllers[gamepads[i].index] !== undefined) {
                this.controllers[gamepads[i].index].currentState = gamepads[i];
            }
        }
    }
    updateStatus() {
        this.scanGamepads();
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        // Iterate over multiple controllers in the case the multiple gamepads are connected
        for (const controller of this.controllers) {
            if (!controller) {
                continue;
            }
            // If we haven't received an id (possible if using an older version of UE), return to original functionality
            const controllerId = controller.id === undefined ? this.controllers.indexOf(controller) : controller.id;
            const currentState = controller.currentState;
            for (let i = 0; i < controller.currentState.buttons.length; i++) {
                const currentButton = controller.currentState.buttons[i];
                const previousButton = controller.prevState.buttons[i];
                if (currentButton.pressed) {
                    // press
                    if (i == GamepadLayout.LeftTrigger) {
                        // UEs left analog has a button index of 5
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 5, currentButton.value]);
                    }
                    else if (i == GamepadLayout.RightTrigger) {
                        // UEs right analog has a button index of 6
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 6, currentButton.value]);
                    }
                    else {
                        toStreamerHandlers.get('GamepadButtonPressed')([
                            controllerId,
                            i,
                            previousButton.pressed ? 1 : 0
                        ]);
                    }
                }
                else if (!currentButton.pressed && previousButton.pressed) {
                    // release
                    if (i == GamepadLayout.LeftTrigger) {
                        // UEs left analog has a button index of 5
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 5, 0]);
                    }
                    else if (i == GamepadLayout.RightTrigger) {
                        // UEs right analog has a button index of 6
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 6, 0]);
                    }
                    else {
                        toStreamerHandlers.get('GamepadButtonReleased')([controllerId, i, 0]);
                    }
                }
            }
            // Iterate over gamepad axes (we will increment in lots of 2 as there is 2 axes per stick)
            for (let i = 0; i < currentState.axes.length; i += 2) {
                // Horizontal axes are even numbered
                const x = parseFloat(currentState.axes[i].toFixed(4));
                // Vertical axes are odd numbered
                // https://w3c.github.io/gamepad/#remapping Gamepad browser side standard mapping has positive down, negative up. This is downright disgusting. So we fix it.
                const y = -parseFloat(currentState.axes[i + 1].toFixed(4));
                // UE's analog axes follow the same order as the browsers, but start at index 1 so we will offset as such
                toStreamerHandlers.get('GamepadAnalog')([controllerId, i + 1, x]); // Horizontal axes, only offset by 1
                toStreamerHandlers.get('GamepadAnalog')([controllerId, i + 2, y]); // Vertical axes, offset by two (1 to match UEs axes convention and then another 1 for the vertical axes)
            }
            const controllerIndex = this.controllers.indexOf(controller);
            this.controllers[controllerIndex].prevState = (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(currentState);
        }
        if (this.controllers.length > 0) {
            this.requestAnimationFrame(() => this.updateStatus());
        }
    }
    onBeforeUnload(_) {
        // When a user navigates away from the page, we need to inform UE of all the disconnecting
        // controllers
        for (const controller of this.controllers) {
            if (!controller || controller.id === undefined) {
                continue;
            }
            this.streamMessageController.toStreamerHandlers.get('GamepadDisconnected')([controller.id]);
        }
    }
}
//# sourceMappingURL=GamepadController.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/GamepadTypes.js":
/*!*****************************************************!*\
  !*** ../../library/dist/esm/Inputs/GamepadTypes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deepCopyGamepad: () => (/* binding */ deepCopyGamepad)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Deep copies the values from a gamepad by first converting it to a JSON object and then back to a gamepad
 *
 * @param gamepad the original gamepad
 * @returns a new gamepad object, populated with the original gamepads values
 */
function deepCopyGamepad(gamepad) {
    return JSON.parse(JSON.stringify({
        buttons: gamepad.buttons.map((b) => JSON.parse(JSON.stringify({
            pressed: b.pressed,
            touched: b.touched,
            value: b.value
        }))),
        axes: gamepad.axes
    }));
}
//# sourceMappingURL=GamepadTypes.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/InputClassesFactory.js":
/*!************************************************************!*\
  !*** ../../library/dist/esm/Inputs/InputClassesFactory.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActiveKeys: () => (/* binding */ ActiveKeys),
/* harmony export */   InputClassesFactory: () => (/* binding */ InputClassesFactory)
/* harmony export */ });
/* harmony import */ var _KeyboardController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KeyboardController */ "../../library/dist/esm/Inputs/KeyboardController.js");
/* harmony import */ var _MouseControllerLocked__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MouseControllerLocked */ "../../library/dist/esm/Inputs/MouseControllerLocked.js");
/* harmony import */ var _MouseControllerHovering__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MouseControllerHovering */ "../../library/dist/esm/Inputs/MouseControllerHovering.js");
/* harmony import */ var _TouchController__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TouchController */ "../../library/dist/esm/Inputs/TouchController.js");
/* harmony import */ var _TouchControllerFake__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TouchControllerFake */ "../../library/dist/esm/Inputs/TouchControllerFake.js");
/* harmony import */ var _GamepadController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GamepadController */ "../../library/dist/esm/Inputs/GamepadController.js");
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.








/**
 * Class for making and setting up input class types
 */
class InputClassesFactory {
    /**
     * @param toStreamerMessagesProvider - Stream message instance
     * @param videoElementProvider - Video Player instance
     * @param coordinateConverter - A coordinateConverter instance
     */
    constructor(toStreamerMessagesProvider, videoElementProvider, coordinateConverter) {
        this.activeKeys = new ActiveKeys();
        this.toStreamerMessagesProvider = toStreamerMessagesProvider;
        this.videoElementProvider = videoElementProvider;
        this.coordinateConverter = coordinateConverter;
    }
    /**
     * Registers browser key events.
     */
    registerKeyBoard(config) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Register Keyboard Events');
        const keyboardController = new _KeyboardController__WEBPACK_IMPORTED_MODULE_1__.KeyboardController(this.toStreamerMessagesProvider, config, this.activeKeys);
        keyboardController.register();
        return keyboardController;
    }
    /**
     * register mouse events based on a control type
     * @param controlScheme - if the mouse is either hovering or locked
     */
    registerMouse(controlScheme) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Register Mouse Events');
        let mouseController;
        if (controlScheme == _Config_Config__WEBPACK_IMPORTED_MODULE_2__.ControlSchemeType.HoveringMouse) {
            mouseController = new _MouseControllerHovering__WEBPACK_IMPORTED_MODULE_3__.MouseControllerHovering(this.toStreamerMessagesProvider, this.videoElementProvider, this.coordinateConverter, this.activeKeys);
        }
        else {
            mouseController = new _MouseControllerLocked__WEBPACK_IMPORTED_MODULE_4__.MouseControllerLocked(this.toStreamerMessagesProvider, this.videoElementProvider, this.coordinateConverter, this.activeKeys);
        }
        mouseController.register();
        return mouseController;
    }
    /**
     * register touch events
     * @param fakeMouseTouch - the faked mouse touch event
     */
    registerTouch(fakeMouseTouch) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Registering Touch');
        let touchController;
        if (fakeMouseTouch) {
            touchController = new _TouchControllerFake__WEBPACK_IMPORTED_MODULE_5__.TouchControllerFake(this.toStreamerMessagesProvider, this.videoElementProvider, this.coordinateConverter);
        }
        else {
            touchController = new _TouchController__WEBPACK_IMPORTED_MODULE_6__.TouchController(this.toStreamerMessagesProvider, this.videoElementProvider, this.coordinateConverter);
        }
        touchController.register();
        return touchController;
    }
    /**
     * registers a gamepad
     */
    registerGamePad() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Register Game Pad');
        const gamepadController = new _GamepadController__WEBPACK_IMPORTED_MODULE_7__.GamepadController(this.toStreamerMessagesProvider);
        gamepadController.register();
        return gamepadController;
    }
}
/**
 * A class that keeps track of current active keys
 */
class ActiveKeys {
    constructor() {
        this.activeKeys = [];
        this.activeKeys = [];
    }
    /**
     * Get the current array of active keys
     * @returns - an array of active keys
     */
    getActiveKeys() {
        return this.activeKeys;
    }
}
//# sourceMappingURL=InputClassesFactory.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/KeyCodes.js":
/*!*************************************************!*\
  !*** ../../library/dist/esm/Inputs/KeyCodes.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CodeToKeyCode: () => (/* binding */ CodeToKeyCode)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/*
 * New browser APIs have moved away from KeyboardEvent.keyCode to KeyboardEvent.Code.
 * For details see: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#constants_for_keycode_value
 * We still use old KeyboardEvent.keyCode integers in the UE C++ side, so we need a way to map the new
 * string-based KeyboardEvent.Code to the old integers.
 */
const CodeToKeyCode = Object.freeze({
    Escape: 27,
    Digit0: 48,
    Digit1: 49,
    Digit2: 50,
    Digit3: 51,
    Digit4: 52,
    Digit5: 53,
    Digit6: 54,
    Digit7: 55,
    Digit8: 56,
    Digit9: 57,
    Minus: 173,
    Equal: 187,
    Backspace: 8,
    Tab: 9,
    KeyQ: 81,
    KeyW: 87,
    KeyE: 69,
    KeyR: 82,
    KeyT: 84,
    KeyY: 89,
    KeyU: 85,
    KeyI: 73,
    KeyO: 79,
    KeyP: 80,
    BracketLeft: 219,
    BracketRight: 221,
    Enter: 13,
    ControlLeft: 17,
    KeyA: 65,
    KeyS: 83,
    KeyD: 68,
    KeyF: 70,
    KeyG: 71,
    KeyH: 72,
    KeyJ: 74,
    KeyK: 75,
    KeyL: 76,
    Semicolon: 186,
    Quote: 222,
    Backquote: 192,
    ShiftLeft: 16,
    Backslash: 220,
    KeyZ: 90,
    KeyX: 88,
    KeyC: 67,
    KeyV: 86,
    KeyB: 66,
    KeyN: 78,
    KeyM: 77,
    Comma: 188,
    Period: 190,
    Slash: 191,
    ShiftRight: 253,
    AltLeft: 18,
    Space: 32,
    CapsLock: 20,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    Pause: 19,
    ScrollLock: 145,
    NumpadDivide: 111,
    NumpadMultiply: 106,
    NumpadSubtract: 109,
    NumpadAdd: 107,
    NumpadDecimal: 110,
    Numpad9: 105,
    Numpad8: 104,
    Numpad7: 103,
    Numpad6: 102,
    Numpad5: 101,
    Numpad4: 100,
    Numpad3: 99,
    Numpad2: 98,
    Numpad1: 97,
    Numpad0: 96,
    NumLock: 144,
    ControlRight: 254,
    AltRight: 255,
    Home: 36,
    End: 35,
    ArrowUp: 38,
    ArrowLeft: 37,
    ArrowRight: 39,
    ArrowDown: 40,
    PageUp: 33,
    PageDown: 34,
    Insert: 45,
    Delete: 46,
    ContextMenu: 93
});
//# sourceMappingURL=KeyCodes.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/KeyboardController.js":
/*!***********************************************************!*\
  !*** ../../library/dist/esm/Inputs/KeyboardController.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeyboardController: () => (/* binding */ KeyboardController)
/* harmony export */ });
/* harmony import */ var _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SpecialKeyCodes */ "../../library/dist/esm/Inputs/SpecialKeyCodes.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _KeyCodes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./KeyCodes */ "../../library/dist/esm/Inputs/KeyCodes.js");
// Copyright Epic Games, Inc. All Rights Reserved.




/**
 * Handles the Keyboard Inputs for the document
 */
class KeyboardController {
    constructor(streamMessageController, config, activeKeys) {
        this.streamMessageController = streamMessageController;
        this.config = config;
        this.activeKeys = activeKeys;
        this.onKeyDownListener = this.handleOnKeyDown.bind(this);
        this.onKeyUpListener = this.handleOnKeyUp.bind(this);
        this.onKeyPressListener = this.handleOnKeyPress.bind(this);
    }
    register() {
        document.addEventListener('keydown', this.onKeyDownListener);
        document.addEventListener('keyup', this.onKeyUpListener);
        //This has been deprecated as at Jun 13 2021
        document.addEventListener('keypress', this.onKeyPressListener);
    }
    unregister() {
        document.removeEventListener('keydown', this.onKeyDownListener);
        document.removeEventListener('keyup', this.onKeyUpListener);
        document.removeEventListener('keypress', this.onKeyPressListener);
    }
    handleOnKeyDown(keyboardEvent) {
        var _a;
        const keyCode = this.getKeycode(keyboardEvent);
        if (!keyCode || keyCode === 229) {
            return;
        }
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        (_a = toStreamerHandlers.get('KeyDown')) === null || _a === void 0 ? void 0 : _a([this.getKeycode(keyboardEvent), keyboardEvent.repeat ? 1 : 0]);
        const activeKeys = this.activeKeys.getActiveKeys();
        activeKeys.push(keyCode);
        // Backspace is not considered a keypress in JavaScript but we need it
        // to be so characters may be deleted in a UE text entry field.
        // since keypress is deprecated we really should be sending all keys to keypress
        // or we change everything to handle the deprecation of these parts
        if (keyCode === _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.backSpace) {
            this.handleOnKeyPress(new KeyboardEvent('keypress', {
                charCode: _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.backSpace,
                keyCode: _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.backSpace
            }));
        }
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.SuppressBrowserKeys) && this.isKeyCodeBrowserKey(keyCode)) {
            keyboardEvent.preventDefault();
        }
    }
    handleOnKeyUp(keyboardEvent) {
        var _a;
        const keyCode = this.getKeycode(keyboardEvent);
        if (!keyCode) {
            return;
        }
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        (_a = toStreamerHandlers.get('KeyUp')) === null || _a === void 0 ? void 0 : _a([keyCode]);
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.SuppressBrowserKeys) && this.isKeyCodeBrowserKey(keyCode)) {
            keyboardEvent.preventDefault();
        }
    }
    handleOnKeyPress(keyboardEvent) {
        var _a;
        const keyCode = this.getKeycode(keyboardEvent);
        if (!keyCode) {
            return;
        }
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        (_a = toStreamerHandlers.get('KeyPress')) === null || _a === void 0 ? void 0 : _a([keyCode]);
    }
    /**
     * Gets the Keycode of the Key pressed
     * @param keyboardEvent - Key board Event
     * @returns - the key code of the Key
     */
    getKeycode(keyboardEvent) {
        // If we don't have keyCode property because browser API is deprecated then use KeyboardEvent.code instead.
        // See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#constants_for_keycode_value
        if (!('keyCode' in keyboardEvent)) {
            // this type assertion here is required because if 'keyCode' doesnt exist in keyboardEvent then
            // it cannot be a KeyboardEvent and so it gets narrowed to 'never'
            const event = keyboardEvent;
            // Convert KeyboardEvent.code string into integer-based key code for backwards compatibility reasons.
            if (event.code in _KeyCodes__WEBPACK_IMPORTED_MODULE_2__.CodeToKeyCode) {
                return _KeyCodes__WEBPACK_IMPORTED_MODULE_2__.CodeToKeyCode[event.code];
            }
            else {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Keyboard code of ${event.code} is not supported in our mapping, ignoring this key.`);
                return null;
            }
        }
        // If we made it here KeyboardEvent.keyCode is still supported so we can safely use it.
        if (keyboardEvent.keyCode === _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.shift && keyboardEvent.code === 'ShiftRight') {
            return _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.rightShift;
        }
        else if (keyboardEvent.keyCode === _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.control &&
            keyboardEvent.code === 'ControlRight') {
            return _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.rightControl;
        }
        else if (keyboardEvent.keyCode === _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.alt && keyboardEvent.code === 'AltRight') {
            return _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.rightAlt;
        }
        else {
            return keyboardEvent.keyCode;
        }
    }
    /**
     * Browser keys do not have a charCode so we only need to test keyCode.
     * @param keyCode - the browser keycode number
     */
    isKeyCodeBrowserKey(keyCode) {
        // Function keys or tab key are considered "browser keys" that we may wish to suppress by preventing them being process by browser.
        return (keyCode >= 112 && keyCode <= 123) || keyCode === 9;
    }
}
//# sourceMappingURL=KeyboardController.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/MouseButtons.js":
/*!*****************************************************!*\
  !*** ../../library/dist/esm/Inputs/MouseButtons.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MouseButton: () => (/* binding */ MouseButton),
/* harmony export */   MouseButtonsMask: () => (/* binding */ MouseButtonsMask)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Mouse Button Data
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button}
 */
class MouseButton {
}
MouseButton.mainButton = 0; // Left button.
MouseButton.auxiliaryButton = 1; // Wheel button.
MouseButton.secondaryButton = 2; // Right button.
MouseButton.fourthButton = 3; // Browser Back button.
MouseButton.fifthButton = 4; // Browser Forward button.
/**
 * Mouse Button Mask Data
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons}
 */
class MouseButtonsMask {
}
MouseButtonsMask.primaryButton = 1; // Left button.
MouseButtonsMask.secondaryButton = 2; // Right button.
MouseButtonsMask.auxiliaryButton = 4; // Wheel button.
MouseButtonsMask.fourthButton = 8; // Browser Back button.
MouseButtonsMask.fifthButton = 16; // Browser Forward button.
//# sourceMappingURL=MouseButtons.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/MouseController.js":
/*!********************************************************!*\
  !*** ../../library/dist/esm/Inputs/MouseController.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MouseController: () => (/* binding */ MouseController)
/* harmony export */ });
/* harmony import */ var _MouseButtons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MouseButtons */ "../../library/dist/esm/Inputs/MouseButtons.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * The base class for mouse controllers. Since there is a bunch of shared behaviour between locked and
 * hover mouse controllers this is where that shared behaviour lives.
 */
class MouseController {
    constructor(streamMessageController, videoPlayer, coordinateConverter, activeKeys) {
        this.streamMessageController = streamMessageController;
        this.coordinateConverter = coordinateConverter;
        this.videoPlayer = videoPlayer;
        this.activeKeys = activeKeys;
        this.onEnterListener = this.onMouseEnter.bind(this);
        this.onLeaveListener = this.onMouseLeave.bind(this);
    }
    register() {
        this.registerMouseEnterAndLeaveEvents();
    }
    unregister() {
        this.unregisterMouseEnterAndLeaveEvents();
    }
    registerMouseEnterAndLeaveEvents() {
        const videoElementParent = this.videoPlayer.getVideoParentElement();
        videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.addEventListener('mouseenter', this.onEnterListener);
        videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.addEventListener('mouseleave', this.onLeaveListener);
    }
    unregisterMouseEnterAndLeaveEvents() {
        const videoElementParent = this.videoPlayer.getVideoParentElement();
        videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.removeEventListener('mouseenter', this.onEnterListener);
        videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.removeEventListener('mouseleave', this.onLeaveListener);
    }
    onMouseEnter(event) {
        var _a;
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        (_a = this.streamMessageController.toStreamerHandlers.get('MouseEnter')) === null || _a === void 0 ? void 0 : _a();
        this.pressMouseButtons(event.buttons, event.x, event.y);
    }
    onMouseLeave(event) {
        var _a;
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        (_a = this.streamMessageController.toStreamerHandlers.get('MouseLeave')) === null || _a === void 0 ? void 0 : _a();
        this.releaseMouseButtons(event.buttons, event.x, event.y);
    }
    releaseMouseButtons(buttons, X, Y) {
        const coord = this.coordinateConverter.translateUnsigned(X, Y);
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.primaryButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.mainButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.secondaryButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.secondaryButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.auxiliaryButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.auxiliaryButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.fourthButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.fourthButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.fifthButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.fifthButton, coord.x, coord.y);
        }
    }
    pressMouseButtons(buttons, X, Y) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(X, Y);
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.primaryButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.mainButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.secondaryButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.secondaryButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.auxiliaryButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.auxiliaryButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.fourthButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.fourthButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.fifthButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.fifthButton, coord.x, coord.y);
        }
    }
    sendMouseDown(button, X, Y) {
        var _a;
        (_a = this.streamMessageController.toStreamerHandlers.get('MouseDown')) === null || _a === void 0 ? void 0 : _a([button, X, Y]);
    }
    sendMouseUp(button, X, Y) {
        var _a;
        const coord = this.coordinateConverter.translateUnsigned(X, Y);
        (_a = this.streamMessageController.toStreamerHandlers.get('MouseUp')) === null || _a === void 0 ? void 0 : _a([button, coord.x, coord.y]);
    }
}
//# sourceMappingURL=MouseController.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/MouseControllerHovering.js":
/*!****************************************************************!*\
  !*** ../../library/dist/esm/Inputs/MouseControllerHovering.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MouseControllerHovering: () => (/* binding */ MouseControllerHovering)
/* harmony export */ });
/* harmony import */ var _MouseController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MouseController */ "../../library/dist/esm/Inputs/MouseController.js");

/**
 * A mouse controller that allows the mouse to freely float over the video document.
 */
class MouseControllerHovering extends _MouseController__WEBPACK_IMPORTED_MODULE_0__.MouseController {
    constructor(streamMessageController, videoPlayer, coordinateConverter, activeKeys) {
        super(streamMessageController, videoPlayer, coordinateConverter, activeKeys);
        this.videoElementParent = videoPlayer.getVideoParentElement();
        this.onMouseUpListener = this.onMouseUp.bind(this);
        this.onMouseDownListener = this.onMouseDown.bind(this);
        this.onMouseDblClickListener = this.onMouseDblClick.bind(this);
        this.onMouseWheelListener = this.onMouseWheel.bind(this);
        this.onMouseMoveListener = this.onMouseMove.bind(this);
        this.onContextMenuListener = this.onContextMenu.bind(this);
    }
    register() {
        super.register();
        this.videoElementParent.addEventListener('mousemove', this.onMouseMoveListener);
        this.videoElementParent.addEventListener('mousedown', this.onMouseDownListener);
        this.videoElementParent.addEventListener('mouseup', this.onMouseUpListener);
        this.videoElementParent.addEventListener('contextmenu', this.onContextMenuListener);
        this.videoElementParent.addEventListener('wheel', this.onMouseWheelListener);
        this.videoElementParent.addEventListener('dblclick', this.onMouseDblClickListener);
    }
    unregister() {
        this.videoElementParent.removeEventListener('mousemove', this.onMouseMoveListener);
        this.videoElementParent.removeEventListener('mousedown', this.onMouseDownListener);
        this.videoElementParent.removeEventListener('mouseup', this.onMouseUpListener);
        this.videoElementParent.removeEventListener('contextmenu', this.onContextMenuListener);
        this.videoElementParent.removeEventListener('wheel', this.onMouseWheelListener);
        this.videoElementParent.removeEventListener('dblclick', this.onMouseDblClickListener);
        super.unregister();
    }
    onMouseDown(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        this.streamMessageController.toStreamerHandlers.get('MouseDown')([event.button, coord.x, coord.y]);
        event.preventDefault();
    }
    onMouseUp(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        this.streamMessageController.toStreamerHandlers.get('MouseUp')([event.button, coord.x, coord.y]);
        event.preventDefault();
    }
    onContextMenu(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        event.preventDefault();
    }
    onMouseMove(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        const delta = this.coordinateConverter.translateSigned(event.movementX, event.movementY);
        this.streamMessageController.toStreamerHandlers.get('MouseMove')([
            coord.x,
            coord.y,
            delta.x,
            delta.y
        ]);
        event.preventDefault();
    }
    onMouseWheel(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        this.streamMessageController.toStreamerHandlers.get('MouseWheel')([
            event.wheelDelta,
            coord.x,
            coord.y
        ]);
        event.preventDefault();
    }
    onMouseDblClick(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        this.streamMessageController.toStreamerHandlers.get('MouseDouble')([event.button, coord.x, coord.y]);
    }
}
//# sourceMappingURL=MouseControllerHovering.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/MouseControllerLocked.js":
/*!**************************************************************!*\
  !*** ../../library/dist/esm/Inputs/MouseControllerLocked.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MouseControllerLocked: () => (/* binding */ MouseControllerLocked)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _MouseController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MouseController */ "../../library/dist/esm/Inputs/MouseController.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * A mouse controller that locks the mouse to the video document and prevents it from leaving the window
 */
class MouseControllerLocked extends _MouseController__WEBPACK_IMPORTED_MODULE_0__.MouseController {
    constructor(streamMessageController, videoPlayer, coordinateConverter, activeKeys) {
        super(streamMessageController, videoPlayer, coordinateConverter, activeKeys);
        this.videoElementParent = videoPlayer.getVideoParentElement();
        this.x = this.videoElementParent.getBoundingClientRect().width / 2;
        this.y = this.videoElementParent.getBoundingClientRect().height / 2;
        this.normalizedCoord = this.coordinateConverter.translateUnsigned(this.x, this.y);
        this.onRequestLockListener = this.onRequestLock.bind(this);
        this.onLockStateChangeListener = this.onLockStateChange.bind(this);
        this.onMouseUpListener = this.onMouseUp.bind(this);
        this.onMouseDownListener = this.onMouseDown.bind(this);
        this.onMouseDblClickListener = this.onMouseDblClick.bind(this);
        this.onMouseWheelListener = this.onMouseWheel.bind(this);
        this.onMouseMoveListener = this.onMouseMove.bind(this);
    }
    register() {
        super.register();
        this.videoElementParent.requestPointerLock =
            this.videoElementParent.requestPointerLock || this.videoElementParent.mozRequestPointerLock;
        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
        if (this.videoElementParent.requestPointerLock) {
            this.videoElementParent.addEventListener('click', this.onRequestLockListener);
        }
        document.addEventListener('pointerlockchange', this.onLockStateChangeListener);
        document.addEventListener('mozpointerlockchange', this.onLockStateChangeListener);
        this.videoElementParent.addEventListener('mousedown', this.onMouseDownListener);
        this.videoElementParent.addEventListener('mouseup', this.onMouseUpListener);
        this.videoElementParent.addEventListener('wheel', this.onMouseWheelListener);
        this.videoElementParent.addEventListener('dblclick', this.onMouseDblClickListener);
    }
    unregister() {
        const pointerLockElement = document.pointerLockElement || document.mozPointerLockElement;
        if (document.exitPointerLock && pointerLockElement === this.videoElementParent) {
            document.exitPointerLock();
        }
        this.videoElementParent.removeEventListener('click', this.onRequestLockListener);
        document.removeEventListener('pointerlockchange', this.onLockStateChangeListener);
        document.removeEventListener('mozpointerlockchange', this.onLockStateChangeListener);
        document.removeEventListener('mousemove', this.onMouseMoveListener);
        this.videoElementParent.removeEventListener('mousedown', this.onMouseDownListener);
        this.videoElementParent.removeEventListener('mouseup', this.onMouseUpListener);
        this.videoElementParent.removeEventListener('wheel', this.onMouseWheelListener);
        this.videoElementParent.removeEventListener('dblclick', this.onMouseDblClickListener);
        super.unregister();
    }
    onRequestLock() {
        this.videoElementParent.requestPointerLock();
    }
    onLockStateChange() {
        const pointerLockElement = document.pointerLockElement || document.mozPointerLockElement;
        if (pointerLockElement === this.videoElementParent) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Pointer locked');
            document.addEventListener('mousemove', this.onMouseMoveListener);
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('The pointer lock status is now unlocked');
            document.removeEventListener('mousemove', this.onMouseMoveListener);
            // If mouse loses focus, send a key up for all of the currently held-down keys
            // This is necessary as when the mouse loses focus, the windows stops listening for events and as such
            // the keyup listener won't get fired
            const activeKeys = this.activeKeys.getActiveKeys();
            activeKeys.forEach((key) => {
                this.streamMessageController.toStreamerHandlers.get('KeyUp')([key]);
            });
        }
    }
    onMouseDown(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.streamMessageController.toStreamerHandlers.get('MouseDown')([
            event.button,
            // We use the store value of this.coord as opposed to the mouseEvent.x/y as the mouseEvent location
            // uses the system cursor location which hasn't moved
            this.normalizedCoord.x,
            this.normalizedCoord.y
        ]);
    }
    onMouseUp(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.streamMessageController.toStreamerHandlers.get('MouseUp')([
            event.button,
            // We use the store value of this.coord as opposed to the mouseEvent.x/y as the mouseEvent location
            // uses the system cursor location which hasn't moved
            this.normalizedCoord.x,
            this.normalizedCoord.y
        ]);
    }
    onMouseMove(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const styleWidth = this.videoPlayer.getVideoParentElement().clientWidth;
        const styleHeight = this.videoPlayer.getVideoParentElement().clientHeight;
        this.x += event.movementX;
        this.y += event.movementY;
        while (this.x > styleWidth) {
            this.x -= styleWidth;
        }
        while (this.y > styleHeight) {
            this.y -= styleHeight;
        }
        while (this.x < 0) {
            this.x += styleWidth;
        }
        while (this.y < 0) {
            this.y += styleHeight;
        }
        this.normalizedCoord = this.coordinateConverter.translateUnsigned(this.x, this.y);
        const delta = this.coordinateConverter.translateSigned(event.movementX, event.movementY);
        this.streamMessageController.toStreamerHandlers.get('MouseMove')([
            this.normalizedCoord.x,
            this.normalizedCoord.y,
            delta.x,
            delta.y
        ]);
    }
    onMouseWheel(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.streamMessageController.toStreamerHandlers.get('MouseWheel')([
            event.wheelDelta,
            // We use the store value of this.coord as opposed to the mouseEvent.x/y as the mouseEvent location
            // uses the system cursor location which hasn't moved
            this.normalizedCoord.x,
            this.normalizedCoord.y
        ]);
    }
    onMouseDblClick(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.streamMessageController.toStreamerHandlers.get('MouseDouble')([
            event.button,
            // We use the store value of this.coord as opposed to the mouseEvent.x/y as the mouseEvent location
            // uses the system cursor location which hasn't moved
            this.normalizedCoord.x,
            this.normalizedCoord.y
        ]);
    }
}
//# sourceMappingURL=MouseControllerLocked.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/SpecialKeyCodes.js":
/*!********************************************************!*\
  !*** ../../library/dist/esm/Inputs/SpecialKeyCodes.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpecialKeyCodes: () => (/* binding */ SpecialKeyCodes)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Registers the Special Key codes
 *  Must be kept in sync with JavaScriptKeyCodeToFKey C++ array.
 * The index of the entry in the array is the special key code given below.
 */
class SpecialKeyCodes {
}
SpecialKeyCodes.backSpace = 8;
SpecialKeyCodes.shift = 16;
SpecialKeyCodes.control = 17;
SpecialKeyCodes.alt = 18;
SpecialKeyCodes.rightShift = 253;
SpecialKeyCodes.rightControl = 254;
SpecialKeyCodes.rightAlt = 255;
//# sourceMappingURL=SpecialKeyCodes.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/TouchController.js":
/*!********************************************************!*\
  !*** ../../library/dist/esm/Inputs/TouchController.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TouchController: () => (/* binding */ TouchController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * The basic touch controller that handles the touch events on the document.
 */
class TouchController {
    constructor(streamMessageController, videoPlayer, coordinateConverter) {
        this.fingers = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0];
        this.fingerIds = new Map();
        this.maxByteValue = 255;
        this.streamMessageController = streamMessageController;
        this.videoPlayer = videoPlayer;
        this.coordinateConverter = coordinateConverter;
        this.videoElementParent = videoPlayer.getVideoElement();
        this.onTouchStartListener = this.onTouchStart.bind(this);
        this.onTouchEndListener = this.onTouchEnd.bind(this);
        this.onTouchMoveListener = this.onTouchMove.bind(this);
    }
    register() {
        this.videoElementParent.addEventListener('touchstart', this.onTouchStartListener);
        this.videoElementParent.addEventListener('touchend', this.onTouchEndListener);
        this.videoElementParent.addEventListener('touchmove', this.onTouchMoveListener);
    }
    unregister() {
        this.videoElementParent.removeEventListener('touchstart', this.onTouchStartListener);
        this.videoElementParent.removeEventListener('touchend', this.onTouchEndListener);
        this.videoElementParent.removeEventListener('touchmove', this.onTouchMoveListener);
    }
    rememberTouch(touch) {
        const finger = this.fingers.pop();
        if (finger === undefined) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('exhausted touch identifiers');
        }
        this.fingerIds.set(touch.identifier, finger);
    }
    forgetTouch(touch) {
        this.fingers.push(this.fingerIds.get(touch.identifier));
        // Sort array back into descending order. This means if finger '1' were to lift after finger '0', we would ensure that 0 will be the first index to pop
        this.fingers.sort(function (a, b) {
            return b - a;
        });
        this.fingerIds.delete(touch.identifier);
    }
    onTouchStart(touchEvent) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        for (let t = 0; t < touchEvent.changedTouches.length; t++) {
            this.rememberTouch(touchEvent.changedTouches[t]);
        }
        this.emitTouchData('TouchStart', touchEvent.changedTouches);
        touchEvent.preventDefault();
    }
    onTouchEnd(touchEvent) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.emitTouchData('TouchEnd', touchEvent.changedTouches);
        // Re-cycle unique identifiers previously assigned to each touch.
        for (let t = 0; t < touchEvent.changedTouches.length; t++) {
            this.forgetTouch(touchEvent.changedTouches[t]);
        }
        touchEvent.preventDefault();
    }
    onTouchMove(touchEvent) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.emitTouchData('TouchMove', touchEvent.touches);
        touchEvent.preventDefault();
    }
    emitTouchData(type, touches) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const offset = this.videoPlayer.getVideoParentElement().getBoundingClientRect();
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        for (let t = 0; t < touches.length; t++) {
            const numTouches = 1; // the number of touches to be sent this message
            const touch = touches[t];
            const x = touch.clientX - offset.left;
            const y = touch.clientY - offset.top;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`F${this.fingerIds.get(touch.identifier)}=(${x}, ${y})`);
            const coord = this.coordinateConverter.translateUnsigned(x, y);
            switch (type) {
                case 'TouchStart':
                    toStreamerHandlers.get('TouchStart')([
                        numTouches,
                        coord.x,
                        coord.y,
                        this.fingerIds.get(touch.identifier),
                        this.maxByteValue * (touch.force > 0 ? touch.force : 1),
                        coord.inRange ? 1 : 0
                    ]);
                    break;
                case 'TouchEnd':
                    toStreamerHandlers.get('TouchEnd')([
                        numTouches,
                        coord.x,
                        coord.y,
                        this.fingerIds.get(touch.identifier),
                        this.maxByteValue * touch.force,
                        coord.inRange ? 1 : 0
                    ]);
                    break;
                case 'TouchMove':
                    toStreamerHandlers.get('TouchMove')([
                        numTouches,
                        coord.x,
                        coord.y,
                        this.fingerIds.get(touch.identifier),
                        this.maxByteValue * (touch.force > 0 ? touch.force : 1),
                        coord.inRange ? 1 : 0
                    ]);
                    break;
            }
        }
    }
}
//# sourceMappingURL=TouchController.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/TouchControllerFake.js":
/*!************************************************************!*\
  !*** ../../library/dist/esm/Inputs/TouchControllerFake.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TouchControllerFake: () => (/* binding */ TouchControllerFake)
/* harmony export */ });
/* harmony import */ var _MouseButtons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MouseButtons */ "../../library/dist/esm/Inputs/MouseButtons.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Allows for the usage of fake touch events
 */
class TouchControllerFake {
    constructor(streamMessageController, videoPlayer, coordinateConverter) {
        this.streamMessageController = streamMessageController;
        this.videoPlayer = videoPlayer;
        this.coordinateConverter = coordinateConverter;
        this.onTouchStartListener = this.onTouchStart.bind(this);
        this.onTouchEndListener = this.onTouchEnd.bind(this);
        this.onTouchMoveListener = this.onTouchMove.bind(this);
        this.videoElementParentClientRect = this.videoPlayer.getVideoParentElement().getBoundingClientRect();
    }
    register() {
        document.addEventListener('touchstart', this.onTouchStartListener);
        document.addEventListener('touchend', this.onTouchEndListener);
        document.addEventListener('touchmove', this.onTouchMoveListener);
    }
    unregister() {
        document.removeEventListener('touchstart', this.onTouchStartListener);
        document.removeEventListener('touchend', this.onTouchEndListener);
        document.removeEventListener('touchmove', this.onTouchMoveListener);
    }
    onTouchStart(touch) {
        if (!this.videoPlayer.isVideoReady() || touch.target !== this.videoPlayer.getVideoElement()) {
            return;
        }
        if (this.fakeTouchFinger == null) {
            const first_touch = touch.changedTouches[0];
            this.fakeTouchFinger = {
                id: first_touch.identifier,
                x: first_touch.clientX - this.videoElementParentClientRect.left,
                y: first_touch.clientY - this.videoElementParentClientRect.top
            };
            const videoElementParent = this.videoPlayer.getVideoParentElement();
            const mouseEvent = new MouseEvent('mouseenter', first_touch);
            videoElementParent.dispatchEvent(mouseEvent);
            const coord = this.coordinateConverter.translateUnsigned(this.fakeTouchFinger.x, this.fakeTouchFinger.y);
            const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
            toStreamerHandlers.get('MouseDown')([_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.mainButton, coord.x, coord.y]);
        }
        touch.preventDefault();
    }
    onTouchEnd(touchEvent) {
        if (!this.videoPlayer.isVideoReady() || this.fakeTouchFinger == null) {
            return;
        }
        const videoElementParent = this.videoPlayer.getVideoParentElement();
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        for (let t = 0; t < touchEvent.changedTouches.length; t++) {
            const touch = touchEvent.changedTouches[t];
            if (touch.identifier === this.fakeTouchFinger.id) {
                const x = touch.clientX - this.videoElementParentClientRect.left;
                const y = touch.clientY - this.videoElementParentClientRect.top;
                const coord = this.coordinateConverter.translateUnsigned(x, y);
                toStreamerHandlers.get('MouseUp')([_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.mainButton, coord.x, coord.y]);
                const mouseEvent = new MouseEvent('mouseleave', touch);
                videoElementParent.dispatchEvent(mouseEvent);
                this.fakeTouchFinger = null;
                break;
            }
        }
        touchEvent.preventDefault();
    }
    onTouchMove(touchEvent) {
        if (!this.videoPlayer.isVideoReady() || this.fakeTouchFinger == null) {
            return;
        }
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        for (let t = 0; t < touchEvent.touches.length; t++) {
            const touch = touchEvent.touches[t];
            if (touch.identifier === this.fakeTouchFinger.id) {
                const x = touch.clientX - this.videoElementParentClientRect.left;
                const y = touch.clientY - this.videoElementParentClientRect.top;
                const coord = this.coordinateConverter.translateUnsigned(x, y);
                const delta = this.coordinateConverter.translateSigned(x - this.fakeTouchFinger.x, y - this.fakeTouchFinger.y);
                toStreamerHandlers.get('MouseMove')([coord.x, coord.y, delta.x, delta.y]);
                this.fakeTouchFinger.x = x;
                this.fakeTouchFinger.y = y;
                break;
            }
        }
        touchEvent.preventDefault();
    }
}
//# sourceMappingURL=TouchControllerFake.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/XRGamepadController.js":
/*!************************************************************!*\
  !*** ../../library/dist/esm/Inputs/XRGamepadController.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   XRGamepadController: () => (/* binding */ XRGamepadController)
/* harmony export */ });
/* harmony import */ var _GamepadTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GamepadTypes */ "../../library/dist/esm/Inputs/GamepadTypes.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * The class that handles the functionality of XR gamepads and controllers.
 */
class XRGamepadController {
    /**
     * @param toStreamerMessagesProvider - Stream message instance
     */
    constructor(toStreamerMessagesProvider) {
        this.toStreamerMessagesProvider = toStreamerMessagesProvider;
        this.controllers = [];
    }
    updateStatus(source, frame, refSpace) {
        if (source.gamepad) {
            const gamepadPose = frame.getPose(source.gripSpace, refSpace);
            if (!gamepadPose) {
                return;
            }
            let system = 0;
            if (source.profiles.includes('htc-vive')) {
                system = 1;
            }
            else if (source.profiles.includes('oculus-touch')) {
                system = 2;
            }
            // TODO (william.belcher): Add other profiles (Quest, Microsoft Mixed Reality, etc)
            this.toStreamerMessagesProvider.toStreamerHandlers.get('XRSystem')([system]);
            // Default: AnyHand (2)
            let handedness = 2;
            switch (source.handedness) {
                case 'left':
                    handedness = 0;
                    break;
                case 'right':
                    handedness = 1;
                    break;
            }
            // Send controller transform
            const matrix = gamepadPose.transform.matrix;
            const mat = [];
            for (let i = 0; i < 16; i++) {
                mat[i] = new Float32Array([matrix[i]])[0];
            }
            // prettier-ignore
            this.toStreamerMessagesProvider.toStreamerHandlers.get('XRControllerTransform')([
                mat[0], mat[4], mat[8], mat[12],
                mat[1], mat[5], mat[9], mat[13],
                mat[2], mat[6], mat[10], mat[14],
                mat[3], mat[7], mat[11], mat[15],
                handedness
            ]);
            // Handle controller buttons and axes
            if (this.controllers[handedness] === undefined) {
                this.controllers[handedness] = {
                    prevState: undefined,
                    currentState: undefined,
                    id: undefined
                };
                this.controllers[handedness].prevState = (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(source.gamepad);
            }
            this.controllers[handedness].currentState = (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(source.gamepad);
            const controller = this.controllers[handedness];
            const currState = controller.currentState;
            const prevState = controller.prevState;
            // Iterate over buttons
            for (let i = 0; i < currState.buttons.length; i++) {
                const currButton = currState.buttons[i];
                const prevButton = prevState.buttons[i];
                if (currButton.pressed) {
                    // press
                    const isRepeat = prevButton.pressed ? 1 : 0;
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRButtonPressed')([
                        handedness,
                        i,
                        isRepeat,
                        currButton.value
                    ]);
                }
                else if (prevButton.pressed) {
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRButtonReleased')([
                        handedness,
                        i,
                        0
                    ]);
                }
                if (currButton.touched) {
                    // touched
                    const isRepeat = prevButton.touched ? 1 : 0;
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRButtonTouched')([
                        handedness,
                        i,
                        isRepeat
                    ]);
                }
                else if (prevButton.touched) {
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRButtonTouchReleased')([
                        handedness,
                        i,
                        0
                    ]);
                }
            }
            // Iterate over gamepad axes
            for (let i = 0; i < currState.axes.length; i++) {
                const curAxisValue = currState.axes[i];
                const prevAxisValue = prevState.axes[i];
                // Only send axis update if there is a change
                if (curAxisValue != prevAxisValue) {
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRAnalog')([
                        handedness,
                        i,
                        curAxisValue
                    ]);
                }
            }
            this.controllers[handedness].prevState = currState;
        }
    }
}
//# sourceMappingURL=XRGamepadController.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/AggregatedStats.js":
/*!**************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/AggregatedStats.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AggregatedStats: () => (/* binding */ AggregatedStats)
/* harmony export */ });
/* harmony import */ var _InboundRTPStats__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InboundRTPStats */ "../../library/dist/esm/PeerConnectionController/InboundRTPStats.js");
/* harmony import */ var _DataChannelStats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DataChannelStats */ "../../library/dist/esm/PeerConnectionController/DataChannelStats.js");
/* harmony import */ var _CandidateStat__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CandidateStat */ "../../library/dist/esm/PeerConnectionController/CandidateStat.js");
/* harmony import */ var _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OutBoundRTPStats */ "../../library/dist/esm/PeerConnectionController/OutBoundRTPStats.js");
/* harmony import */ var _SessionStats__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SessionStats */ "../../library/dist/esm/PeerConnectionController/SessionStats.js");
/* harmony import */ var _StreamStats__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./StreamStats */ "../../library/dist/esm/PeerConnectionController/StreamStats.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.







/**
 * The Aggregated Stats that is generated from the RTC Stats Report
 */
class AggregatedStats {
    constructor() {
        this.inboundVideoStats = new _InboundRTPStats__WEBPACK_IMPORTED_MODULE_0__.InboundVideoStats();
        this.inboundAudioStats = new _InboundRTPStats__WEBPACK_IMPORTED_MODULE_0__.InboundAudioStats();
        this.candidatePairs = new Array();
        this.datachannelStats = new _DataChannelStats__WEBPACK_IMPORTED_MODULE_1__.DataChannelStats();
        this.localCandidates = new Array();
        this.remoteCandidates = new Array();
        this.outboundVideoStats = new _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__.OutboundRTPStats();
        this.outboundAudioStats = new _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__.OutboundRTPStats();
        this.remoteOutboundAudioStats = new _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__.RemoteOutboundRTPStats();
        this.remoteOutboundVideoStats = new _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__.RemoteOutboundRTPStats();
        this.sessionStats = new _SessionStats__WEBPACK_IMPORTED_MODULE_3__.SessionStats();
        this.streamStats = new _StreamStats__WEBPACK_IMPORTED_MODULE_4__.StreamStats();
        this.codecs = new Map();
    }
    /**
     * Gather all the information from the RTC Peer Connection Report
     * @param rtcStatsReport - RTC Stats Report
     */
    processStats(rtcStatsReport) {
        this.localCandidates = new Array();
        this.remoteCandidates = new Array();
        this.candidatePairs = new Array();
        rtcStatsReport.forEach((stat) => {
            const type = stat.type;
            switch (type) {
                case 'candidate-pair':
                    this.handleCandidatePair(stat);
                    break;
                case 'certificate':
                    break;
                case 'codec':
                    this.handleCodec(stat);
                    break;
                case 'data-channel':
                    this.handleDataChannel(stat);
                    break;
                case 'inbound-rtp':
                    this.handleInboundRTP(stat);
                    break;
                case 'local-candidate':
                    this.handleLocalCandidate(stat);
                    break;
                case 'media-source':
                    break;
                case 'media-playout':
                    break;
                case 'outbound-rtp':
                    this.handleLocalOutbound(stat);
                    break;
                case 'peer-connection':
                    break;
                case 'remote-candidate':
                    this.handleRemoteCandidate(stat);
                    break;
                case 'remote-inbound-rtp':
                    break;
                case 'remote-outbound-rtp':
                    this.handleRemoteOutbound(stat);
                    break;
                case 'track':
                    this.handleTrack(stat);
                    break;
                case 'transport':
                    this.handleTransport(stat);
                    break;
                case 'stream':
                    this.handleStream(stat);
                    break;
                default:
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Logger.Error('unhandled Stat Type');
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Logger.Info(stat);
                    break;
            }
        });
    }
    /**
     * Process stream stats data from webrtc
     *
     * @param stat - the stats coming in from webrtc
     */
    handleStream(stat) {
        this.streamStats = stat;
    }
    /**
     * Process the Ice Candidate Pair Data
     * @param stat - the stats coming in from ice candidates
     */
    handleCandidatePair(stat) {
        // Add the candidate pair to the candidate pair array
        this.candidatePairs.push(stat);
    }
    /**
     * Process the Data Channel Data
     * @param stat - the stats coming in from the data channel
     */
    handleDataChannel(stat) {
        this.datachannelStats.bytesReceived = stat.bytesReceived;
        this.datachannelStats.bytesSent = stat.bytesSent;
        this.datachannelStats.dataChannelIdentifier = stat.dataChannelIdentifier;
        this.datachannelStats.id = stat.id;
        this.datachannelStats.label = stat.label;
        this.datachannelStats.messagesReceived = stat.messagesReceived;
        this.datachannelStats.messagesSent = stat.messagesSent;
        this.datachannelStats.protocol = stat.protocol;
        this.datachannelStats.state = stat.state;
        this.datachannelStats.timestamp = stat.timestamp;
    }
    /**
     * Process the Local Ice Candidate Data
     * @param stat - local stats
     */
    handleLocalCandidate(stat) {
        const localCandidate = new _CandidateStat__WEBPACK_IMPORTED_MODULE_6__.CandidateStat();
        localCandidate.label = 'local-candidate';
        localCandidate.address = stat.address;
        localCandidate.port = stat.port;
        localCandidate.protocol = stat.protocol;
        localCandidate.candidateType = stat.candidateType;
        localCandidate.id = stat.id;
        localCandidate.relayProtocol = stat.relayProtocol;
        localCandidate.transportId = stat.transportId;
        this.localCandidates.push(localCandidate);
    }
    /**
     * Process the Remote Ice Candidate Data
     * @param stat - ice candidate stats
     */
    handleRemoteCandidate(stat) {
        const remoteCandidate = new _CandidateStat__WEBPACK_IMPORTED_MODULE_6__.CandidateStat();
        remoteCandidate.label = 'remote-candidate';
        remoteCandidate.address = stat.address;
        remoteCandidate.port = stat.port;
        remoteCandidate.protocol = stat.protocol;
        remoteCandidate.id = stat.id;
        remoteCandidate.candidateType = stat.candidateType;
        remoteCandidate.relayProtocol = stat.relayProtocol;
        remoteCandidate.transportId = stat.transportId;
        this.remoteCandidates.push(remoteCandidate);
    }
    /**
     * Process the Inbound RTP Audio and Video Data
     * @param stat - inbound rtp stats
     */
    handleInboundRTP(stat) {
        switch (stat.kind) {
            case 'video':
                // Calculate bitrate between stat updates
                if (stat.bytesReceived > this.inboundVideoStats.bytesReceived &&
                    stat.timestamp > this.inboundVideoStats.timestamp) {
                    this.inboundVideoStats.bitrate =
                        (8 * (stat.bytesReceived - this.inboundVideoStats.bytesReceived)) /
                            (stat.timestamp - this.inboundVideoStats.timestamp);
                    this.inboundVideoStats.bitrate = Math.floor(this.inboundVideoStats.bitrate);
                }
                // Copy members from stat into `this.inboundVideoStats`
                for (const key in stat) {
                    this.inboundVideoStats[key] = stat[key];
                }
                break;
            case 'audio':
                if (stat.bytesReceived > this.inboundAudioStats.bytesReceived &&
                    stat.timestamp > this.inboundAudioStats.timestamp) {
                    this.inboundAudioStats.bitrate =
                        (8 * (stat.bytesReceived - this.inboundAudioStats.bytesReceived)) /
                            (stat.timestamp - this.inboundAudioStats.timestamp);
                    this.inboundAudioStats.bitrate = Math.floor(this.inboundAudioStats.bitrate);
                }
                // Copy members from stat into `this.inboundAudioStats`
                for (const key in stat) {
                    this.inboundAudioStats[key] = stat[key];
                }
                break;
            default:
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Logger.Error(`Kind should be audio or video, we got ${stat.kind} - that's unsupported.`);
                break;
        }
    }
    /**
     * Process the "local" outbound RTP Audio and Video stats.
     * @param stat - local outbound rtp stats
     */
    handleLocalOutbound(stat) {
        const localOutboundStats = stat.kind === 'audio' ? this.outboundAudioStats : this.outboundVideoStats;
        localOutboundStats.active = stat.active;
        localOutboundStats.codecId = stat.codecId;
        localOutboundStats.bytesSent = stat.bytesSent;
        localOutboundStats.frameHeight = stat.frameHeight;
        localOutboundStats.frameWidth = stat.frameWidth;
        localOutboundStats.framesEncoded = stat.framesEncoded;
        localOutboundStats.framesPerSecond = stat.framesPerSecond;
        localOutboundStats.headerBytesSent = stat.headerBytesSent;
        localOutboundStats.id = stat.id;
        localOutboundStats.keyFramesEncoded = stat.keyFramesEncoded;
        localOutboundStats.kind = stat.kind;
        localOutboundStats.mediaSourceId = stat.mediaSourceId;
        localOutboundStats.mid = stat.mid;
        localOutboundStats.nackCount = stat.nackCount;
        localOutboundStats.packetsSent = stat.packetsSent;
        localOutboundStats.qpSum = stat.qpSum;
        localOutboundStats.qualityLimitationDurations = stat.qualityLimitationDurations;
        localOutboundStats.qualityLimitationReason = stat.qualityLimitationReason;
        localOutboundStats.remoteId = stat.remoteId;
        localOutboundStats.retransmittedBytesSent = stat.retransmittedBytesSent;
        localOutboundStats.rid = stat.rid;
        localOutboundStats.scalabilityMode = stat.scalabilityMode;
        localOutboundStats.ssrc = stat.ssrc;
        localOutboundStats.targetBitrate = stat.targetBitrate;
        localOutboundStats.timestamp = stat.timestamp;
        localOutboundStats.totalEncodeTime = stat.totalEncodeTime;
        localOutboundStats.totalEncodeBytesTarget = stat.totalEncodeBytesTarget;
        localOutboundStats.totalPacketSendDelay = stat.totalPacketSendDelay;
        localOutboundStats.transportId = stat.transportId;
    }
    /**
     * Process the "remote" outbound RTP Audio and Video stats.
     * @param stat - remote outbound rtp stats
     */
    handleRemoteOutbound(stat) {
        const remoteOutboundStats = stat.kind === 'audio' ? this.remoteOutboundAudioStats : this.remoteOutboundVideoStats;
        remoteOutboundStats.bytesSent = stat.bytesSent;
        remoteOutboundStats.codecId = stat.codecId;
        remoteOutboundStats.id = stat.id;
        remoteOutboundStats.kind = stat.kind;
        remoteOutboundStats.localId = stat.localId;
        remoteOutboundStats.packetsSent = stat.packetsSent;
        remoteOutboundStats.remoteTimestamp = stat.remoteTimestamp;
        remoteOutboundStats.reportsSent = stat.reportsSent;
        remoteOutboundStats.roundTripTimeMeasurements = stat.roundTripTimeMeasurements;
        remoteOutboundStats.ssrc = stat.ssrc;
        remoteOutboundStats.timestamp = stat.timestamp;
        remoteOutboundStats.totalRoundTripTime = stat.totalRoundTripTime;
        remoteOutboundStats.transportId = stat.transportId;
    }
    /**
     * Process the Inbound Video Track Data
     * @param stat - video track stats
     */
    handleTrack(stat) {
        // we only want to extract stats from the video track
        if (stat.type === 'track' && (stat.trackIdentifier === 'video_label' || stat.kind === 'video')) {
            this.inboundVideoStats.framesDropped = stat.framesDropped;
            this.inboundVideoStats.framesReceived = stat.framesReceived;
            this.inboundVideoStats.frameHeight = stat.frameHeight;
            this.inboundVideoStats.frameWidth = stat.frameWidth;
        }
    }
    handleTransport(stat) {
        this.transportStats = stat;
    }
    handleCodec(stat) {
        const codecId = stat.id;
        this.codecs.set(codecId, stat);
    }
    handleSessionStatistics(videoStartTime, inputController, videoEncoderAvgQP) {
        const deltaTime = Date.now() - videoStartTime;
        this.sessionStats.runTime = new Date(deltaTime).toISOString().substr(11, 8).toString();
        const controlsStreamInput = inputController === null ? 'Not sent yet' : inputController ? 'true' : 'false';
        this.sessionStats.controlsStreamInput = controlsStreamInput;
        this.sessionStats.videoEncoderAvgQP = videoEncoderAvgQP;
    }
    /**
     * Check if a value coming in from our stats is actually a number
     * @param value - the number to be checked
     */
    isNumber(value) {
        return typeof value === 'number' && isFinite(value);
    }
    /**
     * Helper function to return the active candidate pair
     * @returns The candidate pair that is currently receiving data
     */
    getActiveCandidatePair() {
        if (this.candidatePairs === undefined) {
            return null;
        }
        // Check if the RTCTransport stat is not undefined
        if (this.transportStats) {
            // Return the candidate pair that matches the transport candidate pair id
            const selectedPair = this.candidatePairs.find((candidatePair) => candidatePair.id === this.transportStats.selectedCandidatePairId);
            if (selectedPair === undefined) {
                return null;
            }
            else {
                return selectedPair;
            }
        }
        // Fall back to the `.selected` member of the candidate pair
        const selectedPair = this.candidatePairs.find((candidatePair) => candidatePair.selected);
        if (selectedPair === undefined) {
            return null;
        }
        else {
            return selectedPair;
        }
    }
}
//# sourceMappingURL=AggregatedStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/CandidateStat.js":
/*!************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/CandidateStat.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CandidateStat: () => (/* binding */ CandidateStat)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * ICE Candidate Stat collected from the RTC Stats Report
 */
class CandidateStat {
}
//# sourceMappingURL=CandidateStat.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/DataChannelStats.js":
/*!***************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/DataChannelStats.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataChannelStats: () => (/* binding */ DataChannelStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Data Channel Stats collected from the RTC Stats Report
 */
class DataChannelStats {
}
//# sourceMappingURL=DataChannelStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/InboundRTPStats.js":
/*!**************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/InboundRTPStats.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InboundAudioStats: () => (/* binding */ InboundAudioStats),
/* harmony export */   InboundRTPStats: () => (/* binding */ InboundRTPStats),
/* harmony export */   InboundVideoStats: () => (/* binding */ InboundVideoStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Inbound Audio Stats collected from the RTC Stats Report
 */
class InboundAudioStats {
}
/**
 * Inbound Video Stats collected from the RTC Stats Report
 */
class InboundVideoStats {
}
/**
 * Inbound Stats collected from the RTC Stats Report
 */
class InboundRTPStats {
}
//# sourceMappingURL=InboundRTPStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/LatencyCalculator.js":
/*!****************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/LatencyCalculator.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FrameTimingInfo: () => (/* binding */ FrameTimingInfo),
/* harmony export */   LatencyCalculator: () => (/* binding */ LatencyCalculator),
/* harmony export */   LatencyInfo: () => (/* binding */ LatencyInfo)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Represents either a:
 * - synchronization source: https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpReceiver/getSynchronizationSources
 * - contributing source: https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpReceiver/getContributingSources
 * Which also (if browser supports it) may optionall contain fields for captureTimestamp + senderCaptureTimeOffset
 * if the abs-capture-time RTP header extension is enabled (currently this only works in Chromium based browsers).
 */
class RTCRtpCaptureSource {
}
/**
 * FrameTimingInfo is a Chromium-specific set of WebRTC stats useful for latency calculation. It is stored in WebRTC stats as `googTimingFrameInfo`.
 * It is defined as an RTP header extension here: https://webrtc.googlesource.com/src/+/refs/heads/main/docs/native-code/rtp-hdrext/video-timing/README.md
 * It is defined in source code here: https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/api/video/video_timing.cc;l=82;drc=8d399817282e3c12ed54eb23ec42a5e418298ec6
 * It is discussed by its author here: https://github.com/w3c/webrtc-provisional-stats/issues/40#issuecomment-1272916692
 * In summary it a comma-delimited string that contains the following (in this order):
 * 1)  RTP timestamp: the RTP timestamp of the frame
 * 2)  Capture time: timestamp when this frame was captured
 * 3)  Encode start: timestamp when this frame started to be encoded
 * 4)  Encode finish: timestamp when this frame finished encoding
 * 5)  Packetization finish: timestamp when this frame was split into packets and was ready to be sent over the network
 * 6)  Pacer exit: timestamp when last packet of this frame was sent over the network by the sender at this timestamp
 * 7)  Network timestamp1: place for the SFU to mark when the frame started being forwarded. Application specific.
 * 8)  Network timestamp2: place for the SFU to mark when the frame finished being forwarded. Application specific.
 * 9)  Receive start: timestamp when the first packet of this frame was received
 * 10) Receive finish: timestamp when the last packet of this frame was received
 * 11) Decode start:  timestamp when the frame was passed to decoder
 * 12) Decode finish:  timestamp when the frame was decoded
 * 13) Render time:  timestamp of the projected render time for this frame
 * 14) "is outlier": a flag for if this frame is bigger in encoded size than the average frame by at least 5x.
 * 15) "triggered by timer": a flag for if this report was triggered by the timer (The report is sent every 200ms)
 */
class FrameTimingInfo {
}
/**
 * Calculates a combination of latency statistics using purely WebRTC API.
 */
class LatencyCalculator {
    constructor() {
        /* Clock offset between peer clocks cannot always be calculated as it relies of latest sender reports.
         * so we store the last time we had a valid clock offset in the assumption that clocks haven't drifted too much since then.
         */
        this.latestSenderRecvClockOffset = null;
    }
    calculate(stats, receivers) {
        const latencyInfo = new LatencyInfo();
        const rttMS = this.getRTTMs(stats);
        if (rttMS != null) {
            latencyInfo.rttMs = rttMS;
            // Calculate sender latency using the first valid video ssrc/csrc
            const captureSource = this.getCaptureSource(receivers);
            if (captureSource != null) {
                const senderLatencyMs = this.calculateSenderLatency(stats, captureSource);
                if (senderLatencyMs !== null) {
                    latencyInfo.senderLatencyMs = senderLatencyMs;
                }
            }
        }
        // https://w3c.github.io/webrtc-stats/#dom-rtcinboundrtpstreamstats-totalprocessingdelay
        if (stats.inboundVideoStats.totalProcessingDelay !== undefined &&
            stats.inboundVideoStats.framesDecoded !== undefined) {
            latencyInfo.averageProcessingDelayMs =
                (stats.inboundVideoStats.totalProcessingDelay / stats.inboundVideoStats.framesDecoded) * 1000;
        }
        // https://w3c.github.io/webrtc-stats/#dom-rtcinboundrtpstreamstats-jitterbufferminimumdelay
        if (stats.inboundVideoStats.jitterBufferDelay !== undefined &&
            stats.inboundVideoStats.jitterBufferEmittedCount !== undefined) {
            latencyInfo.averageJitterBufferDelayMs =
                (stats.inboundVideoStats.jitterBufferDelay /
                    stats.inboundVideoStats.jitterBufferEmittedCount) *
                    1000;
        }
        // https://w3c.github.io/webrtc-stats/#dom-rtcinboundrtpstreamstats-totaldecodetime
        if (stats.inboundVideoStats.framesDecoded !== undefined &&
            stats.inboundVideoStats.totalDecodeTime !== undefined) {
            latencyInfo.averageDecodeLatencyMs =
                (stats.inboundVideoStats.totalDecodeTime / stats.inboundVideoStats.framesDecoded) * 1000;
        }
        // https://w3c.github.io/webrtc-stats/#dom-rtcinboundrtpstreamstats-framesassembledfrommultiplepackets
        if (stats.inboundVideoStats.totalAssemblyTime !== undefined &&
            stats.inboundVideoStats.framesAssembledFromMultiplePackets !== undefined) {
            latencyInfo.averageAssemblyDelayMs =
                (stats.inboundVideoStats.totalAssemblyTime /
                    stats.inboundVideoStats.framesAssembledFromMultiplePackets) *
                    1000;
        }
        // Extract extra Chrome-specific stats like encoding latency
        if (stats.inboundVideoStats.googTimingFrameInfo !== undefined &&
            stats.inboundVideoStats.googTimingFrameInfo.length > 0) {
            latencyInfo.frameTiming = this.extractFrameTimingInfo(stats.inboundVideoStats.googTimingFrameInfo);
        }
        // Calculate E2E latency using video-timing capture to send time + one way network latency + receiver-side latency
        if (latencyInfo.frameTiming !== undefined &&
            latencyInfo.frameTiming.captureToSendLatencyMs !== undefined &&
            latencyInfo.averageProcessingDelayMs !== undefined &&
            latencyInfo.rttMs !== undefined) {
            latencyInfo.averageE2ELatency =
                latencyInfo.frameTiming.captureToSendLatencyMs +
                    latencyInfo.rttMs * 0.5 +
                    latencyInfo.averageProcessingDelayMs;
        }
        // Calculate E2E latency as abs-capture-time capture to send latency + one way network latency + receiver-side latency
        if (latencyInfo.senderLatencyMs != undefined &&
            latencyInfo.averageProcessingDelayMs !== undefined &&
            latencyInfo.rttMs !== undefined) {
            latencyInfo.averageE2ELatency =
                latencyInfo.senderLatencyMs + latencyInfo.rttMs * 0.5 + latencyInfo.averageProcessingDelayMs;
        }
        return latencyInfo;
    }
    extractFrameTimingInfo(googTimingFrameInfo) {
        const timingInfo = new FrameTimingInfo();
        const timingInfoArr = googTimingFrameInfo.split(',');
        // Should have exactly 15 elements according to:
        // https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/api/video/video_timing.cc;l=82;drc=8d399817282e3c12ed54eb23ec42a5e418298ec6
        if (timingInfoArr.length === 15) {
            timingInfo.rtpTimestamp = Number.parseInt(timingInfoArr[0]);
            timingInfo.captureTimestamp = Number.parseInt(timingInfoArr[1]);
            timingInfo.encodeStartTimestamp = Number.parseInt(timingInfoArr[2]);
            timingInfo.encodeFinishTimestamp = Number.parseInt(timingInfoArr[3]);
            timingInfo.packetizerFinishTimestamp = Number.parseInt(timingInfoArr[4]);
            timingInfo.pacerExitTimestamp = Number.parseInt(timingInfoArr[5]);
            timingInfo.networkTimestamp1 = Number.parseInt(timingInfoArr[6]);
            timingInfo.networkTimestamp2 = Number.parseInt(timingInfoArr[7]);
            timingInfo.receiveStart = Number.parseInt(timingInfoArr[8]);
            timingInfo.receiveFinish = Number.parseInt(timingInfoArr[9]);
            timingInfo.decodeStart = Number.parseInt(timingInfoArr[10]);
            timingInfo.decodeFinish = Number.parseInt(timingInfoArr[11]);
            timingInfo.renderTime = Number.parseInt(timingInfoArr[12]);
            timingInfo.isOutlier = Number.parseInt(timingInfoArr[13]) > 0;
            timingInfo.isTriggeredByTimer = Number.parseInt(timingInfoArr[14]) > 0;
            // Calculate some latency stats
            timingInfo.encoderLatencyMs = timingInfo.encodeFinishTimestamp - timingInfo.encodeStartTimestamp;
            timingInfo.packetizeLatencyMs =
                timingInfo.packetizerFinishTimestamp - timingInfo.encodeFinishTimestamp;
            timingInfo.pacerLatencyMs = timingInfo.pacerExitTimestamp - timingInfo.packetizerFinishTimestamp;
            timingInfo.captureToSendLatencyMs = timingInfo.pacerExitTimestamp - timingInfo.captureTimestamp;
        }
        return timingInfo;
    }
    calculateSenderLatency(stats, captureSource) {
        // The calculation performed in this function is as per the procedure defined here:
        // https://w3c.github.io/webrtc-extensions/#dom-rtcrtpcontributingsource-sendercapturetimeoffset
        // Get the sender capture in the sender's clock
        const senderCaptureTimestamp = captureSource.captureTimestamp + captureSource.senderCaptureTimeOffset;
        let sendRecvClockOffset = this.calculateSenderReceiverClockOffset(stats);
        // Use latest clock offset if we couldn't calculate one now
        if (sendRecvClockOffset == null) {
            if (this.latestSenderRecvClockOffset != null) {
                sendRecvClockOffset = this.latestSenderRecvClockOffset;
            }
            else {
                return null;
            }
        }
        else {
            this.latestSenderRecvClockOffset = sendRecvClockOffset;
        }
        // This brings sender clock roughly inline with recv clock
        const recvCaptureTimestampNTP = senderCaptureTimestamp + sendRecvClockOffset;
        // As defined in Chrome source: https://chromium.googlesource.com/external/webrtc/+/master/system_wrappers/include/clock.h#26
        const ntp1970 = 2208988800000;
        const recvCaptureTimestamp = recvCaptureTimestampNTP - ntp1970;
        const senderLatency = captureSource.timestamp - recvCaptureTimestamp;
        return senderLatency;
    }
    /**
     * Find the first valid ssrc or csrc that has capture time fields present from abs-capture-time header extension.
     * @param receivers The RTP receviers this peer connection has.
     * @returns A single valid ssrc or csrc that has capture time fields or null if there is none (e.g. in non-chromium browsers it will be null).
     */
    getCaptureSource(receivers) {
        // We only want video receivers
        receivers = receivers.filter((receiver) => receiver.track.kind === 'video');
        for (const receiver of receivers) {
            // Go through all ssrc and csrc to check for capture timestamp
            // Note: Conversion to `any` here is because TS does not have captureTimestamp etc defined in the types
            // these fields only exist in Chromium currently.
            const sources = receiver
                .getSynchronizationSources()
                .concat(receiver.getContributingSources());
            for (const src of sources) {
                if (src.captureTimestamp !== undefined &&
                    src.senderCaptureTimeOffset !== undefined &&
                    src.timestamp !== undefined) {
                    const captureSrc = new RTCRtpCaptureSource();
                    captureSrc.timestamp = src.timestamp;
                    captureSrc.captureTimestamp = src.captureTimestamp;
                    captureSrc.senderCaptureTimeOffset = src.senderCaptureTimeOffset;
                    return captureSrc;
                }
            }
        }
        return null;
    }
    calculateSenderReceiverClockOffset(stats) {
        // The calculation performed in this function is as per the procedure defined here:
        // https://w3c.github.io/webrtc-extensions/#dom-rtcrtpcontributingsource-sendercapturetimeoffset
        const hasRemoteOutboundVideoStats = stats.remoteOutboundVideoStats !== undefined &&
            stats.remoteOutboundVideoStats.timestamp !== undefined &&
            stats.remoteOutboundVideoStats.remoteTimestamp !== undefined;
        // Note: As of Chrome 132, remote-outbound-rtp stats for video are not yet implemented (audio works).
        // This codepath should activate once they do begin to work.
        if (!hasRemoteOutboundVideoStats) {
            return null;
        }
        const remoteStatsArrivedTimestamp = stats.remoteOutboundVideoStats.timestamp;
        const remoteStatsSentTimestamp = stats.remoteOutboundVideoStats.remoteTimestamp;
        const rttMs = this.getRTTMs(stats);
        if (remoteStatsArrivedTimestamp !== undefined &&
            remoteStatsSentTimestamp !== undefined &&
            rttMs !== null) {
            const onewayDelay = rttMs * 0.5;
            return remoteStatsArrivedTimestamp - (remoteStatsSentTimestamp + onewayDelay);
        }
        // Could not get stats to calculate sender/receiver clock offset
        else {
            return null;
        }
    }
    getRTTMs(stats) {
        // Try to get it from the active candidate pair
        const activeCandidatePair = stats.getActiveCandidatePair();
        if (!!activeCandidatePair && activeCandidatePair.currentRoundTripTime !== undefined) {
            const curRTTSeconds = activeCandidatePair.currentRoundTripTime;
            return curRTTSeconds * 1000;
        }
        // Next try to get it from remote-outbound-rtp video stats
        if (!!stats.remoteOutboundVideoStats &&
            stats.remoteOutboundVideoStats.totalRoundTripTime !== undefined &&
            stats.remoteOutboundVideoStats.roundTripTimeMeasurements !== undefined &&
            stats.remoteOutboundVideoStats.roundTripTimeMeasurements > 0) {
            const avgRttSeconds = stats.remoteOutboundVideoStats.totalRoundTripTime /
                stats.remoteOutboundVideoStats.roundTripTimeMeasurements;
            return avgRttSeconds * 1000;
        }
        // Next try to get it from remote-outbound-rtp audio stats
        if (!!stats.remoteOutboundAudioStats &&
            stats.remoteOutboundAudioStats.totalRoundTripTime !== undefined &&
            stats.remoteOutboundAudioStats.roundTripTimeMeasurements !== undefined &&
            stats.remoteOutboundAudioStats.roundTripTimeMeasurements > 0) {
            const avgRttSeconds = stats.remoteOutboundAudioStats.totalRoundTripTime /
                stats.remoteOutboundAudioStats.roundTripTimeMeasurements;
            return avgRttSeconds * 1000;
        }
        return null;
    }
}
/**
 * A collection of latency information calculated using the WebRTC API.
 * Most stats are calculated following the spec:
 * https://w3c.github.io/webrtc-stats/#dictionary-rtcinboundrtpstreamstats-members
 */
class LatencyInfo {
    constructor() {
        /**
         * The time taken from the moment a frame is done capturing to the moment it is sent over the network.
         * Note: This can only be calculated if both offer and answer contain the
         * the RTP header extension for `video-timing` (Chrome only for now)
         */
        this.senderLatencyMs = undefined;
        /**
         * The time taken from the moment a frame is done capturing to the moment it is sent over the network.
         * Note: This can only be calculated if both offer and answer contain the
         * the RTP header extension for `abs-capture-time` (Chrome only for now)
         */
        this.senderLatencyAbsCaptureTimeMs = undefined;
        /* The round trip time (milliseconds) between each sender->receiver->sender */
        this.rttMs = undefined;
        /* Average time taken (milliseconds) from video packet receipt to post-decode. */
        this.averageProcessingDelayMs = undefined;
        /* Average time taken (milliseconds) inside the jitter buffer (which is post-receipt but pre-decode). */
        this.averageJitterBufferDelayMs = undefined;
        /* Average time taken (milliseconds) to decode a video frame. */
        this.averageDecodeLatencyMs = undefined;
        /* Average time taken (milliseconds) to between receipt of the first and last video packet of a. */
        this.averageAssemblyDelayMs = undefined;
        /* The sender latency + RTT/2 + processing delay */
        this.averageE2ELatency = undefined;
        /* Timing information about the worst performing frame since the last getStats call (only works on Chrome) */
        this.frameTiming = undefined;
    }
}
//# sourceMappingURL=LatencyCalculator.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/OutBoundRTPStats.js":
/*!***************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/OutBoundRTPStats.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OutboundRTPStats: () => (/* binding */ OutboundRTPStats),
/* harmony export */   RemoteOutboundRTPStats: () => (/* binding */ RemoteOutboundRTPStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Outbound RTP stats collected from the RTC Stats Report under `outbound-rtp`.
 * Wrapper around: https://developer.mozilla.org/en-US/docs/Web/API/RTCOutboundRtpStreamStats
 * These are stats for video we are sending to a remote peer.
 */
class OutboundRTPStats {
}
/**
 * Remote outbound stats collected from the RTC Stats Report under `remote-outbound-rtp`.
 * Wrapper around: https://developer.mozilla.org/en-US/docs/Web/API/RTCRemoteOutboundRtpStreamStats
 * These are stats for media we are receiving from a remote peer.
 */
class RemoteOutboundRTPStats {
}
//# sourceMappingURL=OutBoundRTPStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/PeerConnectionController.js":
/*!***********************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/PeerConnectionController.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PeerConnectionController: () => (/* binding */ PeerConnectionController),
/* harmony export */   kAbsCaptureTime: () => (/* binding */ kAbsCaptureTime)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _AggregatedStats__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AggregatedStats */ "../../library/dist/esm/PeerConnectionController/AggregatedStats.js");
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sdp */ "../../../node_modules/sdp/sdp.js");
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sdp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Util_RTCUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Util/RTCUtils */ "../../library/dist/esm/Util/RTCUtils.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Util/SdpUtils.js");
/* harmony import */ var _LatencyCalculator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LatencyCalculator */ "../../library/dist/esm/PeerConnectionController/LatencyCalculator.js");
// Copyright Epic Games, Inc. All Rights Reserved.
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







const kAbsCaptureTime = 'http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time';
/**
 * Handles the Peer Connection
 */
class PeerConnectionController {
    /**
     * Create a new RTC Peer Connection client
     * @param options - Peer connection Options
     * @param config - The config for our PS experience.
     */
    constructor(options, config, preferredCodec) {
        this.config = config;
        this.createPeerConnection(options, preferredCodec);
        this.latencyCalculator = new _LatencyCalculator__WEBPACK_IMPORTED_MODULE_1__.LatencyCalculator();
    }
    createPeerConnection(options, preferredCodec) {
        // Set the ICE transport to relay if TURN enabled
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.ForceTURN)) {
            options.iceTransportPolicy = 'relay';
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('Forcing TURN usage by setting ICE Transport Policy in peer connection config.');
        }
        // build a new peer connection with the options
        this.peerConnection = new RTCPeerConnection(options);
        this.peerConnection.onsignalingstatechange = (ev) => this.handleSignalStateChange(ev);
        this.peerConnection.oniceconnectionstatechange = (ev) => this.handleIceConnectionStateChange(ev);
        this.peerConnection.onicegatheringstatechange = (ev) => this.handleIceGatheringStateChange(ev);
        this.peerConnection.ontrack = (ev) => this.handleOnTrack(ev);
        this.peerConnection.onicecandidate = (ev) => this.handleIceCandidate(ev);
        this.peerConnection.ondatachannel = (ev) => this.handleDataChannel(ev);
        this.aggregatedStats = new _AggregatedStats__WEBPACK_IMPORTED_MODULE_4__.AggregatedStats();
        this.preferredCodec = preferredCodec;
        this.updateCodecSelection = true;
    }
    /**
     * Create an offer for the Web RTC handshake and send the offer to the signaling server via websocket
     * @param offerOptions - RTC Offer Options
     */
    createOffer(offerOptions, config) {
        return __awaiter(this, void 0, void 0, function* () {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('Create Offer');
            const isLocalhostConnection = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
            const isHttpsConnection = location.protocol === 'https:';
            let useMic = config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.UseMic);
            let useCamera = config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.UseCamera);
            if ((useMic || useCamera) && !(isLocalhostConnection || isHttpsConnection)) {
                useMic = false;
                useCamera = false;
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error('Microphone and Webcam access in the browser will not work if you are not on HTTPS or localhost. Disabling mic and webcam access.');
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error("For testing you can enable HTTP microphone access Chrome by visiting chrome://flags/ and enabling 'unsafely-treat-insecure-origin-as-secure'");
            }
            this.setupTransceiversAsync(useMic, useCamera).finally(() => {
                var _a;
                (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.createOffer(offerOptions).then((offer) => {
                    var _a;
                    this.showTextOverlayConnecting();
                    offer.sdp = this.mungeSDP(offer.sdp, useMic);
                    (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setLocalDescription(offer);
                    this.onSendWebRTCOffer(offer);
                }).catch(() => {
                    this.showTextOverlaySetupFailure();
                });
            });
        });
    }
    /**
     * Receive offer from UE side and process it as the remote description of this peer connection
     */
    receiveOffer(offer, config) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('Receive Offer');
            // If UE or JSStreamer did send abs-capture-time RTP header extension to a non-Chrome browser
            // then remove it from the SDP because if Firefox detects it in offer or answer it will fail to connect
            // due having 15 or more header extensions: https://mailarchive.ietf.org/arch/msg/rtcweb/QRnWNuWzGuLRovWdHkodNP6VOgg/
            if (this.isFirefox()) {
                // example: a=extmap:15 http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time
                offer.sdp = offer.sdp.replace(/^a=extmap:\d+ http:\/\/www\.webrtc\.org\/experiments\/rtp-hdrext\/abs-capture-time\r\n/gm, '');
            }
            (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setRemoteDescription(offer).then(() => {
                // Fire event for when remote offer description is set
                this.onSetRemoteDescription(offer);
                const isLocalhostConnection = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
                const isHttpsConnection = location.protocol === 'https:';
                let useMic = config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.UseMic);
                let useCamera = config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.UseCamera);
                if ((useMic || useCamera) && !(isLocalhostConnection || isHttpsConnection)) {
                    useMic = false;
                    useCamera = false;
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error('Microphone and Webcam access in the browser will not work if you are not on HTTPS or localhost. Disabling mic and webcam access.');
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error("For testing you can enable HTTP microphone access Chrome by visiting chrome://flags/ and enabling 'unsafely-treat-insecure-origin-as-secure'");
                }
                // Add our list of preferred codecs, in order of preference
                this.config.setOptionSettingOptions(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec, this.fuzzyIntersectUEAndBrowserCodecs(offer));
                this.setupTransceiversAsync(useMic, useCamera).finally(() => {
                    var _a;
                    (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.createAnswer().then((Answer) => {
                        var _a;
                        Answer.sdp = this.mungeSDP(Answer.sdp, useMic);
                        return (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setLocalDescription(Answer);
                    }).then(() => {
                        var _a;
                        this.onSetLocalDescription((_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.localDescription);
                    }).catch((err) => {
                        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error(`createAnswer() failed - ${err}`);
                    });
                });
            });
        });
    }
    /**
     * Set the Remote Descriptor from the signaling server to the RTC Peer Connection
     * @param answer - RTC Session Descriptor from the Signaling Server
     */
    receiveAnswer(answer) {
        var _a;
        (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setRemoteDescription(answer);
        // Add our list of preferred codecs, in order of preference
        this.config.setOptionSettingOptions(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec, this.fuzzyIntersectUEAndBrowserCodecs(answer));
    }
    /**
     * Generate Aggregated Stats and then fire a onVideo Stats event
     */
    generateStats() {
        this.peerConnection.getStats().then((statsData) => {
            this.aggregatedStats.processStats(statsData);
            this.onVideoStats(this.aggregatedStats);
            // Calculate latency using stats and video receivers and then call the handling function
            const latencyInfo = this.latencyCalculator.calculate(this.aggregatedStats, this.peerConnection.getReceivers());
            this.onLatencyCalculated(latencyInfo);
            // Update the preferred codec selection based on what was actually negotiated
            if (this.updateCodecSelection && !!this.aggregatedStats.inboundVideoStats.codecId) {
                // Construct the qualified codec name from the mimetype and fmtp
                const codecStats = this.aggregatedStats.codecs.get(this.aggregatedStats.inboundVideoStats.codecId);
                if (codecStats === undefined) {
                    return;
                }
                const codecShortname = codecStats.mimeType.replace('video/', '');
                let fullCodecName = codecShortname;
                if (codecStats.sdpFmtpLine && codecStats.sdpFmtpLine.trim() !== '') {
                    fullCodecName = `${codecShortname} ${codecStats.sdpFmtpLine.trim()}`;
                }
                const allBrowserCodecs = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec).options;
                // The list of codecs directly contains the one that was negotiated, select that
                if (allBrowserCodecs.includes(fullCodecName)) {
                    this.config.setOptionSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec, fullCodecName);
                    return;
                }
                // If we couldn't match on the full name, try to match on just the codec shortname
                const filteredList = allBrowserCodecs.filter((option) => option.indexOf(codecShortname) !== -1);
                if (filteredList.length > 0) {
                    this.config.setOptionSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec, filteredList[0]);
                    return;
                }
            }
        });
    }
    /**
     * Close The Peer Connection
     */
    close() {
        if (this.peerConnection) {
            this.peerConnection.close();
            this.peerConnection = null;
        }
    }
    /**
     * Modify the Session Descriptor
     * @param sdp - Session Descriptor as a string
     * @param useMic - Is the microphone in use
     * @returns A modified Session Descriptor
     */
    mungeSDP(sdp, useMic) {
        let mungedSDP = sdp.replace(/(a=fmtp:\d+ .*level-asymmetry-allowed=.*)\r\n/gm, '$1;x-google-start-bitrate=10000;x-google-max-bitrate=100000\r\n');
        // set max bitrate to highest bitrate Opus supports
        let audioSDP = 'maxaveragebitrate=510000;';
        if (useMic) {
            // set the max capture rate to 48khz (so we can send high quality audio from mic)
            audioSDP += 'sprop-maxcapturerate=48000;';
        }
        // Force mono or stereo based on whether ?forceMono was passed or not
        audioSDP += this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.ForceMonoAudio) ? 'stereo=0;' : 'stereo=1;';
        // enable in-band forward error correction for opus audio
        audioSDP += 'useinbandfec=1';
        // We use the line 'useinbandfec=1' (which Opus uses) to set our Opus specific audio parameters.
        mungedSDP = mungedSDP.replace('useinbandfec=1', audioSDP);
        // Add abs-capture-time RTP header extension if we have enabled the setting.
        // Note: As at Feb 2025, Chromium based browsers are the only ones that support this and
        // munging it into the answer in Firefox will cause the connection to fail.
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.EnableCaptureTimeExt) && !this.isFirefox()) {
            mungedSDP = _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__.SDPUtils.addVideoHeaderExtensionToSdp(mungedSDP, kAbsCaptureTime);
        }
        return mungedSDP;
    }
    isFirefox() {
        return navigator.userAgent.indexOf('Firefox') > 0;
    }
    /**
     * When a Ice Candidate is received add to the RTC Peer Connection
     * @param iceCandidate - RTC Ice Candidate from the Signaling Server
     */
    handleOnIce(iceCandidate) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('peerconnection handleOnIce');
        // // if forcing TURN, reject any candidates not relay
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.ForceTURN)) {
            // check if no relay address is found, if so, we are assuming it means no TURN server
            if (iceCandidate.candidate.indexOf('relay') < 0) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info(`Dropping candidate because it was not TURN relay. | Type= ${iceCandidate.type} | Protocol= ${iceCandidate.protocol} | Address=${iceCandidate.address} | Port=${iceCandidate.port} |`);
                return;
            }
        }
        (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.addIceCandidate(iceCandidate);
    }
    /**
     * When the RTC Peer Connection Signaling server state Changes
     * @param state - Signaling Server State Change Event
     */
    handleSignalStateChange(state) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('signaling state change: ' + state);
    }
    /**
     * Handle when the Ice Connection State Changes
     * @param state - Ice Connection State
     */
    handleIceConnectionStateChange(state) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('ice connection state change: ' + state);
        this.onIceConnectionStateChange(state);
    }
    /**
     * Handle when the Ice Gathering State Changes
     * @param state - Ice Gathering State Change
     */
    handleIceGatheringStateChange(state) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('ice gathering state change: ' + JSON.stringify(state));
    }
    /**
     * Activates the onTrack method
     * @param event - The webRtc track event
     */
    handleOnTrack(event) {
        if (event.streams.length < 1 || event.streams[0].id == 'probator') {
            return;
        }
        if (event.track.kind == 'video') {
            this.videoTrack = event.track;
        }
        if (event.track.kind == 'audio') {
            this.audioTrack = event.track;
        }
        this.onTrack(event);
    }
    /**
     * Activates the onPeerIceCandidate
     * @param event - The peer ice candidate
     */
    handleIceCandidate(event) {
        this.onPeerIceCandidate(event);
    }
    /**
     * Activates the onDataChannel
     * @param event - The peer's data channel
     */
    handleDataChannel(event) {
        this.onDataChannel(event);
    }
    /**
     * An override method for onTrack for use outside of the PeerConnectionController
     * @param trackEvent - The webRtc track event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onTrack(trackEvent) {
        // Default Functionality: Do Nothing
    }
    /**
     * An override method for onIceConnectionStateChange for use outside of the PeerConnectionController
     * @param event - The webRtc iceconnectionstatechange event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onIceConnectionStateChange(event) {
        // Default Functionality: Do Nothing
    }
    /**
     * An override method for onPeerIceCandidate for use outside of the PeerConnectionController
     * @param peerConnectionIceEvent - The peer ice candidate
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onPeerIceCandidate(peerConnectionIceEvent) {
        // Default Functionality: Do Nothing
    }
    /**
     * An override method for onDataChannel for use outside of the PeerConnectionController
     * @param datachannelEvent - The peer's data channel
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onDataChannel(datachannelEvent) {
        // Default Functionality: Do Nothing
    }
    /**
     * Find the intersection between UE and browser codecs, with fuzzy matching if some parameters are mismatched.
     * @param sdp The remote sdp
     * @returns The intersection between browser supported codecs and ue supported codecs.
     */
    fuzzyIntersectUEAndBrowserCodecs(sdp) {
        // We want to build an array of all supported codecs on both sides
        const allSupportedCodecs = new Array();
        const allUECodecs = this.parseAvailableCodecs(sdp);
        const allBrowserCodecs = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec).options;
        for (const ueCodec of allUECodecs) {
            // Check if browser codecs directly matches UE codec (with parameters and everything)
            if (allBrowserCodecs.includes(ueCodec)) {
                allSupportedCodecs.push(ueCodec);
                continue;
            }
            // Otherwise check if browser codec at least contains a match for the UE codec name (without parameters).
            else {
                const ueCodecNameAndParams = ueCodec.split(' ');
                const ueCodecName = ueCodecNameAndParams[0];
                for (const browserCodec of allBrowserCodecs) {
                    if (browserCodec.includes(ueCodecName)) {
                        // We pass browser codec here as they option contain extra parameters.
                        allSupportedCodecs.push(browserCodec);
                        break;
                    }
                }
            }
        }
        return allSupportedCodecs;
    }
    /**
     * Setup tracks on the RTC Peer Connection
     * @param useMic - is mic in use
     * @param useCamera - is webcam in use
     */
    setupTransceiversAsync(useMic, useCamera) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            let hasVideoReceiver = false;
            for (const transceiver of (_b = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : []) {
                if (transceiver &&
                    transceiver.receiver &&
                    transceiver.receiver.track &&
                    transceiver.receiver.track.kind === 'video') {
                    hasVideoReceiver = true;
                    break;
                }
            }
            // Setup a transceiver for sending webcam video to UE and receiving video from UE
            if (!useCamera) {
                if (!hasVideoReceiver) {
                    (_c = this.peerConnection) === null || _c === void 0 ? void 0 : _c.addTransceiver('video', { direction: 'recvonly' });
                }
            }
            else {
                yield this.setupVideoSender(hasVideoReceiver);
            }
            if (RTCRtpReceiver.getCapabilities && this.preferredCodec != '') {
                for (const transceiver of (_e = (_d = this.peerConnection) === null || _d === void 0 ? void 0 : _d.getTransceivers()) !== null && _e !== void 0 ? _e : []) {
                    if (transceiver &&
                        transceiver.receiver &&
                        transceiver.receiver.track &&
                        transceiver.receiver.track.kind === 'video' &&
                        transceiver.setCodecPreferences) {
                        // Get our preferred codec from the codecs options drop down
                        const preferredRTPCodec = this.preferredCodec.split(' ');
                        const preferredRTCRtpCodecCapability = {
                            mimeType: 'video/' + preferredRTPCodec[0] /* Name */,
                            clockRate: 90000 /* All current video formats in browsers have 90khz clock rate */,
                            sdpFmtpLine: preferredRTPCodec[1] ? preferredRTPCodec[1] : ''
                        };
                        // Populate a list of codecs we will support with our preferred one in the first position
                        const ourSupportedCodecs = [preferredRTCRtpCodecCapability];
                        // Go through all codecs the browser supports and add them to the list (in any order)
                        RTCRtpReceiver.getCapabilities('video').codecs.forEach((browserSupportedCodec) => {
                            // Don't add our preferred codec again, but add everything else
                            if (browserSupportedCodec.mimeType != preferredRTCRtpCodecCapability.mimeType) {
                                ourSupportedCodecs.push(browserSupportedCodec);
                            }
                            else if ((browserSupportedCodec === null || browserSupportedCodec === void 0 ? void 0 : browserSupportedCodec.sdpFmtpLine) !=
                                (preferredRTCRtpCodecCapability === null || preferredRTCRtpCodecCapability === void 0 ? void 0 : preferredRTCRtpCodecCapability.sdpFmtpLine)) {
                                ourSupportedCodecs.push(browserSupportedCodec);
                            }
                        });
                        for (const codec of ourSupportedCodecs) {
                            if ((codec === null || codec === void 0 ? void 0 : codec.sdpFmtpLine) === undefined || codec.sdpFmtpLine === '') {
                                // We can't dynamically add members to the codec, so instead remove the field if it's empty
                                delete codec.sdpFmtpLine;
                            }
                        }
                        transceiver.setCodecPreferences(ourSupportedCodecs);
                    }
                }
            }
            let hasAudioReceiver = false;
            for (const transceiver of (_g = (_f = this.peerConnection) === null || _f === void 0 ? void 0 : _f.getTransceivers()) !== null && _g !== void 0 ? _g : []) {
                if (transceiver &&
                    transceiver.receiver &&
                    transceiver.receiver.track &&
                    transceiver.receiver.track.kind === 'audio') {
                    hasAudioReceiver = true;
                    break;
                }
            }
            // Setup a transceiver for sending mic audio to UE and receiving audio from UE
            if (!useMic) {
                if (!hasAudioReceiver) {
                    (_h = this.peerConnection) === null || _h === void 0 ? void 0 : _h.addTransceiver('audio', {
                        direction: 'recvonly'
                    });
                }
            }
            else {
                yield this.setupAudioSender(hasAudioReceiver);
            }
        });
    }
    setupVideoSender(hasVideoReceiver) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            // set the media send options
            const mediaSendOptions = {
                video: true
            };
            // Note using webcam on android chrome requires SSL or chrome://flags/ "unsafely-treat-insecure-origin-as-secure"
            const stream = yield navigator.mediaDevices.getUserMedia(mediaSendOptions);
            if (stream) {
                if (hasVideoReceiver) {
                    for (const transceiver of (_b = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : []) {
                        if (_Util_RTCUtils__WEBPACK_IMPORTED_MODULE_6__.RTCUtils.canTransceiverReceiveVideo(transceiver)) {
                            for (const track of stream.getTracks()) {
                                if (track.kind && track.kind == 'video') {
                                    transceiver.sender.replaceTrack(track);
                                    transceiver.direction = 'sendrecv';
                                }
                            }
                        }
                    }
                }
                else {
                    for (const track of stream.getTracks()) {
                        if (track.kind && track.kind == 'video') {
                            (_c = this.peerConnection) === null || _c === void 0 ? void 0 : _c.addTransceiver(track, {
                                direction: 'sendrecv'
                            });
                        }
                    }
                }
            }
            else {
                if (!hasVideoReceiver) {
                    (_d = this.peerConnection) === null || _d === void 0 ? void 0 : _d.addTransceiver('video', { direction: 'recvonly' });
                }
            }
        });
    }
    setupAudioSender(hasAudioReceiver) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            // set the audio options based on mic usage
            const audioOptions = {
                autoGainControl: false,
                channelCount: 1,
                echoCancellation: false,
                latency: 0,
                noiseSuppression: false,
                sampleRate: 48000,
                sampleSize: 16,
                volume: 1.0
            };
            // set the media send options
            const mediaSendOptions = {
                video: false,
                audio: audioOptions
            };
            // Note using mic on android chrome requires SSL or chrome://flags/ "unsafely-treat-insecure-origin-as-secure"
            const stream = yield navigator.mediaDevices.getUserMedia(mediaSendOptions);
            if (stream) {
                if (hasAudioReceiver) {
                    for (const transceiver of (_b = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : []) {
                        if (_Util_RTCUtils__WEBPACK_IMPORTED_MODULE_6__.RTCUtils.canTransceiverReceiveAudio(transceiver)) {
                            for (const track of stream.getTracks()) {
                                if (track.kind && track.kind == 'audio') {
                                    transceiver.sender.replaceTrack(track);
                                    transceiver.direction = 'sendrecv';
                                }
                            }
                        }
                    }
                }
                else {
                    for (const track of stream.getTracks()) {
                        if (track.kind && track.kind == 'audio') {
                            (_c = this.peerConnection) === null || _c === void 0 ? void 0 : _c.addTransceiver(track, {
                                direction: 'sendrecv'
                            });
                        }
                    }
                }
            }
            else {
                if (!hasAudioReceiver) {
                    (_d = this.peerConnection) === null || _d === void 0 ? void 0 : _d.addTransceiver('audio', {
                        direction: 'recvonly'
                    });
                }
            }
        });
    }
    /**
     * And override event for when the video stats are fired
     * @param event - Aggregated Stats
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVideoStats(event) {
        // Default Functionality: Do Nothing
    }
    /**
     * And override event for when latency info is calculated
     * @param latencyInfo - Calculated latency information.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onLatencyCalculated(latencyInfo) {
        // Default Functionality: Do Nothing
    }
    /**
     * Event to send the RTC offer to the Signaling server
     * @param offer - RTC Offer
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onSendWebRTCOffer(offer) {
        // Default Functionality: Do Nothing
    }
    /**
     * Event fired when remote offer description is set.
     * @param offer - RTC Offer
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onSetRemoteDescription(offer) {
        // Default Functionality: Do Nothing
    }
    /**
     * Event fire when local description answer is set.
     * @param answer - RTC Answer
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onSetLocalDescription(answer) {
        // Default Functionality: Do Nothing
    }
    /**
     * An override for showing the Peer connection connecting Overlay
     */
    showTextOverlayConnecting() {
        // Default Functionality: Do Nothing
    }
    /**
     * An override for showing the Peer connection Failed overlay
     */
    showTextOverlaySetupFailure() {
        // Default Functionality: Do Nothing
    }
    parseAvailableCodecs(rtcSessionDescription) {
        // No point in updating the available codecs if on FF
        if (!RTCRtpReceiver.getCapabilities)
            return ['Only available on Chrome'];
        const ueSupportedCodecs = [];
        const sections = (0,sdp__WEBPACK_IMPORTED_MODULE_0__.splitSections)(rtcSessionDescription.sdp);
        // discard the session information as we only want media related info
        sections.shift();
        sections.forEach((mediaSection) => {
            const { codecs } = (0,sdp__WEBPACK_IMPORTED_MODULE_0__.parseRtpParameters)(mediaSection);
            // Filter only for VPX / H26X / AV1
            const matcher = /(VP\d|H26\d|AV1).*/;
            codecs.forEach((c) => {
                const str = c.name +
                    ' ' +
                    Object.keys(c.parameters || {})
                        .map((p) => p + '=' + c.parameters[p])
                        .join(';');
                const match = matcher.exec(str);
                if (match !== null) {
                    if (c.name == 'VP9') {
                        // UE answers don't specify profile but we know we want profile 0
                        c.parameters = {
                            'profile-id': '0'
                        };
                    }
                    const codecStr = c.name +
                        ' ' +
                        Object.keys(c.parameters || {})
                            .map((p) => p + '=' + c.parameters[p])
                            .join(';');
                    ueSupportedCodecs.push(codecStr);
                }
            });
        });
        return ueSupportedCodecs;
    }
}
//# sourceMappingURL=PeerConnectionController.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/SessionStats.js":
/*!***********************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/SessionStats.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SessionStats: () => (/* binding */ SessionStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Session statistics
 */
class SessionStats {
}
//# sourceMappingURL=SessionStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/StreamStats.js":
/*!**********************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/StreamStats.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StreamStats: () => (/* binding */ StreamStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Class to hold the stream stats data coming in from webRtc
 */
class StreamStats {
}
//# sourceMappingURL=StreamStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PixelStreaming/PixelStreaming.js":
/*!***************************************************************!*\
  !*** ../../library/dist/esm/PixelStreaming/PixelStreaming.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PixelStreaming: () => (/* binding */ PixelStreaming)
/* harmony export */ });
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _WebRtcPlayer_WebRtcPlayerController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../WebRtcPlayer/WebRtcPlayerController */ "../../library/dist/esm/WebRtcPlayer/WebRtcPlayerController.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Util/EventEmitter */ "../../library/dist/esm/Util/EventEmitter.js");
/* harmony import */ var _WebXR_WebXRController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../WebXR/WebXRController */ "../../library/dist/esm/WebXR/WebXRController.js");
/* harmony import */ var _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../UeInstanceMessage/StreamMessageController */ "../../library/dist/esm/UeInstanceMessage/StreamMessageController.js");
/* harmony import */ var _DataChannel_DataChannelLatencyTestController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../DataChannel/DataChannelLatencyTestController */ "../../library/dist/esm/DataChannel/DataChannelLatencyTestController.js");
/* harmony import */ var _Util_RTCUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Util/RTCUtils */ "../../library/dist/esm/Util/RTCUtils.js");
/* harmony import */ var _Util_IURLSearchParams__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Util/IURLSearchParams */ "../../library/dist/esm/Util/IURLSearchParams.js");
// Copyright Epic Games, Inc. All Rights Reserved.










/**
 * The key class for the browser side of a Pixel Streaming application, it includes:
 * WebRTC handling, XR support, input handling, and emitters for lifetime and state change events.
 * Users are encouraged to use this class as is, through composition, or extend it. In any case,
 * this will likely be the core of your Pixel Streaming experience in terms of functionality.
 */
class PixelStreaming {
    /**
     * @param config - A newly instantiated config object
     * @param overrides - Parameters to override default behaviour
     * returns the base Pixel streaming object
     */
    constructor(config, overrides) {
        this.allowConsoleCommands = false;
        this.config = config;
        if (overrides === null || overrides === void 0 ? void 0 : overrides.videoElementParent) {
            this._videoElementParent = overrides.videoElementParent;
        }
        this._eventEmitter = new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.PixelStreamingEventEmitter();
        this.configureSettings();
        // setup WebRTC
        this.setWebRtcPlayerController(new _WebRtcPlayer_WebRtcPlayerController__WEBPACK_IMPORTED_MODULE_1__.WebRtcPlayerController(this.config, this));
        this._webXrController = new _WebXR_WebXRController__WEBPACK_IMPORTED_MODULE_2__.WebXRController(this._webRtcController);
        this._setupWebRtcTCPRelayDetection = this._setupWebRtcTCPRelayDetection.bind(this);
        // Add event listener for the webRtcConnected event
        this._eventEmitter.addEventListener('webRtcConnected', (_) => {
            // Bind to the stats received event
            this._eventEmitter.addEventListener('statsReceived', this._setupWebRtcTCPRelayDetection);
        });
    }
    /**
     * Gets the element that contains the video stream element.
     */
    get videoElementParent() {
        if (!this._videoElementParent) {
            this._videoElementParent = document.createElement('div');
            this._videoElementParent.id = 'videoElementParent';
        }
        return this._videoElementParent;
    }
    /**
     * Configure the settings with on change listeners and any additional per experience settings.
     */
    configureSettings() {
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.IsQualityController, (wantsQualityController) => {
            // If the setting has been set to true (either programmatically or the user has flicked the toggle)
            // and we aren't currently quality controller, send the request
            if (wantsQualityController === true && !this._webRtcController.isQualityController) {
                this._webRtcController.sendRequestQualityControlOwnership();
            }
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.AFKDetection, (isAFKEnabled) => {
            this._webRtcController.setAfkEnabled(isAFKEnabled);
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.MatchViewportResolution, () => {
            this._webRtcController.videoPlayer.updateVideoStreamSize();
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.HoveringMouseMode, (isHoveringMouse) => {
            this.config.setFlagLabel(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.HoveringMouseMode, `Control Scheme: ${isHoveringMouse ? 'Hovering' : 'Locked'} Mouse`);
            this._webRtcController.setMouseInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.MouseInput));
        });
        // user input
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.KeyboardInput, (isEnabled) => {
            this._webRtcController.setKeyboardInputEnabled(isEnabled);
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.MouseInput, (isEnabled) => {
            this._webRtcController.setMouseInputEnabled(isEnabled);
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.FakeMouseWithTouches, (_isFakeMouseEnabled) => {
            this._webRtcController.setTouchInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.TouchInput));
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.TouchInput, (isEnabled) => {
            this._webRtcController.setTouchInputEnabled(isEnabled);
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.GamepadInput, (isEnabled) => {
            this._webRtcController.setGamePadInputEnabled(isEnabled);
        });
        // direct qp settings
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQP, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MinQP  --------');
            this._webRtcController.sendEncoderMinQP(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
            const quality = Math.trunc(100 * (1 - newValue / 51));
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax, quality);
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQP, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MaxQP  --------');
            this._webRtcController.sendEncoderMaxQP(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
            const quality = Math.trunc(100 * (1 - newValue / 51));
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin, quality);
        });
        // direct quality factor settings
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQuality, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MinQuality  --------');
            this._webRtcController.sendEncoderMinQuality(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin, newValue);
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQuality, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MaxQuality  --------');
            this._webRtcController.sendEncoderMaxQuality(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax, newValue);
        });
        // new quality value that gets scaled to qp for legacy reasons
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin, (newValue) => {
            newValue = 51 - (newValue / 100) * 51;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MinQP from quality value  --------');
            this._webRtcController.sendEncoderMaxQP(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax, (newValue) => {
            newValue = 51 - (newValue / 100) * 51;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MaxQP from quality value  --------');
            this._webRtcController.sendEncoderMinQP(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        // WebRTC settings
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMinBitrate, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending web rtc settings  --------');
            this._webRtcController.sendWebRTCMinBitrate(newValue * 1000 /* kbps to bps */);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMaxBitrate, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending web rtc settings  --------');
            this._webRtcController.sendWebRTCMaxBitrate(newValue * 1000 /* kbps to bps */);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCFPS, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending web rtc settings  --------');
            this._webRtcController.sendWebRTCFps(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        this.config._addOnOptionSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.OptionParameters.PreferredCodec, (newValue) => {
            if (this._webRtcController) {
                this._webRtcController.setPreferredCodec(newValue);
            }
        });
        this.config._registerOnChangeEvents(this._eventEmitter);
    }
    /**
     * Set the input control ownership
     * @param inputControlOwnership - does the user have input control ownership
     */
    _onInputControlOwnership(inputControlOwnership) {
        this._inputController = inputControlOwnership;
    }
    /**
     * Instantiate the WebRTCPlayerController interface to provide WebRTCPlayerController functionality within this class and set up anything that requires it
     * @param webRtcPlayerController - a WebRtcPlayerController controller instance
     */
    setWebRtcPlayerController(webRtcPlayerController) {
        this._webRtcController = webRtcPlayerController;
        this._webRtcController.setPreferredCodec(this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.OptionParameters.PreferredCodec).selected);
        this._webRtcController.resizePlayerStyle();
        // connect if auto connect flag is enabled
        this.checkForAutoConnect();
    }
    /**
     * Connect to signaling server.
     */
    connect() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StreamPreConnectEvent());
        this._webRtcController.connectToSignallingServer();
    }
    /**
     * Reconnects to the signaling server. If connection is up, disconnects first
     * before establishing a new connection
     */
    reconnect() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StreamReconnectEvent());
        this._webRtcController.tryReconnect('Reconnecting...');
    }
    /**
     * Disconnect from the signaling server and close open peer connections.
     */
    disconnect() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StreamPreDisconnectEvent());
        this._webRtcController.close();
    }
    /**
     * Play the stream. Can be called only after a peer connection has been established.
     */
    play() {
        this._onStreamLoading();
        this._webRtcController.playStream();
    }
    /**
     * Auto connect if AutoConnect flag is enabled
     */
    checkForAutoConnect() {
        // set up if the auto play will be used or regular click to start
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.AutoConnect)) {
            // if autoplaying show an info overlay while while waiting for the connection to begin
            this._onWebRtcAutoConnect();
            this._webRtcController.connectToSignallingServer();
        }
    }
    /**
     * Will unmute the microphone track which is sent to Unreal Engine.
     * By default, will only unmute an existing mic track.
     *
     * @param forceEnable Can be used for cases when this object wasn't initialized with a mic track.
     * If this parameter is true, the connection will be restarted with a microphone.
     * Warning: this takes some time, as a full renegotiation and reconnection will happen.
     */
    unmuteMicrophone(forceEnable = false) {
        // If there's an existing mic track, we just set muted state
        if (this.config.isFlagEnabled('UseMic')) {
            this.setMicrophoneMuted(false);
            return;
        }
        // If there's no pre-existing mic track, and caller is ok with full reset, we enable and reset
        if (forceEnable) {
            this.config.setFlagEnabled('UseMic', true);
            this.reconnect();
            return;
        }
        // If we prefer not to force a reconnection, just warn the user that this operation didn't happen
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Warning('Trying to unmute mic, but PixelStreaming was initialized with no microphone track. Call with forceEnable == true to re-connect with a mic track.');
    }
    muteMicrophone() {
        if (this.config.isFlagEnabled('UseMic')) {
            this.setMicrophoneMuted(true);
            return;
        }
        // If there wasn't a mic track, just let user know there's nothing to mute
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('Trying to mute mic, but PixelStreaming has no microphone track, so sending sound is already disabled.');
    }
    setMicrophoneMuted(mute) {
        var _a, _b, _c, _d;
        for (const transceiver of (_d = (_c = (_b = (_a = this._webRtcController) === null || _a === void 0 ? void 0 : _a.peerConnectionController) === null || _b === void 0 ? void 0 : _b.peerConnection) === null || _c === void 0 ? void 0 : _c.getTransceivers()) !== null && _d !== void 0 ? _d : []) {
            if (_Util_RTCUtils__WEBPACK_IMPORTED_MODULE_5__.RTCUtils.canTransceiverSendAudio(transceiver)) {
                transceiver.sender.track.enabled = !mute;
            }
        }
    }
    /**
     * Will unmute the video track which is sent to Unreal Engine.
     * By default, will only unmute an existing video track.
     *
     * @param forceEnable Can be used for cases when this object wasn't initialized with a video track.
     * If this parameter is true, the connection will be restarted with a camera.
     * Warning: this takes some time, as a full renegotiation and reconnection will happen.
     */
    unmuteCamera(forceEnable = false) {
        // If there's an existing video track, we just set muted state
        if (this.config.isFlagEnabled('UseCamera')) {
            this.setCameraMuted(false);
            return;
        }
        // If there's no pre-existing video track, and caller is ok with full reset, we enable and reset
        if (forceEnable) {
            this.config.setFlagEnabled('UseCamera', true);
            this.reconnect();
            return;
        }
        // If we prefer not to force a reconnection, just warn the user that this operation didn't happen
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Warning('Trying to unmute video, but PixelStreaming was initialized with no video track. Call with forceEnable == true to re-connect with a video track.');
    }
    muteCamera() {
        if (this.config.isFlagEnabled('UseCamera')) {
            this.setCameraMuted(true);
            return;
        }
        // If there wasn't a mic track, just let user know there's nothing to mute
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('Trying to mute camera, but PixelStreaming has no video track, so sending video is already disabled.');
    }
    setCameraMuted(mute) {
        var _a, _b, _c, _d;
        for (const transceiver of (_d = (_c = (_b = (_a = this._webRtcController) === null || _a === void 0 ? void 0 : _a.peerConnectionController) === null || _b === void 0 ? void 0 : _b.peerConnection) === null || _c === void 0 ? void 0 : _c.getTransceivers()) !== null && _d !== void 0 ? _d : []) {
            if (_Util_RTCUtils__WEBPACK_IMPORTED_MODULE_5__.RTCUtils.canTransceiverSendVideo(transceiver)) {
                transceiver.sender.track.enabled = !mute;
            }
        }
    }
    /**
     * Internal function to emit an event when auto connecting occurs
     */
    _onWebRtcAutoConnect() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcAutoConnectEvent());
    }
    /**
     * Internal function to emit an event for when SDP negotiation is fully finished.
     */
    _onWebRtcSdp() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcSdpEvent());
    }
    /**
     * Internal function to emit an SDP offer after it has been set.
     */
    _onWebRtcSdpOffer(offer) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcSdpOfferEvent({ sdp: offer }));
    }
    /**
     * Internal function to emit an SDP answer after it has been set.
     */
    _onWebRtcSdpAnswer(answer) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcSdpAnswerEvent({ sdp: answer }));
    }
    /**
     * Internal function call to emit a `latencyCalculated` event.
     */
    _onLatencyCalculated(latencyInfo) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.LatencyCalculatedEvent({ latencyInfo }));
    }
    /**
     * Internal function to emits a StreamLoading event
     */
    _onStreamLoading() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StreamLoadingEvent());
    }
    /**
     * Event fired when the video is disconnected - emits given eventString or an override
     * message from webRtcController if one has been set
     * @param eventString - a string describing why the connection closed
     * @param allowClickToReconnect - true if we want to allow the user to retry the connection with a click
     */
    _onDisconnect(eventString, allowClickToReconnect) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcDisconnectedEvent({
            eventString: eventString,
            allowClickToReconnect: allowClickToReconnect
        }));
    }
    /**
     * Handles when Web Rtc is connecting
     */
    _onWebRtcConnecting() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcConnectingEvent());
    }
    /**
     * Handles when Web Rtc has connected
     */
    _onWebRtcConnected() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcConnectedEvent());
    }
    /**
     * Handles when Web Rtc fails to connect
     */
    _onWebRtcFailed() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcFailedEvent());
    }
    /**
     * Handle when the Video has been Initialized
     */
    _onVideoInitialized() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.VideoInitializedEvent());
        this._videoStartTime = Date.now();
    }
    /**
     * Set up functionality to happen when receiving latency test results
     * @param latency - latency test results object
     */
    _onLatencyTestResult(latencyTimings) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.LatencyTestResultEvent({ latencyTimings }));
    }
    _onDataChannelLatencyTestResponse(response) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.DataChannelLatencyTestResponseEvent({ response }));
    }
    /**
     * Set up functionality to happen when receiving video statistics
     * @param videoStats - video statistics as a aggregate stats object
     */
    _onVideoStats(videoStats) {
        // Duration
        if (!this._videoStartTime || this._videoStartTime === undefined) {
            this._videoStartTime = Date.now();
        }
        videoStats.handleSessionStatistics(this._videoStartTime, this._inputController, this._webRtcController.videoAvgQp);
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StatsReceivedEvent({ aggregatedStats: videoStats }));
    }
    /**
     * Set up functionality to happen when calculating the average video encoder qp
     * @param QP - the quality number of the stream
     */
    _onVideoEncoderAvgQP(QP) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.VideoEncoderAvgQPEvent({ avgQP: QP }));
    }
    /**
     * Set up functionality to happen when receiving and handling initial settings for the UE app
     * @param settings - initial UE app settings
     */
    _onInitialSettings(settings) {
        var _a;
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.InitialSettingsEvent({ settings }));
        if (settings.PixelStreamingSettings) {
            this.allowConsoleCommands = (_a = settings.PixelStreamingSettings.AllowPixelStreamingCommands) !== null && _a !== void 0 ? _a : false;
            if (this.allowConsoleCommands === false) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-AllowPixelStreamingCommands=false, sending arbitrary console commands from browser to UE is disabled.');
            }
        }
        const useUrlParams = this.config.useUrlParams;
        const urlParams = new _Util_IURLSearchParams__WEBPACK_IMPORTED_MODULE_6__.IURLSearchParams(window.location.search);
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info(`using URL parameters ${useUrlParams}`);
        if (settings.EncoderSettings) {
            // here we should either get Min/MaxQP from PS1
            // or Min/MaxQuality from PS2
            // we only want to set one set or the other as they converge in CompatQualityMin/Max and
            // we dont want to have them conflict with default values.
            if (settings.EncoderSettings.MinQP) {
                this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQP, 
                // If a setting is set in the URL, make sure we respect that value as opposed to what the application sends us
                useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQP)
                    ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQP))
                    : settings.EncoderSettings.MinQP || 0);
                this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQP, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQP)
                    ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQP))
                    : settings.EncoderSettings.MaxQP || 51);
            }
            if (settings.EncoderSettings.MinQuality) {
                this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQuality, 
                // If a setting is set in the URL, make sure we respect that value as opposed to what the application sends us
                useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQuality)
                    ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQuality))
                    : settings.EncoderSettings.MinQuality || 0);
                this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQuality, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQuality)
                    ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQuality))
                    : settings.EncoderSettings.MaxQuality || 100);
            }
            // these two are just used to converge quality and qp and behave slightly differently since they
            // shouldnt exist in EncoderSettings
            if (useUrlParams) {
                if (urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin)) {
                    this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin, Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin)));
                }
                if (urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax)) {
                    this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax, Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax)));
                }
            }
        }
        if (settings.WebRTCSettings) {
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMinBitrate, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMinBitrate)
                ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMinBitrate))
                : settings.WebRTCSettings.MinBitrate / 1000 /* bps to kbps */);
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMaxBitrate, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMaxBitrate)
                ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMaxBitrate))
                : settings.WebRTCSettings.MaxBitrate / 1000 /* bps to kbps */);
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCFPS, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCFPS)
                ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCFPS))
                : settings.WebRTCSettings.FPS);
        }
    }
    /**
     * Set up functionality to happen when setting quality control ownership of a stream
     * @param hasQualityOwnership - does this user have quality ownership of the stream true / false
     */
    _onQualityControlOwnership(hasQualityOwnership) {
        this.config.setFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.IsQualityController, hasQualityOwnership);
    }
    _onPlayerCount(playerCount) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.PlayerCountEvent({ count: playerCount }));
    }
    _onSubscribeFailed(message) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.SubscribeFailedEvent({ message: message }));
    }
    // Sets up to emit the webrtc tcp relay detect event
    _setupWebRtcTCPRelayDetection(statsReceivedEvent) {
        // Get the active candidate pair
        const activeCandidatePair = statsReceivedEvent.data.aggregatedStats.getActiveCandidatePair();
        // Check if the active candidate pair is not null
        if (activeCandidatePair != null) {
            // Get the local candidate assigned to the active candidate pair
            const localCandidate = statsReceivedEvent.data.aggregatedStats.localCandidates.find((candidate) => candidate.id == activeCandidatePair.localCandidateId, null);
            // Check if the local candidate is not null, candidate type is relay and the relay protocol is tcp
            if (localCandidate != null &&
                localCandidate.candidateType == 'relay' &&
                localCandidate.relayProtocol == 'tcp') {
                // Send the web rtc tcp relay detected event
                this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcTCPRelayDetectedEvent());
            }
            // The check is completed and the stats listen event can be removed
            this._eventEmitter.removeEventListener('statsReceived', this._setupWebRtcTCPRelayDetection);
        }
    }
    /**
     * Request a connection latency test.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     * @returns
     */
    requestLatencyTest() {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendLatencyTest();
        return true;
    }
    /**
     * Request a data channel latency test.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     */
    requestDataChannelLatencyTest(config) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        if (!this._dataChannelLatencyTestController) {
            this._dataChannelLatencyTestController = new _DataChannel_DataChannelLatencyTestController__WEBPACK_IMPORTED_MODULE_7__.DataChannelLatencyTestController(this._webRtcController.sendDataChannelLatencyTest.bind(this._webRtcController), (result) => {
                this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.DataChannelLatencyTestResultEvent({ result }));
            });
            this.addEventListener('dataChannelLatencyTestResponse', ({ data: { response } }) => {
                this._dataChannelLatencyTestController.receive(response);
            });
        }
        return this._dataChannelLatencyTestController.start(config);
    }
    /**
     * Request for the UE application to show FPS counter.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     * @returns
     */
    requestShowFps() {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendShowFps();
        return true;
    }
    /**
     * Request for a new IFrame from the UE application.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     * @returns
     */
    requestIframe() {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendIframeRequest();
        return true;
    }
    /**
     * Send data to UE application. The data will be run through JSON.stringify() so e.g. strings
     * and any serializable plain JSON objects with no recurrence can be sent.
     * @returns true if succeeded, false if rejected
     */
    emitUIInteraction(descriptor) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.emitUIInteraction(descriptor);
        return true;
    }
    /**
     * Send a command to UE application. Blocks ConsoleCommand descriptors unless UE
     * has signaled that it allows console commands.
     * @returns true if succeeded, false if rejected
     */
    emitCommand(descriptor) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        if (!this.allowConsoleCommands && 'ConsoleCommand' in descriptor) {
            return false;
        }
        this._webRtcController.emitCommand(descriptor);
        return true;
    }
    /**
     * Send a console command to UE application. Only allowed if UE has signaled that it allows
     * console commands.
     * @returns true if succeeded, false if rejected
     */
    emitConsoleCommand(command) {
        if (!this.allowConsoleCommands || !this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.emitConsoleCommand(command);
        return true;
    }
    /**
     * Sets the text contents of the currently focused UE text box widget.
     * @param contents The new contents of the UE text box.
     * @returns True if the message could be sent.
     */
    sendTextboxEntry(contents) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendTextboxEntry(contents);
        return true;
    }
    /**
     * Add a UE -> browser response event listener
     * @param name - The name of the response handler
     * @param listener - The method to be activated when a message is received
     */
    addResponseEventListener(name, listener) {
        this._webRtcController.responseController.addResponseEventListener(name, listener);
    }
    /**
     * Remove a UE -> browser response event listener
     * @param name - The name of the response handler
     */
    removeResponseEventListener(name) {
        this._webRtcController.responseController.removeResponseEventListener(name);
    }
    /**
     * Dispatch a new event.
     * @param e event
     * @returns
     */
    dispatchEvent(e) {
        return this._eventEmitter.dispatchEvent(e);
    }
    /**
     * Register an event handler.
     * @param type event name
     * @param listener event handler function
     */
    addEventListener(type, listener) {
        this._eventEmitter.addEventListener(type, listener);
    }
    /**
     * Remove an event handler.
     * @param type event name
     * @param listener event handler function
     */
    removeEventListener(type, listener) {
        this._eventEmitter.removeEventListener(type, listener);
    }
    /**
     * Enable/disable XR mode.
     */
    toggleXR() {
        this.webXrController.xrClicked();
    }
    /**
     * Pass in a function to generate a signalling server URL.
     * This function is useful if you need to programmatically construct your signalling server URL.
     * @param signallingUrlBuilderFunc A function that generates a signalling server url.
     */
    setSignallingUrlBuilder(signallingUrlBuilderFunc) {
        this._webRtcController.signallingUrlBuilder = signallingUrlBuilderFunc;
    }
    get webRtcController() {
        return this._webRtcController;
    }
    /**
     * Public getter for the websocket controller. Access to this property allows you to send
     * custom websocket messages.
     */
    get signallingProtocol() {
        return this._webRtcController.protocol;
    }
    /**
     * Public getter for the webXrController controller. Used for all XR features.
     */
    get webXrController() {
        return this._webXrController;
    }
    registerMessageHandler(name, direction, handler) {
        if (direction === _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_8__.MessageDirection.FromStreamer && typeof handler === 'undefined') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Warning(`Unable to register an undefined handler for ${name}`);
            return;
        }
        if (direction === _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_8__.MessageDirection.ToStreamer && typeof handler === 'undefined') {
            this._webRtcController.streamMessageController.registerMessageHandler(direction, name, (data) => this._webRtcController.sendMessageController.sendMessageToStreamer(name, data));
        }
        else {
            this._webRtcController.streamMessageController.registerMessageHandler(direction, name, (data) => handler(data));
        }
    }
    get toStreamerHandlers() {
        return this._webRtcController.streamMessageController.toStreamerHandlers;
    }
    isReconnecting() {
        return this._webRtcController.isReconnecting;
    }
}
//# sourceMappingURL=PixelStreaming.js.map

/***/ }),

/***/ "../../library/dist/esm/UeInstanceMessage/ResponseController.js":
/*!**********************************************************************!*\
  !*** ../../library/dist/esm/UeInstanceMessage/ResponseController.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ResponseController: () => (/* binding */ ResponseController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class ResponseController {
    constructor() {
        this.responseEventListeners = new Map();
    }
    /**
     * Add a response event listener to the response map
     * @param name - The name of the response
     * @param listener - The method to be activated when the response is selected
     */
    addResponseEventListener(name, listener) {
        this.responseEventListeners.set(name, listener);
    }
    /**
     * Remove a response event listener to the response map
     * @param name - The name of the response
     */
    removeResponseEventListener(name) {
        this.responseEventListeners.delete(name);
    }
    /**
     * Handle a response when receiving one form the streamer
     * @param message - Data received from the data channel with the command in question
     */
    onResponse(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('DataChannelReceiveMessageType.Response');
        const responses = new TextDecoder('utf-16').decode(message.slice(1));
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(responses);
        this.responseEventListeners.forEach((listener) => {
            listener(responses);
        });
    }
}
//# sourceMappingURL=ResponseController.js.map

/***/ }),

/***/ "../../library/dist/esm/UeInstanceMessage/SendMessageController.js":
/*!*************************************************************************!*\
  !*** ../../library/dist/esm/UeInstanceMessage/SendMessageController.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SendMessageController: () => (/* binding */ SendMessageController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class SendMessageController {
    /**
     * @param dataChannelSender - Data channel instance
     * @param toStreamerMessagesMapProvider - Stream Messages instance
     */
    constructor(dataChannelSender, toStreamerMessagesMapProvider) {
        this.dataChannelSender = dataChannelSender;
        this.toStreamerMessagesMapProvider = toStreamerMessagesMapProvider;
    }
    /**
     * Send a message to the streamer through the data channel
     * @param messageType - the type of message we are sending
     * @param messageData - the message data we are sending over the data channel
     * @returns - nil
     */
    sendMessageToStreamer(messageType, messageData) {
        if (messageData === undefined) {
            messageData = [];
        }
        const toStreamerMessages = this.toStreamerMessagesMapProvider.toStreamerMessages;
        const messageFormat = toStreamerMessages.get(messageType);
        if (messageFormat === undefined) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Attempted to send a message to the streamer with message type: ${messageType}, but the frontend hasn't been configured to send such a message. Check you've added the message type in your cpp`);
            return;
        }
        if (messageFormat.structure && messageData && messageFormat.structure.length !== messageData.length) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Provided message data doesn't match expected layout. Expected [ ${messageFormat.structure
                .map((element) => {
                switch (element) {
                    case 'uint8':
                    case 'uint16':
                    case 'int16':
                    case 'float':
                    case 'double':
                    default:
                        return 'number';
                    case 'string':
                        return 'string';
                }
            })
                .toString()} ] but received [ ${messageData.map((element) => typeof element).toString()} ]`);
            return;
        }
        let byteLength = 0;
        const textEncoder = new TextEncoder();
        // One loop to calculate the length in bytes of all of the provided data
        messageData.forEach((element, idx) => {
            const type = messageFormat.structure[idx];
            switch (type) {
                case 'uint8':
                    byteLength += 1;
                    break;
                case 'uint16':
                    byteLength += 2;
                    break;
                case 'int16':
                    byteLength += 2;
                    break;
                case 'float':
                    byteLength += 4;
                    break;
                case 'double':
                    byteLength += 8;
                    break;
                case 'string':
                    // 2 bytes for string length
                    byteLength += 2;
                    // 2 bytes per characters
                    byteLength += 2 * textEncoder.encode(element).length;
                    break;
            }
        });
        const data = new DataView(new ArrayBuffer(byteLength + 1));
        data.setUint8(0, messageFormat.id);
        let byteOffset = 1;
        messageData.forEach((element, idx) => {
            const type = messageFormat.structure[idx];
            switch (type) {
                case 'uint8':
                    data.setUint8(byteOffset, element);
                    byteOffset += 1;
                    break;
                case 'uint16':
                    data.setUint16(byteOffset, element, true);
                    byteOffset += 2;
                    break;
                case 'int16':
                    data.setInt16(byteOffset, element, true);
                    byteOffset += 2;
                    break;
                case 'float':
                    data.setFloat32(byteOffset, element, true);
                    byteOffset += 4;
                    break;
                case 'double':
                    data.setFloat64(byteOffset, element, true);
                    byteOffset += 8;
                    break;
                case 'string':
                    data.setUint16(byteOffset, element.length, true);
                    byteOffset += 2;
                    for (let i = 0; i < element.length; i++) {
                        data.setUint16(byteOffset, element.charCodeAt(i), true);
                        byteOffset += 2;
                    }
                    break;
            }
        });
        if (!this.dataChannelSender.canSend()) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data channel cannot send yet, skipping sending message: ${messageType} - ${new Uint8Array(data.buffer)}`);
            return;
        }
        this.dataChannelSender.sendData(data.buffer);
    }
}
//# sourceMappingURL=SendMessageController.js.map

/***/ }),

/***/ "../../library/dist/esm/UeInstanceMessage/StreamMessageController.js":
/*!***************************************************************************!*\
  !*** ../../library/dist/esm/UeInstanceMessage/StreamMessageController.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MessageDirection: () => (/* binding */ MessageDirection),
/* harmony export */   StreamMessageController: () => (/* binding */ StreamMessageController),
/* harmony export */   ToStreamerMessage: () => (/* binding */ ToStreamerMessage)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class ToStreamerMessage {
}
class StreamMessageController {
    constructor() {
        this.toStreamerHandlers = new Map();
        this.fromStreamerHandlers = new Map();
        this.toStreamerMessages = new Map();
        this.fromStreamerMessages = new Map();
    }
    /**
     * Populate the Default message protocol
     */
    populateDefaultProtocol() {
        /*
         * Control Messages. Range = 0..49.
         */
        this.toStreamerMessages.set('IFrameRequest', {
            id: 0,
            structure: []
        });
        this.toStreamerMessages.set('RequestQualityControl', {
            id: 1,
            structure: []
        });
        this.toStreamerMessages.set('FpsRequest', {
            id: 2,
            structure: []
        });
        this.toStreamerMessages.set('AverageBitrateRequest', {
            id: 3,
            structure: []
        });
        this.toStreamerMessages.set('StartStreaming', {
            id: 4,
            structure: []
        });
        this.toStreamerMessages.set('StopStreaming', {
            id: 5,
            structure: []
        });
        this.toStreamerMessages.set('LatencyTest', {
            id: 6,
            structure: ['string']
        });
        this.toStreamerMessages.set('RequestInitialSettings', {
            id: 7,
            structure: []
        });
        this.toStreamerMessages.set('TestEcho', {
            id: 8,
            structure: []
        });
        this.toStreamerMessages.set('DataChannelLatencyTest', {
            id: 9,
            structure: []
        });
        /*
         * Input Messages. Range = 50..89.
         */
        // Generic Input Messages. Range = 50..59.
        this.toStreamerMessages.set('UIInteraction', {
            id: 50,
            structure: ['string']
        });
        this.toStreamerMessages.set('Command', {
            id: 51,
            structure: ['string']
        });
        this.toStreamerMessages.set('TextboxEntry', {
            id: 52,
            structure: ['string']
        });
        // Keyboard Input Message. Range = 60..69.
        this.toStreamerMessages.set('KeyDown', {
            id: 60,
            //            keyCode  isRepeat
            structure: ['uint8', 'uint8']
        });
        this.toStreamerMessages.set('KeyUp', {
            id: 61,
            //            keyCode
            structure: ['uint8']
        });
        this.toStreamerMessages.set('KeyPress', {
            id: 62,
            //            charcode
            structure: ['uint16']
        });
        // Mouse Input Messages. Range = 70..79.
        this.toStreamerMessages.set('MouseEnter', {
            id: 70,
            structure: []
        });
        this.toStreamerMessages.set('MouseLeave', {
            id: 71,
            structure: []
        });
        this.toStreamerMessages.set('MouseDown', {
            id: 72,
            //              button     x         y
            structure: ['uint8', 'uint16', 'uint16']
        });
        this.toStreamerMessages.set('MouseUp', {
            id: 73,
            //              button     x         y
            structure: ['uint8', 'uint16', 'uint16']
        });
        this.toStreamerMessages.set('MouseMove', {
            id: 74,
            //              x           y      deltaX    deltaY
            structure: ['uint16', 'uint16', 'int16', 'int16']
        });
        this.toStreamerMessages.set('MouseWheel', {
            id: 75,
            //              delta       x        y
            structure: ['int16', 'uint16', 'uint16']
        });
        this.toStreamerMessages.set('MouseDouble', {
            id: 76,
            //              button     x         y
            structure: ['uint8', 'uint16', 'uint16']
        });
        // Touch Input Messages. Range = 80..89.
        this.toStreamerMessages.set('TouchStart', {
            id: 80,
            //          numtouches(1)   x       y        idx     force     valid
            structure: ['uint8', 'uint16', 'uint16', 'uint8', 'uint8', 'uint8']
        });
        this.toStreamerMessages.set('TouchEnd', {
            id: 81,
            //          numtouches(1)   x       y        idx     force     valid
            structure: ['uint8', 'uint16', 'uint16', 'uint8', 'uint8', 'uint8']
        });
        this.toStreamerMessages.set('TouchMove', {
            id: 82,
            //          numtouches(1)   x       y       idx      force     valid
            structure: ['uint8', 'uint16', 'uint16', 'uint8', 'uint8', 'uint8']
        });
        // Gamepad Input Messages. Range = 90..99
        this.toStreamerMessages.set('GamepadConnected', {
            id: 93,
            structure: []
        });
        this.toStreamerMessages.set('GamepadButtonPressed', {
            id: 90,
            //         ctrlerId   button  isRepeat
            structure: ['uint8', 'uint8', 'uint8']
        });
        this.toStreamerMessages.set('GamepadButtonReleased', {
            id: 91,
            //         ctrlerId   button  isRepeat(0)
            structure: ['uint8', 'uint8', 'uint8']
        });
        this.toStreamerMessages.set('GamepadAnalog', {
            id: 92,
            //         ctrlerId   button  analogValue
            structure: ['uint8', 'uint8', 'double']
        });
        this.toStreamerMessages.set('GamepadDisconnected', {
            id: 94,
            //          ctrlerId
            structure: ['uint8']
        });
        this.fromStreamerMessages.set(0, 'QualityControlOwnership');
        this.fromStreamerMessages.set(1, 'Response');
        this.fromStreamerMessages.set(2, 'Command');
        this.fromStreamerMessages.set(3, 'FreezeFrame');
        this.fromStreamerMessages.set(4, 'UnfreezeFrame');
        this.fromStreamerMessages.set(5, 'VideoEncoderAvgQP');
        this.fromStreamerMessages.set(6, 'LatencyTest');
        this.fromStreamerMessages.set(7, 'InitialSettings');
        this.fromStreamerMessages.set(8, 'FileExtension');
        this.fromStreamerMessages.set(9, 'FileMimeType');
        this.fromStreamerMessages.set(10, 'FileContents');
        this.fromStreamerMessages.set(11, 'TestEcho');
        this.fromStreamerMessages.set(12, 'InputControlOwnership');
        this.fromStreamerMessages.set(13, 'GamepadResponse');
        this.fromStreamerMessages.set(14, 'DataChannelLatencyTest');
        this.fromStreamerMessages.set(255, 'Protocol');
    }
    /**
     * Register a message handler
     * @param messageDirection - the direction of the message; toStreamer or fromStreamer
     * @param messageType - the type of the message
     * @param messageHandler - the function or method to be executed when this handler is called
     */
    registerMessageHandler(messageDirection, messageType, messageHandler) {
        switch (messageDirection) {
            case MessageDirection.ToStreamer:
                this.toStreamerHandlers.set(messageType, messageHandler);
                break;
            case MessageDirection.FromStreamer:
                this.fromStreamerHandlers.set(messageType, messageHandler);
                break;
            default:
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Unknown message direction ${messageDirection}`);
        }
    }
}
/**
 * The enum for message directions
 */
var MessageDirection;
(function (MessageDirection) {
    MessageDirection[MessageDirection["ToStreamer"] = 0] = "ToStreamer";
    MessageDirection[MessageDirection["FromStreamer"] = 1] = "FromStreamer";
})(MessageDirection || (MessageDirection = {}));
//# sourceMappingURL=StreamMessageController.js.map

/***/ }),

/***/ "../../library/dist/esm/UeInstanceMessage/ToStreamerMessagesController.js":
/*!********************************************************************************!*\
  !*** ../../library/dist/esm/UeInstanceMessage/ToStreamerMessagesController.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ToStreamerMessagesController: () => (/* binding */ ToStreamerMessagesController)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class ToStreamerMessagesController {
    /**
     * @param sendMessageController - Stream message controller instance
     */
    constructor(sendMessageController) {
        this.sendMessageController = sendMessageController;
    }
    /**
     * Send Request to Take Quality Control to the UE Instance
     */
    SendRequestQualityControl() {
        this.sendMessageController.sendMessageToStreamer('RequestQualityControl');
    }
    /**
     * Send Max FPS Request to the UE Instance
     */
    SendMaxFpsRequest() {
        this.sendMessageController.sendMessageToStreamer('FpsRequest');
    }
    /**
     * Send Average Bitrate Request to the UE Instance
     */
    SendAverageBitrateRequest() {
        this.sendMessageController.sendMessageToStreamer('AverageBitrateRequest');
    }
    /**
     * Send a Start Streaming Message to the UE Instance
     */
    SendStartStreaming() {
        this.sendMessageController.sendMessageToStreamer('StartStreaming');
    }
    /**
     * Send a Stop Streaming Message to the UE Instance
     */
    SendStopStreaming() {
        this.sendMessageController.sendMessageToStreamer('StopStreaming');
    }
    /**
     * Send a Request Initial Settings to the UE Instance
     */
    SendRequestInitialSettings() {
        this.sendMessageController.sendMessageToStreamer('RequestInitialSettings');
    }
}
//# sourceMappingURL=ToStreamerMessagesController.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/BrowserUtils.js":
/*!***************************************************!*\
  !*** ../../library/dist/esm/Util/BrowserUtils.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BrowserUtils: () => (/* binding */ BrowserUtils)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class BrowserUtils {
    static getSupportedVideoCodecs() {
        const browserSupportedCodecs = [];
        // Try get the info needed from the RTCRtpReceiver. This is only available on chrome
        if (!RTCRtpReceiver.getCapabilities) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Warning('RTCRtpReceiver.getCapabilities API is not available in your browser, defaulting to guess that we support H.264.');
            browserSupportedCodecs.push('H264 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f');
            return browserSupportedCodecs;
        }
        const matcher = /(VP\d|H26\d|AV1).*/;
        const capabilities = RTCRtpReceiver.getCapabilities('video');
        if (!capabilities) {
            browserSupportedCodecs.push('H264 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f');
            return browserSupportedCodecs;
        }
        capabilities.codecs.forEach((codec) => {
            const str = codec.mimeType.split('/')[1] + ' ' + (codec.sdpFmtpLine || '');
            const match = matcher.exec(str);
            if (match !== null) {
                browserSupportedCodecs.push(str);
            }
        });
        return browserSupportedCodecs;
    }
}
//# sourceMappingURL=BrowserUtils.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/EventEmitter.js":
/*!***************************************************!*\
  !*** ../../library/dist/esm/Util/EventEmitter.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AfkTimedOutEvent: () => (/* binding */ AfkTimedOutEvent),
/* harmony export */   AfkWarningActivateEvent: () => (/* binding */ AfkWarningActivateEvent),
/* harmony export */   AfkWarningDeactivateEvent: () => (/* binding */ AfkWarningDeactivateEvent),
/* harmony export */   AfkWarningUpdateEvent: () => (/* binding */ AfkWarningUpdateEvent),
/* harmony export */   DataChannelCloseEvent: () => (/* binding */ DataChannelCloseEvent),
/* harmony export */   DataChannelErrorEvent: () => (/* binding */ DataChannelErrorEvent),
/* harmony export */   DataChannelLatencyTestResponseEvent: () => (/* binding */ DataChannelLatencyTestResponseEvent),
/* harmony export */   DataChannelLatencyTestResultEvent: () => (/* binding */ DataChannelLatencyTestResultEvent),
/* harmony export */   DataChannelOpenEvent: () => (/* binding */ DataChannelOpenEvent),
/* harmony export */   HideFreezeFrameEvent: () => (/* binding */ HideFreezeFrameEvent),
/* harmony export */   InitialSettingsEvent: () => (/* binding */ InitialSettingsEvent),
/* harmony export */   LatencyCalculatedEvent: () => (/* binding */ LatencyCalculatedEvent),
/* harmony export */   LatencyTestResultEvent: () => (/* binding */ LatencyTestResultEvent),
/* harmony export */   LoadFreezeFrameEvent: () => (/* binding */ LoadFreezeFrameEvent),
/* harmony export */   PixelStreamingEventEmitter: () => (/* binding */ PixelStreamingEventEmitter),
/* harmony export */   PlayStreamErrorEvent: () => (/* binding */ PlayStreamErrorEvent),
/* harmony export */   PlayStreamEvent: () => (/* binding */ PlayStreamEvent),
/* harmony export */   PlayStreamRejectedEvent: () => (/* binding */ PlayStreamRejectedEvent),
/* harmony export */   PlayerCountEvent: () => (/* binding */ PlayerCountEvent),
/* harmony export */   SettingsChangedEvent: () => (/* binding */ SettingsChangedEvent),
/* harmony export */   ShowOnScreenKeyboardEvent: () => (/* binding */ ShowOnScreenKeyboardEvent),
/* harmony export */   StatsReceivedEvent: () => (/* binding */ StatsReceivedEvent),
/* harmony export */   StreamLoadingEvent: () => (/* binding */ StreamLoadingEvent),
/* harmony export */   StreamPreConnectEvent: () => (/* binding */ StreamPreConnectEvent),
/* harmony export */   StreamPreDisconnectEvent: () => (/* binding */ StreamPreDisconnectEvent),
/* harmony export */   StreamReconnectEvent: () => (/* binding */ StreamReconnectEvent),
/* harmony export */   StreamerIDChangedMessageEvent: () => (/* binding */ StreamerIDChangedMessageEvent),
/* harmony export */   StreamerListMessageEvent: () => (/* binding */ StreamerListMessageEvent),
/* harmony export */   SubscribeFailedEvent: () => (/* binding */ SubscribeFailedEvent),
/* harmony export */   VideoEncoderAvgQPEvent: () => (/* binding */ VideoEncoderAvgQPEvent),
/* harmony export */   VideoInitializedEvent: () => (/* binding */ VideoInitializedEvent),
/* harmony export */   WebRtcAutoConnectEvent: () => (/* binding */ WebRtcAutoConnectEvent),
/* harmony export */   WebRtcConnectedEvent: () => (/* binding */ WebRtcConnectedEvent),
/* harmony export */   WebRtcConnectingEvent: () => (/* binding */ WebRtcConnectingEvent),
/* harmony export */   WebRtcDisconnectedEvent: () => (/* binding */ WebRtcDisconnectedEvent),
/* harmony export */   WebRtcFailedEvent: () => (/* binding */ WebRtcFailedEvent),
/* harmony export */   WebRtcSdpAnswerEvent: () => (/* binding */ WebRtcSdpAnswerEvent),
/* harmony export */   WebRtcSdpEvent: () => (/* binding */ WebRtcSdpEvent),
/* harmony export */   WebRtcSdpOfferEvent: () => (/* binding */ WebRtcSdpOfferEvent),
/* harmony export */   WebRtcTCPRelayDetectedEvent: () => (/* binding */ WebRtcTCPRelayDetectedEvent),
/* harmony export */   XrFrameEvent: () => (/* binding */ XrFrameEvent),
/* harmony export */   XrSessionEndedEvent: () => (/* binding */ XrSessionEndedEvent),
/* harmony export */   XrSessionStartedEvent: () => (/* binding */ XrSessionStartedEvent)
/* harmony export */ });
/**
 * An event that is emitted when AFK disconnect is about to happen.
 * Can be cancelled by calling the callback function provided as part of the event.
 */
class AfkWarningActivateEvent extends Event {
    constructor(data) {
        super('afkWarningActivate');
        this.data = data;
    }
}
/**
 * An event that is emitted when the AFK disconnect countdown is updated.
 */
class AfkWarningUpdateEvent extends Event {
    constructor(data) {
        super('afkWarningUpdate');
        this.data = data;
    }
}
/**
 * An event that is emitted when AFK warning is deactivated.
 */
class AfkWarningDeactivateEvent extends Event {
    constructor() {
        super('afkWarningDeactivate');
    }
}
/**
 * An event that is emitted when AFK countdown reaches 0 and the user is disconnected.
 */
class AfkTimedOutEvent extends Event {
    constructor() {
        super('afkTimedOut');
    }
}
/**
 * An event that is emitted when we receive new video quality value.
 */
class VideoEncoderAvgQPEvent extends Event {
    constructor(data) {
        super('videoEncoderAvgQP');
        this.data = data;
    }
}
/**
 * An event that is emitted after a WebRtc connection has been negotiated.
 */
class WebRtcSdpEvent extends Event {
    constructor() {
        super('webRtcSdp');
    }
}
/**
 * An event that is emitted after the SDP answer is set.
 */
class WebRtcSdpAnswerEvent extends Event {
    constructor(data) {
        super('webRtcSdpAnswer');
        this.data = data;
    }
}
/**
 * An event that is emitted after the SDP offer is set.
 */
class WebRtcSdpOfferEvent extends Event {
    constructor(data) {
        super('webRtcSdpOffer');
        this.data = data;
    }
}
/**
 * An event that is emitted when auto connecting.
 */
class WebRtcAutoConnectEvent extends Event {
    constructor() {
        super('webRtcAutoConnect');
    }
}
/**
 * An event that is emitted when sending a WebRtc offer.
 */
class WebRtcConnectingEvent extends Event {
    constructor() {
        super('webRtcConnecting');
    }
}
/**
 * An event that is emitted when WebRtc connection has been established.
 */
class WebRtcConnectedEvent extends Event {
    constructor() {
        super('webRtcConnected');
    }
}
/**
 * An event that is emitted if WebRtc connection has failed.
 */
class WebRtcFailedEvent extends Event {
    constructor() {
        super('webRtcFailed');
    }
}
/**
 * An event that is emitted if WebRtc connection is disconnected.
 */
class WebRtcDisconnectedEvent extends Event {
    constructor(data) {
        super('webRtcDisconnected');
        this.data = data;
    }
}
/**
 * An event that is emitted when RTCDataChannel is opened.
 */
class DataChannelOpenEvent extends Event {
    constructor(data) {
        super('dataChannelOpen');
        this.data = data;
    }
}
/**
 * An event that is emitted when RTCDataChannel is closed.
 */
class DataChannelCloseEvent extends Event {
    constructor(data) {
        super('dataChannelClose');
        this.data = data;
    }
}
/**
 * An event that is emitted on RTCDataChannel errors.
 */
class DataChannelErrorEvent extends Event {
    constructor(data) {
        super('dataChannelError');
        this.data = data;
    }
}
/**
 * An event that is emitted when the video stream has been initialized.
 */
class VideoInitializedEvent extends Event {
    constructor() {
        super('videoInitialized');
    }
}
/**
 * An event that is emitted when video stream loading starts.
 */
class StreamLoadingEvent extends Event {
    constructor() {
        super('streamLoading');
    }
}
/**
 * An event that is emitted when video stream loading has finished.
 */
class StreamPreConnectEvent extends Event {
    constructor() {
        super('streamConnect');
    }
}
/**
 * An event that is emitted when video stream has stopped.
 */
class StreamPreDisconnectEvent extends Event {
    constructor() {
        super('streamDisconnect');
    }
}
/**
 * An event that is emitted when video stream is reconnecting.
 */
class StreamReconnectEvent extends Event {
    constructor() {
        super('streamReconnect');
    }
}
/**
 * An event that is emitted if there are errors loading the video stream.
 */
class PlayStreamErrorEvent extends Event {
    constructor(data) {
        super('playStreamError');
        this.data = data;
    }
}
/**
 * An event that is emitted before trying to start video playback.
 */
class PlayStreamEvent extends Event {
    constructor() {
        super('playStream');
    }
}
/**
 * An event that is emitted if the browser rejects video playback. Can happen for example if
 * video auto-play without user interaction is refused by the browser.
 */
class PlayStreamRejectedEvent extends Event {
    constructor(data) {
        super('playStreamRejected');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving a full FreezeFrame image from UE.
 */
class LoadFreezeFrameEvent extends Event {
    constructor(data) {
        super('loadFreezeFrame');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving UnfreezeFrame message from UE and video playback is about to be resumed.
 */
class HideFreezeFrameEvent extends Event {
    constructor() {
        super('hideFreezeFrame');
    }
}
/**
 * An event that is emitted when receiving WebRTC statistics.
 */
class StatsReceivedEvent extends Event {
    constructor(data) {
        super('statsReceived');
        this.data = data;
    }
}
/**
 * An event that is emitted when streamer list changes.
 */
class StreamerListMessageEvent extends Event {
    constructor(data) {
        super('streamerListMessage');
        this.data = data;
    }
}
/**
 * An event that is emitted when a subscribed to streamer's id changes.
 */
class StreamerIDChangedMessageEvent extends Event {
    constructor(data) {
        super('StreamerIDChangedMessage');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving latency test results.
 */
class LatencyTestResultEvent extends Event {
    constructor(data) {
        super('latencyTestResult');
        this.data = data;
    }
}
/**
 * An event that is emitted everytime latency is calculated using the WebRTC stats API.
 */
class LatencyCalculatedEvent extends Event {
    constructor(data) {
        super('latencyCalculated');
        this.data = data;
    }
}
/**
 * An event that is emitted when we receive the "onScreenKeyboard" command from UE.
 */
class ShowOnScreenKeyboardEvent extends Event {
    constructor(data) {
        super('showOnScreenKeyboard');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving data channel latency test response from server.
 * This event is handled by DataChannelLatencyTestController
 */
class DataChannelLatencyTestResponseEvent extends Event {
    constructor(data) {
        super('dataChannelLatencyTestResponse');
        this.data = data;
    }
}
/**
 * An event that is emitted when data channel latency test results are ready.
 */
class DataChannelLatencyTestResultEvent extends Event {
    constructor(data) {
        super('dataChannelLatencyTestResult');
        this.data = data;
    }
}
class SubscribeFailedEvent extends Event {
    constructor(data) {
        super('subscribeFailed');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving initial settings from UE.
 */
class InitialSettingsEvent extends Event {
    constructor(data) {
        super('initialSettings');
        this.data = data;
    }
}
/**
 * An event that is emitted when PixelStreaming settings change.
 */
class SettingsChangedEvent extends Event {
    constructor(data) {
        super('settingsChanged');
        this.data = data;
    }
}
/**
 * Event emitted when an XR Session starts
 */
class XrSessionStartedEvent extends Event {
    constructor() {
        super('xrSessionStarted');
    }
}
/**
 * Event emitted when an XR Session ends
 */
class XrSessionEndedEvent extends Event {
    constructor() {
        super('xrSessionEnded');
    }
}
/**
 * Event emitted when an XR Frame is complete
 */
class XrFrameEvent extends Event {
    constructor(data) {
        super('xrFrame');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving a player count from the signalling server
 */
class PlayerCountEvent extends Event {
    constructor(data) {
        super('playerCount');
        this.data = data;
    }
}
/**
 * An event that is emitted when the webRTC connections is relayed over TCP.
 */
class WebRtcTCPRelayDetectedEvent extends Event {
    constructor() {
        super('webRtcTCPRelayDetected');
    }
}
class PixelStreamingEventEmitter extends EventTarget {
    /**
     * Dispatch a new event.
     * @param e event
     * @returns
     */
    dispatchEvent(e) {
        return super.dispatchEvent(e);
    }
    /**
     * Register an event handler.
     * @param type event name
     * @param listener event handler function
     */
    addEventListener(type, listener) {
        super.addEventListener(type, listener);
    }
    /**
     * Remove an event handler.
     * @param type event name
     * @param listener event handler function
     */
    removeEventListener(type, listener) {
        super.removeEventListener(type, listener);
    }
}
//# sourceMappingURL=EventEmitter.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/FileUtil.js":
/*!***********************************************!*\
  !*** ../../library/dist/esm/Util/FileUtil.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FileTemplate: () => (/* binding */ FileTemplate),
/* harmony export */   FileUtil: () => (/* binding */ FileUtil)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Utility function for populate file information from byte buffers.
 */
class FileUtil {
    /**
     * Processes a files extension when received over data channel
     * @param view - the file extension data
     */
    static setExtensionFromBytes(view, file) {
        // Reset file if we got a file message and we are not "receiving" it yet
        if (!file.receiving) {
            file.mimetype = '';
            file.extension = '';
            file.receiving = true;
            file.valid = false;
            file.chunks = 0;
            file.data = [];
            file.timestampStart = new Date().getTime();
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Received first chunk of file');
        }
        const extensionAsString = new TextDecoder('utf-16').decode(view.slice(1));
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(extensionAsString);
        file.extension = extensionAsString;
    }
    /**
     * Processes a files mime type when received over data channel
     * @param view - the file mime type data
     */
    static setMimeTypeFromBytes(view, file) {
        // Reset file if we got a file message and we are not "receiving" it yet
        if (!file.receiving) {
            file.mimetype = '';
            file.extension = '';
            file.receiving = true;
            file.valid = false;
            file.chunks = 0;
            file.data = [];
            file.timestampStart = new Date().getTime();
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Received first chunk of file');
        }
        const mimeAsString = new TextDecoder('utf-16').decode(view.slice(1));
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(mimeAsString);
        file.mimetype = mimeAsString;
    }
    /**
     * Processes a files contents when received over data channel
     * @param view - the file contents data
     */
    static setContentsFromBytes(view, file) {
        // If we haven't received the initial setup instructions, return
        if (!file.receiving)
            return;
        const typeSize = 1;
        const intSize = 4;
        const maxMessageSize = 16 * 1024;
        const headerSize = typeSize + intSize;
        const maxPayloadSize = maxMessageSize - headerSize;
        // Calculate total number of chunks from the total file size
        file.chunks = Math.ceil(new DataView(view.slice(typeSize, headerSize).buffer).getInt32(0, true) / maxPayloadSize);
        // Get the file part of the payload
        const fileBytes = view.slice(headerSize);
        // Append to existing data that holds the file
        file.data.push(fileBytes);
        // Uncomment for debug
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Received file chunk: ${file.data.length}/${file.chunks}`);
        if (file.data.length === file.chunks) {
            file.receiving = false;
            file.valid = true;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Received complete file');
            const transferDuration = new Date().getTime() - file.timestampStart;
            const transferBitrate = Math.round((file.chunks * maxMessageSize) / transferDuration);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Average transfer bitrate: ${transferBitrate}kb/s over ${transferDuration / 1000} seconds`);
            // File reconstruction
            /**
             * Example code to reconstruct the file
             *
             * This code reconstructs the received data into the original file based on the mime type and extension provided and then downloads the reconstructed file
             */
            const received = new Blob(file.data, { type: file.mimetype });
            const a = document.createElement('a');
            a.setAttribute('href', URL.createObjectURL(received));
            a.setAttribute('download', `transfer.${file.extension}`);
            document.body.append(a);
            // if you are so inclined to make it auto-download, do something like: a.click();
            a.remove();
        }
        else if (file.data.length > file.chunks) {
            file.receiving = false;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Received bigger file than advertised: ${file.data.length}/${file.chunks}`);
        }
    }
}
/**
 * A class that represents a template for a downloaded file
 */
class FileTemplate {
    constructor() {
        this.mimetype = '';
        this.extension = '';
        this.receiving = false;
        this.chunks = 0;
        this.data = [];
        this.valid = false;
    }
}
//# sourceMappingURL=FileUtil.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/IURLSearchParams.js":
/*!*******************************************************!*\
  !*** ../../library/dist/esm/Util/IURLSearchParams.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IURLSearchParams: () => (/* binding */ IURLSearchParams)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * A case insensitive, partial implementation of URLSearchParams
 */
class IURLSearchParams {
    constructor(search) {
        this._urlParams = {};
        const urlParams = new URLSearchParams(search);
        for (const [name, value] of urlParams) {
            this._urlParams[name.toLowerCase()] = value;
        }
    }
    has(name) {
        return name.toLowerCase() in this._urlParams;
    }
    get(name) {
        if (this.has(name)) {
            return this._urlParams[name.toLowerCase()];
        }
        return null;
    }
}
//# sourceMappingURL=IURLSearchParams.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/InputCoordTranslator.js":
/*!***********************************************************!*\
  !*** ../../library/dist/esm/Util/InputCoordTranslator.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InputCoordTranslator: () => (/* binding */ InputCoordTranslator)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Converts coordinates from element relative coordinates to values normalized within the value range of a short (and back again)
 */
class InputCoordTranslator {
    // we dont use a constructor here because the object is created and passed around to various locations
    // possibly before this method is called.
    reconfigure(playerSize, videoSize) {
        const playerAspectRatio = playerSize.height / playerSize.width;
        const videoAspectRatio = videoSize.height / videoSize.width;
        this.playerIsLarger = playerAspectRatio > videoAspectRatio;
        this.playerSize = playerSize;
        this.ratio = this.playerIsLarger
            ? playerAspectRatio / videoAspectRatio
            : videoAspectRatio / playerAspectRatio;
    }
    translateUnsigned(x, y) {
        const normalizedX = this.playerIsLarger
            ? x / this.playerSize.width
            : this.ratio * (x / this.playerSize.width - 0.5) + 0.5;
        const normalizedY = this.playerIsLarger
            ? this.ratio * (y / this.playerSize.height - 0.5) + 0.5
            : y / this.playerSize.height;
        if (normalizedX < 0.0 || normalizedX > 1.0 || normalizedY < 0.0 || normalizedY > 1.0) {
            return { inRange: false, x: 65535, y: 65535 };
        }
        else {
            return { inRange: true, x: normalizedX * 65536, y: normalizedY * 65536 };
        }
    }
    translateSigned(x, y) {
        const normalizedX = this.playerIsLarger
            ? x / (0.5 * this.playerSize.width)
            : (this.ratio * x) / (0.5 * this.playerSize.width);
        const normalizedY = this.playerIsLarger
            ? (this.ratio * y) / (0.5 * this.playerSize.height)
            : y / (0.5 * this.playerSize.height);
        return { x: normalizedX * 32767, y: normalizedY * 32767 };
    }
    untranslateUnsigned(x, y) {
        const normalizedX = this.playerIsLarger ? x / 65536 : (x / 65536 - 0.5) / this.ratio + 0.5;
        const normalizedY = this.playerIsLarger ? (y / 65536 - 0.5) / this.ratio + 0.5 : y / 65536;
        return { x: normalizedX * this.playerSize.width, y: normalizedY * this.playerSize.height };
    }
}
//# sourceMappingURL=InputCoordTranslator.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/RTCUtils.js":
/*!***********************************************!*\
  !*** ../../library/dist/esm/Util/RTCUtils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RTCUtils: () => (/* binding */ RTCUtils)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class RTCUtils {
    static isVideoTransceiver(transceiver) {
        return this.canTransceiverReceiveVideo(transceiver) || this.canTransceiverSendVideo(transceiver);
    }
    static canTransceiverReceiveVideo(transceiver) {
        return (!!transceiver &&
            (transceiver.direction === 'sendrecv' || transceiver.direction === 'recvonly') &&
            transceiver.receiver &&
            transceiver.receiver.track &&
            transceiver.receiver.track.kind === 'video');
    }
    static canTransceiverSendVideo(transceiver) {
        return (!!transceiver &&
            (transceiver.direction === 'sendrecv' || transceiver.direction === 'sendonly') &&
            transceiver.sender &&
            transceiver.sender.track &&
            transceiver.sender.track.kind === 'video');
    }
    static isAudioTransceiver(transceiver) {
        return this.canTransceiverReceiveAudio(transceiver) || this.canTransceiverSendAudio(transceiver);
    }
    static canTransceiverReceiveAudio(transceiver) {
        return (!!transceiver &&
            (transceiver.direction === 'sendrecv' || transceiver.direction === 'recvonly') &&
            transceiver.receiver &&
            transceiver.receiver.track &&
            transceiver.receiver.track.kind === 'audio');
    }
    static canTransceiverSendAudio(transceiver) {
        return (!!transceiver &&
            (transceiver.direction === 'sendrecv' || transceiver.direction === 'sendonly') &&
            transceiver.sender &&
            transceiver.sender.track &&
            transceiver.sender.track.kind === 'audio');
    }
}
//# sourceMappingURL=RTCUtils.js.map

/***/ }),

/***/ "../../library/dist/esm/VideoPlayer/StreamController.js":
/*!**************************************************************!*\
  !*** ../../library/dist/esm/VideoPlayer/StreamController.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StreamController: () => (/* binding */ StreamController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Video Player Controller handles the creation of the video HTML element and all handlers
 */
class StreamController {
    /**
     * @param videoElementProvider Video Player instance
     */
    constructor(videoElementProvider) {
        this.videoElementProvider = videoElementProvider;
        this.audioElement = document.createElement('Audio');
        this.videoElementProvider.setAudioElement(this.audioElement);
    }
    /**
     * Handles when the Peer connection has a track event
     * @param rtcTrackEvent - RTC Track Event
     */
    handleOnTrack(rtcTrackEvent) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('handleOnTrack ' + JSON.stringify(rtcTrackEvent.streams));
        // Do not add the track if the ID is `probator` as this is special track created by mediasoup for bitrate probing.
        // Refer to https://github.com/EpicGamesExt/PixelStreamingInfrastructure/pull/86 for more details.
        if (rtcTrackEvent.streams.length < 1 || rtcTrackEvent.streams[0].id == 'probator') {
            return;
        }
        const videoElement = this.videoElementProvider.getVideoElement();
        if (rtcTrackEvent.track) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Got track - ' +
                rtcTrackEvent.track.kind +
                ' id=' +
                rtcTrackEvent.track.id +
                ' readyState=' +
                rtcTrackEvent.track.readyState);
        }
        if (rtcTrackEvent.track.kind == 'audio') {
            this.CreateAudioTrack(rtcTrackEvent.streams[0]);
            return;
        }
        else if (rtcTrackEvent.track.kind == 'video' &&
            videoElement.srcObject !== rtcTrackEvent.streams[0]) {
            videoElement.srcObject = rtcTrackEvent.streams[0];
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Set video source from video track ontrack.');
            return;
        }
    }
    /**
     * Creates the audio device when receiving an RTCTrackEvent with the kind of "audio"
     * @param audioMediaStream - Audio Media stream track
     */
    CreateAudioTrack(audioMediaStream) {
        const videoElement = this.videoElementProvider.getVideoElement();
        // do nothing the video has the same media stream as the audio track we have here (they are linked)
        if (videoElement.srcObject == audioMediaStream) {
            return;
        }
        // video element has some other media stream that is not associated with this audio track
        else if (videoElement.srcObject && videoElement.srcObject !== audioMediaStream) {
            // create a new audio element
            this.audioElement.srcObject = audioMediaStream;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Created new audio element to play separate audio stream.');
        }
    }
}
//# sourceMappingURL=StreamController.js.map

/***/ }),

/***/ "../../library/dist/esm/VideoPlayer/VideoPlayer.js":
/*!*********************************************************!*\
  !*** ../../library/dist/esm/VideoPlayer/VideoPlayer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VideoPlayer: () => (/* binding */ VideoPlayer)
/* harmony export */ });
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * The video player html element
 */
class VideoPlayer {
    /**
     * @param videoElementParent the html div the the video player will be injected into
     * @param config the applications configuration. We're interested in the startVideoMuted flag
     */
    constructor(videoElementParent, config) {
        this.lastTimeResized = new Date().getTime();
        this.videoElement = document.createElement('video');
        this.config = config;
        this.videoElement.id = 'streamingVideo';
        this.videoElement.disablePictureInPicture = true;
        this.videoElement.playsInline = true;
        this.videoElement.style.width = '100%';
        this.videoElement.style.height = '100%';
        this.videoElement.style.position = 'absolute';
        this.videoElement.style.pointerEvents = 'all';
        videoElementParent.appendChild(this.videoElement);
        this.onResizePlayerCallback = () => {
            console.log('Resolution changed, restyling player, did you forget to override this function?');
        };
        this.onMatchViewportResolutionCallback = () => {
            console.log('Resolution changed and match viewport resolution is turned on, did you forget to override this function?');
        };
        // set play for video (and audio)
        this.videoElement.onclick = () => {
            if (this.audioElement != undefined && this.audioElement.paused) {
                this.audioElement.play();
            }
            if (this.videoElement.paused) {
                this.videoElement.play();
            }
        };
        this.videoElement.onloadedmetadata = () => {
            this.onVideoInitialized();
        };
        // set resize events to the windows if it is resized or its orientation is changed
        window.addEventListener('resize', () => this.resizePlayerStyle(), true);
        window.addEventListener('orientationchange', () => this.onOrientationChange());
    }
    destroy() {
        this.videoElement.src = '';
        this.videoElement.srcObject = null;
        this.videoElement.remove();
        if (this.audioElement) {
            this.audioElement.src = '';
            this.audioElement.srcObject = null;
            this.audioElement.remove();
        }
    }
    setAudioElement(audioElement) {
        this.audioElement = audioElement;
    }
    /**
     * Sets up the video element with any application config and plays the video element.
     * @returns A promise for if playing the video was successful or not.
     */
    play() {
        this.videoElement.muted = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_0__.Flags.StartVideoMuted);
        this.videoElement.autoplay = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_0__.Flags.AutoPlayVideo);
        return this.videoElement.play();
    }
    /**
     * @returns True if the video element is paused.
     */
    isPaused() {
        return this.videoElement.paused;
    }
    /**
     * @returns - whether the video element is playing.
     */
    isVideoReady() {
        return this.videoElement.readyState !== undefined && this.videoElement.readyState > 0;
    }
    /**
     * @returns True if the video element has a valid video source (srcObject).
     */
    hasVideoSource() {
        return this.videoElement.srcObject !== undefined && this.videoElement.srcObject !== null;
    }
    /**
     * Get the current context of the html video element
     * @returns - the current context of the video element
     */
    getVideoElement() {
        return this.videoElement;
    }
    /**
     * Get the current context of the html video elements parent
     * @returns - the current context of the video elements parent
     */
    getVideoParentElement() {
        var _a;
        return (_a = this.videoElement.parentElement) !== null && _a !== void 0 ? _a : undefined;
    }
    /**
     * Set the Video Elements src object tracks to enable
     * @param enabled - Enable Tracks on the Src Object
     */
    setVideoEnabled(enabled) {
        // this is a temporary hack until type scripts video element is updated to reflect the need for tracks on a html video element
        const videoElement = this.videoElement;
        videoElement.srcObject
            .getTracks()
            .forEach((track) => (track.enabled = enabled));
    }
    /**
     * An override for when the video has been initialized with a srcObject
     */
    onVideoInitialized() {
        // Default Functionality: Do Nothing
    }
    /**
     * On the orientation change of a window clear the timeout
     */
    onOrientationChange() {
        clearTimeout(this.orientationChangeTimeout);
        this.orientationChangeTimeout = window.setTimeout(() => {
            this.resizePlayerStyle();
        }, 500);
    }
    /**
     * Resizes the player style based on the window height and width
     * @returns - nil if requirements are satisfied
     */
    resizePlayerStyle() {
        const videoElementParent = this.getVideoParentElement();
        if (!videoElementParent) {
            return;
        }
        this.updateVideoStreamSize();
        if (videoElementParent.classList.contains('fixed-size')) {
            this.onResizePlayerCallback();
            return;
        }
        // controls for resizing the player
        this.resizePlayerStyleToFillParentElement();
        this.onResizePlayerCallback();
    }
    /**
     * Resizes the player element to fill the parent element
     */
    resizePlayerStyleToFillParentElement() {
        const videoElementParent = this.getVideoParentElement();
        //Video is not initialized yet so set videoElementParent to size of parent element
        const styleWidth = '100%';
        const styleHeight = '100%';
        const styleTop = 0;
        const styleLeft = 0;
        videoElementParent.setAttribute('style', 'top: ' +
            styleTop +
            'px; left: ' +
            styleLeft +
            'px; width: ' +
            styleWidth +
            '; height: ' +
            styleHeight +
            '; cursor: default;');
    }
    updateVideoStreamSize() {
        if (!this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_0__.Flags.MatchViewportResolution)) {
            return;
        }
        const now = new Date().getTime();
        if (now - this.lastTimeResized > 300) {
            const videoElementParent = this.getVideoParentElement();
            if (!videoElementParent) {
                return;
            }
            this.onMatchViewportResolutionCallback(videoElementParent.clientWidth, videoElementParent.clientHeight);
            this.lastTimeResized = new Date().getTime();
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Resizing too often - skipping');
            clearTimeout(this.resizeTimeoutHandle);
            this.resizeTimeoutHandle = window.setTimeout(() => this.updateVideoStreamSize(), 100);
        }
    }
}
//# sourceMappingURL=VideoPlayer.js.map

/***/ }),

/***/ "../../library/dist/esm/WebRtcPlayer/WebRtcPlayerController.js":
/*!*********************************************************************!*\
  !*** ../../library/dist/esm/WebRtcPlayer/WebRtcPlayerController.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebRtcPlayerController: () => (/* binding */ WebRtcPlayerController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Transport/WebSocketTransport.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Protocol/SignallingProtocol.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Messages/signalling_messages.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Messages/message_helpers.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Protocol/KeepaliveMonitor.js");
/* harmony import */ var _VideoPlayer_StreamController__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../VideoPlayer/StreamController */ "../../library/dist/esm/VideoPlayer/StreamController.js");
/* harmony import */ var _FreezeFrame_FreezeFrameController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../FreezeFrame/FreezeFrameController */ "../../library/dist/esm/FreezeFrame/FreezeFrameController.js");
/* harmony import */ var _AFK_AFKController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../AFK/AFKController */ "../../library/dist/esm/AFK/AFKController.js");
/* harmony import */ var _DataChannel_DataChannelController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../DataChannel/DataChannelController */ "../../library/dist/esm/DataChannel/DataChannelController.js");
/* harmony import */ var _PeerConnectionController_PeerConnectionController__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../PeerConnectionController/PeerConnectionController */ "../../library/dist/esm/PeerConnectionController/PeerConnectionController.js");
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _DataChannel_InitialSettings__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../DataChannel/InitialSettings */ "../../library/dist/esm/DataChannel/InitialSettings.js");
/* harmony import */ var _DataChannel_LatencyTestResults__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../DataChannel/LatencyTestResults */ "../../library/dist/esm/DataChannel/LatencyTestResults.js");
/* harmony import */ var _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util/FileUtil */ "../../library/dist/esm/Util/FileUtil.js");
/* harmony import */ var _Inputs_InputClassesFactory__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../Inputs/InputClassesFactory */ "../../library/dist/esm/Inputs/InputClassesFactory.js");
/* harmony import */ var _VideoPlayer_VideoPlayer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../VideoPlayer/VideoPlayer */ "../../library/dist/esm/VideoPlayer/VideoPlayer.js");
/* harmony import */ var _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../UeInstanceMessage/StreamMessageController */ "../../library/dist/esm/UeInstanceMessage/StreamMessageController.js");
/* harmony import */ var _UeInstanceMessage_ResponseController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../UeInstanceMessage/ResponseController */ "../../library/dist/esm/UeInstanceMessage/ResponseController.js");
/* harmony import */ var _UeInstanceMessage_SendMessageController__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../UeInstanceMessage/SendMessageController */ "../../library/dist/esm/UeInstanceMessage/SendMessageController.js");
/* harmony import */ var _UeInstanceMessage_ToStreamerMessagesController__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../UeInstanceMessage/ToStreamerMessagesController */ "../../library/dist/esm/UeInstanceMessage/ToStreamerMessagesController.js");
/* harmony import */ var _DataChannel_DataChannelSender__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../DataChannel/DataChannelSender */ "../../library/dist/esm/DataChannel/DataChannelSender.js");
/* harmony import */ var _Util_InputCoordTranslator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Util/InputCoordTranslator */ "../../library/dist/esm/Util/InputCoordTranslator.js");
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../Util/EventEmitter */ "../../library/dist/esm/Util/EventEmitter.js");
/* harmony import */ var _Util_IURLSearchParams__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../Util/IURLSearchParams */ "../../library/dist/esm/Util/IURLSearchParams.js");
/* harmony import */ var _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../Util/BrowserUtils */ "../../library/dist/esm/Util/BrowserUtils.js");
// Copyright Epic Games, Inc. All Rights Reserved.





















/**
 * Entry point for the WebRTC Player
 */
class WebRtcPlayerController {
    /**
     *
     * @param config - the frontend config object
     * @param pixelStreaming - the PixelStreaming object
     */
    constructor(config, pixelStreaming) {
        this.shouldShowPlayOverlay = true;
        this.autoJoinTimer = undefined;
        this.config = config;
        this.pixelStreaming = pixelStreaming;
        this.responseController = new _UeInstanceMessage_ResponseController__WEBPACK_IMPORTED_MODULE_0__.ResponseController();
        this.file = new _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__.FileTemplate();
        this.sdpConstraints = {
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
        };
        // set up the afk logic class and connect up its method for closing the signaling server
        this.afkController = new _AFK_AFKController__WEBPACK_IMPORTED_MODULE_2__.AFKController(this.config, this.pixelStreaming, this.onAfkTriggered.bind(this));
        this.afkController.onAFKTimedOutCallback = () => {
            this.closeSignalingServer('You have been disconnected due to inactivity.', false);
        };
        this.freezeFrameController = new _FreezeFrame_FreezeFrameController__WEBPACK_IMPORTED_MODULE_3__.FreezeFrameController(this.pixelStreaming.videoElementParent);
        this.videoPlayer = new _VideoPlayer_VideoPlayer__WEBPACK_IMPORTED_MODULE_4__.VideoPlayer(this.pixelStreaming.videoElementParent, this.config);
        this.videoPlayer.onVideoInitialized = () => this.handleVideoInitialized();
        // When in match viewport resolution mode, when the browser viewport is resized we send a resize command back to UE.
        this.videoPlayer.onMatchViewportResolutionCallback = (width, height) => {
            const descriptor = {
                'Resolution.Width': width,
                'Resolution.Height': height
            };
            this.streamMessageController.toStreamerHandlers.get('Command')([JSON.stringify(descriptor)]);
        };
        // Every time video player is resized in browser we need to reinitialize the mouse coordinate conversion and freeze frame sizing logic.
        this.videoPlayer.onResizePlayerCallback = () => {
            this.setUpMouseAndFreezeFrame();
        };
        this.streamController = new _VideoPlayer_StreamController__WEBPACK_IMPORTED_MODULE_5__.StreamController(this.videoPlayer);
        this.coordinateConverter = new _Util_InputCoordTranslator__WEBPACK_IMPORTED_MODULE_6__.InputCoordTranslator();
        this.sendrecvDataChannelController = new _DataChannel_DataChannelController__WEBPACK_IMPORTED_MODULE_7__.DataChannelController();
        this.recvDataChannelController = new _DataChannel_DataChannelController__WEBPACK_IMPORTED_MODULE_7__.DataChannelController();
        this.registerDataChannelEventEmitters(this.sendrecvDataChannelController);
        this.registerDataChannelEventEmitters(this.recvDataChannelController);
        this.dataChannelSender = new _DataChannel_DataChannelSender__WEBPACK_IMPORTED_MODULE_8__.DataChannelSender(this.sendrecvDataChannelController);
        this.dataChannelSender.resetAfkWarningTimerOnDataSend = () => this.afkController.resetAfkWarningTimer();
        this.streamMessageController = new _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.StreamMessageController();
        // set up websocket methods
        this.transport = new _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_10__.WebSocketTransport(config.webSocketProtocols);
        this.protocol = new _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_11__.SignallingProtocol(this.transport);
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.config.typeName, (msg) => this.handleOnConfigMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.ping.typeName, (msg) => this.handlePingMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.streamerList.typeName, (msg) => this.handleStreamerListMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.subscribeFailed.typeName, (msg) => this.handleSubscribeFailedMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.streamerIdChanged.typeName, (msg) => this.handleStreamerIDChangedMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.playerCount.typeName, (msg) => {
            const playerCountMessage = msg;
            this.pixelStreaming._onPlayerCount(playerCountMessage.count);
        });
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.answer.typeName, (msg) => this.handleWebRtcAnswer(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.offer.typeName, (msg) => this.handleWebRtcOffer(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.peerDataChannels.typeName, (msg) => this.handleWebRtcSFUPeerDatachannels(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.iceCandidate.typeName, (msg) => {
            const iceCandidateMessage = msg;
            this.handleIceCandidate(iceCandidateMessage.candidate);
        });
        this.protocol.transport.addListener('open', () => {
            const BrowserSendOffer = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.BrowserSendOffer);
            if (!BrowserSendOffer) {
                const message = _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.listStreamers);
                this.protocol.sendMessage(message);
            }
            this.reconnectAttempt = 0;
            this.isReconnecting = false;
        });
        this.protocol.transport.addListener('error', () => {
            // dont really need to do anything here since the close event should follow.
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`Got a transport error.`);
        });
        this.protocol.transport.addListener('close', (event) => {
            // when we refresh the page during a stream we get the going away code.
            // in that case we don't want to reconnect since we're navigating away.
            // https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code
            // lists all the codes.
            const CODE_GOING_AWAY = 1001;
            const maxReconnectAttempts = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.MaxReconnectAttempts);
            const attemptsLeft = this.reconnectAttempt < maxReconnectAttempts;
            const reconnectEnabled = this.forceReconnect || (this.enableAutoReconnect && maxReconnectAttempts > 0 && attemptsLeft);
            const willTryReconnect = reconnectEnabled && event.code != CODE_GOING_AWAY;
            const allowClickToReconnect = !willTryReconnect;
            const disconnectMessage = this.disconnectMessage ? this.disconnectMessage : event.reason;
            this.forceReconnect = false;
            // Reset the list of all possible codecs on disconnect so that if the next connection has "NegotiateCodecs" on
            // then all codecs can be negotiated
            this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.PreferredCodec).options =
                _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_16__.BrowserUtils.getSupportedVideoCodecs();
            this.pixelStreaming._onDisconnect(disconnectMessage, allowClickToReconnect);
            this.afkController.stopAfkWarningTimer();
            // stop sending stats on interval if we have closed our connection
            if (this.statsTimerHandle && this.statsTimerHandle !== undefined) {
                window.clearInterval(this.statsTimerHandle);
            }
            // reset the stream quality icon.
            this.setVideoEncoderAvgQP(0);
            // unregister all input device event handlers on disconnect
            this.setTouchInputEnabled(false);
            this.setMouseInputEnabled(false);
            this.setKeyboardInputEnabled(false);
            this.setGamePadInputEnabled(false);
            if (willTryReconnect) {
                // need a small delay here to prevent reconnect spamming
                setTimeout(() => {
                    this.reconnectAttempt++;
                    this.doReconnect(event.reason);
                }, 2000);
            }
        });
        // set up the final webRtc player controller methods from within our application so a connection can be activated
        this.sendMessageController = new _UeInstanceMessage_SendMessageController__WEBPACK_IMPORTED_MODULE_17__.SendMessageController(this.dataChannelSender, this.streamMessageController);
        this.toStreamerMessagesController = new _UeInstanceMessage_ToStreamerMessagesController__WEBPACK_IMPORTED_MODULE_18__.ToStreamerMessagesController(this.sendMessageController);
        this.registerMessageHandlers();
        this.streamMessageController.populateDefaultProtocol();
        this.inputClassesFactory = new _Inputs_InputClassesFactory__WEBPACK_IMPORTED_MODULE_19__.InputClassesFactory(this.streamMessageController, this.videoPlayer, this.coordinateConverter);
        this.isUsingSFU = false;
        this.isUsingSVC = false;
        this.isQualityController = false;
        this.preferredCodec = '';
        this.enableAutoReconnect = true;
        this.forceReconnect = false;
        this.reconnectAttempt = 0;
        this.isReconnecting = false;
        this.config._addOnOptionSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId, (streamerid) => {
            if (streamerid === undefined || streamerid === '') {
                return;
            }
            // close the current peer connection and create a new one
            this.peerConnectionController.peerConnection.close();
            this.peerConnectionController.createPeerConnection(this.peerConfig, this.preferredCodec);
            this.subscribedStream = streamerid;
            const message = _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.subscribe, { streamerId: streamerid });
            this.protocol.sendMessage(message);
        });
        this.config._addOnOptionSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.PreferredQuality, (preferredQuality) => {
            if (preferredQuality === undefined || preferredQuality === '') {
                return;
            }
            let message;
            if (this.isUsingSVC) {
                // User is using SVC so selected quality will be of the form SxTy(h). Just extract the x and y numbers
                message = _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.layerPreference, {
                    spatialLayer: +preferredQuality[1] - 1,
                    temporalLayer: +preferredQuality[3] - 1
                });
            }
            else {
                // User is not using SVC so the selected quality will be either Low, Medium or High so we extract the appropriate spatial layer index
                const allQualities = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.PreferredQuality).options;
                const qualityIndex = allQualities.indexOf(preferredQuality);
                message = _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.layerPreference, {
                    spatialLayer: qualityIndex,
                    temporalLayer: 0
                });
            }
            this.protocol.sendMessage(message);
        });
        this.setVideoEncoderAvgQP(-1);
        this.signallingUrlBuilder = () => {
            const signallingServerUrl = this.config.getTextSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.TextParameters.SignallingServerUrl);
            return signallingServerUrl;
        };
    }
    /**
     * Destroys the video player and makes sure resources are freed. This helps to prevent the issue in chrome
     * where it refuses to make new video players.
     */
    destroyVideoPlayer() {
        this.videoPlayer.destroy();
    }
    /**
     * Handles when a message is received
     * @param event - Message Event
     */
    handleOnMessage(event) {
        const message = new Uint8Array(event.data);
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Message incoming:' + message);
        //try {
        const messageType = this.streamMessageController.fromStreamerMessages.get(message[0]);
        this.streamMessageController.fromStreamerHandlers.get(messageType)(event.data);
        //} catch (e) {
        //Logger.Error(Logger.GetStackTrace(), `Custom data channel message with message type that is unknown to the Pixel Streaming protocol. Does your PixelStreamingProtocol need updating? The message type was: ${message[0]}`);
        //}
    }
    /**
     * Register message all handlers
     */
    registerMessageHandlers() {
        // From Streamer
        // Message events from the streamer have a data type of ArrayBuffer as we force this type in the DatachannelController
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'QualityControlOwnership', (data) => this.onQualityControlOwnership(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'Response', (data) => this.responseController.onResponse(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'Command', (data) => {
            this.onCommand(data);
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'FreezeFrame', (data) => this.onFreezeFrameMessage(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'UnfreezeFrame', () => this.invalidateFreezeFrameAndEnableVideo());
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'VideoEncoderAvgQP', (data) => this.handleVideoEncoderAvgQP(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'LatencyTest', (data) => this.handleLatencyTestResult(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'DataChannelLatencyTest', (data) => this.handleDataChannelLatencyTestResponse(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'InitialSettings', (data) => this.handleInitialSettings(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'FileExtension', (data) => this.onFileExtension(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'FileMimeType', (data) => this.onFileMimeType(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'FileContents', (data) => this.onFileContents(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'TestEcho', () => {
            /* Do nothing */
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'InputControlOwnership', (data) => this.onInputControlOwnership(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'GamepadResponse', (data) => this.onGamepadResponse(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'Multiplexed', () => {
            /* Do nothing as this message type is used only by the SFU */
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'Protocol', (data) => this.onProtocolMessage(data));
        // To Streamer
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'IFrameRequest', () => this.sendMessageController.sendMessageToStreamer('IFrameRequest'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'RequestQualityControl', () => this.sendMessageController.sendMessageToStreamer('RequestQualityControl'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'FpsRequest', () => this.sendMessageController.sendMessageToStreamer('FpsRequest'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'AverageBitrateRequest', () => this.sendMessageController.sendMessageToStreamer('AverageBitrateRequest'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'StartStreaming', () => this.sendMessageController.sendMessageToStreamer('StartStreaming'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'StopStreaming', () => this.sendMessageController.sendMessageToStreamer('StopStreaming'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'LatencyTest', (data) => this.sendMessageController.sendMessageToStreamer('LatencyTest', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'RequestInitialSettings', () => this.sendMessageController.sendMessageToStreamer('RequestInitialSettings'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TestEcho', () => {
            /* Do nothing */
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'UIInteraction', (data) => this.sendMessageController.sendMessageToStreamer('UIInteraction', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'Command', (data) => this.sendMessageController.sendMessageToStreamer('Command', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TextboxEntry', (data) => this.sendMessageController.sendMessageToStreamer('TextboxEntry', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'KeyDown', (data) => this.sendMessageController.sendMessageToStreamer('KeyDown', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'KeyUp', (data) => this.sendMessageController.sendMessageToStreamer('KeyUp', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'KeyPress', (data) => this.sendMessageController.sendMessageToStreamer('KeyPress', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseEnter', (data) => this.sendMessageController.sendMessageToStreamer('MouseEnter', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseLeave', (data) => this.sendMessageController.sendMessageToStreamer('MouseLeave', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseDown', (data) => this.sendMessageController.sendMessageToStreamer('MouseDown', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseUp', (data) => this.sendMessageController.sendMessageToStreamer('MouseUp', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseMove', (data) => this.sendMessageController.sendMessageToStreamer('MouseMove', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseWheel', (data) => this.sendMessageController.sendMessageToStreamer('MouseWheel', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseDouble', (data) => this.sendMessageController.sendMessageToStreamer('MouseDouble', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TouchStart', (data) => this.sendMessageController.sendMessageToStreamer('TouchStart', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TouchEnd', (data) => this.sendMessageController.sendMessageToStreamer('TouchEnd', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TouchMove', (data) => this.sendMessageController.sendMessageToStreamer('TouchMove', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadConnected', () => this.sendMessageController.sendMessageToStreamer('GamepadConnected'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadButtonPressed', (data) => this.sendMessageController.sendMessageToStreamer('GamepadButtonPressed', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadButtonReleased', (data) => this.sendMessageController.sendMessageToStreamer('GamepadButtonReleased', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadAnalog', (data) => this.sendMessageController.sendMessageToStreamer('GamepadAnalog', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadDisconnected', (data) => this.sendMessageController.sendMessageToStreamer('GamepadDisconnected', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XREyeViews', (data) => this.sendMessageController.sendMessageToStreamer('XREyeViews', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRHMDTransform', (data) => this.sendMessageController.sendMessageToStreamer('XRHMDTransform', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRControllerTransform', (data) => this.sendMessageController.sendMessageToStreamer('XRControllerTransform', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRSystem', (data) => this.sendMessageController.sendMessageToStreamer('XRSystem', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRButtonTouched', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonTouched', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRButtonTouchReleased', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonTouchReleased', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRButtonPressed', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonPressed', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRButtonReleased', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonReleased', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRAnalog', (data) => this.sendMessageController.sendMessageToStreamer('XRAnalog', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'ChannelRelayStatus', () => {
            /* Do nothing as this message type is used only by the SFU */
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'Multiplexed', () => {
            /* Do nothing as this message type is used only by the SFU */
        });
    }
    /**
     * Activate the logic associated with a command from UE
     * @param message
     */
    onCommand(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.Command');
        const commandAsString = new TextDecoder('utf-16').decode(message.slice(1));
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Data Channel Command: ' + commandAsString);
        const command = JSON.parse(commandAsString);
        // Handle "onScreenKeyboard" event
        if (command.command === 'onScreenKeyboard') {
            this.handleOnScreenKeyboardCommand(command);
        }
    }
    handleOnScreenKeyboardCommand(command) {
        var _a, _b, _c, _d;
        const data = {
            showOnScreenKeyboard: (_a = command.showOnScreenKeyboard) !== null && _a !== void 0 ? _a : true,
            x: (_b = command.x) !== null && _b !== void 0 ? _b : 0,
            y: (_c = command.y) !== null && _c !== void 0 ? _c : 0,
            contents: (_d = command.contents) !== null && _d !== void 0 ? _d : ''
        };
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.ShowOnScreenKeyboardEvent(data));
    }
    /**
     * Handles a protocol message received from the streamer
     * @param message the message data from the streamer
     */
    onProtocolMessage(message) {
        try {
            const protocolString = new TextDecoder('utf-16').decode(message.slice(1));
            const protocolJSON = JSON.parse(protocolString);
            if (!Object.prototype.hasOwnProperty.call(protocolJSON, 'Direction')) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error('Malformed protocol received. Ensure the protocol message contains a direction');
            }
            const direction = protocolJSON.Direction;
            delete protocolJSON.Direction;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Received new ${direction == _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer ? 'FromStreamer' : 'ToStreamer'} protocol. Updating existing protocol...`);
            Object.keys(protocolJSON).forEach((messageType) => {
                const message = protocolJSON[messageType];
                switch (direction) {
                    case _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer:
                        // Check that the message contains all the relevant params
                        if (!Object.prototype.hasOwnProperty.call(message, 'id')) {
                            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`ToStreamer->${messageType} protocol definition was malformed as it didn't contain at least an id\n
                                           Definition was: ${JSON.stringify(message, null, 2)}`);
                            // return in a forEach is equivalent to a continue in a normal for loop
                            return;
                        }
                        // UE5.1 and UE5.2 don't send a structure for these message types, but they actually do have a structure so ignore updating them
                        if (messageType === 'UIInteraction' ||
                            messageType === 'Command' ||
                            messageType === 'LatencyTest') {
                            return;
                        }
                        if (this.streamMessageController.toStreamerHandlers.get(messageType)) {
                            // If we've registered a handler for this message type we can add it to our supported messages. ie registerMessageHandler(...)
                            this.streamMessageController.toStreamerMessages.set(messageType, message);
                        }
                        else {
                            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`There was no registered handler for "${messageType}" - try adding one using registerMessageHandler(MessageDirection.ToStreamer, "${messageType}", myHandler)`);
                        }
                        break;
                    case _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer:
                        // Check that the message contains all the relevant params
                        if (!Object.prototype.hasOwnProperty.call(message, 'id')) {
                            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`FromStreamer->${messageType} protocol definition was malformed as it didn't contain at least an id\n
                            Definition was: ${JSON.stringify(message, null, 2)}`);
                            // return in a forEach is equivalent to a continue in a normal for loop
                            return;
                        }
                        if (this.streamMessageController.fromStreamerHandlers.get(messageType)) {
                            // If we've registered a handler for this message type. ie registerMessageHandler(...)
                            this.streamMessageController.fromStreamerMessages.set(message.id, messageType);
                        }
                        else {
                            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`There was no registered handler for "${message}" - try adding one using registerMessageHandler(MessageDirection.FromStreamer, "${messageType}", myHandler)`);
                        }
                        break;
                    default:
                        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`Unknown direction: ${direction}`);
                }
            });
            // Once the protocol has been received, we can send our control messages
            this.toStreamerMessagesController.SendRequestInitialSettings();
            this.toStreamerMessagesController.SendRequestQualityControl();
        }
        catch (e) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(e);
        }
    }
    /**
     * Handles an input control message when it is received from the streamer
     * @param message The input control message
     */
    onInputControlOwnership(message) {
        const view = new Uint8Array(message);
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.InputControlOwnership');
        const inputControlOwnership = new Boolean(view[1]).valueOf();
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Received input controller message - will your input control the stream: ${inputControlOwnership}`);
        this.pixelStreaming._onInputControlOwnership(inputControlOwnership);
    }
    /**
     *
     * @param message
     */
    onGamepadResponse(message) {
        const responseString = new TextDecoder('utf-16').decode(message.slice(1));
        const responseJSON = JSON.parse(responseString);
        this.gamePadController.onGamepadResponseReceived(responseJSON.controllerId);
    }
    onAfkTriggered() {
        this.afkController.onAfkClick();
        // if the stream is paused play it, if we can
        if (this.videoPlayer.isPaused() && this.videoPlayer.hasVideoSource()) {
            this.playStream();
        }
    }
    /**
     * Set whether we should timeout when afk.
     * @param afkEnabled If true we timeout when idle for some given amount of time.
     */
    setAfkEnabled(afkEnabled) {
        if (afkEnabled) {
            this.onAfkTriggered();
        }
        else {
            this.afkController.stopAfkWarningTimer();
        }
    }
    /**
     * Attempt a reconnection to the signalling server. Manual trigger
     */
    tryReconnect(message) {
        this.forceReconnect = true;
        this.doReconnect(message);
    }
    /**
     * Does the actual reconnect work. Used by the auto reconnect feature to skip the manual flag.
     */
    doReconnect(message) {
        // if there is no webSocketController return immediately or this will not work
        if (!this.protocol) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('This player has no protocol connection.');
            return;
        }
        this.isReconnecting = true;
        // if the connection is open, first close it and force a reconnect.
        if (this.protocol.isConnected()) {
            if (!this.forceReconnect) {
                this.disconnectMessage = `${message} Reconnecting.`;
            }
            this.closeSignalingServer(message, true);
        }
        else {
            this.pixelStreaming._onWebRtcAutoConnect();
            this.connectToSignallingServer();
        }
    }
    /**
     * Loads a freeze frame if it is required otherwise shows the play overlay
     */
    loadFreezeFrameOrShowPlayOverlay() {
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.LoadFreezeFrameEvent({
            shouldShowPlayOverlay: this.shouldShowPlayOverlay,
            isValid: this.freezeFrameController.valid,
            jpegData: this.freezeFrameController.jpeg
        }));
        if (this.shouldShowPlayOverlay === true) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('showing play overlay');
            this.resizePlayerStyle();
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('showing freeze frame');
            this.freezeFrameController.showFreezeFrame();
        }
        setTimeout(() => {
            this.videoPlayer.setVideoEnabled(false);
        }, this.freezeFrameController.freezeFrameDelay);
    }
    /**
     * Process the freeze frame and load it
     * @param message The freeze frame data in bytes
     */
    onFreezeFrameMessage(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.FreezeFrame');
        const view = new Uint8Array(message);
        this.freezeFrameController.processFreezeFrameMessage(view, () => this.loadFreezeFrameOrShowPlayOverlay());
    }
    /**
     * Enable the video after hiding a freeze frame
     */
    invalidateFreezeFrameAndEnableVideo() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.FreezeFrame');
        setTimeout(() => {
            this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.HideFreezeFrameEvent());
            this.freezeFrameController.hideFreezeFrame();
        }, this.freezeFrameController.freezeFrameDelay);
        if (this.videoPlayer.getVideoElement()) {
            this.videoPlayer.setVideoEnabled(true);
        }
    }
    /**
     * Prep datachannel data for processing file extension
     * @param data the file extension data
     */
    onFileExtension(data) {
        const view = new Uint8Array(data);
        _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__.FileUtil.setExtensionFromBytes(view, this.file);
    }
    /**
     * Prep datachannel data for processing the file mime type
     * @param data the file mime type data
     */
    onFileMimeType(data) {
        const view = new Uint8Array(data);
        _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__.FileUtil.setMimeTypeFromBytes(view, this.file);
    }
    /**
     * Prep datachannel data for processing the file contents
     * @param data the file contents data
     */
    onFileContents(data) {
        const view = new Uint8Array(data);
        _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__.FileUtil.setContentsFromBytes(view, this.file);
    }
    /**
     * Plays the stream audio and video source and sets up other pieces while the stream starts
     */
    playStream() {
        if (!this.videoPlayer.getVideoElement()) {
            const message = 'Could not play video stream because the video player was not initialized correctly.';
            this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.PlayStreamErrorEvent({ message }));
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(message);
            // close the connection
            this.closeSignalingServer('Stream not initialized correctly', false);
            return;
        }
        if (!this.videoPlayer.hasVideoSource()) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Warning('Cannot play stream, the video element has no srcObject to play.');
            return;
        }
        this.setTouchInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.TouchInput));
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.PlayStreamEvent());
        if (this.streamController.audioElement.srcObject) {
            const startMuted = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.StartVideoMuted);
            this.streamController.audioElement.muted = startMuted;
            if (startMuted) {
                this.playVideo();
            }
            else {
                this.streamController.audioElement
                    .play()
                    .then(() => {
                    this.playVideo();
                })
                    .catch((onRejectedReason) => {
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(onRejectedReason);
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Browser does not support autoplaying video without interaction - to resolve this we are going to show the play button overlay.');
                    this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.PlayStreamRejectedEvent({
                        reason: onRejectedReason
                    }));
                });
            }
        }
        else {
            this.playVideo();
        }
        this.shouldShowPlayOverlay = false;
        this.freezeFrameController.showFreezeFrame();
    }
    /**
     * Plays the video stream
     */
    playVideo() {
        // handle play() with promise as it is an asynchronous call
        this.videoPlayer.play().catch((onRejectedReason) => {
            if (this.streamController.audioElement.srcObject) {
                this.streamController.audioElement.pause();
            }
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(onRejectedReason);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Browser does not support autoplaying video without interaction - to resolve this we are going to show the play button overlay.');
            this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.PlayStreamRejectedEvent({ reason: onRejectedReason }));
        });
    }
    /**
     * Enable the video to play automatically if enableAutoplay is true
     */
    autoPlayVideoOrSetUpPlayOverlay() {
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.AutoPlayVideo)) {
            // attempt to play the video
            this.playStream();
        }
        this.resizePlayerStyle();
    }
    /**
     * Connect to the Signaling server
     */
    connectToSignallingServer() {
        this.locallyClosed = false;
        this.enableAutoReconnect = true;
        this.disconnectMessage = null;
        const signallingUrl = this.signallingUrlBuilder();
        this.protocol.connect(signallingUrl);
        const keepaliveDelay = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.KeepaliveDelay);
        if (keepaliveDelay > 0) {
            this.keepalive = new _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_21__.KeepaliveMonitor(this.protocol, keepaliveDelay);
            this.keepalive.onTimeout = () => {
                // if the ping fails just disconnect
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`Protocol timeout`);
                this.protocol.disconnect();
            };
        }
    }
    /**
     * This will start the handshake to the signalling server
     * @param peerConfig  - RTC Configuration Options from the Signaling server
     * @remark RTC Peer Connection on Ice Candidate event have it handled by handle Send Ice Candidate
     */
    startSession(peerConfig) {
        this.peerConfig = peerConfig;
        // check for forcing turn
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.ForceTURN)) {
            // check for a turn server
            const hasTurnServer = this.checkTurnServerAvailability(peerConfig);
            // close and error if turn is forced and there is no turn server
            if (!hasTurnServer) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('No turn server was found in the Peer Connection Options. TURN cannot be forced, closing connection. Please use STUN instead');
                this.closeSignalingServer('TURN cannot be forced, closing connection. Please use STUN instead.', false);
                return;
            }
        }
        // set up the peer connection controller
        this.peerConnectionController = new _PeerConnectionController_PeerConnectionController__WEBPACK_IMPORTED_MODULE_22__.PeerConnectionController(this.peerConfig, this.config, this.preferredCodec);
        // set up peer connection controller video stats
        this.peerConnectionController.onVideoStats = (event) => {
            this.handleVideoStats(event);
        };
        /* Set event handler for latency information is calculated, handle the event by propogating to the PixelStreaming API */
        this.peerConnectionController.onLatencyCalculated = (latencyInfo) => {
            this.pixelStreaming._onLatencyCalculated(latencyInfo);
        };
        /* When our PeerConnection wants to send an offer call our handler */
        this.peerConnectionController.onSendWebRTCOffer = (offer) => {
            this.handleSendWebRTCOffer(offer);
        };
        /* Set event handler for when local description is set */
        this.peerConnectionController.onSetLocalDescription = (sdp) => {
            if (sdp.type === 'offer') {
                this.handleSendWebRTCOffer(sdp);
            }
            else if (sdp.type === 'answer') {
                this.handleSendWebRTCAnswer(sdp);
            }
            else {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`PeerConnectionController onSetLocalDescription was called with unexpected type ${sdp.type}`);
            }
        };
        /* Event handler for when PeerConnection's remote description is set */
        this.peerConnectionController.onSetRemoteDescription = (sdp) => {
            if (sdp.type === 'offer') {
                this.pixelStreaming._onWebRtcSdpOffer(sdp);
            }
            else if (sdp.type === 'answer') {
                this.pixelStreaming._onWebRtcSdpAnswer(sdp);
            }
            else {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`PeerConnectionController onSetRemoteDescription was called with unexpected type ${sdp.type}`);
            }
        };
        /* When the Peer Connection ice candidate is added have it handled */
        this.peerConnectionController.onPeerIceCandidate = (peerConnectionIceEvent) => this.handleSendIceCandidate(peerConnectionIceEvent);
        /* When the Peer Connection has a data channel created for it by the browser, handle it */
        this.peerConnectionController.onDataChannel = (datachannelEvent) => this.handleDataChannel(datachannelEvent);
        // set up webRtc text overlays
        this.peerConnectionController.showTextOverlayConnecting = () => this.pixelStreaming._onWebRtcConnecting();
        this.peerConnectionController.showTextOverlaySetupFailure = () => this.pixelStreaming._onWebRtcFailed();
        let webRtcConnectedSent = false;
        this.peerConnectionController.onIceConnectionStateChange = () => {
            // Browsers emit "connected" when getting first connection and "completed" when finishing
            // candidate checking. However, sometimes browsers can skip "connected" and only emit "completed".
            // Therefore need to check both cases and emit onWebRtcConnected only once on the first hit.
            if (!webRtcConnectedSent &&
                ['connected', 'completed'].includes(this.peerConnectionController.peerConnection.iceConnectionState)) {
                this.pixelStreaming._onWebRtcConnected();
                webRtcConnectedSent = true;
            }
        };
        /* RTC Peer Connection on Track event -> handle on track */
        this.peerConnectionController.onTrack = (trackEvent) => this.streamController.handleOnTrack(trackEvent);
        const BrowserSendOffer = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.BrowserSendOffer);
        if (BrowserSendOffer) {
            // If browser is sending the offer, create an offer and send it to the streamer
            this.sendrecvDataChannelController.createDataChannel(this.peerConnectionController.peerConnection, 'cirrus', this.datachannelOptions);
            this.sendrecvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
            this.peerConnectionController.createOffer(this.sdpConstraints, this.config);
        }
    }
    /**
     * Checks the peer connection options for a turn server and returns true or false
     */
    checkTurnServerAvailability(options) {
        // if iceServers is empty return false this should not be the general use case but is here incase
        if (!options.iceServers) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('A turn sever was not found');
            return false;
        }
        // loop through the ice servers to check for a turn url
        for (const iceServer of options.iceServers) {
            for (const url of iceServer.urls) {
                if (url.includes('turn')) {
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`A turn sever was found at ${url}`);
                    return true;
                }
            }
        }
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('A turn sever was not found');
        return false;
    }
    /**
     * Handles when a Config Message is received contains the Peer Connection Options required (STUN and TURN Server Info)
     * @param messageConfig - Config Message received from the signaling server
     */
    handleOnConfigMessage(messageConfig) {
        this.resizePlayerStyle();
        // Tell the WebRtcController to start a session with the peer options sent from the signaling server
        this.startSession(messageConfig.peerConnectionOptions);
    }
    handlePingMessage(pingMessage) {
        this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.pong, { time: pingMessage.time }));
    }
    /**
     * Handles when the signalling server gives us the list of streamer ids.
     */
    handleStreamerListMessage(messageStreamerList) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Got streamer list ${messageStreamerList.ids}`);
        let wantedStreamerId = '';
        // get the current selected streamer id option
        const streamerIDOption = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId);
        const existingSelection = streamerIDOption.selected.toString().trim();
        if (existingSelection) {
            // default to selected option if it exists
            wantedStreamerId = streamerIDOption.selected;
        }
        // add the streamers to the UI
        const settingOptions = [...messageStreamerList.ids]; // copy the original messageStreamerList.ids
        settingOptions.unshift(''); // add an empty option at the top
        this.config.setOptionSettingOptions(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId, settingOptions);
        let autoSelectedStreamerId = '';
        const waitForStreamer = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.WaitForStreamer);
        const reconnectLimit = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.MaxReconnectAttempts);
        const reconnectDelay = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.StreamerAutoJoinInterval);
        // first we figure out a wanted streamer id through various means
        const useUrlParams = this.config.useUrlParams;
        const urlParams = new _Util_IURLSearchParams__WEBPACK_IMPORTED_MODULE_23__.IURLSearchParams(window.location.search);
        if (useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId)) {
            // if we've set the streamer id on the url we only want that streamer id
            wantedStreamerId = urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId);
        }
        else if (this.subscribedStream) {
            // we were previously subscribed to a streamer, we want that
            wantedStreamerId = this.subscribedStream;
        }
        // now lets see if we can pick it.
        if (wantedStreamerId && messageStreamerList.ids.includes(wantedStreamerId)) {
            // if the wanted stream is in the list. we pick that
            autoSelectedStreamerId = wantedStreamerId;
        }
        else if ((!wantedStreamerId || !waitForStreamer) && messageStreamerList.ids.length == 1) {
            // otherwise, if we're not waiting for the wanted streamer and there's only one streamer, connect to it
            autoSelectedStreamerId = messageStreamerList.ids[0];
        }
        // if we found a streamer id to auto select, select it
        if (autoSelectedStreamerId) {
            this.reconnectAttempt = 0;
            this.isReconnecting = false;
            this.config.setOptionSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId, autoSelectedStreamerId);
        }
        else {
            // no auto selected streamer.
            // if we're waiting for a streamer then try reconnecting
            if (waitForStreamer) {
                if (this.reconnectAttempt < reconnectLimit) {
                    // still reconnects available
                    this.reconnectAttempt++;
                    this.isReconnecting = true;
                    setTimeout(() => {
                        this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.listStreamers));
                    }, reconnectDelay);
                }
                else {
                    // We've exhausted our reconnect attempts, return to main screen
                    this.reconnectAttempt = 0;
                    this.isReconnecting = false;
                    this.enableAutoReconnect = false;
                }
            }
        }
        // dispatch this event finally
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.StreamerListMessageEvent({
            messageStreamerList,
            autoSelectedStreamerId,
            wantedStreamerId
        }));
    }
    handleSubscribeFailedMessage(subscribeFailedMessage) {
        this.reconnectAttempt = 0;
        this.isReconnecting = false;
        this.enableAutoReconnect = false;
        this.pixelStreaming._onSubscribeFailed(subscribeFailedMessage.message);
    }
    handleStreamerIDChangedMessage(streamerIDChangedMessage) {
        const newID = streamerIDChangedMessage.newID;
        // need to edit the selected streamer in the settings list
        const streamerListOptions = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId);
        // temporarily prevent onChange from firing (it would try to subscribe to the streamer again)
        const oldOnChange = streamerListOptions.onChange;
        streamerListOptions.onChange = () => { };
        // change the selected entry.
        const streamerList = streamerListOptions.options;
        for (let i = 0; i < streamerList.length; ++i) {
            if (streamerList[i] == this.subscribedStream) {
                streamerList[i] = newID;
                break;
            }
        }
        // update the list
        streamerListOptions.options = streamerList;
        // update the selected entry
        streamerListOptions.selected = newID;
        // restore the old change notifier.
        streamerListOptions.onChange = oldOnChange;
        // remember which stream we're subscribe to
        this.subscribedStream = streamerIDChangedMessage.newID;
        // notify any listeners
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.StreamerIDChangedMessageEvent({
            newID
        }));
    }
    /**
     * Handle the RTC Answer from the signaling server
     * @param Answer - Answer SDP from the peer.
     */
    handleWebRtcAnswer(Answer) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Got answer sdp ${Answer.sdp}`);
        const sdpAnswer = {
            sdp: Answer.sdp,
            type: 'answer'
        };
        this.peerConnectionController.receiveAnswer(sdpAnswer);
        this.handlePostWebrtcNegotiation();
    }
    /**
     * Handle the RTC offer from a WebRTC peer (received through the signalling server).
     * @param Offer - Offer SDP from the peer.
     */
    handleWebRtcOffer(Offer) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Got offer sdp ${Offer.sdp}`);
        this.isUsingSFU = Offer.sfu ? Offer.sfu : false;
        this.isUsingSVC = Offer.scalabilityMode ? Offer.scalabilityMode != 'L1T1' : false;
        if (this.isUsingSFU || this.isUsingSVC) {
            // Disable negotiating with the sfu as the sfu only supports one codec at a time
            this.peerConnectionController.preferredCodec = '';
        }
        // NOTE: These two settings configurations are done outside of an if(this.isUsingSFU) so that users
        // can switch between a default and SFU stream and have the settings reconfigure appropriately
        const scalabilityMode = Offer.scalabilityMode ? Offer.scalabilityMode : 'L1T1';
        let availableQualities = ['Default'];
        if (this.isUsingSFU) {
            if (!this.isUsingSVC) {
                // User is using an SFU without any temporal scalability. Just offer easily readable names
                availableQualities = ['Low', 'Medium', 'High'];
            }
            else {
                // User is using SVC. Generate all available options.
                availableQualities = [];
                const maxSpatialLayers = +scalabilityMode[1];
                const maxTemporalLayers = +scalabilityMode[3];
                for (let s = 1; s <= maxSpatialLayers; s++) {
                    for (let t = 1; t <= maxTemporalLayers; t++) {
                        availableQualities.push(`S${s}T${t}`);
                    }
                }
            }
        }
        // Update the possible video quality options
        this.config.setOptionSettingOptions(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.PreferredQuality, availableQualities);
        // Update the selected video quality with the highest possible resolution
        this.config.setOptionSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.PreferredQuality, availableQualities.slice(-1)[0]);
        const sdpOffer = {
            sdp: Offer.sdp,
            type: 'offer'
        };
        this.peerConnectionController.receiveOffer(sdpOffer, this.config);
        this.handlePostWebrtcNegotiation();
    }
    /**
     * Handle when the SFU provides the peer with its data channels
     * @param DataChannels - The message from the SFU containing the data channels ids
     */
    handleWebRtcSFUPeerDatachannels(DataChannels) {
        const SendOptions = {
            ordered: true,
            negotiated: true,
            id: DataChannels.sendStreamId
        };
        const unidirectional = DataChannels.sendStreamId != DataChannels.recvStreamId;
        this.sendrecvDataChannelController.createDataChannel(this.peerConnectionController.peerConnection, unidirectional ? 'send-datachannel' : 'datachannel', SendOptions);
        if (unidirectional) {
            const RecvOptions = {
                ordered: true,
                negotiated: true,
                id: DataChannels.recvStreamId
            };
            this.recvDataChannelController.createDataChannel(this.peerConnectionController.peerConnection, 'recv-datachannel', RecvOptions);
            this.recvDataChannelController.handleOnOpen = () => this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.peerDataChannelsReady));
            // If we're uni-directional, only the recv data channel should handle incoming messages
            this.recvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
        }
        else {
            // else our primary datachannel is send/recv so it can handle incoming messages
            this.sendrecvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
        }
    }
    handlePostWebrtcNegotiation() {
        // start the afk warning timer as PS is now running
        this.afkController.startAfkWarningTimer();
        // show the overlay that we have negotiated a connection
        this.pixelStreaming._onWebRtcSdp();
        if (this.statsTimerHandle && this.statsTimerHandle !== undefined) {
            window.clearInterval(this.statsTimerHandle);
        }
        this.statsTimerHandle = window.setInterval(() => this.getStats(), 1000);
        /*  */
        this.setMouseInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.MouseInput));
        this.setKeyboardInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.KeyboardInput));
        this.setGamePadInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.GamepadInput));
    }
    /**
     * Handler for when a remote ICE candidate is received.
     * @param iceCandidateInit - Initialization data used to make the actual ICE Candidate.
     */
    handleIceCandidate(iceCandidateInit) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Remote ICE candidate information received: ${JSON.stringify(iceCandidateInit)}`);
        // We are using "bundle" policy for media lines so we remove the sdpMid and sdpMLineIndex attributes
        // from ICE candidates as these are legacy attributes for when bundle is not used.
        // If we don't do this the browser may be unable to form a media connection
        // because some browsers are brittle if the bundle master (e.g. commonly mid=0) doesn't get a candidate first.
        const remoteIceCandidate = new RTCIceCandidate({
            candidate: iceCandidateInit.candidate,
            sdpMid: ''
        });
        this.peerConnectionController.handleOnIce(remoteIceCandidate);
    }
    /**
     * Send the ice Candidate to the signaling server via websocket
     * @param iceEvent - RTC Peer ConnectionIceEvent) {
     */
    handleSendIceCandidate(iceEvent) {
        if (iceEvent.candidate && iceEvent.candidate.candidate) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Local ICE candidate generated: ` + JSON.stringify(iceEvent.candidate));
            this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.iceCandidate, { candidate: iceEvent.candidate }));
        }
    }
    /**
     * Send the ice Candidate to the signaling server via websocket
     * @param iceEvent - RTC Peer ConnectionIceEvent) {
     */
    handleDataChannel(datachannelEvent) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Data channel created for us by browser as we are a receiving peer.');
        this.sendrecvDataChannelController.dataChannel = datachannelEvent.channel;
        // Data channel was created for us, so we just need to setup its callbacks and array type
        this.sendrecvDataChannelController.setupDataChannel();
        this.sendrecvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
    }
    /**
     * Send the RTC Offer Session to the Signaling server via websocket
     * @param offer - RTC Session Description
     */
    handleSendWebRTCOffer(offer) {
        if (offer.type !== 'offer') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`handleSendWebRTCOffer was called with type ${offer.type} - it only expects "offer"`);
            return;
        }
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Sending the offer to the Server');
        const extraParams = {
            sdp: offer.sdp,
            minBitrateBps: 1000 * this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.WebRTCMinBitrate),
            maxBitrateBps: 1000 * this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.WebRTCMaxBitrate)
        };
        this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.offer, extraParams));
        // Send offer back to Pixel Streaming main class for event dispatch
        this.pixelStreaming._onWebRtcSdpOffer(offer);
    }
    /**
     * Send the RTC Offer Session to the Signaling server via websocket
     * @param answer - RTC Session Description
     */
    handleSendWebRTCAnswer(answer) {
        if (answer.type !== 'answer') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`handleSendWebRTCAnswer was called with type ${answer.type} - it only expects "answer"`);
            return;
        }
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Sending the answer to the Server');
        const extraParams = {
            sdp: answer.sdp,
            minBitrateBps: 1000 * this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.WebRTCMinBitrate),
            maxBitrateBps: 1000 * this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.WebRTCMaxBitrate)
        };
        this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.answer, extraParams));
        if (this.isUsingSFU) {
            this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.dataChannelRequest));
        }
        // Send answer back to Pixel Streaming main class for event dispatch
        this.pixelStreaming._onWebRtcSdpAnswer(answer);
    }
    /**
     * Set the freeze frame overlay to the player div
     */
    setUpMouseAndFreezeFrame() {
        // Calculating and normalizing positions depends on the width and height of the player.
        const playerElement = this.videoPlayer.getVideoParentElement();
        const videoElement = this.videoPlayer.getVideoElement();
        this.coordinateConverter.reconfigure({ width: playerElement.clientWidth, height: playerElement.clientHeight }, { width: videoElement.videoWidth, height: videoElement.videoHeight });
        this.freezeFrameController.freezeFrame.resize();
    }
    /**
     * Close the Connection to the signaling server
     */
    closeSignalingServer(message, allowReconnect) {
        var _a;
        this.locallyClosed = true;
        this.enableAutoReconnect = allowReconnect;
        this.disconnectMessage = message;
        (_a = this.protocol) === null || _a === void 0 ? void 0 : _a.disconnect(1000, message);
    }
    /**
     * Close the peer connection
     */
    closePeerConnection() {
        var _a;
        (_a = this.peerConnectionController) === null || _a === void 0 ? void 0 : _a.close();
    }
    /**
     * Close all connections
     */
    close() {
        this.closeSignalingServer('', false);
        this.closePeerConnection();
    }
    /**
     * Fires a Video Stats Event in the RTC Peer Connection
     */
    getStats() {
        this.peerConnectionController.generateStats();
    }
    /**
     * Send a Latency Test Request to the UE Instance
     */
    sendLatencyTest() {
        this.latencyStartTime = Date.now();
        this.streamMessageController.toStreamerHandlers.get('LatencyTest')([
            JSON.stringify({
                StartTime: this.latencyStartTime
            })
        ]);
    }
    /**
     * Send a Data Channel Latency Test Request to the UE Instance
     */
    sendDataChannelLatencyTest(descriptor) {
        this.streamMessageController.toStreamerHandlers.get('DataChannelLatencyTest')([
            JSON.stringify(descriptor)
        ]);
    }
    /**
     * Send the MinQP encoder setting to the UE Instance.
     * @param minQP - The lower bound for QP when encoding
     * valid values are (1-51) where:
     * 1 = Best quality but highest bitrate.
     * 51 = Worst quality but lowest bitrate.
     * By default the minQP is 1 meaning the encoder is free
     * to aim for the best quality it can on the given network link.
     */
    sendEncoderMinQP(minQP) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`MinQP=${minQP}\n`);
        if (minQP != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MinQP': minQP
                })
            ]);
        }
    }
    /**
     * Send the MaxQP encoder setting to the UE Instance.
     * @param maxQP - The upper bound for QP when encoding
     * valid values are (1-51) where:
     * 1 = Best quality but highest bitrate.
     * 51 = Worst quality but lowest bitrate.
     * By default the maxQP is 51 meaning the encoder is free
     * to drop quality as low as needed on the given network link.
     */
    sendEncoderMaxQP(maxQP) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`MaxQP=${maxQP}\n`);
        if (maxQP != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MaxQP': maxQP
                })
            ]);
        }
    }
    /**
     * Send the MinQuality encoder setting to the UE Instance.
     * @param minQuality - The lower bound for quality when encoding
     * valid values are (0-100) where:
     * 0 = Worst quality.
     * 100 = Best quality.
     */
    sendEncoderMinQuality(minQuality) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`MinQuality=${minQuality}\n`);
        if (minQuality != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MinQuality': minQuality
                })
            ]);
        }
    }
    /**
     * Send the MaxQuality encoder setting to the UE Instance.
     * @param maxQuality - The upper bound for quality when encoding
     * valid values are (0-100) where:
     * 0 = Worst quality.
     * 100 = Best quality.
     */
    sendEncoderMaxQuality(maxQuality) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`MaxQuality=${maxQuality}\n`);
        if (maxQuality != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MaxQuality': maxQuality
                })
            ]);
        }
    }
    /**
     * Send the { WebRTC.MinBitrate: SomeNumber }} command to UE to set
     * the minimum bitrate that we allow WebRTC to use
     * (note setting this too high in poor networks can be problematic).
     * @param minBitrate - The minimum bitrate we would like WebRTC to not fall below.
     */
    sendWebRTCMinBitrate(minBitrate) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`WebRTC Min Bitrate=${minBitrate}`);
        if (minBitrate != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'WebRTC.MinBitrate': minBitrate
                })
            ]);
        }
    }
    /**
     * Send the { WebRTC.MaxBitrate: SomeNumber }} command to UE to set
     * the minimum bitrate that we allow WebRTC to use
     * (note setting this too low could result in blocky video).
     * @param minBitrate - The minimum bitrate we would like WebRTC to not fall below.
     */
    sendWebRTCMaxBitrate(maxBitrate) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`WebRTC Max Bitrate=${maxBitrate}`);
        if (maxBitrate != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'WebRTC.MaxBitrate': maxBitrate
                })
            ]);
        }
    }
    /**
     * Send the { WebRTC.Fps: SomeNumber }} UE 5.0+
     * and { WebRTC.MaxFps } UE 4.27 command to set
     * the maximum fps we would like WebRTC to stream at.
     * @param fps - The maximum stream fps.
     */
    sendWebRTCFps(fps) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`WebRTC FPS=${fps}`);
        if (fps != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({ 'WebRTC.Fps': fps })
            ]);
            /* TODO: Remove when UE 4.27 unsupported. */
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({ 'WebRTC.MaxFps': fps })
            ]);
        }
    }
    /**
     * Sends the UI Descriptor `stat fps` to the UE Instance
     */
    sendShowFps() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending show stat to UE   ----');
        this.streamMessageController.toStreamerHandlers.get('Command')([JSON.stringify({ 'stat.fps': '' })]);
    }
    /**
     * Send an Iframe request to the streamer
     */
    sendIframeRequest() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending Request for an IFrame  ----');
        this.streamMessageController.toStreamerHandlers.get('IFrameRequest')();
    }
    /**
     * Send a UIInteraction message
     */
    emitUIInteraction(descriptor) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending custom UIInteraction message   ----');
        this.streamMessageController.toStreamerHandlers.get('UIInteraction')([JSON.stringify(descriptor)]);
    }
    /**
     * Send a Command message
     */
    emitCommand(descriptor) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending custom Command message   ----');
        this.streamMessageController.toStreamerHandlers.get('Command')([JSON.stringify(descriptor)]);
    }
    /**
     * Send a console command message
     */
    emitConsoleCommand(command) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending custom Command:ConsoleCommand message   ----');
        this.streamMessageController.toStreamerHandlers.get('Command')([
            JSON.stringify({
                ConsoleCommand: command
            })
        ]);
    }
    /**
     * Sends a request to the UE Instance to have ownership of Quality
     */
    sendRequestQualityControlOwnership() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending Request to Control Quality  ----');
        this.toStreamerMessagesController.SendRequestQualityControl();
    }
    /**
     * Send a `TextBoxEntry` message back to UE.
     * @param contents The new contents of the UE side text box.
     */
    sendTextboxEntry(contents) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending TextboxEntry message  ----');
        (_a = this.streamMessageController.toStreamerHandlers.get('TextboxEntry')) === null || _a === void 0 ? void 0 : _a([contents]);
    }
    /**
     * Handles when a Latency Test Result are received from the UE Instance
     * @param message - Latency Test Timings
     */
    handleLatencyTestResult(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.latencyTest');
        const latencyAsString = new TextDecoder('utf-16').decode(message.slice(1));
        const latencyTestResults = new _DataChannel_LatencyTestResults__WEBPACK_IMPORTED_MODULE_24__.LatencyTestResults();
        Object.assign(latencyTestResults, JSON.parse(latencyAsString));
        latencyTestResults.processFields();
        latencyTestResults.testStartTimeMs = this.latencyStartTime;
        latencyTestResults.browserReceiptTimeMs = Date.now();
        latencyTestResults.latencyExcludingDecode = ~~(latencyTestResults.browserReceiptTimeMs - latencyTestResults.testStartTimeMs);
        latencyTestResults.testDuration = ~~(latencyTestResults.TransmissionTimeMs - latencyTestResults.ReceiptTimeMs);
        latencyTestResults.networkLatency = ~~(latencyTestResults.latencyExcludingDecode - latencyTestResults.testDuration);
        if (latencyTestResults.frameDisplayDeltaTimeMs && latencyTestResults.browserReceiptTimeMs) {
            latencyTestResults.endToEndLatency = ~~(latencyTestResults.frameDisplayDeltaTimeMs +
                latencyTestResults.networkLatency,
                +latencyTestResults.CaptureToSendMs);
        }
        this.pixelStreaming._onLatencyTestResult(latencyTestResults);
    }
    /**
     * Handles when a Data Channel Latency Test Response is received from the UE Instance
     * @param message - Data Channel Latency Test Response
     */
    handleDataChannelLatencyTestResponse(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.dataChannelLatencyResponse');
        const responseAsString = new TextDecoder('utf-16').decode(message.slice(1));
        const latencyTestResponse = JSON.parse(responseAsString);
        this.pixelStreaming._onDataChannelLatencyTestResponse(latencyTestResponse);
    }
    /**
     * Handles when the Encoder and Web RTC Settings are received from the UE Instance
     * @param message - Initial Encoder and Web RTC Settings
     */
    handleInitialSettings(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.InitialSettings');
        const payloadAsString = new TextDecoder('utf-16').decode(message.slice(1));
        const parsedInitialSettings = JSON.parse(payloadAsString);
        const initialSettings = new _DataChannel_InitialSettings__WEBPACK_IMPORTED_MODULE_25__.InitialSettings();
        if (parsedInitialSettings.Encoder) {
            initialSettings.EncoderSettings = parsedInitialSettings.Encoder;
        }
        if (parsedInitialSettings.WebRTC) {
            initialSettings.WebRTCSettings = parsedInitialSettings.WebRTC;
        }
        if (parsedInitialSettings.PixelStreaming) {
            initialSettings.PixelStreamingSettings = parsedInitialSettings.PixelStreaming;
        }
        if (parsedInitialSettings.ConfigOptions &&
            parsedInitialSettings.ConfigOptions.DefaultToHover !== undefined) {
            this.config.setFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.HoveringMouseMode, !!parsedInitialSettings.ConfigOptions.DefaultToHover);
        }
        initialSettings.ueCompatible();
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(payloadAsString);
        this.pixelStreaming._onInitialSettings(initialSettings);
    }
    /**
     * Handles when the Quantization Parameter are received from the UE Instance
     * @param message - Encoders Quantization Parameter
     */
    handleVideoEncoderAvgQP(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.VideoEncoderAvgQP');
        const AvgQP = Number(new TextDecoder('utf-16').decode(message.slice(1)));
        this.setVideoEncoderAvgQP(AvgQP);
    }
    /**
     * Handles when the video element has been loaded with a srcObject
     */
    handleVideoInitialized() {
        this.pixelStreaming._onVideoInitialized();
        // either autoplay the video or set up the play overlay
        this.autoPlayVideoOrSetUpPlayOverlay();
        this.resizePlayerStyle();
        this.videoPlayer.updateVideoStreamSize();
    }
    /**
     * Flag set if the user has Quality Ownership
     * @param message - Does the current client have Quality Ownership
     */
    onQualityControlOwnership(message) {
        const view = new Uint8Array(message);
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.QualityControlOwnership');
        this.isQualityController = new Boolean(view[1]).valueOf();
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Received quality controller message, will control quality: ${this.isQualityController}`);
        this.pixelStreaming._onQualityControlOwnership(this.isQualityController);
    }
    /**
     * Handles when the Aggregated stats are Collected
     * @param stats - Aggregated Stats
     */
    handleVideoStats(stats) {
        this.pixelStreaming._onVideoStats(stats);
    }
    /**
     * To Resize the Video Player element
     */
    resizePlayerStyle() {
        this.videoPlayer.resizePlayerStyle();
    }
    setPreferredCodec(codec) {
        this.preferredCodec = codec;
        if (this.peerConnectionController) {
            this.peerConnectionController.preferredCodec = codec;
            this.peerConnectionController.updateCodecSelection = false;
        }
    }
    setVideoEncoderAvgQP(avgQP) {
        this.videoAvgQp = avgQP;
        this.pixelStreaming._onVideoEncoderAvgQP(this.videoAvgQp);
    }
    /**
     * enables/disables keyboard event listeners
     */
    setKeyboardInputEnabled(isEnabled) {
        var _a;
        (_a = this.keyboardController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            this.keyboardController = this.inputClassesFactory.registerKeyBoard(this.config);
        }
    }
    /**
     * enables/disables mouse event listeners
     */
    setMouseInputEnabled(isEnabled) {
        var _a;
        (_a = this.mouseController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            const mouseMode = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.HoveringMouseMode)
                ? _Config_Config__WEBPACK_IMPORTED_MODULE_13__.ControlSchemeType.HoveringMouse
                : _Config_Config__WEBPACK_IMPORTED_MODULE_13__.ControlSchemeType.LockedMouse;
            this.mouseController = this.inputClassesFactory.registerMouse(mouseMode);
        }
    }
    /**
     * enables/disables touch event listeners
     */
    setTouchInputEnabled(isEnabled) {
        var _a;
        (_a = this.touchController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            this.touchController = this.inputClassesFactory.registerTouch(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.FakeMouseWithTouches));
        }
    }
    /**
     * enables/disables game pad event listeners
     */
    setGamePadInputEnabled(isEnabled) {
        var _a;
        (_a = this.gamePadController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            this.gamePadController = this.inputClassesFactory.registerGamePad();
        }
    }
    registerDataChannelEventEmitters(dataChannel) {
        dataChannel.onOpen = (label, event) => this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.DataChannelOpenEvent({ label, event }));
        dataChannel.onClose = (label, event) => this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.DataChannelCloseEvent({ label, event }));
        dataChannel.onError = (label, event) => this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.DataChannelErrorEvent({ label, event }));
    }
    registerMessageHandler(name, direction, handler) {
        if (direction === _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer && typeof handler === 'undefined') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Warning(`Unable to register handler for ${name} as no handler was passed`);
        }
        this.streamMessageController.registerMessageHandler(direction, name, (data) => typeof handler === 'undefined' && direction === _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer
            ? this.sendMessageController.sendMessageToStreamer(name, data)
            : handler(data));
    }
}
//# sourceMappingURL=WebRtcPlayerController.js.map

/***/ }),

/***/ "../../library/dist/esm/WebXR/WebXRController.js":
/*!*******************************************************!*\
  !*** ../../library/dist/esm/WebXR/WebXRController.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebXRController: () => (/* binding */ WebXRController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Inputs_XRGamepadController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Inputs/XRGamepadController */ "../../library/dist/esm/Inputs/XRGamepadController.js");
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Util/EventEmitter */ "../../library/dist/esm/Util/EventEmitter.js");
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
// Copyright Epic Games, Inc. All Rights Reserved.




class WebXRController {
    constructor(webRtcPlayerController) {
        this.xrViewerPose = null;
        // Used for comparisons to ensure two numbers are close enough.
        this.EPSILON = 0.0000001;
        this.videoTexture = null;
        this.prevVideoWidth = 0;
        this.prevVideoHeight = 0;
        this.leftView = null;
        this.rightView = null;
        // Store the HMD data we have last sent (not all of it is needed every frame unless it changes)
        this.lastSentLeftEyeProj = null;
        this.lastSentRightEyeProj = null;
        this.lastSentRelativeLeftEyePos = null;
        this.lastSentRelativeRightEyePos = null;
        this.xrSession = null;
        this.webRtcController = webRtcPlayerController;
        this.xrGamepadController = new _Inputs_XRGamepadController__WEBPACK_IMPORTED_MODULE_0__.XRGamepadController(this.webRtcController.streamMessageController);
        this.onSessionEnded = new EventTarget();
        this.onSessionStarted = new EventTarget();
        this.onFrame = new EventTarget();
    }
    xrClicked() {
        if (!this.xrSession) {
            if (!navigator.xr) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Error('This browser does not support XR.');
                return;
            }
            navigator.xr
                /* Request immersive-vr session without any optional features. */
                .requestSession('immersive-vr', { optionalFeatures: [] })
                .then((session) => {
                this.onXrSessionStarted(session);
            });
        }
        else {
            this.xrSession.end();
        }
    }
    onXrSessionEnded() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('XR Session ended');
        this.xrSession = null;
        this.onSessionEnded.dispatchEvent(new Event('xrSessionEnded'));
    }
    initGL() {
        if (this.gl) {
            return;
        }
        const canvas = document.createElement('canvas');
        this.gl = canvas.getContext('webgl2', {
            xrCompatible: true
        });
        // Set our clear color
        this.gl.clearColor(0.0, 0.0, 0.0, 1);
    }
    initShaders() {
        // shader source code
        const vertexShaderSource = `
        attribute vec2 a_position;
        attribute vec2 a_texCoord;

        // varyings
        varying vec2 v_texCoord;

        void main() {
           gl_Position = vec4(a_position.x, a_position.y, 0, 1);
           // pass the texCoord to the fragment shader
           // The GPU will interpolate this value between points.
           v_texCoord = a_texCoord;
        }
        `;
        const fragmentShaderSource = `
        precision mediump float;

        // our texture
        uniform sampler2D u_image;

        // the texCoords passed in from the vertex shader.
        varying vec2 v_texCoord;

        void main() {
           gl_FragColor = texture2D(u_image, v_texCoord);
        }
        `;
        // setup vertex shader
        const vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
        this.gl.shaderSource(vertexShader, vertexShaderSource);
        this.gl.compileShader(vertexShader);
        // setup fragment shader
        const fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        this.gl.shaderSource(fragmentShader, fragmentShaderSource);
        this.gl.compileShader(fragmentShader);
        // setup GLSL program
        const shaderProgram = this.gl.createProgram();
        this.gl.attachShader(shaderProgram, vertexShader);
        this.gl.attachShader(shaderProgram, fragmentShader);
        this.gl.linkProgram(shaderProgram);
        this.gl.useProgram(shaderProgram);
        // look up where vertex data needs to go
        this.positionLocation = this.gl.getAttribLocation(shaderProgram, 'a_position');
        this.texcoordLocation = this.gl.getAttribLocation(shaderProgram, 'a_texCoord');
    }
    updateVideoTexture() {
        if (!this.videoTexture) {
            // Create our texture that we use in our shader
            // and bind it once because we never use any other texture.
            this.videoTexture = this.gl.createTexture();
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.videoTexture);
            // Set the parameters so we can render any size image.
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        }
        const videoHeight = this.webRtcController.videoPlayer.getVideoElement().videoHeight;
        const videoWidth = this.webRtcController.videoPlayer.getVideoElement().videoWidth;
        if (this.prevVideoHeight != videoHeight || this.prevVideoWidth != videoWidth) {
            // Do full update of texture if dimensions do not match
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, videoWidth, videoHeight, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.webRtcController.videoPlayer.getVideoElement());
        }
        else {
            // If dimensions match just update the sub region
            this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, 0, 0, videoWidth, videoHeight, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.webRtcController.videoPlayer.getVideoElement());
        }
        // Update prev video width/height
        this.prevVideoHeight = videoHeight;
        this.prevVideoWidth = videoWidth;
    }
    initBuffers() {
        // Create out position buffer and its vertex shader attribute
        {
            // Create a buffer to put the the vertices of the plane we will draw the video stream onto
            this.positionBuffer = this.gl.createBuffer();
            // Bind the position buffer
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
            // Enable `positionLocation` to be used as vertex shader attribute
            this.gl.enableVertexAttribArray(this.positionLocation);
            // Note: positions are passed in clip-space coordinates [-1..1] so no need to convert in-shader
            // prettier-ignore
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([
                -1.0, 1.0,
                1.0, 1.0,
                -1.0, -1.0,
                -1.0, -1.0,
                1.0, 1.0,
                1.0, -1.0
            ]), this.gl.STATIC_DRAW);
            // Tell position attribute of the vertex shader how to get data out of the bound buffer (the positionBuffer)
            this.gl.vertexAttribPointer(this.positionLocation, 2 /*size*/, this.gl.FLOAT /*type*/, false /*normalize*/, 0 /*stride*/, 0 /*offset*/);
        }
        // Create our texture coordinate buffers for accessing our texture
        {
            this.texcoordBuffer = this.gl.createBuffer();
            // Bind the texture coordinate buffer
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texcoordBuffer);
            // Enable `texcoordLocation` to be used as a vertex shader attribute
            this.gl.enableVertexAttribArray(this.texcoordLocation);
            // The texture coordinates to apply for rectangle we are drawing
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), this.gl.STATIC_DRAW);
            // Tell texture coordinate attribute of the vertex shader how to get data out of the bound buffer (the texcoordBuffer)
            this.gl.vertexAttribPointer(this.texcoordLocation, 2 /*size*/, this.gl.FLOAT /*type*/, false /*normalize*/, 0 /*stride*/, 0 /*offset*/);
        }
    }
    onXrSessionStarted(session) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('XR Session started');
        this.xrSession = session;
        this.xrSession.addEventListener('end', () => {
            this.onXrSessionEnded();
        });
        // Initialization
        this.initGL();
        this.initShaders();
        this.initBuffers();
        session.requestReferenceSpace('local').then((refSpace) => {
            this.xrRefSpace = refSpace;
            // Set up our base layer (i.e. a projection layer that fills the entire XR viewport).
            this.xrSession.updateRenderState({
                baseLayer: new XRWebGLLayer(this.xrSession, this.gl)
            });
            // Update target framerate to 90 fps if 90 fps is supported in this XR device
            if (this.xrSession.supportedFrameRates) {
                for (const frameRate of this.xrSession.supportedFrameRates) {
                    if (frameRate == 90) {
                        session.updateTargetFrameRate(90);
                    }
                }
            }
            // Binding to each new frame to get latest XR updates
            this.xrSession.requestAnimationFrame(this.onXrFrame.bind(this));
        });
        this.onSessionStarted.dispatchEvent(new Event('xrSessionStarted'));
    }
    areArraysEqual(a, b) {
        return (a.length === b.length && a.every((element, index) => Math.abs(element - b[index]) <= this.EPSILON));
    }
    arePointsEqual(a, b) {
        return (Math.abs(a.x - b.x) >= this.EPSILON &&
            Math.abs(a.y - b.y) >= this.EPSILON &&
            Math.abs(a.z - b.z) >= this.EPSILON);
    }
    sendXRDataToUE() {
        if (this.leftView == null || this.rightView == null) {
            return;
        }
        // We selectively send either the `XREyeViews` or `XRHMDTransform`
        // messages over the datachannel. The reason for this selective sending is that
        // the `XREyeViews` is a much larger message and changes infrequently (e.g. only when user changes headset IPD).
        // Therefore, we only need to send it once on startup and then any time it changes.
        // The rest of the time we can send the `XRHMDTransform` message.
        let shouldSendEyeViews = this.lastSentLeftEyeProj == null ||
            this.lastSentRightEyeProj == null ||
            this.lastSentRelativeLeftEyePos == null ||
            this.lastSentRelativeRightEyePos == null;
        const leftEyeTrans = this.leftView.transform.matrix;
        const leftEyeProj = this.leftView.projectionMatrix;
        const rightEyeTrans = this.rightView.transform.matrix;
        const rightEyeProj = this.rightView.projectionMatrix;
        const hmdTrans = this.xrViewerPose.transform.matrix;
        // Check if projection matrices have changed
        if (!shouldSendEyeViews && this.lastSentLeftEyeProj != null && this.lastSentRightEyeProj != null) {
            const leftEyeProjUnchanged = this.areArraysEqual(leftEyeProj, this.lastSentLeftEyeProj);
            const rightEyeProjUnchanged = this.areArraysEqual(rightEyeProj, this.lastSentRightEyeProj);
            shouldSendEyeViews = leftEyeProjUnchanged == false || rightEyeProjUnchanged == false;
        }
        const leftEyeRelativePos = new DOMPointReadOnly(this.leftView.transform.position.x - this.xrViewerPose.transform.position.x, this.leftView.transform.position.y - this.xrViewerPose.transform.position.y, this.leftView.transform.position.z - this.xrViewerPose.transform.position.z, 1.0);
        const rightEyeRelativePos = new DOMPointReadOnly(this.leftView.transform.position.x - this.xrViewerPose.transform.position.x, this.leftView.transform.position.y - this.xrViewerPose.transform.position.y, this.leftView.transform.position.z - this.xrViewerPose.transform.position.z, 1.0);
        // Check if relative eye pos has changed (e.g IPD changed)
        if (!shouldSendEyeViews &&
            this.lastSentRelativeLeftEyePos != null &&
            this.lastSentRelativeRightEyePos != null) {
            const leftEyePosUnchanged = this.arePointsEqual(leftEyeRelativePos, this.lastSentRelativeLeftEyePos);
            const rightEyePosUnchanged = this.arePointsEqual(rightEyeRelativePos, this.lastSentRelativeRightEyePos);
            shouldSendEyeViews = leftEyePosUnchanged == false || rightEyePosUnchanged == false;
            // Note: We are not checking if EyeView rotation changes (as far as I know no HMD supports changing this value at runtime).
        }
        if (shouldSendEyeViews) {
            // send transform (4x4) and projection matrix (4x4) data for each eye (left first, then right)
            // prettier-ignore
            this.webRtcController.streamMessageController.toStreamerHandlers.get('XREyeViews')([
                // Left eye 4x4 transform matrix
                leftEyeTrans[0], leftEyeTrans[4], leftEyeTrans[8], leftEyeTrans[12],
                leftEyeTrans[1], leftEyeTrans[5], leftEyeTrans[9], leftEyeTrans[13],
                leftEyeTrans[2], leftEyeTrans[6], leftEyeTrans[10], leftEyeTrans[14],
                leftEyeTrans[3], leftEyeTrans[7], leftEyeTrans[11], leftEyeTrans[15],
                // Left eye 4x4 projection matrix
                leftEyeProj[0], leftEyeProj[4], leftEyeProj[8], leftEyeProj[12],
                leftEyeProj[1], leftEyeProj[5], leftEyeProj[9], leftEyeProj[13],
                leftEyeProj[2], leftEyeProj[6], leftEyeProj[10], leftEyeProj[14],
                leftEyeProj[3], leftEyeProj[7], leftEyeProj[11], leftEyeProj[15],
                // Right eye 4x4 transform matrix
                rightEyeTrans[0], rightEyeTrans[4], rightEyeTrans[8], rightEyeTrans[12],
                rightEyeTrans[1], rightEyeTrans[5], rightEyeTrans[9], rightEyeTrans[13],
                rightEyeTrans[2], rightEyeTrans[6], rightEyeTrans[10], rightEyeTrans[14],
                rightEyeTrans[3], rightEyeTrans[7], rightEyeTrans[11], rightEyeTrans[15],
                // right eye 4x4 projection matrix
                rightEyeProj[0], rightEyeProj[4], rightEyeProj[8], rightEyeProj[12],
                rightEyeProj[1], rightEyeProj[5], rightEyeProj[9], rightEyeProj[13],
                rightEyeProj[2], rightEyeProj[6], rightEyeProj[10], rightEyeProj[14],
                rightEyeProj[3], rightEyeProj[7], rightEyeProj[11], rightEyeProj[15],
                // HMD 4x4 transform
                hmdTrans[0], hmdTrans[4], hmdTrans[8], hmdTrans[12],
                hmdTrans[1], hmdTrans[5], hmdTrans[9], hmdTrans[13],
                hmdTrans[2], hmdTrans[6], hmdTrans[10], hmdTrans[14],
                hmdTrans[3], hmdTrans[7], hmdTrans[11], hmdTrans[15],
            ]);
            this.lastSentLeftEyeProj = leftEyeProj;
            this.lastSentRightEyeProj = rightEyeProj;
            this.lastSentRelativeLeftEyePos = leftEyeRelativePos;
            this.lastSentRelativeRightEyePos = rightEyeRelativePos;
        }
        else {
            // If we don't need to the entire eye views being sent just send the HMD transform
            this.webRtcController.streamMessageController.toStreamerHandlers.get('XRHMDTransform')([
                // HMD 4x4 transform
                hmdTrans[0],
                hmdTrans[4],
                hmdTrans[8],
                hmdTrans[12],
                hmdTrans[1],
                hmdTrans[5],
                hmdTrans[9],
                hmdTrans[13],
                hmdTrans[2],
                hmdTrans[6],
                hmdTrans[10],
                hmdTrans[14],
                hmdTrans[3],
                hmdTrans[7],
                hmdTrans[11],
                hmdTrans[15]
            ]);
        }
    }
    onXrFrame(time, frame) {
        this.xrViewerPose = frame.getViewerPose(this.xrRefSpace);
        if (this.xrViewerPose) {
            this.updateViews();
            if (this.leftView == null || this.rightView == null) {
                return;
            }
            this.sendXRDataToUE();
            this.updateVideoTexture();
            this.render();
        }
        if (this.webRtcController.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.XRControllerInput)) {
            this.xrSession.inputSources.forEach((source, _index, _array) => {
                this.xrGamepadController.updateStatus(source, frame, this.xrRefSpace);
            }, this);
        }
        this.xrSession.requestAnimationFrame((time, frame) => this.onXrFrame(time, frame));
        this.onFrame.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_3__.XrFrameEvent({ time, frame }));
    }
    updateViews() {
        if (!this.xrViewerPose) {
            return;
        }
        for (const view of this.xrViewerPose.views) {
            if (view.eye === 'left') {
                this.leftView = view;
            }
            else if (view.eye === 'right') {
                this.rightView = view;
            }
        }
    }
    render() {
        if (!this.gl) {
            return;
        }
        // Bind the framebuffer to the base layer's framebuffer
        const glLayer = this.xrSession.renderState.baseLayer;
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, glLayer.framebuffer);
        // Set the relevant portion of clip space
        this.gl.viewport(0, 0, glLayer.framebufferWidth, glLayer.framebufferHeight);
        // Draw the rectangle we will show the video stream texture on
        this.gl.drawArrays(this.gl.TRIANGLES /*primitiveType*/, 0 /*offset*/, 6 /*count*/);
    }
    static isSessionSupported(mode) {
        if (location.protocol !== 'https:') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('WebXR requires https, if you want WebXR use https.');
        }
        if (navigator.xr) {
            return navigator.xr.isSessionSupported(mode);
        }
        else {
            return new Promise(() => {
                return false;
            });
        }
    }
}
//# sourceMappingURL=WebXRController.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Application/Application.js":
/*!************************************************************!*\
  !*** ../../ui-library/dist/esm/Application/Application.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Application: () => (/* binding */ Application)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Overlay_ConnectOverlay__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Overlay/ConnectOverlay */ "../../ui-library/dist/esm/Overlay/ConnectOverlay.js");
/* harmony import */ var _Overlay_DisconnectOverlay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Overlay/DisconnectOverlay */ "../../ui-library/dist/esm/Overlay/DisconnectOverlay.js");
/* harmony import */ var _Overlay_PlayOverlay__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Overlay/PlayOverlay */ "../../ui-library/dist/esm/Overlay/PlayOverlay.js");
/* harmony import */ var _Overlay_InfoOverlay__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Overlay/InfoOverlay */ "../../ui-library/dist/esm/Overlay/InfoOverlay.js");
/* harmony import */ var _Overlay_ErrorOverlay__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Overlay/ErrorOverlay */ "../../ui-library/dist/esm/Overlay/ErrorOverlay.js");
/* harmony import */ var _Overlay_AFKOverlay__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../Overlay/AFKOverlay */ "../../ui-library/dist/esm/Overlay/AFKOverlay.js");
/* harmony import */ var _UI_Controls__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../UI/Controls */ "../../ui-library/dist/esm/UI/Controls.js");
/* harmony import */ var _UI_LabelledButton__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../UI/LabelledButton */ "../../ui-library/dist/esm/UI/LabelledButton.js");
/* harmony import */ var _UI_SettingsPanel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../UI/SettingsPanel */ "../../ui-library/dist/esm/UI/SettingsPanel.js");
/* harmony import */ var _UI_StatsPanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../UI/StatsPanel */ "../../ui-library/dist/esm/UI/StatsPanel.js");
/* harmony import */ var _UI_VideoQpIndicator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../UI/VideoQpIndicator */ "../../ui-library/dist/esm/UI/VideoQpIndicator.js");
/* harmony import */ var _Config_ConfigUI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Config/ConfigUI */ "../../ui-library/dist/esm/Config/ConfigUI.js");
/* harmony import */ var _UI_EditTextModal__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../UI/EditTextModal */ "../../ui-library/dist/esm/UI/EditTextModal.js");
/* harmony import */ var _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UI/UIConfigurationTypes */ "../../ui-library/dist/esm/UI/UIConfigurationTypes.js");
/* harmony import */ var _UI_FullscreenIcon__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../UI/FullscreenIcon */ "../../ui-library/dist/esm/UI/FullscreenIcon.js");
// Copyright Epic Games, Inc. All Rights Reserved.
















/**
 * An Application is a combination of UI elements to display and manage a WebRTC Pixel Streaming
 * connection. It includes features for controlling a stream with mouse and keyboard,
 * managing connection endpoints, as well as displaying stats and other information about it.
 */
class Application {
    /**
     * @param options - Initialization options
     */
    constructor(options) {
        this.editTextModal = null;
        this._options = options;
        this.stream = options.stream;
        // Explicitly create ui features now so creation time is known
        this._uiFeatureElement = this.createUIFeaturesElement();
        // Explicitly create root element now so creation time is known
        this._rootElement = this.createRootElement(this.stream, this._uiFeatureElement);
        this.onColorModeChanged = options.onColorModeChanged;
        this.configUI = new _Config_ConfigUI__WEBPACK_IMPORTED_MODULE_0__.ConfigUI(this.stream.config);
        this.createOverlays();
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.isPanelEnabled)(options.statsPanelConfig)) {
            // Add stats panel
            this.statsPanel = new _UI_StatsPanel__WEBPACK_IMPORTED_MODULE_2__.StatsPanel(options.statsPanelConfig, this.stream.config);
            this.uiFeaturesElement.appendChild(this.statsPanel.rootElement);
        }
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.isPanelEnabled)(options.settingsPanelConfig)) {
            // Add settings panel
            this.settingsPanel = new _UI_SettingsPanel__WEBPACK_IMPORTED_MODULE_3__.SettingsPanel();
            this.uiFeaturesElement.appendChild(this.settingsPanel.rootElement);
            this.configureSettings();
        }
        if (!options.videoQpIndicatorConfig || !options.videoQpIndicatorConfig.disableIndicator) {
            // Add the video stream QP indicator
            this.videoQpIndicator = new _UI_VideoQpIndicator__WEBPACK_IMPORTED_MODULE_4__.VideoQpIndicator(options.videoQpIndicatorConfig);
            this.uiFeaturesElement.appendChild(this.videoQpIndicator.rootElement);
        }
        this.createButtons();
        this.registerCallbacks();
        this.showConnectOrAutoConnectOverlays();
        this.setColorMode(this.configUI.isCustomFlagEnabled(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.ExtraFlags.LightMode));
        this.stream.config._addOnSettingChangedListener(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Flags.HideUI, (isEnabled) => {
            this._uiFeatureElement.style.visibility = isEnabled ? 'hidden' : 'visible';
        });
        if (this.stream.config.isFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Flags.HideUI)) {
            this._uiFeatureElement.style.visibility = 'hidden';
        }
    }
    createOverlays() {
        // build all of the overlays
        this.disconnectOverlay = new _Overlay_DisconnectOverlay__WEBPACK_IMPORTED_MODULE_6__.DisconnectOverlay(this.stream.videoElementParent);
        this.connectOverlay = new _Overlay_ConnectOverlay__WEBPACK_IMPORTED_MODULE_7__.ConnectOverlay(this.stream.videoElementParent);
        this.playOverlay = new _Overlay_PlayOverlay__WEBPACK_IMPORTED_MODULE_8__.PlayOverlay(this.stream.videoElementParent);
        this.infoOverlay = new _Overlay_InfoOverlay__WEBPACK_IMPORTED_MODULE_9__.InfoOverlay(this.stream.videoElementParent);
        this.errorOverlay = new _Overlay_ErrorOverlay__WEBPACK_IMPORTED_MODULE_10__.ErrorOverlay(this.stream.videoElementParent);
        this.afkOverlay = new _Overlay_AFKOverlay__WEBPACK_IMPORTED_MODULE_11__.AFKOverlay(this.stream.videoElementParent);
        this.disconnectOverlay.onAction(() => this.stream.reconnect());
        // Build the webRtc connect overlay Event Listener and show the connect overlay
        this.connectOverlay.onAction(() => this.stream.connect());
        // set up the play overlays action
        this.playOverlay.onAction(() => this.stream.play());
    }
    /**
     * Set up button click functions and button functionality
     */
    createButtons() {
        const isIphone = /iPhone/.test(navigator.userAgent);
        const isIpad = /iPad/.test(navigator.userAgent) ||
            (/Macintosh/.test(navigator.userAgent) && 'ontouchend' in document);
        const isSafari = navigator.vendor &&
            navigator.vendor.indexOf('Apple') > -1 &&
            navigator.userAgent &&
            navigator.userAgent.indexOf('CriOS') == -1 &&
            navigator.userAgent.indexOf('FxiOS') == -1;
        // In some cases we want to disable fullscreen button if it is not explicitly requested:
        // IPhone does not support fullscreen API as at 28th July 2024 (see: https://caniuse.com/fullscreen) so if
        // we are on IPhone and user has not specified explicitly configured UI config for
        // fullscreen button then we should disable this button as it doesn't work.
        // Additionally iPad on non-Safari browsers doesn't really allow touch inputs and fullscreen video at the same time.
        // If you do this the video gets dragged off back to normal non-fullscreen video and then the video is paused.
        // See: https://github.com/EpicGamesExt/PixelStreamingInfrastructure/issues/219
        const disableFullscreenButton = isIphone || (!isSafari && isIpad);
        if (this._options.fullScreenControlsConfig === undefined && disableFullscreenButton) {
            this._options.fullScreenControlsConfig = { creationMode: _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.UIElementCreationMode.Disable };
        }
        const controlsUIConfig = {
            statsButtonType: this._options.statsPanelConfig
                ? this._options.statsPanelConfig.visibilityButtonConfig
                : undefined,
            settingsButtonType: this._options.settingsPanelConfig
                ? this._options.settingsPanelConfig.visibilityButtonConfig
                : undefined,
            fullscreenButtonType: this._options.fullScreenControlsConfig,
            xrIconType: this._options.xrControlsConfig,
            hideControlsInFullscreen: this._options.hideControlsInFullscreen
        };
        // Setup controls
        const controls = new _UI_Controls__WEBPACK_IMPORTED_MODULE_12__.Controls(controlsUIConfig);
        this.uiFeaturesElement.appendChild(controls.rootElement);
        // When we fullscreen we want this element to be the root
        const fullScreenButton = 
        // Depending on if we're creating an internal button, or using an external one
        !!this._options.fullScreenControlsConfig &&
            this._options.fullScreenControlsConfig.creationMode === _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.UIElementCreationMode.UseCustomElement
            ? // Either create a fullscreen class based on the external button
                new _UI_FullscreenIcon__WEBPACK_IMPORTED_MODULE_13__.FullScreenIconExternal(this._options.fullScreenControlsConfig.customElement)
            : // Or use the one created by the Controls initializer earlier
                controls.fullscreenIcon;
        if (fullScreenButton) {
            fullScreenButton.fullscreenElement = /iPad|iPhone|iPod/.test(navigator.userAgent)
                ? this.stream.videoElementParent.getElementsByTagName('video')[0]
                : this.rootElement;
        }
        // Add settings button to controls
        const settingsButton = controls.settingsIcon
            ? controls.settingsIcon.rootElement
            : this._options.settingsPanelConfig.visibilityButtonConfig.customElement;
        if (settingsButton)
            settingsButton.onclick = () => this.settingsClicked();
        if (this.settingsPanel)
            this.settingsPanel.settingsCloseButton.onclick = () => this.settingsClicked();
        // Add WebXR button to controls
        const xrButton = controls.xrIcon
            ? controls.xrIcon.rootElement
            : this._options.xrControlsConfig.creationMode === _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.UIElementCreationMode.UseCustomElement
                ? this._options.xrControlsConfig.customElement
                : undefined;
        if (xrButton)
            xrButton.onclick = () => this.stream.toggleXR();
        // setup the stats/info button
        const statsButton = controls.statsIcon
            ? controls.statsIcon.rootElement
            : this._options.statsPanelConfig.visibilityButtonConfig.customElement;
        if (statsButton)
            statsButton.onclick = () => this.statsClicked();
        if (this.statsPanel) {
            this.statsPanel.statsCloseButton.onclick = () => this.statsClicked();
        }
        // Add command buttons (if we have somewhere to add them to)
        if (this.settingsPanel) {
            // Add button for toggle fps
            const showFPSButton = new _UI_LabelledButton__WEBPACK_IMPORTED_MODULE_14__.LabelledButton('Show FPS', 'Toggle');
            showFPSButton.addOnClickListener(() => {
                this.stream.requestShowFps();
            });
            // Add button for restart stream
            const restartStreamButton = new _UI_LabelledButton__WEBPACK_IMPORTED_MODULE_14__.LabelledButton('Restart Stream', 'Restart');
            restartStreamButton.addOnClickListener(() => {
                this.stream.reconnect();
            });
            // Add button for request keyframe
            const requestKeyframeButton = new _UI_LabelledButton__WEBPACK_IMPORTED_MODULE_14__.LabelledButton('Request keyframe', 'Request');
            requestKeyframeButton.addOnClickListener(() => {
                this.stream.requestIframe();
            });
            const commandsSectionElem = this.configUI.buildSectionWithHeading(this.settingsPanel.settingsContentElement, 'Commands');
            commandsSectionElem.appendChild(showFPSButton.rootElement);
            commandsSectionElem.appendChild(requestKeyframeButton.rootElement);
            commandsSectionElem.appendChild(restartStreamButton.rootElement);
        }
    }
    /**
     * Configure the settings with on change listeners and any additional per experience settings.
     */
    configureSettings() {
        // This builds all the settings sections and flags under this `settingsContent` element.
        this.configUI.populateSettingsElement(this.settingsPanel.settingsContentElement, this._options.settingsPanelConfig);
        this.configUI.addCustomFlagOnSettingChangedListener(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.ExtraFlags.LightMode, (isLightMode) => {
            this.configUI.setCustomFlagLabel(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.ExtraFlags.LightMode, `Color Scheme: ${isLightMode ? 'Light' : 'Dark'} Mode`);
            this.setColorMode(isLightMode);
        });
    }
    registerCallbacks() {
        this.stream.addEventListener('afkWarningActivate', ({ data: { countDown, dismissAfk } }) => this.showAfkOverlay(countDown, dismissAfk));
        this.stream.addEventListener('afkWarningUpdate', ({ data: { countDown } }) => this.afkOverlay.updateCountdown(countDown));
        this.stream.addEventListener('afkWarningDeactivate', () => this.afkOverlay.hide());
        this.stream.addEventListener('afkTimedOut', () => this.afkOverlay.hide());
        this.stream.addEventListener('videoEncoderAvgQP', ({ data: { avgQP } }) => this.onVideoEncoderAvgQP(avgQP));
        this.stream.addEventListener('webRtcSdp', () => this.onWebRtcSdp());
        this.stream.addEventListener('webRtcAutoConnect', () => this.onWebRtcAutoConnect());
        this.stream.addEventListener('webRtcConnecting', () => this.onWebRtcConnecting());
        this.stream.addEventListener('webRtcConnected', () => this.onWebRtcConnected());
        this.stream.addEventListener('webRtcFailed', () => this.onWebRtcFailed());
        this.stream.addEventListener('webRtcDisconnected', ({ data: { eventString, allowClickToReconnect } }) => this.onDisconnect(eventString, allowClickToReconnect));
        this.stream.addEventListener('videoInitialized', () => this.onVideoInitialized());
        this.stream.addEventListener('streamLoading', () => this.onStreamLoading());
        this.stream.addEventListener('playStreamError', ({ data: { message } }) => this.onPlayStreamError(message));
        this.stream.addEventListener('playStream', () => this.onPlayStream());
        this.stream.addEventListener('playStreamRejected', ({ data: { reason } }) => this.onPlayStreamRejected(reason));
        this.stream.addEventListener('loadFreezeFrame', ({ data: { shouldShowPlayOverlay } }) => this.onLoadFreezeFrame(shouldShowPlayOverlay));
        this.stream.addEventListener('statsReceived', ({ data: { aggregatedStats } }) => this.onStatsReceived(aggregatedStats));
        this.stream.addEventListener('latencyCalculated', ({ data: { latencyInfo } }) => this.onLatencyUpdate(latencyInfo));
        this.stream.addEventListener('latencyTestResult', ({ data: { latencyTimings } }) => this.onLatencyTestResults(latencyTimings));
        this.stream.addEventListener('dataChannelLatencyTestResult', ({ data: { result } }) => this.onDataChannelLatencyTestResults(result));
        this.stream.addEventListener('streamerListMessage', ({ data: { messageStreamerList, autoSelectedStreamerId, wantedStreamerId } }) => this.handleStreamerListMessage(messageStreamerList, autoSelectedStreamerId, wantedStreamerId));
        this.stream.addEventListener('subscribeFailed', ({ data: { message } }) => this.handleSubscribeFailedMessage(message));
        this.stream.addEventListener('settingsChanged', (event) => this.onSettingsChanged(event));
        this.stream.addEventListener('playerCount', ({ data: { count } }) => this.onPlayerCount(count));
        this.stream.addEventListener('webRtcTCPRelayDetected', () => _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Warning(`Stream quailty degraded due to network enviroment, stream is relayed over TCP.`));
        this.stream.addEventListener('showOnScreenKeyboard', (event) => {
            // Only show the edit text modal if the flag is enabled
            if (!this.stream.config.isFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Flags.UseModalForTextInput)) {
                return;
            }
            const evtData = event.data;
            if (evtData.showOnScreenKeyboard) {
                this.showEditTextModal(evtData.contents);
            }
        });
    }
    /**
     * Gets the rootElement of the application, video stream and all UI are children of this element.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = this.createRootElement(this.stream, this.uiFeaturesElement);
        }
        return this._rootElement;
    }
    /**
     * Creates the root element for the Pixel Streaming UI.
     * Note: This should be called before the Pixel Streaming object is created.
     * @param pixelstreaming - The Pixel Streaming object.
     * @param uiFeaturesElem - The element holding all the custom UI features.
     * @returns A div with the id #playerUI populated with videoElementParent and uiFeatureElement.
     */
    createRootElement(pixelstreaming, uiFeaturesElem) {
        const elem = document.createElement('div');
        elem.id = 'playerUI';
        elem.classList.add('noselect');
        if (pixelstreaming === undefined) {
            throw new Error('Could not create root element properly - pixelstreaming object was undefined. Are you calling this too early?');
        }
        if (pixelstreaming.videoElementParent === undefined) {
            throw new Error('Could not create root element properly - videoElementParent object was undefined. Are you calling this too early?');
        }
        if (uiFeaturesElem === undefined) {
            throw new Error('Could not create root element properly - uiFeaturesElement object was undefined. Are you calling this too early?');
        }
        elem.appendChild(pixelstreaming.videoElementParent);
        elem.appendChild(uiFeaturesElem);
        return elem;
    }
    /**
     * Gets the element that contains all the UI features, like the stats and settings panels.
     */
    get uiFeaturesElement() {
        if (!this._uiFeatureElement) {
            this._uiFeatureElement = this.createUIFeaturesElement();
        }
        return this._uiFeatureElement;
    }
    /**
     * Creates the UI features element for holding all the custom UI features.
     * @returns A div with the id #uiFeatures.
     */
    createUIFeaturesElement() {
        const elem = document.createElement('div');
        elem.id = 'uiFeatures';
        return elem;
    }
    /**
     * Shows the disconnect overlay
     * @param updateText - the text that will be displayed in the overlay
     */
    showDisconnectOverlay(updateText) {
        this.hideCurrentOverlay();
        this.updateDisconnectOverlay(updateText);
        this.disconnectOverlay.show();
        this.currentOverlay = this.disconnectOverlay;
    }
    /**
     * Update the disconnect overlays span text
     * @param updateText - the new countdown number
     */
    updateDisconnectOverlay(updateText) {
        this.disconnectOverlay.update(updateText);
    }
    /**
     * Activates the disconnect overlays action
     */
    onDisconnectionAction() {
        this.disconnectOverlay.activate();
    }
    /**
     * Hides the current overlay
     */
    hideCurrentOverlay() {
        if (this.currentOverlay != null) {
            this.currentOverlay.hide();
            this.currentOverlay = null;
        }
    }
    /**
     * Shows the connect overlay
     */
    showConnectOverlay() {
        this.hideCurrentOverlay();
        this.connectOverlay.show();
        this.currentOverlay = this.connectOverlay;
    }
    /**
     * Shows the play overlay
     */
    showPlayOverlay() {
        this.hideCurrentOverlay();
        this.playOverlay.show();
        this.currentOverlay = this.playOverlay;
    }
    /**
     * Shows the text overlay
     * @param text - the text that will be shown in the overlay
     */
    showTextOverlay(text) {
        this.hideCurrentOverlay();
        this.infoOverlay.update(text);
        this.infoOverlay.show();
        this.currentOverlay = this.infoOverlay;
    }
    /**
     * Shows the error overlay
     * @param text - the text that will be shown in the overlay
     */
    showErrorOverlay(text) {
        this.hideCurrentOverlay();
        this.errorOverlay.update(text);
        this.errorOverlay.show();
        this.currentOverlay = this.errorOverlay;
    }
    /**
     * Shows or hides the settings panel if clicked
     */
    settingsClicked() {
        var _a;
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.hide();
        this.settingsPanel.toggleVisibility();
    }
    /**
     * Shows or hides the stats panel if clicked
     */
    statsClicked() {
        var _a;
        (_a = this.settingsPanel) === null || _a === void 0 ? void 0 : _a.hide();
        this.statsPanel.toggleVisibility();
    }
    /**
     * Activates the connect overlays action
     */
    onConnectAction() {
        this.connectOverlay.activate();
    }
    /**
     * Activates the play overlays action
     */
    onPlayAction() {
        this.playOverlay.activate();
    }
    /**
     * Shows the afk overlay
     * @param countDown - the countdown number for the afk countdown
     */
    showAfkOverlay(countDown, dismissAfk) {
        this.hideCurrentOverlay();
        this.afkOverlay.updateCountdown(countDown);
        this.afkOverlay.onAction(() => dismissAfk());
        this.afkOverlay.show();
        this.currentOverlay = this.afkOverlay;
    }
    /**
     * Show the Connect Overlay or auto connect
     */
    showConnectOrAutoConnectOverlays() {
        // set up if the auto play will be used or regular click to start
        if (!this.stream.config.isFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Flags.AutoConnect)) {
            this.showConnectOverlay();
        }
    }
    /**
     * Show the webRtcAutoConnect Overlay and connect
     */
    onWebRtcAutoConnect() {
        this.showTextOverlay('Auto Connecting Now');
    }
    /**
     * Set up functionality to happen when receiving a webRTC answer
     */
    onWebRtcSdp() {
        this.showTextOverlay('WebRTC Connection Negotiated');
    }
    /**
     * Shows a text overlay to alert the user the stream is currently loading
     */
    onStreamLoading() {
        // build the spinner span
        const spinnerSpan = document.createElement('span');
        spinnerSpan.className = 'visually-hidden';
        spinnerSpan.innerHTML = 'Loading...';
        // build the spinner div
        const spinnerDiv = document.createElement('div');
        spinnerDiv.id = 'loading-spinner';
        spinnerDiv.className = 'spinner-border ms-2';
        spinnerDiv.setAttribute('role', 'status');
        // append the spinner to the element
        spinnerDiv.appendChild(spinnerSpan);
        this.showTextOverlay('Loading Stream ' + spinnerDiv.outerHTML);
    }
    /**
     * Event fired when the video is disconnected - displays the error overlay and resets the buttons stream tools upon disconnect
     * @param eventString - the event text that will be shown in the overlay
     * @param allowClickToReconnect - true if we want to allow the user to click to reconnect. Otherwise it's just a message.
     */
    onDisconnect(eventString, allowClickToReconnect) {
        var _a;
        const overlayMessage = 'Disconnected' + (eventString ? `: ${eventString}` : '.');
        if (allowClickToReconnect) {
            this.showDisconnectOverlay(`${overlayMessage} Click To Restart.`);
        }
        else {
            this.showErrorOverlay(overlayMessage);
        }
        // disable starting a latency checks
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.onDisconnect();
    }
    /**
     * Handles when Web Rtc is connecting
     */
    onWebRtcConnecting() {
        this.showTextOverlay('Starting connection to server, please wait');
    }
    /**
     * Handles when Web Rtc has connected
     */
    onWebRtcConnected() {
        this.showTextOverlay('WebRTC connected, waiting for video');
    }
    /**
     * Handles when Web Rtc fails to connect
     */
    onWebRtcFailed() {
        this.showErrorOverlay('Unable to setup video');
    }
    onLoadFreezeFrame(shouldShowPlayOverlay) {
        if (shouldShowPlayOverlay === true) {
            _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('showing play overlay');
            this.showPlayOverlay();
        }
    }
    onPlayStream() {
        this.hideCurrentOverlay();
    }
    onPlayStreamError(message) {
        this.showErrorOverlay(message);
    }
    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
    onPlayStreamRejected(onRejectedReason) {
        this.showPlayOverlay();
    }
    onVideoInitialized() {
        var _a;
        if (!this.stream.config.isFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Flags.AutoPlayVideo)) {
            this.showPlayOverlay();
        }
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.onVideoInitialized(this.stream);
    }
    /**
     * Set up functionality to happen when calculating the average video encoder qp
     * @param QP - the quality number of the stream
     */
    onVideoEncoderAvgQP(QP) {
        // Update internal QP indicator if one is present
        if (this.videoQpIndicator) {
            this.videoQpIndicator.updateQpTooltip(QP);
        }
    }
    onInitialSettings(settings) {
        var _a;
        if (settings.PixelStreamingSettings) {
            (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.configure(settings.PixelStreamingSettings);
        }
    }
    onStatsReceived(aggregatedStats) {
        var _a;
        // Grab all stats we can off the aggregated stats
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.handleStats(aggregatedStats);
    }
    onLatencyUpdate(latencyInfo) {
        var _a;
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.handleLatencyInfo(latencyInfo);
    }
    onLatencyTestResults(latencyTimings) {
        var _a;
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.latencyTest.handleTestResult(latencyTimings);
    }
    onDataChannelLatencyTestResults(result) {
        var _a;
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.dataChannelLatencyTest.handleTestResult(result);
    }
    onPlayerCount(playerCount) {
        var _a;
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.handlePlayerCount(playerCount);
    }
    handleStreamerListMessage(messageStreamingList, autoSelectedStreamerId, wantedStreamerId) {
        const waitForStreamer = this.stream.config.isFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Flags.WaitForStreamer);
        const isReconnecting = this.stream.isReconnecting();
        let message = null;
        let allowRestart = true;
        if (!autoSelectedStreamerId) {
            if (waitForStreamer && wantedStreamerId) {
                if (isReconnecting) {
                    message = `Waiting for ${wantedStreamerId} to become available.`;
                    allowRestart = false;
                }
                else {
                    message = `Gave up waiting for ${wantedStreamerId} to become available. Click to try again`;
                    if (messageStreamingList.ids.length > 0) {
                        message += ` or select a streamer from the settings menu.`;
                    }
                    allowRestart = true;
                }
            }
            else if (messageStreamingList.ids.length == 0) {
                if (isReconnecting) {
                    message = `Waiting for a streamer to become available.`;
                    allowRestart = false;
                }
                else {
                    message = `No streamers available. Click to try again.`;
                    allowRestart = true;
                }
            }
            else {
                message = `Multiple streamers available. Select one from the settings menu.`;
                allowRestart = false;
            }
            if (allowRestart) {
                this.showDisconnectOverlay(message);
            }
            else {
                this.showTextOverlay(message);
            }
        }
    }
    handleSubscribeFailedMessage(message) {
        this.showDisconnectOverlay(`Subscribe failed: "${message}" Click to try again`);
    }
    /**
     * Set light/dark color mode
     * @param isLightMode - should we use a light or dark color scheme
     */
    setColorMode(isLightMode) {
        if (this.onColorModeChanged) {
            this.onColorModeChanged(isLightMode);
        }
    }
    showEditTextModal(ueTextboxContents) {
        var _a;
        // Remove any existing modal
        (_a = this.editTextModal) === null || _a === void 0 ? void 0 : _a.rootElement.remove();
        // Make a new modal for editing the UE textbox on the browser side
        this.editTextModal = new _UI_EditTextModal__WEBPACK_IMPORTED_MODULE_16__.EditTextModal();
        // Add it to the root of the Pixel Streaming application
        this.rootElement.append(this.editTextModal.rootElement);
        // Add the text content from UE side and summon on-screen keyboard
        this.editTextModal.showModal(ueTextboxContents);
        // Bind to the confirm event
        this.editTextModal.events.addEventListener('editConfirmed', (evt) => {
            const editTextEvent = evt;
            this.stream.sendTextboxEntry(editTextEvent.confirmedText);
        });
    }
    onSettingsChanged(event) {
        // Pass the event directly onto the configUI. This will do things like updating the possible values
        // as well as the selected value
        this.configUI.onSettingsChanged(event);
        const { 
        /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
        data: { id, target, type } } = event;
        // Explicitly handle specific setting behaviour
        if (id == _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.OptionParameters.PreferredQuality) {
            const preferredQualityOption = this.stream.config.getSettingOption(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.OptionParameters.PreferredQuality);
            if ([...preferredQualityOption.options].includes('Default')) {
                this.configUI.disableSetting(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.OptionParameters.PreferredQuality);
            }
            else {
                this.configUI.enableSetting(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.OptionParameters.PreferredQuality);
            }
        }
    }
}
//# sourceMappingURL=Application.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Config/ConfigUI.js":
/*!****************************************************!*\
  !*** ../../ui-library/dist/esm/Config/ConfigUI.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConfigUI: () => (/* binding */ ConfigUI)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/Config/SettingFlag.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _SettingUIFlag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SettingUIFlag */ "../../ui-library/dist/esm/Config/SettingUIFlag.js");
/* harmony import */ var _SettingUINumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SettingUINumber */ "../../ui-library/dist/esm/Config/SettingUINumber.js");
/* harmony import */ var _SettingUIText__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SettingUIText */ "../../ui-library/dist/esm/Config/SettingUIText.js");
/* harmony import */ var _SettingUIOption__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SettingUIOption */ "../../ui-library/dist/esm/Config/SettingUIOption.js");
/* harmony import */ var _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../UI/UIConfigurationTypes */ "../../ui-library/dist/esm/UI/UIConfigurationTypes.js");
// Copyright Epic Games, Inc. All Rights Reserved.






class ConfigUI {
    // ------------ Settings -----------------
    constructor(config) {
        this.customFlags = new Map();
        /* A map of flags that can be toggled - options that can be set in the application - e.g. Use Mic? */
        this.flagsUi = new Map();
        /* A map of numerical settings - options that can be in the application - e.g. MinBitrate */
        this.numericParametersUi = new Map();
        /* A map of text settings - e.g. signalling server url */
        this.textParametersUi = new Map();
        /* A map of enum based settings - e.g. preferred codec */
        this.optionParametersUi = new Map();
        this.createCustomUISettings(config.useUrlParams);
        this.registerSettingsUIComponents(config);
    }
    /**
     * Create custom UI settings that are not provided by the Pixel Streaming library.
     */
    createCustomUISettings(useUrlParams) {
        this.customFlags.set(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.ExtraFlags.LightMode, new _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__.SettingFlag(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.ExtraFlags.LightMode, 'Color Scheme: Dark Mode', 'Page styling will be either light or dark', false /*if want to use system pref: (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches)*/, useUrlParams, (isLightMode, setting) => {
            setting.label = `Color Scheme: ${isLightMode ? 'Light' : 'Dark'} Mode`;
        }));
    }
    /**
     * Creates UI wrapper components for each setting element in config.
     * @param config -
     */
    registerSettingsUIComponents(config) {
        for (const setting of config.getFlags()) {
            this.flagsUi.set(setting.id, new _SettingUIFlag__WEBPACK_IMPORTED_MODULE_2__.SettingUIFlag(setting));
        }
        for (const setting of Array.from(this.customFlags.values())) {
            this.flagsUi.set(setting.id, new _SettingUIFlag__WEBPACK_IMPORTED_MODULE_2__.SettingUIFlag(setting));
        }
        for (const setting of config.getTextSettings()) {
            this.textParametersUi.set(setting.id, new _SettingUIText__WEBPACK_IMPORTED_MODULE_3__.SettingUIText(setting));
        }
        for (const setting of config.getNumericSettings()) {
            this.numericParametersUi.set(setting.id, new _SettingUINumber__WEBPACK_IMPORTED_MODULE_4__.SettingUINumber(setting));
        }
        for (const setting of config.getOptionSettings()) {
            this.optionParametersUi.set(setting.id, new _SettingUIOption__WEBPACK_IMPORTED_MODULE_5__.SettingUIOption(setting));
        }
    }
    /**
     * Make DOM elements for a settings section with a heading.
     * @param settingsElem - The parent container for our DOM elements.
     * @param sectionHeading - The heading element to go into the section.
     * @returns The constructed DOM element for the section.
     */
    buildSectionWithHeading(settingsElem, sectionHeading) {
        // make section element
        const sectionElem = document.createElement('section');
        sectionElem.classList.add('settingsContainer');
        // make section heading
        const psSettingsHeader = document.createElement('div');
        psSettingsHeader.classList.add('settingsHeader');
        psSettingsHeader.classList.add('settings-text');
        psSettingsHeader.textContent = sectionHeading;
        // add section and heading to parent settings element
        sectionElem.appendChild(psSettingsHeader);
        settingsElem.appendChild(sectionElem);
        return sectionElem;
    }
    /**
     * Setup flags with their default values and add them to the `Config.flags` map.
     * @param settingsElem - - The element that contains all the individual settings sections, flags, and so on.
     */
    populateSettingsElement(settingsElem, settingsConfig) {
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSectionEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.PixelStreaming)) {
            /* Setup all Pixel Streaming specific settings */
            const psSettingsSection = this.buildSectionWithHeading(settingsElem, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.PixelStreaming);
            // make settings show up in DOM
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.TextParameters.SignallingServerUrl))
                this.addSettingText(psSettingsSection, this.textParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.TextParameters.SignallingServerUrl));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.BrowserSendOffer))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.BrowserSendOffer));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.StreamerId))
                this.addSettingOption(psSettingsSection, this.optionParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.StreamerId));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.AutoConnect))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.AutoConnect));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.AutoPlayVideo))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.AutoPlayVideo));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.UseMic))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.UseMic));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.UseCamera))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.UseCamera));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.StartVideoMuted))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.StartVideoMuted));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.IsQualityController))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.IsQualityController));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.ForceMonoAudio))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.ForceMonoAudio));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.ForceTURN))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.ForceTURN));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.SuppressBrowserKeys))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.SuppressBrowserKeys));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.AFKDetection))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.AFKDetection));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.WaitForStreamer))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.WaitForStreamer));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.AFKTimeoutSecs))
                this.addSettingNumeric(psSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.AFKTimeoutSecs));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.AFKCountdownSecs))
                this.addSettingNumeric(psSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.AFKCountdownSecs));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.MaxReconnectAttempts))
                this.addSettingNumeric(psSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.MaxReconnectAttempts));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.StreamerAutoJoinInterval))
                this.addSettingNumeric(psSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.StreamerAutoJoinInterval));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.KeepaliveDelay))
                this.addSettingNumeric(psSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.KeepaliveDelay));
        }
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSectionEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.UI)) {
            /* Setup all view/ui related settings under this section */
            const viewSettingsSection = this.buildSectionWithHeading(settingsElem, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.UI);
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.MatchViewportResolution))
                this.addSettingFlag(viewSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.MatchViewportResolution));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.HoveringMouseMode))
                this.addSettingFlag(viewSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.HoveringMouseMode));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.ExtraFlags.LightMode))
                this.addSettingFlag(viewSettingsSection, this.flagsUi.get(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.ExtraFlags.LightMode));
        }
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSectionEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.Input)) {
            /* Setup all encoder related settings under this section */
            const inputSettingsSection = this.buildSectionWithHeading(settingsElem, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.Input);
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.KeyboardInput))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.KeyboardInput));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.MouseInput))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.MouseInput));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.FakeMouseWithTouches))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.FakeMouseWithTouches));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.TouchInput))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.TouchInput));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.GamepadInput))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.GamepadInput));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.XRControllerInput))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.XRControllerInput));
        }
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSectionEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.Encoder)) {
            /* Setup all encoder related settings under this section */
            const encoderSettingsSection = this.buildSectionWithHeading(settingsElem, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.Encoder);
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.CompatQualityMin))
                this.addSettingNumeric(encoderSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.CompatQualityMin));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.CompatQualityMax))
                this.addSettingNumeric(encoderSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.CompatQualityMax));
            const preferredCodecOption = this.optionParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.PreferredCodec);
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.PreferredCodec))
                this.addSettingOption(encoderSettingsSection, this.optionParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.PreferredCodec));
            if (preferredCodecOption &&
                [...preferredCodecOption.selector.options]
                    .map((o) => o.value)
                    .includes('Only available on Chrome')) {
                preferredCodecOption.disable();
            }
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.PreferredQuality))
                this.addSettingOption(encoderSettingsSection, this.optionParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.PreferredQuality));
        }
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSectionEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.WebRTC)) {
            /* Setup all webrtc related settings under this section */
            const webrtcSettingsSection = this.buildSectionWithHeading(settingsElem, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.WebRTC);
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCFPS))
                this.addSettingNumeric(webrtcSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCFPS));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCMinBitrate))
                this.addSettingNumeric(webrtcSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCMinBitrate));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCMaxBitrate))
                this.addSettingNumeric(webrtcSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCMaxBitrate));
        }
    }
    /**
     * Add a SettingText element to a particular settings section in the DOM and registers that text in the text settings map.
     * @param settingsSection - The settings section HTML element.
     * @param settingText - The textual settings object.
     */
    addSettingText(settingsSection, settingText) {
        if (settingText) {
            settingsSection.appendChild(settingText.rootElement);
            this.textParametersUi.set(settingText.setting.id, settingText);
        }
    }
    /**
     * Add a SettingFlag element to a particular settings section in the DOM and registers that flag in the Config.flag map.
     * @param settingsSection - The settings section HTML element.
     * @param settingFlag - The settings flag object.
     */
    addSettingFlag(settingsSection, settingFlag) {
        if (settingFlag) {
            settingsSection.appendChild(settingFlag.rootElement);
            this.flagsUi.set(settingFlag.setting.id, settingFlag);
        }
    }
    /**
     * Add a numeric setting element to a particular settings section in the DOM and registers that flag in the Config.numericParameters map.
     * @param settingsSection - The settings section HTML element.
     * @param settingFlag - The settings flag object.
     */
    addSettingNumeric(settingsSection, setting) {
        if (setting) {
            settingsSection.appendChild(setting.rootElement);
            this.numericParametersUi.set(setting.setting.id, setting);
        }
    }
    /**
     * Add an enum based settings element to a particular settings section in the DOM and registers that flag in the Config.enumParameters map.
     * @param settingsSection - The settings section HTML element.
     * @param settingFlag - The settings flag object.
     */
    addSettingOption(settingsSection, setting) {
        if (setting) {
            settingsSection.appendChild(setting.rootElement);
            this.optionParametersUi.set(setting.setting.id, setting);
        }
    }
    onSettingsChanged({ data: { id, target, type } }) {
        if (type === 'flag') {
            const _id = id;
            const _target = target;
            const setting = this.flagsUi.get(_id);
            if (setting) {
                if (setting.flag !== _target.flag) {
                    setting.flag = _target.flag;
                }
                if (setting.label !== _target.label) {
                    setting.label = _target.label;
                }
            }
        }
        else if (type === 'number') {
            const _id = id;
            const _target = target;
            const setting = this.numericParametersUi.get(_id);
            if (setting) {
                if (setting.number !== _target.number) {
                    setting.number = _target.number;
                }
                if (setting.label !== _target.label) {
                    setting.label = _target.label;
                }
            }
        }
        else if (type === 'text') {
            const _id = id;
            const _target = target;
            const setting = this.textParametersUi.get(_id);
            if (setting) {
                if (setting.text !== _target.text) {
                    setting.text = _target.text;
                }
                if (setting.label !== _target.label) {
                    setting.label = _target.label;
                }
            }
        }
        else if (type === 'option') {
            const _id = id;
            const _target = target;
            const setting = this.optionParametersUi.get(_id);
            if (setting) {
                const uiOptions = setting.options;
                const targetOptions = _target.options;
                if (uiOptions.length !== targetOptions.length ||
                    !uiOptions.every((value) => targetOptions.includes(value))) {
                    setting.options = _target.options;
                }
                if (setting.selected !== _target.selected) {
                    setting.selected = _target.selected;
                }
                if (setting.label !== _target.label) {
                    setting.label = _target.label;
                }
            }
        }
    }
    /**
     * Add a callback to fire when the flag is toggled.
     * @param id - The id of the flag.
     * @param onChangeListener - The callback to fire when the value changes.
     */
    addCustomFlagOnSettingChangedListener(id, onChangeListener) {
        if (this.customFlags.has(id)) {
            this.customFlags.get(id).onChange = onChangeListener;
        }
    }
    /**
     * Set the label for the flag.
     * @param id - The id of the flag.
     * @param label - The new label to use for the flag.
     */
    setCustomFlagLabel(id, label) {
        if (!this.customFlags.has(id)) {
            _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_7__.Logger.Warning(`Cannot set label for flag called ${id} - it does not exist in the Config.flags map.`);
        }
        else {
            this.customFlags.get(id).label = label;
            this.flagsUi.get(id).label = label;
        }
    }
    /**
     * Get the value of the configuration flag which has the given id.
     * @param id - The unique id for the flag.
     * @returns True if the flag is enabled.
     */
    isCustomFlagEnabled(id) {
        return this.customFlags.get(id).flag;
    }
    disableSetting(id) {
        var _a, _b, _c, _d;
        if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.isFlagId)(id)) {
            (_a = this.flagsUi.get(id)) === null || _a === void 0 ? void 0 : _a.disable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.isNumericId)(id)) {
            (_b = this.numericParametersUi.get(id)) === null || _b === void 0 ? void 0 : _b.disable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.isTextId)(id)) {
            (_c = this.textParametersUi.get(id)) === null || _c === void 0 ? void 0 : _c.disable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.isOptionId)(id)) {
            (_d = this.optionParametersUi.get(id)) === null || _d === void 0 ? void 0 : _d.disable();
        }
    }
    enableSetting(id) {
        var _a, _b, _c, _d;
        if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.isFlagId)(id)) {
            (_a = this.flagsUi.get(id)) === null || _a === void 0 ? void 0 : _a.enable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.isNumericId)(id)) {
            (_b = this.numericParametersUi.get(id)) === null || _b === void 0 ? void 0 : _b.enable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.isTextId)(id)) {
            (_c = this.textParametersUi.get(id)) === null || _c === void 0 ? void 0 : _c.enable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.isOptionId)(id)) {
            (_d = this.optionParametersUi.get(id)) === null || _d === void 0 ? void 0 : _d.enable();
        }
    }
}
//# sourceMappingURL=ConfigUI.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Config/SettingUIBase.js":
/*!*********************************************************!*\
  !*** ../../ui-library/dist/esm/Config/SettingUIBase.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingUIBase: () => (/* binding */ SettingUIBase)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Base class for a setting that has a text label, an arbitrary setting value it stores, an a HTML element that represents this setting.
 */
class SettingUIBase {
    constructor(setting) {
        this._setting = setting;
    }
    /**
     * @returns The setting component.
     */
    get setting() {
        return this._setting;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('div');
        }
        return this._rootElement;
    }
}
//# sourceMappingURL=SettingUIBase.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Config/SettingUIFlag.js":
/*!*********************************************************!*\
  !*** ../../ui-library/dist/esm/Config/SettingUIFlag.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingUIFlag: () => (/* binding */ SettingUIFlag)
/* harmony export */ });
/* harmony import */ var _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingUIBase */ "../../ui-library/dist/esm/Config/SettingUIBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class SettingUIFlag extends _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__.SettingUIBase {
    constructor(setting) {
        super(setting);
        this.label = setting.label;
        this.flag = setting.flag;
    }
    /**
     * @returns The setting component.
     */
    get setting() {
        return this._setting;
    }
    get settingsTextElem() {
        if (!this._settingsTextElem) {
            this._settingsTextElem = document.createElement('div');
            this._settingsTextElem.innerText = this.setting._label;
            this._settingsTextElem.title = this.setting.description;
        }
        return this._settingsTextElem;
    }
    get checkbox() {
        if (!this._checkbox) {
            this._checkbox = document.createElement('input');
            this._checkbox.type = 'checkbox';
            // Block keypress/up/down propogation from text field typing going to UE
            this._checkbox.addEventListener('keypress', (event) => {
                event.stopPropagation();
            });
            this._checkbox.addEventListener('keyup', (event) => {
                event.stopPropagation();
            });
            this._checkbox.addEventListener('keydown', (event) => {
                event.stopPropagation();
            });
        }
        return this._checkbox;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            // create root div with "setting" css class
            this._rootElement = document.createElement('div');
            this._rootElement.id = this.setting.id;
            this._rootElement.classList.add('setting');
            // create div element to contain our setting's text
            this._rootElement.appendChild(this.settingsTextElem);
            // create label element to wrap out input type
            const wrapperLabel = document.createElement('label');
            wrapperLabel.classList.add('tgl-switch');
            this._rootElement.appendChild(wrapperLabel);
            // create input type=checkbox
            this.checkbox.title = this.setting.description;
            this.checkbox.classList.add('tgl');
            this.checkbox.classList.add('tgl-flat');
            const slider = document.createElement('div');
            slider.classList.add('tgl-slider');
            wrapperLabel.appendChild(this.checkbox);
            wrapperLabel.appendChild(slider);
            // setup on change from checkbox
            this.checkbox.addEventListener('change', () => {
                if (this.setting.flag !== this.checkbox.checked) {
                    this.setting.flag = this.checkbox.checked;
                    this.setting.updateURLParams();
                }
            });
        }
        return this._rootElement;
    }
    /**
     * Update the setting's stored value.
     * @param inValue - The new value for the setting.
     */
    set flag(inValue) {
        this.checkbox.checked = inValue;
    }
    /**
     * Get value
     */
    get flag() {
        return this.checkbox.checked;
    }
    /**
     * Set the label text for the setting.
     * @param label - setting label.
     */
    set label(inLabel) {
        this.settingsTextElem.innerText = inLabel;
    }
    /**
     * Get label
     */
    get label() {
        return this.settingsTextElem.innerText;
    }
    disable() {
        this.checkbox.disabled = true;
    }
    enable() {
        this.checkbox.disabled = false;
    }
}
//# sourceMappingURL=SettingUIFlag.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Config/SettingUINumber.js":
/*!***********************************************************!*\
  !*** ../../ui-library/dist/esm/Config/SettingUINumber.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingUINumber: () => (/* binding */ SettingUINumber)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingUIBase */ "../../ui-library/dist/esm/Config/SettingUIBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * A number spinner with a text label beside it.
 */
class SettingUINumber extends _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__.SettingUIBase {
    constructor(setting) {
        super(setting);
        this.label = this.setting.label;
        this.number = this.setting.number;
    }
    /**
     * @returns The setting component.
     */
    get setting() {
        return this._setting;
    }
    get settingsTextElem() {
        if (!this._settingsTextElem) {
            this._settingsTextElem = document.createElement('label');
            this._settingsTextElem.innerText = this.setting.label;
            this._settingsTextElem.title = this.setting.description;
        }
        return this._settingsTextElem;
    }
    /**
     * Get the HTMLInputElement for the button.
     */
    get spinner() {
        if (!this._spinner) {
            this._spinner = document.createElement('input');
            this._spinner.type = 'number';
            if (this.setting.min != null) {
                this._spinner.min = this.setting.min.toString();
            }
            if (this.setting.max != null) {
                this._spinner.max = this.setting.max.toString();
            }
            this._spinner.value = this.setting.number.toString();
            this._spinner.title = this.setting.description;
            this._spinner.classList.add('form-control');
            // Block keypress/up/down propogation from text field typing going to UE
            this.spinner.addEventListener('keypress', (event) => {
                event.stopPropagation();
            });
            this.spinner.addEventListener('keyup', (event) => {
                event.stopPropagation();
            });
            this.spinner.addEventListener('keydown', (event) => {
                event.stopPropagation();
            });
        }
        return this._spinner;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            // create root div with "setting" css class
            this._rootElement = document.createElement('div');
            this._rootElement.classList.add('setting');
            this._rootElement.classList.add('form-group');
            // create div element to contain our setting's text
            this._rootElement.appendChild(this.settingsTextElem);
            // create label element to wrap out input type
            this._rootElement.appendChild(this.spinner);
            // setup onchange
            this.spinner.onchange = (event) => {
                const inputElem = event.target;
                const parsedValue = Number.parseFloat(inputElem.value);
                if (Number.isNaN(parsedValue)) {
                    _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Warning(`Could not parse value change into a valid number - value was ${inputElem.value}, resetting value to ${this.setting.min}`);
                    if (this.setting.number !== this.setting.min) {
                        this.setting.number = this.setting.min;
                    }
                }
                else {
                    if (this.setting.number !== parsedValue) {
                        this.setting.number = parsedValue;
                        this.setting.updateURLParams();
                    }
                }
            };
        }
        return this._rootElement;
    }
    /**
     * Set the number in the spinner (will be clamped within range).
     */
    set number(newNumber) {
        this.spinner.value = this.setting.clamp(newNumber).toString();
    }
    /**
     * Get value
     */
    get number() {
        return +this.spinner.value;
    }
    /**
     * Set the label text for the setting.
     * @param label - setting label.
     */
    set label(inLabel) {
        this.settingsTextElem.innerText = inLabel;
    }
    /**
     * Get label
     */
    get label() {
        return this.settingsTextElem.innerText;
    }
    disable() {
        this.spinner.disabled = true;
    }
    enable() {
        this.spinner.disabled = false;
    }
}
//# sourceMappingURL=SettingUINumber.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Config/SettingUIOption.js":
/*!***********************************************************!*\
  !*** ../../ui-library/dist/esm/Config/SettingUIOption.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingUIOption: () => (/* binding */ SettingUIOption)
/* harmony export */ });
/* harmony import */ var _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingUIBase */ "../../ui-library/dist/esm/Config/SettingUIBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class SettingUIOption extends _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__.SettingUIBase {
    constructor(setting) {
        super(setting);
        this.label = this.setting.label;
        this.options = this.setting.options;
        this.selected = this.setting.selected;
    }
    /**
     * @returns The setting component.
     */
    get setting() {
        return this._setting;
    }
    get selector() {
        if (!this._selector) {
            this._selector = document.createElement('select');
            this._selector.classList.add('form-control');
            this._selector.classList.add('settings-option');
        }
        return this._selector;
    }
    get settingsTextElem() {
        if (!this._settingsTextElem) {
            this._settingsTextElem = document.createElement('div');
            this._settingsTextElem.innerText = this.setting.label;
            this._settingsTextElem.title = this.setting.description;
        }
        return this._settingsTextElem;
    }
    /**
     * Set the label text for the setting.
     * @param label - setting label.
     */
    set label(inLabel) {
        this.settingsTextElem.innerText = inLabel;
    }
    /**
     * Get label
     */
    get label() {
        return this.settingsTextElem.innerText;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            // create root div with "setting" css class
            this._rootElement = document.createElement('div');
            this._rootElement.id = this.setting.id;
            this._rootElement.classList.add('setting');
            this._rootElement.classList.add('form-group');
            // create div element to contain our setting's text
            this._rootElement.appendChild(this.settingsTextElem);
            // create label element to wrap out input type
            const wrapperLabel = document.createElement('label');
            this._rootElement.appendChild(wrapperLabel);
            // create select element
            this.selector.title = this.setting.description;
            wrapperLabel.appendChild(this.selector);
            // setup on change from selector
            this.selector.onchange = () => {
                if (this.setting.selected !== this.selector.value) {
                    this.setting.selected = this.selector.value;
                    this.setting.updateURLParams();
                }
            };
            // Block keypress/up/down propogation from text field typing going to UE
            this.selector.addEventListener('keypress', (event) => {
                event.stopPropagation();
            });
            this.selector.addEventListener('keyup', (event) => {
                event.stopPropagation();
            });
            this.selector.addEventListener('keydown', (event) => {
                event.stopPropagation();
            });
        }
        return this._rootElement;
    }
    set options(values) {
        for (let i = this.selector.options.length - 1; i >= 0; i--) {
            this.selector.remove(i);
        }
        values.forEach((value) => {
            const opt = document.createElement('option');
            opt.value = value;
            opt.innerHTML = value;
            this.selector.appendChild(opt);
        });
    }
    get options() {
        return [...this.selector.options].map((o) => o.value);
    }
    set selected(value) {
        // A user may not specify the full possible value so we instead use the closest match.
        // eg ?xxx=H264 would select 'H264 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f'
        const filteredList = this.options.filter((option) => option.indexOf(value) !== -1);
        if (filteredList.length) {
            this.selector.value = filteredList[0];
        }
    }
    get selected() {
        return this.selector.value;
    }
    disable() {
        this.selector.disabled = true;
    }
    enable() {
        this.selector.disabled = false;
    }
}
//# sourceMappingURL=SettingUIOption.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Config/SettingUIText.js":
/*!*********************************************************!*\
  !*** ../../ui-library/dist/esm/Config/SettingUIText.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingUIText: () => (/* binding */ SettingUIText)
/* harmony export */ });
/* harmony import */ var _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingUIBase */ "../../ui-library/dist/esm/Config/SettingUIBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class SettingUIText extends _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__.SettingUIBase {
    constructor(setting) {
        super(setting);
        this.label = this.setting.label;
        this.text = this.setting.text;
    }
    /**
     * @returns The setting component.
     */
    get setting() {
        return this._setting;
    }
    get settingsTextElem() {
        if (!this._settingsTextElem) {
            this._settingsTextElem = document.createElement('div');
            this._settingsTextElem.innerText = this.setting.label;
            this._settingsTextElem.title = this.setting.description;
        }
        return this._settingsTextElem;
    }
    get textbox() {
        if (!this._textbox) {
            this._textbox = document.createElement('input');
            this._textbox.classList.add('form-control');
            this._textbox.type = 'textbox';
        }
        return this._textbox;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            // create root div with "setting" css class
            this._rootElement = document.createElement('div');
            this._rootElement.id = this.setting.id;
            this._rootElement.classList.add('setting');
            // create div element to contain our setting's text
            this._rootElement.appendChild(this.settingsTextElem);
            // create label element to wrap out input type
            const wrapperLabel = document.createElement('label');
            this._rootElement.appendChild(wrapperLabel);
            // create input type=checkbox
            this.textbox.title = this.setting.description;
            wrapperLabel.appendChild(this.textbox);
            // setup on change from checkbox
            this.textbox.addEventListener('input', (event) => {
                if (this.setting.text !== this.textbox.value) {
                    this.setting.text = this.textbox.value;
                    this.setting.updateURLParams();
                }
                event.stopPropagation();
            });
            // Block keypress/up/down propogation from text field typing going to UE
            this.textbox.addEventListener('keypress', (event) => {
                event.stopPropagation();
            });
            this.textbox.addEventListener('keyup', (event) => {
                event.stopPropagation();
            });
            this.textbox.addEventListener('keydown', (event) => {
                event.stopPropagation();
            });
        }
        return this._rootElement;
    }
    /**
     * Update the setting's stored value.
     * @param inValue - The new value for the setting.
     */
    set text(inValue) {
        this.textbox.value = inValue;
    }
    /**
     * Get value
     */
    get text() {
        return this.textbox.value;
    }
    /**
     * Set the label text for the setting.
     * @param label - setting label.
     */
    set label(inLabel) {
        this.settingsTextElem.innerText = inLabel;
    }
    /**
     * Get label
     */
    get label() {
        return this.settingsTextElem.innerText;
    }
    disable() {
        this.textbox.disabled = true;
    }
    enable() {
        this.textbox.disabled = false;
    }
}
//# sourceMappingURL=SettingUIText.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/AFKOverlay.js":
/*!*******************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/AFKOverlay.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AFKOverlay: () => (/* binding */ AFKOverlay)
/* harmony export */ });
/* harmony import */ var _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ActionOverlay */ "../../ui-library/dist/esm/Overlay/ActionOverlay.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Show an overlay for when the session is unattended, it begins a countdown timer, which when elapsed will disconnect the stream.
 */
class AFKOverlay extends _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__.ActionOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const afkOverlayHtml = document.createElement('div');
        afkOverlayHtml.id = 'afkOverlay';
        afkOverlayHtml.className = 'clickableState';
        return afkOverlayHtml;
    }
    /**
     * @returns The created content element of this overlay, which contain some text for an afk count down.
     */
    static createContentElement() {
        const afkOverlayHtmlInner = document.createElement('div');
        afkOverlayHtmlInner.id = 'afkOverlayInner';
        afkOverlayHtmlInner.innerHTML =
            '<center>No activity detected<br>Disconnecting in <span id="afkCountDownNumber"></span> seconds<br>Click to continue<br></center>';
        return afkOverlayHtmlInner;
    }
    /**
     * Construct an Afk overlay
     * @param parentElement - the element this overlay will be inserted into
     */
    constructor(rootDiv) {
        super(rootDiv, AFKOverlay.createRootElement(), AFKOverlay.createContentElement());
        this.rootElement.addEventListener('click', () => {
            this.activate();
        });
    }
    /**
     * Update the count down spans number for the overlay
     * @param countdown - the count down number to be inserted into the span for updating
     */
    updateCountdown(countdown) {
        this.textElement.innerHTML = `<center>No activity detected<br>Disconnecting in <span id="afkCountDownNumber">${countdown}</span> seconds<br>Click to continue<br></center>`;
    }
}
//# sourceMappingURL=AFKOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/ActionOverlay.js":
/*!**********************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/ActionOverlay.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActionOverlay: () => (/* binding */ ActionOverlay)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _BaseOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseOverlay */ "../../ui-library/dist/esm/Overlay/BaseOverlay.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * Class for the base action overlay structure
 */
class ActionOverlay extends _BaseOverlay__WEBPACK_IMPORTED_MODULE_0__.OverlayBase {
    /**
     * Construct an action overlay
     * @param rootDiv - the root element this overlay will be inserted into
     * @param rootElement - the root element that is the overlay
     * @param contentElement - an element that contains text for the action overlay
     */
    constructor(rootDiv, rootElement, contentElement) {
        super(rootDiv, rootElement, contentElement);
        this.onActionCallback = () => {
            /* do nothing */ _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Did you forget to set the onAction callback in your overlay?');
        };
    }
    /**
     * Update the text overlays inner text
     * @param text - the update text to be inserted into the overlay
     */
    update(text) {
        if (text != null || text != undefined) {
            this.textElement.innerHTML = text;
        }
    }
    /**
     * Set a method as an event emitter callback
     * @param callBack - the method that is to be called when the event is emitted
     */
    onAction(callBack) {
        this.onActionCallback = callBack;
    }
    /**
     * Activate an event that is attached to the event emitter
     */
    activate() {
        this.onActionCallback();
    }
}
//# sourceMappingURL=ActionOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/BaseOverlay.js":
/*!********************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/BaseOverlay.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OverlayBase: () => (/* binding */ OverlayBase)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Class for the base overlay structure
 */
class OverlayBase {
    /**
     * Construct an overlay
     * @param rootDiv - the root element this overlay will be inserted into
     * @param rootElement - the root element that is the overlay
     */
    constructor(rootDiv, rootElement, textElement) {
        this.rootDiv = rootDiv;
        this.rootElement = rootElement;
        this.textElement = textElement;
        this.rootElement.appendChild(this.textElement);
        this.hide();
        this.rootDiv.appendChild(this.rootElement);
    }
    /**
     * Show the overlay
     */
    show() {
        this.rootElement.classList.remove('hiddenState');
    }
    /**
     * Hide the overlay
     */
    hide() {
        this.rootElement.classList.add('hiddenState');
    }
}
//# sourceMappingURL=BaseOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/ConnectOverlay.js":
/*!***********************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/ConnectOverlay.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConnectOverlay: () => (/* binding */ ConnectOverlay)
/* harmony export */ });
/* harmony import */ var _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ActionOverlay */ "../../ui-library/dist/esm/Overlay/ActionOverlay.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Overlay shown during connection, has a button that can be clicked to initiate a connection.
 */
class ConnectOverlay extends _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__.ActionOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const connectElem = document.createElement('div');
        connectElem.id = 'connectOverlay';
        connectElem.className = 'clickableState';
        return connectElem;
    }
    /**
     * @returns The created content element of this overlay, which contain whatever content this element contains, like text or a button.
     */
    static createContentElement() {
        const connectContentElem = document.createElement('div');
        connectContentElem.id = 'connectButton';
        connectContentElem.innerHTML = 'Click to start';
        return connectContentElem;
    }
    /**
     * Construct a connect overlay with a connection button.
     * @param parentElem - the parent element this overlay will be inserted into.
     */
    constructor(parentElem) {
        super(parentElem, ConnectOverlay.createRootElement(), ConnectOverlay.createContentElement());
        // add the new event listener
        this.rootElement.addEventListener('click', () => {
            this.activate();
        });
    }
}
//# sourceMappingURL=ConnectOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/DisconnectOverlay.js":
/*!**************************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/DisconnectOverlay.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DisconnectOverlay: () => (/* binding */ DisconnectOverlay)
/* harmony export */ });
/* harmony import */ var _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ActionOverlay */ "../../ui-library/dist/esm/Overlay/ActionOverlay.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Overlay shown during disconnection, has a reconnection element that can be clicked to reconnect.
 */
class DisconnectOverlay extends _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__.ActionOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const disconnectOverlayHtml = document.createElement('div');
        disconnectOverlayHtml.id = 'disconnectOverlay';
        disconnectOverlayHtml.className = 'clickableState';
        return disconnectOverlayHtml;
    }
    /**
     * @returns The created content element of this overlay, which contain whatever content this element contains, like text or a button.
     */
    static createContentElement() {
        // build the inner html container
        const disconnectOverlayHtmlContainer = document.createElement('div');
        disconnectOverlayHtmlContainer.id = 'disconnectButton';
        disconnectOverlayHtmlContainer.innerHTML = 'Click To Restart';
        return disconnectOverlayHtmlContainer;
    }
    /**
     * Construct a disconnect overlay with a retry connection icon.
     * @param parentElem - the parent element this overlay will be inserted into.
     */
    constructor(parentElem) {
        super(parentElem, DisconnectOverlay.createRootElement(), DisconnectOverlay.createContentElement());
        // add the new event listener
        this.rootElement.addEventListener('click', () => {
            this.activate();
        });
    }
}
//# sourceMappingURL=DisconnectOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/ErrorOverlay.js":
/*!*********************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/ErrorOverlay.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ErrorOverlay: () => (/* binding */ ErrorOverlay)
/* harmony export */ });
/* harmony import */ var _TextOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextOverlay */ "../../ui-library/dist/esm/Overlay/TextOverlay.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Generic overlay used to show textual error info to the user.
 */
class ErrorOverlay extends _TextOverlay__WEBPACK_IMPORTED_MODULE_0__.TextOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const errorOverlayHtml = document.createElement('div');
        errorOverlayHtml.id = 'errorOverlay';
        errorOverlayHtml.className = 'textDisplayState';
        return errorOverlayHtml;
    }
    /**
     * @returns The created content element of this overlay, which contain whatever content this element contains, like text or a button.
     */
    static createContentElement() {
        const errorOverlayHtmlInner = document.createElement('div');
        errorOverlayHtmlInner.id = 'errorOverlayInner';
        return errorOverlayHtmlInner;
    }
    /**
     * Construct a connect overlay with a connection button.
     * @param parentElem - the parent element this overlay will be inserted into.
     */
    constructor(parentElem) {
        super(parentElem, ErrorOverlay.createRootElement(), ErrorOverlay.createContentElement());
    }
}
//# sourceMappingURL=ErrorOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/InfoOverlay.js":
/*!********************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/InfoOverlay.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InfoOverlay: () => (/* binding */ InfoOverlay)
/* harmony export */ });
/* harmony import */ var _TextOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextOverlay */ "../../ui-library/dist/esm/Overlay/TextOverlay.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Generic overlay used to show textual info to the user.
 */
class InfoOverlay extends _TextOverlay__WEBPACK_IMPORTED_MODULE_0__.TextOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const infoOverlayHtml = document.createElement('div');
        infoOverlayHtml.id = 'infoOverlay';
        infoOverlayHtml.className = 'textDisplayState';
        return infoOverlayHtml;
    }
    /**
     * @returns The created content element of this overlay, which contain whatever content this element contains, like text or a button.
     */
    static createContentElement() {
        const infoOverlayHtmlInner = document.createElement('div');
        infoOverlayHtmlInner.id = 'messageOverlayInner';
        return infoOverlayHtmlInner;
    }
    /**
     * Construct a connect overlay with a connection button.
     * @param parentElem - the parent element this overlay will be inserted into.
     */
    constructor(parentElem) {
        super(parentElem, InfoOverlay.createRootElement(), InfoOverlay.createContentElement());
    }
}
//# sourceMappingURL=InfoOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/PlayOverlay.js":
/*!********************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/PlayOverlay.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PlayOverlay: () => (/* binding */ PlayOverlay)
/* harmony export */ });
/* harmony import */ var _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ActionOverlay */ "../../ui-library/dist/esm/Overlay/ActionOverlay.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Overlay shown when stream is ready to play.
 */
class PlayOverlay extends _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__.ActionOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const playElem = document.createElement('div');
        playElem.id = 'playOverlay';
        playElem.className = 'clickableState';
        return playElem;
    }
    /**
     * @returns The created content element of this overlay, which contain whatever content this element contains, like text or a button.
     */
    static createContentElement() {
        // todo: change this to an svg
        const playOverlayHtmlInner = document.createElement('img');
        playOverlayHtmlInner.id = 'playButton';
        playOverlayHtmlInner.src =
            'data:image/png;base64,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';
        playOverlayHtmlInner.alt = 'Start Streaming';
        return playOverlayHtmlInner;
    }
    /**
     * Construct a connect overlay with a connection button.
     * @param parentElem - the parent element this overlay will be inserted into.
     */
    constructor(parentElem) {
        super(parentElem, PlayOverlay.createRootElement(), PlayOverlay.createContentElement());
        // add the new event listener
        this.rootElement.addEventListener('click', () => {
            this.activate();
        });
    }
}
//# sourceMappingURL=PlayOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/TextOverlay.js":
/*!********************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/TextOverlay.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextOverlay: () => (/* binding */ TextOverlay)
/* harmony export */ });
/* harmony import */ var _BaseOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseOverlay */ "../../ui-library/dist/esm/Overlay/BaseOverlay.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Class for the text overlay base
 */
class TextOverlay extends _BaseOverlay__WEBPACK_IMPORTED_MODULE_0__.OverlayBase {
    /**
     * Construct a text overlay
     * @param rootDiv - the root element this overlay will be inserted into
     * @param rootElement - the root element that is the overlay
     * @param textElement - an element that contains text for the action overlay
     */
    constructor(rootDiv, rootElement, textElement) {
        super(rootDiv, rootElement, textElement);
    }
    /**
     * Update the text overlays inner text
     * @param text - the update text to be inserted into the overlay
     */
    update(text) {
        if (text != null || text != undefined) {
            this.textElement.innerHTML = text;
        }
    }
}
//# sourceMappingURL=TextOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Styles/PixelStreamingApplicationStyles.js":
/*!***************************************************************************!*\
  !*** ../../ui-library/dist/esm/Styles/PixelStreamingApplicationStyles.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PixelStreamingApplicationStyle: () => (/* binding */ PixelStreamingApplicationStyle)
/* harmony export */ });
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jss */ "../../../node_modules/jss/dist/jss.esm.js");
/* harmony import */ var jss_plugin_global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jss-plugin-global */ "../../../node_modules/jss-plugin-global/dist/jss-plugin-global.esm.js");
/* harmony import */ var jss_plugin_camel_case__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jss-plugin-camel-case */ "../../../node_modules/jss-plugin-camel-case/dist/jss-plugin-camel-case.esm.js");
/* Copyright Epic Games, Inc. All Rights Reserved. */



class PixelStreamingApplicationStyle {
    constructor(options) {
        this.defaultLightModePalette = {
            '--color0': '#e2e0dd80',
            '--color1': '#FFFFFF',
            '--color2': '#000000',
            '--color3': '#0585fe',
            '--color4': '#35b350',
            '--color5': '#ffab00',
            '--color6': '#e1e2dd',
            '--color7': '#c3c4bf'
        };
        this.defaultDarkModePalette = {
            '--color0': '#1d1f22e0',
            '--color1': '#000000',
            '--color2': '#FFFFFF',
            '--color3': '#0585fe',
            '--color4': '#35b350',
            '--color5': '#ffab00',
            '--color6': '#1e1d22',
            '--color7': '#3c3b40'
        };
        this.defaultStyles = {
            ':root': {
                '--color0': '#1d1f22e0',
                '--color1': '#000000',
                '--color2': '#FFFFFF',
                '--color3': '#0585fe',
                '--color4': '#35b350',
                '--color5': '#ffab00',
                '--color6': '#1e1d22',
                '--color7': '#3c3b40',
                '--color8': '#41008c',
                '--color9': '#3e0070',
                '--color10': '#2e0052',
                '--color11': 'rgba(65,0,139,1)'
            },
            '.noselect': {
                userSelect: 'none'
            },
            '#playerUI': {
                width: '100%',
                height: '100%',
                position: 'relative'
            },
            '#videoElementParent': {
                width: '100%',
                height: '100%',
                position: 'absolute',
                backgroundColor: 'var(--color1)'
            },
            '#uiFeatures': {
                width: '100%',
                height: '100%',
                zIndex: '30',
                position: 'relative',
                color: 'var(--color2)',
                pointerEvents: 'none',
                overflow: 'hidden'
            },
            '.UiTool .tooltiptext': {
                visibility: 'hidden',
                width: 'auto',
                color: 'var(--color2)',
                textAlign: 'center',
                borderRadius: '15px',
                padding: '0px 10px',
                fontFamily: "'Montserrat', sans-serif",
                fontSize: '0.75rem',
                letterSpacing: '0.75px',
                position: 'absolute',
                top: '0',
                transform: 'translateY(25%)',
                left: '125%',
                zIndex: '20'
            },
            '.UiTool:hover .tooltiptext': {
                visibility: 'visible',
                backgroundColor: 'var(--color7)'
            },
            '#connection .tooltiptext': {
                top: '125%',
                transform: 'translateX(-25%)',
                left: '0',
                zIndex: '20',
                padding: '5px 10px'
            },
            '#connection': {
                position: 'absolute',
                bottom: '8%',
                left: '5%',
                fontFamily: "'Michroma', sans-serif",
                height: '3rem',
                width: '3rem',
                pointerEvents: 'all'
            },
            '#settings-panel .tooltiptext': {
                display: 'block',
                top: '125%',
                transform: 'translateX(-50%)',
                left: '0',
                zIndex: '20',
                padding: '5px 10px',
                border: '3px solid var(--color3)',
                width: 'max-content',
                fallbacks: [
                    {
                        width: 'max-content'
                    },
                    {
                        border: '3px solid var(--color3)'
                    },
                    {
                        padding: '5px 10px'
                    },
                    {
                        zIndex: '20'
                    },
                    {
                        left: '0'
                    },
                    {
                        transform: 'translateX(-50%)'
                    },
                    {
                        top: '125%'
                    },
                    {
                        display: 'block'
                    }
                ]
            },
            '#controls': {
                position: 'absolute',
                top: '3%',
                left: '2%',
                fontFamily: "'Michroma', sans-serif",
                pointerEvents: 'all',
                display: 'block'
            },
            '#controls>*': {
                marginBottom: '0.5rem',
                borderRadius: '50%',
                display: 'block',
                height: '2rem',
                lineHeight: '1.75rem',
                padding: '0.5rem'
            },
            '#controls #additionalinfo': {
                textAlign: 'center',
                fontFamily: "'Montserrat', sans-serif"
            },
            '#fullscreen-btn': {
                padding: '0.6rem !important'
            },
            '#minimizeIcon': {
                display: 'none'
            },
            '#settingsBtn, #statsBtn': {
                cursor: 'pointer'
            },
            '#uiFeatures button': {
                backgroundColor: 'var(--color7)',
                border: '1px solid var(--color7)',
                color: 'var(--color2)',
                position: 'relative',
                width: '3rem',
                height: '3rem',
                padding: '0.5rem',
                textAlign: 'center'
            },
            '#uiFeatures button:hover': {
                backgroundColor: 'var(--color3)',
                border: '3px solid var(--color3)',
                transition: '0.25s ease',
                paddingLeft: '0.55rem',
                paddingTop: '0.55rem'
            },
            '#uiFeatures button:active': {
                border: '3px solid var(--color3)',
                backgroundColor: 'var(--color7)',
                paddingLeft: '0.55rem',
                paddingTop: '0.55rem'
            },
            '.btn-flat': {
                backgroundColor: 'transparent',
                color: 'var(--color2)',
                fontFamily: "'Montserrat'",
                fontWeight: 'bold',
                border: '3px solid var(--color3)',
                borderRadius: '1rem',
                fontSize: '0.75rem',
                paddingLeft: '0.5rem',
                paddingRight: '0.5rem',
                cursor: 'pointer',
                textAlign: 'center'
            },
            '.btn-flat:hover': {
                backgroundColor: 'var(--color3)',
                transition: 'ease 0.3s'
            },
            '.btn-flat:disabled': {
                background: 'var(--color7)',
                borderColor: 'var(--color3)',
                color: 'var(--color3)',
                cursor: 'default'
            },
            '.btn-flat:active': {
                backgroundColor: 'transparent'
            },
            '.btn-flat:focus': {
                outline: 'none'
            },
            '#uiFeatures img': {
                width: '100%',
                height: '100%'
            },
            '.panel-wrap': {
                position: 'absolute',
                top: '0',
                bottom: '0',
                right: '0',
                height: '100%',
                minWidth: '20vw',
                maxWidth: '90vw',
                transform: 'translateX(100%)',
                transition: '.3s ease-out',
                pointerEvents: 'all',
                overflowY: 'auto',
                overflowX: 'hidden',
                backgroundColor: 'var(--color0)'
            },
            '.panel-wrap-visible': {
                transform: 'translateX(0%)'
            },
            '.panel': {
                overflowY: 'auto',
                padding: '1em'
            },
            '#settingsHeading, #statsHeading': {
                display: 'inline-block',
                fontSize: '2em',
                marginBlockStart: '0.67em',
                marginBlockEnd: '0.67em',
                marginInlineStart: '0px',
                marginInlineEnd: '0px',
                position: 'relative',
                padding: '0 0 0 2rem'
            },
            '#settingsClose, #statsClose': {
                margin: '0.5rem',
                paddingTop: '0.5rem',
                paddingBottom: '0.5rem',
                paddingRight: '0.5rem',
                fontSize: '2em',
                float: 'right'
            },
            '#settingsClose:after, #statsClose:after': {
                paddingLeft: '0.5rem',
                display: 'inline-block',
                content: '"\\00d7"'
            },
            '#settingsClose:hover, #statsClose:hover': {
                color: 'var(--color3)',
                transition: 'ease 0.3s'
            },
            '#settingsContent, #statsContent': {
                marginLeft: '2rem',
                marginRight: '2rem'
            },
            '.setting': {
                display: 'flex',
                flexDirection: 'row',
                justifyContent: 'space-between',
                padding: '0.15rem 10px 0.15rem 10px'
            },
            '.settings-text': {
                color: 'var(--color2)',
                verticalAlign: 'middle',
                fontWeight: 'normal'
            },
            '.settings-option': {
                width: '100%',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap'
            },
            '#connectOverlay, #playOverlay, #infoOverlay, #errorOverlay, #afkOverlay, #disconnectOverlay': {
                zIndex: '30',
                position: 'absolute',
                color: 'var(--color2)',
                fontSize: '1.8em',
                width: '100%',
                height: '100%',
                backgroundColor: 'var(--color1)',
                alignItems: 'center',
                justifyContent: 'center',
                textTransform: 'uppercase'
            },
            '.clickableState': {
                alignItems: 'center',
                justifyContent: 'center',
                display: 'flex',
                cursor: 'pointer'
            },
            '.textDisplayState': {
                display: 'flex'
            },
            '.hiddenState': {
                display: 'none'
            },
            '#playButton, #connectButton': {
                display: 'inline-block',
                height: 'auto',
                zIndex: '30'
            },
            'img#playButton': {
                maxWidth: '241px',
                width: '10%'
            },
            '#uiInteraction': {
                position: 'fixed'
            },
            '#UIInteractionButtonBoundary': {
                padding: '2px'
            },
            '#UIInteractionButton': {
                cursor: 'pointer'
            },
            '.btn-overlay': {
                verticalAlign: 'middle',
                display: 'inline-block'
            },
            '.tgl-switch': {
                verticalAlign: 'middle',
                display: 'inline-block'
            },
            '.tgl-switch .tgl': {
                display: 'none'
            },
            '.tgl, .tgl:after, .tgl:before, .tgl *, .tgl *:after, .tgl *:before, .tgl+.tgl-slider': {
                '-webkit-box-sizing': 'border-box',
                boxSizing: 'border-box'
            },
            '.tgl::-moz-selection, .tgl:after::-moz-selection, .tgl:before::-moz-selection, .tgl *::-moz-selection, .tgl *:after::-moz-selection, .tgl *:before::-moz-selection, .tgl+.tgl-slider::-moz-selection': {
                background: 'none'
            },
            '.tgl::selection, .tgl:after::selection, .tgl:before::selection, .tgl *::selection, .tgl *:after::selection, .tgl *:before::selection, .tgl+.tgl-slider::selection': {
                background: 'none'
            },
            '.tgl-slider': {},
            '.tgl+.tgl-slider': {
                outline: '0',
                display: 'block',
                width: '40px',
                height: '18px',
                position: 'relative',
                cursor: 'pointer',
                userSelect: 'none'
            },
            '.tgl+.tgl-slider:after, .tgl+.tgl-slider:before': {
                position: 'relative',
                display: 'block',
                content: '""',
                width: '50%',
                height: '100%'
            },
            '.tgl+.tgl-slider:after': {
                left: '0'
            },
            '.tgl+.tgl-slider:before': {
                display: 'none'
            },
            '.tgl-flat+.tgl-slider': {
                padding: '2px',
                '-webkit-transition': 'all .2s ease',
                transition: 'all .2s ease',
                background: 'var(--color6)',
                border: '3px solid var(--color7)',
                borderRadius: '2em'
            },
            '.tgl-flat+.tgl-slider:after': {
                '-webkit-transition': 'all .2s ease',
                transition: 'all .2s ease',
                background: 'var(--color7)',
                content: '""',
                borderRadius: '1em'
            },
            '.tgl-flat:checked+.tgl-slider': {
                border: '3px solid var(--color3)'
            },
            '.tgl-flat:checked+.tgl-slider:after': {
                left: '50%',
                background: 'var(--color3)'
            },
            '.btn-apply': {
                display: 'block !important',
                marginLeft: 'auto',
                marginRight: 'auto',
                width: '40%'
            },
            '.form-control': {
                backgroundColor: 'var(--color7)',
                border: '2px solid var(--color7)',
                borderRadius: '4px',
                color: 'var(--color2)',
                textAlign: 'right',
                fontFamily: 'inherit'
            },
            '.form-control:hover': {
                borderColor: 'var(--color7)'
            },
            '.form-group': {
                paddingTop: '4px',
                display: 'grid',
                gridTemplateColumns: '80% 20%',
                rowGap: '4px',
                paddingRight: '10px',
                paddingLeft: '10px'
            },
            '.form-group label': {
                verticalAlign: 'middle',
                fontWeight: 'normal'
            },
            '.settingsContainer': {
                display: 'flex',
                flexDirection: 'column',
                borderBottom: '1px solid var(--color7)',
                paddingTop: '10px',
                paddingBottom: '10px'
            },
            '.settingsContainer> :first-child': {
                marginTop: '4px',
                marginBottom: '4px',
                fontWeight: 'bold',
                justifyContent: 'space-between',
                display: 'flex',
                flexDirection: 'row',
                alignItems: 'baseline'
            },
            '.collapse': {
                paddingLeft: '5%'
            },
            '#streamTools': {
                borderBottomRightRadius: '5px',
                borderBottomLeftRadius: '5px',
                userSelect: 'none',
                position: 'absolute',
                top: '0',
                right: '2%',
                zIndex: '100',
                border: '4px solid var(--colour8)',
                borderTopWidth: '0px'
            },
            '.settingsHeader': {
                fontStyle: 'italic'
            },
            '#streamToolsHeader': {
                display: 'flex',
                flexDirection: 'row',
                justifyContent: 'space-between',
                borderBottom: '1px solid var(--colour8)',
                backgroundColor: 'var(--color7)'
            },
            '.streamTools': {
                backgroundColor: 'var(--color2)',
                fontFamily: 'var(--buttonFont)',
                fontWeight: 'lighter',
                color: 'var(--color7)'
            },
            '.streamTools-shown>#streamToolsSettings, .streamTools-shown>#streamToolsStats': {
                display: 'block'
            },
            '#streamToolsToggle': {
                width: '100%'
            },
            '#qualityStatus': {
                fontSize: '37px',
                paddingRight: '4px'
            },
            '.svgIcon': {
                fill: 'var(--color2)'
            },
            '.modal': {
                minWidth: '100vw',
                minHeight: '100vh',
                left: '0',
                top: '0',
                position: 'fixed',
                display: 'flex',
                flexDirection: 'column',
                justifyContent: 'center',
                alignItems: 'center',
                color: 'var(--color2)'
            },
            '.innerModal': {
                position: 'relative',
                width: '500px',
                height: '300px',
                backgroundColor: 'var(--color0)',
                display: 'flex',
                flexDirection: 'column',
                justifyContent: 'space-between',
                alignItems: 'center',
                borderRadius: '0.75em'
            },
            '.modalBtnContainer': {
                display: 'flex',
                flexDirection: 'row',
                justifyContent: 'space-around',
                width: '100%',
                paddingTop: '1em',
                paddingBottom: '1em'
            },
            '.modalTextArea': {
                textAlign: 'left',
                width: '95%',
                height: '100%',
                resize: 'none',
                fontSize: '1rem',
                border: '1px solid var(--color2)'
            },
            '.modalTextArea:focus-visible': {
                outline: 'none !important',
                border: '1px solid var(--color3)'
            },
            '.modal .btn-flat': {
                fontSize: '1.0rem'
            }
        };
        const { customStyles, lightModePalette, darkModePalette, jssInsertionPoint } = options !== null && options !== void 0 ? options : {};
        // One time setup with default plugins and settings.
        const jssOptions = {
            // JSS has many interesting plugins we may wish to turn on
            //plugins: [functions(), template(), global(), extend(), nested(), compose(), camelCase(), defaultUnit(options.defaultUnit), expand(), vendorPrefixer(), propsSort()]
            plugins: [(0,jss_plugin_global__WEBPACK_IMPORTED_MODULE_0__["default"])(), (0,jss_plugin_camel_case__WEBPACK_IMPORTED_MODULE_1__["default"])()],
            insertionPoint: jssInsertionPoint
        };
        jss__WEBPACK_IMPORTED_MODULE_2__["default"].setup(jssOptions);
        this.customStyles = customStyles;
        this.lightModePalette = lightModePalette !== null && lightModePalette !== void 0 ? lightModePalette : this.defaultLightModePalette;
        this.darkModePalette = darkModePalette !== null && darkModePalette !== void 0 ? darkModePalette : this.defaultDarkModePalette;
    }
    applyStyleSheet() {
        // Todo: refactor codebase to use jss at a component level, classes can be grabbed like so:
        //const {pixelStreamingClasses} = jss.createStyleSheet(styles).attach();
        // attach generated style sheet to page
        jss__WEBPACK_IMPORTED_MODULE_2__["default"].createStyleSheet({
            '@global': Object.assign(Object.assign({}, this.defaultStyles), this.customStyles)
        }).attach();
    }
    applyPalette(palette) {
        const rootElement = document.querySelector(':root');
        rootElement.style.setProperty('--color0', palette['--color0']);
        rootElement.style.setProperty('--color1', palette['--color1']);
        rootElement.style.setProperty('--color2', palette['--color2']);
        rootElement.style.setProperty('--color3', palette['--color3']);
        rootElement.style.setProperty('--color4', palette['--color4']);
        rootElement.style.setProperty('--color5', palette['--color5']);
        rootElement.style.setProperty('--color6', palette['--color6']);
        rootElement.style.setProperty('--color7', palette['--color7']);
    }
    /**
     * Update the players color variables
     * @param isLightMode - should we use a light or dark color scheme
     */
    setColorMode(isLightMode) {
        if (isLightMode) {
            this.applyPalette(this.lightModePalette);
        }
        else {
            this.applyPalette(this.darkModePalette);
        }
    }
}
//# sourceMappingURL=PixelStreamingApplicationStyles.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/Controls.js":
/*!************************************************!*\
  !*** ../../ui-library/dist/esm/UI/Controls.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Controls: () => (/* binding */ Controls)
/* harmony export */ });
/* harmony import */ var _FullscreenIcon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FullscreenIcon */ "../../ui-library/dist/esm/UI/FullscreenIcon.js");
/* harmony import */ var _SettingsIcon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SettingsIcon */ "../../ui-library/dist/esm/UI/SettingsIcon.js");
/* harmony import */ var _StatsIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StatsIcon */ "../../ui-library/dist/esm/UI/StatsIcon.js");
/* harmony import */ var _XRIcon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./XRIcon */ "../../ui-library/dist/esm/UI/XRIcon.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/WebXR/WebXRController.js");
/* harmony import */ var _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../UI/UIConfigurationTypes */ "../../ui-library/dist/esm/UI/UIConfigurationTypes.js");
// Copyright Epic Games, Inc. All Rights Reserved.






// If there isn't a type provided, default behaviour is to create the element.
function shouldCreateButton(type) {
    return type == undefined ? true : type.creationMode === _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.UIElementCreationMode.CreateDefaultElement;
}
/**
 * Element containing various controls like stats, settings, fullscreen.
 */
class Controls {
    /**
     * Construct the controls
     */
    constructor(config) {
        this.config = config;
        if (!config || shouldCreateButton(config.statsButtonType)) {
            this.statsIcon = new _StatsIcon__WEBPACK_IMPORTED_MODULE_1__.StatsIcon();
        }
        if (!config || shouldCreateButton(config.settingsButtonType)) {
            this.settingsIcon = new _SettingsIcon__WEBPACK_IMPORTED_MODULE_2__.SettingsIcon();
        }
        if (!config || shouldCreateButton(config.fullscreenButtonType)) {
            this.fullscreenIcon = new _FullscreenIcon__WEBPACK_IMPORTED_MODULE_3__.FullScreenIcon();
        }
        if (!config || shouldCreateButton(config.xrIconType)) {
            this.xrIcon = new _XRIcon__WEBPACK_IMPORTED_MODULE_4__.XRIcon();
        }
    }
    /**
     * Get the element containing the controls.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('div');
            this._rootElement.id = 'controls';
            if (this.fullscreenIcon) {
                this._rootElement.appendChild(this.fullscreenIcon.rootElement);
            }
            if (this.settingsIcon) {
                this._rootElement.appendChild(this.settingsIcon.rootElement);
            }
            if (this.statsIcon) {
                this._rootElement.appendChild(this.statsIcon.rootElement);
            }
            if (this.xrIcon) {
                void _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.WebXRController.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        this._rootElement.appendChild(this.xrIcon.rootElement);
                    }
                });
            }
            document.addEventListener('fullscreenchange', this.handleFullscreenChange.bind(this));
        }
        return this._rootElement;
    }
    handleFullscreenChange() {
        var _a;
        const isInFullscreen = !!document.fullscreenElement;
        if (isInFullscreen && ((_a = this.config) === null || _a === void 0 ? void 0 : _a.hideControlsInFullscreen)) {
            this._rootElement.style.visibility = 'hidden';
        }
        else {
            this._rootElement.style.visibility = 'visible';
        }
    }
}
//# sourceMappingURL=Controls.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/DataChannelLatencyTest.js":
/*!**************************************************************!*\
  !*** ../../ui-library/dist/esm/UI/DataChannelLatencyTest.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataChannelLatencyTest: () => (/* binding */ DataChannelLatencyTest)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UIConfigurationTypes */ "../../ui-library/dist/esm/UI/UIConfigurationTypes.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * DataChannel Latency test UI elements and results handling.
 */
class DataChannelLatencyTest {
    /**
     * Get the button containing the stats icon.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('section');
            this._rootElement.classList.add('settingsContainer');
            // make heading
            const heading = document.createElement('div');
            heading.id = 'dataChannelLatencyTestHeader';
            heading.classList.add('settings-text');
            heading.classList.add('settingsHeader');
            this._rootElement.appendChild(heading);
            const headingText = document.createElement('div');
            headingText.innerHTML = _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.StatsSections.DataChannelLatencyTest;
            heading.appendChild(headingText);
            heading.appendChild(this.latencyTestButton);
            // make test results element
            const resultsParentElem = document.createElement('div');
            resultsParentElem.id = 'dataChannelLatencyTestContainer';
            resultsParentElem.classList.add('d-none');
            this._rootElement.appendChild(resultsParentElem);
            resultsParentElem.appendChild(this.latencyTestResultsElement);
        }
        return this._rootElement;
    }
    get latencyTestResultsElement() {
        if (!this._latencyTestResultsElement) {
            this._latencyTestResultsElement = document.createElement('div');
            this._latencyTestResultsElement.id = 'dataChannelLatencyStatsResults';
            this._latencyTestResultsElement.classList.add('StatsResult');
        }
        return this._latencyTestResultsElement;
    }
    get latencyTestButton() {
        if (!this._latencyTestButton) {
            this._latencyTestButton = document.createElement('input');
            this._latencyTestButton.type = 'button';
            this._latencyTestButton.value = 'Run Test';
            this._latencyTestButton.id = 'btn-start-data-channel-latency-test';
            this._latencyTestButton.classList.add('streamTools-button');
            this._latencyTestButton.classList.add('btn-flat');
        }
        return this._latencyTestButton;
    }
    /**
     * Populate the UI based on the latency test's results.
     * @param result - The latency test results.
     */
    handleTestResult(result) {
        _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(JSON.stringify(result));
        /**
         * Check we have results, NaN would mean that UE version we talk to doesn't support our test
         */
        if (isNaN(result.dataChannelRtt)) {
            this.latencyTestResultsElement.innerHTML = '<div>Not supported</div>';
            return;
        }
        let latencyStatsInnerHTML = '';
        latencyStatsInnerHTML += '<div>Data channel RTT (ms): ' + result.dataChannelRtt + '</div>';
        /**
         * Separate path time discovery works only when UE and Player clocks have been synchronized.
         */
        if (result.playerToStreamerTime >= 0 && result.streamerToPlayerTime >= 0) {
            latencyStatsInnerHTML +=
                '<div>Player to Streamer path (ms): ' + result.playerToStreamerTime + '</div>';
            latencyStatsInnerHTML +=
                '<div>Streamer to Player path (ms): ' + result.streamerToPlayerTime + '</div>';
        }
        this.latencyTestResultsElement.innerHTML = latencyStatsInnerHTML;
        //setup button to download the detailed results
        const downloadButton = document.createElement('input');
        downloadButton.type = 'button';
        downloadButton.value = 'Download';
        downloadButton.classList.add('streamTools-button');
        downloadButton.classList.add('btn-flat');
        downloadButton.onclick = () => {
            const file = new Blob([result.exportLatencyAsCSV()], { type: 'text/plain' });
            const a = document.createElement('a');
            const url = URL.createObjectURL(file);
            a.href = url;
            a.download = 'data_channel_latency_test_results.csv';
            document.body.appendChild(a);
            a.click();
            setTimeout(function () {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 0);
        };
        this.latencyTestResultsElement.appendChild(downloadButton);
    }
    handleTestStart() {
        this.latencyTestResultsElement.innerHTML = '<div>Test in progress</div>';
    }
}
//# sourceMappingURL=DataChannelLatencyTest.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/EditTextModal.js":
/*!*****************************************************!*\
  !*** ../../ui-library/dist/esm/UI/EditTextModal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EditConfirmedEvent: () => (/* binding */ EditConfirmedEvent),
/* harmony export */   EditTextModal: () => (/* binding */ EditTextModal)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
// Event fired when "Confirm" button is clicked
class EditConfirmedEvent extends CustomEvent {
    constructor(confirmedText) {
        super('editConfirmed', {
            detail: confirmedText,
            bubbles: true,
            cancelable: true
        });
        this.confirmedText = confirmedText;
    }
}
/**
 * A modal that is shown when a UE widget is touched on mobile.
 * or
 * A hidden (offscreen) input field that is shown on non-touch devices (e.g. Desktop)
 * when a UE widget is clicked. The hidden text field is used so non-latin character
 * input can be composed using IME assistance (which requires an input field).
 *
 * The reason this modal is required is that on mobile typing uses
 * an on-screen keyboard, which requires a valid input text area/input
 * to be focused to summon it. Therefore we show this modal which has
 * the contents of the UE widget, populate its text area with the contents
 * of the UE widget, then focus the text area to finally summon the native
 * on-screen keyboard.
 *
 * The modal also contains:
 * 1) A cancel button - this closes the modal
 * 2) A confirm button - this submits the edit back to the UE side
 */
class EditTextModal {
    constructor() {
        this._rootElement = this.rootElement;
        this._events = new EventTarget();
    }
    // Bind to this if you want to handle edit confirmed
    get events() {
        return this._events;
    }
    showModal(existingTextAreaContents) {
        if (existingTextAreaContents) {
            // Remove any null terminators from the string
            existingTextAreaContents = existingTextAreaContents.replace(/\0/g, '');
            this.textArea.value = existingTextAreaContents;
        }
        // Bring focus to the text area.
        // This will make the on-screen keyboard show if we are
        // a device that has a native on-screen keyboard.
        // If we are on a non-touch device this will give IME a valid
        // input field to work with.
        this.textArea.focus();
        // Put cursor to the end of the textarea
        this.textArea.selectionStart = this.textArea.value.length;
    }
    /**
     * Get the root element that contains either the modal (mobile) or hidden text input (desktop)
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('div');
            this._rootElement.classList.add('modal');
            this._rootElement.appendChild(this.innerModal);
        }
        return this._rootElement;
    }
    get innerModal() {
        if (!this._innerModal) {
            this._innerModal = document.createElement('div');
            this._innerModal.classList.add('innerModal');
            this._innerModal.appendChild(this.editTextHeading);
            this._innerModal.appendChild(this.textArea);
            this._innerModal.appendChild(this.modalBtnContainer);
        }
        return this._innerModal;
    }
    get editTextHeading() {
        if (!this._editTextHeading) {
            this._editTextHeading = document.createElement('h2');
            this._editTextHeading.innerText = 'Edit Text';
        }
        return this._editTextHeading;
    }
    get textArea() {
        if (!this._textArea) {
            this._textArea = document.createElement('textarea');
            this._textArea.classList.add('form-control');
            this._textArea.classList.add('modalTextArea');
            this._textArea.title = 'Edit Text Area';
            this._textArea.placeholder = 'UE text widget value here...';
            // When keyboard is typed into we want to ensure keys are not sent back to UE until we confirm.
            this.textArea.addEventListener('keypress', (event) => {
                event.stopPropagation();
            });
            this.textArea.addEventListener('keyup', (event) => {
                event.stopPropagation();
            });
            this.textArea.addEventListener('keydown', (event) => {
                event.stopPropagation();
            });
            this.textArea.addEventListener('compositionend', (event) => {
                event.stopPropagation();
            });
        }
        return this._textArea;
    }
    get modalBtnContainer() {
        if (!this._modalBtnContainer) {
            this._modalBtnContainer = document.createElement('div');
            this._modalBtnContainer.classList.add('modalBtnContainer');
            this._modalBtnContainer.appendChild(this.cancelBtn);
            this._modalBtnContainer.appendChild(this.confirmBtn);
        }
        return this._modalBtnContainer;
    }
    get cancelBtn() {
        if (!this._cancelBtn) {
            this._cancelBtn = document.createElement('button');
            this._cancelBtn.classList.add('btn-flat');
            this._cancelBtn.innerText = 'Cancel';
            // When cancel is clicked, remove this modal from the DOM
            this._cancelBtn.addEventListener('click', (event) => {
                this.rootElement.remove();
                // Ensure the click/tap does not go back to UE
                event.stopPropagation();
            });
        }
        return this._cancelBtn;
    }
    get confirmBtn() {
        if (!this._confirmBtn) {
            this._confirmBtn = document.createElement('button');
            this._confirmBtn.classList.add('btn-flat');
            this._confirmBtn.innerText = 'Confirm';
            // When confirm is clicked, remove from DOM and send the contents of textarea to UE
            this._confirmBtn.addEventListener('click', (event) => {
                this.events.dispatchEvent(new EditConfirmedEvent(this.textArea.value));
                this.rootElement.remove();
                // Ensure the click/tap does not go back to UE
                event.stopPropagation();
            });
        }
        return this._confirmBtn;
    }
}
//# sourceMappingURL=EditTextModal.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/FullscreenIcon.js":
/*!******************************************************!*\
  !*** ../../ui-library/dist/esm/UI/FullscreenIcon.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FullScreenIcon: () => (/* binding */ FullScreenIcon),
/* harmony export */   FullScreenIconBase: () => (/* binding */ FullScreenIconBase),
/* harmony export */   FullScreenIconExternal: () => (/* binding */ FullScreenIconExternal)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Base class for an element (i.e. button) that, when clicked, will toggle fullscreen of a given element.
 * Can be initialized with any HTMLElement, if it is set as rootElement in the constructor.
 */
class FullScreenIconBase {
    get rootElement() {
        return this._rootElement;
    }
    set rootElement(element) {
        element.onclick = () => this.toggleFullscreen();
        this._rootElement = element;
    }
    constructor() {
        this.isFullscreen = false;
        // set up the full screen events
        document.addEventListener('webkitfullscreenchange', () => this.onFullscreenChange(), false);
        document.addEventListener('mozfullscreenchange', () => this.onFullscreenChange(), false);
        document.addEventListener('fullscreenchange', () => this.onFullscreenChange(), false);
        document.addEventListener('MSFullscreenChange', () => this.onFullscreenChange(), false);
    }
    /**
     * Makes the document or fullscreenElement fullscreen.
     */
    toggleFullscreen() {
        // if already full screen; exit
        // else go fullscreen
        if (document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement) {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
            else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            }
            else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            }
            else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }
        else {
            const element = this.fullscreenElement;
            if (!element) {
                return;
            }
            if (element.requestFullscreen) {
                element.requestFullscreen();
            }
            else if (element.mozRequestFullscreen) {
                element.mozRequestFullscreen();
            }
            else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen();
            }
            else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            }
            else if (element.webkitEnterFullscreen) {
                element.webkitEnterFullscreen(); //for iphone this code worked
            }
        }
        this.onFullscreenChange();
    }
    /**
     * Handles the fullscreen button on change
     */
    onFullscreenChange() {
        this.isFullscreen =
            document.webkitIsFullScreen ||
                document.mozFullScreen ||
                (document.msFullscreenElement && document.msFullscreenElement !== null) ||
                (document.fullscreenElement && document.fullscreenElement !== null);
    }
}
/**
 * An implementation of FullScreenIconBase that uses an externally
 * provided HTMLElement for toggling full screen.
 */
class FullScreenIconExternal extends FullScreenIconBase {
    constructor(externalButton) {
        super();
        this.rootElement = externalButton;
    }
}
/**
 * The default fullscreen icon that contains a button and svgs for each state.
 */
class FullScreenIcon extends FullScreenIconBase {
    constructor() {
        super();
        const createdButton = document.createElement('button');
        createdButton.type = 'button';
        createdButton.classList.add('UiTool');
        createdButton.id = 'fullscreen-btn';
        createdButton.appendChild(this.maximizeIcon);
        createdButton.appendChild(this.minimizeIcon);
        createdButton.appendChild(this.tooltipText);
        this.rootElement = createdButton;
    }
    get tooltipText() {
        if (!this._tooltipText) {
            this._tooltipText = document.createElement('span');
            this._tooltipText.classList.add('tooltiptext');
            this._tooltipText.innerHTML = 'Fullscreen';
        }
        return this._tooltipText;
    }
    get maximizeIcon() {
        if (!this._maximizeIcon) {
            this._maximizeIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._maximizeIcon.setAttributeNS(null, 'id', 'maximizeIcon');
            this._maximizeIcon.setAttributeNS(null, 'x', '0px');
            this._maximizeIcon.setAttributeNS(null, 'y', '0px');
            this._maximizeIcon.setAttributeNS(null, 'viewBox', '0 0 384.97 384.97');
            // create svg group for the paths
            const svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svgGroup.classList.add('svgIcon');
            this._maximizeIcon.appendChild(svgGroup);
            // create paths for the icon itself, one for each corner
            const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path1.setAttributeNS(null, 'd', 'M384.97,12.03c0-6.713-5.317-12.03-12.03-12.03H264.847c-6.833,0-11.922,5.39-11.934,12.223c0,6.821,5.101,11.838,11.934,11.838h96.062l-0.193,96.519c0,6.833,5.197,12.03,12.03,12.03c6.833-0.012,12.03-5.197,12.03-12.03l0.193-108.369c0-0.036-0.012-0.06-0.012-0.084C384.958,12.09,384.97,12.066,384.97,12.03z');
            const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path2.setAttributeNS(null, 'd', 'M120.496,0H12.403c-0.036,0-0.06,0.012-0.096,0.012C12.283,0.012,12.247,0,12.223,0C5.51,0,0.192,5.317,0.192,12.03L0,120.399c0,6.833,5.39,11.934,12.223,11.934c6.821,0,11.838-5.101,11.838-11.934l0.192-96.339h96.242c6.833,0,12.03-5.197,12.03-12.03C132.514,5.197,127.317,0,120.496,0z');
            const path3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path3.setAttributeNS(null, 'd', 'M120.123,360.909H24.061v-96.242c0-6.833-5.197-12.03-12.03-12.03S0,257.833,0,264.667v108.092c0,0.036,0.012,0.06,0.012,0.084c0,0.036-0.012,0.06-0.012,0.096c0,6.713,5.317,12.03,12.03,12.03h108.092c6.833,0,11.922-5.39,11.934-12.223C132.057,365.926,126.956,360.909,120.123,360.909z');
            const path4 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path4.setAttributeNS(null, 'd', 'M372.747,252.913c-6.833,0-11.85,5.101-11.838,11.934v96.062h-96.242c-6.833,0-12.03,5.197-12.03,12.03s5.197,12.03,12.03,12.03h108.092c0.036,0,0.06-0.012,0.084-0.012c0.036-0.012,0.06,0.012,0.096,0.012c6.713,0,12.03-5.317,12.03-12.03V264.847C384.97,258.014,379.58,252.913,372.747,252.913z');
            svgGroup.appendChild(path1);
            svgGroup.appendChild(path2);
            svgGroup.appendChild(path3);
            svgGroup.appendChild(path4);
        }
        return this._maximizeIcon;
    }
    get minimizeIcon() {
        if (!this._minimizeIcon) {
            this._minimizeIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._minimizeIcon.setAttributeNS(null, 'id', 'minimizeIcon');
            this._minimizeIcon.setAttributeNS(null, 'x', '0px');
            this._minimizeIcon.setAttributeNS(null, 'y', '0px');
            this._minimizeIcon.setAttributeNS(null, 'viewBox', '0 0 385.331 385.331');
            // create svg group for the paths
            const svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svgGroup.classList.add('svgIcon');
            this._minimizeIcon.appendChild(svgGroup);
            // create paths for the icon itself, one for each corner
            const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path1.setAttributeNS(null, 'd', 'M264.943,156.665h108.273c6.833,0,11.934-5.39,11.934-12.211c0-6.833-5.101-11.85-11.934-11.838h-96.242V36.181c0-6.833-5.197-12.03-12.03-12.03s-12.03,5.197-12.03,12.03v108.273c0,0.036,0.012,0.06,0.012,0.084c0,0.036-0.012,0.06-0.012,0.096C252.913,151.347,258.23,156.677,264.943,156.665z');
            const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path2.setAttributeNS(null, 'd', 'M120.291,24.247c-6.821,0-11.838,5.113-11.838,11.934v96.242H12.03c-6.833,0-12.03,5.197-12.03,12.03c0,6.833,5.197,12.03,12.03,12.03h108.273c0.036,0,0.06-0.012,0.084-0.012c0.036,0,0.06,0.012,0.096,0.012c6.713,0,12.03-5.317,12.03-12.03V36.181C132.514,29.36,127.124,24.259,120.291,24.247z');
            const path3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path3.setAttributeNS(null, 'd', 'M120.387,228.666H12.115c-6.833,0.012-11.934,5.39-11.934,12.223c0,6.833,5.101,11.85,11.934,11.838h96.242v96.423c0,6.833,5.197,12.03,12.03,12.03c6.833,0,12.03-5.197,12.03-12.03V240.877c0-0.036-0.012-0.06-0.012-0.084c0-0.036,0.012-0.06,0.012-0.096C132.418,233.983,127.1,228.666,120.387,228.666z');
            const path4 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path4.setAttributeNS(null, 'd', 'M373.3,228.666H265.028c-0.036,0-0.06,0.012-0.084,0.012c-0.036,0-0.06-0.012-0.096-0.012c-6.713,0-12.03,5.317-12.03,12.03v108.273c0,6.833,5.39,11.922,12.223,11.934c6.821,0.012,11.838-5.101,11.838-11.922v-96.242H373.3c6.833,0,12.03-5.197,12.03-12.03S380.134,228.678,373.3,228.666z');
            svgGroup.appendChild(path1);
            svgGroup.appendChild(path2);
            svgGroup.appendChild(path3);
            svgGroup.appendChild(path4);
        }
        return this._minimizeIcon;
    }
    onFullscreenChange() {
        super.onFullscreenChange();
        const minimize = this.minimizeIcon;
        const maximize = this.maximizeIcon;
        if (this.isFullscreen) {
            minimize.style.display = 'inline';
            //ios disappearing svg fix
            minimize.style.transform = 'translate(0, 0)';
            maximize.style.display = 'none';
        }
        else {
            minimize.style.display = 'none';
            maximize.style.display = 'inline';
            //ios disappearing svg fix
            maximize.style.transform = 'translate(0, 0)';
        }
    }
}
//# sourceMappingURL=FullscreenIcon.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/LabelledButton.js":
/*!******************************************************!*\
  !*** ../../ui-library/dist/esm/UI/LabelledButton.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LabelledButton: () => (/* binding */ LabelledButton)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * A button with a text label beside it.
 */
class LabelledButton {
    constructor(label, buttonText) {
        this._label = label;
        this._buttonText = buttonText;
    }
    /**
     * Add a click listener to the button element.
     */
    addOnClickListener(onClickFunc) {
        this.button.addEventListener('click', onClickFunc);
    }
    /**
     * Get the HTMLInputElement for the button.
     */
    get button() {
        if (!this._button) {
            this._button = document.createElement('input');
            this._button.type = 'button';
            this._button.value = this._buttonText;
            this._button.classList.add('overlay-button');
            this._button.classList.add('btn-flat');
        }
        return this._button;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            // create root div with "setting" css class
            this._rootElement = document.createElement('div');
            this._rootElement.classList.add('setting');
            // create div element to contain our setting's text
            const settingsTextElem = document.createElement('div');
            settingsTextElem.innerText = this._label;
            this._rootElement.appendChild(settingsTextElem);
            // create label element to wrap out input type
            const wrapperLabel = document.createElement('label');
            wrapperLabel.classList.add('btn-overlay');
            this._rootElement.appendChild(wrapperLabel);
            wrapperLabel.appendChild(this.button);
        }
        return this._rootElement;
    }
}
//# sourceMappingURL=LabelledButton.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/LatencyTest.js":
/*!***************************************************!*\
  !*** ../../ui-library/dist/esm/UI/LatencyTest.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LatencyTest: () => (/* binding */ LatencyTest)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UIConfigurationTypes */ "../../ui-library/dist/esm/UI/UIConfigurationTypes.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * Latency test UI elements and results handling.
 */
class LatencyTest {
    /**
     * Get the the button containing the stats icon.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('section');
            this._rootElement.classList.add('settingsContainer');
            // make heading
            const heading = document.createElement('div');
            heading.id = 'latencyTestHeader';
            heading.classList.add('settings-text');
            heading.classList.add('settingsHeader');
            this._rootElement.appendChild(heading);
            const headingText = document.createElement('div');
            headingText.innerHTML = _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.StatsSections.LatencyTest;
            heading.appendChild(headingText);
            heading.appendChild(this.latencyTestButton);
            // make test results element
            const resultsParentElem = document.createElement('div');
            resultsParentElem.id = 'latencyTestContainer';
            resultsParentElem.classList.add('d-none');
            this._rootElement.appendChild(resultsParentElem);
            resultsParentElem.appendChild(this.latencyTestResultsElement);
        }
        return this._rootElement;
    }
    get latencyTestResultsElement() {
        if (!this._latencyTestResultsElement) {
            this._latencyTestResultsElement = document.createElement('div');
            this._latencyTestResultsElement.id = 'latencyStatsResults';
            this._latencyTestResultsElement.classList.add('StatsResult');
        }
        return this._latencyTestResultsElement;
    }
    get latencyTestButton() {
        if (!this._latencyTestButton) {
            this._latencyTestButton = document.createElement('input');
            this._latencyTestButton.type = 'button';
            this._latencyTestButton.value = 'Run Test';
            this._latencyTestButton.id = 'btn-start-latency-test';
            this._latencyTestButton.classList.add('streamTools-button');
            this._latencyTestButton.classList.add('btn-flat');
        }
        return this._latencyTestButton;
    }
    /**
     * Populate the UI based on the latency test's results.
     * @param latencyTimings - The latency test results.
     */
    handleTestResult(latencyTimings) {
        _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(JSON.stringify(latencyTimings));
        let latencyStatsInnerHTML = '';
        if (latencyTimings.networkLatency !== undefined && latencyTimings.networkLatency > 0) {
            latencyStatsInnerHTML += '<div>Net latency RTT (ms): ' + latencyTimings.networkLatency + '</div>';
        }
        if (latencyTimings.EncodeMs !== undefined && latencyTimings.EncodeMs > 0) {
            latencyStatsInnerHTML += '<div>UE Encode (ms): ' + latencyTimings.EncodeMs + '</div>';
        }
        if (latencyTimings.CaptureToSendMs !== undefined && latencyTimings.CaptureToSendMs > 0) {
            latencyStatsInnerHTML += '<div>UE Capture (ms): ' + latencyTimings.CaptureToSendMs + '</div>';
        }
        if (latencyTimings.browserSendLatency !== undefined && latencyTimings.browserSendLatency > 0) {
            latencyStatsInnerHTML +=
                '<div>Browser send latency (ms): ' + latencyTimings.browserSendLatency + '</div>';
        }
        if (latencyTimings.frameDisplayDeltaTimeMs !== undefined &&
            latencyTimings.browserReceiptTimeMs !== undefined) {
            latencyStatsInnerHTML +=
                latencyTimings.frameDisplayDeltaTimeMs && latencyTimings.browserReceiptTimeMs
                    ? '<div>Browser receive latency (ms): ' +
                        latencyTimings.frameDisplayDeltaTimeMs +
                        '</div>'
                    : '';
        }
        if (latencyTimings.latencyExcludingDecode !== undefined) {
            latencyStatsInnerHTML +=
                '<div>Total latency (excluding browser) (ms): ' +
                    latencyTimings.latencyExcludingDecode +
                    '</div>';
        }
        if (latencyTimings.endToEndLatency !== undefined) {
            latencyStatsInnerHTML += latencyTimings.endToEndLatency
                ? '<div>Total latency (ms): ' + latencyTimings.endToEndLatency + '</div>'
                : '';
        }
        this.latencyTestResultsElement.innerHTML = latencyStatsInnerHTML;
    }
}
//# sourceMappingURL=LatencyTest.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/SessionTest.js":
/*!***************************************************!*\
  !*** ../../ui-library/dist/esm/UI/SessionTest.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SessionTest: () => (/* binding */ SessionTest)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/Config/SettingNumber.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Config_SettingUINumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Config/SettingUINumber */ "../../ui-library/dist/esm/Config/SettingUINumber.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * Session test UI elements and results handling.
 * Creates a button to start the test and collects stats and latency info during the test.
 * After the test is finished, it generates CSV files for stats and latency info.
 * The test runs for a specified time frame, which can be set in the UI.
 */
class SessionTest {
    constructor() {
        this.isCollectingStats = false;
    }
    /**
     * Make the elements for the session test: e.g. button and test time input.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('section');
            this._rootElement.classList.add('settingsContainer');
            // make heading
            const heading = document.createElement('div');
            heading.id = 'latencyTestHeader';
            heading.classList.add('settings-text');
            heading.classList.add('settingsHeader');
            this._rootElement.appendChild(heading);
            const headingText = document.createElement('div');
            headingText.innerHTML = 'Session Test';
            heading.appendChild(headingText);
            // make test results element
            const resultsParentElem = document.createElement('div');
            resultsParentElem.id = 'latencyTestContainer';
            resultsParentElem.classList.add('d-none');
            this._rootElement.appendChild(resultsParentElem);
            this._testTimeFrameSetting = new _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_0__.SettingNumber('TestTimeFrame', 'Test Time Frame', 'How long the test runs for (seconds)', 0 /*min*/, 3600 /*max*/, 60 /*default*/, false);
            const testTimeFrameSetting = new _Config_SettingUINumber__WEBPACK_IMPORTED_MODULE_1__.SettingUINumber(this._testTimeFrameSetting);
            resultsParentElem.appendChild(testTimeFrameSetting.rootElement);
            resultsParentElem.appendChild(this.latencyTestButton);
        }
        return this._rootElement;
    }
    get latencyTestButton() {
        if (!this._latencyTestButton) {
            this._latencyTestButton = document.createElement('input');
            this._latencyTestButton.type = 'button';
            this._latencyTestButton.value = 'Run Test';
            this._latencyTestButton.id = 'btn-start-latency-test';
            this._latencyTestButton.classList.add('streamTools-button');
            this._latencyTestButton.classList.add('btn-flat');
            this._latencyTestButton.onclick = () => {
                this.records = [];
                this.latencyRecords = [];
                this.isCollectingStats = true;
                this._latencyTestButton.disabled = true;
                this._latencyTestButton.value = 'Running...';
                _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_2__.Logger.Info(`Starting session test. Duration: [${this._testTimeFrameSetting.number}]`);
                setTimeout(() => {
                    this.onCollectingFinished();
                    this._latencyTestButton.disabled = false;
                    this._latencyTestButton.value = 'Run Test';
                }, this._testTimeFrameSetting.number * 1000);
            };
        }
        return this._latencyTestButton;
    }
    handleStats(stats) {
        if (!this.isCollectingStats) {
            return;
        }
        const statsCopy = structuredClone(stats);
        this.records.push(statsCopy);
    }
    handleLatencyInfo(latencyInfo) {
        if (!this.isCollectingStats) {
            return;
        }
        const latencyInfoCopy = structuredClone(latencyInfo);
        this.latencyRecords.push(latencyInfoCopy);
    }
    onCollectingFinished() {
        this.isCollectingStats = false;
        _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_2__.Logger.Info(`Finished session test`);
        this.generateStatsCsv();
        this.generateLatencyCsv();
    }
    generateStatsCsv() {
        const csvHeader = [];
        this.records.forEach((record) => {
            for (const i in record) {
                const obj = record[i];
                if (Array.isArray(obj)) {
                    for (let j = 0; j < obj.length; j++) {
                        const arrayVal = obj[j];
                        for (const k in arrayVal) {
                            if (csvHeader.indexOf(`${i}.${j}.${k}`) === -1) {
                                csvHeader.push(`${i}.${j}.${k}`);
                            }
                        }
                    }
                }
                else if (obj instanceof Map) {
                    for (const j in obj.keys()) {
                        const mapVal = obj.get(j);
                        for (const k in mapVal) {
                            if (csvHeader.indexOf(`${i}.${j}.${k}`) === -1) {
                                csvHeader.push(`${i}.${j}.${k}`);
                            }
                        }
                    }
                }
                else {
                    for (const j in obj) {
                        if (csvHeader.indexOf(`${i}.${j}`) === -1) {
                            csvHeader.push(`${i}.${j}`);
                        }
                    }
                }
            }
        });
        let csvBody = '';
        this.records.forEach((record) => {
            csvHeader.forEach((field) => {
                try {
                    csvBody += `"${field.split('.').reduce((o, k) => o[k], record)}",`;
                }
                catch (_) {
                    csvBody += `"",`;
                }
            });
            csvBody += `\n`;
        });
        const file = new Blob([`${csvHeader.join(',')}\n${csvBody}`], { type: 'text/plain' });
        const a = document.createElement('a');
        const url = URL.createObjectURL(file);
        a.href = url;
        a.download = 'stats.csv';
        document.body.appendChild(a);
        a.click();
        setTimeout(function () {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 0);
    }
    generateLatencyCsv() {
        const csvHeader = [];
        this.latencyRecords.forEach((record) => {
            for (const i in record) {
                const obj = record[i];
                if (typeof obj === 'object') {
                    for (const j in obj) {
                        if (csvHeader.indexOf(`${i}.${j}`) === -1) {
                            csvHeader.push(`${i}.${j}`);
                        }
                    }
                }
                else if (csvHeader.indexOf(`${i}`) === -1) {
                    csvHeader.push(`${i}`);
                }
            }
        });
        let csvBody = '';
        this.latencyRecords.forEach((record) => {
            csvHeader.forEach((field) => {
                try {
                    csvBody += `"${field.split('.').reduce((o, k) => o[k], record)}",`;
                }
                catch (_) {
                    csvBody += `"",`;
                }
            });
            csvBody += `\n`;
        });
        const file = new Blob([`${csvHeader.join(',')}\n${csvBody}`], { type: 'text/plain' });
        const a = document.createElement('a');
        const url = URL.createObjectURL(file);
        a.href = url;
        a.download = 'latency.csv';
        document.body.appendChild(a);
        a.click();
        setTimeout(function () {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 0);
    }
}
//# sourceMappingURL=SessionTest.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/SettingsIcon.js":
/*!****************************************************!*\
  !*** ../../ui-library/dist/esm/UI/SettingsIcon.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingsIcon: () => (/* binding */ SettingsIcon)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Settings icon that can be clicked.
 */
class SettingsIcon {
    /**
     * Get the the button containing the settings icon.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('button');
            this._rootElement.type = 'button';
            this._rootElement.classList.add('UiTool');
            this._rootElement.id = 'settingsBtn';
            this._rootElement.appendChild(this.settingsIcon);
            this._rootElement.appendChild(this.tooltipText);
        }
        return this._rootElement;
    }
    get tooltipText() {
        if (!this._tooltipText) {
            this._tooltipText = document.createElement('span');
            this._tooltipText.classList.add('tooltiptext');
            this._tooltipText.innerHTML = 'Settings';
        }
        return this._tooltipText;
    }
    get settingsIcon() {
        if (!this._settingsIcon) {
            this._settingsIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._settingsIcon.setAttributeNS(null, 'id', 'settingsIcon');
            this._settingsIcon.setAttributeNS(null, 'x', '0px');
            this._settingsIcon.setAttributeNS(null, 'y', '0px');
            this._settingsIcon.setAttributeNS(null, 'viewBox', '0 0 478.703 478.703');
            // create svg group for the paths
            const svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svgGroup.classList.add('svgIcon');
            this._settingsIcon.appendChild(svgGroup);
            // create paths for the icon itself, the inner and out path of a cog
            const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path1.setAttributeNS(null, 'd', 'M454.2,189.101l-33.6-5.7c-3.5-11.3-8-22.2-13.5-32.6l19.8-27.7c8.4-11.8,7.1-27.9-3.2-38.1l-29.8-29.8\
			c-5.6-5.6-13-8.7-20.9-8.7c-6.2,0-12.1,1.9-17.1,5.5l-27.8,19.8c-10.8-5.7-22.1-10.4-33.8-13.9l-5.6-33.2\
			c-2.4-14.3-14.7-24.7-29.2-24.7h-42.1c-14.5,0-26.8,10.4-29.2,24.7l-5.8,34c-11.2,3.5-22.1,8.1-32.5,13.7l-27.5-19.8\
			c-5-3.6-11-5.5-17.2-5.5c-7.9,0-15.4,3.1-20.9,8.7l-29.9,29.8c-10.2,10.2-11.6,26.3-3.2,38.1l20,28.1\
			c-5.5,10.5-9.9,21.4-13.3,32.7l-33.2,5.6c-14.3,2.4-24.7,14.7-24.7,29.2v42.1c0,14.5,10.4,26.8,24.7,29.2l34,5.8\
			c3.5,11.2,8.1,22.1,13.7,32.5l-19.7,27.4c-8.4,11.8-7.1,27.9,3.2,38.1l29.8,29.8c5.6,5.6,13,8.7,20.9,8.7c6.2,0,12.1-1.9,17.1-5.5\
			l28.1-20c10.1,5.3,20.7,9.6,31.6,13l5.6,33.6c2.4,14.3,14.7,24.7,29.2,24.7h42.2c14.5,0,26.8-10.4,29.2-24.7l5.7-33.6\
			c11.3-3.5,22.2-8,32.6-13.5l27.7,19.8c5,3.6,11,5.5,17.2,5.5l0,0c7.9,0,15.3-3.1,20.9-8.7l29.8-29.8c10.2-10.2,11.6-26.3,3.2-38.1\
			l-19.8-27.8c5.5-10.5,10.1-21.4,13.5-32.6l33.6-5.6c14.3-2.4,24.7-14.7,24.7-29.2v-42.1\
			C478.9,203.801,468.5,191.501,454.2,189.101z M451.9,260.401c0,1.3-0.9,2.4-2.2,2.6l-42,7c-5.3,0.9-9.5,4.8-10.8,9.9\
			c-3.8,14.7-9.6,28.8-17.4,41.9c-2.7,4.6-2.5,10.3,0.6,14.7l24.7,34.8c0.7,1,0.6,2.5-0.3,3.4l-29.8,29.8c-0.7,0.7-1.4,0.8-1.9,0.8\
			c-0.6,0-1.1-0.2-1.5-0.5l-34.7-24.7c-4.3-3.1-10.1-3.3-14.7-0.6c-13.1,7.8-27.2,13.6-41.9,17.4c-5.2,1.3-9.1,5.6-9.9,10.8l-7.1,42\
			c-0.2,1.3-1.3,2.2-2.6,2.2h-42.1c-1.3,0-2.4-0.9-2.6-2.2l-7-42c-0.9-5.3-4.8-9.5-9.9-10.8c-14.3-3.7-28.1-9.4-41-16.8\
			c-2.1-1.2-4.5-1.8-6.8-1.8c-2.7,0-5.5,0.8-7.8,2.5l-35,24.9c-0.5,0.3-1,0.5-1.5,0.5c-0.4,0-1.2-0.1-1.9-0.8l-29.8-29.8\
			c-0.9-0.9-1-2.3-0.3-3.4l24.6-34.5c3.1-4.4,3.3-10.2,0.6-14.8c-7.8-13-13.8-27.1-17.6-41.8c-1.4-5.1-5.6-9-10.8-9.9l-42.3-7.2\
			c-1.3-0.2-2.2-1.3-2.2-2.6v-42.1c0-1.3,0.9-2.4,2.2-2.6l41.7-7c5.3-0.9,9.6-4.8,10.9-10c3.7-14.7,9.4-28.9,17.1-42\
			c2.7-4.6,2.4-10.3-0.7-14.6l-24.9-35c-0.7-1-0.6-2.5,0.3-3.4l29.8-29.8c0.7-0.7,1.4-0.8,1.9-0.8c0.6,0,1.1,0.2,1.5,0.5l34.5,24.6\
			c4.4,3.1,10.2,3.3,14.8,0.6c13-7.8,27.1-13.8,41.8-17.6c5.1-1.4,9-5.6,9.9-10.8l7.2-42.3c0.2-1.3,1.3-2.2,2.6-2.2h42.1\
			c1.3,0,2.4,0.9,2.6,2.2l7,41.7c0.9,5.3,4.8,9.6,10,10.9c15.1,3.8,29.5,9.7,42.9,17.6c4.6,2.7,10.3,2.5,14.7-0.6l34.5-24.8\
			c0.5-0.3,1-0.5,1.5-0.5c0.4,0,1.2,0.1,1.9,0.8l29.8,29.8c0.9,0.9,1,2.3,0.3,3.4l-24.7,34.7c-3.1,4.3-3.3,10.1-0.6,14.7\
			c7.8,13.1,13.6,27.2,17.4,41.9c1.3,5.2,5.6,9.1,10.8,9.9l42,7.1c1.3,0.2,2.2,1.3,2.2,2.6v42.1H451.9z');
            const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path2.setAttributeNS(null, 'd', 'M239.4,136.001c-57,0-103.3,46.3-103.3,103.3s46.3,103.3,103.3,103.3s103.3-46.3,103.3-103.3S296.4,136.001,239.4,136.001z M239.4,315.601c-42.1,0-76.3-34.2-76.3-76.3s34.2-76.3,76.3-76.3s76.3,34.2,76.3,76.3S281.5,315.601,239.4,315.601z');
            svgGroup.appendChild(path1);
            svgGroup.appendChild(path2);
        }
        return this._settingsIcon;
    }
}
//# sourceMappingURL=SettingsIcon.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/SettingsPanel.js":
/*!*****************************************************!*\
  !*** ../../ui-library/dist/esm/UI/SettingsPanel.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingsPanel: () => (/* binding */ SettingsPanel)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * A UI component containing all the settings for the application.
 */
class SettingsPanel {
    constructor() {
        this._rootElement = null;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('div');
            this._rootElement.id = 'settings-panel';
            this._rootElement.classList.add('panel-wrap');
            const panelElem = document.createElement('div');
            panelElem.classList.add('panel');
            this._rootElement.appendChild(panelElem);
            const settingsHeading = document.createElement('div');
            settingsHeading.id = 'settingsHeading';
            settingsHeading.textContent = 'Settings';
            panelElem.appendChild(settingsHeading);
            panelElem.appendChild(this.settingsCloseButton);
            panelElem.appendChild(this.settingsContentElement);
        }
        return this._rootElement;
    }
    get settingsContentElement() {
        if (!this._settingsContentElement) {
            this._settingsContentElement = document.createElement('div');
            this._settingsContentElement.id = 'settingsContent';
        }
        return this._settingsContentElement;
    }
    get settingsCloseButton() {
        if (!this._settingsCloseButton) {
            this._settingsCloseButton = document.createElement('div');
            this._settingsCloseButton.id = 'settingsClose';
        }
        return this._settingsCloseButton;
    }
    /**
     * Show settings panel.
     */
    show() {
        if (!this.rootElement.classList.contains('panel-wrap-visible')) {
            this.rootElement.classList.add('panel-wrap-visible');
        }
    }
    /**
     * Toggle the visibility of the settings panel.
     */
    toggleVisibility() {
        this.rootElement.classList.toggle('panel-wrap-visible');
    }
    /**
     * Hide settings panel.
     */
    hide() {
        if (this.rootElement.classList.contains('panel-wrap-visible')) {
            this.rootElement.classList.remove('panel-wrap-visible');
        }
    }
}
//# sourceMappingURL=SettingsPanel.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/StatsIcon.js":
/*!*************************************************!*\
  !*** ../../ui-library/dist/esm/UI/StatsIcon.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StatsIcon: () => (/* binding */ StatsIcon)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Stats icon that can be clicked.
 */
class StatsIcon {
    /**
     * Get the the button containing the stats icon.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('button');
            this._rootElement.type = 'button';
            this._rootElement.classList.add('UiTool');
            this._rootElement.id = 'statsBtn';
            this._rootElement.appendChild(this.statsIcon);
            this._rootElement.appendChild(this.tooltipText);
        }
        return this._rootElement;
    }
    get tooltipText() {
        if (!this._tooltipText) {
            this._tooltipText = document.createElement('span');
            this._tooltipText.classList.add('tooltiptext');
            this._tooltipText.innerHTML = 'Information';
        }
        return this._tooltipText;
    }
    get statsIcon() {
        if (!this._statsIcon) {
            this._statsIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._statsIcon.setAttributeNS(null, 'id', 'statsIcon');
            this._statsIcon.setAttributeNS(null, 'x', '0px');
            this._statsIcon.setAttributeNS(null, 'y', '0px');
            this._statsIcon.setAttributeNS(null, 'viewBox', '0 0 330 330');
            // create svg group for the paths
            const svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svgGroup.classList.add('svgIcon');
            this._statsIcon.appendChild(svgGroup);
            // create paths for the icon itself, the inner and out path of a cog
            const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path1.setAttributeNS(null, 'd', 'M165,0.008C74.019,0.008,0,74.024,0,164.999c0,90.977,74.019,164.992,165,164.992s165-74.015,165-164.992C330,74.024,255.981,0.008,165,0.008z M165,299.992c-74.439,0-135-60.557-135-134.992S90.561,30.008,165,30.008s135,60.557,135,134.991C300,239.436,239.439,299.992,165,299.992z');
            const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path2.setAttributeNS(null, 'd', 'M165,130.008c-8.284,0-15,6.716-15,15v99.983c0,8.284,6.716,15,15,15s15-6.716,15-15v-99.983C180,136.725,173.284,130.008,165,130.008z');
            const path3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path3.setAttributeNS(null, 'd', 'M165,70.011c-3.95,0-7.811,1.6-10.61,4.39c-2.79,2.79-4.39,6.66-4.39,10.61s1.6,7.81,4.39,10.61c2.79,2.79,6.66,4.39,10.61,4.39s7.81-1.6,10.609-4.39c2.79-2.8,4.391-6.66,4.391-10.61s-1.601-7.82-4.391-10.61C172.81,71.61,168.95,70.011,165,70.011z');
            svgGroup.appendChild(path1);
            svgGroup.appendChild(path2);
            svgGroup.appendChild(path3);
        }
        return this._statsIcon;
    }
}
//# sourceMappingURL=StatsIcon.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/StatsPanel.js":
/*!**************************************************!*\
  !*** ../../ui-library/dist/esm/UI/StatsPanel.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Stat: () => (/* binding */ Stat),
/* harmony export */   StatsPanel: () => (/* binding */ StatsPanel)
/* harmony export */ });
/* harmony import */ var _LatencyTest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LatencyTest */ "../../ui-library/dist/esm/UI/LatencyTest.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Util_MathUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Util/MathUtils */ "../../ui-library/dist/esm/Util/MathUtils.js");
/* harmony import */ var _DataChannelLatencyTest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DataChannelLatencyTest */ "../../ui-library/dist/esm/UI/DataChannelLatencyTest.js");
/* harmony import */ var _SessionTest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SessionTest */ "../../ui-library/dist/esm/UI/SessionTest.js");
/* harmony import */ var _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UIConfigurationTypes */ "../../ui-library/dist/esm/UI/UIConfigurationTypes.js");
// Copyright Epic Games, Inc. All Rights Reserved.






/**
 * A stat structure, an id, the stat string, and the element where it is rendered.
 */
class Stat {
}
/**
 * A UI component containing all the stats for the application.
 */
class StatsPanel {
    constructor(config, streamConfig) {
        this.sessionTest = null;
        /* A map stats we are storing/rendering */
        this.statsMap = new Map();
        this._config = config;
        // Only create the session test class/ui-elements if the ?LatencyCSV flag is enabled.
        this.sessionTest = streamConfig.isFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Flags.LatencyCSV) ? new _SessionTest__WEBPACK_IMPORTED_MODULE_1__.SessionTest() : null;
        this.latencyTest = new _LatencyTest__WEBPACK_IMPORTED_MODULE_2__.LatencyTest();
        this.dataChannelLatencyTest = new _DataChannelLatencyTest__WEBPACK_IMPORTED_MODULE_3__.DataChannelLatencyTest();
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('div');
            this._rootElement.id = 'stats-panel';
            this._rootElement.classList.add('panel-wrap');
            const panelElem = document.createElement('div');
            panelElem.classList.add('panel');
            this._rootElement.appendChild(panelElem);
            const statsHeading = document.createElement('div');
            statsHeading.id = 'statsHeading';
            statsHeading.textContent = 'Information';
            panelElem.appendChild(statsHeading);
            panelElem.appendChild(this.statsCloseButton);
            panelElem.appendChild(this.statsContentElement);
        }
        return this._rootElement;
    }
    get statsContentElement() {
        if (!this._statsContentElement) {
            this._statsContentElement = document.createElement('div');
            this._statsContentElement.id = 'statsContent';
            const streamToolStats = document.createElement('div');
            streamToolStats.id = 'streamToolsStats';
            streamToolStats.classList.add('container');
            const controlStats = document.createElement('div');
            controlStats.id = 'ControlStats';
            controlStats.classList.add('row');
            const statistics = document.createElement('section');
            statistics.id = 'statistics';
            statistics.classList.add('settingsContainer');
            const latencyStats = document.createElement('section');
            latencyStats.id = 'latencyStats';
            latencyStats.classList.add('settingsContainer');
            const statisticsHeader = document.createElement('div');
            statisticsHeader.id = 'statisticsHeader';
            statisticsHeader.classList.add('settings-text');
            statisticsHeader.classList.add('settingsHeader');
            const latencyStatsHeader = document.createElement('div');
            latencyStatsHeader.id = 'latencyStatsHeader';
            latencyStatsHeader.classList.add('settings-text');
            latencyStatsHeader.classList.add('settingsHeader');
            this._statsContentElement.appendChild(streamToolStats);
            streamToolStats.appendChild(controlStats);
            // Add sesssion test to the UI if ?LatencyCSV flag is enabled and config allows it.
            if (this.sessionTest && (0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.SessionTest)) {
                controlStats.appendChild(this.sessionTest.rootElement);
            }
            controlStats.appendChild(statistics);
            controlStats.appendChild(latencyStats);
            statistics.appendChild(statisticsHeader);
            latencyStats.appendChild(latencyStatsHeader);
            if ((0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.SessionStats)) {
                const sessionStatsText = document.createElement('div');
                sessionStatsText.innerHTML = _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.SessionStats;
                statisticsHeader.appendChild(sessionStatsText);
            }
            statistics.appendChild(this.statisticsContainer);
            if ((0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.LatencyStats)) {
                const latencyStatsText = document.createElement('div');
                latencyStatsText.innerHTML = _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.LatencyStats;
                latencyStatsHeader.appendChild(latencyStatsText);
            }
            latencyStats.appendChild(this.latencyStatsContainer);
            if ((0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.LatencyTest)) {
                controlStats.appendChild(this.latencyTest.rootElement);
            }
            if ((0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.DataChannelLatencyTest)) {
                controlStats.appendChild(this.dataChannelLatencyTest.rootElement);
            }
        }
        return this._statsContentElement;
    }
    get statisticsContainer() {
        if (!this._statisticsContainer) {
            this._statisticsContainer = document.createElement('div');
            this._statisticsContainer.id = 'statisticsContainer';
            this._statisticsContainer.classList.add('d-none');
            this._statisticsContainer.appendChild(this.statsResult);
        }
        return this._statisticsContainer;
    }
    get latencyStatsContainer() {
        if (!this._latencyStatsContainer) {
            this._latencyStatsContainer = document.createElement('div');
            this._latencyStatsContainer.id = 'latencyStatsContainer';
            this._latencyStatsContainer.classList.add('d-none');
            this._latencyStatsContainer.appendChild(this.latencyResult);
        }
        return this._latencyStatsContainer;
    }
    get statsResult() {
        if (!this._statsResult) {
            this._statsResult = document.createElement('div');
            this._statsResult.id = 'statisticsResult';
            this._statsResult.classList.add('StatsResult');
        }
        return this._statsResult;
    }
    get latencyResult() {
        if (!this._latencyResult) {
            this._latencyResult = document.createElement('div');
            this._latencyResult.id = 'latencyResult';
            this._latencyResult.classList.add('StatsResult');
        }
        return this._latencyResult;
    }
    get statsCloseButton() {
        if (!this._statsCloseButton) {
            this._statsCloseButton = document.createElement('div');
            this._statsCloseButton.id = 'statsClose';
        }
        return this._statsCloseButton;
    }
    onDisconnect() {
        this.latencyTest.latencyTestButton.onclick = () => {
            // do nothing
        };
        this.dataChannelLatencyTest.latencyTestButton.onclick = () => {
            //do nothing
        };
    }
    onVideoInitialized(stream) {
        // starting a latency check
        this.latencyTest.latencyTestButton.onclick = () => {
            stream.requestLatencyTest();
        };
        this.dataChannelLatencyTest.latencyTestButton.onclick = () => {
            const started = stream.requestDataChannelLatencyTest({
                duration: 1000,
                rps: 10,
                requestSize: 200,
                responseSize: 200
            });
            if (started) {
                this.dataChannelLatencyTest.handleTestStart();
            }
        };
    }
    configure(settings) {
        if (settings.DisableLatencyTest) {
            this.latencyTest.latencyTestButton.disabled = true;
            this.latencyTest.latencyTestButton.title = 'Disabled by -PixelStreamingDisableLatencyTester=true';
            this.dataChannelLatencyTest.latencyTestButton.disabled = true;
            this.dataChannelLatencyTest.latencyTestButton.title =
                'Disabled by -PixelStreamingDisableLatencyTester=true';
            _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Logger.Info('-PixelStreamingDisableLatencyTester=true, requesting latency report from the the browser to UE is disabled.');
        }
    }
    /**
     * Show stats panel.
     */
    show() {
        if (!this.rootElement.classList.contains('panel-wrap-visible')) {
            this.rootElement.classList.add('panel-wrap-visible');
        }
    }
    /**
     * Toggle the visibility of the stats panel.
     */
    toggleVisibility() {
        this.rootElement.classList.toggle('panel-wrap-visible');
    }
    /**
     * Hide the stats panel.
     */
    hide() {
        if (this.rootElement.classList.contains('panel-wrap-visible')) {
            this.rootElement.classList.remove('panel-wrap-visible');
        }
    }
    handlePlayerCount(playerCount) {
        this.addOrUpdateSessionStat('PlayerCountStat', 'Players', playerCount.toString());
    }
    /**
     * Handle stats coming in from browser/UE
     * @param stats - the stats structure
     */
    handleStats(stats) {
        var _a, _b, _c, _d;
        // format numbering based on the browser language
        const numberFormat = new Intl.NumberFormat(window.navigator.language, {
            maximumFractionDigits: 0
        });
        if (this.sessionTest) {
            this.sessionTest.handleStats(stats);
        }
        // Inbound data
        const inboundData = _Util_MathUtils__WEBPACK_IMPORTED_MODULE_6__.MathUtils.formatBytes(stats.inboundVideoStats.bytesReceived, 2);
        this.addOrUpdateSessionStat('InboundDataStat', 'Received', inboundData);
        // Packets lost
        const packetsLostStat = Object.prototype.hasOwnProperty.call(stats.inboundVideoStats, 'packetsLost')
            ? numberFormat.format(stats.inboundVideoStats.packetsLost)
            : 'Chrome only';
        this.addOrUpdateSessionStat('PacketsLostStat', 'Packets Lost', packetsLostStat);
        // Bitrate
        if (stats.inboundVideoStats.bitrate) {
            this.addOrUpdateSessionStat('VideoBitrateStat', 'Video Bitrate (kbps)', stats.inboundVideoStats.bitrate.toString());
        }
        if (stats.inboundAudioStats.bitrate) {
            this.addOrUpdateSessionStat('AudioBitrateStat', 'Audio Bitrate (kbps)', stats.inboundAudioStats.bitrate.toString());
        }
        // Video resolution
        const resStat = stats.inboundVideoStats.frameWidth !== undefined &&
            stats.inboundVideoStats.frameWidth > 0 &&
            stats.inboundVideoStats.frameHeight !== undefined &&
            stats.inboundVideoStats.frameHeight > 0
            ? stats.inboundVideoStats.frameWidth + 'x' + stats.inboundVideoStats.frameHeight
            : 'Chrome only';
        this.addOrUpdateSessionStat('VideoResStat', 'Video resolution', resStat);
        // Frames decoded
        if (stats.inboundVideoStats.framesDecoded !== undefined) {
            const framesDecoded = numberFormat.format(stats.inboundVideoStats.framesDecoded);
            this.addOrUpdateSessionStat('FramesDecodedStat', 'Frames Decoded', framesDecoded);
        }
        // Framerate
        if (stats.inboundVideoStats.framesPerSecond) {
            this.addOrUpdateSessionStat('FramerateStat', 'Framerate', stats.inboundVideoStats.framesPerSecond.toString());
        }
        // Frames dropped
        if (stats.inboundVideoStats.framesDropped !== undefined) {
            this.addOrUpdateSessionStat('FramesDroppedStat', 'Frames dropped', stats.inboundVideoStats.framesDropped.toString());
        }
        if (stats.inboundVideoStats.codecId) {
            this.addOrUpdateSessionStat('VideoCodecStat', 'Video codec', 
            // Split the codec to remove the Fmtp line
            (_b = (_a = stats.codecs.get(stats.inboundVideoStats.codecId)) === null || _a === void 0 ? void 0 : _a.mimeType.replace('video/', '')) !== null && _b !== void 0 ? _b : '');
        }
        if (stats.inboundAudioStats.codecId) {
            this.addOrUpdateSessionStat('AudioCodecStat', 'Audio codec', 
            // Split the codec to remove the Fmtp line
            (_d = (_c = stats.codecs.get(stats.inboundAudioStats.codecId)) === null || _c === void 0 ? void 0 : _c.mimeType.replace('audio/', '')) !== null && _d !== void 0 ? _d : '');
        }
        // Store the active candidate pair return a new Candidate pair stat if getActiveCandidate is null
        const activeCandidatePair = stats.getActiveCandidatePair();
        if (activeCandidatePair) {
            // RTT
            const netRTT = Object.prototype.hasOwnProperty.call(activeCandidatePair, 'currentRoundTripTime') &&
                stats.isNumber(activeCandidatePair.currentRoundTripTime)
                ? Math.ceil(activeCandidatePair.currentRoundTripTime * 1000).toString()
                : "Can't calculate";
            this.addOrUpdateSessionStat('RTTStat', 'Net RTT (ms)', netRTT);
        }
        this.addOrUpdateSessionStat('DurationStat', 'Duration', stats.sessionStats.runTime);
        this.addOrUpdateSessionStat('ControlsInputStat', 'Controls stream input', stats.sessionStats.controlsStreamInput);
        // QP
        if (stats.sessionStats.videoEncoderAvgQP !== undefined &&
            !Number.isNaN(stats.sessionStats.videoEncoderAvgQP)) {
            this.addOrUpdateSessionStat('QPStat', 'Video quantization parameter', stats.sessionStats.videoEncoderAvgQP.toString());
        }
        _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Logger.Info(`--------- Stats ---------\n ${JSON.stringify(stats)}\n------------------------`);
    }
    handleLatencyInfo(latencyInfo) {
        if (this.sessionTest) {
            this.sessionTest.handleLatencyInfo(latencyInfo);
        }
        if (latencyInfo.frameTiming !== undefined) {
            // Encoder latency
            if (latencyInfo.frameTiming.encoderLatencyMs !== undefined) {
                this.addOrUpdateLatencyStat('EncodeLatency', 'Encode latency (ms)', Math.ceil(latencyInfo.frameTiming.encoderLatencyMs).toString());
            }
            // Packetizer latency
            if (latencyInfo.frameTiming.packetizeLatencyMs !== undefined) {
                this.addOrUpdateLatencyStat('PacketizerLatency', 'Packetizer latency (ms)', Math.ceil(latencyInfo.frameTiming.packetizeLatencyMs).toString());
            }
            // Pacer latency
            if (latencyInfo.frameTiming.pacerLatencyMs !== undefined) {
                this.addOrUpdateLatencyStat('PacerLatency', 'Pacer latency (ms)', Math.ceil(latencyInfo.frameTiming.pacerLatencyMs).toString());
            }
            // Sender latency calculated using timing stats
            if (latencyInfo.frameTiming.captureToSendLatencyMs !== undefined) {
                this.addOrUpdateLatencyStat('VideoTimingCaptureToSend', 'Post-capture to send latency (ms)', Math.ceil(latencyInfo.frameTiming.captureToSendLatencyMs).toString());
            }
        }
        if (latencyInfo.senderLatencyMs !== undefined) {
            this.addOrUpdateLatencyStat('AbsCaptureTimeToSendLatency', 'Post-capture (abs-ct) to send latency (ms)', Math.ceil(latencyInfo.senderLatencyMs).toString());
        }
        if (latencyInfo.averageAssemblyDelayMs !== undefined) {
            this.addOrUpdateLatencyStat('AvgAssemblyDelay', 'Assembly delay (ms)', Math.ceil(latencyInfo.averageAssemblyDelayMs).toString());
        }
        if (latencyInfo.averageDecodeLatencyMs !== undefined) {
            this.addOrUpdateLatencyStat('AvgDecodeDelay', 'Decode time (ms)', Math.ceil(latencyInfo.averageDecodeLatencyMs).toString());
        }
        if (latencyInfo.averageJitterBufferDelayMs !== undefined) {
            this.addOrUpdateLatencyStat('AvgJitterBufferDelay', 'Jitter buffer (ms)', Math.ceil(latencyInfo.averageJitterBufferDelayMs).toString());
        }
        if (latencyInfo.averageProcessingDelayMs !== undefined) {
            this.addOrUpdateLatencyStat('AvgProcessingDelay', 'Processing delay (ms)', Math.ceil(latencyInfo.averageProcessingDelayMs).toString());
        }
        if (latencyInfo.averageE2ELatency !== undefined) {
            this.addOrUpdateLatencyStat('AvgE2ELatency', 'Total latency (ms)', Math.ceil(latencyInfo.averageE2ELatency).toString());
        }
    }
    /**
     * Adds a new stat to the stats results in the DOM or updates an exiting stat.
     * @param id - The id of the stat to add/update.
     * @param stat - The contents of the stat.
     */
    addOrUpdateSessionStat(id, statLabel, stat) {
        this.addOrUpdateStat(_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.SessionStats, id, statLabel, stat);
    }
    /**
     * Adds a new stat to the latency results in the DOM or updates an exiting stat.
     * @param id - The id of the stat to add/update.
     * @param stat - The contents of the stat.
     */
    addOrUpdateLatencyStat(id, statLabel, stat) {
        this.addOrUpdateStat(_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.LatencyStats, id, statLabel, stat);
    }
    /**
     * Adds a new stat to the stats results in the DOM or updates an exiting stat.
     * @param sectionId - The section to add this stat too.
     * @param id - The id of the stat to add/update.
     * @param stat - The contents of the stat.
     */
    addOrUpdateStat(sectionId, id, statLabel, stat) {
        if (sectionId === _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.SessionStats &&
            !(0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.SessionStats)) {
            return;
        }
        if (sectionId === _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.LatencyStats &&
            !(0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.LatencyStats)) {
            return;
        }
        // Only support session or latency stats being updated in this function currently
        if (sectionId !== _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.SessionStats && sectionId !== _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.LatencyStats) {
            return;
        }
        const parentElem = sectionId === _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.SessionStats ? this.statsResult : this.latencyResult;
        const statHTML = `${statLabel}: ${stat}`;
        if (!this.statsMap.has(id)) {
            // create the stat
            const newStat = new Stat();
            newStat.id = id;
            newStat.stat = stat;
            newStat.title = statLabel;
            newStat.element = document.createElement('div');
            newStat.element.innerHTML = statHTML;
            // add the stat to the dom
            parentElem.appendChild(newStat.element);
            this.statsMap.set(id, newStat);
        }
        // update the existing stat
        else {
            const value = this.statsMap.get(id);
            if (value !== undefined) {
                value.element.innerHTML = statHTML;
            }
        }
    }
}
//# sourceMappingURL=StatsPanel.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/UIConfigurationTypes.js":
/*!************************************************************!*\
  !*** ../../ui-library/dist/esm/UI/UIConfigurationTypes.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExtraFlags: () => (/* binding */ ExtraFlags),
/* harmony export */   SettingsSections: () => (/* binding */ SettingsSections),
/* harmony export */   StatsSections: () => (/* binding */ StatsSections),
/* harmony export */   UIElementCreationMode: () => (/* binding */ UIElementCreationMode),
/* harmony export */   isPanelEnabled: () => (/* binding */ isPanelEnabled),
/* harmony export */   isSectionEnabled: () => (/* binding */ isSectionEnabled),
/* harmony export */   isSettingEnabled: () => (/* binding */ isSettingEnabled)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class ExtraFlags {
}
ExtraFlags.LightMode = 'LightMode';
/**
 * All the UI sections across all the panels.
 */
class SettingsSections {
}
SettingsSections.PixelStreaming = 'Pixel Streaming';
SettingsSections.UI = 'UI';
SettingsSections.Input = 'Input';
SettingsSections.Encoder = 'Encoder';
SettingsSections.WebRTC = 'WebRTC';
SettingsSections.Commands = 'Commands';
class StatsSections {
}
StatsSections.SessionStats = 'Session Stats';
StatsSections.LatencyStats = 'Latency Stats';
StatsSections.LatencyTest = 'Latency Test';
StatsSections.DataChannelLatencyTest = 'Data Channel Latency Test';
StatsSections.SessionTest = 'Session Test';
/** Whether a stream UI element is internally made, externally provided, or disabled. */
var UIElementCreationMode;
(function (UIElementCreationMode) {
    UIElementCreationMode[UIElementCreationMode["CreateDefaultElement"] = 0] = "CreateDefaultElement";
    UIElementCreationMode[UIElementCreationMode["UseCustomElement"] = 1] = "UseCustomElement";
    UIElementCreationMode[UIElementCreationMode["Disable"] = 2] = "Disable";
})(UIElementCreationMode || (UIElementCreationMode = {}));
function isPanelEnabled(config) {
    return !config || (!!config && config.isEnabled);
}
function isSectionEnabled(config, section) {
    return (!config ||
        (!!config &&
            (!Object.prototype.hasOwnProperty.call(config.sectionVisibility, section) ||
                (Object.prototype.hasOwnProperty.call(config.sectionVisibility, section) &&
                    config.sectionVisibility[section]))));
}
function isSettingEnabled(config, setting) {
    return (!config ||
        (!!config &&
            (!Object.prototype.hasOwnProperty.call(config.settingVisibility, setting) ||
                (Object.prototype.hasOwnProperty.call(config.settingVisibility, setting) &&
                    config.settingVisibility[setting]))));
}
//# sourceMappingURL=UIConfigurationTypes.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/VideoQpIndicator.js":
/*!********************************************************!*\
  !*** ../../ui-library/dist/esm/UI/VideoQpIndicator.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VideoQpIndicator: () => (/* binding */ VideoQpIndicator)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * A UI element showing the QP (quantization parameter) of the video stream at the last encoded frame (well, last transmitted QP really).
 * A blockier encoding will have a higher QP and this will make the indicator turn more red.
 * A non-blocky stream will have a lower QP and this will make the indicator turn more green.
 * The QP indicator is represented visually using a WiFi icon.
 */
class VideoQpIndicator {
    constructor(config) {
        this.videoEncoderAvgQP = -1;
        // non html elements
        this.statsText = '';
        this.color = '';
        // qp colors
        this.orangeQP = 26;
        this.redQP = 35;
        this.config = config;
    }
    /**
     * Get the root element of the QP indicator.
     */
    get rootElement() {
        if (!this._rootElement) {
            // make the root element that contains the svg for the connection
            this._rootElement = document.createElement('div');
            this._rootElement.id = 'connection';
            this._rootElement.classList.add('UiTool');
            // add svg icon for the connection strength
            this._rootElement.appendChild(this.qualityStatus);
            // add the text underneath the connection
            this._rootElement.appendChild(this.qualityText);
            // set colors to not connected initially
            this.updateQpTooltip(-1);
        }
        return this._rootElement;
    }
    /**
     * Get the text that displays under the icon.
     */
    get qualityText() {
        if (!this._qualityText) {
            this._qualityText = document.createElement('span');
            this._qualityText.id = 'qualityText';
            this._qualityText.classList.add('tooltiptext');
        }
        return this._qualityText;
    }
    /**
     * Get the icon.
     */
    get qualityStatus() {
        if (!this._qualityStatus) {
            this._qualityStatus = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._qualityStatus.setAttributeNS(null, 'id', 'connectionStrength');
            this._qualityStatus.setAttributeNS(null, 'x', '0px');
            this._qualityStatus.setAttributeNS(null, 'y', '0px');
            this._qualityStatus.setAttributeNS(null, 'viewBox', '0 0 494.45 494.45');
            // build wifi icon
            this.qualityStatus.appendChild(this.dot);
            this.qualityStatus.appendChild(this.middle);
            this.qualityStatus.appendChild(this.outer);
            this.qualityStatus.appendChild(this.inner);
        }
        return this._qualityStatus;
    }
    /**
     * Get the dot at the bottom of the wifi icon.
     */
    get dot() {
        if (!this._dot) {
            this._dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            this._dot.setAttributeNS(null, 'id', 'dot');
            this._dot.setAttributeNS(null, 'cx', '247.125');
            this._dot.setAttributeNS(null, 'cy', '398.925');
            this._dot.setAttributeNS(null, 'r', '35.3');
        }
        return this._dot;
    }
    /**
     * Get the outer arc of the wifi icon.
     */
    get outer() {
        if (!this._outer) {
            this._outer = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            this._outer.setAttributeNS(null, 'id', 'outer');
            this._outer.setAttributeNS(null, 'd', 'M467.925,204.625c-6.8,0-13.5-2.6-18.7-7.8c-111.5-111.4-292.7-111.4-404.1,0c-10.3,10.3-27.1,10.3-37.4,0s-10.3-27.1,0-37.4c64-64,149-99.2,239.5-99.2s175.5,35.2,239.5,99.2c10.3,10.3,10.3,27.1,0,37.4C481.425,202.025,474.625,204.625,467.925,204.625z');
        }
        return this._outer;
    }
    /**
     * Get the middle arc of the wifi icon.
     */
    get middle() {
        if (!this._middle) {
            this._middle = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            this._middle.setAttributeNS(null, 'id', 'middle');
            this._middle.setAttributeNS(null, 'd', 'M395.225,277.325c-6.8,0-13.5-2.6-18.7-7.8c-71.4-71.3-187.4-71.3-258.8,0c-10.3,10.3-27.1,10.3-37.4,0s-10.3-27.1,0-37.4c92-92,241.6-92,333.6,0c10.3,10.3,10.3,27.1,0,37.4C408.725,274.725,401.925,277.325,395.225,277.325z');
        }
        return this._middle;
    }
    /**
     * Get the inner arc of the wifi icon.
     */
    get inner() {
        if (!this._inner) {
            this._inner = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            this._inner.setAttributeNS(null, 'id', 'inner');
            this._inner.setAttributeNS(null, 'd', 'M323.625,348.825c-6.8,0-13.5-2.6-18.7-7.8c-15.4-15.4-36-23.9-57.8-23.9s-42.4,8.5-57.8,23.9c-10.3,10.3-27.1,10.3-37.4,0c-10.3-10.3-10.3-27.1,0-37.4c25.4-25.4,59.2-39.4,95.2-39.4s69.8,14,95.2,39.5c10.3,10.3,10.3,27.1,0,37.4C337.225,346.225,330.425,348.825,323.625,348.825z');
        }
        return this._inner;
    }
    /**
     * Used to set the speed of the status light.
     * @param speed - Set the speed of the blink, higher numbers make the status light blink faster.
     */
    blinkVideoQualityStatus(speed) {
        let iteration = speed;
        let opacity = 1;
        const tickID = setInterval(() => {
            opacity -= 0.1;
            this.qualityText.style.opacity = String(Math.abs((opacity - 0.5) * 2));
            if (opacity <= 0.1) {
                if (--iteration == 0) {
                    clearInterval(tickID);
                }
                else {
                    opacity = 1;
                }
            }
        }, 100 / speed);
    }
    /**
     * updates the QP tooltip by converting the Video Encoder QP to a color light
     * @param QP - The video encoder QP number needed to find the average
     */
    updateQpTooltip(QP) {
        var _a;
        this.videoEncoderAvgQP = QP;
        if (QP > this.redQP) {
            this.color = 'red';
            this.blinkVideoQualityStatus(2);
            this.statsText = `<div style="color: ${this.color}">Poor encoding quality</div>`;
            this.outer.setAttributeNS(null, 'fill', '#3c3b40');
            this.middle.setAttributeNS(null, 'fill', '#3c3b40');
            this.inner.setAttributeNS(null, 'fill', this.color);
            this.dot.setAttributeNS(null, 'fill', this.color);
        }
        else if (QP > this.orangeQP) {
            this.color = 'orange';
            this.blinkVideoQualityStatus(1);
            this.statsText = `<div style="color: ${this.color}">Blocky encoding quality</div>`;
            this.outer.setAttributeNS(null, 'fill', '#3c3b40');
            this.middle.setAttributeNS(null, 'fill', this.color);
            this.inner.setAttributeNS(null, 'fill', this.color);
            this.dot.setAttributeNS(null, 'fill', this.color);
        }
        else if (QP <= 0) {
            this.color = '#b0b0b0';
            this.outer.setAttributeNS(null, 'fill', '#3c3b40');
            this.middle.setAttributeNS(null, 'fill', '#3c3b40');
            this.inner.setAttributeNS(null, 'fill', '#3c3b40');
            this.dot.setAttributeNS(null, 'fill', '#3c3b40');
            this.statsText = `<div style="color: ${this.color}">Not connected</div>`;
        }
        else {
            this.color = 'lime';
            this.qualityStatus.style.opacity = ((_a = this.config) === null || _a === void 0 ? void 0 : _a.hideWhenGood) == true ? '0' : '1';
            this.statsText = `<div style="color: ${this.color}">Clear encoding quality</div>`;
            this.outer.setAttributeNS(null, 'fill', this.color);
            this.middle.setAttributeNS(null, 'fill', this.color);
            this.inner.setAttributeNS(null, 'fill', this.color);
            this.dot.setAttributeNS(null, 'fill', this.color);
        }
        this.qualityText.innerHTML = this.statsText;
    }
}
//# sourceMappingURL=VideoQpIndicator.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/XRIcon.js":
/*!**********************************************!*\
  !*** ../../ui-library/dist/esm/UI/XRIcon.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   XRIcon: () => (/* binding */ XRIcon)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * XR icon that can be clicked.
 */
class XRIcon {
    /**
     * Get the the button containing the XR icon.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('button');
            this._rootElement.type = 'button';
            this._rootElement.classList.add('UiTool');
            this._rootElement.id = 'xrBtn';
            this._rootElement.appendChild(this.xrIcon);
            this._rootElement.appendChild(this.tooltipText);
        }
        return this._rootElement;
    }
    get tooltipText() {
        if (!this._tooltipText) {
            this._tooltipText = document.createElement('span');
            this._tooltipText.classList.add('tooltiptext');
            this._tooltipText.innerHTML = 'XR';
        }
        return this._tooltipText;
    }
    get xrIcon() {
        if (!this._xrIcon) {
            this._xrIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._xrIcon.setAttributeNS(null, 'id', 'xrIcon');
            this._xrIcon.setAttributeNS(null, 'x', '0px');
            this._xrIcon.setAttributeNS(null, 'y', '0px');
            this._xrIcon.setAttributeNS(null, 'viewBox', '0 0 100 100');
            // create svg group for the paths
            const svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svgGroup.classList.add('svgIcon');
            this._xrIcon.appendChild(svgGroup);
            // create paths for the icon itself, the path of the xr headset
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttributeNS(null, 'd', 'M29 41c-5 0-9 4-9 9s4 9 9 9 9-4 9-9-4-9-9-9zm0 14c-2.8 0-5-2.2-5-5s2.2-5 5-5 5 2.2 5 5-2.2 5-5 5zm42-14c-5 0-9 4-9 9s4 9 9 9 9-4 9-9-4-9-9-9zm0 14c-2.8 0-5-2.2-5-5s2.2-5 5-5 5 2.2 5 5-2.2 5-5 5zm12-31H17c-6.6 0-12 5.4-12 12v28c0 6.6 5.4 12 12 12h14.5c3.5 0 6.8-1.5 9-4.1l3.5-4c1.5-1.7 3.7-2.7 6-2.7s4.5 1 6 2.7l3.5 4c2.3 2.6 5.6 4.1 9 4.1H83c6.6 0 12-5.4 12-12V36c0-6.6-5.4-12-12-12zm8 40c0 4.4-3.6 8-8 8H68.5c-2.3 0-4.5-1-6-2.7l-3.5-4c-2.3-2.6-5.6-4.1-9-4.1-3.5 0-6.8 1.5-9 4.1l-3.5 4C36 71 33.8 72 31.5 72H17c-4.4 0-8-3.6-8-8V36c0-4.4 3.6-8 8-8h66c4.4 0 8 3.6 8 8v28z');
            svgGroup.appendChild(path);
        }
        return this._xrIcon;
    }
}
//# sourceMappingURL=XRIcon.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Util/MathUtils.js":
/*!***************************************************!*\
  !*** ../../ui-library/dist/esm/Util/MathUtils.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MathUtils: () => (/* binding */ MathUtils)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class MathUtils {
    /**
     * formats Bytes coming in for video stats
     * @param bytes - number to convert
     * @param decimals - number of decimal places
     */
    static formatBytes(bytes, decimals) {
        if (bytes === 0) {
            return '0';
        }
        const factor = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
        const i = Math.floor(Math.log(bytes) / Math.log(factor));
        return parseFloat((bytes / Math.pow(factor, i)).toFixed(dm)) + ' ' + sizes[i];
    }
}
//# sourceMappingURL=MathUtils.js.map

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!*************************!*\
  !*** ./src/showcase.ts ***!
  \*************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PixelStreamingApplicationStyles: () => (/* binding */ PixelStreamingApplicationStyles)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/PixelStreaming/PixelStreaming.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ui_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ui-ue5.6 */ "../../ui-library/dist/esm/Styles/PixelStreamingApplicationStyles.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ui_ue5_6__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ui-ue5.6 */ "../../ui-library/dist/esm/Application/Application.js");
// Copyright Epic Games, Inc. All Rights Reserved.


const PixelStreamingApplicationStyles = new _epicgames_ps_lib_pixelstreamingfrontend_ui_ue5_6__WEBPACK_IMPORTED_MODULE_0__.PixelStreamingApplicationStyle();
PixelStreamingApplicationStyles.applyStyleSheet();
document.body.onload = function () {
    // Create a config object
    const config = new _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Config({ useUrlParams: true });
    // Create Pixel Streaming application
    const stream = new _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_2__.PixelStreaming(config);
    const application = new _epicgames_ps_lib_pixelstreamingfrontend_ui_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Application({
        stream,
        onColorModeChanged: (isLightMode) => PixelStreamingApplicationStyles.setColorMode(isLightMode)
    });
    document.getElementById("playercontainer").appendChild(application.rootElement);
    const showcase = new Showcase(stream);
    // Bind example selection to the onExampleChanged function
    document.getElementById("exampleSelect").onchange = (event) => { showcase.onExampleChanged(event); };
};
class Showcase {
    constructor(pixelStreaming) {
        this._pixelStreaming = pixelStreaming;
        this._infoElem = document.getElementById("infoinstructions");
        this._exampleSettingsElem = document.getElementById("sidebarContent");
        this._createGettingStartedExample();
    }
    /**
     * Event fired for when the selection drop down containing our showcase examples changes.
     * @param event The change event.
     */
    onExampleChanged(event) {
        if (!event) {
            return;
        }
        const selectElement = event.target;
        const exampleName = selectElement.value;
        this._createExample(exampleName);
    }
    _createExample(exampleName) {
        // clear example elements
        while (this._exampleSettingsElem.lastElementChild) {
            this._exampleSettingsElem.removeChild(this._exampleSettingsElem.lastElementChild);
        }
        // create the relevant example based on the string passed in
        switch (exampleName) {
            case "Send Data to UE":
                this._createSendUEDataExample();
                break;
            case "Getting Started":
                this._createGettingStartedExample();
                break;
            case "Send Commands to UE":
                this._createUECommandExample();
                break;
            default:
                break;
        }
    }
    _onCharacterClicked(characterName) {
        this._pixelStreaming.emitUIInteraction({ Character: characterName });
    }
    _onSkinClicked(skinIndex) {
        this._pixelStreaming.emitUIInteraction({ Skin: skinIndex });
    }
    _onResClicked(width, height) {
        this._pixelStreaming.emitCommand({ Resolution: { Width: width, Height: height } });
    }
    _createGettingStartedExample() {
        this._infoElem.innerHTML =
            `
		<p>Welcome to the Pixel Streaming demo showcase!</p>
		<p> <u>Getting Started</u> </p>
		<ol>
			<li>Run the Unreal Engine Pixel Streaming demo project with launch args for this server, example: -PixelStreamingUrl=ws://localhost:8888.</li>
			<li>Click the "click to start" text on this page to start streaming.</li>
			<li>Use the drop down to select an example.</li>
			<li>Use control panel on the left to interact with the example.</li>
		</ol>
		`;
    }
    _createSendUEDataExample() {
        this._infoElem.innerHTML =
            `
		<p> <u>Example: Sending data to Unreal Engine</u> </p>
		<ol>
			<li>Click the character portraits to change character.</li>
			<li>Click the skins to change character skins.</li>
		</ol>
		<p>Under the hood these interactions use the WebRTC data channel to send a data payload that we interpret on the UE side and respond to appropriately.</p>
		<p>In particular the function called to send custom data to Unreal Engine from the frontend is:</p>
		<code>pixelstreaming.emitUIInteraction(data: object | string)</code>
		`;
        const characterSelectElem = document.createElement("div");
        this._exampleSettingsElem.appendChild(characterSelectElem);
        const sendDataTitle = document.createElement("h2");
        sendDataTitle.innerText = "Send data: ";
        characterSelectElem.appendChild(sendDataTitle);
        const characterSelectTitle = document.createElement("p");
        characterSelectTitle.innerText = "Select a character: ";
        characterSelectElem.appendChild(characterSelectTitle);
        // Make Aurora character
        const auroraElem = document.createElement("div");
        characterSelectElem.appendChild(auroraElem);
        const auroraImg = document.createElement("img");
        auroraImg.classList.add("characterBtn");
        auroraImg.src = "./images/Aurora.jpg";
        auroraImg.onclick = () => { this._onCharacterClicked("Aurora"); };
        auroraElem.appendChild(auroraImg);
        // Make Crunch character
        const crunchElem = document.createElement("div");
        characterSelectElem.appendChild(crunchElem);
        const crunchImg = document.createElement("img");
        crunchImg.classList.add("characterBtn");
        crunchImg.src = "./images/Crunch.jpg";
        crunchImg.onclick = () => { this._onCharacterClicked("Crunch"); };
        crunchElem.appendChild(crunchImg);
        // Make skin selection title
        const skinSelectTitle = document.createElement("p");
        skinSelectTitle.innerText = "Select a skin: ";
        this._exampleSettingsElem.appendChild(skinSelectTitle);
        // Make skin selection
        const skinSelectElem = document.createElement("div");
        skinSelectElem.classList.add("spaced-row");
        this._exampleSettingsElem.appendChild(skinSelectElem);
        // Make skin selection buttons
        // Skin1
        const skin1Btn = document.createElement("button");
        skin1Btn.classList.add("btn-flat");
        skin1Btn.onclick = () => { this._onSkinClicked(0); };
        skin1Btn.innerText = "Skin 1";
        skinSelectElem.appendChild(skin1Btn);
        // Skin2
        const skin2Btn = document.createElement("button");
        skin2Btn.classList.add("btn-flat");
        skin2Btn.onclick = () => { this._onSkinClicked(1); };
        skin2Btn.innerText = "Skin 2";
        skinSelectElem.appendChild(skin2Btn);
        // Skin3
        const skin3Btn = document.createElement("button");
        skin3Btn.classList.add("btn-flat");
        skin3Btn.onclick = () => { this._onSkinClicked(2); };
        skin3Btn.innerText = "Skin 3";
        skinSelectElem.appendChild(skin3Btn);
    }
    _createUECommandExample() {
        this._infoElem.innerHTML =
            `
		<p> <u>Example: Triggering Commands in Unreal Engine</u> </p>
		<ul>
			<li>Click on the resolution buttons to change your Unreal Engine application's resolution (requires a <code>-windowed</code> application).</li>
		</ul>
		<p>Under the hood these interactions use the WebRTC data channel to send command messages that we interpret on the UE side to call specific UE functions.</p>
		<p>There are a very select set of built-in commands such as <i>changing resolution</i> and <i>change encoder QP</i>, which can be triggered like so:</p>
		<code>pixelStreaming.emitCommand({"Encoder.MinQP": 51,})</code>

		<p>However, you can bind your own custom commands in C++ using:</p>
		<code>
			// C++ side 
			</br>
			IPixelStreamingInputHandler::SetCommandHandler(const FString& CommandName, const TFunction<void(FString, FString)>& Handler)
			</br>
			// JS side
			</br>
			pixelstreaming.emitCommand({"MyCustomCommand": "MyCustomCommandParameter"});
		</code>

		<p>Additionally you can also trigger Unreal Engine console commands like <code>stat gpu</code> if you launch Pixel Streaming with <code>-AllowPixelStreamingCommands</code> then calling:</p>
		<code>pixelstreaming.emitConsoleCommand(command: string)</code>
		`;
        // Add a new element for containing elements for res changing feature
        const changeResElem = document.createElement("div");
        this._exampleSettingsElem.appendChild(changeResElem);
        // Make res change title
        const changeResTitle = document.createElement("h2");
        changeResTitle.innerText = "Send a custom command: ";
        changeResElem.appendChild(changeResTitle);
        // Make change resolution text
        const changeResText = document.createElement("p");
        changeResText.innerHTML = "Change resolution";
        changeResElem.appendChild(changeResText);
        // Make res change button container
        const changeResBtnContainer = document.createElement("div");
        changeResBtnContainer.classList.add("spaced-row");
        this._exampleSettingsElem.appendChild(changeResBtnContainer);
        // Make res change buttons
        // 720p
        const res720pBtn = document.createElement("button");
        res720pBtn.classList.add("btn-flat");
        res720pBtn.onclick = () => { this._onResClicked(1280, 720); };
        res720pBtn.innerText = "720p";
        changeResBtnContainer.appendChild(res720pBtn);
        // 1080p
        const res1080pBtn = document.createElement("button");
        res1080pBtn.classList.add("btn-flat");
        res1080pBtn.onclick = () => { this._onResClicked(1920, 1080); };
        res1080pBtn.innerText = "1080p";
        changeResBtnContainer.appendChild(res1080pBtn);
        // 1440p
        const res1440pBtn = document.createElement("button");
        res1440pBtn.classList.add("btn-flat");
        res1440pBtn.onclick = () => { this._onResClicked(2560, 1440); };
        res1440pBtn.innerText = "1440p";
        changeResBtnContainer.appendChild(res1440pBtn);
        // 4k
        const res4kBtn = document.createElement("button");
        res4kBtn.classList.add("btn-flat");
        res4kBtn.onclick = () => { this._onResClicked(3840, 2160); };
        res4kBtn.innerText = "4k";
        changeResBtnContainer.appendChild(res4kBtn);
        // Add a new element for containing elements for res changing feature
        const consoleCommandElem = document.createElement("div");
        this._exampleSettingsElem.appendChild(consoleCommandElem);
        // Make console command title
        const consoleCommandTitle = document.createElement("h2");
        consoleCommandTitle.innerText = "Send a console command: ";
        consoleCommandElem.appendChild(consoleCommandTitle);
        // Text informing using about -AllowPixelStreamingCommands
        const informPSCommandsText = document.createElement("p");
        informPSCommandsText.innerHTML = "(Requires UE side launched with <code>-AllowPixelStreamingCommands</code>)";
        consoleCommandElem.appendChild(informPSCommandsText);
        // Make buttons for stat fps/stat gpu
        const consoleCmdBtnsContainer = document.createElement("div");
        consoleCmdBtnsContainer.classList.add("spaced-row");
        this._exampleSettingsElem.appendChild(consoleCmdBtnsContainer);
        // stat fps
        const statfpsBtn = document.createElement("button");
        statfpsBtn.classList.add("btn-flat");
        statfpsBtn.onclick = () => { this._pixelStreaming.emitConsoleCommand("stat fps"); };
        statfpsBtn.innerText = "stat fps";
        consoleCmdBtnsContainer.appendChild(statfpsBtn);
        // stat pixelstreaming
        const statgpuBtn = document.createElement("button");
        statgpuBtn.classList.add("btn-flat");
        statgpuBtn.onclick = () => { this._pixelStreaming.emitConsoleCommand("stat pixelstreaming"); this._pixelStreaming.emitConsoleCommand("stat pixelstreaming2"); };
        statgpuBtn.innerText = "stat pixelstreaming";
        consoleCmdBtnsContainer.appendChild(statgpuBtn);
        //stat pixelStreamingGraphs
        const statGraphBtn = document.createElement("button");
        statGraphBtn.classList.add("btn-flat");
        statGraphBtn.onclick = () => { this._pixelStreaming.emitConsoleCommand("stat pixelstreaminggraphs"); this._pixelStreaming.emitConsoleCommand("stat pixelstreaming2graphs"); };
        statGraphBtn.innerText = "stat pixelstreaminggraphs";
        consoleCmdBtnsContainer.appendChild(statGraphBtn);
    }
}

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQ0FBc0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtREFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hHK0Q7QUFDL0Q7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZEQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwyREFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw2REFBZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkRBQWE7QUFDdEM7QUFDQSxlQUFlLDJEQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZPeUU7QUFDaEI7QUFDUztBQUNJO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVMsYUFBYSxTQUFTLFFBQVEsbUJBQW1CO0FBQy9HO0FBQ0E7QUFDQSxrQ0FBa0Msd0VBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsd0RBQVU7QUFDN0Q7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCx3Q0FBd0MsNkRBQVEseUJBQXlCLHdEQUFVLGdCQUFnQix3REFBVTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdEQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxzREFBUTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUyxhQUFhLFNBQVMscUJBQXFCLG1CQUFtQixHQUFHLFdBQVc7QUFDMUk7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1GQUF1QjtBQUNoRCw2QkFBNkIsd0RBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUZBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBLGlCQUFpQix3REFBVTtBQUMzQix1QkFBdUIsK0VBQXFCO0FBQzVDLGlCQUFpQix3REFBVTtBQUMzQix1QkFBdUIsK0VBQXFCO0FBQzVDLGlCQUFpQix3REFBVTtBQUMzQix1QkFBdUIsK0VBQXFCO0FBQzVDLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBLGlCQUFpQix3REFBVTtBQUMzQix1QkFBdUIsK0VBQXFCO0FBQzVDLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBLGlCQUFpQix3REFBVTtBQUMzQix1QkFBdUIsK0VBQXFCO0FBQzVDO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xMeUU7QUFDZDtBQUN6QjtBQUNVO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsd0RBQVU7QUFDN0Q7QUFDQSx3QkFBd0IsK0NBQU07QUFDOUIsd0NBQXdDLHdEQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQ0FBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtDQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0NBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0VBQW1CO0FBQzdDO0FBQ0E7QUFDQSw2QkFBNkIsNkRBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBVTtBQUMzQixpQkFBaUIsd0RBQVU7QUFDM0IsaUJBQWlCLHdEQUFVO0FBQzNCLGlCQUFpQix3REFBVTtBQUMzQixpQkFBaUIsd0RBQVU7QUFDM0I7QUFDQTtBQUNBLGlCQUFpQix3REFBVTtBQUMzQixnQkFBZ0IsK0NBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3REFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw2REFBUTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUFNLFVBQVUsd0RBQVUsbUJBQW1CLHdEQUFVO0FBQy9EO0FBQ0EsNEJBQTRCLDZEQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkRBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQVU7QUFDM0I7QUFDQTtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBLG9CQUFvQiw2REFBUTtBQUM1QjtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCLG9CQUFvQiw2REFBUTtBQUM1QjtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCLG9CQUFvQiw2REFBUTtBQUM1QjtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCLHlCQUF5Qiw0Q0FBTTtBQUMvQjtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCLHlCQUF5Qiw2Q0FBTztBQUNoQztBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCLHlCQUF5Qiw2Q0FBTztBQUNoQyxvQkFBb0IsNkRBQVE7QUFDNUI7QUFDQTtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBLG9CQUFvQiw2REFBUTtBQUM1QjtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCLG9CQUFvQiw2REFBUTtBQUM1QjtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCLG9CQUFvQiw2REFBUTtBQUM1QjtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCLHlCQUF5Qiw0Q0FBTTtBQUMvQixvQkFBb0IsNkRBQVE7QUFDNUI7QUFDQTtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCLHlCQUF5Qiw0Q0FBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcE9zRTtBQUNmO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsRUFBRSxnRUFBWSxJQUFJLGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1GQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQytDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx3REFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHdEQUFVO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hFb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsOEVBQThFLGlFQUFjO0FBQzVGLDRFQUE0RSxpRUFBYztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEorRDtBQUN2QjtBQUNpQjtBQUNiO0FBQ2dDO0FBQ1Y7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhEQUFlO0FBQ3RDO0FBQ0E7QUFDQSxpREFBaUQsTUFBTSxNQUFNLG1CQUFtQixHQUFHLFVBQVU7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLG9CQUFvQiw4QkFBOEIsUUFBUTtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsWUFBWSxPQUFPLG9CQUFvQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJEQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0RBQVU7QUFDN0M7QUFDQSxvREFBb0Qsc0RBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFNLGtFQUFrRSxtQkFBbUIsR0FBRyxVQUFVLFNBQVMsU0FBUztBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFNLGtEQUFrRCxtQkFBbUIsR0FBRyxVQUFVLDBDQUEwQyxLQUFLO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFNLHlEQUF5RCxtQkFBbUIsR0FBRyxVQUFVLFNBQVMsU0FBUyxvQkFBb0IsS0FBSztBQUMxSjtBQUNBO0FBQ0EsUUFBUSwrQ0FBTSxpQ0FBaUMsbUJBQW1CLEdBQUcsVUFBVSxpQ0FBaUMsWUFBWTtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3REFBVTtBQUMvQixxQkFBcUIsd0RBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3REFBVTtBQUMxQyx3QkFBd0Isc0RBQWE7QUFDckM7QUFDQTtBQUNBLHFCQUFxQix3REFBVTtBQUMvQixxQkFBcUIsd0RBQVU7QUFDL0IscUJBQXFCLHdEQUFVO0FBQy9CLHFCQUFxQix3REFBVTtBQUMvQixxQkFBcUIsd0RBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdEQUFVO0FBQzFDLHdCQUF3QixxREFBWTtBQUNwQztBQUNBLHdCQUF3QixvREFBVztBQUNuQztBQUNBO0FBQ0EscUJBQXFCLHdEQUFVO0FBQy9CLHFCQUFxQix3REFBVTtBQUMvQixxQkFBcUIsd0RBQVU7QUFDL0I7QUFDQSwrQkFBK0IsK0VBQXFCLENBQUMsNENBQU07QUFDM0Q7QUFDQTtBQUNBLDJCQUEyQiwrRUFBcUIsQ0FBQyw0Q0FBTTtBQUN2RCxxQkFBcUIsd0RBQVU7QUFDL0IscUJBQXFCLHdEQUFVO0FBQy9CO0FBQ0EsK0JBQStCLCtFQUFxQixDQUFDLDZDQUFPO0FBQzVEO0FBQ0E7QUFDQSwyQkFBMkIsK0VBQXFCLENBQUMsNkNBQU87QUFDeEQ7QUFDQSxxQkFBcUIsd0RBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFEQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4VHdDO0FBQ0k7QUFDRztBQUM2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLGdEQUFnRCxjQUFjLHlCQUF5QjtBQUN2RjtBQUNBLFlBQVksK0NBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0NBQU07QUFDOUIsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQ0FBTTtBQUM5Qiw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQ0FBTTtBQUM5QjtBQUNBLHdCQUF3QiwrQ0FBTTtBQUM5Qiw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQSx3QkFBd0IsK0NBQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQsd0JBQXdCLCtDQUFNO0FBQzlCO0FBQ0Esd0JBQXdCLCtDQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0Esd0JBQXdCLCtDQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0NBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0NBQU07QUFDZCxRQUFRLCtDQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQ0FBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQVU7QUFDM0IsaUJBQWlCLHdEQUFVO0FBQzNCLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBO0FBQ0EsZ0JBQWdCLG9EQUFXO0FBQzNCO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBVTtBQUMzQixnQkFBZ0Isc0RBQWE7QUFDN0IsaUJBQWlCLHdEQUFVO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFNO0FBQ3RCO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQVU7QUFDM0I7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBTTtBQUN0QjtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCLGlCQUFpQix3REFBVTtBQUMzQixnQkFBZ0IsK0NBQU07QUFDdEIsNEJBQTRCLDZDQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCLGlCQUFpQix3REFBVTtBQUMzQixpQkFBaUIsd0RBQVU7QUFDM0IsZ0JBQWdCLCtDQUFNO0FBQ3RCLDJCQUEyQiw0Q0FBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCLGdCQUFnQiwrQ0FBTTtBQUN0QjtBQUNBO0FBQ0EsdUJBQXVCLHFEQUFZO0FBQ25DO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2pPNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsYUFBYSxzREFBUTtBQUNyQjtBQUNBLGFBQWEsc0RBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLGdHQUFnRztBQUNoRywwQkFBMEI7QUFDMUI7QUFDQSxzQ0FBc0M7QUFDdEMsMENBQTBDO0FBQzFDLGdEQUFnRDtBQUNoRDtBQUNBLHFDQUFxQztBQUNyQywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLDZCQUE2QjtBQUM3QjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUI7QUFDM0QseURBQXlEO0FBQ3pEO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVCQUF1QjtBQUMzRDtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckZ5RDtBQUNTO0FBQ3RCO0FBQzVDO0FBQ0E7QUFDQTtBQUNPLGtEQUFrRCxzREFBUTtBQUNqRTtBQUNBLGFBQWEsd0RBQVU7QUFDdkI7QUFDQSxhQUFhLHdEQUFVO0FBQ3ZCLGFBQWEsd0RBQVU7QUFDdkIsbUJBQW1CLCtFQUFxQixDQUFDLDZDQUFPO0FBQ2hELGFBQWEsd0RBQVU7QUFDdkIsYUFBYSx3REFBVTtBQUN2QixhQUFhLHdEQUFVO0FBQ3ZCLG1CQUFtQiwrRUFBcUIsQ0FBQyw0Q0FBTTtBQUMvQyxhQUFhLHdEQUFVO0FBQ3ZCLGFBQWEsd0RBQVU7QUFDdkI7QUFDQSxhQUFhLHdEQUFVO0FBQ3ZCO0FBQ0EsYUFBYSx3REFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQ3lEO0FBQ2xCO0FBQ3ZDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9EQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsd0RBQVU7QUFDdkQsd0NBQXdDLHdEQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usd0RBQVU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCLGlCQUFpQix3REFBVTtBQUMzQixpQkFBaUIsd0RBQVU7QUFDM0IsaUJBQWlCLHdEQUFVO0FBQzNCLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBLHlCQUF5QixzREFBUTtBQUNqQztBQUNBLHlCQUF5QixzREFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBLGlCQUFpQix3REFBVTtBQUMzQixpQkFBaUIsd0RBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCLGlCQUFpQix3REFBVTtBQUMzQixpQkFBaUIsd0RBQVU7QUFDM0IsaUJBQWlCLHdEQUFVO0FBQzNCLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBO0FBQ0EsdURBQXVELHNEQUFRO0FBQy9EO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDak9BO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsa0JBQWtCOzs7Ozs7Ozs7Ozs7Ozs7O0FDbEJqQyxxR0FBcUcscUJBQXFCLG1CQUFtQjs7QUFFdEk7O0FBRVAsaUVBQWUsU0FBUyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDSm9COztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxnRUFBUztBQUN6RDtBQUNBOztBQUVBO0FBQ0EsK0ZBQStGO0FBQy9GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsZ0VBQVMsUUFBUTs7QUFFMUM7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxTQUFTLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMURpQztBQUMzQjs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUNBQVEsQ0FBQyw4RUFBUSxHQUFHO0FBQ3pDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDhFQUFRLEdBQUc7QUFDbkU7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLDhFQUFRLEdBQUc7QUFDaEQ7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDhFQUFRLEdBQUc7QUFDcEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxTQUFTLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekxpQztBQUNsQjtBQUNMO0FBQytCO0FBQ0k7QUFDZ0I7QUFDYzs7QUFFcEcsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQSxJQUFJLEtBQXFDLEdBQUcsd0RBQU8sd0NBQXdDLENBQU07QUFDakc7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELGdEQUFnRDtBQUNoRCw0RUFBNEU7QUFDNUUseURBQXlEO0FBQ3pEOzs7QUFHQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1DQUFtQzs7O0FBR3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBLHFCQUFxQixhQUFhLFlBQVk7QUFDOUM7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBLElBQUk7OztBQUdKLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtDQUFrQztBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qzs7QUFFeEMsc0RBQXNEOztBQUV0RDtBQUNBLHdDQUF3QyxrQ0FBa0M7O0FBRTFFO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNLEtBQXFDLEdBQUcsd0RBQU8sMEVBQTBFLENBQU07QUFDckk7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFFLG9GQUFjOztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTiw0QkFBNEIsNEZBQXNCLENBQUMsNEZBQXNCO0FBQ3pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhFQUFRLEdBQUc7QUFDakM7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxFQUFFLGtGQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBLDhCQUE4Qiw4RUFBUSxHQUFHO0FBQ3pDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBLHNDQUFzQyx5Q0FBeUM7QUFDL0U7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTSxLQUFxQyxHQUFHLHdEQUFPLDZDQUE2QyxDQUFNO0FBQ3hHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4RUFBUSxHQUFHO0FBQ3pDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHlDQUF5Qyw4RUFBUSxHQUFHO0FBQ3BEO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLGlCQUFpQjtBQUN6RDs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLEtBQXFDLEdBQUcsd0RBQU8sOEVBQThFLENBQU07QUFDekk7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLG9GQUFjOztBQUVoQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhFQUFRLEdBQUc7QUFDakM7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsMkJBQTJCO0FBQ3JELHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsOEVBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdCQUFnQjtBQUNyQjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLDhFQUFRLEdBQUc7QUFDOUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTiwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEVBQVEsR0FBRztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVDQUF1QztBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isd0NBQXdDO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IseUNBQXlDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FB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QUFFQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0VBQStFOzs7QUFHL0U7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZ0JBQWdCLHFEQUFX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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQixPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksSUFBMEI7QUFDOUI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDanlCQSxtQkFBbUIsYUFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLGlFQUFlLE9BQU8sRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkJ2QjtBQUM0RDtBQUNVO0FBQzZEO0FBQzVIO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHlFQUF5QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNkRBQWlCO0FBQ2hFLHNDQUFzQyxpREFBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGlEQUFLO0FBQzFEO0FBQ0EsMEdBQTBHLDZEQUFpQjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUVBQXVCO0FBQ3JFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0REFBNEQsNkRBQWlCO0FBQzdFO0FBQ0EsOENBQThDLHFFQUFxQixHQUFHLDJCQUEyQjtBQUNqRztBQUNBLHVDQUF1QyxpREFBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnRUFBZ0I7QUFDdEU7QUFDQSxnQkFBZ0IsZ0ZBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QscUVBQXFCLEdBQUcsMkJBQTJCO0FBQ3pHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekdBO0FBQ3NFO0FBQzFCO0FBQ0k7QUFDSjtBQUNJO0FBQ1k7QUFDUjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvREFBb0Q7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLHFEQUFXO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0MsbUVBQW1FLHlEQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNERBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdGQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw0REFBWTtBQUN2RDtBQUNBLG9EQUFvRCxxQkFBcUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHlEQUFhO0FBQ3BGO0FBQ0Esc0NBQXNDLDREQUFZO0FBQ2xELHlFQUF5RSx5REFBYTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFEQUFXO0FBQ3pEO0FBQ0E7QUFDQSxnREFBZ0QscURBQVc7QUFDM0Q7QUFDQTtBQUNBLHlDQUF5QyxxREFBVztBQUNwRDtBQUNBO0FBQ0EsdURBQXVELHFEQUFXO0FBQ2xFO0FBQ0E7QUFDQSw0Q0FBNEMscURBQVc7QUFDdkQ7QUFDQTtBQUNBLGtEQUFrRCxxREFBVztBQUM3RDtBQUNBO0FBQ0Esc0RBQXNELHFEQUFXO0FBQ2pFO0FBQ0E7QUFDQSxzREFBc0QscURBQVc7QUFDakU7QUFDQTtBQUNBLGlEQUFpRCxxREFBVztBQUM1RDtBQUNBO0FBQ0EsNENBQTRDLHFEQUFXO0FBQ3ZEO0FBQ0E7QUFDQSwrQ0FBK0MscURBQVc7QUFDMUQ7QUFDQTtBQUNBLDBEQUEwRCxxREFBVztBQUNyRTtBQUNBO0FBQ0Esb0RBQW9ELHFEQUFXO0FBQy9EO0FBQ0E7QUFDQSwrQ0FBK0MseUNBQXlDO0FBQ3hGLFNBQVM7QUFDVCx1REFBdUQscURBQVc7QUFDbEU7QUFDQTtBQUNBLGdEQUFnRCxxREFBVztBQUMzRDtBQUNBO0FBQ0EsNkNBQTZDLHFEQUFXO0FBQ3hEO0FBQ0E7QUFDQSw2Q0FBNkMscURBQVc7QUFDeEQ7QUFDQTtBQUNBLCtDQUErQyxxREFBVztBQUMxRDtBQUNBO0FBQ0Esb0RBQW9ELHFEQUFXO0FBQy9EO0FBQ0E7QUFDQSxrREFBa0QscURBQVc7QUFDN0Q7QUFDQTtBQUNBLHlDQUF5QyxxREFBVztBQUNwRDtBQUNBO0FBQ0EsdURBQXVELHFEQUFXO0FBQ2xFO0FBQ0E7QUFDQSxtREFBbUQscURBQVc7QUFDOUQ7QUFDQTtBQUNBLDZDQUE2QyxxREFBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLHlEQUFhO0FBQ3RGO0FBQ0E7QUFDQSwyRUFBMkUseURBQWE7QUFDeEYsK0VBQStFLHlEQUFhO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSx5REFBYTtBQUM3RTtBQUNBO0FBQ0EsZ0VBQWdFLHlEQUFhO0FBQzdFO0FBQ0E7QUFDQSxxRUFBcUUseURBQWE7QUFDbEY7QUFDQTtBQUNBLHFFQUFxRSx5REFBYTtBQUNsRjtBQUNBO0FBQ0EsMkVBQTJFLHlEQUFhO0FBQ3hGO0FBQ0E7QUFDQSwyRUFBMkUseURBQWE7QUFDeEY7QUFDQTtBQUNBLG9FQUFvRSx5REFBYTtBQUNqRjtBQUNBO0FBQ0EsMkVBQTJFLHlEQUFhO0FBQ3hGO0FBQ0E7QUFDQSwyRUFBMkUseURBQWE7QUFDeEY7QUFDQTtBQUNBLG1GQUFtRix5REFBYTtBQUNoRztBQUNBO0FBQ0E7QUFDQSx5RUFBeUUseURBQWE7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLEdBQUc7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxHQUFHO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxHQUFHO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU0sc0NBQXNDLElBQUk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTSwyQ0FBMkMsSUFBSTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdGQUFNLDJDQUEyQyxJQUFJO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU0sMkNBQTJDLElBQUk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTSw2Q0FBNkMsSUFBSTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixvRUFBb0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixvRUFBb0I7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixvRUFBb0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixvRUFBb0I7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DOzs7Ozs7Ozs7Ozs7OztBQ3BrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDLGtCQUFrQixHQUFHLFVBQVUsT0FBTyxrQkFBa0I7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDNUZBO0FBQzRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNPLDBCQUEwQixxREFBVztBQUM1QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzNDQTtBQUM0QztBQUM1QztBQUNBO0FBQ0E7QUFDTyw0QkFBNEIscURBQVc7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3RUE7QUFDc0U7QUFDMUI7QUFDNUM7QUFDQTtBQUNBO0FBQ08sNEJBQTRCLHFEQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3R0E7QUFDb0Q7QUFDa0I7QUFDN0I7QUFDRTtBQUMzQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2REFBZTtBQUN2QztBQUNBLDBCQUEwQiw2REFBZTtBQUN6Qyx5QkFB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDekZBO0FBQ3NFO0FBQ2xCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNPLG9DQUFvQyw2REFBZTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdGQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDclRBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRJQUE0SSxLQUFLO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUhBQWlILEtBQUs7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnRkFBTSxtQ0FBbUMsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7Ozs7Ozs7Ozs7Ozs7O0FDak5BO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUM3Q0E7QUFDc0U7QUFDL0Q7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU07QUFDbEIsd0VBQXdFLHFCQUFxQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLHFCQUFxQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ25ZQTtBQUNzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdGQUFNO0FBQ2xCO0FBQ0E7QUFDQSxRQUFRLGdGQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdGQUFNO0FBQ2xCO0FBQ0E7QUFDQSxRQUFRLGdGQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdGQUFNLDhCQUE4QixpQkFBaUIsR0FBRyxZQUFZO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU07QUFDbEI7QUFDQTtBQUNBLFlBQVksZ0ZBQU0sbUNBQW1DLGdCQUFnQixZQUFZLHlCQUF5QjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQscUJBQXFCO0FBQ3hFO0FBQ0E7QUFDQSxtREFBbUQsZUFBZTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdGQUFNLGdEQUFnRCxpQkFBaUIsR0FBRyxZQUFZO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDN0NBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvREE7QUFDeUM7QUFDNkI7QUFDdEU7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlEQUFLO0FBQ2pFLCtEQUErRCxpREFBSztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZSxnQkFBZ0I7QUFD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QUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0VBQXdFLDJEQUFjO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWix1TkFBdU4sV0FBVztBQUNsTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUU7QUFDQSxTQUFTO0FBQ1QsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RTtBQUNBLFNBQVM7QUFDVCw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RTtBQUNBLFNBQVM7QUFDVCw0REFBNEQsd0ZBQWdCO0FBQzVFO0FBQ0EsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUU7QUFDQSxTQUFTO0FBQ1QsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdCO0FBQzVFLDREQUE0RCx3RkFBZ0I7QUFDNUUsNERBQTRELHdGQUFnQjtBQUM1RSw0REFBNEQsd0ZBQWdC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QUFRLGdGQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxpRkFBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxRUFBcUU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkRBQU0sSUFBSSxpRUFBUztBQUN6QztBQUNBO0FBQ0EsUUFBUSwyQ0FBRztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQSxRQUFRLDJDQUFHO0FBQ1gscURBQXFEO0FBQ3JELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xrQkE7QUFDa0Q7QUFDSjtBQUNOO0FBQ047QUFDK0M7QUFDZDtBQUNuRTtBQUNBO0FBQ0EsNERBQTRELDJFQUFxQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlEQUFTO0FBQzFDO0FBQ0E7QUFDQSxvQ0FBb0MsdURBQVk7QUFDaEQ7QUFDQTtBQUNBLHNDQUFzQywyREFBYztBQUNwRDtBQUNBO0FBQ0EsOEJBQThCLDJDQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJGQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDdkVBO0FBQ3dFO0FBQ2pCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnRUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsb0JBQW9CO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN0R0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqREE7QUFDd0U7QUFDakI7QUFDdkQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdFQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BEQTtBQUM0QztBQUNtQztBQUNqQztBQUNvQjtBQUN0QjtBQUM2QjtBQUN6RTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaUZBQUssbUJBQW1CLHFEQUFXO0FBQ3pGLCtCQUErQixxREFBVztBQUMxQywwQ0FBMEMsMkVBQXNCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1RUFBZ0IsZUFBZSxnRUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUVBQWdCLGVBQWUsZ0VBQWE7QUFDNUQ7QUFDQSw2Q0FBNkMsZ0VBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVFQUFnQixlQUFlLGdFQUFhO0FBQzVEO0FBQ0EsNkNBQTZDLGdFQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1RUFBZ0IsZUFBZSxnRUFBYTtBQUM1RDtBQUNBO0FBQ0EsZ0JBQWdCLHVFQUFnQixlQUFlLGdFQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRkFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtGQUFNLHFDQUFxQyxzQkFBc0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdFQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdFQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0VBQWE7QUFDdkMsYUFBYSx1RUFBZ0IsZUFBZSxnRUFBYTtBQUN6RDtBQUNBO0FBQ0EsMEJBQTBCLGdFQUFhO0FBQ3ZDLGFBQWEsdUVBQWdCLGVBQWUsZ0VBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdFQUFhLCtCQUErQixnRUFBYTtBQUNuRjtBQUNBO0FBQ0EseUNBQXlDLGdFQUFhO0FBQ3RELDRCQUE0QixVQUFVLElBQUksS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzWEE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUNoRDtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFdBQVc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxXQUFXO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsV0FBVztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxXQUFXO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNo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Q0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLGtCQUFrQixDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQy9KLFVBQVUsQ0FBQyxTQUFTLEdBQUcscUJBQXFCLENBQUM7UUFDN0MsdUJBQXVCLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRWhELDJCQUEyQjtRQUMzQixNQUFNLFlBQVksR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3RELFlBQVksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3ZDLFlBQVksQ0FBQyxPQUFPLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxrQkFBa0IsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxrQkFBa0IsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3SyxZQUFZLENBQUMsU0FBUyxHQUFHLDJCQUEyQixDQUFDO1FBQ3JELHVCQUF1QixDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUVuRCxDQUFDO0NBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9Db21tb24vZGlzdC9lc20vRXZlbnQvRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9Db21tb24vZGlzdC9lc20vTG9nZ2VyL0xvZ2dlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vQ29tbW9uL2Rpc3QvZXNtL01lc3NhZ2VzL21lc3NhZ2VfaGVscGVycy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vQ29tbW9uL2Rpc3QvZXNtL01lc3NhZ2VzL21lc3NhZ2VfcmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL0NvbW1vbi9kaXN0L2VzbS9NZXNzYWdlcy9zaWduYWxsaW5nX21lc3NhZ2VzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9Db21tb24vZGlzdC9lc20vUHJvdG9jb2wvS2VlcGFsaXZlTW9uaXRvci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vQ29tbW9uL2Rpc3QvZXNtL1Byb3RvY29sL1NpZ25hbGxpbmdQcm90b2NvbC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vQ29tbW9uL2Rpc3QvZXNtL1RyYW5zcG9ydC9XZWJTb2NrZXRUcmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL0NvbW1vbi9kaXN0L2VzbS9VdGlsL1NkcFV0aWxzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZS5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvUHJpbWl0aXZlLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Qcm9wZXJ0eUtleS5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvYmFzZTY0LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L2JpbmFyeS1mb3JtYXQtY29udHJhY3QuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvYmluYXJ5LXJlYWRlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9iaW5hcnktd3JpdGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L2dvb2ctdmFyaW50LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L2pzb24tZm9ybWF0LWNvbnRyYWN0LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L2pzb24tdHlwaW5ncy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9sb3dlci1jYW1lbC1jYXNlLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L21lc3NhZ2UtdHlwZS1jb250cmFjdC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9tZXNzYWdlLXR5cGUuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvb25lb2YuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvcGItbG9uZy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9yZWZsZWN0aW9uLWJpbmFyeS1yZWFkZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvcmVmbGVjdGlvbi1iaW5hcnktd3JpdGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L3JlZmxlY3Rpb24tY3JlYXRlLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L3JlZmxlY3Rpb24tZXF1YWxzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L3JlZmxlY3Rpb24taW5mby5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9yZWZsZWN0aW9uLWpzb24tcmVhZGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L3JlZmxlY3Rpb24tanNvbi13cml0ZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvcmVmbGVjdGlvbi1sb25nLWNvbnZlcnQuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvcmVmbGVjdGlvbi1tZXJnZS1wYXJ0aWFsLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L3JlZmxlY3Rpb24tc2NhbGFyLWRlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvcmVmbGVjdGlvbi10eXBlLWNoZWNrLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaHlwaGVuYXRlLXN0eWxlLW5hbWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9pcy1pbi1icm93c2VyL2Rpc3QvbW9kdWxlLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvanNzLXBsdWdpbi1jYW1lbC1jYXNlL2Rpc3QvanNzLXBsdWdpbi1jYW1lbC1jYXNlLmVzbS5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tZ2xvYmFsL2Rpc3QvanNzLXBsdWdpbi1nbG9iYWwuZXNtLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvanNzL2Rpc3QvanNzLmVzbS5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NkcC9zZHAuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90aW55LXdhcm5pbmcvZGlzdC90aW55LXdhcm5pbmcuZXNtLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0FGSy9BRktDb250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0NvbmZpZy9Db25maWcuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vQ29uZmlnL1NldHRpbmdCYXNlLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0NvbmZpZy9TZXR0aW5nRmxhZy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9Db25maWcvU2V0dGluZ051bWJlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9Db25maWcvU2V0dGluZ09wdGlvbi5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9Db25maWcvU2V0dGluZ1RleHQuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vRGF0YUNoYW5uZWwvRGF0YUNoYW5uZWxDb250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0RhdGFDaGFubmVsL0RhdGFDaGFubmVsTGF0ZW5jeVRlc3RDb250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0RhdGFDaGFubmVsL0RhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXN1bHRzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0RhdGFDaGFubmVsL0RhdGFDaGFubmVsU2VuZGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0RhdGFDaGFubmVsL0luaXRpYWxTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9EYXRhQ2hhbm5lbC9MYXRlbmN5VGVzdFJlc3VsdHMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vRnJlZXplRnJhbWUvRnJlZXplRnJhbWUuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vRnJlZXplRnJhbWUvRnJlZXplRnJhbWVDb250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0lucHV0cy9HYW1lcGFkQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9JbnB1dHMvR2FtZXBhZFR5cGVzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0lucHV0cy9JbnB1dENsYXNzZXNGYWN0b3J5LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0lucHV0cy9LZXlDb2Rlcy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9JbnB1dHMvS2V5Ym9hcmRDb250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0lucHV0cy9Nb3VzZUJ1dHRvbnMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vSW5wdXRzL01vdXNlQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9JbnB1dHMvTW91c2VDb250cm9sbGVySG92ZXJpbmcuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vSW5wdXRzL01vdXNlQ29udHJvbGxlckxvY2tlZC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9JbnB1dHMvU3BlY2lhbEtleUNvZGVzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0lucHV0cy9Ub3VjaENvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vSW5wdXRzL1RvdWNoQ29udHJvbGxlckZha2UuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vSW5wdXRzL1hSR2FtZXBhZENvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vUGVlckNvbm5lY3Rpb25Db250cm9sbGVyL0FnZ3JlZ2F0ZWRTdGF0cy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9QZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIvQ2FuZGlkYXRlU3RhdC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9QZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIvRGF0YUNoYW5uZWxTdGF0cy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9QZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIvSW5ib3VuZFJUUFN0YXRzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1BlZXJDb25uZWN0aW9uQ29udHJvbGxlci9MYXRlbmN5Q2FsY3VsYXRvci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9QZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIvT3V0Qm91bmRSVFBTdGF0cy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9QZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIvUGVlckNvbm5lY3Rpb25Db250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1BlZXJDb25uZWN0aW9uQ29udHJvbGxlci9TZXNzaW9uU3RhdHMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vUGVlckNvbm5lY3Rpb25Db250cm9sbGVyL1N0cmVhbVN0YXRzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1BpeGVsU3RyZWFtaW5nL1BpeGVsU3RyZWFtaW5nLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1VlSW5zdGFuY2VNZXNzYWdlL1Jlc3BvbnNlQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9VZUluc3RhbmNlTWVzc2FnZS9TZW5kTWVzc2FnZUNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vVWVJbnN0YW5jZU1lc3NhZ2UvU3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vVWVJbnN0YW5jZU1lc3NhZ2UvVG9TdHJlYW1lck1lc3NhZ2VzQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9VdGlsL0Jyb3dzZXJVdGlscy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9VdGlsL0V2ZW50RW1pdHRlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9VdGlsL0ZpbGVVdGlsLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1V0aWwvSVVSTFNlYXJjaFBhcmFtcy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9VdGlsL0lucHV0Q29vcmRUcmFuc2xhdG9yLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1V0aWwvUlRDVXRpbHMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vVmlkZW9QbGF5ZXIvU3RyZWFtQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9WaWRlb1BsYXllci9WaWRlb1BsYXllci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9XZWJSdGNQbGF5ZXIvV2ViUnRjUGxheWVyQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9XZWJYUi9XZWJYUkNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vQXBwbGljYXRpb24vQXBwbGljYXRpb24uanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vQ29uZmlnL0NvbmZpZ1VJLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL0NvbmZpZy9TZXR0aW5nVUlCYXNlLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL0NvbmZpZy9TZXR0aW5nVUlGbGFnLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL0NvbmZpZy9TZXR0aW5nVUlOdW1iZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vQ29uZmlnL1NldHRpbmdVSU9wdGlvbi5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9Db25maWcvU2V0dGluZ1VJVGV4dC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9PdmVybGF5L0FGS092ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vT3ZlcmxheS9BY3Rpb25PdmVybGF5LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL092ZXJsYXkvQmFzZU92ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vT3ZlcmxheS9Db25uZWN0T3ZlcmxheS5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9PdmVybGF5L0Rpc2Nvbm5lY3RPdmVybGF5LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL092ZXJsYXkvRXJyb3JPdmVybGF5LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL092ZXJsYXkvSW5mb092ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vT3ZlcmxheS9QbGF5T3ZlcmxheS5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9PdmVybGF5L1RleHRPdmVybGF5LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL1N0eWxlcy9QaXhlbFN0cmVhbWluZ0FwcGxpY2F0aW9uU3R5bGVzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL1VJL0NvbnRyb2xzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL1VJL0RhdGFDaGFubmVsTGF0ZW5jeVRlc3QuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vVUkvRWRpdFRleHRNb2RhbC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9VSS9GdWxsc2NyZWVuSWNvbi5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9VSS9MYWJlbGxlZEJ1dHRvbi5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9VSS9MYXRlbmN5VGVzdC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9VSS9TZXNzaW9uVGVzdC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9VSS9TZXR0aW5nc0ljb24uanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vVUkvU2V0dGluZ3NQYW5lbC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9VSS9TdGF0c0ljb24uanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vVUkvU3RhdHNQYW5lbC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9VSS9VSUNvbmZpZ3VyYXRpb25UeXBlcy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9VSS9WaWRlb1FwSW5kaWNhdG9yLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL1VJL1hSSWNvbi5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9VdGlsL01hdGhVdGlscy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4vc3JjL3Nob3djYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImVwaWNnYW1lcy1mcm9udGVuZFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJlcGljZ2FtZXMtZnJvbnRlbmRcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCAoKSA9PiB7XG5yZXR1cm4gIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFRvIG1hdGNoIE5vZGVKUycgRXZlbnRFbWl0dGVyIHN5bnRheCB3aXRob3V0IGRvd25zdHJlYW0gY29kZSBjaGFuZ2VzIHdlIG5lZWQgdG8gdXNlIGBhbnlgLlxuLy8gVGhpcyBtZWFucyB3ZSBuZWVkIHRvIGRpc2FibGUgbGludGluZyBgYW55YCBjaGVja3Mgb24gdGhpcyBmaWxlLlxuLy9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQgKi9cbmNsYXNzIFBpeGVsU3RyZWFtaW5nRXZlbnRMaXN0ZW5lciB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fYXJncyA9IFtdO1xuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBoYW5kbGVFdmVudChfZXZ0KSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrKC4uLnRoaXMuX2FyZ3MpO1xuICAgICAgICAvLyBSZXNldCBzdG9yYWdlIG9mIGFyZ3MuXG4gICAgICAgIHRoaXMuX2FyZ3MgPSBbXTtcbiAgICB9XG4gICAgc2V0QXJncyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2FyZ3MgPSBhcmdzO1xuICAgIH1cbn1cbi8qKlxuICogQSBmZWF0dXJlLWxpbWl0ZWQsIGJ1dCBfbW9zdGx5XyBkcm9wLWluIHJlcGxhY2VtZW50IGZvciBOb2RlJ3MgRXZlbnRFbWl0dGVyIHR5cGUgdGhhdCBpcyBpbXBsZW1lbnRlZCB1c2luZyBFdmVudFRhcmdldC5cbiAqXG4gKiBGb3IgdGhvc2UgdW5mYW1pbGlhciB3aXRoIE5vZGUncyBFdmVudEVtaXR0ZXIsIGhlcmUgaXMgc29tZSBpbmZvIGZyb20gdGhlIG9mZmljaWFsIGRvY3M6XG4gKlxuICogW0luIE5vZGVKU10gYWxsIG9iamVjdHMgdGhhdCBlbWl0IGV2ZW50cyBhcmUgaW5zdGFuY2VzIG9mIHRoZSBgRXZlbnRFbWl0dGVyYCBjbGFzcy4gVGhlc2VcbiAqIG9iamVjdHMgZXhwb3NlIGFuIGBldmVudEVtaXR0ZXIub24oKWAgZnVuY3Rpb24gdGhhdCBhbGxvd3Mgb25lIG9yIG1vcmVcbiAqIGZ1bmN0aW9ucyB0byBiZSBhdHRhY2hlZCB0byBuYW1lZCBldmVudHMgZW1pdHRlZCBieSB0aGUgb2JqZWN0LiBUeXBpY2FsbHksXG4gKiBldmVudCBuYW1lcyBhcmUgY2FtZWwtY2FzZWQgc3RyaW5ncyBidXQgYW55IHZhbGlkIEphdmFTY3JpcHQgcHJvcGVydHkga2V5XG4gKiBjYW4gYmUgdXNlZC5cbiAqXG4gKiBXaGVuIHRoZSBgRXZlbnRFbWl0dGVyYCBvYmplY3QgZW1pdHMgYW4gZXZlbnQsIGFsbCBvZiB0aGUgZnVuY3Rpb25zIGF0dGFjaGVkXG4gKiB0byB0aGF0IHNwZWNpZmljIGV2ZW50IGFyZSBjYWxsZWQgX3N5bmNocm9ub3VzbHlfLiBBbnkgdmFsdWVzIHJldHVybmVkIGJ5IHRoZVxuICogY2FsbGVkIGxpc3RlbmVycyBhcmUgX2lnbm9yZWRfIGFuZCBkaXNjYXJkZWQuXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGEgc2ltcGxlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlIHdpdGggYSBzaW5nbGVcbiAqIGxpc3RlbmVyLiBUaGUgYGV2ZW50RW1pdHRlci5vbigpYCBtZXRob2QgaXMgdXNlZCB0byByZWdpc3RlciBsaXN0ZW5lcnMsIHdoaWxlXG4gKiB0aGUgYGV2ZW50RW1pdHRlci5lbWl0KClgIG1ldGhvZCBpcyB1c2VkIHRvIHRyaWdnZXIgdGhlIGV2ZW50LlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdub2RlOmV2ZW50cyc7XG4gKlxuICogY2xhc3MgTXlFbWl0dGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHt9XG4gKlxuICogY29uc3QgbXlFbWl0dGVyID0gbmV3IE15RW1pdHRlcigpO1xuICogbXlFbWl0dGVyLm9uKCdldmVudCcsICgpID0+IHtcbiAqICAgY29uc29sZS5sb2coJ2FuIGV2ZW50IG9jY3VycmVkIScpO1xuICogfSk7XG4gKiBteUVtaXR0ZXIuZW1pdCgnZXZlbnQnKTtcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgRXZlbnRFbWl0dGVyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXJJbnRlcm5hbChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudExpc3RlbmVycy5oYXMoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRQYWlyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChldmVudFBhaXIuY2FsbGJhY2sgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGV2ZW50IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICBzdXBlci5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRQYWlyLmV2ZW50TGlzdGVuZXJXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gb3VyIGludGVybmFsIG1hcFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBgZW1pdHRlci5vbihldmVudE5hbWUsIGxpc3RlbmVyKWAuXG4gICAgICovXG4gICAgYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgYGxpc3RlbmVyYCBmdW5jdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkgZm9yIHRoZSBldmVudFxuICAgICAqIG5hbWVkIGBldmVudE5hbWVgLlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBzZXJ2ZXIub24oJ2Nvbm5lY3Rpb24nLCAoc3RyZWFtKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygnc29tZW9uZSBjb25uZWN0ZWQhJyk7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCwgc28gdGhhdCBjYWxscyBjYW4gYmUgY2hhaW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICovXG4gICAgb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFdyYXAgb3VyIG5vcm1hbCBKUyBmdW5jdGlvbiBpbiBhIGV2ZW50IGxpc3RlbmVyIGludGVyZmFjZVxuICAgICAgICAvLyBzbyB3ZSBjYW4gdXNlIGl0IHdpdGggZXZlbnQgdGFyZ2V0LlxuICAgICAgICBjb25zdCBldmVudExpc3RlbmVyV3JhcHBlciA9IG5ldyBQaXhlbFN0cmVhbWluZ0V2ZW50TGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICBzdXBlci5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lcldyYXBwZXIpO1xuICAgICAgICAvLyBTdG9yZSB0aGUgZXZlbnQgbGlzdGVuZXIvZnVuY3Rpb24gcGFpciBmb3IgbGF0ZXIgcmVtb3ZhbC5cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudExpc3RlbmVycy5oYXMoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbmV3IEFycmF5KCkpO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzXG4gICAgICAgICAgICAuZ2V0KGV2ZW50TmFtZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wdXNoKHsgY2FsbGJhY2s6IGxpc3RlbmVyLCBldmVudExpc3RlbmVyV3JhcHBlcjogZXZlbnRMaXN0ZW5lcldyYXBwZXIgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgKipvbmUtdGltZSoqIGBsaXN0ZW5lcmAgZnVuY3Rpb24gZm9yIHRoZSBldmVudCBuYW1lZCBgZXZlbnROYW1lYC4gVGhlXG4gICAgICogbmV4dCB0aW1lIGBldmVudE5hbWVgIGlzIHRyaWdnZXJlZCwgdGhpcyBsaXN0ZW5lciBpcyByZW1vdmVkIGFuZCB0aGVuIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIHNlcnZlci5vbmNlKCdjb25uZWN0aW9uJywgKHN0cmVhbSkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ0FoLCB3ZSBoYXZlIG91ciBmaXJzdCB1c2VyIScpO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAsIHNvIHRoYXQgY2FsbHMgY2FuIGJlIGNoYWluZWQuXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBQYXNzIG9wdGlvbnMgc28gdGhpcyBldmVudCBjYWxsYmFjayBpcyBvbmx5IGNhbGxlZCBvbmNlXG4gICAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJPcHRzID0geyBvbmNlOiB0cnVlIH07XG4gICAgICAgIC8vIFdyYXAgb3VyIG5vcm1hbCBKUyBmdW5jdGlvbiBpbiBhIGV2ZW50IGxpc3RlbmVyIGludGVyZmFjZVxuICAgICAgICAvLyBzbyB3ZSBjYW4gdXNlIGl0IHdpdGggZXZlbnQgdGFyZ2V0IGFuZCByZW1vdmUgaXQgZnJvbSBldmVudCB0YXJnZXQgd2hlbiB0aGlzIGZ1bmN0aW9uIGNvbXBsZXRlcy5cbiAgICAgICAgY29uc3QgZXZlbnRMaXN0ZW5lcldyYXBwZXIgPSBuZXcgUGl4ZWxTdHJlYW1pbmdFdmVudExpc3RlbmVyKCguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBsaXN0ZW5lcihhcmdzKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJJbnRlcm5hbChldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN1cGVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudExpc3RlbmVyV3JhcHBlciwgZXZlbnRMaXN0ZW5lck9wdHMpO1xuICAgICAgICAvLyBTdG9yZSB0aGUgZXZlbnQgbGlzdGVuZXIvZnVuY3Rpb24gcGFpciBmb3IgbGF0ZXIgcmVtb3ZhbC5cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudExpc3RlbmVycy5oYXMoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbmV3IEFycmF5KCkpO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzXG4gICAgICAgICAgICAuZ2V0KGV2ZW50TmFtZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wdXNoKHsgY2FsbGJhY2s6IGxpc3RlbmVyLCBldmVudExpc3RlbmVyV3JhcHBlcjogZXZlbnRMaXN0ZW5lcldyYXBwZXIgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgYGxpc3RlbmVyYCBmcm9tIHRoaXMgRXZlbnRFbWl0dGVyLlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBjYWxsYmFjayA9IChzdHJlYW0pID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdzb21lb25lIGNvbm5lY3RlZCEnKTtcbiAgICAgKiB9O1xuICAgICAqIHNlcnZlci5vbignY29ubmVjdGlvbicsIGNhbGxiYWNrKTtcbiAgICAgKiAvLyAuLi5cbiAgICAgKiBzZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoJ2Nvbm5lY3Rpb24nLCBjYWxsYmFjayk7XG4gICAgICogYGBgXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAsIHNvIHRoYXQgY2FsbHMgY2FuIGJlIGNoYWluZWQuXG4gICAgICovXG4gICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVySW50ZXJuYWwoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3IgYGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoKWAuXG4gICAgICovXG4gICAgb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBgZXZlbnROYW1lYC5cbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCwgc28gdGhhdCBjYWxscyBjYW4gYmUgY2hhaW5lZC5cbiAgICAgKi9cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudExpc3RlbmVycy5oYXMoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBlYWNoIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhlIGV2ZW50IHRhcmdldFxuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lclBhaXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXJQYWlyLmV2ZW50TGlzdGVuZXJXcmFwcGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgZXZlbnQgbGlzdGVuZXJzIG1hcHBlZCB0byB0aGlzIGV2ZW50IGZyb20gb3VyIGludGVybmFsIG1hcFxuICAgICAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9ub3VzbHkgY2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIHRoZSBldmVudCBuYW1lZCBgZXZlbnROYW1lYCwgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSByZWdpc3RlcmVkLCBwYXNzaW5nIHRoZSBzdXBwbGllZCBhcmd1bWVudHNcbiAgICAgKiB0byBlYWNoLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdub2RlOmV2ZW50cyc7XG4gICAgICogY29uc3QgbXlFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAqXG4gICAgICogLy8gRmlyc3QgbGlzdGVuZXJcbiAgICAgKiBteUVtaXR0ZXIub24oJ2V2ZW50JywgZnVuY3Rpb24gZmlyc3RMaXN0ZW5lcigpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdIZWxsb29vbyEgZmlyc3QgbGlzdGVuZXInKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyBTZWNvbmQgbGlzdGVuZXJcbiAgICAgKiBteUVtaXR0ZXIub24oJ2V2ZW50JywgZnVuY3Rpb24gc2Vjb25kTGlzdGVuZXIoYXJnMSwgYXJnMikge1xuICAgICAqICAgY29uc29sZS5sb2coYGV2ZW50IHdpdGggcGFyYW1ldGVycyAke2FyZzF9LCAke2FyZzJ9IGluIHNlY29uZCBsaXN0ZW5lcmApO1xuICAgICAqIH0pO1xuICAgICAqIC8vIFRoaXJkIGxpc3RlbmVyXG4gICAgICogbXlFbWl0dGVyLm9uKCdldmVudCcsIGZ1bmN0aW9uIHRoaXJkTGlzdGVuZXIoLi4uYXJncykge1xuICAgICAqICAgY29uc3QgcGFyYW1ldGVycyA9IGFyZ3Muam9pbignLCAnKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGBldmVudCB3aXRoIHBhcmFtZXRlcnMgJHtwYXJhbWV0ZXJzfSBpbiB0aGlyZCBsaXN0ZW5lcmApO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cobXlFbWl0dGVyLmxpc3RlbmVycygnZXZlbnQnKSk7XG4gICAgICpcbiAgICAgKiBteUVtaXR0ZXIuZW1pdCgnZXZlbnQnLCAxLCAyLCAzLCA0LCA1KTtcbiAgICAgKlxuICAgICAqIC8vIFByaW50czpcbiAgICAgKiAvLyBbXG4gICAgICogLy8gICBbRnVuY3Rpb246IGZpcnN0TGlzdGVuZXJdLFxuICAgICAqIC8vICAgW0Z1bmN0aW9uOiBzZWNvbmRMaXN0ZW5lcl0sXG4gICAgICogLy8gICBbRnVuY3Rpb246IHRoaXJkTGlzdGVuZXJdXG4gICAgICogLy8gXVxuICAgICAqIC8vIEhlbGxvb29vISBmaXJzdCBsaXN0ZW5lclxuICAgICAqIC8vIGV2ZW50IHdpdGggcGFyYW1ldGVycyAxLCAyIGluIHNlY29uZCBsaXN0ZW5lclxuICAgICAqIC8vIGV2ZW50IHdpdGggcGFyYW1ldGVycyAxLCAyLCAzLCA0LCA1IGluIHRoaXJkIGxpc3RlbmVyXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50TGlzdGVuZXJzLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudExpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVuc3VyZSBlYWNoIG9mIG91ciBsaXN0ZW5lcnMgaGF2ZSB0aGUgYXJncyB0aGUgY2FsbGJhY2sgaW5qZWN0ZWRcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXJQYWlyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyUGFpci5ldmVudExpc3RlbmVyV3JhcHBlci5zZXRBcmdzKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmlyZSBvZmYgdGhlIGFjdHVhbCBldmVudFxuICAgICAgICAgICAgc3VwZXIuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoZXZlbnROYW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRFbWl0dGVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5leHBvcnQgdmFyIExvZ0xldmVsO1xuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRGlzYWJsZWRcIl0gPSAwXSA9IFwiRGlzYWJsZWRcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVycm9yXCJdID0gMV0gPSBcIkVycm9yXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJXYXJuaW5nXCJdID0gMl0gPSBcIldhcm5pbmdcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkluZm9cIl0gPSAzXSA9IFwiSW5mb1wiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRGVidWdcIl0gPSA0XSA9IFwiRGVidWdcIjtcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XG4vKipcbiAqIFRoZSBnbG9iYWwgY29udGV4dCBmb3IgdGhlIGxvZ2dlciBjb25maWd1cmF0aW9uLlxuICogVGhpcyBjYW5ub3QgYmUgc3RvcmVkIHN0YXRpY2FsbHkgaW4gdGhlIExvZ2dlciBjbGFzcyBiZWNhdXNlIHdlIHNvbWV0aW1lcyBoYXZlIG11bHRpcGxlIGV4ZWN1dGlvblxuICogY29udGV4dHMsIHN1Y2ggYXMgc3RhdHMgcmVwb3J0aW5nLiBJbnN0ZWFkIHdlIHN0b3JlIHRoZSBsb2dnZXIgY29uZmlnIGNvbnRleHQgb24gdGhlIHdpbmRvdyBvYmplY3RcbiAqIHRvIGJlIHNoYXJlZCB3aXRoIGFueSBMb2dnZXIgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgY2xhc3MgTG9nZ2VyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPSBMb2dMZXZlbC5EZWJ1ZztcbiAgICAgICAgdGhpcy5pbmNsdWRlU3RhY2sgPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBvdmVycmlkZUxvZ2dlcihsb2dnZXIpIHtcbiAgICBMb2dnZXIgPSBsb2dnZXI7XG59XG4vKipcbiAqIEEgYmFzaWMgY29uc29sZSBsb2dnZXIgdXRpbGl6ZWQgYnkgdGhlIFBpeGVsIFN0cmVhbWluZyBmcm9udGVuZCB0byBhbGxvd1xuICogbG9nZ2luZyB0byB0aGUgYnJvd3NlciBjb25zb2xlLlxuICovXG5leHBvcnQgY2xhc3MgTG9nZ2VyVHlwZSB7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsb2cgdmVyYm9zaXR5IGxldmVsXG4gICAgICovXG4gICAgSW5pdExvZ2dpbmcobG9nTGV2ZWwsIGluY2x1ZGVTdGFjaykge1xuICAgICAgICB0aGlzLlZhbGlkYXRlQ29udGV4dCgpO1xuICAgICAgICB0aGlzLmNvbnRleHQubG9nTGV2ZWwgPSBsb2dMZXZlbDtcbiAgICAgICAgdGhpcy5jb250ZXh0LmluY2x1ZGVTdGFjayA9IGluY2x1ZGVTdGFjaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nZ2luZyBvdXRwdXQgZm9yIGRlYnVnZ2luZ1xuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gdGhlIG1lc3NhZ2UgdG8gYmUgbG9nZ2VkXG4gICAgICovXG4gICAgRGVidWcobWVzc2FnZSkge1xuICAgICAgICB0aGlzLlZhbGlkYXRlQ29udGV4dCgpO1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmxvZ0xldmVsID49IExvZ0xldmVsLkRlYnVnKSB7XG4gICAgICAgICAgICB0aGlzLkNvbW1vbkxvZygnRGVidWcnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXNpYyBsb2dnaW5nIG91dHB1dCBmb3Igc3RhbmRhcmQgbWVzc2FnZXNcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZFxuICAgICAqL1xuICAgIEluZm8obWVzc2FnZSkge1xuICAgICAgICB0aGlzLlZhbGlkYXRlQ29udGV4dCgpO1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmxvZ0xldmVsID49IExvZ0xldmVsLkluZm8pIHtcbiAgICAgICAgICAgIHRoaXMuQ29tbW9uTG9nKCdJbmZvJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nZ2luZyBmb3Igd2FybmluZ3NcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZFxuICAgICAqL1xuICAgIFdhcm5pbmcobWVzc2FnZSkge1xuICAgICAgICB0aGlzLlZhbGlkYXRlQ29udGV4dCgpO1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmxvZ0xldmVsID49IExvZ0xldmVsLldhcm5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuQ29tbW9uTG9nKCdXYXJuaW5nJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXJyb3IgbG9nZ2luZ1xuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gdGhlIG1lc3NhZ2UgdG8gYmUgbG9nZ2VkXG4gICAgICovXG4gICAgRXJyb3IobWVzc2FnZSkge1xuICAgICAgICB0aGlzLlZhbGlkYXRlQ29udGV4dCgpO1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmxvZ0xldmVsID49IExvZ0xldmVsLkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLkNvbW1vbkxvZygnRXJyb3InLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29tbW9uIGxvZyBmdW5jdGlvbiB0aGF0IGFsbCBvdGhlciBsb2cgZnVuY3Rpb25zIGNhbGwgdG8uXG4gICAgICogQHBhcmFtIGxldmVsIC0gdGhlIGxldmVsIG9mIHRoaXMgbG9nIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHN0YWNrIC0gYW4gb3B0aW9uYWwgc3RhY2sgdHJhY2Ugc3RyaW5nIGZyb20gd2hlcmUgdGhlIGxvZyBtZXNzYWdlIHdhcyBjYWxsZWQuXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWQuXG4gICAgICovXG4gICAgQ29tbW9uTG9nKGxldmVsLCBtZXNzYWdlKSB7XG4gICAgICAgIGxldCBsb2dNZXNzYWdlID0gYFske2xldmVsfV0gLSAke21lc3NhZ2V9YDtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5pbmNsdWRlU3RhY2spIHtcbiAgICAgICAgICAgIGxvZ01lc3NhZ2UgKz0gYFxcblN0YWNrOiAke3RoaXMuR2V0U3RhY2tUcmFjZSgpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxldmVsID09PSAnRXJyb3InKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGxvZ01lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxldmVsID09PSAnV2FybmluZycpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybihsb2dNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGxvZ01lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhcHR1cmVzIHRoZSBzdGFjayBhbmQgcmV0dXJucyBpdFxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHN0YWNrXG4gICAgICovXG4gICAgR2V0U3RhY2tUcmFjZSgpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgbGV0IGZvcm1hdHRlZFN0YWNrID0gJ05vIFN0YWNrIEF2YWlsYWJsZSBmb3IgdGhpcyBicm93c2VyJztcbiAgICAgICAgLy8gZm9ybWF0IHRoZSBlcnJvclxuICAgICAgICBpZiAoZXJyb3Iuc3RhY2spIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0YWNrID0gZXJyb3Iuc3RhY2sudG9TdHJpbmcoKS5yZXBsYWNlKC9FcnJvci9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFN0YWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW5jZSB0aGVyZSBjYW4gYmUgbXVsdGlwbGUgZXhlY3V0aW9uIGNvbnRleHRzLCAoc3RhdHMgcmVwb3J0aW5nIGFuZCBzb21lIHdlYnhyIGxvZ2dpbmcgY29tZXMgZnJvbVxuICAgICAqIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dHMgd2UgY2FuIGVuZCB1cCB3aXRoIG11bHRpcGxlIHN0YXRpYyBMb2dnZXIgaW5zdGFuY2VzLiBIZXJlIHdlIHRyeSB0b1xuICAgICAqIHdvcmsgYXJvdW5kIGl0IGJ5IHN0b3JpbmcgdGhlIGNvbnRleHQgb24gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAgICovXG4gICAgVmFsaWRhdGVDb250ZXh0KCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdykge1xuICAgICAgICAgICAgICAgIC8vIG5vIHdpbmRvdyBvYmplY3Qgc28gd2UgY2FuIG9ubHkgc3RvcmUgYSBsb2NhbCBjb250ZXh0LlxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IG5ldyBMb2dnZXJDb250ZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghd2luZG93LmxvZ2dlckNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBuZXcgTG9nZ2VyQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2dnZXJDb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gd2luZG93LmxvZ2dlckNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgbGV0IExvZ2dlciA9IG5ldyBMb2dnZXJUeXBlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2dnZXIuanMubWFwIiwiaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vTG9nZ2VyL0xvZ2dlcic7XG5pbXBvcnQgeyBNZXNzYWdlUmVnaXN0cnkgfSBmcm9tICcuL21lc3NhZ2VfcmVnaXN0cnknO1xuLyoqXG4gKiBBIGhlbHBlciBmb3IgY3JlYXRpbmcgc2lnbmFsbGluZyBtZXNzYWdlcy4gVGFrZXMgaW4gb3B0aW9uYWwgZ2l2ZW4gcGFyYW1ldGVycyBhbmRcbiAqIGluY2x1ZGVzIHRoZW0gaW4gYSBtZXNzYWdlIG9iamVjdCB3aXRoIHRoZSAndHlwZScgZmllbGQgc2V0IHByb3Blcmx5IGZvciB0aGUgbWVzc2FnZVxuICogdHlwZSBzdXBwbGllZC5cbiAqIEBwYXJhbSBtZXNzYWdlVHlwZSAtIEEgbWVzc2FnZSB0eXBlIGZyb20gTWVzc2FnZVJlZ2lzdHJ5IHRoYXQgaW5kaWNhdGVzIHRoZSB0eXBlIG9mIG1lc3NhZ2UgdG8gY3JlYXRlLlxuICogQHBhcmFtIHBhcmFtcyAtIEFuIG9wdGlvbmFsIG9iamVjdCB3aG9zZSBmaWVsZHMgYXJlIGFkZGVkIHRvIHRoZSBuZXdseSBjcmVhdGVkIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBUaGUgcmVzdWx0aW5nIG1lc3NhZ2Ugb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWVzc2FnZShtZXNzYWdlVHlwZSwgcGFyYW1zKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VUeXBlLmNyZWF0ZSgpO1xuICAgIG1lc3NhZ2UudHlwZSA9IG1lc3NhZ2VUeXBlLnR5cGVOYW1lO1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgbWVzc2FnZVR5cGUubWVyZ2VQYXJ0aWFsKG1lc3NhZ2UsIHBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xufVxuLyoqXG4gKiBUZXN0cyB0aGF0IHRoZSBzdXBwbGllZCBtZXNzYWdlIGlzIHZhbGlkLiBUaGF0IGlzIGNvbnRhaW5zIGFsbCBleHBlY3RlZCBmaWVsZHMgYW5kXG4gKiBkb2Vzbid0IGNvbnRhaW4gYW55IHVua25vd24gZmllbGRzLlxuICogQHBhcmFtIG1zZyAtIFRoZSBtZXNzYWdlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybnMgVGhlIG1lc3NhZ2UgdHlwZSBmcm9tIE1lc3NhZ2VSZWdpc3RyeSBvZiB0aGUgc3VwcGxpZWQgbWVzc2FnZSBvYmplY3QgaWYgaXQncyB2YWxpZCwgb3IgbnVsbCBpZiBpbnZhbGlkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlKG1zZykge1xuICAgIGxldCB2YWxpZCA9IHRydWU7XG4gICAgaWYgKCFtc2cudHlwZSkge1xuICAgICAgICBMb2dnZXIuRXJyb3IoYFBhcnNlZCBtZXNzYWdlIGhhcyBubyB0eXBlLiBSZWplY3RlZC4gJHtKU09OLnN0cmluZ2lmeShtc2cpfWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZVR5cGUgPSBNZXNzYWdlUmVnaXN0cnlbbXNnLnR5cGVdO1xuICAgIGlmICghbWVzc2FnZVR5cGUpIHtcbiAgICAgICAgTG9nZ2VyLkVycm9yKGBNZXNzYWdlIGlzIG9mIGFuIHVua25vd24gdHlwZTogXCIke21zZy50eXBlfVwiLiBSZWplY3RlZC5gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlVHlwZS5maWVsZHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBtZXNzYWdlVHlwZS5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmICghZmllbGQub3B0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobXNnLCBmaWVsZC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoYE1lc3NhZ2UgXCIke21zZy50eXBlfVwiXCIgaXMgbWlzc2luZyByZXF1aXJlZCBmaWVsZCBcIiR7ZmllbGQubmFtZX1cIi4gUmVqZWN0ZWQuYCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmllbGROYW1lIGluIG1zZykge1xuICAgICAgICBjb25zdCBmb3VuZCA9IG1lc3NhZ2VUeXBlLmZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQubmFtZSA9PT0gZmllbGROYW1lKTtcbiAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBNZXNzYWdlIFwiJHttc2cudHlwZX1cIiBjb250YWlucyB1bmtub3duIGZpZWxkIFwiJHtmaWVsZE5hbWV9XCIuIFJlamVjdGVkLmApO1xuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsaWQgPyBtZXNzYWdlVHlwZSA6IG51bGw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlX2hlbHBlcnMuanMubWFwIiwiaW1wb3J0ICogYXMgTWVzc2FnZXMgZnJvbSAnLi9zaWduYWxsaW5nX21lc3NhZ2VzJztcbi8qKlxuICogQSBtYXAgb2YgYWxsIHRoZSBzdXBwb3J0ZWQgc2lnbmFsbGluZyBtZXNzYWdlcyBpbiB0aGUgUGl4ZWwgU3RyZWFtaW5nXG4gKiBzaWduYWxsaW5nIHByb3RvY29sLiBUaGlzIGFsbG93cyBtYXBwaW5nIG9mIHNpZ25hbGxpbmcgbWVzc2FnZSBuYW1lc1xuICogdG8gYWN0dWFsIG1lc3NhZ2UgdHlwZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBNZXNzYWdlUmVnaXN0cnkgPSB7XG4gICAgYW5zd2VyOiBNZXNzYWdlcy5hbnN3ZXIsXG4gICAgY29uZmlnOiBNZXNzYWdlcy5jb25maWcsXG4gICAgZGlzY29ubmVjdFBsYXllcjogTWVzc2FnZXMuZGlzY29ubmVjdFBsYXllcixcbiAgICBlbmRwb2ludElkOiBNZXNzYWdlcy5lbmRwb2ludElkLFxuICAgIGVuZHBvaW50SWRDb25maXJtOiBNZXNzYWdlcy5lbmRwb2ludElkQ29uZmlybSxcbiAgICBpY2VDYW5kaWRhdGU6IE1lc3NhZ2VzLmljZUNhbmRpZGF0ZSxcbiAgICBpZGVudGlmeTogTWVzc2FnZXMuaWRlbnRpZnksXG4gICAgbGlzdFN0cmVhbWVyczogTWVzc2FnZXMubGlzdFN0cmVhbWVycyxcbiAgICBvZmZlcjogTWVzc2FnZXMub2ZmZXIsXG4gICAgcGluZzogTWVzc2FnZXMucGluZyxcbiAgICBwbGF5ZXJDb25uZWN0ZWQ6IE1lc3NhZ2VzLnBsYXllckNvbm5lY3RlZCxcbiAgICBwbGF5ZXJDb3VudDogTWVzc2FnZXMucGxheWVyQ291bnQsXG4gICAgcGxheWVyRGlzY29ubmVjdGVkOiBNZXNzYWdlcy5wbGF5ZXJEaXNjb25uZWN0ZWQsXG4gICAgcG9uZzogTWVzc2FnZXMucG9uZyxcbiAgICBzdGF0czogTWVzc2FnZXMuc3RhdHMsXG4gICAgc3RyZWFtZXJEaXNjb25uZWN0ZWQ6IE1lc3NhZ2VzLnN0cmVhbWVyRGlzY29ubmVjdGVkLFxuICAgIHN0cmVhbWVyTGlzdDogTWVzc2FnZXMuc3RyZWFtZXJMaXN0LFxuICAgIHN1YnNjcmliZTogTWVzc2FnZXMuc3Vic2NyaWJlLFxuICAgIHVuc3Vic2NyaWJlOiBNZXNzYWdlcy51bnN1YnNjcmliZSxcbiAgICBsYXllclByZWZlcmVuY2U6IE1lc3NhZ2VzLmxheWVyUHJlZmVyZW5jZSxcbiAgICBkYXRhQ2hhbm5lbFJlcXVlc3Q6IE1lc3NhZ2VzLmRhdGFDaGFubmVsUmVxdWVzdCxcbiAgICBwZWVyRGF0YUNoYW5uZWxzOiBNZXNzYWdlcy5wZWVyRGF0YUNoYW5uZWxzLFxuICAgIHBlZXJEYXRhQ2hhbm5lbHNSZWFkeTogTWVzc2FnZXMucGVlckRhdGFDaGFubmVsc1JlYWR5LFxuICAgIHN0cmVhbWVyRGF0YUNoYW5uZWxzOiBNZXNzYWdlcy5zdHJlYW1lckRhdGFDaGFubmVscyxcbiAgICBzdGFydFN0cmVhbWluZzogTWVzc2FnZXMuc3RhcnRTdHJlYW1pbmcsXG4gICAgc3RvcFN0cmVhbWluZzogTWVzc2FnZXMuc3RvcFN0cmVhbWluZ1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2VfcmVnaXN0cnkuanMubWFwIiwiaW1wb3J0IHsgV2lyZVR5cGUgfSBmcm9tIFwiQHByb3RvYnVmLXRzL3J1bnRpbWVcIjtcbmltcG9ydCB7IFVua25vd25GaWVsZEhhbmRsZXIgfSBmcm9tIFwiQHByb3RvYnVmLXRzL3J1bnRpbWVcIjtcbmltcG9ydCB7IHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwgfSBmcm9tIFwiQHByb3RvYnVmLXRzL3J1bnRpbWVcIjtcbmltcG9ydCB7IE1lc3NhZ2VUeXBlIH0gZnJvbSBcIkBwcm90b2J1Zi10cy9ydW50aW1lXCI7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBiYXNlX21lc3NhZ2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJiYXNlX21lc3NhZ2VcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgYmFzZV9tZXNzYWdlXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlX21lc3NhZ2UgPSBuZXcgYmFzZV9tZXNzYWdlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHBlZXJDb25uZWN0aW9uT3B0aW9ucyRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInBlZXJDb25uZWN0aW9uT3B0aW9uc1wiLCBbXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgcGVlckNvbm5lY3Rpb25PcHRpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBwZWVyQ29ubmVjdGlvbk9wdGlvbnMgPSBuZXcgcGVlckNvbm5lY3Rpb25PcHRpb25zJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIGNvbmZpZyRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImNvbmZpZ1wiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwicGVlckNvbm5lY3Rpb25PcHRpb25zXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiAoKSA9PiBwZWVyQ29ubmVjdGlvbk9wdGlvbnMgfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6IFwicHJvdG9jb2xWZXJzaW9uXCIsIGtpbmQ6IFwic2NhbGFyXCIsIG9wdDogdHJ1ZSwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBwZWVyQ29ubmVjdGlvbk9wdGlvbnMgcGVlckNvbm5lY3Rpb25PcHRpb25zICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGVlckNvbm5lY3Rpb25PcHRpb25zID0gcGVlckNvbm5lY3Rpb25PcHRpb25zLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5wZWVyQ29ubmVjdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIG9wdGlvbmFsIHN0cmluZyBwcm90b2NvbFZlcnNpb24gKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcm90b2NvbFZlcnNpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBwZWVyQ29ubmVjdGlvbk9wdGlvbnMgcGVlckNvbm5lY3Rpb25PcHRpb25zID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGVlckNvbm5lY3Rpb25PcHRpb25zKVxuICAgICAgICAgICAgcGVlckNvbm5lY3Rpb25PcHRpb25zLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5wZWVyQ29ubmVjdGlvbk9wdGlvbnMsIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogb3B0aW9uYWwgc3RyaW5nIHByb3RvY29sVmVyc2lvbiA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnByb3RvY29sVmVyc2lvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnByb3RvY29sVmVyc2lvbik7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBjb25maWdcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IG5ldyBjb25maWckVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgaWRlbnRpZnkkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJpZGVudGlmeVwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBpZGVudGlmeVxuICovXG5leHBvcnQgY29uc3QgaWRlbnRpZnkgPSBuZXcgaWRlbnRpZnkkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgZW5kcG9pbnRJZCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImVuZHBvaW50SWRcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcImlkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiBcInByb3RvY29sVmVyc2lvblwiLCBraW5kOiBcInNjYWxhclwiLCBvcHQ6IHRydWUsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5pZCA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBpZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIG9wdGlvbmFsIHN0cmluZyBwcm90b2NvbFZlcnNpb24gKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcm90b2NvbFZlcnNpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBzdHJpbmcgaWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5pZCAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5pZCk7XG4gICAgICAgIC8qIG9wdGlvbmFsIHN0cmluZyBwcm90b2NvbFZlcnNpb24gPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wcm90b2NvbFZlcnNpb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5wcm90b2NvbFZlcnNpb24pO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgZW5kcG9pbnRJZFxuICovXG5leHBvcnQgY29uc3QgZW5kcG9pbnRJZCA9IG5ldyBlbmRwb2ludElkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIGVuZHBvaW50SWRDb25maXJtJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiZW5kcG9pbnRJZENvbmZpcm1cIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcImNvbW1pdHRlZElkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5jb21taXR0ZWRJZCA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBjb21taXR0ZWRJZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbW1pdHRlZElkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyaW5nIGNvbW1pdHRlZElkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY29tbWl0dGVkSWQgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuY29tbWl0dGVkSWQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgZW5kcG9pbnRJZENvbmZpcm1cbiAqL1xuZXhwb3J0IGNvbnN0IGVuZHBvaW50SWRDb25maXJtID0gbmV3IGVuZHBvaW50SWRDb25maXJtJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHN0cmVhbWVySWRDaGFuZ2VkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwic3RyZWFtZXJJZENoYW5nZWRcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcIm5ld0lEXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5uZXdJRCA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBuZXdJRCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5ld0lEID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyaW5nIG5ld0lEID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubmV3SUQgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UubmV3SUQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtZXJJZENoYW5nZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmVhbWVySWRDaGFuZ2VkID0gbmV3IHN0cmVhbWVySWRDaGFuZ2VkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIGxpc3RTdHJlYW1lcnMkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJsaXN0U3RyZWFtZXJzXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGxpc3RTdHJlYW1lcnNcbiAqL1xuZXhwb3J0IGNvbnN0IGxpc3RTdHJlYW1lcnMgPSBuZXcgbGlzdFN0cmVhbWVycyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBzdHJlYW1lckxpc3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJzdHJlYW1lckxpc3RcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcImlkc1wiLCBraW5kOiBcInNjYWxhclwiLCByZXBlYXQ6IDIgLypSZXBlYXRUeXBlLlVOUEFDS0VEKi8sIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5pZHMgPSBbXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyaW5nIGlkcyAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkcy5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJpbmcgaWRzID0gMjsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLmlkcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5pZHNbaV0pO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtZXJMaXN0XG4gKi9cbmV4cG9ydCBjb25zdCBzdHJlYW1lckxpc3QgPSBuZXcgc3RyZWFtZXJMaXN0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHN1YnNjcmliZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInN1YnNjcmliZVwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwic3RyZWFtZXJJZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2Uuc3RyZWFtZXJJZCA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzdHJlYW1lcklkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyZWFtZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBzdHJlYW1lcklkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyZWFtZXJJZCAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zdHJlYW1lcklkKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN1YnNjcmliZVxuICovXG5leHBvcnQgY29uc3Qgc3Vic2NyaWJlID0gbmV3IHN1YnNjcmliZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyB1bnN1YnNjcmliZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInVuc3Vic2NyaWJlXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHVuc3Vic2NyaWJlXG4gKi9cbmV4cG9ydCBjb25zdCB1bnN1YnNjcmliZSA9IG5ldyB1bnN1YnNjcmliZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBzdWJzY3JpYmVGYWlsZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJzdWJzY3JpYmVGYWlsZWRcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcIm1lc3NhZ2VcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLm1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgbWVzc2FnZSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1lc3NhZ2UgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBzdHJpbmcgbWVzc2FnZSA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm1lc3NhZ2UgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdWJzY3JpYmVGYWlsZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHN1YnNjcmliZUZhaWxlZCA9IG5ldyBzdWJzY3JpYmVGYWlsZWQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgcGxheWVyQ29ubmVjdGVkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwicGxheWVyQ29ubmVjdGVkXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJkYXRhQ2hhbm5lbFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6IFwic2Z1XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICAgICAgeyBubzogNSwgbmFtZTogXCJwbGF5ZXJJZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuZGF0YUNoYW5uZWwgPSBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5zZnUgPSBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5wbGF5ZXJJZCA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgZGF0YUNoYW5uZWwgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhQ2hhbm5lbCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBzZnUgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZnUgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBwbGF5ZXJJZCAqLyA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBsYXllcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogYm9vbCBkYXRhQ2hhbm5lbCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmRhdGFDaGFubmVsICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UuZGF0YUNoYW5uZWwpO1xuICAgICAgICAvKiBib29sIHNmdSA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNmdSAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLnNmdSk7XG4gICAgICAgIC8qIHN0cmluZyBwbGF5ZXJJZCA9IDU7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBsYXllcklkICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg1LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnBsYXllcklkKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHBsYXllckNvbm5lY3RlZFxuICovXG5leHBvcnQgY29uc3QgcGxheWVyQ29ubmVjdGVkID0gbmV3IHBsYXllckNvbm5lY3RlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBwbGF5ZXJEaXNjb25uZWN0ZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJwbGF5ZXJEaXNjb25uZWN0ZWRcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcInBsYXllcklkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5wbGF5ZXJJZCA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBwbGF5ZXJJZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBsYXllcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyaW5nIHBsYXllcklkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGxheWVySWQgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UucGxheWVySWQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgcGxheWVyRGlzY29ubmVjdGVkXG4gKi9cbmV4cG9ydCBjb25zdCBwbGF5ZXJEaXNjb25uZWN0ZWQgPSBuZXcgcGxheWVyRGlzY29ubmVjdGVkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIG9mZmVyJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwib2ZmZXJcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcInNkcFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogXCJwbGF5ZXJJZFwiLCBraW5kOiBcInNjYWxhclwiLCBvcHQ6IHRydWUsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiA0LCBuYW1lOiBcInNmdVwiLCBraW5kOiBcInNjYWxhclwiLCBvcHQ6IHRydWUsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICAgICAgeyBubzogNSwgbmFtZTogXCJtdWx0aXBsZXhcIiwga2luZDogXCJzY2FsYXJcIiwgb3B0OiB0cnVlLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDYsIG5hbWU6IFwic2NhbGFiaWxpdHlNb2RlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIG9wdDogdHJ1ZSwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLnNkcCA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZHAgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZHAgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogb3B0aW9uYWwgc3RyaW5nIHBsYXllcklkICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGxheWVySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogb3B0aW9uYWwgYm9vbCBzZnUgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZnUgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIG9wdGlvbmFsIGJvb2wgbXVsdGlwbGV4ICovIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubXVsdGlwbGV4ID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBvcHRpb25hbCBzdHJpbmcgc2NhbGFiaWxpdHlNb2RlICovIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2NhbGFiaWxpdHlNb2RlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyaW5nIHNkcCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNkcCAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZHApO1xuICAgICAgICAvKiBvcHRpb25hbCBzdHJpbmcgcGxheWVySWQgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wbGF5ZXJJZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnBsYXllcklkKTtcbiAgICAgICAgLyogb3B0aW9uYWwgYm9vbCBzZnUgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZnUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2Uuc2Z1KTtcbiAgICAgICAgLyogb3B0aW9uYWwgYm9vbCBtdWx0aXBsZXggPSA1OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5tdWx0aXBsZXggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNSwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UubXVsdGlwbGV4KTtcbiAgICAgICAgLyogb3B0aW9uYWwgc3RyaW5nIHNjYWxhYmlsaXR5TW9kZSA9IDY7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNjYWxhYmlsaXR5TW9kZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg2LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNjYWxhYmlsaXR5TW9kZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBvZmZlclxuICovXG5leHBvcnQgY29uc3Qgb2ZmZXIgPSBuZXcgb2ZmZXIkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgYW5zd2VyJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiYW5zd2VyXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJzZHBcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6IFwicGxheWVySWRcIiwga2luZDogXCJzY2FsYXJcIiwgb3B0OiB0cnVlLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogXCJtaW5CaXRyYXRlQnBzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIG9wdDogdHJ1ZSwgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9LFxuICAgICAgICAgICAgeyBubzogNSwgbmFtZTogXCJtYXhCaXRyYXRlQnBzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIG9wdDogdHJ1ZSwgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2Uuc2RwID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNkcCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNkcCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBvcHRpb25hbCBzdHJpbmcgcGxheWVySWQgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wbGF5ZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBvcHRpb25hbCBpbnQzMiBtaW5CaXRyYXRlQnBzICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWluQml0cmF0ZUJwcyA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIG9wdGlvbmFsIGludDMyIG1heEJpdHJhdGVCcHMgKi8gNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tYXhCaXRyYXRlQnBzID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBzdHJpbmcgc2RwID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2RwICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNkcCk7XG4gICAgICAgIC8qIG9wdGlvbmFsIHN0cmluZyBwbGF5ZXJJZCA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBsYXllcklkICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UucGxheWVySWQpO1xuICAgICAgICAvKiBvcHRpb25hbCBpbnQzMiBtaW5CaXRyYXRlQnBzID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubWluQml0cmF0ZUJwcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UubWluQml0cmF0ZUJwcyk7XG4gICAgICAgIC8qIG9wdGlvbmFsIGludDMyIG1heEJpdHJhdGVCcHMgPSA1OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5tYXhCaXRyYXRlQnBzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDUsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5tYXhCaXRyYXRlQnBzKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGFuc3dlclxuICovXG5leHBvcnQgY29uc3QgYW5zd2VyID0gbmV3IGFuc3dlciRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBpY2VDYW5kaWRhdGVEYXRhJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiaWNlQ2FuZGlkYXRlRGF0YVwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcImNhbmRpZGF0ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJzZHBNaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6IFwic2RwTUxpbmVJbmRleFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovIH0sXG4gICAgICAgICAgICB7IG5vOiA0LCBuYW1lOiBcInVzZXJuYW1lRnJhZ21lbnRcIiwga2luZDogXCJzY2FsYXJcIiwgb3B0OiB0cnVlLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UuY2FuZGlkYXRlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zZHBNaWQgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLnNkcE1MaW5lSW5kZXggPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBjYW5kaWRhdGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jYW5kaWRhdGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNkcE1pZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNkcE1pZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiBzZHBNTGluZUluZGV4ICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2RwTUxpbmVJbmRleCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIG9wdGlvbmFsIHN0cmluZyB1c2VybmFtZUZyYWdtZW50ICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudXNlcm5hbWVGcmFnbWVudCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgY2FuZGlkYXRlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2FuZGlkYXRlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmNhbmRpZGF0ZSk7XG4gICAgICAgIC8qIHN0cmluZyBzZHBNaWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZHBNaWQgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2RwTWlkKTtcbiAgICAgICAgLyogaW50MzIgc2RwTUxpbmVJbmRleCA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNkcE1MaW5lSW5kZXggIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5zZHBNTGluZUluZGV4KTtcbiAgICAgICAgLyogb3B0aW9uYWwgc3RyaW5nIHVzZXJuYW1lRnJhZ21lbnQgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS51c2VybmFtZUZyYWdtZW50ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudXNlcm5hbWVGcmFnbWVudCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBpY2VDYW5kaWRhdGVEYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBpY2VDYW5kaWRhdGVEYXRhID0gbmV3IGljZUNhbmRpZGF0ZURhdGEkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgaWNlQ2FuZGlkYXRlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiaWNlQ2FuZGlkYXRlXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJjYW5kaWRhdGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6ICgpID0+IGljZUNhbmRpZGF0ZURhdGEgfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6IFwicGxheWVySWRcIiwga2luZDogXCJzY2FsYXJcIiwgb3B0OiB0cnVlLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGljZUNhbmRpZGF0ZURhdGEgY2FuZGlkYXRlICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2FuZGlkYXRlID0gaWNlQ2FuZGlkYXRlRGF0YS5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBvcHRpb25hbCBzdHJpbmcgcGxheWVySWQgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wbGF5ZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIGljZUNhbmRpZGF0ZURhdGEgY2FuZGlkYXRlID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2FuZGlkYXRlKVxuICAgICAgICAgICAgaWNlQ2FuZGlkYXRlRGF0YS5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuY2FuZGlkYXRlLCB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIG9wdGlvbmFsIHN0cmluZyBwbGF5ZXJJZCA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBsYXllcklkICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UucGxheWVySWQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgaWNlQ2FuZGlkYXRlXG4gKi9cbmV4cG9ydCBjb25zdCBpY2VDYW5kaWRhdGUgPSBuZXcgaWNlQ2FuZGlkYXRlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIGRpc2Nvbm5lY3RQbGF5ZXIkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJkaXNjb25uZWN0UGxheWVyXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJwbGF5ZXJJZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogXCJyZWFzb25cIiwga2luZDogXCJzY2FsYXJcIiwgb3B0OiB0cnVlLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UucGxheWVySWQgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgcGxheWVySWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wbGF5ZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBvcHRpb25hbCBzdHJpbmcgcmVhc29uICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVhc29uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyaW5nIHBsYXllcklkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGxheWVySWQgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UucGxheWVySWQpO1xuICAgICAgICAvKiBvcHRpb25hbCBzdHJpbmcgcmVhc29uID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucmVhc29uICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UucmVhc29uKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGRpc2Nvbm5lY3RQbGF5ZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGRpc2Nvbm5lY3RQbGF5ZXIgPSBuZXcgZGlzY29ubmVjdFBsYXllciRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBwaW5nJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwicGluZ1wiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwidGltZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS50aW1lID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogaW50MzIgdGltZSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRpbWUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIGludDMyIHRpbWUgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50aW1lICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UudGltZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBwaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBwaW5nID0gbmV3IHBpbmckVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgcG9uZyRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInBvbmdcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcInRpbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudGltZSA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDMyIHRpbWUgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50aW1lID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBpbnQzMiB0aW1lID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudGltZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnRpbWUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgcG9uZ1xuICovXG5leHBvcnQgY29uc3QgcG9uZyA9IG5ldyBwb25nJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHN0cmVhbWVyRGlzY29ubmVjdGVkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwic3RyZWFtZXJEaXNjb25uZWN0ZWRcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtZXJEaXNjb25uZWN0ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmVhbWVyRGlzY29ubmVjdGVkID0gbmV3IHN0cmVhbWVyRGlzY29ubmVjdGVkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIGxheWVyUHJlZmVyZW5jZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImxheWVyUHJlZmVyZW5jZVwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwic3BhdGlhbExheWVyXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6IFwidGVtcG9yYWxMYXllclwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovIH0sXG4gICAgICAgICAgICB7IG5vOiA0LCBuYW1lOiBcInBsYXllcklkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zcGF0aWFsTGF5ZXIgPSAwO1xuICAgICAgICBtZXNzYWdlLnRlbXBvcmFsTGF5ZXIgPSAwO1xuICAgICAgICBtZXNzYWdlLnBsYXllcklkID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogaW50MzIgc3BhdGlhbExheWVyICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3BhdGlhbExheWVyID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogaW50MzIgdGVtcG9yYWxMYXllciAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRlbXBvcmFsTGF5ZXIgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgcGxheWVySWQgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wbGF5ZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIGludDMyIHNwYXRpYWxMYXllciA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNwYXRpYWxMYXllciAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnNwYXRpYWxMYXllcik7XG4gICAgICAgIC8qIGludDMyIHRlbXBvcmFsTGF5ZXIgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50ZW1wb3JhbExheWVyICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UudGVtcG9yYWxMYXllcik7XG4gICAgICAgIC8qIHN0cmluZyBwbGF5ZXJJZCA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBsYXllcklkICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnBsYXllcklkKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGxheWVyUHJlZmVyZW5jZVxuICovXG5leHBvcnQgY29uc3QgbGF5ZXJQcmVmZXJlbmNlID0gbmV3IGxheWVyUHJlZmVyZW5jZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBkYXRhQ2hhbm5lbFJlcXVlc3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJkYXRhQ2hhbm5lbFJlcXVlc3RcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgZGF0YUNoYW5uZWxSZXF1ZXN0XG4gKi9cbmV4cG9ydCBjb25zdCBkYXRhQ2hhbm5lbFJlcXVlc3QgPSBuZXcgZGF0YUNoYW5uZWxSZXF1ZXN0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHBlZXJEYXRhQ2hhbm5lbHMkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJwZWVyRGF0YUNoYW5uZWxzXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJwbGF5ZXJJZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogXCJzZW5kU3RyZWFtSWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9LFxuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogXCJyZWN2U3RyZWFtSWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UucGxheWVySWQgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLnNlbmRTdHJlYW1JZCA9IDA7XG4gICAgICAgIG1lc3NhZ2UucmVjdlN0cmVhbUlkID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHBsYXllcklkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGxheWVySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogaW50MzIgc2VuZFN0cmVhbUlkICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VuZFN0cmVhbUlkID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogaW50MzIgcmVjdlN0cmVhbUlkICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVjdlN0cmVhbUlkID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBzdHJpbmcgcGxheWVySWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wbGF5ZXJJZCAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5wbGF5ZXJJZCk7XG4gICAgICAgIC8qIGludDMyIHNlbmRTdHJlYW1JZCA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNlbmRTdHJlYW1JZCAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnNlbmRTdHJlYW1JZCk7XG4gICAgICAgIC8qIGludDMyIHJlY3ZTdHJlYW1JZCA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnJlY3ZTdHJlYW1JZCAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnJlY3ZTdHJlYW1JZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBwZWVyRGF0YUNoYW5uZWxzXG4gKi9cbmV4cG9ydCBjb25zdCBwZWVyRGF0YUNoYW5uZWxzID0gbmV3IHBlZXJEYXRhQ2hhbm5lbHMkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgcGVlckRhdGFDaGFubmVsc1JlYWR5JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwicGVlckRhdGFDaGFubmVsc1JlYWR5XCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHBlZXJEYXRhQ2hhbm5lbHNSZWFkeVxuICovXG5leHBvcnQgY29uc3QgcGVlckRhdGFDaGFubmVsc1JlYWR5ID0gbmV3IHBlZXJEYXRhQ2hhbm5lbHNSZWFkeSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBzdHJlYW1lckRhdGFDaGFubmVscyRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInN0cmVhbWVyRGF0YUNoYW5uZWxzXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJzZnVJZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogXCJzZW5kU3RyZWFtSWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9LFxuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogXCJyZWN2U3RyZWFtSWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2Uuc2Z1SWQgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLnNlbmRTdHJlYW1JZCA9IDA7XG4gICAgICAgIG1lc3NhZ2UucmVjdlN0cmVhbUlkID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNmdUlkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Z1SWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogaW50MzIgc2VuZFN0cmVhbUlkICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VuZFN0cmVhbUlkID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogaW50MzIgcmVjdlN0cmVhbUlkICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVjdlN0cmVhbUlkID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBzdHJpbmcgc2Z1SWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZnVJZCAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZnVJZCk7XG4gICAgICAgIC8qIGludDMyIHNlbmRTdHJlYW1JZCA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNlbmRTdHJlYW1JZCAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnNlbmRTdHJlYW1JZCk7XG4gICAgICAgIC8qIGludDMyIHJlY3ZTdHJlYW1JZCA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnJlY3ZTdHJlYW1JZCAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnJlY3ZTdHJlYW1JZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW1lckRhdGFDaGFubmVsc1xuICovXG5leHBvcnQgY29uc3Qgc3RyZWFtZXJEYXRhQ2hhbm5lbHMgPSBuZXcgc3RyZWFtZXJEYXRhQ2hhbm5lbHMkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3Mgc3RhcnRTdHJlYW1pbmckVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJzdGFydFN0cmVhbWluZ1wiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdGFydFN0cmVhbWluZ1xuICovXG5leHBvcnQgY29uc3Qgc3RhcnRTdHJlYW1pbmcgPSBuZXcgc3RhcnRTdHJlYW1pbmckVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3Mgc3RvcFN0cmVhbWluZyRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInN0b3BTdHJlYW1pbmdcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RvcFN0cmVhbWluZ1xuICovXG5leHBvcnQgY29uc3Qgc3RvcFN0cmVhbWluZyA9IG5ldyBzdG9wU3RyZWFtaW5nJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHBsYXllckNvdW50JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwicGxheWVyQ291bnRcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcImNvdW50XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLmNvdW50ID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogaW50MzIgY291bnQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb3VudCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogaW50MzIgY291bnQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jb3VudCAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLmNvdW50KTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHBsYXllckNvdW50XG4gKi9cbmV4cG9ydCBjb25zdCBwbGF5ZXJDb3VudCA9IG5ldyBwbGF5ZXJDb3VudCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBzdGF0cyRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInN0YXRzXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJkYXRhXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5kYXRhID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIGRhdGEgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyaW5nIGRhdGEgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5kYXRhICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmRhdGEpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RhdHNcbiAqL1xuZXhwb3J0IGNvbnN0IHN0YXRzID0gbmV3IHN0YXRzJFR5cGUoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25hbGxpbmdfbWVzc2FnZXMuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCAqIGFzIE1lc3NhZ2VzIGZyb20gJy4uL01lc3NhZ2VzL3NpZ25hbGxpbmdfbWVzc2FnZXMnO1xuaW1wb3J0ICogYXMgTWVzc2FnZUhlbHBlcnMgZnJvbSAnLi4vTWVzc2FnZXMvbWVzc2FnZV9oZWxwZXJzJztcbi8qKlxuICogVXNlZCB0byByZWd1bGFybHkgcGluZyBhIHByb3RvY29sIGNvbm5lY3Rpb24gdG8gbWFrZSBzdXJlIHRoZSBjb25uZWN0aW9uIGlzIHN0aWxsIGdvb2QgYW5kIG9wZW4uXG4gKiBXaGVuIHRoZSBwb25nIGRvZXNuJ3QgY29tZSBpbiByZXNwb25zZSB0byBhIHBpbmcgaW4gdGltZSBhIGNhbGxiYWNrIGlzIGZpcmVkIHRoYXQgY2FuIGJlIGhhbmRlZFxuICogYnkgdGhlIG93bmVyLlxuICovXG5leHBvcnQgY2xhc3MgS2VlcGFsaXZlTW9uaXRvciB7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgUm91bmQgVHJpcCBUaW1lIG9mIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIGdldCBSVFQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ0dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBtb25pdG9yIGFuZCBzdGFydHMgdGhlIHBpbmcgdGltZXIuIElmIGEgcG9uZyBkb2VzIG5vdCBjb21lIGJhY2sgYnkgdGhlIHRpbWUgd2Ugd2FudFxuICAgICAqIHRvIHNlbmQgYSBzZWNvbmQgcGluZyB0aGVuIHRoZSBjb25uZWN0aW9uIGlzIGNvbnNpZGVyZWQgZGVhZCBhbmQgdGhlIG9uVGltZW91dCBjYWxsYmFjayBpcyBmaXJlZC5cbiAgICAgKiBAcGFyYW0gcHJvdG9jb2wgLSBUaGUgY29ubmVjdGlvbiB0aGF0IHdlIHdhbnQgdG8gbW9uaXRvci5cbiAgICAgKiBAcGFyYW0gdGltZW91dCAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHBpbmcgbWVzc2FnZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdG9jb2wsIHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJ0dCA9IDA7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgdGhpcy5vblJlc3BvbnNlID0gdGhpcy5vbkhlYXJ0YmVhdFJlc3BvbnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wudHJhbnNwb3J0Lm9uKCdjbG9zZScsIHRoaXMuc3RvcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMucHJvdG9jb2wub24oJ3BvbmcnLCB0aGlzLm9uUmVzcG9uc2UpO1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZSA9IHNldEludGVydmFsKHRoaXMuc2VuZEhlYXJ0YmVhdC5iaW5kKHRoaXMpLCB0aGlzLnRpbWVvdXQpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMua2VlcGFsaXZlKTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC5vZmYoJ3BvbmcnLCB0aGlzLm9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBzZW5kSGVhcnRiZWF0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIGlmIHdlIG5ldmVyIGdvdCBhIHJlc3BvbnNlIGZyb20gdGhlIGxhc3QgaGVhcnRiZWF0LCBhc3N1bWUgdGhlIGNvbm5lY3Rpb24gaXMgZGVhZCBhbmQgdGltZW91dFxuICAgICAgICBpZiAodGhpcy5hbGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMub25UaW1lb3V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYXJrIHRoZSBjb25uZWN0aW9uIGFzIHRlbXBvcmFyaWx5IGRlYWQgdW50aWwgd2UgZ2V0IGEgcmVzcG9uc2UgZnJvbSB0aGUgcGluZ1xuICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvdG9jb2wuc2VuZE1lc3NhZ2UoTWVzc2FnZUhlbHBlcnMuY3JlYXRlTWVzc2FnZShNZXNzYWdlcy5waW5nLCB7IHRpbWU6IG5ldyBEYXRlKCkuZ2V0VGltZSgpIH0pKTtcbiAgICB9XG4gICAgb25IZWFydGJlYXRSZXNwb25zZShwb25nTXNnKSB7XG4gICAgICAgIC8vIHdlIGdvdCBhIHBvbmcgcmVzcG9uc2UgZnJvbSB0aGUgb3RoZXIgc2lkZSwgdGhlIGNvbm5lY3Rpb24gaXMgZ29vZC5cbiAgICAgICAgLy8gd2UgYWxzbyBzdG9yZSB0aGUgcm91bmQgdHJpcCB0aW1lIGlmIGFueW9uZSBpcyBjdXJpb3VzXG4gICAgICAgIHRoaXMucnR0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBwb25nTXNnLnRpbWU7XG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUtlZXBhbGl2ZU1vbml0b3IuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4uL0V2ZW50L0V2ZW50RW1pdHRlcic7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi9Mb2dnZXIvTG9nZ2VyJztcbi8qKlxuICogU2lnbmFsbGluZyBwcm90b2NvbCBmb3IgaGFuZGxpbmcgbWVzc2FnZXMgZnJvbSB0aGUgc2lnbmFsbGluZyBzZXJ2ZXIuXG4gKlxuICogTGlzdGVuIG9uIHRoaXMgZW1pdHRlciBmb3IgbWVzc2FnZXMuIE1lc3NhZ2UgdHlwZSBpcyB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvci5cbiAqIEV4YW1wbGU6XG4gKiAgICAgIHNpZ25hbGxpbmdQcm90b2NvbC5vbignY29uZmlnJywgKG1lc3NhZ2U6IE1lc3NhZ2VzLmNvbmZpZykgPVxcPiBjb25zb2xlLmxvZyhgR290IGEgY29uZmlnIG1lc3NhZ2U6ICR7bWVzc2FnZX1gKSkpO1xuICpcbiAqIFRoZSB0cmFuc3BvcnQgaW4gdGhpcyBjbGFzcyB3aWxsIGFsc28gZW1pdCBvbiBtZXNzYWdlIGV2ZW50cy5cbiAqXG4gKiBFdmVudHMgZW1pdHRlZCBvbiB0cmFuc3BvcnQ6XG4gKiAgIG1lc3NhZ2U6XG4gKiAgICAgIEVtaXR0ZWQgYW55IHRpbWUgYSBtZXNzYWdlIGlzIHJlY2VpdmVkIGJ5IHRoZSB0cmFuc3BvcnQuIExpc3RlbiBvbiB0aGlzIGlmXG4gKiAgICAgIHlvdSB3aXNoIHRvIGNhcHR1cmUgYWxsIG1lc3NhZ2VzLCByYXRoZXIgdGhhbiBzcGVjaWZpYyBtZXNzYWdlcyBvblxuICogICAgICAnbWVzc2FnZUhhbmRsZXJzJy5cbiAqXG4gKiAgIG91dDpcbiAqICAgICAgRW1pdHRlZCB3aGVuIHNlbmRpbmcgYSBtZXNzYWdlIG91dCBvbiB0aGUgdHJhbnNwb3J0LiBTaW1pbGFyIHRvICdtZXNzYWdlJyBidXRcbiAqICAgICAgb25seSBmb3Igd2hlbiBtZXNzYWdlcyBhcmUgc2VudCBmcm9tIHRoaXMgZW5kcG9pbnQuIFVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuICovXG5leHBvcnQgY2xhc3MgU2lnbmFsbGluZ1Byb3RvY29sIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBzdGF0aWMgZ2V0IFNJR05BTExJTkdfVkVSU0lPTigpIHtcbiAgICAgICAgcmV0dXJuICcxLjMuMCc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgdHJhbnNwb3J0Lm9uTWVzc2FnZSA9IChtc2cpID0+IHtcbiAgICAgICAgICAgIGxldCBwYXJzZWRNZXNzYWdlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IEpTT04ucGFyc2UobXNnKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuRGVidWcoJ1Byb3RvY29sIHJlY2VpdmVkID0+IFxcbicgKyBKU09OLnN0cmluZ2lmeShwYXJzZWREYXRhLCB1bmRlZmluZWQsIDQpKTtcbiAgICAgICAgICAgICAgICBwYXJzZWRNZXNzYWdlID0gcGFyc2VkRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoYEVycm9yIHBhcnNpbmcgbWVzc2FnZSBzdHJpbmcgJHttc2d9LlxcbiR7ZS5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBVbmtub3duIGVycm9yIHdoaWxlIHBhcnNpbmcgbWVzc2FnZSBkYXRhIGluIGhhbmRsZU9uTWVzc2FnZWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjYWxsIHRoZSBoYW5kbGVyc1xuICAgICAgICAgICAgdHJhbnNwb3J0LmVtaXQoJ21lc3NhZ2UnLCBwYXJzZWRNZXNzYWdlKTsgLy8gZW1pdCB0aGlzIGZvciBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGFueSBtZXNzYWdlXG4gICAgICAgICAgICBpZiAoIXRoaXMuZW1pdChwYXJzZWRNZXNzYWdlLnR5cGUsIHBhcnNlZE1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1pdCB0aGlzIGZvciBsaXN0ZW5lcnMgbGlzdGVuaW5nIGZvciBzcGVjaWZpYyBtZXNzYWdlc1xuICAgICAgICAgICAgICAgIC8vIG5vIGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndW5oYW5kbGVkJywgcGFyc2VkTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFza3MgdGhlIHRyYW5zcG9ydCB0byBjb25uZWN0IHRvIHRoZSBnaXZlbiBVUkwuXG4gICAgICogQHBhcmFtIHVybCAtIFRoZSB1cmwgdG8gY29ubmVjdCB0by5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjb25uZWN0aW9uIGNhbGwgc3VjY2VlZGVkLlxuICAgICAqL1xuICAgIGNvbm5lY3QodXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5jb25uZWN0KHVybCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFza3MgdGhlIHRyYW5zcG9ydCB0byBkaXNjb25uZWN0IGZyb20gYW55IGNvbm5lY3Rpb24gaXQgbWlnaHQgaGF2ZS5cbiAgICAgKiBAcGFyYW0gY29kZSAtIEFuIG9wdGlvbmFsIGRpc2Nvbm5lY3Rpb24gY29kZS5cbiAgICAgKiBAcGFyYW0gcmVhc29uIC0gQW4gb3B0aW9uYWwgZGVzY3JpcHRpdmUgc3RyaW5nIGZvciB0aGUgZGlzY29ubmVjdCByZWFzb24uXG4gICAgICovXG4gICAgZGlzY29ubmVjdChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuZGlzY29ubmVjdChjb2RlLCByZWFzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQgYW5kIHJlYWR5IHRvIHNlbmQvcmVjZWl2ZSBtZXNzYWdlcy5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBwcm90b2NvbCBpcyBjb25uZWN0ZWQuXG4gICAgICovXG4gICAgaXNDb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5pc0Nvbm5lY3RlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXNzZXMgYSBtZXNzYWdlIHRvIHRoZSB0cmFuc3BvcnQgdG8gc2VuZCB0byB0aGUgb3RoZXIgZW5kLlxuICAgICAqIEBwYXJhbSBtc2cgLSBUaGUgbWVzc2FnZSB0byBzZW5kLlxuICAgICAqL1xuICAgIHNlbmRNZXNzYWdlKG1zZykge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kTWVzc2FnZShKU09OLnN0cmluZ2lmeShtc2cpKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuZW1pdCgnb3V0JywgbXNnKTsgLy8gZW1pdCB0aGlzIGZvciBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIG91dGdvaW5nIG1lc3NhZ2VzXG4gICAgICAgIExvZ2dlci5EZWJ1ZygnUHJvdG9jb2wgc2VudCA9PiBcXG4nICsgSlNPTi5zdHJpbmdpZnkobXNnLCB1bmRlZmluZWQsIDQpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaWduYWxsaW5nUHJvdG9jb2wuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL0xvZ2dlci9Mb2dnZXInO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vRXZlbnQvRXZlbnRFbWl0dGVyJztcbi8qKlxuICogVGhlIGNvbnRyb2xsZXIgZm9yIHRoZSBXZWJTb2NrZXQgYW5kIGFsbCBhc3NvY2lhdGVkIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGNsYXNzIFdlYlNvY2tldFRyYW5zcG9ydCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBXZWJTb2NrZXRUcmFuc3BvcnQgZm9yIGJyb3dzZXIgY29udGV4dHMuXG4gICAgICogQHBhcmFtIHByb3RvY29scyAtIEFuIG9wdGlvbmFsIHN0cmluZyBvciBsaXN0IG9mIHN0cmluZ3MgdG8gcGFzcyB0byB0aGUgbmV3IHdlYnNvY2tldCBwcm90b2NvbHMgcGFyYW1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm90b2NvbHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5XU19PUEVOX1NUQVRFID0gMTtcbiAgICAgICAgdGhpcy5wcm90b2NvbHMgPSBwcm90b2NvbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSBvdmVyIHRoZSB3ZWJzb2NrZXQuXG4gICAgICogQHBhcmFtIG1zZyAtIFRoZSBtZXNzYWdlIHRvIHNlbmQuXG4gICAgICovXG4gICAgc2VuZE1lc3NhZ2UobXNnKSB7XG4gICAgICAgIGlmICh0aGlzLndlYlNvY2tldCkge1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQuc2VuZChtc2cpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdG8gdGhlIHNpZ25hbGluZyBzZXJ2ZXJcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvblVSTCAtIFRoZSBBZGRyZXNzIG9mIHRoZSBzaWduYWxpbmcgc2VydmVyXG4gICAgICogQHJldHVybnMgSWYgdGhlcmUgaXMgYSBjb25uZWN0aW9uXG4gICAgICovXG4gICAgY29ubmVjdChjb25uZWN0aW9uVVJMKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKGNvbm5lY3Rpb25VUkwpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQgPSBuZXcgV2ViU29ja2V0KGNvbm5lY3Rpb25VUkwsIHRoaXMucHJvdG9jb2xzKTtcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0Lm9ub3BlbiA9IChfKSA9PiB0aGlzLmhhbmRsZU9uT3BlbigpO1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQub25lcnJvciA9IChfKSA9PiB0aGlzLmhhbmRsZU9uRXJyb3IoKTtcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0Lm9uY2xvc2UgPSAoZXZlbnQpID0+IHRoaXMuaGFuZGxlT25DbG9zZShldmVudCk7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldC5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHRoaXMuaGFuZGxlT25NZXNzYWdlKGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0Lm9ubWVzc2FnZWJpbmFyeSA9IChldmVudCkgPT4gdGhpcy5oYW5kbGVPbk1lc3NhZ2VCaW5hcnkoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgdGhpcyB0cmFuc3BvcnQuXG4gICAgICogQHBhcmFtIGNvZGUgLSBBbiBvcHRpb25hbCBkaXNjb25uZWN0IGNvZGUuXG4gICAgICogQHBhcmFtIHJlYXNvbiAtIEEgZGVzY3JpcHRpdmUgc3RyaW5nIGZvciB0aGUgZGlzY29ubmVjdCByZWFzb24uXG4gICAgICovXG4gICAgZGlzY29ubmVjdChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgaWYgKHRoaXMud2ViU29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldC5jbG9zZShjb2RlLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgY29ubmVjdGVkIGFuZCByZWFkeSB0byBzZW5kL3JlY2VpdmUgbWVzc2FnZXMuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy53ZWJTb2NrZXQgJiYgdGhpcy53ZWJTb2NrZXQucmVhZHlTdGF0ZSAhPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoYXQgaGFwcGVucyB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZCBpbiBiaW5hcnkgZm9ybVxuICAgICAqIEBwYXJhbSBldmVudCAtIE1lc3NhZ2UgUmVjZWl2ZWRcbiAgICAgKi9cbiAgICBoYW5kbGVPbk1lc3NhZ2VCaW5hcnkoZXZlbnQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGV2ZW50IGlzIGVtcHR5IHJldHVyblxuICAgICAgICBpZiAoIWV2ZW50IHx8ICFldmVudC5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIHRoZSBiaW5hcnkgYW5kIHRoZW4gaGFuZGxlIHRoZSBtZXNzYWdlXG4gICAgICAgIGV2ZW50LmRhdGFcbiAgICAgICAgICAgIC50ZXh0KClcbiAgICAgICAgICAgIC50aGVuKChtZXNzYWdlU3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAvLyBidWlsZCBhIG5ldyBtZXNzYWdlXG4gICAgICAgICAgICBjb25zdCBjb25zdHJ1Y3RlZE1lc3NhZ2UgPSBuZXcgTWVzc2FnZUV2ZW50KCdtZXNzYWdlRnJvbUJpbmFyeScsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBtZXNzYWdlU3RyaW5nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHNlbmQgdGhlIG5ldyBzdHJpbmdpZmllZCBldmVudCBiYWNrIGludG8gYG9ubWVzc2FnZWBcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlT25NZXNzYWdlKGNvbnN0cnVjdGVkTWVzc2FnZSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBiaW5hcnkgYmxvYiBmcm9tIHdlYnNvY2tldCwgcmVhc29uOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoYXQgaGFwcGVucyB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZFxuICAgICAqIEBwYXJhbSBldmVudCAtIE1lc3NhZ2UgUmVjZWl2ZWRcbiAgICAgKi9cbiAgICBoYW5kbGVPbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2Vic29ja2V0IG1lc3NhZ2UgaXMgYmluYXJ5LCBpZiBzbywgc3RyaW5naWZ5IGl0LlxuICAgICAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVPbk1lc3NhZ2VCaW5hcnkoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9uTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2UoZXZlbnQuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIHRoZSBXZWJzb2NrZXQgaXMgb3BlbmVkXG4gICAgICovXG4gICAgaGFuZGxlT25PcGVuKCkge1xuICAgICAgICBMb2dnZXIuSW5mbygnQ29ubmVjdGVkIHRvIHRoZSBzaWduYWxsaW5nIHNlcnZlciB2aWEgV2ViU29ja2V0Jyk7XG4gICAgICAgIHRoaXMuZW1pdCgnb3BlbicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3Igb24gdGhlIHdlYnNvY2tldFxuICAgICAqL1xuICAgIGhhbmRsZU9uRXJyb3IoKSB7XG4gICAgICAgIC8vTG9nZ2VyLkVycm9yKExvZ2dlci5HZXRTdGFja1RyYWNlKCksICdXZWJTb2NrZXQgZXJyb3InKTtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gdGhlIFdlYnNvY2tldCBpcyBjbG9zZWRcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBDbG9zZSBFdmVudFxuICAgICAqL1xuICAgIGhhbmRsZU9uQ2xvc2UoZXZlbnQpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ0Rpc2Nvbm5lY3RlZCB0byB0aGUgc2lnbmFsbGluZyBzZXJ2ZXIgdmlhIFdlYlNvY2tldDogJyArXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShldmVudC5jb2RlKSArXG4gICAgICAgICAgICAnIC0gJyArXG4gICAgICAgICAgICBldmVudC5yZWFzb24pO1xuICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgZXZlbnQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdlYlNvY2tldFRyYW5zcG9ydC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuZXhwb3J0IGNsYXNzIFNEUFV0aWxzIHtcbiAgICBzdGF0aWMgYWRkVmlkZW9IZWFkZXJFeHRlbnNpb25Ub1NkcChzZHAsIHVyaSkge1xuICAgICAgICAvLyBGaW5kIHRoZSBoaWdoZXN0IHVzZWQgaGVhZGVyIGV4dGVuc2lvbiBpZCBieSBzb3J0aW5nIHRoZSBleHRlbnNpb24gaWRzIHVzZWQsXG4gICAgICAgIC8vIGVsaW1pbmF0aW5nIGR1cGxpY2F0ZXMgYW5kIGFkZGluZyBvbmUuXG4gICAgICAgIC8vIFRvZG86IFVwZGF0ZSB0aGlzIHdoZW4gV2ViUlRDIGluIENocm9tZSBzdXBwb3J0cyB0aGUgaGVhZGVyIGV4dGVuc2lvbiBBUEkuXG4gICAgICAgIGNvbnN0IHVzZWRJZHMgPSBzZHBcbiAgICAgICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgICAgIC5maWx0ZXIoKGxpbmUpID0+IGxpbmUuc3RhcnRzV2l0aCgnYT1leHRtYXA6JykpXG4gICAgICAgICAgICAubWFwKChsaW5lKSA9PiBwYXJzZUludChsaW5lLnNwbGl0KCcgJylbMF0uc3Vic3RyaW5nKDkpLCAxMCkpXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgICAgICAgICAuZmlsdGVyKChpdGVtLCBpbmRleCwgYXJyYXkpID0+IGFycmF5LmluZGV4T2YoaXRlbSkgPT09IGluZGV4KTtcbiAgICAgICAgY29uc3QgbmV4dElkID0gdXNlZElkc1t1c2VkSWRzLmxlbmd0aCAtIDFdICsgMTtcbiAgICAgICAgY29uc3QgZXh0bWFwTGluZSA9ICdhPWV4dG1hcDonICsgbmV4dElkICsgJyAnICsgdXJpICsgJ1xcclxcbic7XG4gICAgICAgIGNvbnN0IHNlY3Rpb25zID0gc2RwLnNwbGl0KCdcXG5tPScpLm1hcCgocGFydCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoaW5kZXggPiAwID8gJ209JyArIHBhcnQgOiBwYXJ0KS50cmltKCkgKyAnXFxyXFxuJztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNlc3Npb25QYXJ0ID0gc2VjdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgLy8gT25seSBhZGQgZXh0ZW5zaW9uIHRvIG09dmlkZW8gbWVkaWEgc2VjdGlvblxuICAgICAgICByZXR1cm4gKHNlc3Npb25QYXJ0ICtcbiAgICAgICAgICAgIHNlY3Rpb25zXG4gICAgICAgICAgICAgICAgLm1hcCgobWVkaWFTZWN0aW9uKSA9PiBtZWRpYVNlY3Rpb24uc3RhcnRzV2l0aCgnbT12aWRlbycpID8gbWVkaWFTZWN0aW9uICsgZXh0bWFwTGluZSA6IG1lZGlhU2VjdGlvbilcbiAgICAgICAgICAgICAgICAuam9pbignJykpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNkcFV0aWxzLmpzLm1hcCIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoZSkge1xuICBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIHJldHVybiBlO1xufVxuZXhwb3J0IHsgX2Fzc2VydFRoaXNJbml0aWFsaXplZCBhcyBkZWZhdWx0IH07IiwiaW1wb3J0IHRvUHJvcGVydHlLZXkgZnJvbSBcIi4vdG9Qcm9wZXJ0eUtleS5qc1wiO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikge1xuICBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbyA9IHJbdF07XG4gICAgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHRvUHJvcGVydHlLZXkoby5rZXkpLCBvKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHtcbiAgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiAhMVxuICB9KSwgZTtcbn1cbmV4cG9ydCB7IF9jcmVhdGVDbGFzcyBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIHJldHVybiBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciB0ID0gYXJndW1lbnRzW2VdO1xuICAgICAgZm9yICh2YXIgciBpbiB0KSAoe30pLmhhc093blByb3BlcnR5LmNhbGwodCwgcikgJiYgKG5bcl0gPSB0W3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH0sIF9leHRlbmRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5leHBvcnQgeyBfZXh0ZW5kcyBhcyBkZWZhdWx0IH07IiwiaW1wb3J0IHNldFByb3RvdHlwZU9mIGZyb20gXCIuL3NldFByb3RvdHlwZU9mLmpzXCI7XG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZSh0LCBvKSB7XG4gIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShvLnByb3RvdHlwZSksIHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gdCwgc2V0UHJvdG90eXBlT2YodCwgbyk7XG59XG5leHBvcnQgeyBfaW5oZXJpdHNMb29zZSBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkge1xuICBpZiAobnVsbCA9PSByKSByZXR1cm4ge307XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHtcbiAgICBpZiAoLTEgIT09IGUuaW5kZXhPZihuKSkgY29udGludWU7XG4gICAgdFtuXSA9IHJbbl07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5leHBvcnQgeyBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKHQsIGUpIHtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCwgZSkge1xuICAgIHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7XG4gIH0sIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cbmV4cG9ydCB7IF9zZXRQcm90b3R5cGVPZiBhcyBkZWZhdWx0IH07IiwiaW1wb3J0IF90eXBlb2YgZnJvbSBcIi4vdHlwZW9mLmpzXCI7XG5mdW5jdGlvbiB0b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuZXhwb3J0IHsgdG9QcmltaXRpdmUgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfdHlwZW9mIGZyb20gXCIuL3R5cGVvZi5qc1wiO1xuaW1wb3J0IHRvUHJpbWl0aXZlIGZyb20gXCIuL3RvUHJpbWl0aXZlLmpzXCI7XG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSB0b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjtcbn1cbmV4cG9ydCB7IHRvUHJvcGVydHlLZXkgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5leHBvcnQgeyBfdHlwZW9mIGFzIGRlZmF1bHQgfTsiLCIvKipcbiAqIGFzc2VydCB0aGF0IGNvbmRpdGlvbiBpcyB0cnVlIG9yIHRocm93IGVycm9yICh3aXRoIG1lc3NhZ2UpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtc2cpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG4vKipcbiAqIGFzc2VydCB0aGF0IHZhbHVlIGNhbm5vdCBleGlzdCA9IHR5cGUgYG5ldmVyYC4gdGhyb3cgcnVudGltZSBlcnJvciBpZiBpdCBkb2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIodmFsdWUsIG1zZykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cgIT09IG51bGwgJiYgbXNnICE9PSB2b2lkIDAgPyBtc2cgOiAnVW5leHBlY3RlZCBvYmplY3Q6ICcgKyB2YWx1ZSk7XG59XG5jb25zdCBGTE9BVDMyX01BWCA9IDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIEZMT0FUMzJfTUlOID0gLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIFVJTlQzMl9NQVggPSAweEZGRkZGRkZGLCBJTlQzMl9NQVggPSAwWDdGRkZGRkZGLCBJTlQzMl9NSU4gPSAtMFg4MDAwMDAwMDtcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRJbnQzMihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGludCAzMjogJyArIHR5cGVvZiBhcmcpO1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihhcmcpIHx8IGFyZyA+IElOVDMyX01BWCB8fCBhcmcgPCBJTlQzMl9NSU4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnQgMzI6ICcgKyBhcmcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFVJbnQzMihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHVpbnQgMzI6ICcgKyB0eXBlb2YgYXJnKTtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJnKSB8fCBhcmcgPiBVSU5UMzJfTUFYIHx8IGFyZyA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB1aW50IDMyOiAnICsgYXJnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRGbG9hdDMyKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmxvYXQgMzI6ICcgKyB0eXBlb2YgYXJnKTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShhcmcpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGFyZyA+IEZMT0FUMzJfTUFYIHx8IGFyZyA8IEZMT0FUMzJfTUlOKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmxvYXQgMzI6ICcgKyBhcmcpO1xufVxuIiwiLy8gbG9va3VwIHRhYmxlIGZyb20gYmFzZTY0IGNoYXJhY3RlciB0byBieXRlXG5sZXQgZW5jVGFibGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpO1xuLy8gbG9va3VwIHRhYmxlIGZyb20gYmFzZTY0IGNoYXJhY3RlciAqY29kZSogdG8gYnl0ZSBiZWNhdXNlIGxvb2t1cCBieSBudW1iZXIgaXMgZmFzdFxubGV0IGRlY1RhYmxlID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IGVuY1RhYmxlLmxlbmd0aDsgaSsrKVxuICAgIGRlY1RhYmxlW2VuY1RhYmxlW2ldLmNoYXJDb2RlQXQoMCldID0gaTtcbi8vIHN1cHBvcnQgYmFzZTY0dXJsIHZhcmlhbnRzXG5kZWNUYWJsZVtcIi1cIi5jaGFyQ29kZUF0KDApXSA9IGVuY1RhYmxlLmluZGV4T2YoXCIrXCIpO1xuZGVjVGFibGVbXCJfXCIuY2hhckNvZGVBdCgwKV0gPSBlbmNUYWJsZS5pbmRleE9mKFwiL1wiKTtcbi8qKlxuICogRGVjb2RlcyBhIGJhc2U2NCBzdHJpbmcgdG8gYSBieXRlIGFycmF5LlxuICpcbiAqIC0gaWdub3JlcyB3aGl0ZS1zcGFjZSwgaW5jbHVkaW5nIGxpbmUgYnJlYWtzIGFuZCB0YWJzXG4gKiAtIGFsbG93cyBpbm5lciBwYWRkaW5nIChjYW4gZGVjb2RlIGNvbmNhdGVuYXRlZCBiYXNlNjQgc3RyaW5ncylcbiAqIC0gZG9lcyBub3QgcmVxdWlyZSBwYWRkaW5nXG4gKiAtIHVuZGVyc3RhbmRzIGJhc2U2NHVybCBlbmNvZGluZzpcbiAqICAgXCItXCIgaW5zdGVhZCBvZiBcIitcIixcbiAqICAgXCJfXCIgaW5zdGVhZCBvZiBcIi9cIixcbiAqICAgbm8gcGFkZGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0ZGVjb2RlKGJhc2U2NFN0cikge1xuICAgIC8vIGVzdGltYXRlIGJ5dGUgc2l6ZSwgbm90IGFjY291bnRpbmcgZm9yIGlubmVyIHBhZGRpbmcgYW5kIHdoaXRlc3BhY2VcbiAgICBsZXQgZXMgPSBiYXNlNjRTdHIubGVuZ3RoICogMyAvIDQ7XG4gICAgLy8gaWYgKGVzICUgMyAhPT0gMClcbiAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYmFzZTY0IHN0cmluZycpO1xuICAgIGlmIChiYXNlNjRTdHJbYmFzZTY0U3RyLmxlbmd0aCAtIDJdID09ICc9JylcbiAgICAgICAgZXMgLT0gMjtcbiAgICBlbHNlIGlmIChiYXNlNjRTdHJbYmFzZTY0U3RyLmxlbmd0aCAtIDFdID09ICc9JylcbiAgICAgICAgZXMgLT0gMTtcbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShlcyksIGJ5dGVQb3MgPSAwLCAvLyBwb3NpdGlvbiBpbiBieXRlIGFycmF5XG4gICAgZ3JvdXBQb3MgPSAwLCAvLyBwb3NpdGlvbiBpbiBiYXNlNjQgZ3JvdXBcbiAgICBiLCAvLyBjdXJyZW50IGJ5dGVcbiAgICBwID0gMCAvLyBwcmV2aW91cyBieXRlXG4gICAgO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZTY0U3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGIgPSBkZWNUYWJsZVtiYXNlNjRTdHIuY2hhckNvZGVBdChpKV07XG4gICAgICAgIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBGYWxsVGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICAgICAgICAgIHN3aXRjaCAoYmFzZTY0U3RyW2ldKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMDsgLy8gcmVzZXQgc3RhdGUgd2hlbiBwYWRkaW5nIGZvdW5kXG4gICAgICAgICAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgICAgICAgICBjYXNlICdcXHInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBza2lwIHdoaXRlLXNwYWNlLCBhbmQgcGFkZGluZ1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBpbnZhbGlkIGJhc2U2NCBzdHJpbmcuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChncm91cFBvcykge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHAgPSBiO1xuICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gcCA8PCAyIHwgKGIgJiA0OCkgPj4gNDtcbiAgICAgICAgICAgICAgICBwID0gYjtcbiAgICAgICAgICAgICAgICBncm91cFBvcyA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgYnl0ZXNbYnl0ZVBvcysrXSA9IChwICYgMTUpIDw8IDQgfCAoYiAmIDYwKSA+PiAyO1xuICAgICAgICAgICAgICAgIHAgPSBiO1xuICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gKHAgJiAzKSA8PCA2IHwgYjtcbiAgICAgICAgICAgICAgICBncm91cFBvcyA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdyb3VwUG9zID09IDEpXG4gICAgICAgIHRocm93IEVycm9yKGBpbnZhbGlkIGJhc2U2NCBzdHJpbmcuYCk7XG4gICAgcmV0dXJuIGJ5dGVzLnN1YmFycmF5KDAsIGJ5dGVQb3MpO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgYnl0ZSBhcnJheSB0byBhIGJhc2U2NCBzdHJpbmcuXG4gKiBBZGRzIHBhZGRpbmcgYXQgdGhlIGVuZC5cbiAqIERvZXMgbm90IGluc2VydCBuZXdsaW5lcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NGVuY29kZShieXRlcykge1xuICAgIGxldCBiYXNlNjQgPSAnJywgZ3JvdXBQb3MgPSAwLCAvLyBwb3NpdGlvbiBpbiBiYXNlNjQgZ3JvdXBcbiAgICBiLCAvLyBjdXJyZW50IGJ5dGVcbiAgICBwID0gMDsgLy8gY2Fycnkgb3ZlciBmcm9tIHByZXZpb3VzIGJ5dGVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGIgPSBieXRlc1tpXTtcbiAgICAgICAgc3dpdGNoIChncm91cFBvcykge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtiID4+IDJdO1xuICAgICAgICAgICAgICAgIHAgPSAoYiAmIDMpIDw8IDQ7XG4gICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtwIHwgYiA+PiA0XTtcbiAgICAgICAgICAgICAgICBwID0gKGIgJiAxNSkgPDwgMjtcbiAgICAgICAgICAgICAgICBncm91cFBvcyA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW3AgfCBiID4+IDZdO1xuICAgICAgICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtiICYgNjNdO1xuICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBwYWRkaW5nIHJlcXVpcmVkP1xuICAgIGlmIChncm91cFBvcykge1xuICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcF07XG4gICAgICAgIGJhc2U2NCArPSAnPSc7XG4gICAgICAgIGlmIChncm91cFBvcyA9PSAxKVxuICAgICAgICAgICAgYmFzZTY0ICs9ICc9JztcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U2NDtcbn1cbiIsIi8qKlxuICogVGhpcyBoYW5kbGVyIGltcGxlbWVudHMgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIGZvciB1bmtub3duIGZpZWxkcy5cbiAqIFdoZW4gcmVhZGluZyBkYXRhLCB1bmtub3duIGZpZWxkcyBhcmUgc3RvcmVkIG9uIHRoZSBtZXNzYWdlLCBpbiBhXG4gKiBzeW1ib2wgcHJvcGVydHkuXG4gKiBXaGVuIHdyaXRpbmcgZGF0YSwgdGhlIHN5bWJvbCBwcm9wZXJ0eSBpcyBxdWVyaWVkIGFuZCB1bmtub3duIGZpZWxkc1xuICogYXJlIHNlcmlhbGl6ZWQgaW50byB0aGUgb3V0cHV0IGFnYWluLlxuICovXG5leHBvcnQgdmFyIFVua25vd25GaWVsZEhhbmRsZXI7XG4oZnVuY3Rpb24gKFVua25vd25GaWVsZEhhbmRsZXIpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc3ltYm9sIHVzZWQgdG8gc3RvcmUgdW5rbm93biBmaWVsZHMgZm9yIGEgbWVzc2FnZS5cbiAgICAgKiBUaGUgcHJvcGVydHkgbXVzdCBjb25mb3JtIHRvIGBVbmtub3duRmllbGRDb250YWluZXJgLlxuICAgICAqL1xuICAgIFVua25vd25GaWVsZEhhbmRsZXIuc3ltYm9sID0gU3ltYm9sLmZvcihcInByb3RvYnVmLXRzL3Vua25vd25cIik7XG4gICAgLyoqXG4gICAgICogU3RvcmUgYW4gdW5rbm93biBmaWVsZCBkdXJpbmcgYmluYXJ5IHJlYWQgZGlyZWN0bHkgb24gdGhlIG1lc3NhZ2UuXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29tcGF0aWJsZSB3aXRoIGBCaW5hcnlSZWFkT3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkYC5cbiAgICAgKi9cbiAgICBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA9ICh0eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGRhdGEpID0+IHtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IGlzKG1lc3NhZ2UpID8gbWVzc2FnZVtVbmtub3duRmllbGRIYW5kbGVyLnN5bWJvbF0gOiBtZXNzYWdlW1Vua25vd25GaWVsZEhhbmRsZXIuc3ltYm9sXSA9IFtdO1xuICAgICAgICBjb250YWluZXIucHVzaCh7IG5vOiBmaWVsZE5vLCB3aXJlVHlwZSwgZGF0YSB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdyaXRlIHVua25vd24gZmllbGRzIHN0b3JlZCBmb3IgdGhlIG1lc3NhZ2UgdG8gdGhlIHdyaXRlci5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb21wYXRpYmxlIHdpdGggYEJpbmFyeVdyaXRlT3B0aW9ucy53cml0ZVVua25vd25GaWVsZHNgLlxuICAgICAqL1xuICAgIFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA9ICh0eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKSA9PiB7XG4gICAgICAgIGZvciAobGV0IHsgbm8sIHdpcmVUeXBlLCBkYXRhIH0gb2YgVW5rbm93bkZpZWxkSGFuZGxlci5saXN0KG1lc3NhZ2UpKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyhubywgd2lyZVR5cGUpLnJhdyhkYXRhKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExpc3QgdW5rbm93biBmaWVsZHMgc3RvcmVkIGZvciB0aGUgbWVzc2FnZS5cbiAgICAgKiBOb3RlIHRoYXQgdGhlcmUgbWF5IGJlIG11bHRpcGxlcyBmaWVsZHMgd2l0aCB0aGUgc2FtZSBudW1iZXIuXG4gICAgICovXG4gICAgVW5rbm93bkZpZWxkSGFuZGxlci5saXN0ID0gKG1lc3NhZ2UsIGZpZWxkTm8pID0+IHtcbiAgICAgICAgaWYgKGlzKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBsZXQgYWxsID0gbWVzc2FnZVtVbmtub3duRmllbGRIYW5kbGVyLnN5bWJvbF07XG4gICAgICAgICAgICByZXR1cm4gZmllbGRObyA/IGFsbC5maWx0ZXIodWYgPT4gdWYubm8gPT0gZmllbGRObykgOiBhbGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGFzdCB1bmtub3duIGZpZWxkIGJ5IGZpZWxkIG51bWJlci5cbiAgICAgKi9cbiAgICBVbmtub3duRmllbGRIYW5kbGVyLmxhc3QgPSAobWVzc2FnZSwgZmllbGRObykgPT4gVW5rbm93bkZpZWxkSGFuZGxlci5saXN0KG1lc3NhZ2UsIGZpZWxkTm8pLnNsaWNlKC0xKVswXTtcbiAgICBjb25zdCBpcyA9IChtZXNzYWdlKSA9PiBtZXNzYWdlICYmIEFycmF5LmlzQXJyYXkobWVzc2FnZVtVbmtub3duRmllbGRIYW5kbGVyLnN5bWJvbF0pO1xufSkoVW5rbm93bkZpZWxkSGFuZGxlciB8fCAoVW5rbm93bkZpZWxkSGFuZGxlciA9IHt9KSk7XG4vKipcbiAqIE1lcmdlcyBiaW5hcnkgd3JpdGUgb3IgcmVhZCBvcHRpb25zLiBMYXRlciB2YWx1ZXMgb3ZlcnJpZGUgZWFybGllciB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUJpbmFyeU9wdGlvbnMoYSwgYikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGEpLCBiKTtcbn1cbi8qKlxuICogUHJvdG9idWYgYmluYXJ5IGZvcm1hdCB3aXJlIHR5cGVzLlxuICpcbiAqIEEgd2lyZSB0eXBlIHByb3ZpZGVzIGp1c3QgZW5vdWdoIGluZm9ybWF0aW9uIHRvIGZpbmQgdGhlIGxlbmd0aCBvZiB0aGVcbiAqIGZvbGxvd2luZyB2YWx1ZS5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL2VuY29kaW5nI3N0cnVjdHVyZVxuICovXG5leHBvcnQgdmFyIFdpcmVUeXBlO1xuKGZ1bmN0aW9uIChXaXJlVHlwZSkge1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGludDMyLCBpbnQ2NCwgdWludDMyLCB1aW50NjQsIHNpbnQzMiwgc2ludDY0LCBib29sLCBlbnVtXG4gICAgICovXG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJWYXJpbnRcIl0gPSAwXSA9IFwiVmFyaW50XCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgZml4ZWQ2NCwgc2ZpeGVkNjQsIGRvdWJsZS5cbiAgICAgKiBBbHdheXMgOCBieXRlcyB3aXRoIGxpdHRsZS1lbmRpYW4gYnl0ZSBvcmRlci5cbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIkJpdDY0XCJdID0gMV0gPSBcIkJpdDY0XCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3Igc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHNcbiAgICAgKlxuICAgICAqIE9ubHkgcmVwZWF0ZWQgbnVtZXJpYyB0eXBlcyAodHlwZXMgd2hpY2ggdXNlIHRoZSB2YXJpbnQsIDMyLWJpdCxcbiAgICAgKiBvciA2NC1iaXQgd2lyZSB0eXBlcykgY2FuIGJlIHBhY2tlZC4gSW4gcHJvdG8zLCBzdWNoIGZpZWxkcyBhcmVcbiAgICAgKiBwYWNrZWQgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIkxlbmd0aERlbGltaXRlZFwiXSA9IDJdID0gXCJMZW5ndGhEZWxpbWl0ZWRcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBncm91cHNcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiU3RhcnRHcm91cFwiXSA9IDNdID0gXCJTdGFydEdyb3VwXCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgZ3JvdXBzXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIkVuZEdyb3VwXCJdID0gNF0gPSBcIkVuZEdyb3VwXCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgZml4ZWQzMiwgc2ZpeGVkMzIsIGZsb2F0LlxuICAgICAqIEFsd2F5cyA0IGJ5dGVzIHdpdGggbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICAgICAqL1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiQml0MzJcIl0gPSA1XSA9IFwiQml0MzJcIjtcbn0pKFdpcmVUeXBlIHx8IChXaXJlVHlwZSA9IHt9KSk7XG4iLCJpbXBvcnQgeyBXaXJlVHlwZSB9IGZyb20gXCIuL2JpbmFyeS1mb3JtYXQtY29udHJhY3RcIjtcbmltcG9ydCB7IFBiTG9uZywgUGJVTG9uZyB9IGZyb20gXCIuL3BiLWxvbmdcIjtcbmltcG9ydCB7IHZhcmludDMycmVhZCwgdmFyaW50NjRyZWFkIH0gZnJvbSBcIi4vZ29vZy12YXJpbnRcIjtcbmNvbnN0IGRlZmF1bHRzUmVhZCA9IHtcbiAgICByZWFkVW5rbm93bkZpZWxkOiB0cnVlLFxuICAgIHJlYWRlckZhY3Rvcnk6IGJ5dGVzID0+IG5ldyBCaW5hcnlSZWFkZXIoYnl0ZXMpLFxufTtcbi8qKlxuICogTWFrZSBvcHRpb25zIGZvciByZWFkaW5nIGJpbmFyeSBkYXRhIGZvcm0gcGFydGlhbCBvcHRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5UmVhZE9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0c1JlYWQpLCBvcHRpb25zKSA6IGRlZmF1bHRzUmVhZDtcbn1cbmV4cG9ydCBjbGFzcyBCaW5hcnlSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKGJ1ZiwgdGV4dERlY29kZXIpIHtcbiAgICAgICAgdGhpcy52YXJpbnQ2NCA9IHZhcmludDY0cmVhZDsgLy8gZGlydHkgY2FzdCBmb3IgYHRoaXNgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIGEgYHVpbnQzMmAgZmllbGQsIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVpbnQzMiA9IHZhcmludDMycmVhZDsgLy8gZGlydHkgY2FzdCBmb3IgYHRoaXNgIGFuZCBhY2Nlc3MgdG8gcHJvdGVjdGVkIGBidWZgXG4gICAgICAgIHRoaXMuYnVmID0gYnVmO1xuICAgICAgICB0aGlzLmxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMudGV4dERlY29kZXIgPSB0ZXh0RGVjb2RlciAhPT0gbnVsbCAmJiB0ZXh0RGVjb2RlciAhPT0gdm9pZCAwID8gdGV4dERlY29kZXIgOiBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiLCB7XG4gICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgIGlnbm9yZUJPTTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgdGFnIC0gZmllbGQgbnVtYmVyIGFuZCB3aXJlIHR5cGUuXG4gICAgICovXG4gICAgdGFnKCkge1xuICAgICAgICBsZXQgdGFnID0gdGhpcy51aW50MzIoKSwgZmllbGRObyA9IHRhZyA+Pj4gMywgd2lyZVR5cGUgPSB0YWcgJiA3O1xuICAgICAgICBpZiAoZmllbGRObyA8PSAwIHx8IHdpcmVUeXBlIDwgMCB8fCB3aXJlVHlwZSA+IDUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHRhZzogZmllbGQgbm8gXCIgKyBmaWVsZE5vICsgXCIgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUpO1xuICAgICAgICByZXR1cm4gW2ZpZWxkTm8sIHdpcmVUeXBlXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2tpcCBvbmUgZWxlbWVudCBvbiB0aGUgd2lyZSBhbmQgcmV0dXJuIHRoZSBza2lwcGVkIGRhdGEuXG4gICAgICogU3VwcG9ydHMgV2lyZVR5cGUuU3RhcnRHcm91cCBzaW5jZSB2Mi4wLjAtYWxwaGEuMjMuXG4gICAgICovXG4gICAgc2tpcCh3aXJlVHlwZSkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgLy8gbm9pbnNwZWN0aW9uIEZhbGxUaHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgICAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLlZhcmludDpcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV2lyZVR5cGUuQml0NjQ6XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgICAgIGNhc2UgV2lyZVR5cGUuQml0MzI6XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkOlxuICAgICAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV2lyZVR5cGUuU3RhcnRHcm91cDpcbiAgICAgICAgICAgICAgICAvLyBGcm9tIGRlc2NyaXB0b3IucHJvdG86IEdyb3VwIHR5cGUgaXMgZGVwcmVjYXRlZCwgbm90IHN1cHBvcnRlZCBpbiBwcm90bzMuXG4gICAgICAgICAgICAgICAgLy8gQnV0IHdlIG11c3Qgc3RpbGwgYmUgYWJsZSB0byBwYXJzZSBhbmQgdHJlYXQgYXMgdW5rbm93bi5cbiAgICAgICAgICAgICAgICBsZXQgdDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHQgPSB0aGlzLnRhZygpWzFdKSAhPT0gV2lyZVR5cGUuRW5kR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwKHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FudCBza2lwIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWYuc3ViYXJyYXkoc3RhcnQsIHRoaXMucG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhyb3dzIGVycm9yIGlmIHBvc2l0aW9uIGluIGJ5dGUgYXJyYXkgaXMgb3V0IG9mIHJhbmdlLlxuICAgICAqL1xuICAgIGFzc2VydEJvdW5kcygpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zID4gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInByZW1hdHVyZSBFT0ZcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgaW50MzJgIGZpZWxkLCBhIHNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgICAqL1xuICAgIGludDMyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgc2ludDMyYCBmaWVsZCwgYSBzaWduZWQsIHppZ3phZy1lbmNvZGVkIDMyLWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgc2ludDMyKCkge1xuICAgICAgICBsZXQgenplID0gdGhpcy51aW50MzIoKTtcbiAgICAgICAgLy8gZGVjb2RlIHppZ3phZ1xuICAgICAgICByZXR1cm4gKHp6ZSA+Pj4gMSkgXiAtKHp6ZSAmIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGludDY0YCBmaWVsZCwgYSBzaWduZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBpbnQ2NCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYkxvbmcoLi4udGhpcy52YXJpbnQ2NCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGB1aW50NjRgIGZpZWxkLCBhbiB1bnNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHVpbnQ2NCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYlVMb25nKC4uLnRoaXMudmFyaW50NjQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgc2ludDY0YCBmaWVsZCwgYSBzaWduZWQsIHppZy16YWctZW5jb2RlZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHNpbnQ2NCgpIHtcbiAgICAgICAgbGV0IFtsbywgaGldID0gdGhpcy52YXJpbnQ2NCgpO1xuICAgICAgICAvLyBkZWNvZGUgemlnIHphZ1xuICAgICAgICBsZXQgcyA9IC0obG8gJiAxKTtcbiAgICAgICAgbG8gPSAoKGxvID4+PiAxIHwgKGhpICYgMSkgPDwgMzEpIF4gcyk7XG4gICAgICAgIGhpID0gKGhpID4+PiAxIF4gcyk7XG4gICAgICAgIHJldHVybiBuZXcgUGJMb25nKGxvLCBoaSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgYm9vbGAgZmllbGQsIGEgdmFyaWFudC5cbiAgICAgKi9cbiAgICBib29sKCkge1xuICAgICAgICBsZXQgW2xvLCBoaV0gPSB0aGlzLnZhcmludDY0KCk7XG4gICAgICAgIHJldHVybiBsbyAhPT0gMCB8fCBoaSAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBmaXhlZDMyYCBmaWVsZCwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBmaXhlZDMyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldFVpbnQzMigodGhpcy5wb3MgKz0gNCkgLSA0LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBzZml4ZWQzMmAgZmllbGQsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgc2ZpeGVkMzIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0SW50MzIoKHRoaXMucG9zICs9IDQpIC0gNCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgZml4ZWQ2NGAgZmllbGQsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQgYml0IGludGVnZXIuXG4gICAgICovXG4gICAgZml4ZWQ2NCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYlVMb25nKHRoaXMuc2ZpeGVkMzIoKSwgdGhpcy5zZml4ZWQzMigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBmaXhlZDY0YCBmaWVsZCwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCA2NC1iaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBzZml4ZWQ2NCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYkxvbmcodGhpcy5zZml4ZWQzMigpLCB0aGlzLnNmaXhlZDMyKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGZsb2F0YCBmaWVsZCwgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAgKi9cbiAgICBmbG9hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRGbG9hdDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGRvdWJsZWAgZmllbGQsIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAgKi9cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0RmxvYXQ2NCgodGhpcy5wb3MgKz0gOCkgLSA4LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBieXRlc2AgZmllbGQsIGxlbmd0aC1kZWxpbWl0ZWQgYXJiaXRyYXJ5IGRhdGEuXG4gICAgICovXG4gICAgYnl0ZXMoKSB7XG4gICAgICAgIGxldCBsZW4gPSB0aGlzLnVpbnQzMigpO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5wb3MgKz0gbGVuO1xuICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWYuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBzdHJpbmdgIGZpZWxkLCBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgY29udmVydGVkIHRvIFVURi04IHRleHQuXG4gICAgICovXG4gICAgc3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0RGVjb2Rlci5kZWNvZGUodGhpcy5ieXRlcygpKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBQYkxvbmcsIFBiVUxvbmcgfSBmcm9tIFwiLi9wYi1sb25nXCI7XG5pbXBvcnQgeyB2YXJpbnQzMndyaXRlLCB2YXJpbnQ2NHdyaXRlIH0gZnJvbSBcIi4vZ29vZy12YXJpbnRcIjtcbmltcG9ydCB7IGFzc2VydEZsb2F0MzIsIGFzc2VydEludDMyLCBhc3NlcnRVSW50MzIgfSBmcm9tIFwiLi9hc3NlcnRcIjtcbmNvbnN0IGRlZmF1bHRzV3JpdGUgPSB7XG4gICAgd3JpdGVVbmtub3duRmllbGRzOiB0cnVlLFxuICAgIHdyaXRlckZhY3Rvcnk6ICgpID0+IG5ldyBCaW5hcnlXcml0ZXIoKSxcbn07XG4vKipcbiAqIE1ha2Ugb3B0aW9ucyBmb3Igd3JpdGluZyBiaW5hcnkgZGF0YSBmb3JtIHBhcnRpYWwgb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVdyaXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzV3JpdGUpLCBvcHRpb25zKSA6IGRlZmF1bHRzV3JpdGU7XG59XG5leHBvcnQgY2xhc3MgQmluYXJ5V3JpdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0RW5jb2Rlcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJldmlvdXMgZm9yayBzdGF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIHRoaXMudGV4dEVuY29kZXIgPSB0ZXh0RW5jb2RlciAhPT0gbnVsbCAmJiB0ZXh0RW5jb2RlciAhPT0gdm9pZCAwID8gdGV4dEVuY29kZXIgOiBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5idWYgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFsbCBieXRlcyB3cml0dGVuIGFuZCByZXNldCB0aGlzIHdyaXRlci5cbiAgICAgKi9cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IFVpbnQ4QXJyYXkodGhpcy5idWYpKTsgLy8gZmx1c2ggdGhlIGJ1ZmZlclxuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGxlbiArPSB0aGlzLmNodW5rc1tpXS5sZW5ndGg7XG4gICAgICAgIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBieXRlcy5zZXQodGhpcy5jaHVua3NbaV0sIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdGhpcy5jaHVua3NbaV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgYSBuZXcgZm9yayBmb3IgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGxpa2UgYSBtZXNzYWdlXG4gICAgICogb3IgYSBwYWNrZWQgcmVwZWF0ZWQgZmllbGQuXG4gICAgICpcbiAgICAgKiBNdXN0IGJlIGpvaW5lZCBsYXRlciB3aXRoIGBqb2luKClgLlxuICAgICAqL1xuICAgIGZvcmsoKSB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh7IGNodW5rczogdGhpcy5jaHVua3MsIGJ1ZjogdGhpcy5idWYgfSk7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuYnVmID0gW107XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBKb2luIHRoZSBsYXN0IGZvcmsuIFdyaXRlIGl0cyBsZW5ndGggYW5kIGJ5dGVzLCB0aGVuXG4gICAgICogcmV0dXJuIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgICAgKi9cbiAgICBqb2luKCkge1xuICAgICAgICAvLyBnZXQgY2h1bmsgb2YgZm9ya1xuICAgICAgICBsZXQgY2h1bmsgPSB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAvLyByZXN0b3JlIHByZXZpb3VzIHN0YXRlXG4gICAgICAgIGxldCBwcmV2ID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKCFwcmV2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlLCBmb3JrIHN0YWNrIGVtcHR5Jyk7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gcHJldi5jaHVua3M7XG4gICAgICAgIHRoaXMuYnVmID0gcHJldi5idWY7XG4gICAgICAgIC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICAgICAgdGhpcy51aW50MzIoY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIHRhZyAoZmllbGQgbnVtYmVyIGFuZCB3aXJlIHR5cGUpLlxuICAgICAqXG4gICAgICogRXF1aXZhbGVudCB0byBgdWludDMyKCAoZmllbGRObyA8PCAzIHwgdHlwZSkgPj4+IDAgKWAuXG4gICAgICpcbiAgICAgKiBHZW5lcmF0ZWQgY29kZSBzaG91bGQgY29tcHV0ZSB0aGUgdGFnIGFoZWFkIG9mIHRpbWUgYW5kIGNhbGwgYHVpbnQzMigpYC5cbiAgICAgKi9cbiAgICB0YWcoZmllbGRObywgdHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51aW50MzIoKGZpZWxkTm8gPDwgMyB8IHR5cGUpID4+PiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBjaHVuayBvZiByYXcgYnl0ZXMuXG4gICAgICovXG4gICAgcmF3KGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IFVpbnQ4QXJyYXkodGhpcy5idWYpKTtcbiAgICAgICAgICAgIHRoaXMuYnVmID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGB1aW50MzJgIHZhbHVlLCBhbiB1bnNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHVpbnQzMih2YWx1ZSkge1xuICAgICAgICBhc3NlcnRVSW50MzIodmFsdWUpO1xuICAgICAgICAvLyB3cml0ZSB2YWx1ZSBhcyB2YXJpbnQgMzIsIGlubGluZWQgZm9yIHNwZWVkXG4gICAgICAgIHdoaWxlICh2YWx1ZSA+IDB4N2YpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmLnB1c2goKHZhbHVlICYgMHg3ZikgfCAweDgwKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4+IDc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWYucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBpbnQzMmAgdmFsdWUsIGEgc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgaW50MzIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgICAgICB2YXJpbnQzMndyaXRlKHZhbHVlLCB0aGlzLmJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBib29sYCB2YWx1ZSwgYSB2YXJpYW50LlxuICAgICAqL1xuICAgIGJvb2wodmFsdWUpIHtcbiAgICAgICAgdGhpcy5idWYucHVzaCh2YWx1ZSA/IDEgOiAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGJ5dGVzYCB2YWx1ZSwgbGVuZ3RoLWRlbGltaXRlZCBhcmJpdHJhcnkgZGF0YS5cbiAgICAgKi9cbiAgICBieXRlcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLnVpbnQzMih2YWx1ZS5ieXRlTGVuZ3RoKTsgLy8gd3JpdGUgbGVuZ3RoIG9mIGNodW5rIGFzIHZhcmludFxuICAgICAgICByZXR1cm4gdGhpcy5yYXcodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBzdHJpbmdgIHZhbHVlLCBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgY29udmVydGVkIHRvIFVURi04IHRleHQuXG4gICAgICovXG4gICAgc3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGxldCBjaHVuayA9IHRoaXMudGV4dEVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgdGhpcy51aW50MzIoY2h1bmsuYnl0ZUxlbmd0aCk7IC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgZmxvYXRgIHZhbHVlLCAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZsb2F0KHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEZsb2F0MzIodmFsdWUpO1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0RmxvYXQzMigwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGRvdWJsZWAgdmFsdWUsIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAgKi9cbiAgICBkb3VibGUodmFsdWUpIHtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEZsb2F0NjQoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBmaXhlZDMyYCB2YWx1ZSwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBmaXhlZDMyKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydFVJbnQzMih2YWx1ZSk7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRVaW50MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBzZml4ZWQzMmAgdmFsdWUsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgc2ZpeGVkMzIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0SW50MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBzaW50MzJgIHZhbHVlLCBhIHNpZ25lZCwgemlnemFnLWVuY29kZWQgMzItYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBzaW50MzIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgICAgICAvLyB6aWd6YWcgZW5jb2RlXG4gICAgICAgIHZhbHVlID0gKCh2YWx1ZSA8PCAxKSBeICh2YWx1ZSA+PiAzMSkpID4+PiAwO1xuICAgICAgICB2YXJpbnQzMndyaXRlKHZhbHVlLCB0aGlzLmJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBmaXhlZDY0YCB2YWx1ZSwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCA2NC1iaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBzZml4ZWQ2NCh2YWx1ZSkge1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICAgICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKTtcbiAgICAgICAgbGV0IGxvbmcgPSBQYkxvbmcuZnJvbSh2YWx1ZSk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgbG9uZy5sbywgdHJ1ZSk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoNCwgbG9uZy5oaSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGZpeGVkNjRgIHZhbHVlLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0IGJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGZpeGVkNjQodmFsdWUpIHtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcik7XG4gICAgICAgIGxldCBsb25nID0gUGJVTG9uZy5mcm9tKHZhbHVlKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCBsb25nLmxvLCB0cnVlKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMig0LCBsb25nLmhpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgaW50NjRgIHZhbHVlLCBhIHNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIGludDY0KHZhbHVlKSB7XG4gICAgICAgIGxldCBsb25nID0gUGJMb25nLmZyb20odmFsdWUpO1xuICAgICAgICB2YXJpbnQ2NHdyaXRlKGxvbmcubG8sIGxvbmcuaGksIHRoaXMuYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYHNpbnQ2NGAgdmFsdWUsIGEgc2lnbmVkLCB6aWctemFnLWVuY29kZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBzaW50NjQodmFsdWUpIHtcbiAgICAgICAgbGV0IGxvbmcgPSBQYkxvbmcuZnJvbSh2YWx1ZSksIFxuICAgICAgICAvLyB6aWd6YWcgZW5jb2RlXG4gICAgICAgIHNpZ24gPSBsb25nLmhpID4+IDMxLCBsbyA9IChsb25nLmxvIDw8IDEpIF4gc2lnbiwgaGkgPSAoKGxvbmcuaGkgPDwgMSkgfCAobG9uZy5sbyA+Pj4gMzEpKSBeIHNpZ247XG4gICAgICAgIHZhcmludDY0d3JpdGUobG8sIGhpLCB0aGlzLmJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGB1aW50NjRgIHZhbHVlLCBhbiB1bnNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHVpbnQ2NCh2YWx1ZSkge1xuICAgICAgICBsZXQgbG9uZyA9IFBiVUxvbmcuZnJvbSh2YWx1ZSk7XG4gICAgICAgIHZhcmludDY0d3JpdGUobG9uZy5sbywgbG9uZy5oaSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbi8vIG1ldDpcbi8vXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIGRpc3RyaWJ1dGlvbi5cbi8vICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuLy8gY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbi8vIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vL1xuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuLy8gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4vLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuLy8gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4vLyBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuLy9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBQcm90b2NvbCBCdWZmZXIgY29tcGlsZXIgaXMgb3duZWQgYnkgdGhlIG93bmVyXG4vLyBvZiB0aGUgaW5wdXQgZmlsZSB1c2VkIHdoZW4gZ2VuZXJhdGluZyBpdC4gIFRoaXMgY29kZSBpcyBub3Rcbi8vIHN0YW5kYWxvbmUgYW5kIHJlcXVpcmVzIGEgc3VwcG9ydCBsaWJyYXJ5IHRvIGJlIGxpbmtlZCB3aXRoIGl0LiAgVGhpc1xuLy8gc3VwcG9ydCBsaWJyYXJ5IGlzIGl0c2VsZiBjb3ZlcmVkIGJ5IHRoZSBhYm92ZSBsaWNlbnNlLlxuLyoqXG4gKiBSZWFkIGEgNjQgYml0IHZhcmludCBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBSZXR1cm5zIHR1cGxlOlxuICogWzBdOiBsb3cgYml0c1xuICogWzBdOiBoaWdoIGJpdHNcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL2J1ZmZlcl9kZWNvZGVyLmpzI0wxNzVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhcmludDY0cmVhZCgpIHtcbiAgICBsZXQgbG93Qml0cyA9IDA7XG4gICAgbGV0IGhpZ2hCaXRzID0gMDtcbiAgICBmb3IgKGxldCBzaGlmdCA9IDA7IHNoaWZ0IDwgMjg7IHNoaWZ0ICs9IDcpIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICAgICAgbG93Qml0cyB8PSAoYiAmIDB4N0YpIDw8IHNoaWZ0O1xuICAgICAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICAgICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1pZGRsZUJ5dGUgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICAvLyBsYXN0IGZvdXIgYml0cyBvZiB0aGUgZmlyc3QgMzIgYml0IG51bWJlclxuICAgIGxvd0JpdHMgfD0gKG1pZGRsZUJ5dGUgJiAweDBGKSA8PCAyODtcbiAgICAvLyAzIHVwcGVyIGJpdHMgYXJlIHBhcnQgb2YgdGhlIG5leHQgMzIgYml0IG51bWJlclxuICAgIGhpZ2hCaXRzID0gKG1pZGRsZUJ5dGUgJiAweDcwKSA+PiA0O1xuICAgIGlmICgobWlkZGxlQnl0ZSAmIDB4ODApID09IDApIHtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gICAgfVxuICAgIGZvciAobGV0IHNoaWZ0ID0gMzsgc2hpZnQgPD0gMzE7IHNoaWZ0ICs9IDcpIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICAgICAgaGlnaEJpdHMgfD0gKGIgJiAweDdGKSA8PCBzaGlmdDtcbiAgICAgICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB2YXJpbnQnKTtcbn1cbi8qKlxuICogV3JpdGUgYSA2NCBiaXQgdmFyaW50LCBnaXZlbiBhcyB0d28gSlMgbnVtYmVycywgdG8gdGhlIGdpdmVuIGJ5dGVzIGFycmF5LlxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvOGE3MTkyN2Q3NGE0Y2UzNGVmZTJkODc2OWZkYTE5OGY1MmQyMGQxMi9qcy9leHBlcmltZW50YWwvcnVudGltZS9rZXJuZWwvd3JpdGVyLmpzI0wzNDRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhcmludDY0d3JpdGUobG8sIGhpLCBieXRlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjg7IGkgPSBpICsgNykge1xuICAgICAgICBjb25zdCBzaGlmdCA9IGxvID4+PiBpO1xuICAgICAgICBjb25zdCBoYXNOZXh0ID0gISgoc2hpZnQgPj4+IDcpID09IDAgJiYgaGkgPT0gMCk7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSAoaGFzTmV4dCA/IHNoaWZ0IHwgMHg4MCA6IHNoaWZ0KSAmIDB4RkY7XG4gICAgICAgIGJ5dGVzLnB1c2goYnl0ZSk7XG4gICAgICAgIGlmICghaGFzTmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNwbGl0Qml0cyA9ICgobG8gPj4+IDI4KSAmIDB4MEYpIHwgKChoaSAmIDB4MDcpIDw8IDQpO1xuICAgIGNvbnN0IGhhc01vcmVCaXRzID0gISgoaGkgPj4gMykgPT0gMCk7XG4gICAgYnl0ZXMucHVzaCgoaGFzTW9yZUJpdHMgPyBzcGxpdEJpdHMgfCAweDgwIDogc3BsaXRCaXRzKSAmIDB4RkYpO1xuICAgIGlmICghaGFzTW9yZUJpdHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMzsgaSA8IDMxOyBpID0gaSArIDcpIHtcbiAgICAgICAgY29uc3Qgc2hpZnQgPSBoaSA+Pj4gaTtcbiAgICAgICAgY29uc3QgaGFzTmV4dCA9ICEoKHNoaWZ0ID4+PiA3KSA9PSAwKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IChoYXNOZXh0ID8gc2hpZnQgfCAweDgwIDogc2hpZnQpICYgMHhGRjtcbiAgICAgICAgYnl0ZXMucHVzaChieXRlKTtcbiAgICAgICAgaWYgKCFoYXNOZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnl0ZXMucHVzaCgoaGkgPj4+IDMxKSAmIDB4MDEpO1xufVxuLy8gY29uc3RhbnRzIGZvciBiaW5hcnkgbWF0aFxuY29uc3QgVFdPX1BXUl8zMl9EQkwgPSAoMSA8PCAxNikgKiAoMSA8PCAxNik7XG4vKipcbiAqIFBhcnNlIGRlY2ltYWwgc3RyaW5nIG9mIDY0IGJpdCBpbnRlZ2VyIHZhbHVlIGFzIHR3byBKUyBudW1iZXJzLlxuICpcbiAqIFJldHVybnMgdHVwbGU6XG4gKiBbMF06IG1pbnVzIHNpZ24/XG4gKiBbMV06IGxvdyBiaXRzXG4gKiBbMl06IGhpZ2ggYml0c1xuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnQ2NGZyb21TdHJpbmcoZGVjKSB7XG4gICAgLy8gQ2hlY2sgZm9yIG1pbnVzIHNpZ24uXG4gICAgbGV0IG1pbnVzID0gZGVjWzBdID09ICctJztcbiAgICBpZiAobWludXMpXG4gICAgICAgIGRlYyA9IGRlYy5zbGljZSgxKTtcbiAgICAvLyBXb3JrIDYgZGVjaW1hbCBkaWdpdHMgYXQgYSB0aW1lLCBhY3RpbmcgbGlrZSB3ZSdyZSBjb252ZXJ0aW5nIGJhc2UgMWU2XG4gICAgLy8gZGlnaXRzIHRvIGJpbmFyeS4gVGhpcyBpcyBzYWZlIHRvIGRvIHdpdGggZmxvYXRpbmcgcG9pbnQgbWF0aCBiZWNhdXNlXG4gICAgLy8gTnVtYmVyLmlzU2FmZUludGVnZXIoQUxMXzMyX0JJVFMgKiAxZTYpID09IHRydWUuXG4gICAgY29uc3QgYmFzZSA9IDFlNjtcbiAgICBsZXQgbG93Qml0cyA9IDA7XG4gICAgbGV0IGhpZ2hCaXRzID0gMDtcbiAgICBmdW5jdGlvbiBhZGQxZTZkaWdpdChiZWdpbiwgZW5kKSB7XG4gICAgICAgIC8vIE5vdGU6IE51bWJlcignJykgaXMgMC5cbiAgICAgICAgY29uc3QgZGlnaXQxZTYgPSBOdW1iZXIoZGVjLnNsaWNlKGJlZ2luLCBlbmQpKTtcbiAgICAgICAgaGlnaEJpdHMgKj0gYmFzZTtcbiAgICAgICAgbG93Qml0cyA9IGxvd0JpdHMgKiBiYXNlICsgZGlnaXQxZTY7XG4gICAgICAgIC8vIENhcnJ5IGJpdHMgZnJvbSBsb3dCaXRzIHRvIGhpZ2hCaXRzXG4gICAgICAgIGlmIChsb3dCaXRzID49IFRXT19QV1JfMzJfREJMKSB7XG4gICAgICAgICAgICBoaWdoQml0cyA9IGhpZ2hCaXRzICsgKChsb3dCaXRzIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCk7XG4gICAgICAgICAgICBsb3dCaXRzID0gbG93Qml0cyAlIFRXT19QV1JfMzJfREJMO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZDFlNmRpZ2l0KC0yNCwgLTE4KTtcbiAgICBhZGQxZTZkaWdpdCgtMTgsIC0xMik7XG4gICAgYWRkMWU2ZGlnaXQoLTEyLCAtNik7XG4gICAgYWRkMWU2ZGlnaXQoLTYpO1xuICAgIHJldHVybiBbbWludXMsIGxvd0JpdHMsIGhpZ2hCaXRzXTtcbn1cbi8qKlxuICogRm9ybWF0IDY0IGJpdCBpbnRlZ2VyIHZhbHVlIChhcyB0d28gSlMgbnVtYmVycykgdG8gZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludDY0dG9TdHJpbmcoYml0c0xvdywgYml0c0hpZ2gpIHtcbiAgICAvLyBTa2lwIHRoZSBleHBlbnNpdmUgY29udmVyc2lvbiBpZiB0aGUgbnVtYmVyIGlzIHNtYWxsIGVub3VnaCB0byB1c2UgdGhlXG4gICAgLy8gYnVpbHQtaW4gY29udmVyc2lvbnMuXG4gICAgaWYgKChiaXRzSGlnaCA+Pj4gMCkgPD0gMHgxRkZGRkYpIHtcbiAgICAgICAgcmV0dXJuICcnICsgKFRXT19QV1JfMzJfREJMICogYml0c0hpZ2ggKyAoYml0c0xvdyA+Pj4gMCkpO1xuICAgIH1cbiAgICAvLyBXaGF0IHRoaXMgY29kZSBpcyBkb2luZyBpcyBlc3NlbnRpYWxseSBjb252ZXJ0aW5nIHRoZSBpbnB1dCBudW1iZXIgZnJvbVxuICAgIC8vIGJhc2UtMiB0byBiYXNlLTFlNywgd2hpY2ggYWxsb3dzIHVzIHRvIHJlcHJlc2VudCB0aGUgNjQtYml0IHJhbmdlIHdpdGhcbiAgICAvLyBvbmx5IDMgKHZlcnkgbGFyZ2UpIGRpZ2l0cy4gVGhvc2UgZGlnaXRzIGFyZSB0aGVuIHRyaXZpYWwgdG8gY29udmVydCB0b1xuICAgIC8vIGEgYmFzZS0xMCBzdHJpbmcuXG4gICAgLy8gVGhlIG1hZ2ljIG51bWJlcnMgdXNlZCBoZXJlIGFyZSAtXG4gICAgLy8gMl4yNCA9IDE2Nzc3MjE2ID0gKDEsNjc3NzIxNikgaW4gYmFzZS0xZTcuXG4gICAgLy8gMl40OCA9IDI4MTQ3NDk3NjcxMDY1NiA9ICgyLDgxNDc0OTcsNjcxMDY1NikgaW4gYmFzZS0xZTcuXG4gICAgLy8gU3BsaXQgMzI6MzIgcmVwcmVzZW50YXRpb24gaW50byAxNjoyNDoyNCByZXByZXNlbnRhdGlvbiBzbyBvdXJcbiAgICAvLyBpbnRlcm1lZGlhdGUgZGlnaXRzIGRvbid0IG92ZXJmbG93LlxuICAgIGxldCBsb3cgPSBiaXRzTG93ICYgMHhGRkZGRkY7XG4gICAgbGV0IG1pZCA9ICgoKGJpdHNMb3cgPj4+IDI0KSB8IChiaXRzSGlnaCA8PCA4KSkgPj4+IDApICYgMHhGRkZGRkY7XG4gICAgbGV0IGhpZ2ggPSAoYml0c0hpZ2ggPj4gMTYpICYgMHhGRkZGO1xuICAgIC8vIEFzc2VtYmxlIG91ciB0aHJlZSBiYXNlLTFlNyBkaWdpdHMsIGlnbm9yaW5nIGNhcnJpZXMuIFRoZSBtYXhpbXVtXG4gICAgLy8gdmFsdWUgaW4gYSBkaWdpdCBhdCB0aGlzIHN0ZXAgaXMgcmVwcmVzZW50YWJsZSBhcyBhIDQ4LWJpdCBpbnRlZ2VyLCB3aGljaFxuICAgIC8vIGNhbiBiZSBzdG9yZWQgaW4gYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICAgIGxldCBkaWdpdEEgPSBsb3cgKyAobWlkICogNjc3NzIxNikgKyAoaGlnaCAqIDY3MTA2NTYpO1xuICAgIGxldCBkaWdpdEIgPSBtaWQgKyAoaGlnaCAqIDgxNDc0OTcpO1xuICAgIGxldCBkaWdpdEMgPSAoaGlnaCAqIDIpO1xuICAgIC8vIEFwcGx5IGNhcnJpZXMgZnJvbSBBIHRvIEIgYW5kIGZyb20gQiB0byBDLlxuICAgIGxldCBiYXNlID0gMTAwMDAwMDA7XG4gICAgaWYgKGRpZ2l0QSA+PSBiYXNlKSB7XG4gICAgICAgIGRpZ2l0QiArPSBNYXRoLmZsb29yKGRpZ2l0QSAvIGJhc2UpO1xuICAgICAgICBkaWdpdEEgJT0gYmFzZTtcbiAgICB9XG4gICAgaWYgKGRpZ2l0QiA+PSBiYXNlKSB7XG4gICAgICAgIGRpZ2l0QyArPSBNYXRoLmZsb29yKGRpZ2l0QiAvIGJhc2UpO1xuICAgICAgICBkaWdpdEIgJT0gYmFzZTtcbiAgICB9XG4gICAgLy8gQ29udmVydCBiYXNlLTFlNyBkaWdpdHMgdG8gYmFzZS0xMCwgd2l0aCBvcHRpb25hbCBsZWFkaW5nIHplcm9lcy5cbiAgICBmdW5jdGlvbiBkZWNpbWFsRnJvbTFlNyhkaWdpdDFlNywgbmVlZExlYWRpbmdaZXJvcykge1xuICAgICAgICBsZXQgcGFydGlhbCA9IGRpZ2l0MWU3ID8gU3RyaW5nKGRpZ2l0MWU3KSA6ICcnO1xuICAgICAgICBpZiAobmVlZExlYWRpbmdaZXJvcykge1xuICAgICAgICAgICAgcmV0dXJuICcwMDAwMDAwJy5zbGljZShwYXJ0aWFsLmxlbmd0aCkgKyBwYXJ0aWFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0aWFsO1xuICAgIH1cbiAgICByZXR1cm4gZGVjaW1hbEZyb20xZTcoZGlnaXRDLCAvKm5lZWRMZWFkaW5nWmVyb3M9Ki8gMCkgK1xuICAgICAgICBkZWNpbWFsRnJvbTFlNyhkaWdpdEIsIC8qbmVlZExlYWRpbmdaZXJvcz0qLyBkaWdpdEMpICtcbiAgICAgICAgLy8gSWYgdGhlIGZpbmFsIDFlNyBkaWdpdCBkaWRuJ3QgbmVlZCBsZWFkaW5nIHplcm9zLCB3ZSB3b3VsZCBoYXZlXG4gICAgICAgIC8vIHJldHVybmVkIHZpYSB0aGUgdHJpdmlhbCBjb2RlIHBhdGggYXQgdGhlIHRvcC5cbiAgICAgICAgZGVjaW1hbEZyb20xZTcoZGlnaXRBLCAvKm5lZWRMZWFkaW5nWmVyb3M9Ki8gMSk7XG59XG4vKipcbiAqIFdyaXRlIGEgMzIgYml0IHZhcmludCwgc2lnbmVkIG9yIHVuc2lnbmVkLiBTYW1lIGFzIGB2YXJpbnQ2NHdyaXRlKDAsIHZhbHVlLCBieXRlcylgXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi8xYjE4ODMzZjRmMmEyZjY4MWY0ZTRhMjVjZGYzYjBhNDMxMTVlYzI2L2pzL2JpbmFyeS9lbmNvZGVyLmpzI0wxNDRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhcmludDMyd3JpdGUodmFsdWUsIGJ5dGVzKSB7XG4gICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgLy8gd3JpdGUgdmFsdWUgYXMgdmFyaW50IDMyXG4gICAgICAgIHdoaWxlICh2YWx1ZSA+IDB4N2YpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goKHZhbHVlICYgMHg3ZikgfCAweDgwKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4+IDc7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCh2YWx1ZSAmIDEyNyB8IDEyOCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDc7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXMucHVzaCgxKTtcbiAgICB9XG59XG4vKipcbiAqIFJlYWQgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL2J1ZmZlcl9kZWNvZGVyLmpzI0wyMjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhcmludDMycmVhZCgpIHtcbiAgICBsZXQgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIGxldCByZXN1bHQgPSBiICYgMHg3RjtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDdGKSA8PCA3O1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIHJlc3VsdCB8PSAoYiAmIDB4N0YpIDw8IDE0O1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIHJlc3VsdCB8PSAoYiAmIDB4N0YpIDw8IDIxO1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRXh0cmFjdCBvbmx5IGxhc3QgNCBiaXRzXG4gICAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIHJlc3VsdCB8PSAoYiAmIDB4MEYpIDw8IDI4O1xuICAgIGZvciAobGV0IHJlYWRCeXRlcyA9IDU7ICgoYiAmIDB4ODApICE9PSAwKSAmJiByZWFkQnl0ZXMgPCAxMDsgcmVhZEJ5dGVzKyspXG4gICAgICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICBpZiAoKGIgJiAweDgwKSAhPSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdmFyaW50Jyk7XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAvLyBSZXN1bHQgY2FuIGhhdmUgMzIgYml0cywgY29udmVydCBpdCB0byB1bnNpZ25lZFxuICAgIHJldHVybiByZXN1bHQgPj4+IDA7XG59XG4iLCJjb25zdCBkZWZhdWx0c1dyaXRlID0ge1xuICAgIGVtaXREZWZhdWx0VmFsdWVzOiBmYWxzZSxcbiAgICBlbnVtQXNJbnRlZ2VyOiBmYWxzZSxcbiAgICB1c2VQcm90b0ZpZWxkTmFtZTogZmFsc2UsXG4gICAgcHJldHR5U3BhY2VzOiAwLFxufSwgZGVmYXVsdHNSZWFkID0ge1xuICAgIGlnbm9yZVVua25vd25GaWVsZHM6IGZhbHNlLFxufTtcbi8qKlxuICogTWFrZSBvcHRpb25zIGZvciByZWFkaW5nIEpTT04gZGF0YSBmcm9tIHBhcnRpYWwgb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpzb25SZWFkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzUmVhZCksIG9wdGlvbnMpIDogZGVmYXVsdHNSZWFkO1xufVxuLyoqXG4gKiBNYWtlIG9wdGlvbnMgZm9yIHdyaXRpbmcgSlNPTiBkYXRhIGZyb20gcGFydGlhbCBvcHRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24ganNvbldyaXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzV3JpdGUpLCBvcHRpb25zKSA6IGRlZmF1bHRzV3JpdGU7XG59XG4vKipcbiAqIE1lcmdlcyBKU09OIHdyaXRlIG9yIHJlYWQgb3B0aW9ucy4gTGF0ZXIgdmFsdWVzIG92ZXJyaWRlIGVhcmxpZXIgdmFsdWVzLiBUeXBlIHJlZ2lzdHJpZXMgYXJlIG1lcmdlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSnNvbk9wdGlvbnMoYSwgYikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgbGV0IGMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGEpLCBiKTtcbiAgICBjLnR5cGVSZWdpc3RyeSA9IFsuLi4oKF9hID0gYSA9PT0gbnVsbCB8fCBhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhLnR5cGVSZWdpc3RyeSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLCAuLi4oKF9iID0gYiA9PT0gbnVsbCB8fCBiID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiLnR5cGVSZWdpc3RyeSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pXTtcbiAgICByZXR1cm4gYztcbn1cbiIsIi8qKlxuICogR2V0IHRoZSB0eXBlIG9mIGEgSlNPTiB2YWx1ZS5cbiAqIERpc3Rpbmd1aXNoZXMgYmV0d2VlbiBhcnJheSwgbnVsbCBhbmQgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHlwZW9mSnNvblZhbHVlKHZhbHVlKSB7XG4gICAgbGV0IHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgaWYgKHQgPT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuLyoqXG4gKiBJcyB0aGlzIGEgSlNPTiBvYmplY3QgKGluc3RlYWQgb2YgYW4gYXJyYXkgb3IgbnVsbCk/XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0pzb25PYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuIiwiLyoqXG4gKiBDb252ZXJ0cyBzbmFrZV9jYXNlIHRvIGxvd2VyQ2FtZWxDYXNlLlxuICpcbiAqIFNob3VsZCBiZWhhdmUgbGlrZSBwcm90b2M6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvZThhZTEzN2M5NjQ0NGVhMzEzNDg1ZWQxMTE4YzVlNDNiMjA5OWNmMS9zcmMvZ29vZ2xlL3Byb3RvYnVmL2NvbXBpbGVyL2phdmEvamF2YV9oZWxwZXJzLmNjI0wxMThcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvd2VyQ2FtZWxDYXNlKHNuYWtlQ2FzZSkge1xuICAgIGxldCBjYXBOZXh0ID0gZmFsc2U7XG4gICAgY29uc3Qgc2IgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNuYWtlQ2FzZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbmV4dCA9IHNuYWtlQ2FzZS5jaGFyQXQoaSk7XG4gICAgICAgIGlmIChuZXh0ID09ICdfJykge1xuICAgICAgICAgICAgY2FwTmV4dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL1xcZC8udGVzdChuZXh0KSkge1xuICAgICAgICAgICAgc2IucHVzaChuZXh0KTtcbiAgICAgICAgICAgIGNhcE5leHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhcE5leHQpIHtcbiAgICAgICAgICAgIHNiLnB1c2gobmV4dC50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICAgIGNhcE5leHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpID09IDApIHtcbiAgICAgICAgICAgIHNiLnB1c2gobmV4dC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNiLnB1c2gobmV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNiLmpvaW4oJycpO1xufVxuIiwiLyoqXG4gKiBUaGUgc3ltYm9sIHVzZWQgYXMgYSBrZXkgb24gbWVzc2FnZSBvYmplY3RzIHRvIHN0b3JlIHRoZSBtZXNzYWdlIHR5cGUuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUgLSBpdCBpcyBoZXJlIHRvIHN0YXksIGJ1dFxuICogaW1wbGVtZW50YXRpb24gZGV0YWlscyBtYXkgY2hhbmdlIHdpdGhvdXQgbm90aWNlLlxuICovXG5leHBvcnQgY29uc3QgTUVTU0FHRV9UWVBFID0gU3ltYm9sLmZvcihcInByb3RvYnVmLXRzL21lc3NhZ2UtdHlwZVwiKTtcbiIsImltcG9ydCB7IE1FU1NBR0VfVFlQRSB9IGZyb20gXCIuL21lc3NhZ2UtdHlwZS1jb250cmFjdFwiO1xuaW1wb3J0IHsgbm9ybWFsaXplRmllbGRJbmZvIH0gZnJvbSBcIi4vcmVmbGVjdGlvbi1pbmZvXCI7XG5pbXBvcnQgeyBSZWZsZWN0aW9uVHlwZUNoZWNrIH0gZnJvbSBcIi4vcmVmbGVjdGlvbi10eXBlLWNoZWNrXCI7XG5pbXBvcnQgeyBSZWZsZWN0aW9uSnNvblJlYWRlciB9IGZyb20gXCIuL3JlZmxlY3Rpb24tanNvbi1yZWFkZXJcIjtcbmltcG9ydCB7IFJlZmxlY3Rpb25Kc29uV3JpdGVyIH0gZnJvbSBcIi4vcmVmbGVjdGlvbi1qc29uLXdyaXRlclwiO1xuaW1wb3J0IHsgUmVmbGVjdGlvbkJpbmFyeVJlYWRlciB9IGZyb20gXCIuL3JlZmxlY3Rpb24tYmluYXJ5LXJlYWRlclwiO1xuaW1wb3J0IHsgUmVmbGVjdGlvbkJpbmFyeVdyaXRlciB9IGZyb20gXCIuL3JlZmxlY3Rpb24tYmluYXJ5LXdyaXRlclwiO1xuaW1wb3J0IHsgcmVmbGVjdGlvbkNyZWF0ZSB9IGZyb20gXCIuL3JlZmxlY3Rpb24tY3JlYXRlXCI7XG5pbXBvcnQgeyByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsIH0gZnJvbSBcIi4vcmVmbGVjdGlvbi1tZXJnZS1wYXJ0aWFsXCI7XG5pbXBvcnQgeyB0eXBlb2ZKc29uVmFsdWUgfSBmcm9tIFwiLi9qc29uLXR5cGluZ3NcIjtcbmltcG9ydCB7IGpzb25SZWFkT3B0aW9ucywganNvbldyaXRlT3B0aW9ucywgfSBmcm9tIFwiLi9qc29uLWZvcm1hdC1jb250cmFjdFwiO1xuaW1wb3J0IHsgcmVmbGVjdGlvbkVxdWFscyB9IGZyb20gXCIuL3JlZmxlY3Rpb24tZXF1YWxzXCI7XG5pbXBvcnQgeyBiaW5hcnlXcml0ZU9wdGlvbnMgfSBmcm9tIFwiLi9iaW5hcnktd3JpdGVyXCI7XG5pbXBvcnQgeyBiaW5hcnlSZWFkT3B0aW9ucyB9IGZyb20gXCIuL2JpbmFyeS1yZWFkZXJcIjtcbmNvbnN0IGJhc2VEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSkpO1xuLyoqXG4gKiBUaGlzIHN0YW5kYXJkIG1lc3NhZ2UgdHlwZSBwcm92aWRlcyByZWZsZWN0aW9uLWJhc2VkXG4gKiBvcGVyYXRpb25zIHRvIHdvcmsgd2l0aCBhIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgZmllbGRzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdENoZWNrRGVwdGggPSAxNjtcbiAgICAgICAgdGhpcy50eXBlTmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzLm1hcChub3JtYWxpemVGaWVsZEluZm8pO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgdGhpcy5tZXNzYWdlUHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJhc2VEZXNjcmlwdG9ycyksIHsgW01FU1NBR0VfVFlQRV06IHsgdmFsdWU6IHRoaXMgfSB9KSk7XG4gICAgICAgIHRoaXMucmVmVHlwZUNoZWNrID0gbmV3IFJlZmxlY3Rpb25UeXBlQ2hlY2sodGhpcyk7XG4gICAgICAgIHRoaXMucmVmSnNvblJlYWRlciA9IG5ldyBSZWZsZWN0aW9uSnNvblJlYWRlcih0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZKc29uV3JpdGVyID0gbmV3IFJlZmxlY3Rpb25Kc29uV3JpdGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZkJpblJlYWRlciA9IG5ldyBSZWZsZWN0aW9uQmluYXJ5UmVhZGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZkJpbldyaXRlciA9IG5ldyBSZWZsZWN0aW9uQmluYXJ5V3JpdGVyKHRoaXMpO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSByZWZsZWN0aW9uQ3JlYXRlKHRoaXMpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lIHRoZSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogVW5rbm93biBmaWVsZHMgYXJlIGRpc2NhcmRlZC5cbiAgICAgKi9cbiAgICBjbG9uZShtZXNzYWdlKSB7XG4gICAgICAgIGxldCBjb3B5ID0gdGhpcy5jcmVhdGUoKTtcbiAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBjb3B5LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0d28gbWVzc2FnZSBvZiB0aGUgc2FtZSB0eXBlIGhhdmUgdGhlIHNhbWUgZmllbGQgdmFsdWVzLlxuICAgICAqIENoZWNrcyBmb3IgZGVlcCBlcXVhbGl0eSwgdHJhdmVyc2luZyByZXBlYXRlZCBmaWVsZHMsIG9uZW9mIGdyb3VwcywgbWFwc1xuICAgICAqIGFuZCBtZXNzYWdlcyByZWN1cnNpdmVseS5cbiAgICAgKiBXaWxsIGFsc28gcmV0dXJuIHRydWUgaWYgYm90aCBtZXNzYWdlcyBhcmUgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHJlZmxlY3Rpb25FcXVhbHModGhpcywgYSwgYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSBnaXZlbiB2YWx1ZSBhc3NpZ25hYmxlIHRvIG91ciBtZXNzYWdlIHR5cGVcbiAgICAgKiBhbmQgY29udGFpbnMgbm8gW2V4Y2VzcyBwcm9wZXJ0aWVzXShodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9pbnRlcmZhY2VzLmh0bWwjZXhjZXNzLXByb3BlcnR5LWNoZWNrcyk/XG4gICAgICovXG4gICAgaXMoYXJnLCBkZXB0aCA9IHRoaXMuZGVmYXVsdENoZWNrRGVwdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmVHlwZUNoZWNrLmlzKGFyZywgZGVwdGgsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIGdpdmVuIHZhbHVlIGFzc2lnbmFibGUgdG8gb3VyIG1lc3NhZ2UgdHlwZSxcbiAgICAgKiByZWdhcmRsZXNzIG9mIFtleGNlc3MgcHJvcGVydGllc10oaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svaW50ZXJmYWNlcy5odG1sI2V4Y2Vzcy1wcm9wZXJ0eS1jaGVja3MpP1xuICAgICAqL1xuICAgIGlzQXNzaWduYWJsZShhcmcsIGRlcHRoID0gdGhpcy5kZWZhdWx0Q2hlY2tEZXB0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZUeXBlQ2hlY2suaXMoYXJnLCBkZXB0aCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcHkgcGFydGlhbCBkYXRhIGludG8gdGhlIHRhcmdldCBtZXNzYWdlLlxuICAgICAqL1xuICAgIG1lcmdlUGFydGlhbCh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIHRhcmdldCwgc291cmNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG1lc3NhZ2UgZnJvbSBiaW5hcnkgZm9ybWF0LlxuICAgICAqL1xuICAgIGZyb21CaW5hcnkoZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgb3B0ID0gYmluYXJ5UmVhZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQmluYXJ5UmVhZChvcHQucmVhZGVyRmFjdG9yeShkYXRhKSwgZGF0YS5ieXRlTGVuZ3RoLCBvcHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgbmV3IG1lc3NhZ2UgZnJvbSBhIEpTT04gdmFsdWUuXG4gICAgICovXG4gICAgZnJvbUpzb24oanNvbiwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEpzb25SZWFkKGpzb24sIGpzb25SZWFkT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBuZXcgbWVzc2FnZSBmcm9tIGEgSlNPTiBzdHJpbmcuXG4gICAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBULmZyb21Kc29uKEpTT04ucGFyc2UoanNvbikpYC5cbiAgICAgKi9cbiAgICBmcm9tSnNvblN0cmluZyhqc29uLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21Kc29uKHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgdGhlIG1lc3NhZ2UgdG8gY2Fub25pY2FsIEpTT04gdmFsdWUuXG4gICAgICovXG4gICAgdG9Kc29uKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxKc29uV3JpdGUobWVzc2FnZSwganNvbldyaXRlT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIG1lc3NhZ2UgdG8gY2Fub25pY2FsIEpTT04gc3RyaW5nLlxuICAgICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byBgSlNPTi5zdHJpbmdpZnkoVC50b0pzb24odCkpYFxuICAgICAqL1xuICAgIHRvSnNvblN0cmluZyhtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy50b0pzb24obWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXR0eVNwYWNlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIHRoZSBtZXNzYWdlIHRvIGJpbmFyeSBmb3JtYXQuXG4gICAgICovXG4gICAgdG9CaW5hcnkobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgb3B0ID0gYmluYXJ5V3JpdGVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIG9wdC53cml0ZXJGYWN0b3J5KCksIG9wdCkuZmluaXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYW4gaW50ZXJuYWwgbWV0aG9kLiBJZiB5b3UganVzdCB3YW50IHRvIHJlYWQgYSBtZXNzYWdlIGZyb21cbiAgICAgKiBKU09OLCB1c2UgYGZyb21Kc29uKClgIG9yIGBmcm9tSnNvblN0cmluZygpYC5cbiAgICAgKlxuICAgICAqIFJlYWRzIEpTT04gdmFsdWUgYW5kIG1lcmdlcyB0aGUgZmllbGRzIGludG8gdGhlIHRhcmdldFxuICAgICAqIGFjY29yZGluZyB0byBwcm90b2J1ZiBydWxlcy4gSWYgdGhlIHRhcmdldCBpcyBvbWl0dGVkLFxuICAgICAqIGEgbmV3IGluc3RhbmNlIGlzIGNyZWF0ZWQgZmlyc3QuXG4gICAgICovXG4gICAgaW50ZXJuYWxKc29uUmVhZChqc29uLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKGpzb24gIT09IG51bGwgJiYgdHlwZW9mIGpzb24gPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShqc29uKSkge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZWZKc29uUmVhZGVyLnJlYWQoanNvbiwgbWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSBtZXNzYWdlICR7dGhpcy50eXBlTmFtZX0gZnJvbSBKU09OICR7dHlwZW9mSnNvblZhbHVlKGpzb24pfS5gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhbiBpbnRlcm5hbCBtZXRob2QuIElmIHlvdSBqdXN0IHdhbnQgdG8gd3JpdGUgYSBtZXNzYWdlXG4gICAgICogdG8gSlNPTiwgdXNlIGB0b0pzb24oKWAgb3IgYHRvSnNvblN0cmluZygpLlxuICAgICAqXG4gICAgICogV3JpdGVzIEpTT04gdmFsdWUgYW5kIHJldHVybnMgaXQuXG4gICAgICovXG4gICAgaW50ZXJuYWxKc29uV3JpdGUobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZKc29uV3JpdGVyLndyaXRlKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGFuIGludGVybmFsIG1ldGhvZC4gSWYgeW91IGp1c3Qgd2FudCB0byB3cml0ZSBhIG1lc3NhZ2VcbiAgICAgKiBpbiBiaW5hcnkgZm9ybWF0LCB1c2UgYHRvQmluYXJ5KClgLlxuICAgICAqXG4gICAgICogU2VyaWFsaXplcyB0aGUgbWVzc2FnZSBpbiBiaW5hcnkgZm9ybWF0IGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBnaXZlblxuICAgICAqIHdyaXRlci4gUmV0dXJucyBwYXNzZWQgd3JpdGVyLlxuICAgICAqL1xuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucmVmQmluV3JpdGVyLndyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYW4gaW50ZXJuYWwgbWV0aG9kLiBJZiB5b3UganVzdCB3YW50IHRvIHJlYWQgYSBtZXNzYWdlIGZyb21cbiAgICAgKiBiaW5hcnkgZGF0YSwgdXNlIGBmcm9tQmluYXJ5KClgLlxuICAgICAqXG4gICAgICogUmVhZHMgZGF0YSBmcm9tIGJpbmFyeSBmb3JtYXQgYW5kIG1lcmdlcyB0aGUgZmllbGRzIGludG9cbiAgICAgKiB0aGUgdGFyZ2V0IGFjY29yZGluZyB0byBwcm90b2J1ZiBydWxlcy4gSWYgdGhlIHRhcmdldCBpc1xuICAgICAqIG9taXR0ZWQsIGEgbmV3IGluc3RhbmNlIGlzIGNyZWF0ZWQgZmlyc3QuXG4gICAgICovXG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpO1xuICAgICAgICB0aGlzLnJlZkJpblJlYWRlci5yZWFkKHJlYWRlciwgbWVzc2FnZSwgb3B0aW9ucywgbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxufVxuIiwiLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gdmFsdWUgYSB2YWxpZCBvbmVvZiBncm91cD9cbiAqXG4gKiBXZSByZXByZXNlbnQgcHJvdG9idWYgYG9uZW9mYCBhcyBhbGdlYnJhaWMgZGF0YSB0eXBlcyAoQURUKSBpbiBnZW5lcmF0ZWRcbiAqIGNvZGUuIEJ1dCB3aGVuIHdvcmtpbmcgd2l0aCBtZXNzYWdlcyBvZiB1bmtub3duIHR5cGUsIHRoZSBBRFQgZG9lcyBub3RcbiAqIGhlbHAgdXMuXG4gKlxuICogVGhpcyB0eXBlIGd1YXJkIGNoZWNrcyBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGFkaGVyZXMgdG8gdGhlIEFEVCBydWxlcywgd2hpY2hcbiAqIGFyZSBhcyBmb2xsb3dzOlxuICpcbiAqIDEpIE11c3QgYmUgYW4gb2JqZWN0LlxuICpcbiAqIDIpIE11c3QgaGF2ZSBhIFwib25lb2ZLaW5kXCIgZGlzY3JpbWluYXRvciBwcm9wZXJ0eS5cbiAqXG4gKiAzKSBJZiBcIm9uZW9mS2luZFwiIGlzIGB1bmRlZmluZWRgLCBubyBtZW1iZXIgZmllbGQgaXMgc2VsZWN0ZWQuIFRoZSBvYmplY3RcbiAqIG11c3Qgbm90IGhhdmUgYW55IG90aGVyIHByb3BlcnRpZXMuXG4gKlxuICogNCkgSWYgXCJvbmVvZktpbmRcIiBpcyBhIGBzdHJpbmdgLCB0aGUgbWVtYmVyIGZpZWxkIHdpdGggdGhpcyBuYW1lIGlzXG4gKiBzZWxlY3RlZC5cbiAqXG4gKiA1KSBJZiBhIG1lbWJlciBmaWVsZCBpcyBzZWxlY3RlZCwgdGhlIG9iamVjdCBtdXN0IGhhdmUgYSBzZWNvbmQgcHJvcGVydHlcbiAqIHdpdGggdGhpcyBuYW1lLiBUaGUgcHJvcGVydHkgbXVzdCBub3QgYmUgYHVuZGVmaW5lZGAuXG4gKlxuICogNikgTm8gZXh0cmEgcHJvcGVydGllcyBhcmUgYWxsb3dlZC4gVGhlIG9iamVjdCBoYXMgZWl0aGVyIG9uZSBwcm9wZXJ0eVxuICogKG5vIHNlbGVjdGlvbikgb3IgdHdvIHByb3BlcnRpZXMgKHNlbGVjdGlvbikuXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPbmVvZkdyb3VwKGFueSkge1xuICAgIGlmICh0eXBlb2YgYW55ICE9ICdvYmplY3QnIHx8IGFueSA9PT0gbnVsbCB8fCAhYW55Lmhhc093blByb3BlcnR5KCdvbmVvZktpbmQnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mIGFueS5vbmVvZktpbmQpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgaWYgKGFueVthbnkub25lb2ZLaW5kXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhbnkpLmxlbmd0aCA9PSAyO1xuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYW55KS5sZW5ndGggPT0gMTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBmaWVsZCBpbiBhIG9uZW9mIGdyb3VwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T25lb2ZWYWx1ZShvbmVvZiwga2luZCkge1xuICAgIHJldHVybiBvbmVvZltraW5kXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRPbmVvZlZhbHVlKG9uZW9mLCBraW5kLCB2YWx1ZSkge1xuICAgIGlmIChvbmVvZi5vbmVvZktpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgb25lb2Zbb25lb2Yub25lb2ZLaW5kXTtcbiAgICB9XG4gICAgb25lb2Yub25lb2ZLaW5kID0ga2luZDtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbmVvZltraW5kXSA9IHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRVbmtub3duT25lb2ZWYWx1ZShvbmVvZiwga2luZCwgdmFsdWUpIHtcbiAgICBpZiAob25lb2Yub25lb2ZLaW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIG9uZW9mW29uZW9mLm9uZW9mS2luZF07XG4gICAgfVxuICAgIG9uZW9mLm9uZW9mS2luZCA9IGtpbmQ7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYga2luZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9uZW9mW2tpbmRdID0gdmFsdWU7XG4gICAgfVxufVxuLyoqXG4gKiBSZW1vdmVzIHRoZSBzZWxlY3RlZCBmaWVsZCBpbiBhIG9uZW9mIGdyb3VwLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIG1vZGlmeSBhIG9uZW9mIGdyb3VwIGlzIHRvIHNldFxuICogYSBuZXcgb2JqZWN0OlxuICpcbiAqIGBgYHRzXG4gKiBtZXNzYWdlLnJlc3VsdCA9IHsgb25lb2ZLaW5kOiB1bmRlZmluZWQgfTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJPbmVvZlZhbHVlKG9uZW9mKSB7XG4gICAgaWYgKG9uZW9mLm9uZW9mS2luZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSBvbmVvZltvbmVvZi5vbmVvZktpbmRdO1xuICAgIH1cbiAgICBvbmVvZi5vbmVvZktpbmQgPSB1bmRlZmluZWQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHNlbGVjdGVkIHZhbHVlIG9mIHRoZSBnaXZlbiBvbmVvZiBncm91cC5cbiAqXG4gKiBOb3QgdGhhdCB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIGFjY2VzcyBhIG9uZW9mIGdyb3VwIGlzIHRvIGNoZWNrXG4gKiB0aGUgXCJvbmVvZktpbmRcIiBwcm9wZXJ0eSBhbmQgbGV0IFR5cGVTY3JpcHQgbmFycm93IGRvd24gdGhlIHVuaW9uXG4gKiB0eXBlIGZvciB5b3U6XG4gKlxuICogYGBgdHNcbiAqIGlmIChtZXNzYWdlLnJlc3VsdC5vbmVvZktpbmQgPT09IFwiZXJyb3JcIikge1xuICogICBtZXNzYWdlLnJlc3VsdC5lcnJvcjsgLy8gc3RyaW5nXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBJbiB0aGUgcmFyZSBjYXNlIHlvdSBqdXN0IG5lZWQgdGhlIHZhbHVlLCBhbmQgZG8gbm90IGNhcmUgYWJvdXRcbiAqIHdoaWNoIHByb3RvYnVmIGZpZWxkIGlzIHNlbGVjdGVkLCB5b3UgY2FuIHVzZSB0aGlzIGZ1bmN0aW9uXG4gKiBmb3IgY29udmVuaWVuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RlZE9uZW9mVmFsdWUob25lb2YpIHtcbiAgICBpZiAob25lb2Yub25lb2ZLaW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG9uZW9mW29uZW9mLm9uZW9mS2luZF07XG59XG4iLCJpbXBvcnQgeyBpbnQ2NGZyb21TdHJpbmcsIGludDY0dG9TdHJpbmcgfSBmcm9tIFwiLi9nb29nLXZhcmludFwiO1xubGV0IEJJO1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdEJpKCkge1xuICAgIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcig4KSk7XG4gICAgY29uc3Qgb2sgPSBnbG9iYWxUaGlzLkJpZ0ludCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICYmIHR5cGVvZiBkdi5nZXRCaWdJbnQ2NCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICYmIHR5cGVvZiBkdi5nZXRCaWdVaW50NjQgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAmJiB0eXBlb2YgZHYuc2V0QmlnSW50NjQgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAmJiB0eXBlb2YgZHYuc2V0QmlnVWludDY0ID09PSBcImZ1bmN0aW9uXCI7XG4gICAgQkkgPSBvayA/IHtcbiAgICAgICAgTUlOOiBCaWdJbnQoXCItOTIyMzM3MjAzNjg1NDc3NTgwOFwiKSxcbiAgICAgICAgTUFYOiBCaWdJbnQoXCI5MjIzMzcyMDM2ODU0Nzc1ODA3XCIpLFxuICAgICAgICBVTUlOOiBCaWdJbnQoXCIwXCIpLFxuICAgICAgICBVTUFYOiBCaWdJbnQoXCIxODQ0Njc0NDA3MzcwOTU1MTYxNVwiKSxcbiAgICAgICAgQzogQmlnSW50LFxuICAgICAgICBWOiBkdixcbiAgICB9IDogdW5kZWZpbmVkO1xufVxuZGV0ZWN0QmkoKTtcbmZ1bmN0aW9uIGFzc2VydEJpKGJpKSB7XG4gICAgaWYgKCFiaSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmlnSW50IHVuYXZhaWxhYmxlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RpbW9zdGFtbS9wcm90b2J1Zi10cy9ibG9iL3YxLjAuOC9NQU5VQUwubWQjYmlnaW50LXN1cHBvcnRcIik7XG59XG4vLyB1c2VkIHRvIHZhbGlkYXRlIGZyb20oc3RyaW5nKSBpbnB1dCAod2hlbiBiaWdpbnQgaXMgdW5hdmFpbGFibGUpXG5jb25zdCBSRV9ERUNJTUFMX1NUUiA9IC9eLT9bMC05XSskLztcbi8vIGNvbnN0YW50cyBmb3IgYmluYXJ5IG1hdGhcbmNvbnN0IFRXT19QV1JfMzJfREJMID0gMHgxMDAwMDAwMDA7XG5jb25zdCBIQUxGXzJfUFdSXzMyID0gMHgwODAwMDAwMDA7XG4vLyBiYXNlIGNsYXNzIGZvciBQYkxvbmcgYW5kIFBiVUxvbmcgcHJvdmlkZXMgc2hhcmVkIGNvZGVcbmNsYXNzIFNoYXJlZFBiTG9uZyB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIGJpdHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG8sIGhpKSB7XG4gICAgICAgIHRoaXMubG8gPSBsbyB8IDA7XG4gICAgICAgIHRoaXMuaGkgPSBoaSB8IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgaW5zdGFuY2UgZXF1YWwgdG8gMD9cbiAgICAgKi9cbiAgICBpc1plcm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvID09IDAgJiYgdGhpcy5oaSA9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRvIGEgbmF0aXZlIG51bWJlci5cbiAgICAgKi9cbiAgICB0b051bWJlcigpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuaGkgKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvID4+PiAwKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihyZXN1bHQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNvbnZlcnQgdG8gc2FmZSBudW1iZXJcIik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG4gKiA2NC1iaXQgdW5zaWduZWQgaW50ZWdlciBhcyB0d28gMzItYml0IHZhbHVlcy5cbiAqIENvbnZlcnRzIGJldHdlZW4gYHN0cmluZ2AsIGBudW1iZXJgIGFuZCBgYmlnaW50YCByZXByZXNlbnRhdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYlVMb25nIGV4dGVuZHMgU2hhcmVkUGJMb25nIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgaW5zdGFuY2UgZnJvbSBhIGBzdHJpbmdgLCBgbnVtYmVyYCBvciBgYmlnaW50YC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAoQkkpXG4gICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gRmFsbFRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiMFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuWkVSTztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyBpcyBubyBpbnRlZ2VyJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQkkuQyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5aRVJPO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEJJLkModmFsdWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlpFUk87XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IEJJLlVNSU4pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25lZCB2YWx1ZSBmb3IgdWxvbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gQkkuVU1BWClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndWxvbmcgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICAgICAgICAgIEJJLlYuc2V0QmlnVWludDY0KDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYlVMb25nKEJJLlYuZ2V0SW50MzIoMCwgdHJ1ZSksIEJJLlYuZ2V0SW50MzIoNCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiMFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuWkVSTztcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghUkVfREVDSU1BTF9TVFIudGVzdCh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyBpcyBubyBpbnRlZ2VyJyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBbbWludXMsIGxvLCBoaV0gPSBpbnQ2NGZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWludXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25lZCB2YWx1ZSBmb3IgdWxvbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYlVMb25nKGxvLCBoaSk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlpFUk87XG4gICAgICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgaXMgbm8gaW50ZWdlcicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduZWQgdmFsdWUgZm9yIHVsb25nJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGJVTG9uZyh2YWx1ZSwgdmFsdWUgLyBUV09fUFdSXzMyX0RCTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biB2YWx1ZSAnICsgdHlwZW9mIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0byBkZWNpbWFsIHN0cmluZy5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEJJID8gdGhpcy50b0JpZ0ludCgpLnRvU3RyaW5nKCkgOiBpbnQ2NHRvU3RyaW5nKHRoaXMubG8sIHRoaXMuaGkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRvIG5hdGl2ZSBiaWdpbnQuXG4gICAgICovXG4gICAgdG9CaWdJbnQoKSB7XG4gICAgICAgIGFzc2VydEJpKEJJKTtcbiAgICAgICAgQkkuVi5zZXRJbnQzMigwLCB0aGlzLmxvLCB0cnVlKTtcbiAgICAgICAgQkkuVi5zZXRJbnQzMig0LCB0aGlzLmhpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIEJJLlYuZ2V0QmlnVWludDY0KDAsIHRydWUpO1xuICAgIH1cbn1cbi8qKlxuICogdWxvbmcgMCBzaW5nbGV0b24uXG4gKi9cblBiVUxvbmcuWkVSTyA9IG5ldyBQYlVMb25nKDAsIDApO1xuLyoqXG4gKiA2NC1iaXQgc2lnbmVkIGludGVnZXIgYXMgdHdvIDMyLWJpdCB2YWx1ZXMuXG4gKiBDb252ZXJ0cyBiZXR3ZWVuIGBzdHJpbmdgLCBgbnVtYmVyYCBhbmQgYGJpZ2ludGAgcmVwcmVzZW50YXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgUGJMb25nIGV4dGVuZHMgU2hhcmVkUGJMb25nIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgaW5zdGFuY2UgZnJvbSBhIGBzdHJpbmdgLCBgbnVtYmVyYCBvciBgYmlnaW50YC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAoQkkpXG4gICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gRmFsbFRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiMFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuWkVSTztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyBpcyBubyBpbnRlZ2VyJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQkkuQyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5aRVJPO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEJJLkModmFsdWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlpFUk87XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IEJJLk1JTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbmVkIGxvbmcgdG9vIHNtYWxsJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IEJJLk1BWClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbmVkIGxvbmcgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICAgICAgICAgIEJJLlYuc2V0QmlnSW50NjQoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBiTG9uZyhCSS5WLmdldEludDMyKDAsIHRydWUpLCBCSS5WLmdldEludDMyKDQsIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIjBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlpFUk87XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIVJFX0RFQ0lNQUxfU1RSLnRlc3QodmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgaXMgbm8gaW50ZWdlcicpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgW21pbnVzLCBsbywgaGldID0gaW50NjRmcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbnVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGkgPiBIQUxGXzJfUFdSXzMyIHx8IChoaSA9PSBIQUxGXzJfUFdSXzMyICYmIGxvICE9IDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbmVkIGxvbmcgdG9vIHNtYWxsJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGkgPj0gSEFMRl8yX1BXUl8zMilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbmVkIGxvbmcgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYmwgPSBuZXcgUGJMb25nKGxvLCBoaSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtaW51cyA/IHBibC5uZWdhdGUoKSA6IHBibDtcbiAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuWkVSTztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBpcyBubyBpbnRlZ2VyJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IFBiTG9uZyh2YWx1ZSwgdmFsdWUgLyBUV09fUFdSXzMyX0RCTClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IFBiTG9uZygtdmFsdWUsIC12YWx1ZSAvIFRXT19QV1JfMzJfREJMKS5uZWdhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHZhbHVlICcgKyB0eXBlb2YgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEbyB3ZSBoYXZlIGEgbWludXMgc2lnbj9cbiAgICAgKi9cbiAgICBpc05lZ2F0aXZlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaGkgJiBIQUxGXzJfUFdSXzMyKSAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmVnYXRlIHR3bydzIGNvbXBsZW1lbnQuXG4gICAgICogSW52ZXJ0IGFsbCB0aGUgYml0cyBhbmQgYWRkIG9uZSB0byB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgbGV0IGhpID0gfnRoaXMuaGksIGxvID0gdGhpcy5sbztcbiAgICAgICAgaWYgKGxvKVxuICAgICAgICAgICAgbG8gPSB+bG8gKyAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBoaSArPSAxO1xuICAgICAgICByZXR1cm4gbmV3IFBiTG9uZyhsbywgaGkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRvIGRlY2ltYWwgc3RyaW5nLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAoQkkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0JpZ0ludCgpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgbGV0IG4gPSB0aGlzLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuICctJyArIGludDY0dG9TdHJpbmcobi5sbywgbi5oaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludDY0dG9TdHJpbmcodGhpcy5sbywgdGhpcy5oaSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdG8gbmF0aXZlIGJpZ2ludC5cbiAgICAgKi9cbiAgICB0b0JpZ0ludCgpIHtcbiAgICAgICAgYXNzZXJ0QmkoQkkpO1xuICAgICAgICBCSS5WLnNldEludDMyKDAsIHRoaXMubG8sIHRydWUpO1xuICAgICAgICBCSS5WLnNldEludDMyKDQsIHRoaXMuaGksIHRydWUpO1xuICAgICAgICByZXR1cm4gQkkuVi5nZXRCaWdJbnQ2NCgwLCB0cnVlKTtcbiAgICB9XG59XG4vKipcbiAqIGxvbmcgMCBzaW5nbGV0b24uXG4gKi9cblBiTG9uZy5aRVJPID0gbmV3IFBiTG9uZygwLCAwKTtcbiIsImltcG9ydCB7IFVua25vd25GaWVsZEhhbmRsZXIsIFdpcmVUeXBlIH0gZnJvbSBcIi4vYmluYXJ5LWZvcm1hdC1jb250cmFjdFwiO1xuaW1wb3J0IHsgTG9uZ1R5cGUsIFNjYWxhclR5cGUgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWluZm9cIjtcbmltcG9ydCB7IHJlZmxlY3Rpb25Mb25nQ29udmVydCB9IGZyb20gXCIuL3JlZmxlY3Rpb24tbG9uZy1jb252ZXJ0XCI7XG5pbXBvcnQgeyByZWZsZWN0aW9uU2NhbGFyRGVmYXVsdCB9IGZyb20gXCIuL3JlZmxlY3Rpb24tc2NhbGFyLWRlZmF1bHRcIjtcbi8qKlxuICogUmVhZHMgcHJvdG8zIG1lc3NhZ2VzIGluIGJpbmFyeSBmb3JtYXQgdXNpbmcgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvZW5jb2RpbmdcbiAqL1xuZXhwb3J0IGNsYXNzIFJlZmxlY3Rpb25CaW5hcnlSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKGluZm8pIHtcbiAgICAgICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICB9XG4gICAgcHJlcGFyZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuZmllbGROb1RvRmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkc0lucHV0ID0gKF9hID0gdGhpcy5pbmZvLmZpZWxkcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgICAgICB0aGlzLmZpZWxkTm9Ub0ZpZWxkID0gbmV3IE1hcChmaWVsZHNJbnB1dC5tYXAoZmllbGQgPT4gW2ZpZWxkLm5vLCBmaWVsZF0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIG1lc3NhZ2UgZnJvbSBiaW5hcnkgZm9ybWF0IGludG8gdGhlIHRhcmdldCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogUmVwZWF0ZWQgZmllbGRzIGFyZSBhcHBlbmRlZC4gTWFwIGVudHJpZXMgYXJlIGFkZGVkLCBvdmVyd3JpdGluZ1xuICAgICAqIGV4aXN0aW5nIGtleXMuXG4gICAgICpcbiAgICAgKiBJZiBhIG1lc3NhZ2UgZmllbGQgaXMgYWxyZWFkeSBwcmVzZW50LCBpdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZVxuICAgICAqIG5ldyBkYXRhLlxuICAgICAqL1xuICAgIHJlYWQocmVhZGVyLCBtZXNzYWdlLCBvcHRpb25zLCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlKCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAvLyByZWFkIHRoZSB0YWcgYW5kIGZpbmQgdGhlIGZpZWxkXG4gICAgICAgICAgICBjb25zdCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpLCBmaWVsZCA9IHRoaXMuZmllbGROb1RvRmllbGQuZ2V0KGZpZWxkTm8pO1xuICAgICAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgIGlmICh1ID09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy5pbmZvLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMuaW5mby50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGFyZ2V0IG9iamVjdCBmb3IgdGhlIGZpZWxkIHdlIGFyZSByZWFkaW5nXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gbWVzc2FnZSwgcmVwZWF0ZWQgPSBmaWVsZC5yZXBlYXQsIGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIC8vIGlmIGZpZWxkIGlzIG1lbWJlciBvZiBvbmVvZiBBRFQsIHVzZSBBRFQgYXMgdGFyZ2V0XG4gICAgICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXRbZmllbGQub25lb2ZdO1xuICAgICAgICAgICAgICAgIC8vIGlmIG90aGVyIG9uZW9mIG1lbWJlciBzZWxlY3RlZCwgc2V0IG5ldyBBRFRcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Lm9uZW9mS2luZCAhPT0gbG9jYWxOYW1lKVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBtZXNzYWdlW2ZpZWxkLm9uZW9mXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogbG9jYWxOYW1lXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIGhhbmRsZWQgb25lb2YgYWJvdmUsIHdlIGp1c3QgaGF2ZSByZWFkIHRoZSB2YWx1ZSBpbnRvIGB0YXJnZXRbbG9jYWxOYW1lXWBcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICBsZXQgVCA9IGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgPyBTY2FsYXJUeXBlLklOVDMyIDogZmllbGQuVDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IEwgPSBmaWVsZC5raW5kID09IFwic2NhbGFyXCIgPyBmaWVsZC5MIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhcnIgPSB0YXJnZXRbbG9jYWxOYW1lXTsgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgYXJyYXksIG9uZW9mIGNhbm5vdCBjb250YWluIHJlcGVhdGVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09IFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCAmJiBUICE9IFNjYWxhclR5cGUuU1RSSU5HICYmIFQgIT0gU2NhbGFyVHlwZS5CWVRFUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKHRoaXMuc2NhbGFyKHJlYWRlciwgVCwgTCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKHRoaXMuc2NhbGFyKHJlYWRlciwgVCwgTCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gdGhpcy5zY2FsYXIocmVhZGVyLCBULCBMKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXJyID0gdGFyZ2V0W2xvY2FsTmFtZV07IC8vIHNhZmUgdG8gYXNzdW1lIHByZXNlbmNlIG9mIGFycmF5LCBvbmVvZiBjYW5ub3QgY29udGFpbiByZXBlYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtc2cgPSBmaWVsZC5UKCkuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBmaWVsZC5UKCkuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCB0YXJnZXRbbG9jYWxOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgICAgICAgbGV0IFttYXBLZXksIG1hcFZhbF0gPSB0aGlzLm1hcEVudHJ5KGZpZWxkLCByZWFkZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBtYXAgb2JqZWN0LCBvbmVvZiBjYW5ub3QgY29udGFpbiByZXBlYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV1bbWFwS2V5XSA9IG1hcFZhbDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIG1hcCBmaWVsZCwgZXhwZWN0aW5nIGtleSBmaWVsZCA9IDEsIHZhbHVlIGZpZWxkID0gMlxuICAgICAqL1xuICAgIG1hcEVudHJ5KGZpZWxkLCByZWFkZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgbGV0IGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGxldCBrZXkgPSB1bmRlZmluZWQ7IC8vIGphdmFzY3JpcHQgb25seSBhbGxvd3MgbnVtYmVyIG9yIHN0cmluZyBmb3Igb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgICAgbGV0IHZhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuSyA9PSBTY2FsYXJUeXBlLkJPT0wpXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSByZWFkZXIuYm9vbCgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvbmcgdHlwZXMgYXJlIHJlYWQgYXMgc3RyaW5nLCBudW1iZXIgdHlwZXMgYXJlIG9rYXkgYXMgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnNjYWxhcihyZWFkZXIsIGZpZWxkLkssIExvbmdUeXBlLlNUUklORyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLnNjYWxhcihyZWFkZXIsIGZpZWxkLlYuVCwgZmllbGQuVi5MKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGZpZWxkLlYuVCgpLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgaW4gbWFwIGVudHJ5IGZvciAke3RoaXMuaW5mby50eXBlTmFtZX0jJHtmaWVsZC5uYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGtleVJhdyA9IHJlZmxlY3Rpb25TY2FsYXJEZWZhdWx0KGZpZWxkLkspO1xuICAgICAgICAgICAga2V5ID0gZmllbGQuSyA9PSBTY2FsYXJUeXBlLkJPT0wgPyBrZXlSYXcudG9TdHJpbmcoKSA6IGtleVJhdztcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gcmVmbGVjdGlvblNjYWxhckRlZmF1bHQoZmllbGQuVi5ULCBmaWVsZC5WLkwpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBmaWVsZC5WLlQoKS5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBba2V5LCB2YWxdO1xuICAgIH1cbiAgICBzY2FsYXIocmVhZGVyLCB0eXBlLCBsb25nVHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLmZsb2F0KCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3Rpb25Mb25nQ29udmVydChyZWFkZXIuaW50NjQoKSwgbG9uZ1R5cGUpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmbGVjdGlvbkxvbmdDb252ZXJ0KHJlYWRlci51aW50NjQoKSwgbG9uZ1R5cGUpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3Rpb25Mb25nQ29udmVydChyZWFkZXIuZml4ZWQ2NCgpLCBsb25nVHlwZSk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLmZpeGVkMzIoKTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5zZml4ZWQzMigpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICAgICAgICAgIHJldHVybiByZWZsZWN0aW9uTG9uZ0NvbnZlcnQocmVhZGVyLnNmaXhlZDY0KCksIGxvbmdUeXBlKTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5zaW50MzIoKTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3Rpb25Mb25nQ29udmVydChyZWFkZXIuc2ludDY0KCksIGxvbmdUeXBlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IFVua25vd25GaWVsZEhhbmRsZXIsIFdpcmVUeXBlIH0gZnJvbSBcIi4vYmluYXJ5LWZvcm1hdC1jb250cmFjdFwiO1xuaW1wb3J0IHsgUmVwZWF0VHlwZSwgU2NhbGFyVHlwZSB9IGZyb20gXCIuL3JlZmxlY3Rpb24taW5mb1wiO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4vYXNzZXJ0XCI7XG5pbXBvcnQgeyBQYkxvbmcsIFBiVUxvbmcgfSBmcm9tIFwiLi9wYi1sb25nXCI7XG4vKipcbiAqIFdyaXRlcyBwcm90bzMgbWVzc2FnZXMgaW4gYmluYXJ5IGZvcm1hdCB1c2luZyByZWZsZWN0aW9uIGluZm9ybWF0aW9uLlxuICpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9lbmNvZGluZ1xuICovXG5leHBvcnQgY2xhc3MgUmVmbGVjdGlvbkJpbmFyeVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IoaW5mbykge1xuICAgICAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgIH1cbiAgICBwcmVwYXJlKCkge1xuICAgICAgICBpZiAoIXRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZHNJbnB1dCA9IHRoaXMuaW5mby5maWVsZHMgPyB0aGlzLmluZm8uZmllbGRzLmNvbmNhdCgpIDogW107XG4gICAgICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkc0lucHV0LnNvcnQoKGEsIGIpID0+IGEubm8gLSBiLm5vKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgdGhlIG1lc3NhZ2UgdG8gYmluYXJ5IGZvcm1hdC5cbiAgICAgKi9cbiAgICB3cml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlKCk7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSwgLy8gdGhpcyB3aWxsIGJlIG91ciBmaWVsZCB2YWx1ZSwgd2hldGhlciBpdCBpcyBtZW1iZXIgb2YgYSBvbmVvZiBvciBub3RcbiAgICAgICAgICAgIGVtaXREZWZhdWx0LCAvLyB3aGV0aGVyIHdlIGVtaXQgdGhlIGRlZmF1bHQgdmFsdWUgKG9ubHkgdHJ1ZSBmb3Igb25lb2YgbWVtYmVycylcbiAgICAgICAgICAgIHJlcGVhdGVkID0gZmllbGQucmVwZWF0LCBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gICAgICAgICAgICAvLyBoYW5kbGUgb25lb2YgQURUXG4gICAgICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBncm91cCA9IG1lc3NhZ2VbZmllbGQub25lb2ZdO1xuICAgICAgICAgICAgICAgIGlmIChncm91cC5vbmVvZktpbmQgIT09IGxvY2FsTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIGlmIGZpZWxkIGlzIG5vdCBzZWxlY3RlZCwgc2tpcFxuICAgICAgICAgICAgICAgIHZhbHVlID0gZ3JvdXBbbG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICBlbWl0RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1lc3NhZ2VbbG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICBlbWl0RGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UgaGF2ZSBoYW5kbGVkIG9uZW9mIGFib3ZlLiB3ZSBqdXN0IGhhdmUgdG8gaG9ub3IgYGVtaXREZWZhdWx0YC5cbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICBsZXQgVCA9IGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgPyBTY2FsYXJUeXBlLklOVDMyIDogZmllbGQuVDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGVhdGVkID09IFJlcGVhdFR5cGUuUEFDS0VEKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFja2VkKHdyaXRlciwgVCwgZmllbGQubm8sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NhbGFyKHdyaXRlciwgVCwgZmllbGQubm8sIGl0ZW0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZmllbGQub3B0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FsYXIod3JpdGVyLCBULCBmaWVsZC5ubywgdmFsdWUsIGVtaXREZWZhdWx0IHx8IGZpZWxkLm9wdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2Uod3JpdGVyLCBvcHRpb25zLCBmaWVsZC5UKCksIGZpZWxkLm5vLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLlQoKSwgZmllbGQubm8sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBFbnRyeSh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCBrZXksIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy5pbmZvLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgIH1cbiAgICBtYXBFbnRyeSh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHdyaXRlci50YWcoZmllbGQubm8sIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCk7XG4gICAgICAgIHdyaXRlci5mb3JrKCk7XG4gICAgICAgIC8vIGphdmFzY3JpcHQgb25seSBhbGxvd3MgbnVtYmVyIG9yIHN0cmluZyBmb3Igb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgICAgLy8gd2UgY29udmVydCBmcm9tIG91ciByZXByZXNlbnRhdGlvbiB0byB0aGUgcHJvdG9idWYgdHlwZVxuICAgICAgICBsZXQga2V5VmFsdWUgPSBrZXk7XG4gICAgICAgIHN3aXRjaCAoZmllbGQuSykge1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICAgICAgICAgICAgICBrZXlWYWx1ZSA9IE51bWJlci5wYXJzZUludChrZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGtleSA9PSAndHJ1ZScgfHwga2V5ID09ICdmYWxzZScpO1xuICAgICAgICAgICAgICAgIGtleVZhbHVlID0ga2V5ID09ICd0cnVlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyB3cml0ZSBrZXksIGV4cGVjdGluZyBrZXkgZmllbGQgbnVtYmVyID0gMVxuICAgICAgICB0aGlzLnNjYWxhcih3cml0ZXIsIGZpZWxkLkssIDEsIGtleVZhbHVlLCB0cnVlKTtcbiAgICAgICAgLy8gd3JpdGUgdmFsdWUsIGV4cGVjdGluZyB2YWx1ZSBmaWVsZCBudW1iZXIgPSAyXG4gICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGFyKHdyaXRlciwgZmllbGQuVi5ULCAyLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlbnVtJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxhcih3cml0ZXIsIFNjYWxhclR5cGUuSU5UMzIsIDIsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLlYuVCgpLCAyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLmpvaW4oKTtcbiAgICB9XG4gICAgbWVzc2FnZSh3cml0ZXIsIG9wdGlvbnMsIGhhbmRsZXIsIGZpZWxkTm8sIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBoYW5kbGVyLmludGVybmFsQmluYXJ5V3JpdGUodmFsdWUsIHdyaXRlci50YWcoZmllbGRObywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpO1xuICAgICAgICB3cml0ZXIuam9pbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIHNpbmdsZSBzY2FsYXIgdmFsdWUuXG4gICAgICovXG4gICAgc2NhbGFyKHdyaXRlciwgdHlwZSwgZmllbGRObywgdmFsdWUsIGVtaXREZWZhdWx0KSB7XG4gICAgICAgIGxldCBbd2lyZVR5cGUsIG1ldGhvZCwgaXNEZWZhdWx0XSA9IHRoaXMuc2NhbGFySW5mbyh0eXBlLCB2YWx1ZSk7XG4gICAgICAgIGlmICghaXNEZWZhdWx0IHx8IGVtaXREZWZhdWx0KSB7XG4gICAgICAgICAgICB3cml0ZXIudGFnKGZpZWxkTm8sIHdpcmVUeXBlKTtcbiAgICAgICAgICAgIHdyaXRlclttZXRob2RdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhbiBhcnJheSBvZiBzY2FsYXIgdmFsdWVzIGluIHBhY2tlZCBmb3JtYXQuXG4gICAgICovXG4gICAgcGFja2VkKHdyaXRlciwgdHlwZSwgZmllbGRObywgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGFzc2VydCh0eXBlICE9PSBTY2FsYXJUeXBlLkJZVEVTICYmIHR5cGUgIT09IFNjYWxhclR5cGUuU1RSSU5HKTtcbiAgICAgICAgLy8gd3JpdGUgdGFnXG4gICAgICAgIHdyaXRlci50YWcoZmllbGRObywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKTtcbiAgICAgICAgLy8gYmVnaW4gbGVuZ3RoLWRlbGltaXRlZFxuICAgICAgICB3cml0ZXIuZm9yaygpO1xuICAgICAgICAvLyB3cml0ZSB2YWx1ZXMgd2l0aG91dCB0YWdzXG4gICAgICAgIGxldCBbLCBtZXRob2QsXSA9IHRoaXMuc2NhbGFySW5mbyh0eXBlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlclttZXRob2RdKHZhbHVlW2ldKTtcbiAgICAgICAgLy8gZW5kIGxlbmd0aCBkZWxpbWl0ZWRcbiAgICAgICAgd3JpdGVyLmpvaW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGluZm9ybWF0aW9uIGZvciB3cml0aW5nIGEgc2NhbGFyIHZhbHVlLlxuICAgICAqXG4gICAgICogUmV0dXJucyB0dXBsZTpcbiAgICAgKiBbMF06IGFwcHJvcHJpYXRlIFdpcmVUeXBlXG4gICAgICogWzFdOiBuYW1lIG9mIHRoZSBhcHByb3ByaWF0ZSBtZXRob2Qgb2YgSUJpbmFyeVdyaXRlclxuICAgICAqIFsyXTogd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBkZWZhdWx0IHZhbHVlXG4gICAgICpcbiAgICAgKiBJZiBhcmd1bWVudCBgdmFsdWVgIGlzIG9taXR0ZWQsIFsyXSBpcyBhbHdheXMgZmFsc2UuXG4gICAgICovXG4gICAgc2NhbGFySW5mbyh0eXBlLCB2YWx1ZSkge1xuICAgICAgICBsZXQgdCA9IFdpcmVUeXBlLlZhcmludDtcbiAgICAgICAgbGV0IG07XG4gICAgICAgIGxldCBpID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGQgPSB2YWx1ZSA9PT0gMDtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICAgICAgICAgICAgbSA9IFwiaW50MzJcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICAgICAgICAgICAgZCA9IGkgfHwgIXZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0ID0gV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkO1xuICAgICAgICAgICAgICAgIG0gPSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICAgICAgZCA9IHZhbHVlID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgICBtID0gXCJib29sXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgICAgICAgICAgIG0gPSBcInVpbnQzMlwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgICAgICAgICAgICB0ID0gV2lyZVR5cGUuQml0NjQ7XG4gICAgICAgICAgICAgICAgbSA9IFwiZG91YmxlXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICAgICAgdCA9IFdpcmVUeXBlLkJpdDMyO1xuICAgICAgICAgICAgICAgIG0gPSBcImZsb2F0XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICAgICAgICAgICAgZCA9IGkgfHwgUGJMb25nLmZyb20odmFsdWUpLmlzWmVybygpO1xuICAgICAgICAgICAgICAgIG0gPSBcImludDY0XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgICAgICAgICAgICAgIGQgPSBpIHx8IFBiVUxvbmcuZnJvbSh2YWx1ZSkuaXNaZXJvKCk7XG4gICAgICAgICAgICAgICAgbSA9IFwidWludDY0XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgICAgICAgICBkID0gaSB8fCBQYlVMb25nLmZyb20odmFsdWUpLmlzWmVybygpO1xuICAgICAgICAgICAgICAgIHQgPSBXaXJlVHlwZS5CaXQ2NDtcbiAgICAgICAgICAgICAgICBtID0gXCJmaXhlZDY0XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICAgICAgZCA9IGkgfHwgIXZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgdCA9IFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDtcbiAgICAgICAgICAgICAgICBtID0gXCJieXRlc1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICAgICAgICAgICAgdCA9IFdpcmVUeXBlLkJpdDMyO1xuICAgICAgICAgICAgICAgIG0gPSBcImZpeGVkMzJcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICAgICAgICAgICAgICB0ID0gV2lyZVR5cGUuQml0MzI7XG4gICAgICAgICAgICAgICAgbSA9IFwic2ZpeGVkMzJcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgICAgICAgICAgICBkID0gaSB8fCBQYkxvbmcuZnJvbSh2YWx1ZSkuaXNaZXJvKCk7XG4gICAgICAgICAgICAgICAgdCA9IFdpcmVUeXBlLkJpdDY0O1xuICAgICAgICAgICAgICAgIG0gPSBcInNmaXhlZDY0XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAgICAgICAgICAgIG0gPSBcInNpbnQzMlwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgICAgICAgICAgICBkID0gaSB8fCBQYkxvbmcuZnJvbSh2YWx1ZSkuaXNaZXJvKCk7XG4gICAgICAgICAgICAgICAgbSA9IFwic2ludDY0XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0LCBtLCBpIHx8IGRdO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IHJlZmxlY3Rpb25TY2FsYXJEZWZhdWx0IH0gZnJvbSBcIi4vcmVmbGVjdGlvbi1zY2FsYXItZGVmYXVsdFwiO1xuaW1wb3J0IHsgTUVTU0FHRV9UWVBFIH0gZnJvbSAnLi9tZXNzYWdlLXR5cGUtY29udHJhY3QnO1xuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSBnZW5lcmljIG1lc3NhZ2UsIHVzaW5nIHRoZSBmaWVsZFxuICogaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWZsZWN0aW9uQ3JlYXRlKHR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIHRlcm5hcnkgY2FuIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICAgKiBUaGUgYE9iamVjdC5jcmVhdGUoKWAgY29kZSBwYXRoIHV0aWxpemVzIGEgbmV3IGBtZXNzYWdlUHJvdG90eXBlYFxuICAgICAqIHByb3BlcnR5IG9uIHRoZSBgSU1lc3NhZ2VUeXBlYCB3aGljaCBoYXMgdGhpcyBzYW1lIGBNRVNTQUdFX1RZUEVgXG4gICAgICogbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gaXQuIERvaW5nIGl0IHRoaXMgd2F5IG1lYW5zIHRoYXQgd2Ugb25seVxuICAgICAqIHBheSB0aGUgY29zdCBvZiBgT2JqZWN0LmRlZmluZVByb3BlcnR5KClgIG9uY2UgcGVyIGBJTWVzc2FnZVR5cGVgXG4gICAgICogY2xhc3Mgb2Ygb25jZSBwZXIgXCJpbnN0YW5jZVwiLiBUaGUgZmFsc3kgY29kZSBwYXRoIGlzIG9ubHkgcHJvdmlkZWRcbiAgICAgKiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgaW4gY2FzZXMgd2hlcmUgdGhlIHJ1bnRpbWUgbGlicmFyeSBpc1xuICAgICAqIHVwZGF0ZWQgd2l0aG91dCBhbHNvIHVwZGF0aW5nIHRoZSBnZW5lcmF0ZWQgY29kZS5cbiAgICAgKi9cbiAgICBjb25zdCBtc2cgPSB0eXBlLm1lc3NhZ2VQcm90b3R5cGVcbiAgICAgICAgPyBPYmplY3QuY3JlYXRlKHR5cGUubWVzc2FnZVByb3RvdHlwZSlcbiAgICAgICAgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIE1FU1NBR0VfVFlQRSwgeyB2YWx1ZTogdHlwZSB9KTtcbiAgICBmb3IgKGxldCBmaWVsZCBvZiB0eXBlLmZpZWxkcykge1xuICAgICAgICBsZXQgbmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgICAgICAgaWYgKGZpZWxkLm9wdClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoZmllbGQub25lb2YpXG4gICAgICAgICAgICBtc2dbZmllbGQub25lb2ZdID0geyBvbmVvZktpbmQ6IHVuZGVmaW5lZCB9O1xuICAgICAgICBlbHNlIGlmIChmaWVsZC5yZXBlYXQpXG4gICAgICAgICAgICBtc2dbbmFtZV0gPSBbXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICBtc2dbbmFtZV0gPSByZWZsZWN0aW9uU2NhbGFyRGVmYXVsdChmaWVsZC5ULCBmaWVsZC5MKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgcmVxdWlyZSAwIHRvIGJlIGRlZmF1bHQgdmFsdWUgZm9yIGFsbCBlbnVtc1xuICAgICAgICAgICAgICAgICAgICBtc2dbbmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgICAgIG1zZ1tuYW1lXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1zZztcbn1cbiIsImltcG9ydCB7IFNjYWxhclR5cGUgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWluZm9cIjtcbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byBtZXNzYWdlIG9mIHRoZSBzYW1lIHR5cGUgaGF2ZSB0aGUgc2FtZSBmaWVsZCB2YWx1ZXMuXG4gKiBDaGVja3MgZm9yIGRlZXAgZXF1YWxpdHksIHRyYXZlcnNpbmcgcmVwZWF0ZWQgZmllbGRzLCBvbmVvZiBncm91cHMsIG1hcHNcbiAqIGFuZCBtZXNzYWdlcyByZWN1cnNpdmVseS5cbiAqIFdpbGwgYWxzbyByZXR1cm4gdHJ1ZSBpZiBib3RoIG1lc3NhZ2VzIGFyZSBgdW5kZWZpbmVkYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZmxlY3Rpb25FcXVhbHMoaW5mbywgYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIWEgfHwgIWIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBmaWVsZCBvZiBpbmZvLmZpZWxkcykge1xuICAgICAgICBsZXQgbG9jYWxOYW1lID0gZmllbGQubG9jYWxOYW1lO1xuICAgICAgICBsZXQgdmFsX2EgPSBmaWVsZC5vbmVvZiA/IGFbZmllbGQub25lb2ZdW2xvY2FsTmFtZV0gOiBhW2xvY2FsTmFtZV07XG4gICAgICAgIGxldCB2YWxfYiA9IGZpZWxkLm9uZW9mID8gYltmaWVsZC5vbmVvZl1bbG9jYWxOYW1lXSA6IGJbbG9jYWxOYW1lXTtcbiAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgIGxldCB0ID0gZmllbGQua2luZCA9PSBcImVudW1cIiA/IFNjYWxhclR5cGUuSU5UMzIgOiBmaWVsZC5UO1xuICAgICAgICAgICAgICAgIGlmICghKGZpZWxkLnJlcGVhdFxuICAgICAgICAgICAgICAgICAgICA/IHJlcGVhdGVkUHJpbWl0aXZlRXEodCwgdmFsX2EsIHZhbF9iKVxuICAgICAgICAgICAgICAgICAgICA6IHByaW1pdGl2ZUVxKHQsIHZhbF9hLCB2YWxfYikpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgaWYgKCEoZmllbGQuVi5raW5kID09IFwibWVzc2FnZVwiXG4gICAgICAgICAgICAgICAgICAgID8gcmVwZWF0ZWRNc2dFcShmaWVsZC5WLlQoKSwgb2JqZWN0VmFsdWVzKHZhbF9hKSwgb2JqZWN0VmFsdWVzKHZhbF9iKSlcbiAgICAgICAgICAgICAgICAgICAgOiByZXBlYXRlZFByaW1pdGl2ZUVxKGZpZWxkLlYua2luZCA9PSBcImVudW1cIiA/IFNjYWxhclR5cGUuSU5UMzIgOiBmaWVsZC5WLlQsIG9iamVjdFZhbHVlcyh2YWxfYSksIG9iamVjdFZhbHVlcyh2YWxfYikpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICBsZXQgVCA9IGZpZWxkLlQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIShmaWVsZC5yZXBlYXRcbiAgICAgICAgICAgICAgICAgICAgPyByZXBlYXRlZE1zZ0VxKFQsIHZhbF9hLCB2YWxfYilcbiAgICAgICAgICAgICAgICAgICAgOiBULmVxdWFscyh2YWxfYSwgdmFsX2IpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3Qgb2JqZWN0VmFsdWVzID0gT2JqZWN0LnZhbHVlcztcbmZ1bmN0aW9uIHByaW1pdGl2ZUVxKHR5cGUsIGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGUgIT09IFNjYWxhclR5cGUuQllURVMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYmEgPSBhO1xuICAgIGxldCBiYiA9IGI7XG4gICAgaWYgKGJhLmxlbmd0aCAhPT0gYmIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGJhW2ldICE9IGJiW2ldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVwZWF0ZWRQcmltaXRpdmVFcSh0eXBlLCBhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFwcmltaXRpdmVFcSh0eXBlLCBhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlcGVhdGVkTXNnRXEodHlwZSwgYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghdHlwZS5lcXVhbHMoYVtpXSwgYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4iLCJpbXBvcnQgeyBsb3dlckNhbWVsQ2FzZSB9IGZyb20gXCIuL2xvd2VyLWNhbWVsLWNhc2VcIjtcbi8qKlxuICogU2NhbGFyIHZhbHVlIHR5cGVzLiBUaGlzIGlzIGEgc3Vic2V0IG9mIGZpZWxkIHR5cGVzIGRlY2xhcmVkIGJ5IHByb3RvYnVmXG4gKiBlbnVtIGdvb2dsZS5wcm90b2J1Zi5GaWVsZERlc2NyaXB0b3JQcm90by5UeXBlIFRoZSB0eXBlcyBHUk9VUCBhbmQgTUVTU0FHRVxuICogYXJlIG9taXR0ZWQsIGJ1dCB0aGUgbnVtZXJpY2FsIHZhbHVlcyBhcmUgaWRlbnRpY2FsLlxuICovXG5leHBvcnQgdmFyIFNjYWxhclR5cGU7XG4oZnVuY3Rpb24gKFNjYWxhclR5cGUpIHtcbiAgICAvLyAwIGlzIHJlc2VydmVkIGZvciBlcnJvcnMuXG4gICAgLy8gT3JkZXIgaXMgd2VpcmQgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJET1VCTEVcIl0gPSAxXSA9IFwiRE9VQkxFXCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRkxPQVRcIl0gPSAyXSA9IFwiRkxPQVRcIjtcbiAgICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UNjQgaWZcbiAgICAvLyBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJJTlQ2NFwiXSA9IDNdID0gXCJJTlQ2NFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQ2NFwiXSA9IDRdID0gXCJVSU5UNjRcIjtcbiAgICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UMzIgaWZcbiAgICAvLyBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJJTlQzMlwiXSA9IDVdID0gXCJJTlQzMlwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZJWEVENjRcIl0gPSA2XSA9IFwiRklYRUQ2NFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZJWEVEMzJcIl0gPSA3XSA9IFwiRklYRUQzMlwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkJPT0xcIl0gPSA4XSA9IFwiQk9PTFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNUUklOR1wiXSA9IDldID0gXCJTVFJJTkdcIjtcbiAgICAvLyBUYWctZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cbiAgICAvLyBHcm91cCB0eXBlIGlzIGRlcHJlY2F0ZWQgYW5kIG5vdCBzdXBwb3J0ZWQgaW4gcHJvdG8zLiBIb3dldmVyLCBQcm90bzNcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHN0aWxsIGJlIGFibGUgdG8gcGFyc2UgdGhlIGdyb3VwIHdpcmUgZm9ybWF0IGFuZFxuICAgIC8vIHRyZWF0IGdyb3VwIGZpZWxkcyBhcyB1bmtub3duIGZpZWxkcy5cbiAgICAvLyBUWVBFX0dST1VQID0gMTAsXG4gICAgLy8gVFlQRV9NRVNTQUdFID0gMTEsICAvLyBMZW5ndGgtZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cbiAgICAvLyBOZXcgaW4gdmVyc2lvbiAyLlxuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkJZVEVTXCJdID0gMTJdID0gXCJCWVRFU1wiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQzMlwiXSA9IDEzXSA9IFwiVUlOVDMyXCI7XG4gICAgLy8gVFlQRV9FTlVNID0gMTQsXG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVEMzJcIl0gPSAxNV0gPSBcIlNGSVhFRDMyXCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVENjRcIl0gPSAxNl0gPSBcIlNGSVhFRDY0XCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0lOVDMyXCJdID0gMTddID0gXCJTSU5UMzJcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTSU5UNjRcIl0gPSAxOF0gPSBcIlNJTlQ2NFwiO1xufSkoU2NhbGFyVHlwZSB8fCAoU2NhbGFyVHlwZSA9IHt9KSk7XG4vKipcbiAqIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgNjQgYml0IGludGVncmFsIHR5cGVzLiBFcXVpdmFsZW50IHRvIHRoZVxuICogZmllbGQgb3B0aW9uIFwianN0eXBlXCIuXG4gKlxuICogQnkgZGVmYXVsdCwgcHJvdG9idWYtdHMgcmVwcmVzZW50cyA2NCBiaXQgdHlwZXMgYXMgYGJpZ2ludGAuXG4gKlxuICogWW91IGNhbiBjaGFuZ2UgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIGJ5IGVuYWJsaW5nIHRoZSBwbHVnaW4gcGFyYW1ldGVyXG4gKiBgbG9uZ190eXBlX3N0cmluZ2AsIHdoaWNoIHdpbGwgcmVwcmVzZW50IDY0IGJpdCB0eXBlcyBhcyBgc3RyaW5nYC5cbiAqXG4gKiBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIGNoYW5nZSB0aGUgYmVoYXZpb3VyIGZvciBpbmRpdmlkdWFsIGZpZWxkc1xuICogd2l0aCB0aGUgZmllbGQgb3B0aW9uIFwianN0eXBlXCI6XG4gKlxuICogYGBgcHJvdG9idWZcbiAqIHVpbnQ2NCBteV9maWVsZCA9IDEgW2pzdHlwZSA9IEpTX1NUUklOR107XG4gKiB1aW50NjQgb3RoZXJfZmllbGQgPSAyIFtqc3R5cGUgPSBKU19OVU1CRVJdO1xuICogYGBgXG4gKi9cbmV4cG9ydCB2YXIgTG9uZ1R5cGU7XG4oZnVuY3Rpb24gKExvbmdUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVXNlIEphdmFTY3JpcHQgYGJpZ2ludGAuXG4gICAgICpcbiAgICAgKiBGaWVsZCBvcHRpb24gYFtqc3R5cGUgPSBKU19OT1JNQUxdYC5cbiAgICAgKi9cbiAgICBMb25nVHlwZVtMb25nVHlwZVtcIkJJR0lOVFwiXSA9IDBdID0gXCJCSUdJTlRcIjtcbiAgICAvKipcbiAgICAgKiBVc2UgSmF2YVNjcmlwdCBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEZpZWxkIG9wdGlvbiBgW2pzdHlwZSA9IEpTX1NUUklOR11gLlxuICAgICAqL1xuICAgIExvbmdUeXBlW0xvbmdUeXBlW1wiU1RSSU5HXCJdID0gMV0gPSBcIlNUUklOR1wiO1xuICAgIC8qKlxuICAgICAqIFVzZSBKYXZhU2NyaXB0IGBudW1iZXJgLlxuICAgICAqXG4gICAgICogTGFyZ2UgdmFsdWVzIHdpbGwgbG9vc2UgcHJlY2lzaW9uLlxuICAgICAqXG4gICAgICogRmllbGQgb3B0aW9uIGBbanN0eXBlID0gSlNfTlVNQkVSXWAuXG4gICAgICovXG4gICAgTG9uZ1R5cGVbTG9uZ1R5cGVbXCJOVU1CRVJcIl0gPSAyXSA9IFwiTlVNQkVSXCI7XG59KShMb25nVHlwZSB8fCAoTG9uZ1R5cGUgPSB7fSkpO1xuLyoqXG4gKiBQcm90b2J1ZiAyLjEuMCBpbnRyb2R1Y2VkIHBhY2tlZCByZXBlYXRlZCBmaWVsZHMuXG4gKiBTZXR0aW5nIHRoZSBmaWVsZCBvcHRpb24gYFtwYWNrZWQgPSB0cnVlXWAgZW5hYmxlcyBwYWNraW5nLlxuICpcbiAqIEluIHByb3RvMywgYWxsIHJlcGVhdGVkIGZpZWxkcyBhcmUgcGFja2VkIGJ5IGRlZmF1bHQuXG4gKiBTZXR0aW5nIHRoZSBmaWVsZCBvcHRpb24gYFtwYWNrZWQgPSBmYWxzZV1gIGRpc2FibGVzIHBhY2tpbmcuXG4gKlxuICogUGFja2VkIHJlcGVhdGVkIGZpZWxkcyBhcmUgZW5jb2RlZCB3aXRoIGEgc2luZ2xlIHRhZyxcbiAqIHRoZW4gYSBsZW5ndGgtZGVsaW1pdGVyLCB0aGVuIHRoZSBlbGVtZW50IHZhbHVlcy5cbiAqXG4gKiBVbnBhY2tlZCByZXBlYXRlZCBmaWVsZHMgYXJlIGVuY29kZWQgd2l0aCBhIHRhZyBhbmRcbiAqIHZhbHVlIGZvciBlYWNoIGVsZW1lbnQuXG4gKlxuICogYGJ5dGVzYCBhbmQgYHN0cmluZ2AgY2Fubm90IGJlIHBhY2tlZC5cbiAqL1xuZXhwb3J0IHZhciBSZXBlYXRUeXBlO1xuKGZ1bmN0aW9uIChSZXBlYXRUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGZpZWxkIGlzIG5vdCByZXBlYXRlZC5cbiAgICAgKi9cbiAgICBSZXBlYXRUeXBlW1JlcGVhdFR5cGVbXCJOT1wiXSA9IDBdID0gXCJOT1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCBpcyByZXBlYXRlZCBhbmQgc2hvdWxkIGJlIHBhY2tlZC5cbiAgICAgKiBJbnZhbGlkIGZvciBgYnl0ZXNgIGFuZCBgc3RyaW5nYCwgdGhleSBjYW5ub3QgYmUgcGFja2VkLlxuICAgICAqL1xuICAgIFJlcGVhdFR5cGVbUmVwZWF0VHlwZVtcIlBBQ0tFRFwiXSA9IDFdID0gXCJQQUNLRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZmllbGQgaXMgcmVwZWF0ZWQgYnV0IHNob3VsZCBub3QgYmUgcGFja2VkLlxuICAgICAqIFRoZSBvbmx5IHZhbGlkIHJlcGVhdCB0eXBlIGZvciByZXBlYXRlZCBgYnl0ZXNgIGFuZCBgc3RyaW5nYC5cbiAgICAgKi9cbiAgICBSZXBlYXRUeXBlW1JlcGVhdFR5cGVbXCJVTlBBQ0tFRFwiXSA9IDJdID0gXCJVTlBBQ0tFRFwiO1xufSkoUmVwZWF0VHlwZSB8fCAoUmVwZWF0VHlwZSA9IHt9KSk7XG4vKipcbiAqIFR1cm5zIFBhcnRpYWxGaWVsZEluZm8gaW50byBGaWVsZEluZm8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVGaWVsZEluZm8oZmllbGQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgZmllbGQubG9jYWxOYW1lID0gKF9hID0gZmllbGQubG9jYWxOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBsb3dlckNhbWVsQ2FzZShmaWVsZC5uYW1lKTtcbiAgICBmaWVsZC5qc29uTmFtZSA9IChfYiA9IGZpZWxkLmpzb25OYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBsb3dlckNhbWVsQ2FzZShmaWVsZC5uYW1lKTtcbiAgICBmaWVsZC5yZXBlYXQgPSAoX2MgPSBmaWVsZC5yZXBlYXQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFJlcGVhdFR5cGUuTk87XG4gICAgZmllbGQub3B0ID0gKF9kID0gZmllbGQub3B0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAoZmllbGQucmVwZWF0ID8gZmFsc2UgOiBmaWVsZC5vbmVvZiA/IGZhbHNlIDogZmllbGQua2luZCA9PSBcIm1lc3NhZ2VcIik7XG4gICAgcmV0dXJuIGZpZWxkO1xufVxuLyoqXG4gKiBSZWFkIGN1c3RvbSBmaWVsZCBvcHRpb25zIGZyb20gYSBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlLlxuICpcbiAqIEBkZXByZWNhdGVkIHVzZSByZWFkRmllbGRPcHRpb24oKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZEZpZWxkT3B0aW9ucyhtZXNzYWdlVHlwZSwgZmllbGROYW1lLCBleHRlbnNpb25OYW1lLCBleHRlbnNpb25UeXBlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG9wdGlvbnMgPSAoX2EgPSBtZXNzYWdlVHlwZS5maWVsZHMuZmluZCgobSwgaSkgPT4gbS5sb2NhbE5hbWUgPT0gZmllbGROYW1lIHx8IGkgPT0gZmllbGROYW1lKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGlvbnM7XG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9uc1tleHRlbnNpb25OYW1lXSA/IGV4dGVuc2lvblR5cGUuZnJvbUpzb24ob3B0aW9uc1tleHRlbnNpb25OYW1lXSkgOiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZEZpZWxkT3B0aW9uKG1lc3NhZ2VUeXBlLCBmaWVsZE5hbWUsIGV4dGVuc2lvbk5hbWUsIGV4dGVuc2lvblR5cGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgb3B0aW9ucyA9IChfYSA9IG1lc3NhZ2VUeXBlLmZpZWxkcy5maW5kKChtLCBpKSA9PiBtLmxvY2FsTmFtZSA9PSBmaWVsZE5hbWUgfHwgaSA9PSBmaWVsZE5hbWUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW9ucztcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9uVmFsID0gb3B0aW9uc1tleHRlbnNpb25OYW1lXTtcbiAgICBpZiAob3B0aW9uVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvblZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuc2lvblR5cGUgPyBleHRlbnNpb25UeXBlLmZyb21Kc29uKG9wdGlvblZhbCkgOiBvcHRpb25WYWw7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZE1lc3NhZ2VPcHRpb24obWVzc2FnZVR5cGUsIGV4dGVuc2lvbk5hbWUsIGV4dGVuc2lvblR5cGUpIHtcbiAgICBjb25zdCBvcHRpb25zID0gbWVzc2FnZVR5cGUub3B0aW9ucztcbiAgICBjb25zdCBvcHRpb25WYWwgPSBvcHRpb25zW2V4dGVuc2lvbk5hbWVdO1xuICAgIGlmIChvcHRpb25WYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gb3B0aW9uVmFsO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5zaW9uVHlwZSA/IGV4dGVuc2lvblR5cGUuZnJvbUpzb24ob3B0aW9uVmFsKSA6IG9wdGlvblZhbDtcbn1cbiIsImltcG9ydCB7IGlzSnNvbk9iamVjdCwgdHlwZW9mSnNvblZhbHVlIH0gZnJvbSBcIi4vanNvbi10eXBpbmdzXCI7XG5pbXBvcnQgeyBiYXNlNjRkZWNvZGUgfSBmcm9tIFwiLi9iYXNlNjRcIjtcbmltcG9ydCB7IExvbmdUeXBlLCBTY2FsYXJUeXBlIH0gZnJvbSBcIi4vcmVmbGVjdGlvbi1pbmZvXCI7XG5pbXBvcnQgeyBQYkxvbmcsIFBiVUxvbmcgfSBmcm9tIFwiLi9wYi1sb25nXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEZsb2F0MzIsIGFzc2VydEludDMyLCBhc3NlcnRVSW50MzIgfSBmcm9tIFwiLi9hc3NlcnRcIjtcbmltcG9ydCB7IHJlZmxlY3Rpb25Mb25nQ29udmVydCB9IGZyb20gXCIuL3JlZmxlY3Rpb24tbG9uZy1jb252ZXJ0XCI7XG4vKipcbiAqIFJlYWRzIHByb3RvMyBtZXNzYWdlcyBpbiBjYW5vbmljYWwgSlNPTiBmb3JtYXQgdXNpbmcgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvcHJvdG8zI2pzb25cbiAqL1xuZXhwb3J0IGNsYXNzIFJlZmxlY3Rpb25Kc29uUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpbmZvKSB7XG4gICAgICAgIHRoaXMuaW5mbyA9IGluZm87XG4gICAgfVxuICAgIHByZXBhcmUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuZk1hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZNYXAgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkc0lucHV0ID0gKF9hID0gdGhpcy5pbmZvLmZpZWxkcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkc0lucHV0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mTWFwW2ZpZWxkLm5hbWVdID0gZmllbGQ7XG4gICAgICAgICAgICAgICAgdGhpcy5mTWFwW2ZpZWxkLmpzb25OYW1lXSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgIHRoaXMuZk1hcFtmaWVsZC5sb2NhbE5hbWVdID0gZmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2Fubm90IHBhcnNlIEpTT04gPHR5cGUgb2YganNvblZhbHVlPiBmb3IgPHR5cGUgbmFtZT4jPGZpZWxkTmFtZT4uXG4gICAgYXNzZXJ0KGNvbmRpdGlvbiwgZmllbGROYW1lLCBqc29uVmFsdWUpIHtcbiAgICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIGxldCB3aGF0ID0gdHlwZW9mSnNvblZhbHVlKGpzb25WYWx1ZSk7XG4gICAgICAgICAgICBpZiAod2hhdCA9PSBcIm51bWJlclwiIHx8IHdoYXQgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICAgICAgd2hhdCA9IGpzb25WYWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgSlNPTiAke3doYXR9IGZvciAke3RoaXMuaW5mby50eXBlTmFtZX0jJHtmaWVsZE5hbWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBtZXNzYWdlIGZyb20gY2Fub25pY2FsIEpTT04gZm9ybWF0IGludG8gdGhlIHRhcmdldCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogUmVwZWF0ZWQgZmllbGRzIGFyZSBhcHBlbmRlZC4gTWFwIGVudHJpZXMgYXJlIGFkZGVkLCBvdmVyd3JpdGluZ1xuICAgICAqIGV4aXN0aW5nIGtleXMuXG4gICAgICpcbiAgICAgKiBJZiBhIG1lc3NhZ2UgZmllbGQgaXMgYWxyZWFkeSBwcmVzZW50LCBpdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZVxuICAgICAqIG5ldyBkYXRhLlxuICAgICAqL1xuICAgIHJlYWQoaW5wdXQsIG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlKCk7XG4gICAgICAgIGNvbnN0IG9uZW9mc0hhbmRsZWQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbanNvbktleSwganNvblZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5mTWFwW2pzb25LZXldO1xuICAgICAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIHVua25vd24gZmllbGQgd2hpbGUgcmVhZGluZyAke3RoaXMuaW5mby50eXBlTmFtZX0gZnJvbSBKU09OIGZvcm1hdC4gSlNPTiBrZXk6ICR7anNvbktleX1gKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBvbmVvZiBBRFRcbiAgICAgICAgICAgIGxldCB0YXJnZXQ7IC8vIHRoaXMgd2lsbCBiZSB0aGUgdGFyZ2V0IGZvciB0aGUgZmllbGQgdmFsdWUsIHdoZXRoZXIgaXQgaXMgbWVtYmVyIG9mIGEgb25lb2Ygb3Igbm90XG4gICAgICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsICYmIChmaWVsZC5raW5kICE9PSAnZW51bScgfHwgZmllbGQuVCgpWzBdICE9PSAnZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBqc29uIG9iamVjdHMgYXJlIHVub3JkZXJlZCBieSBzcGVjaWZpY2F0aW9uLCBpdCBpcyBub3QgcG9zc2libGUgdG8gdGFrZSB0aGUgbGFzdCBvZiBtdWx0aXBsZSBvbmVvZnNcbiAgICAgICAgICAgICAgICBpZiAob25lb2ZzSGFuZGxlZC5pbmNsdWRlcyhmaWVsZC5vbmVvZikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwbGUgbWVtYmVycyBvZiB0aGUgb25lb2YgZ3JvdXAgXCIke2ZpZWxkLm9uZW9mfVwiIG9mICR7dGhpcy5pbmZvLnR5cGVOYW1lfSBhcmUgcHJlc2VudCBpbiBKU09OLmApO1xuICAgICAgICAgICAgICAgIG9uZW9mc0hhbmRsZWQucHVzaChmaWVsZC5vbmVvZik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gbWVzc2FnZVtmaWVsZC5vbmVvZl0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogbG9jYWxOYW1lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIGhhbmRsZWQgb25lb2YgYWJvdmUuIHdlIGp1c3QgaGF2ZSByZWFkIHRoZSB2YWx1ZSBpbnRvIGB0YXJnZXRgLlxuICAgICAgICAgICAgaWYgKGZpZWxkLmtpbmQgPT0gJ21hcCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpbnB1dFxuICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0KGlzSnNvbk9iamVjdChqc29uVmFsdWUpLCBmaWVsZC5uYW1lLCBqc29uVmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIG91ciB0YXJnZXQgdG8gcHV0IG1hcCBlbnRyaWVzIGludG9cbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZE9iaiA9IHRhcmdldFtsb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgIC8vIHJlYWQgZW50cmllc1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2pzb25PYmpLZXksIGpzb25PYmpWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoanNvblZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFzc2VydChqc29uT2JqVmFsdWUgIT09IG51bGwsIGZpZWxkLm5hbWUgKyBcIiBtYXAgdmFsdWVcIiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gZmllbGQuVi5UKCkuaW50ZXJuYWxKc29uUmVhZChqc29uT2JqVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLmVudW0oZmllbGQuVi5UKCksIGpzb25PYmpWYWx1ZSwgZmllbGQubmFtZSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5zY2FsYXIoanNvbk9ialZhbHVlLCBmaWVsZC5WLlQsIGZpZWxkLlYuTCwgZmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc3NlcnQodmFsICE9PSB1bmRlZmluZWQsIGZpZWxkLm5hbWUgKyBcIiBtYXAgdmFsdWVcIiwganNvbk9ialZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZCBrZXlcbiAgICAgICAgICAgICAgICAgICAgbGV0IGtleSA9IGpzb25PYmpLZXk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5LID09IFNjYWxhclR5cGUuQk9PTClcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGtleSA9PSBcInRydWVcIiA/IHRydWUgOiBrZXkgPT0gXCJmYWxzZVwiID8gZmFsc2UgOiBrZXk7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMuc2NhbGFyKGtleSwgZmllbGQuSywgTG9uZ1R5cGUuU1RSSU5HLCBmaWVsZC5uYW1lKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZE9ialtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLnJlcGVhdCkge1xuICAgICAgICAgICAgICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlucHV0XG4gICAgICAgICAgICAgICAgdGhpcy5hc3NlcnQoQXJyYXkuaXNBcnJheShqc29uVmFsdWUpLCBmaWVsZC5uYW1lLCBqc29uVmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIG91ciB0YXJnZXQgdG8gcHV0IGFycmF5IGVudHJpZXMgaW50b1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkQXJyID0gdGFyZ2V0W2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgLy8gcmVhZCBhcnJheSBlbnRyaWVzXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBqc29uSXRlbSBvZiBqc29uVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc3NlcnQoanNvbkl0ZW0gIT09IG51bGwsIGZpZWxkLm5hbWUsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gZmllbGQuVCgpLmludGVybmFsSnNvblJlYWQoanNvbkl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLmVudW0oZmllbGQuVCgpLCBqc29uSXRlbSwgZmllbGQubmFtZSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5zY2FsYXIoanNvbkl0ZW0sIGZpZWxkLlQsIGZpZWxkLkwsIGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0KHZhbCAhPT0gdW5kZWZpbmVkLCBmaWVsZC5uYW1lLCBqc29uVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEFyci5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsICYmIGZpZWxkLlQoKS50eXBlTmFtZSAhPSAnZ29vZ2xlLnByb3RvYnVmLlZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0KGZpZWxkLm9uZW9mID09PSB1bmRlZmluZWQsIGZpZWxkLm5hbWUgKyBcIiAob25lb2YgbWVtYmVyKVwiLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gZmllbGQuVCgpLmludGVybmFsSnNvblJlYWQoanNvblZhbHVlLCBvcHRpb25zLCB0YXJnZXRbbG9jYWxOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gdGhpcy5lbnVtKGZpZWxkLlQoKSwganNvblZhbHVlLCBmaWVsZC5uYW1lLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSB0aGlzLnNjYWxhcihqc29uVmFsdWUsIGZpZWxkLlQsIGZpZWxkLkwsIGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYGZhbHNlYCBmb3IgdW5yZWNvZ25pemVkIHN0cmluZyByZXByZXNlbnRhdGlvbnMuXG4gICAgICpcbiAgICAgKiBnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlIGFjY2VwdHMgb25seSBKU09OIGBudWxsYCAob3IgdGhlIG9sZCBgXCJOVUxMX1ZBTFVFXCJgKS5cbiAgICAgKi9cbiAgICBlbnVtKHR5cGUsIGpzb24sIGZpZWxkTmFtZSwgaWdub3JlVW5rbm93bkZpZWxkcykge1xuICAgICAgICBpZiAodHlwZVswXSA9PSAnZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZScpXG4gICAgICAgICAgICBhc3NlcnQoanNvbiA9PT0gbnVsbCB8fCBqc29uID09PSBcIk5VTExfVkFMVUVcIiwgYFVuYWJsZSB0byBwYXJzZSBmaWVsZCAke3RoaXMuaW5mby50eXBlTmFtZX0jJHtmaWVsZE5hbWV9LCBlbnVtICR7dHlwZVswXX0gb25seSBhY2NlcHRzIG51bGwuYCk7XG4gICAgICAgIGlmIChqc29uID09PSBudWxsKVxuICAgICAgICAgICAgLy8gd2UgcmVxdWlyZSAwIHRvIGJlIGRlZmF1bHQgdmFsdWUgZm9yIGFsbCBlbnVtc1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIGpzb24pIHtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBhc3NlcnQoTnVtYmVyLmlzSW50ZWdlcihqc29uKSwgYFVuYWJsZSB0byBwYXJzZSBmaWVsZCAke3RoaXMuaW5mby50eXBlTmFtZX0jJHtmaWVsZE5hbWV9LCBlbnVtIGNhbiBvbmx5IGJlIGludGVncmFsIG51bWJlciwgZ290ICR7anNvbn0uYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgbGV0IGxvY2FsRW51bU5hbWUgPSBqc29uO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlWzJdICYmIGpzb24uc3Vic3RyaW5nKDAsIHR5cGVbMl0ubGVuZ3RoKSA9PT0gdHlwZVsyXSlcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9va3VwIHdpdGhvdXQgdGhlIHNoYXJlZCBwcmVmaXhcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxFbnVtTmFtZSA9IGpzb24uc3Vic3RyaW5nKHR5cGVbMl0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsZXQgZW51bU51bWJlciA9IHR5cGVbMV1bbG9jYWxFbnVtTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnVtTnVtYmVyID09PSAndW5kZWZpbmVkJyAmJiBpZ25vcmVVbmtub3duRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiBlbnVtTnVtYmVyID09IFwibnVtYmVyXCIsIGBVbmFibGUgdG8gcGFyc2UgZmllbGQgJHt0aGlzLmluZm8udHlwZU5hbWV9IyR7ZmllbGROYW1lfSwgZW51bSAke3R5cGVbMF19IGhhcyBubyB2YWx1ZSBmb3IgXCIke2pzb259XCIuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudW1OdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgVW5hYmxlIHRvIHBhcnNlIGZpZWxkICR7dGhpcy5pbmZvLnR5cGVOYW1lfSMke2ZpZWxkTmFtZX0sIGNhbm5vdCBwYXJzZSBlbnVtIHZhbHVlIGZyb20gJHt0eXBlb2YganNvbn1cIi5gKTtcbiAgICB9XG4gICAgc2NhbGFyKGpzb24sIHR5cGUsIGxvbmdUeXBlLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgbGV0IGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBmbG9hdCwgZG91YmxlOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBzcGVjaWFsIHN0cmluZyB2YWx1ZXMgXCJOYU5cIiwgXCJJbmZpbml0eVwiLCBhbmQgXCItSW5maW5pdHlcIi5cbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC4gRXhwb25lbnQgbm90YXRpb24gaXMgYWxzbyBhY2NlcHRlZC5cbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgICAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLjA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uID09PSBcIk5hTlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5OYU47XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uID09PSBcIkluZmluaXR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbiA9PT0gXCItSW5maW5pdHlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gXCJlbXB0eSBzdHJpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcInN0cmluZ1wiICYmIGpzb24udHJpbSgpLmxlbmd0aCAhPT0ganNvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBcImV4dHJhIHdoaXRlc3BhY2VcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBmbG9hdCA9IE51bWJlcihqc29uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTihmbG9hdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBcIm5vdCBhIG51bWJlclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZmxvYXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmZpbml0eSBhbmQgLWluZmluaXR5IGFyZSBoYW5kbGVkIGJ5IHN0cmluZyByZXByZXNlbnRhdGlvbiBhYm92ZSwgc28gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IFwidG9vIGxhcmdlIG9yIHNtYWxsXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBTY2FsYXJUeXBlLkZMT0FUKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0RmxvYXQzMihmbG9hdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbG9hdDtcbiAgICAgICAgICAgICAgICAvLyBpbnQzMiwgZml4ZWQzMiwgdWludDMyOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIG51bWJlci4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgICAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnQzMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnQzMiA9IGpzb247XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGpzb24gPT09IFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gXCJlbXB0eSBzdHJpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGpzb24gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24udHJpbSgpLmxlbmd0aCAhPT0ganNvbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IFwiZXh0cmEgd2hpdGVzcGFjZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludDMyID0gTnVtYmVyKGpzb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnQzMiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IFNjYWxhclR5cGUuVUlOVDMyKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0VUludDMyKGludDMyKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0SW50MzIoaW50MzIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50MzI7XG4gICAgICAgICAgICAgICAgLy8gaW50NjQsIGZpeGVkNjQsIHVpbnQ2NDogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBzdHJpbmcuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgICAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVmbGVjdGlvbkxvbmdDb252ZXJ0KFBiTG9uZy5aRVJPLCBsb25nVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcIm51bWJlclwiICYmIHR5cGVvZiBqc29uICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3Rpb25Mb25nQ29udmVydChQYkxvbmcuZnJvbShqc29uKSwgbG9uZ1R5cGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3Rpb25Mb25nQ29udmVydChQYlVMb25nLlpFUk8sIGxvbmdUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIgJiYgdHlwZW9mIGpzb24gIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVmbGVjdGlvbkxvbmdDb252ZXJ0KFBiVUxvbmcuZnJvbShqc29uKSwgbG9uZ1R5cGUpO1xuICAgICAgICAgICAgICAgIC8vIGJvb2w6XG4gICAgICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICAgICAgICAgIC8vIHN0cmluZzpcbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBcImV4dHJhIHdoaXRlc3BhY2VcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoanNvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBcImludmFsaWQgVVRGOFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgICAgICAgICAgLy8gYnl0ZXM6IEpTT04gdmFsdWUgd2lsbCBiZSB0aGUgZGF0YSBlbmNvZGVkIGFzIGEgc3RyaW5nIHVzaW5nIHN0YW5kYXJkIGJhc2U2NCBlbmNvZGluZyB3aXRoIHBhZGRpbmdzLlxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciBzdGFuZGFyZCBvciBVUkwtc2FmZSBiYXNlNjQgZW5jb2Rpbmcgd2l0aC93aXRob3V0IHBhZGRpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uID09PSBudWxsIHx8IGpzb24gPT09IFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U2NGRlY29kZShqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGUgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXNzZXJ0KGZhbHNlLCBmaWVsZE5hbWUgKyAoZSA/IFwiIC0gXCIgKyBlIDogXCJcIiksIGpzb24pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGJhc2U2NGVuY29kZSB9IGZyb20gXCIuL2Jhc2U2NFwiO1xuaW1wb3J0IHsgUGJMb25nLCBQYlVMb25nIH0gZnJvbSBcIi4vcGItbG9uZ1wiO1xuaW1wb3J0IHsgU2NhbGFyVHlwZSB9IGZyb20gXCIuL3JlZmxlY3Rpb24taW5mb1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRGbG9hdDMyLCBhc3NlcnRJbnQzMiwgYXNzZXJ0VUludDMyIH0gZnJvbSBcIi4vYXNzZXJ0XCI7XG4vKipcbiAqIFdyaXRlcyBwcm90bzMgbWVzc2FnZXMgaW4gY2Fub25pY2FsIEpTT04gZm9ybWF0IHVzaW5nIHJlZmxlY3Rpb25cbiAqIGluZm9ybWF0aW9uLlxuICpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9wcm90bzMjanNvblxuICovXG5leHBvcnQgY2xhc3MgUmVmbGVjdGlvbkpzb25Xcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGluZm8pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IChfYSA9IGluZm8uZmllbGRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIG1lc3NhZ2UgdG8gYSBKU09OIG9iamVjdCwgYmFzZWQgb24gdGhlIGZpZWxkIGRlc2NyaXB0b3JzLlxuICAgICAqL1xuICAgIHdyaXRlKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QganNvbiA9IHt9LCBzb3VyY2UgPSBtZXNzYWdlO1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICAvLyBmaWVsZCBpcyBub3QgcGFydCBvZiBhIG9uZW9mLCBzaW1wbHkgd3JpdGUgYXMgaXNcbiAgICAgICAgICAgIGlmICghZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgICAgICBsZXQganNvblZhbHVlID0gdGhpcy5maWVsZChmaWVsZCwgc291cmNlW2ZpZWxkLmxvY2FsTmFtZV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChqc29uVmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAganNvbltvcHRpb25zLnVzZVByb3RvRmllbGROYW1lID8gZmllbGQubmFtZSA6IGZpZWxkLmpzb25OYW1lXSA9IGpzb25WYWx1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZpZWxkIGlzIHBhcnQgb2YgYSBvbmVvZlxuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBzb3VyY2VbZmllbGQub25lb2ZdO1xuICAgICAgICAgICAgaWYgKGdyb3VwLm9uZW9mS2luZCAhPT0gZmllbGQubG9jYWxOYW1lKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBub3Qgc2VsZWN0ZWQsIHNraXBcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGZpZWxkLmtpbmQgPT0gJ3NjYWxhcicgfHwgZmllbGQua2luZCA9PSAnZW51bSdcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZW1pdERlZmF1bHRWYWx1ZXM6IHRydWUgfSkgOiBvcHRpb25zO1xuICAgICAgICAgICAgbGV0IGpzb25WYWx1ZSA9IHRoaXMuZmllbGQoZmllbGQsIGdyb3VwW2ZpZWxkLmxvY2FsTmFtZV0sIG9wdCk7XG4gICAgICAgICAgICBhc3NlcnQoanNvblZhbHVlICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAganNvbltvcHRpb25zLnVzZVByb3RvRmllbGROYW1lID8gZmllbGQubmFtZSA6IGZpZWxkLmpzb25OYW1lXSA9IGpzb25WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgZmllbGQoZmllbGQsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBqc29uVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChmaWVsZC5raW5kID09ICdtYXAnKSB7XG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpO1xuICAgICAgICAgICAgY29uc3QganNvbk9iaiA9IHt9O1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuc2NhbGFyKGZpZWxkLlYuVCwgZW50cnlWYWx1ZSwgZmllbGQubmFtZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25PYmpbZW50cnlLZXkudG9TdHJpbmcoKV0gPSB2YWw7IC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IGZpZWxkLlYuVCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeUtleSwgZW50cnlWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzLm1lc3NhZ2UobWVzc2FnZVR5cGUsIGVudHJ5VmFsdWUsIGZpZWxkLm5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25PYmpbZW50cnlLZXkudG9TdHJpbmcoKV0gPSB2YWw7IC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnVtSW5mbyA9IGZpZWxkLlYuVCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeUtleSwgZW50cnlWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZW50cnlWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBlbnRyeVZhbHVlID09ICdudW1iZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuZW51bShlbnVtSW5mbywgZW50cnlWYWx1ZSwgZmllbGQubmFtZSwgZmFsc2UsIHRydWUsIG9wdGlvbnMuZW51bUFzSW50ZWdlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQodmFsICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IHZhbDsgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMgfHwgT2JqZWN0LmtleXMoanNvbk9iaikubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICBqc29uVmFsdWUgPSBqc29uT2JqO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpZWxkLnJlcGVhdCkge1xuICAgICAgICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkodmFsdWUpKTtcbiAgICAgICAgICAgIGNvbnN0IGpzb25BcnIgPSBbXTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpcy5zY2FsYXIoZmllbGQuVCwgdmFsdWVbaV0sIGZpZWxkLm5hbWUsIGZpZWxkLm9wdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQodmFsICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbkFyci5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW51bUluZm8gPSBmaWVsZC5UKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCh2YWx1ZVtpXSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWx1ZVtpXSA9PSAnbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzLmVudW0oZW51bUluZm8sIHZhbHVlW2ldLCBmaWVsZC5uYW1lLCBmaWVsZC5vcHQsIHRydWUsIG9wdGlvbnMuZW51bUFzSW50ZWdlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQodmFsICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbkFyci5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBmaWVsZC5UKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRoaXMubWVzc2FnZShtZXNzYWdlVHlwZSwgdmFsdWVbaV0sIGZpZWxkLm5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25BcnIucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIGNvbnZlcnRlZCBhcnJheSB0byBqc29uIG91dHB1dFxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMgfHwganNvbkFyci5sZW5ndGggPiAwIHx8IG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMpXG4gICAgICAgICAgICAgICAganNvblZhbHVlID0ganNvbkFycjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAganNvblZhbHVlID0gdGhpcy5zY2FsYXIoZmllbGQuVCwgdmFsdWUsIGZpZWxkLm5hbWUsIGZpZWxkLm9wdCwgb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgIGpzb25WYWx1ZSA9IHRoaXMuZW51bShmaWVsZC5UKCksIHZhbHVlLCBmaWVsZC5uYW1lLCBmaWVsZC5vcHQsIG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMsIG9wdGlvbnMuZW51bUFzSW50ZWdlcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgIGpzb25WYWx1ZSA9IHRoaXMubWVzc2FnZShmaWVsZC5UKCksIHZhbHVlLCBmaWVsZC5uYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb25WYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgbnVsbGAgYXMgdGhlIGRlZmF1bHQgZm9yIGdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWUuXG4gICAgICovXG4gICAgZW51bSh0eXBlLCB2YWx1ZSwgZmllbGROYW1lLCBvcHRpb25hbCwgZW1pdERlZmF1bHRWYWx1ZXMsIGVudW1Bc0ludGVnZXIpIHtcbiAgICAgICAgaWYgKHR5cGVbMF0gPT0gJ2dvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWUnKVxuICAgICAgICAgICAgcmV0dXJuICFlbWl0RGVmYXVsdFZhbHVlcyAmJiAhb3B0aW9uYWwgPyB1bmRlZmluZWQgOiBudWxsO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0KG9wdGlvbmFsKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSAwICYmICFlbWl0RGVmYXVsdFZhbHVlcyAmJiAhb3B0aW9uYWwpXG4gICAgICAgICAgICAvLyB3ZSByZXF1aXJlIDAgdG8gYmUgZGVmYXVsdCB2YWx1ZSBmb3IgYWxsIGVudW1zXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09ICdudW1iZXInKTtcbiAgICAgICAgYXNzZXJ0KE51bWJlci5pc0ludGVnZXIodmFsdWUpKTtcbiAgICAgICAgaWYgKGVudW1Bc0ludGVnZXIgfHwgIXR5cGVbMV0uaGFzT3duUHJvcGVydHkodmFsdWUpKVxuICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3Qgbm93IHRoZSBlbnVtIHZhbHVlLCBqdXN0IHJldHVybiB0aGUgbnVtYmVyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGlmICh0eXBlWzJdKVxuICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUgZHJvcHBlZCBwcmVmaXhcbiAgICAgICAgICAgIHJldHVybiB0eXBlWzJdICsgdHlwZVsxXVt2YWx1ZV07XG4gICAgICAgIHJldHVybiB0eXBlWzFdW3ZhbHVlXTtcbiAgICB9XG4gICAgbWVzc2FnZSh0eXBlLCB2YWx1ZSwgZmllbGROYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMgPyBudWxsIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdHlwZS5pbnRlcm5hbEpzb25Xcml0ZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHNjYWxhcih0eXBlLCB2YWx1ZSwgZmllbGROYW1lLCBvcHRpb25hbCwgZW1pdERlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydChvcHRpb25hbCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVkID0gZW1pdERlZmF1bHRWYWx1ZXMgfHwgb3B0aW9uYWw7XG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBGYWxsVGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAvLyBpbnQzMiwgZml4ZWQzMiwgdWludDMyOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIG51bWJlci4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVkID8gMCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBhc3NlcnRJbnQzMih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVkID8gMCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBhc3NlcnRVSW50MzIodmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIC8vIGZsb2F0LCBkb3VibGU6IEpTT04gdmFsdWUgd2lsbCBiZSBhIG51bWJlciBvciBvbmUgb2YgdGhlIHNwZWNpYWwgc3RyaW5nIHZhbHVlcyBcIk5hTlwiLCBcIkluZmluaXR5XCIsIGFuZCBcIi1JbmZpbml0eVwiLlxuICAgICAgICAgICAgLy8gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuIEV4cG9uZW50IG5vdGF0aW9uIGlzIGFsc28gYWNjZXB0ZWQuXG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICAgICAgYXNzZXJ0RmxvYXQzMih2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVkID8gMCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09ICdudW1iZXInKTtcbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdOYU4nO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ0luZmluaXR5JztcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICctSW5maW5pdHknO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIC8vIHN0cmluZzpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWQgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAvLyBib29sOlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVkID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSAnYm9vbGVhbicpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIC8vIEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgc3RyaW5nLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT0gJ2JpZ2ludCcpO1xuICAgICAgICAgICAgICAgIGxldCB1bG9uZyA9IFBiVUxvbmcuZnJvbSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHVsb25nLmlzWmVybygpICYmICFlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdWxvbmcudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIC8vIEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgc3RyaW5nLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09ICdiaWdpbnQnKTtcbiAgICAgICAgICAgICAgICBsZXQgbG9uZyA9IFBiTG9uZy5mcm9tKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAobG9uZy5pc1plcm8oKSAmJiAhZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvbmcudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIC8vIGJ5dGVzOiBKU09OIHZhbHVlIHdpbGwgYmUgdGhlIGRhdGEgZW5jb2RlZCBhcyBhIHN0cmluZyB1c2luZyBzdGFuZGFyZCBiYXNlNjQgZW5jb2Rpbmcgd2l0aCBwYWRkaW5ncy5cbiAgICAgICAgICAgIC8vIEVpdGhlciBzdGFuZGFyZCBvciBVUkwtc2FmZSBiYXNlNjQgZW5jb2Rpbmcgd2l0aC93aXRob3V0IHBhZGRpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgICAgICAgICAgICBhc3NlcnQodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlZCA/IFwiXCIgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U2NGVuY29kZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBMb25nVHlwZSB9IGZyb20gXCIuL3JlZmxlY3Rpb24taW5mb1wiO1xuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IGEgUGJMb25nIG9yIFBiVWxvbmcgdG8gYSBKYXZhU2NyaXB0XG4gKiByZXByZXNlbnRhdGlvbiBkdXJpbmcgcnVudGltZS5cbiAqXG4gKiBXb3JrcyB3aXRoIGdlbmVyYXRlZCBmaWVsZCBpbmZvcm1hdGlvbiwgYHVuZGVmaW5lZGAgaXMgZXF1aXZhbGVudFxuICogdG8gYFNUUklOR2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWZsZWN0aW9uTG9uZ0NvbnZlcnQobG9uZywgdHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIExvbmdUeXBlLkJJR0lOVDpcbiAgICAgICAgICAgIHJldHVybiBsb25nLnRvQmlnSW50KCk7XG4gICAgICAgIGNhc2UgTG9uZ1R5cGUuTlVNQkVSOlxuICAgICAgICAgICAgcmV0dXJuIGxvbmcudG9OdW1iZXIoKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgLy8gY2FzZSBMb25nVHlwZS5TVFJJTkc6XG4gICAgICAgICAgICByZXR1cm4gbG9uZy50b1N0cmluZygpO1xuICAgIH1cbn1cbiIsIi8qKlxuICogQ29weSBwYXJ0aWFsIGRhdGEgaW50byB0aGUgdGFyZ2V0IG1lc3NhZ2UuXG4gKlxuICogSWYgYSBzaW5ndWxhciBzY2FsYXIgb3IgZW51bSBmaWVsZCBpcyBwcmVzZW50IGluIHRoZSBzb3VyY2UsIGl0XG4gKiByZXBsYWNlcyB0aGUgZmllbGQgaW4gdGhlIHRhcmdldC5cbiAqXG4gKiBJZiBhIHNpbmd1bGFyIG1lc3NhZ2UgZmllbGQgaXMgcHJlc2VudCBpbiB0aGUgc291cmNlLCBpdCBpcyBtZXJnZWRcbiAqIHdpdGggdGhlIHRhcmdldCBmaWVsZCBieSBjYWxsaW5nIG1lcmdlUGFydGlhbCgpIG9mIHRoZSByZXNwb25zaWJsZVxuICogbWVzc2FnZSB0eXBlLlxuICpcbiAqIElmIGEgcmVwZWF0ZWQgZmllbGQgaXMgcHJlc2VudCBpbiB0aGUgc291cmNlLCBpdHMgdmFsdWVzIHJlcGxhY2VcbiAqIGFsbCB2YWx1ZXMgaW4gdGhlIHRhcmdldCBhcnJheSwgcmVtb3ZpbmcgZXh0cmFuZW91cyB2YWx1ZXMuXG4gKiBSZXBlYXRlZCBtZXNzYWdlIGZpZWxkcyBhcmUgY29waWVkLCBub3QgbWVyZ2VkLlxuICpcbiAqIElmIGEgbWFwIGZpZWxkIGlzIHByZXNlbnQgaW4gdGhlIHNvdXJjZSwgZW50cmllcyBhcmUgYWRkZWQgdG8gdGhlXG4gKiB0YXJnZXQgbWFwLCByZXBsYWNpbmcgZW50cmllcyB3aXRoIHRoZSBzYW1lIGtleS4gRW50cmllcyB0aGF0IG9ubHlcbiAqIGV4aXN0IGluIHRoZSB0YXJnZXQgcmVtYWluLiBFbnRyaWVzIHdpdGggbWVzc2FnZSB2YWx1ZXMgYXJlIGNvcGllZCxcbiAqIG5vdCBtZXJnZWQuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gZGlmZmVycyBmcm9tIHByb3RvYnVmIG1lcmdlIHNlbWFudGljcyxcbiAqIHdoaWNoIGFwcGVuZHMgcmVwZWF0ZWQgZmllbGRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVmbGVjdGlvbk1lcmdlUGFydGlhbChpbmZvLCB0YXJnZXQsIHNvdXJjZSkge1xuICAgIGxldCBmaWVsZFZhbHVlLCAvLyB0aGUgZmllbGQgdmFsdWUgd2UgYXJlIHdvcmtpbmcgd2l0aFxuICAgIGlucHV0ID0gc291cmNlLCBvdXRwdXQ7IC8vIHdoZXJlIHdlIHdhbnQgb3VyIGZpZWxkIHZhbHVlIHRvIGdvXG4gICAgZm9yIChsZXQgZmllbGQgb2YgaW5mby5maWVsZHMpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gICAgICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBpbnB1dFtmaWVsZC5vbmVvZl07IC8vIHRoaXMgaXMgdGhlIG9uZW9mYHMgZ3JvdXAgaW4gdGhlIHNvdXJjZVxuICAgICAgICAgICAgaWYgKChncm91cCA9PT0gbnVsbCB8fCBncm91cCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JvdXAub25lb2ZLaW5kKSA9PSB1bmRlZmluZWQpIHsgLy8gdGhlIHVzZXIgaXMgZnJlZSB0byBvbWl0XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIHdlIHNraXAgdGhpcyBmaWVsZCwgYW5kIGFsbCBvdGhlciBtZW1iZXJzIHRvb1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IGdyb3VwW25hbWVdOyAvLyBvdXIgdmFsdWUgY29tZXMgZnJvbSB0aGUgdGhlIG9uZW9mIGdyb3VwIG9mIHRoZSBzb3VyY2VcbiAgICAgICAgICAgIG91dHB1dCA9IHRhcmdldFtmaWVsZC5vbmVvZl07IC8vIGFuZCBvdXIgb3V0cHV0IGlzIHRoZSBvbmVvZiBncm91cCBvZiB0aGUgdGFyZ2V0XG4gICAgICAgICAgICBvdXRwdXQub25lb2ZLaW5kID0gZ3JvdXAub25lb2ZLaW5kOyAvLyBhbHdheXMgdXBkYXRlIGRpc2NyaW1pbmF0b3JcbiAgICAgICAgICAgIGlmIChmaWVsZFZhbHVlID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvdXRwdXRbbmFtZV07IC8vIHJlbW92ZSBhbnkgZXhpc3RpbmcgdmFsdWVcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCBmdXJ0aGVyIHdvcmsgb24gZmllbGRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBpbnB1dFtuYW1lXTsgLy8gd2UgYXJlIHVzaW5nIHRoZSBzb3VyY2UgZGlyZWN0bHlcbiAgICAgICAgICAgIG91dHB1dCA9IHRhcmdldDsgLy8gd2Ugd2FudCBvdXIgZmllbGQgdmFsdWUgdG8gZ28gZGlyZWN0bHkgaW50byB0aGUgdGFyZ2V0XG4gICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCBmdXJ0aGVyIHdvcmsgb24gZmllbGQsIGV4aXN0aW5nIHZhbHVlIGlzIHVzZWQgYXMgaXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGQucmVwZWF0KVxuICAgICAgICAgICAgb3V0cHV0W25hbWVdLmxlbmd0aCA9IGZpZWxkVmFsdWUubGVuZ3RoOyAvLyByZXNpemUgdGFyZ2V0IGFycmF5IHRvIG1hdGNoIHNvdXJjZSBhcnJheVxuICAgICAgICAvLyBub3cgd2UganVzdCB3b3JrIHdpdGggYGZpZWxkVmFsdWVgIGFuZCBgb3V0cHV0YCB0byBtZXJnZSB0aGUgdmFsdWVcbiAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5yZXBlYXQpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRWYWx1ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtuYW1lXVtpXSA9IGZpZWxkVmFsdWVbaV07IC8vIG5vdCBhIHJlZmVyZW5jZSB0eXBlXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmFtZV0gPSBmaWVsZFZhbHVlOyAvLyBub3QgYSByZWZlcmVuY2UgdHlwZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICBsZXQgVCA9IGZpZWxkLlQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVwZWF0KVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkVmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmFtZV1baV0gPSBULmNyZWF0ZShmaWVsZFZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvdXRwdXRbbmFtZV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W25hbWVdID0gVC5jcmVhdGUoZmllbGRWYWx1ZSk7IC8vIG5vdGhpbmcgdG8gbWVyZ2Ugd2l0aFxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgVC5tZXJnZVBhcnRpYWwob3V0cHV0W25hbWVdLCBmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgICAvLyBNYXAgYW5kIHJlcGVhdGVkIGZpZWxkcyBhcmUgc2ltcGx5IG92ZXJ3cml0dGVuLCBub3QgYXBwZW5kZWQgb3IgbWVyZ2VkXG4gICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvdXRwdXRbbmFtZV0sIGZpZWxkVmFsdWUpOyAvLyBlbGVtZW50cyBhcmUgbm90IHJlZmVyZW5jZSB0eXBlc1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgVCA9IGZpZWxkLlYuVCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayBvZiBPYmplY3Qua2V5cyhmaWVsZFZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmFtZV1ba10gPSBULmNyZWF0ZShmaWVsZFZhbHVlW2tdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IExvbmdUeXBlLCBTY2FsYXJUeXBlIH0gZnJvbSBcIi4vcmVmbGVjdGlvbi1pbmZvXCI7XG5pbXBvcnQgeyByZWZsZWN0aW9uTG9uZ0NvbnZlcnQgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWxvbmctY29udmVydFwiO1xuaW1wb3J0IHsgUGJMb25nLCBQYlVMb25nIH0gZnJvbSBcIi4vcGItbG9uZ1wiO1xuLyoqXG4gKiBDcmVhdGVzIHRoZSBkZWZhdWx0IHZhbHVlIGZvciBhIHNjYWxhciB0eXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVmbGVjdGlvblNjYWxhckRlZmF1bHQodHlwZSwgbG9uZ1R5cGUgPSBMb25nVHlwZS5TVFJJTkcpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3Rpb25Mb25nQ29udmVydChQYlVMb25nLlpFUk8sIGxvbmdUeXBlKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICByZXR1cm4gcmVmbGVjdGlvbkxvbmdDb252ZXJ0KFBiTG9uZy5aRVJPLCBsb25nVHlwZSk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgICAgICAgICAgLy8gY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgICAgIC8vIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgICAgICAvLyBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICAgICAgICAgIC8vIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IExvbmdUeXBlLCBTY2FsYXJUeXBlIH0gZnJvbSBcIi4vcmVmbGVjdGlvbi1pbmZvXCI7XG5pbXBvcnQgeyBpc09uZW9mR3JvdXAgfSBmcm9tIFwiLi9vbmVvZlwiO1xuLy8gbm9pbnNwZWN0aW9uIEpTTWV0aG9kQ2FuQmVTdGF0aWNcbmV4cG9ydCBjbGFzcyBSZWZsZWN0aW9uVHlwZUNoZWNrIHtcbiAgICBjb25zdHJ1Y3RvcihpbmZvKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSAoX2EgPSBpbmZvLmZpZWxkcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgfVxuICAgIHByZXBhcmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHJlcSA9IFtdLCBrbm93biA9IFtdLCBvbmVvZnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZmllbGQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgICAgIGlmICghb25lb2ZzLmluY2x1ZGVzKGZpZWxkLm9uZW9mKSkge1xuICAgICAgICAgICAgICAgICAgICBvbmVvZnMucHVzaChmaWVsZC5vbmVvZik7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5wdXNoKGZpZWxkLm9uZW9mKTtcbiAgICAgICAgICAgICAgICAgICAga25vd24ucHVzaChmaWVsZC5vbmVvZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga25vd24ucHVzaChmaWVsZC5sb2NhbE5hbWUpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkLm9wdCB8fCBmaWVsZC5yZXBlYXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnB1c2goZmllbGQubG9jYWxOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLnJlcGVhdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEucHVzaChmaWVsZC5sb2NhbE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5wdXNoKGZpZWxkLmxvY2FsTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhID0geyByZXEsIGtub3duLCBvbmVvZnM6IE9iamVjdC52YWx1ZXMob25lb2ZzKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgYXJndW1lbnQgYSB2YWxpZCBtZXNzYWdlIGFzIHNwZWNpZmllZCBieSB0aGVcbiAgICAgKiByZWZsZWN0aW9uIGluZm9ybWF0aW9uP1xuICAgICAqXG4gICAgICogQ2hlY2tzIGFsbCBmaWVsZCB0eXBlcyByZWN1cnNpdmVseS4gVGhlIGBkZXB0aGBcbiAgICAgKiBzcGVjaWZpZXMgaG93IGRlZXAgaW50byB0aGUgc3RydWN0dXJlIHRoZSBjaGVjayB3aWxsIGJlLlxuICAgICAqXG4gICAgICogV2l0aCBhIGRlcHRoIG9mIDAsIG9ubHkgdGhlIHByZXNlbmNlIG9mIGZpZWxkc1xuICAgICAqIGlzIGNoZWNrZWQuXG4gICAgICpcbiAgICAgKiBXaXRoIGEgZGVwdGggb2YgMSBvciBtb3JlLCB0aGUgZmllbGQgdHlwZXMgYXJlIGNoZWNrZWQuXG4gICAgICpcbiAgICAgKiBXaXRoIGEgZGVwdGggb2YgMiBvciBtb3JlLCB0aGUgbWVtYmVycyBvZiBtYXAsIHJlcGVhdGVkXG4gICAgICogYW5kIG1lc3NhZ2UgZmllbGRzIGFyZSBjaGVja2VkLlxuICAgICAqXG4gICAgICogTWVzc2FnZSBmaWVsZHMgd2lsbCBiZSBjaGVja2VkIHJlY3Vyc2l2ZWx5IHdpdGggZGVwdGggLSAxLlxuICAgICAqXG4gICAgICogVGhlIG51bWJlciBvZiBtYXAgZW50cmllcyAvIHJlcGVhdGVkIHZhbHVlcyBiZWluZyBjaGVja2VkXG4gICAgICogaXMgPCBkZXB0aC5cbiAgICAgKi9cbiAgICBpcyhtZXNzYWdlLCBkZXB0aCwgYWxsb3dFeGNlc3NQcm9wZXJ0aWVzID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGRlcHRoIDwgMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCB8fCBtZXNzYWdlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1lc3NhZ2UgIT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMucHJlcGFyZSgpO1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKG1lc3NhZ2UpLCBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAvLyBpZiBhIHJlcXVpcmVkIGZpZWxkIGlzIG1pc3NpbmcgaW4gYXJnLCB0aGlzIGNhbm5vdCBiZSBhIFRcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoIDwgZGF0YS5yZXEubGVuZ3RoIHx8IGRhdGEucmVxLnNvbWUobiA9PiAha2V5cy5pbmNsdWRlcyhuKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghYWxsb3dFeGNlc3NQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgYXJnIGNvbnRhaW5zIGEga2V5IHdlIGRvbnQga25vdywgdGhpcyBpcyBub3QgYSBsaXRlcmFsIFRcbiAgICAgICAgICAgIGlmIChrZXlzLnNvbWUoayA9PiAhZGF0YS5rbm93bi5pbmNsdWRlcyhrKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiV2l0aCBhIGRlcHRoIG9mIDAsIG9ubHkgdGhlIHByZXNlbmNlIGFuZCBhYnNlbmNlIG9mIGZpZWxkcyBpcyBjaGVja2VkLlwiXG4gICAgICAgIC8vIFwiV2l0aCBhIGRlcHRoIG9mIDEgb3IgbW9yZSwgdGhlIGZpZWxkIHR5cGVzIGFyZSBjaGVja2VkLlwiXG4gICAgICAgIGlmIChkZXB0aCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIG9uZW9mIGdyb3VwXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBkYXRhLm9uZW9mcykge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBtZXNzYWdlW25hbWVdO1xuICAgICAgICAgICAgaWYgKCFpc09uZW9mR3JvdXAoZ3JvdXApKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChncm91cC5vbmVvZktpbmQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZHMuZmluZChmID0+IGYubG9jYWxOYW1lID09PSBncm91cC5vbmVvZktpbmQpO1xuICAgICAgICAgICAgaWYgKCFmaWVsZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHdlIGZvdW5kIG5vIGZpZWxkLCBidXQgaGF2ZSBhIGtpbmQsIHNvbWV0aGluZyBpcyB3cm9uZ1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpZWxkKGdyb3VwW2dyb3VwLm9uZW9mS2luZF0sIGZpZWxkLCBhbGxvd0V4Y2Vzc1Byb3BlcnRpZXMsIGRlcHRoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgdHlwZXNcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm9uZW9mICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmllbGQobWVzc2FnZVtmaWVsZC5sb2NhbE5hbWVdLCBmaWVsZCwgYWxsb3dFeGNlc3NQcm9wZXJ0aWVzLCBkZXB0aCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmaWVsZChhcmcsIGZpZWxkLCBhbGxvd0V4Y2Vzc1Byb3BlcnRpZXMsIGRlcHRoKSB7XG4gICAgICAgIGxldCByZXBlYXRlZCA9IGZpZWxkLnJlcGVhdDtcbiAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmllbGQub3B0O1xuICAgICAgICAgICAgICAgIGlmIChyZXBlYXRlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGFycyhhcmcsIGZpZWxkLlQsIGRlcHRoLCBmaWVsZC5MKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsYXIoYXJnLCBmaWVsZC5ULCBmaWVsZC5MKTtcbiAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmllbGQub3B0O1xuICAgICAgICAgICAgICAgIGlmIChyZXBlYXRlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGFycyhhcmcsIFNjYWxhclR5cGUuSU5UMzIsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsYXIoYXJnLCBTY2FsYXJUeXBlLklOVDMyKTtcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmVwZWF0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzKGFyZywgZmllbGQuVCgpLCBhbGxvd0V4Y2Vzc1Byb3BlcnRpZXMsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlKGFyZywgZmllbGQuVCgpLCBhbGxvd0V4Y2Vzc1Byb3BlcnRpZXMsIGRlcHRoKTtcbiAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZyAhPSAnb2JqZWN0JyB8fCBhcmcgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPCAyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWFwS2V5cyhhcmcsIGZpZWxkLkssIGRlcHRoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxhcnMoT2JqZWN0LnZhbHVlcyhhcmcpLCBmaWVsZC5WLlQsIGRlcHRoLCBmaWVsZC5WLkwpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGFycyhPYmplY3QudmFsdWVzKGFyZyksIFNjYWxhclR5cGUuSU5UMzIsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzKE9iamVjdC52YWx1ZXMoYXJnKSwgZmllbGQuVi5UKCksIGFsbG93RXhjZXNzUHJvcGVydGllcywgZGVwdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbWVzc2FnZShhcmcsIHR5cGUsIGFsbG93RXhjZXNzUHJvcGVydGllcywgZGVwdGgpIHtcbiAgICAgICAgaWYgKGFsbG93RXhjZXNzUHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGUuaXNBc3NpZ25hYmxlKGFyZywgZGVwdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlLmlzKGFyZywgZGVwdGgpO1xuICAgIH1cbiAgICBtZXNzYWdlcyhhcmcsIHR5cGUsIGFsbG93RXhjZXNzUHJvcGVydGllcywgZGVwdGgpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkZXB0aCA8IDIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGFsbG93RXhjZXNzUHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmcubGVuZ3RoICYmIGkgPCBkZXB0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmICghdHlwZS5pc0Fzc2lnbmFibGUoYXJnW2ldLCBkZXB0aCAtIDEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZy5sZW5ndGggJiYgaSA8IGRlcHRoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlLmlzKGFyZ1tpXSwgZGVwdGggLSAxKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzY2FsYXIoYXJnLCB0eXBlLCBsb25nVHlwZSkge1xuICAgICAgICBsZXQgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGxvbmdUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTG9uZ1R5cGUuQklHSU5UOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT0gXCJiaWdpbnRcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMb25nVHlwZS5OVU1CRVI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PSBcIm51bWJlclwiICYmICFpc05hTihhcmcpO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PSAnYm9vbGVhbic7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09ICdzdHJpbmcnO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcmcgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PSAnbnVtYmVyJyAmJiAhaXNOYU4oYXJnKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgICAgICAgICAvLyBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICAgICAgICAgICAgICAvLyBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICAgICAgICAgICAgLy8gY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICAgICAgICAgICAgICAvLyBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT0gJ251bWJlcicgJiYgTnVtYmVyLmlzSW50ZWdlcihhcmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjYWxhcnMoYXJnLCB0eXBlLCBkZXB0aCwgbG9uZ1R5cGUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkZXB0aCA8IDIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJnLmxlbmd0aCAmJiBpIDwgZGVwdGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2NhbGFyKGFyZ1tpXSwgdHlwZSwgbG9uZ1R5cGUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtYXBLZXlzKG1hcCwgdHlwZSwgZGVwdGgpIHtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGFycyhrZXlzLnNsaWNlKDAsIGRlcHRoKS5tYXAoayA9PiBwYXJzZUludChrKSksIHR5cGUsIGRlcHRoKTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxhcnMoa2V5cy5zbGljZSgwLCBkZXB0aCkubWFwKGsgPT4gayA9PSAndHJ1ZScgPyB0cnVlIDogayA9PSAnZmFsc2UnID8gZmFsc2UgOiBrKSwgdHlwZSwgZGVwdGgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsYXJzKGtleXMsIHR5cGUsIGRlcHRoLCBMb25nVHlwZS5TVFJJTkcpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdmFyLCBwcmVmZXItdGVtcGxhdGUgKi9cbnZhciB1cHBlcmNhc2VQYXR0ZXJuID0gL1tBLVpdL2dcbnZhciBtc1BhdHRlcm4gPSAvXm1zLS9cbnZhciBjYWNoZSA9IHt9XG5cbmZ1bmN0aW9uIHRvSHlwaGVuTG93ZXIobWF0Y2gpIHtcbiAgcmV0dXJuICctJyArIG1hdGNoLnRvTG93ZXJDYXNlKClcbn1cblxuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKG5hbWUpIHtcbiAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIGNhY2hlW25hbWVdXG4gIH1cblxuICB2YXIgaE5hbWUgPSBuYW1lLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwgdG9IeXBoZW5Mb3dlcilcbiAgcmV0dXJuIChjYWNoZVtuYW1lXSA9IG1zUGF0dGVybi50ZXN0KGhOYW1lKSA/ICctJyArIGhOYW1lIDogaE5hbWUpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGh5cGhlbmF0ZVN0eWxlTmFtZVxuIiwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnQgdmFyIGlzQnJvd3NlciA9ICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yod2luZG93KSkgPT09IFwib2JqZWN0XCIgJiYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGRvY3VtZW50KSkgPT09ICdvYmplY3QnICYmIGRvY3VtZW50Lm5vZGVUeXBlID09PSA5O1xuXG5leHBvcnQgZGVmYXVsdCBpc0Jyb3dzZXI7XG4iLCJpbXBvcnQgaHlwaGVuYXRlIGZyb20gJ2h5cGhlbmF0ZS1zdHlsZS1uYW1lJztcblxuLyoqXG4gKiBDb252ZXJ0IGNhbWVsIGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGRhc2ggc2VwYXJhdGVkLlxuICovXG5cbmZ1bmN0aW9uIGNvbnZlcnRDYXNlKHN0eWxlKSB7XG4gIHZhciBjb252ZXJ0ZWQgPSB7fTtcblxuICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgdmFyIGtleSA9IHByb3AuaW5kZXhPZignLS0nKSA9PT0gMCA/IHByb3AgOiBoeXBoZW5hdGUocHJvcCk7XG4gICAgY29udmVydGVkW2tleV0gPSBzdHlsZVtwcm9wXTtcbiAgfVxuXG4gIGlmIChzdHlsZS5mYWxsYmFja3MpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZS5mYWxsYmFja3MpKSBjb252ZXJ0ZWQuZmFsbGJhY2tzID0gc3R5bGUuZmFsbGJhY2tzLm1hcChjb252ZXJ0Q2FzZSk7ZWxzZSBjb252ZXJ0ZWQuZmFsbGJhY2tzID0gY29udmVydENhc2Uoc3R5bGUuZmFsbGJhY2tzKTtcbiAgfVxuXG4gIHJldHVybiBjb252ZXJ0ZWQ7XG59XG4vKipcbiAqIEFsbG93IGNhbWVsIGNhc2VkIHByb3BlcnR5IG5hbWVzIGJ5IGNvbnZlcnRpbmcgdGhlbSBiYWNrIHRvIGRhc2hlcml6ZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBjYW1lbENhc2UoKSB7XG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICAvLyBIYW5kbGUgcnVsZXMgbGlrZSBAZm9udC1mYWNlLCB3aGljaCBjYW4gaGF2ZSBtdWx0aXBsZSBzdHlsZXMgaW4gYW4gYXJyYXlcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdHlsZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc3R5bGVbaW5kZXhdID0gY29udmVydENhc2Uoc3R5bGVbaW5kZXhdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cblxuICAgIHJldHVybiBjb252ZXJ0Q2FzZShzdHlsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNoYW5nZVZhbHVlKHZhbHVlLCBwcm9wLCBydWxlKSB7XG4gICAgaWYgKHByb3AuaW5kZXhPZignLS0nKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBoeXBoZW5hdGVkUHJvcCA9IGh5cGhlbmF0ZShwcm9wKTsgLy8gVGhlcmUgd2FzIG5vIGNhbWVsIGNhc2UgaW4gcGxhY2VcblxuICAgIGlmIChwcm9wID09PSBoeXBoZW5hdGVkUHJvcCkgcmV0dXJuIHZhbHVlO1xuICAgIHJ1bGUucHJvcChoeXBoZW5hdGVkUHJvcCwgdmFsdWUpOyAvLyBDb3JlIHdpbGwgaWdub3JlIHRoYXQgcHJvcGVydHkgdmFsdWUgd2Ugc2V0IHRoZSBwcm9wZXIgb25lIGFib3ZlLlxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZSxcbiAgICBvbkNoYW5nZVZhbHVlOiBvbkNoYW5nZVZhbHVlXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhbWVsQ2FzZTtcbiIsImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCB7IFJ1bGVMaXN0IH0gZnJvbSAnanNzJztcblxudmFyIGF0ID0gJ0BnbG9iYWwnO1xudmFyIGF0UHJlZml4ID0gJ0BnbG9iYWwgJztcblxudmFyIEdsb2JhbENvbnRhaW5lclJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHbG9iYWxDb250YWluZXJSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2dsb2JhbCc7XG4gICAgdGhpcy5hdCA9IGF0O1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pKTtcblxuICAgIGZvciAodmFyIHNlbGVjdG9yIGluIHN0eWxlcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQoc2VsZWN0b3IsIHN0eWxlc1tzZWxlY3Rvcl0pO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBydWxlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBHbG9iYWxDb250YWluZXJSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0UnVsZSA9IGZ1bmN0aW9uIGdldFJ1bGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmdldChuYW1lKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZWdpc3RlciBydWxlLCBydW4gcGx1Z2lucy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZSA9IGZ1bmN0aW9uIGFkZFJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlLCBvcHRpb25zKTtcbiAgICBpZiAocnVsZSkgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlcGxhY2UgcnVsZSwgcnVuIHBsdWdpbnMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlcGxhY2VSdWxlID0gZnVuY3Rpb24gcmVwbGFjZVJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV3UnVsZSA9IHRoaXMucnVsZXMucmVwbGFjZShuYW1lLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgaWYgKG5ld1J1bGUpIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKG5ld1J1bGUpO1xuICAgIHJldHVybiBuZXdSdWxlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihydWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuaW5kZXhPZihydWxlKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMudG9TdHJpbmcob3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIEdsb2JhbENvbnRhaW5lclJ1bGU7XG59KCk7XG5cbnZhciBHbG9iYWxQcmVmaXhlZFJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHbG9iYWxQcmVmaXhlZFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdnbG9iYWwnO1xuICAgIHRoaXMuYXQgPSBhdDtcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB2YXIgc2VsZWN0b3IgPSBrZXkuc3Vic3RyKGF0UHJlZml4Lmxlbmd0aCk7XG4gICAgdGhpcy5ydWxlID0gb3B0aW9ucy5qc3MuY3JlYXRlUnVsZShzZWxlY3Rvciwgc3R5bGUsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IEdsb2JhbFByZWZpeGVkUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlID8gdGhpcy5ydWxlLnRvU3RyaW5nKG9wdGlvbnMpIDogJyc7XG4gIH07XG5cbiAgcmV0dXJuIEdsb2JhbFByZWZpeGVkUnVsZTtcbn0oKTtcblxudmFyIHNlcGFyYXRvclJlZ0V4cCA9IC9cXHMqLFxccyovZztcblxuZnVuY3Rpb24gYWRkU2NvcGUoc2VsZWN0b3IsIHNjb3BlKSB7XG4gIHZhciBwYXJ0cyA9IHNlbGVjdG9yLnNwbGl0KHNlcGFyYXRvclJlZ0V4cCk7XG4gIHZhciBzY29wZWQgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgc2NvcGVkICs9IHNjb3BlICsgXCIgXCIgKyBwYXJ0c1tpXS50cmltKCk7XG4gICAgaWYgKHBhcnRzW2kgKyAxXSkgc2NvcGVkICs9ICcsICc7XG4gIH1cblxuICByZXR1cm4gc2NvcGVkO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVOZXN0ZWRHbG9iYWxDb250YWluZXJSdWxlKHJ1bGUsIHNoZWV0KSB7XG4gIHZhciBvcHRpb25zID0gcnVsZS5vcHRpb25zLFxuICAgICAgc3R5bGUgPSBydWxlLnN0eWxlO1xuICB2YXIgcnVsZXMgPSBzdHlsZSA/IHN0eWxlW2F0XSA6IG51bGw7XG4gIGlmICghcnVsZXMpIHJldHVybjtcblxuICBmb3IgKHZhciBuYW1lIGluIHJ1bGVzKSB7XG4gICAgc2hlZXQuYWRkUnVsZShuYW1lLCBydWxlc1tuYW1lXSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHNlbGVjdG9yOiBhZGRTY29wZShuYW1lLCBydWxlLnNlbGVjdG9yKVxuICAgIH0pKTtcbiAgfVxuXG4gIGRlbGV0ZSBzdHlsZVthdF07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVByZWZpeGVkR2xvYmFsUnVsZShydWxlLCBzaGVldCkge1xuICB2YXIgb3B0aW9ucyA9IHJ1bGUub3B0aW9ucyxcbiAgICAgIHN0eWxlID0gcnVsZS5zdHlsZTtcblxuICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgaWYgKHByb3BbMF0gIT09ICdAJyB8fCBwcm9wLnN1YnN0cigwLCBhdC5sZW5ndGgpICE9PSBhdCkgY29udGludWU7XG4gICAgdmFyIHNlbGVjdG9yID0gYWRkU2NvcGUocHJvcC5zdWJzdHIoYXQubGVuZ3RoKSwgcnVsZS5zZWxlY3Rvcik7XG4gICAgc2hlZXQuYWRkUnVsZShzZWxlY3Rvciwgc3R5bGVbcHJvcF0sIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBzZWxlY3Rvcjogc2VsZWN0b3JcbiAgICB9KSk7XG4gICAgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICB9XG59XG4vKipcbiAqIENvbnZlcnQgbmVzdGVkIHJ1bGVzIHRvIHNlcGFyYXRlLCByZW1vdmUgdGhlbSBmcm9tIG9yaWdpbmFsIHN0eWxlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGpzc0dsb2JhbCgpIHtcbiAgZnVuY3Rpb24gb25DcmVhdGVSdWxlKG5hbWUsIHN0eWxlcywgb3B0aW9ucykge1xuICAgIGlmICghbmFtZSkgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAobmFtZSA9PT0gYXQpIHtcbiAgICAgIHJldHVybiBuZXcgR2xvYmFsQ29udGFpbmVyUnVsZShuYW1lLCBzdHlsZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChuYW1lWzBdID09PSAnQCcgJiYgbmFtZS5zdWJzdHIoMCwgYXRQcmVmaXgubGVuZ3RoKSA9PT0gYXRQcmVmaXgpIHtcbiAgICAgIHJldHVybiBuZXcgR2xvYmFsUHJlZml4ZWRSdWxlKG5hbWUsIHN0eWxlcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC50eXBlID09PSAnZ2xvYmFsJyB8fCBwYXJlbnQub3B0aW9ucy5wYXJlbnQgJiYgcGFyZW50Lm9wdGlvbnMucGFyZW50LnR5cGUgPT09ICdnbG9iYWwnKSB7XG4gICAgICAgIG9wdGlvbnMuc2NvcGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnNlbGVjdG9yICYmIG9wdGlvbnMuc2NvcGVkID09PSBmYWxzZSkge1xuICAgICAgb3B0aW9ucy5zZWxlY3RvciA9IG5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBvblByb2Nlc3NSdWxlKHJ1bGUsIHNoZWV0KSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJyB8fCAhc2hlZXQpIHJldHVybjtcbiAgICBoYW5kbGVOZXN0ZWRHbG9iYWxDb250YWluZXJSdWxlKHJ1bGUsIHNoZWV0KTtcbiAgICBoYW5kbGVQcmVmaXhlZEdsb2JhbFJ1bGUocnVsZSwgc2hlZXQpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvbkNyZWF0ZVJ1bGU6IG9uQ3JlYXRlUnVsZSxcbiAgICBvblByb2Nlc3NSdWxlOiBvblByb2Nlc3NSdWxlXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGpzc0dsb2JhbDtcbiIsImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCBpc0luQnJvd3NlciBmcm9tICdpcy1pbi1icm93c2VyJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3Rpbnktd2FybmluZyc7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzJztcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlJztcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZCc7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSc7XG5cbnZhciBwbGFpbk9iamVjdENvbnN0cnVyY3RvciA9IHt9LmNvbnN0cnVjdG9yO1xuZnVuY3Rpb24gY2xvbmVTdHlsZShzdHlsZSkge1xuICBpZiAoc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2Ygc3R5bGUgIT09ICdvYmplY3QnKSByZXR1cm4gc3R5bGU7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0eWxlKSkgcmV0dXJuIHN0eWxlLm1hcChjbG9uZVN0eWxlKTtcbiAgaWYgKHN0eWxlLmNvbnN0cnVjdG9yICE9PSBwbGFpbk9iamVjdENvbnN0cnVyY3RvcikgcmV0dXJuIHN0eWxlO1xuICB2YXIgbmV3U3R5bGUgPSB7fTtcblxuICBmb3IgKHZhciBuYW1lIGluIHN0eWxlKSB7XG4gICAgbmV3U3R5bGVbbmFtZV0gPSBjbG9uZVN0eWxlKHN0eWxlW25hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBuZXdTdHlsZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBydWxlIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgbmFtZSA9ICd1bm5hbWVkJztcbiAgfVxuXG4gIHZhciBqc3MgPSBvcHRpb25zLmpzcztcbiAgdmFyIGRlY2xDb3B5ID0gY2xvbmVTdHlsZShkZWNsKTtcbiAgdmFyIHJ1bGUgPSBqc3MucGx1Z2lucy5vbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbENvcHksIG9wdGlvbnMpO1xuICBpZiAocnVsZSkgcmV0dXJuIHJ1bGU7IC8vIEl0IGlzIGFuIGF0LXJ1bGUgYW5kIGl0IGhhcyBubyBpbnN0YW5jZS5cblxuICBpZiAobmFtZVswXSA9PT0gJ0AnKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBVbmtub3duIHJ1bGUgXCIgKyBuYW1lKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgam9pbiA9IGZ1bmN0aW9uIGpvaW4odmFsdWUsIGJ5KSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gUmVtb3ZlICFpbXBvcnRhbnQgZnJvbSB0aGUgdmFsdWUsIGl0IHdpbGwgYmUgcmVhZGRlZCBsYXRlci5cbiAgICBpZiAodmFsdWVbaV0gPT09ICchaW1wb3J0YW50JykgYnJlYWs7XG4gICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9IGJ5O1xuICAgIHJlc3VsdCArPSB2YWx1ZVtpXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBKU1MgYXJyYXkgdmFsdWUgdG8gYSBDU1Mgc3RyaW5nLlxuICpcbiAqIGBtYXJnaW46IFtbJzVweCcsICcxMHB4J11dYCA+IGBtYXJnaW46IDVweCAxMHB4O2BcbiAqIGBib3JkZXI6IFsnMXB4JywgJzJweCddYCA+IGBib3JkZXI6IDFweCwgMnB4O2BcbiAqIGBtYXJnaW46IFtbJzVweCcsICcxMHB4J10sICchaW1wb3J0YW50J11gID4gYG1hcmdpbjogNXB4IDEwcHggIWltcG9ydGFudDtgXG4gKiBgY29sb3I6IFsncmVkJywgIWltcG9ydGFudF1gID4gYGNvbG9yOiByZWQgIWltcG9ydGFudDtgXG4gKi9cblxuXG52YXIgdG9Dc3NWYWx1ZSA9IGZ1bmN0aW9uIHRvQ3NzVmFsdWUodmFsdWUpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICB2YXIgY3NzVmFsdWUgPSAnJzsgLy8gU3VwcG9ydCBzcGFjZSBzZXBhcmF0ZWQgdmFsdWVzIHZpYSBgW1snNXB4JywgJzEwcHgnXV1gLlxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlWzBdKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZVtpXSA9PT0gJyFpbXBvcnRhbnQnKSBicmVhaztcbiAgICAgIGlmIChjc3NWYWx1ZSkgY3NzVmFsdWUgKz0gJywgJztcbiAgICAgIGNzc1ZhbHVlICs9IGpvaW4odmFsdWVbaV0sICcgJyk7XG4gICAgfVxuICB9IGVsc2UgY3NzVmFsdWUgPSBqb2luKHZhbHVlLCAnLCAnKTsgLy8gQWRkICFpbXBvcnRhbnQsIGJlY2F1c2UgaXQgd2FzIGlnbm9yZWQuXG5cblxuICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICchaW1wb3J0YW50Jykge1xuICAgIGNzc1ZhbHVlICs9ICcgIWltcG9ydGFudCc7XG4gIH1cblxuICByZXR1cm4gY3NzVmFsdWU7XG59O1xuXG5mdW5jdGlvbiBnZXRXaGl0ZXNwYWNlU3ltYm9scyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZm9ybWF0ID09PSBmYWxzZSkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lYnJlYWs6ICcnLFxuICAgICAgc3BhY2U6ICcnXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGluZWJyZWFrOiAnXFxuJyxcbiAgICBzcGFjZTogJyAnXG4gIH07XG59XG5cbi8qKlxuICogSW5kZW50IGEgc3RyaW5nLlxuICogaHR0cDovL2pzcGVyZi5jb20vYXJyYXktam9pbi12cy1mb3JcbiAqL1xuXG5mdW5jdGlvbiBpbmRlbnRTdHIoc3RyLCBpbmRlbnQpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBpbmRlbnQ7IGluZGV4KyspIHtcbiAgICByZXN1bHQgKz0gJyAgJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQgKyBzdHI7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgUnVsZSB0byBDU1Mgc3RyaW5nLlxuICovXG5cblxuZnVuY3Rpb24gdG9Dc3Moc2VsZWN0b3IsIHN0eWxlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICghc3R5bGUpIHJldHVybiByZXN1bHQ7XG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRpbmRlbnQgPSBfb3B0aW9ucy5pbmRlbnQsXG4gICAgICBpbmRlbnQgPSBfb3B0aW9ucyRpbmRlbnQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRpbmRlbnQ7XG4gIHZhciBmYWxsYmFja3MgPSBzdHlsZS5mYWxsYmFja3M7XG5cbiAgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSBmYWxzZSkge1xuICAgIGluZGVudCA9IC1JbmZpbml0eTtcbiAgfVxuXG4gIHZhciBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMgPSBnZXRXaGl0ZXNwYWNlU3ltYm9scyhvcHRpb25zKSxcbiAgICAgIGxpbmVicmVhayA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5saW5lYnJlYWssXG4gICAgICBzcGFjZSA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5zcGFjZTtcblxuICBpZiAoc2VsZWN0b3IpIGluZGVudCsrOyAvLyBBcHBseSBmYWxsYmFja3MgZmlyc3QuXG5cbiAgaWYgKGZhbGxiYWNrcykge1xuICAgIC8vIEFycmF5IHN5bnRheCB7ZmFsbGJhY2tzOiBbe3Byb3A6IHZhbHVlfV19XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmFsbGJhY2tzKSkge1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGZhbGxiYWNrcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIGZhbGxiYWNrID0gZmFsbGJhY2tzW2luZGV4XTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGZhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZmFsbGJhY2tbcHJvcF07XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9IGxpbmVicmVhaztcbiAgICAgICAgICAgIHJlc3VsdCArPSBpbmRlbnRTdHIocHJvcCArIFwiOlwiICsgc3BhY2UgKyB0b0Nzc1ZhbHVlKHZhbHVlKSArIFwiO1wiLCBpbmRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPYmplY3Qgc3ludGF4IHtmYWxsYmFja3M6IHtwcm9wOiB2YWx1ZX19XG4gICAgICBmb3IgKHZhciBfcHJvcCBpbiBmYWxsYmFja3MpIHtcbiAgICAgICAgdmFyIF92YWx1ZSA9IGZhbGxiYWNrc1tfcHJvcF07XG5cbiAgICAgICAgaWYgKF92YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9IGxpbmVicmVhaztcbiAgICAgICAgICByZXN1bHQgKz0gaW5kZW50U3RyKF9wcm9wICsgXCI6XCIgKyBzcGFjZSArIHRvQ3NzVmFsdWUoX3ZhbHVlKSArIFwiO1wiLCBpbmRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX3Byb3AyIGluIHN0eWxlKSB7XG4gICAgdmFyIF92YWx1ZTIgPSBzdHlsZVtfcHJvcDJdO1xuXG4gICAgaWYgKF92YWx1ZTIgIT0gbnVsbCAmJiBfcHJvcDIgIT09ICdmYWxsYmFja3MnKSB7XG4gICAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gbGluZWJyZWFrO1xuICAgICAgcmVzdWx0ICs9IGluZGVudFN0cihfcHJvcDIgKyBcIjpcIiArIHNwYWNlICsgdG9Dc3NWYWx1ZShfdmFsdWUyKSArIFwiO1wiLCBpbmRlbnQpO1xuICAgIH1cbiAgfSAvLyBBbGxvdyBlbXB0eSBzdHlsZSBpbiB0aGlzIGNhc2UsIGJlY2F1c2UgcHJvcGVydGllcyB3aWxsIGJlIGFkZGVkIGR5bmFtaWNhbGx5LlxuXG5cbiAgaWYgKCFyZXN1bHQgJiYgIW9wdGlvbnMuYWxsb3dFbXB0eSkgcmV0dXJuIHJlc3VsdDsgLy8gV2hlbiBydWxlIGlzIGJlaW5nIHN0cmluZ2lmaWVkIGJlZm9yZSBzZWxlY3RvciB3YXMgZGVmaW5lZC5cblxuICBpZiAoIXNlbGVjdG9yKSByZXR1cm4gcmVzdWx0O1xuICBpbmRlbnQtLTtcbiAgaWYgKHJlc3VsdCkgcmVzdWx0ID0gXCJcIiArIGxpbmVicmVhayArIHJlc3VsdCArIGxpbmVicmVhaztcbiAgcmV0dXJuIGluZGVudFN0cihcIlwiICsgc2VsZWN0b3IgKyBzcGFjZSArIFwie1wiICsgcmVzdWx0LCBpbmRlbnQpICsgaW5kZW50U3RyKCd9JywgaW5kZW50KTtcbn1cblxudmFyIGVzY2FwZVJlZ2V4ID0gLyhbW1xcXS4jKiQ+PCt+PXxeOigpLFwiJ2BcXHNdKS9nO1xudmFyIG5hdGl2ZUVzY2FwZSA9IHR5cGVvZiBDU1MgIT09ICd1bmRlZmluZWQnICYmIENTUy5lc2NhcGU7XG52YXIgZXNjYXBlID0gKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIG5hdGl2ZUVzY2FwZSA/IG5hdGl2ZUVzY2FwZShzdHIpIDogc3RyLnJlcGxhY2UoZXNjYXBlUmVnZXgsICdcXFxcJDEnKTtcbn0pO1xuXG52YXIgQmFzZVN0eWxlUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VTdHlsZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdzdHlsZSc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHZhciBzaGVldCA9IG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIFJlbmRlcmVyID0gb3B0aW9ucy5SZW5kZXJlcjtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICBpZiAoc2hlZXQpIHRoaXMucmVuZGVyZXIgPSBzaGVldC5yZW5kZXJlcjtlbHNlIGlmIChSZW5kZXJlcikgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlcigpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IGEgc3R5bGUgcHJvcGVydHkuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IEJhc2VTdHlsZVJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5wcm9wID0gZnVuY3Rpb24gcHJvcChuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIC8vIEl0J3MgYSBnZXR0ZXIuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLnN0eWxlW25hbWVdOyAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGUgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkLlxuXG4gICAgdmFyIGZvcmNlID0gb3B0aW9ucyA/IG9wdGlvbnMuZm9yY2UgOiBmYWxzZTtcbiAgICBpZiAoIWZvcmNlICYmIHRoaXMuc3R5bGVbbmFtZV0gPT09IHZhbHVlKSByZXR1cm4gdGhpcztcbiAgICB2YXIgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLnByb2Nlc3MgIT09IGZhbHNlKSB7XG4gICAgICBuZXdWYWx1ZSA9IHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vbkNoYW5nZVZhbHVlKHZhbHVlLCBuYW1lLCB0aGlzKTtcbiAgICB9XG5cbiAgICB2YXIgaXNFbXB0eSA9IG5ld1ZhbHVlID09IG51bGwgfHwgbmV3VmFsdWUgPT09IGZhbHNlO1xuICAgIHZhciBpc0RlZmluZWQgPSBuYW1lIGluIHRoaXMuc3R5bGU7IC8vIFZhbHVlIGlzIGVtcHR5IGFuZCB3YXNuJ3QgZGVmaW5lZCBiZWZvcmUuXG5cbiAgICBpZiAoaXNFbXB0eSAmJiAhaXNEZWZpbmVkICYmICFmb3JjZSkgcmV0dXJuIHRoaXM7IC8vIFdlIGFyZSBnb2luZyB0byByZW1vdmUgdGhpcyB2YWx1ZS5cblxuICAgIHZhciByZW1vdmUgPSBpc0VtcHR5ICYmIGlzRGVmaW5lZDtcbiAgICBpZiAocmVtb3ZlKSBkZWxldGUgdGhpcy5zdHlsZVtuYW1lXTtlbHNlIHRoaXMuc3R5bGVbbmFtZV0gPSBuZXdWYWx1ZTsgLy8gUmVuZGVyYWJsZSBpcyBkZWZpbmVkIGlmIFN0eWxlU2hlZXQgb3B0aW9uIGBsaW5rYCBpcyB0cnVlLlxuXG4gICAgaWYgKHRoaXMucmVuZGVyYWJsZSAmJiB0aGlzLnJlbmRlcmVyKSB7XG4gICAgICBpZiAocmVtb3ZlKSB0aGlzLnJlbmRlcmVyLnJlbW92ZVByb3BlcnR5KHRoaXMucmVuZGVyYWJsZSwgbmFtZSk7ZWxzZSB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMucmVuZGVyYWJsZSwgbmFtZSwgbmV3VmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuXG4gICAgaWYgKHNoZWV0ICYmIHNoZWV0LmF0dGFjaGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAnW0pTU10gUnVsZSBpcyBub3QgbGlua2VkLiBNaXNzaW5nIHNoZWV0IG9wdGlvbiBcImxpbms6IHRydWVcIi4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gQmFzZVN0eWxlUnVsZTtcbn0oKTtcbnZhciBTdHlsZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlU3R5bGVSdWxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFN0eWxlUnVsZSwgX0Jhc2VTdHlsZVJ1bGUpO1xuXG4gIGZ1bmN0aW9uIFN0eWxlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQmFzZVN0eWxlUnVsZS5jYWxsKHRoaXMsIGtleSwgc3R5bGUsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgdmFyIHNlbGVjdG9yID0gb3B0aW9ucy5zZWxlY3RvcixcbiAgICAgICAgc2NvcGVkID0gb3B0aW9ucy5zY29wZWQsXG4gICAgICAgIHNoZWV0ID0gb3B0aW9ucy5zaGVldCxcbiAgICAgICAgZ2VuZXJhdGVJZCA9IG9wdGlvbnMuZ2VuZXJhdGVJZDtcblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgX3RoaXMuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XG4gICAgfSBlbHNlIGlmIChzY29wZWQgIT09IGZhbHNlKSB7XG4gICAgICBfdGhpcy5pZCA9IGdlbmVyYXRlSWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIHNoZWV0KTtcbiAgICAgIF90aGlzLnNlbGVjdG9yVGV4dCA9IFwiLlwiICsgZXNjYXBlKF90aGlzLmlkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBzZWxlY3RvciBzdHJpbmcuXG4gICAqIEF0dGVudGlvbjogdXNlIHRoaXMgd2l0aCBjYXV0aW9uLiBNb3N0IGJyb3dzZXJzIGRpZG4ndCBpbXBsZW1lbnRcbiAgICogc2VsZWN0b3JUZXh0IHNldHRlciwgc28gdGhpcyBtYXkgcmVzdWx0IGluIHJlcmVuZGVyaW5nIG9mIGVudGlyZSBTdHlsZSBTaGVldC5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvMiA9IFN0eWxlUnVsZS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEFwcGx5IHJ1bGUgdG8gYW4gZWxlbWVudCBpbmxpbmUuXG4gICAqL1xuICBfcHJvdG8yLmFwcGx5VG8gPSBmdW5jdGlvbiBhcHBseVRvKHJlbmRlcmFibGUpIHtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuXG4gICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICB2YXIganNvbiA9IHRoaXMudG9KU09OKCk7XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4ganNvbikge1xuICAgICAgICByZW5kZXJlci5zZXRQcm9wZXJ0eShyZW5kZXJhYmxlLCBwcm9wLCBqc29uW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBydWxlLlxuICAgKiBGYWxsYmFja3MgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAqIFVzZWZ1bCBmb3IgaW5saW5lIHN0eWxlcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8yLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICB2YXIganNvbiA9IHt9O1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnN0eWxlW3Byb3BdO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIGpzb25bcHJvcF0gPSB2YWx1ZTtlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkganNvbltwcm9wXSA9IHRvQ3NzVmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBqc29uO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzIudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcbiAgICB2YXIgb3B0cyA9IGxpbmsgPyBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgYWxsb3dFbXB0eTogdHJ1ZVxuICAgIH0pIDogb3B0aW9ucztcbiAgICByZXR1cm4gdG9Dc3ModGhpcy5zZWxlY3RvclRleHQsIHRoaXMuc3R5bGUsIG9wdHMpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTdHlsZVJ1bGUsIFt7XG4gICAga2V5OiBcInNlbGVjdG9yXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChzZWxlY3RvciA9PT0gdGhpcy5zZWxlY3RvclRleHQpIHJldHVybjtcbiAgICAgIHRoaXMuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XG4gICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLFxuICAgICAgICAgIHJlbmRlcmFibGUgPSB0aGlzLnJlbmRlcmFibGU7XG4gICAgICBpZiAoIXJlbmRlcmFibGUgfHwgIXJlbmRlcmVyKSByZXR1cm47XG4gICAgICB2YXIgaGFzQ2hhbmdlZCA9IHJlbmRlcmVyLnNldFNlbGVjdG9yKHJlbmRlcmFibGUsIHNlbGVjdG9yKTsgLy8gSWYgc2VsZWN0b3Igc2V0dGVyIGlzIG5vdCBpbXBsZW1lbnRlZCwgcmVyZW5kZXIgdGhlIHJ1bGUuXG5cbiAgICAgIGlmICghaGFzQ2hhbmdlZCkge1xuICAgICAgICByZW5kZXJlci5yZXBsYWNlUnVsZShyZW5kZXJhYmxlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHNlbGVjdG9yIHN0cmluZy5cbiAgICAgKi9cbiAgICAsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RvclRleHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0eWxlUnVsZTtcbn0oQmFzZVN0eWxlUnVsZSk7XG52YXIgcGx1Z2luU3R5bGVSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKGtleVswXSA9PT0gJ0AnIHx8IG9wdGlvbnMucGFyZW50ICYmIG9wdGlvbnMucGFyZW50LnR5cGUgPT09ICdrZXlmcmFtZXMnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFN0eWxlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGRlZmF1bHRUb1N0cmluZ09wdGlvbnMgPSB7XG4gIGluZGVudDogMSxcbiAgY2hpbGRyZW46IHRydWVcbn07XG52YXIgYXRSZWdFeHAgPSAvQChbXFx3LV0rKS87XG4vKipcbiAqIENvbmRpdGlvbmFsIHJ1bGUgZm9yIEBtZWRpYSwgQHN1cHBvcnRzXG4gKi9cblxudmFyIENvbmRpdGlvbmFsUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbmRpdGlvbmFsUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdjb25kaXRpb25hbCc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHZhciBhdE1hdGNoID0ga2V5Lm1hdGNoKGF0UmVnRXhwKTtcbiAgICB0aGlzLmF0ID0gYXRNYXRjaCA/IGF0TWF0Y2hbMV0gOiAndW5rbm93bic7IC8vIEtleSBtaWdodCBjb250YWluIGEgdW5pcXVlIHN1ZmZpeCBpbiBjYXNlIHRoZSBgbmFtZWAgcGFzc2VkIGJ5IHVzZXIgd2FzIGR1cGxpY2F0ZS5cblxuICAgIHRoaXMucXVlcnkgPSBvcHRpb25zLm5hbWUgfHwgXCJAXCIgKyB0aGlzLmF0O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5ydWxlcyA9IG5ldyBSdWxlTGlzdChfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgcGFyZW50OiB0aGlzXG4gICAgfSkpO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlc1tuYW1lXSk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcy5wcm9jZXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHJ1bGUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IENvbmRpdGlvbmFsUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFJ1bGUgPSBmdW5jdGlvbiBnZXRSdWxlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5nZXQobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJlZ2lzdGVyIHJ1bGUsIHJ1biBwbHVnaW5zLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5hZGRSdWxlID0gZnVuY3Rpb24gYWRkUnVsZShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHZhciBydWxlID0gdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGUsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlcGxhY2UgcnVsZSwgcnVuIHBsdWdpbnMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlcGxhY2VSdWxlID0gZnVuY3Rpb24gcmVwbGFjZVJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV3UnVsZSA9IHRoaXMucnVsZXMucmVwbGFjZShuYW1lLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgaWYgKG5ld1J1bGUpIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKG5ld1J1bGUpO1xuICAgIHJldHVybiBuZXdSdWxlO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgX2dldFdoaXRlc3BhY2VTeW1ib2xzID0gZ2V0V2hpdGVzcGFjZVN5bWJvbHMob3B0aW9ucyksXG4gICAgICAgIGxpbmVicmVhayA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5saW5lYnJlYWs7XG5cbiAgICBpZiAob3B0aW9ucy5pbmRlbnQgPT0gbnVsbCkgb3B0aW9ucy5pbmRlbnQgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zLmluZGVudDtcbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PSBudWxsKSBvcHRpb25zLmNoaWxkcmVuID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucy5jaGlsZHJlbjtcblxuICAgIGlmIChvcHRpb25zLmNoaWxkcmVuID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMucXVlcnkgKyBcIiB7fVwiO1xuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucnVsZXMudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgcmV0dXJuIGNoaWxkcmVuID8gdGhpcy5xdWVyeSArIFwiIHtcIiArIGxpbmVicmVhayArIGNoaWxkcmVuICsgbGluZWJyZWFrICsgXCJ9XCIgOiAnJztcbiAgfTtcblxuICByZXR1cm4gQ29uZGl0aW9uYWxSdWxlO1xufSgpO1xudmFyIGtleVJlZ0V4cCA9IC9AY29udGFpbmVyfEBtZWRpYXxAc3VwcG9ydHNcXHMrLztcbnZhciBwbHVnaW5Db25kaXRpb25hbFJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGtleVJlZ0V4cC50ZXN0KGtleSkgPyBuZXcgQ29uZGl0aW9uYWxSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDEgPSB7XG4gIGluZGVudDogMSxcbiAgY2hpbGRyZW46IHRydWVcbn07XG52YXIgbmFtZVJlZ0V4cCA9IC9Aa2V5ZnJhbWVzXFxzKyhbXFx3LV0rKS87XG4vKipcbiAqIFJ1bGUgZm9yIEBrZXlmcmFtZXNcbiAqL1xuXG52YXIgS2V5ZnJhbWVzUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEtleWZyYW1lc1J1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAna2V5ZnJhbWVzJztcbiAgICB0aGlzLmF0ID0gJ0BrZXlmcmFtZXMnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB2YXIgbmFtZU1hdGNoID0ga2V5Lm1hdGNoKG5hbWVSZWdFeHApO1xuXG4gICAgaWYgKG5hbWVNYXRjaCAmJiBuYW1lTWF0Y2hbMV0pIHtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWVNYXRjaFsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uYW1lID0gJ25vbmFtZSc7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIEJhZCBrZXlmcmFtZXMgbmFtZSBcIiArIGtleSkgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdGhpcy5rZXkgPSB0aGlzLnR5cGUgKyBcIi1cIiArIHRoaXMubmFtZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciBzY29wZWQgPSBvcHRpb25zLnNjb3BlZCxcbiAgICAgICAgc2hlZXQgPSBvcHRpb25zLnNoZWV0LFxuICAgICAgICBnZW5lcmF0ZUlkID0gb3B0aW9ucy5nZW5lcmF0ZUlkO1xuICAgIHRoaXMuaWQgPSBzY29wZWQgPT09IGZhbHNlID8gdGhpcy5uYW1lIDogZXNjYXBlKGdlbmVyYXRlSWQodGhpcywgc2hlZXQpKTtcbiAgICB0aGlzLnJ1bGVzID0gbmV3IFJ1bGVMaXN0KF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGZyYW1lcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQobmFtZSwgZnJhbWVzW25hbWVdLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgICBwYXJlbnQ6IHRoaXNcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gS2V5ZnJhbWVzUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDE7XG4gICAgfVxuXG4gICAgdmFyIF9nZXRXaGl0ZXNwYWNlU3ltYm9scyA9IGdldFdoaXRlc3BhY2VTeW1ib2xzKG9wdGlvbnMpLFxuICAgICAgICBsaW5lYnJlYWsgPSBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMubGluZWJyZWFrO1xuXG4gICAgaWYgKG9wdGlvbnMuaW5kZW50ID09IG51bGwpIG9wdGlvbnMuaW5kZW50ID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxLmluZGVudDtcbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PSBudWxsKSBvcHRpb25zLmNoaWxkcmVuID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxLmNoaWxkcmVuO1xuXG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdCArIFwiIFwiICsgdGhpcy5pZCArIFwiIHt9XCI7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5ydWxlcy50b1N0cmluZyhvcHRpb25zKTtcbiAgICBpZiAoY2hpbGRyZW4pIGNoaWxkcmVuID0gXCJcIiArIGxpbmVicmVhayArIGNoaWxkcmVuICsgbGluZWJyZWFrO1xuICAgIHJldHVybiB0aGlzLmF0ICsgXCIgXCIgKyB0aGlzLmlkICsgXCIge1wiICsgY2hpbGRyZW4gKyBcIn1cIjtcbiAgfTtcblxuICByZXR1cm4gS2V5ZnJhbWVzUnVsZTtcbn0oKTtcbnZhciBrZXlSZWdFeHAkMSA9IC9Aa2V5ZnJhbWVzXFxzKy87XG52YXIgcmVmUmVnRXhwID0gL1xcJChbXFx3LV0rKS9nO1xuXG52YXIgZmluZFJlZmVyZW5jZWRLZXlmcmFtZSA9IGZ1bmN0aW9uIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUodmFsLCBrZXlmcmFtZXMpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbC5yZXBsYWNlKHJlZlJlZ0V4cCwgZnVuY3Rpb24gKG1hdGNoLCBuYW1lKSB7XG4gICAgICBpZiAobmFtZSBpbiBrZXlmcmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIGtleWZyYW1lc1tuYW1lXTtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBSZWZlcmVuY2VkIGtleWZyYW1lcyBydWxlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQuXCIpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn07XG4vKipcbiAqIFJlcGxhY2UgdGhlIHJlZmVyZW5jZSBmb3IgYSBhbmltYXRpb24gbmFtZS5cbiAqL1xuXG5cbnZhciByZXBsYWNlUmVmID0gZnVuY3Rpb24gcmVwbGFjZVJlZihzdHlsZSwgcHJvcCwga2V5ZnJhbWVzKSB7XG4gIHZhciB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuICB2YXIgcmVmS2V5ZnJhbWUgPSBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbHVlLCBrZXlmcmFtZXMpO1xuXG4gIGlmIChyZWZLZXlmcmFtZSAhPT0gdmFsdWUpIHtcbiAgICBzdHlsZVtwcm9wXSA9IHJlZktleWZyYW1lO1xuICB9XG59O1xuXG52YXIgcGx1Z2luS2V5ZnJhbWVzUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5UmVnRXhwJDEudGVzdChrZXkpID8gbmV3IEtleWZyYW1lc1J1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIDogbnVsbDtcbiAgfSxcbiAgLy8gQW5pbWF0aW9uIG5hbWUgcmVmIHJlcGxhY2VyLlxuICBvblByb2Nlc3NTdHlsZTogZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUsIHNoZWV0KSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJyB8fCAhc2hlZXQpIHJldHVybiBzdHlsZTtcbiAgICBpZiAoJ2FuaW1hdGlvbi1uYW1lJyBpbiBzdHlsZSkgcmVwbGFjZVJlZihzdHlsZSwgJ2FuaW1hdGlvbi1uYW1lJywgc2hlZXQua2V5ZnJhbWVzKTtcbiAgICBpZiAoJ2FuaW1hdGlvbicgaW4gc3R5bGUpIHJlcGxhY2VSZWYoc3R5bGUsICdhbmltYXRpb24nLCBzaGVldC5rZXlmcmFtZXMpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgb25DaGFuZ2VWYWx1ZTogZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWwsIHByb3AsIHJ1bGUpIHtcbiAgICB2YXIgc2hlZXQgPSBydWxlLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICBpZiAoIXNoZWV0KSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgY2FzZSAnYW5pbWF0aW9uJzpcbiAgICAgICAgcmV0dXJuIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUodmFsLCBzaGVldC5rZXlmcmFtZXMpO1xuXG4gICAgICBjYXNlICdhbmltYXRpb24tbmFtZSc6XG4gICAgICAgIHJldHVybiBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbCwgc2hlZXQua2V5ZnJhbWVzKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBLZXlmcmFtZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlU3R5bGVSdWxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKEtleWZyYW1lUnVsZSwgX0Jhc2VTdHlsZVJ1bGUpO1xuXG4gIGZ1bmN0aW9uIEtleWZyYW1lUnVsZSgpIHtcbiAgICByZXR1cm4gX0Jhc2VTdHlsZVJ1bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEtleWZyYW1lUnVsZS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcbiAgICB2YXIgb3B0cyA9IGxpbmsgPyBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgYWxsb3dFbXB0eTogdHJ1ZVxuICAgIH0pIDogb3B0aW9ucztcbiAgICByZXR1cm4gdG9Dc3ModGhpcy5rZXksIHRoaXMuc3R5bGUsIG9wdHMpO1xuICB9O1xuXG4gIHJldHVybiBLZXlmcmFtZVJ1bGU7XG59KEJhc2VTdHlsZVJ1bGUpO1xudmFyIHBsdWdpbktleWZyYW1lUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC50eXBlID09PSAna2V5ZnJhbWVzJykge1xuICAgICAgcmV0dXJuIG5ldyBLZXlmcmFtZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbnZhciBGb250RmFjZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb250RmFjZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdmb250LWZhY2UnO1xuICAgIHRoaXMuYXQgPSAnQGZvbnQtZmFjZSc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBGb250RmFjZVJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgX2dldFdoaXRlc3BhY2VTeW1ib2xzID0gZ2V0V2hpdGVzcGFjZVN5bWJvbHMob3B0aW9ucyksXG4gICAgICAgIGxpbmVicmVhayA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5saW5lYnJlYWs7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnN0eWxlKSkge1xuICAgICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5zdHlsZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc3RyICs9IHRvQ3NzKHRoaXMuYXQsIHRoaXMuc3R5bGVbaW5kZXhdKTtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVbaW5kZXggKyAxXSkgc3RyICs9IGxpbmVicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9Dc3ModGhpcy5hdCwgdGhpcy5zdHlsZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIEZvbnRGYWNlUnVsZTtcbn0oKTtcbnZhciBrZXlSZWdFeHAkMiA9IC9AZm9udC1mYWNlLztcbnZhciBwbHVnaW5Gb250RmFjZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5UmVnRXhwJDIudGVzdChrZXkpID8gbmV3IEZvbnRGYWNlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBWaWV3cG9ydFJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWaWV3cG9ydFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICd2aWV3cG9ydCc7XG4gICAgdGhpcy5hdCA9ICdAdmlld3BvcnQnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gVmlld3BvcnRSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRvQ3NzKHRoaXMua2V5LCB0aGlzLnN0eWxlLCBvcHRpb25zKTtcbiAgfTtcblxuICByZXR1cm4gVmlld3BvcnRSdWxlO1xufSgpO1xudmFyIHBsdWdpblZpZXdwb3J0UnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBrZXkgPT09ICdAdmlld3BvcnQnIHx8IGtleSA9PT0gJ0AtbXMtdmlld3BvcnQnID8gbmV3IFZpZXdwb3J0UnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBTaW1wbGVSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2ltcGxlUnVsZShrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ3NpbXBsZSc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cblxuICB2YXIgX3Byb3RvID0gU2ltcGxlUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpKSB7XG4gICAgICB2YXIgc3RyID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnZhbHVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzdHIgKz0gdGhpcy5rZXkgKyBcIiBcIiArIHRoaXMudmFsdWVbaW5kZXhdICsgXCI7XCI7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlW2luZGV4ICsgMV0pIHN0ciArPSAnXFxuJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5rZXkgKyBcIiBcIiArIHRoaXMudmFsdWUgKyBcIjtcIjtcbiAgfTtcblxuICByZXR1cm4gU2ltcGxlUnVsZTtcbn0oKTtcbnZhciBrZXlzTWFwID0ge1xuICAnQGNoYXJzZXQnOiB0cnVlLFxuICAnQGltcG9ydCc6IHRydWUsXG4gICdAbmFtZXNwYWNlJzogdHJ1ZVxufTtcbnZhciBwbHVnaW5TaW1wbGVSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGtleSBpbiBrZXlzTWFwID8gbmV3IFNpbXBsZVJ1bGUoa2V5LCB2YWx1ZSwgb3B0aW9ucykgOiBudWxsO1xuICB9XG59O1xuXG52YXIgcGx1Z2lucyA9IFtwbHVnaW5TdHlsZVJ1bGUsIHBsdWdpbkNvbmRpdGlvbmFsUnVsZSwgcGx1Z2luS2V5ZnJhbWVzUnVsZSwgcGx1Z2luS2V5ZnJhbWVSdWxlLCBwbHVnaW5Gb250RmFjZVJ1bGUsIHBsdWdpblZpZXdwb3J0UnVsZSwgcGx1Z2luU2ltcGxlUnVsZV07XG5cbnZhciBkZWZhdWx0VXBkYXRlT3B0aW9ucyA9IHtcbiAgcHJvY2VzczogdHJ1ZVxufTtcbnZhciBmb3JjZVVwZGF0ZU9wdGlvbnMgPSB7XG4gIGZvcmNlOiB0cnVlLFxuICBwcm9jZXNzOiB0cnVlXG4gIC8qKlxuICAgKiBDb250YWlucyBydWxlcyBvYmplY3RzIGFuZCBhbGxvd3MgYWRkaW5nL3JlbW92aW5nIGV0Yy5cbiAgICogSXMgdXNlZCBmb3IgZS5nLiBieSBgU3R5bGVTaGVldGAgb3IgYENvbmRpdGlvbmFsUnVsZWAuXG4gICAqL1xuXG59O1xuXG52YXIgUnVsZUxpc3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvLyBSdWxlcyByZWdpc3RyeSBmb3IgYWNjZXNzIGJ5IC5nZXQoKSBtZXRob2QuXG4gIC8vIEl0IGNvbnRhaW5zIHRoZSBzYW1lIHJ1bGUgcmVnaXN0ZXJlZCBieSBuYW1lIGFuZCBieSBzZWxlY3Rvci5cbiAgLy8gT3JpZ2luYWwgc3R5bGVzIG9iamVjdC5cbiAgLy8gVXNlZCB0byBlbnN1cmUgY29ycmVjdCBydWxlcyBvcmRlci5cbiAgZnVuY3Rpb24gUnVsZUxpc3Qob3B0aW9ucykge1xuICAgIHRoaXMubWFwID0ge307XG4gICAgdGhpcy5yYXcgPSB7fTtcbiAgICB0aGlzLmluZGV4ID0gW107XG4gICAgdGhpcy5jb3VudGVyID0gMDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY2xhc3NlcyA9IG9wdGlvbnMuY2xhc3NlcztcbiAgICB0aGlzLmtleWZyYW1lcyA9IG9wdGlvbnMua2V5ZnJhbWVzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJlZ2lzdGVyIHJ1bGUuXG4gICAqXG4gICAqIFdpbGwgbm90IHJlbmRlciBhZnRlciBTdHlsZSBTaGVldCB3YXMgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFJ1bGVMaXN0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKG5hbWUsIGRlY2wsIHJ1bGVPcHRpb25zKSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHBhcmVudCA9IF90aGlzJG9wdGlvbnMucGFyZW50LFxuICAgICAgICBzaGVldCA9IF90aGlzJG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIGpzcyA9IF90aGlzJG9wdGlvbnMuanNzLFxuICAgICAgICBSZW5kZXJlciA9IF90aGlzJG9wdGlvbnMuUmVuZGVyZXIsXG4gICAgICAgIGdlbmVyYXRlSWQgPSBfdGhpcyRvcHRpb25zLmdlbmVyYXRlSWQsXG4gICAgICAgIHNjb3BlZCA9IF90aGlzJG9wdGlvbnMuc2NvcGVkO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBfZXh0ZW5kcyh7XG4gICAgICBjbGFzc2VzOiB0aGlzLmNsYXNzZXMsXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgIHNoZWV0OiBzaGVldCxcbiAgICAgIGpzczoganNzLFxuICAgICAgUmVuZGVyZXI6IFJlbmRlcmVyLFxuICAgICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZCxcbiAgICAgIHNjb3BlZDogc2NvcGVkLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGtleWZyYW1lczogdGhpcy5rZXlmcmFtZXMsXG4gICAgICBzZWxlY3RvcjogdW5kZWZpbmVkXG4gICAgfSwgcnVsZU9wdGlvbnMpOyAvLyBXaGVuIHVzZXIgdXNlcyAuY3JlYXRlU3R5bGVTaGVldCgpLCBkdXBsaWNhdGUgbmFtZXMgYXJlIG5vdCBwb3NzaWJsZSwgYnV0XG4gICAgLy8gYHNoZWV0LmFkZFJ1bGUoKWAgb3BlbnMgdGhlIGRvb3IgZm9yIGFueSBkdXBsaWNhdGUgcnVsZSBuYW1lLiBXaGVuIHRoaXMgaGFwcGVuc1xuICAgIC8vIHdlIG5lZWQgdG8gbWFrZSB0aGUga2V5IHVuaXF1ZSB3aXRoaW4gdGhpcyBSdWxlTGlzdCBpbnN0YW5jZSBzY29wZS5cblxuXG4gICAgdmFyIGtleSA9IG5hbWU7XG5cbiAgICBpZiAobmFtZSBpbiB0aGlzLnJhdykge1xuICAgICAga2V5ID0gbmFtZSArIFwiLWRcIiArIHRoaXMuY291bnRlcisrO1xuICAgIH0gLy8gV2UgbmVlZCB0byBzYXZlIHRoZSBvcmlnaW5hbCBkZWNsIGJlZm9yZSBjcmVhdGluZyB0aGUgcnVsZVxuICAgIC8vIGJlY2F1c2UgY2FjaGUgcGx1Z2luIG5lZWRzIHRvIHVzZSBpdCBhcyBhIGtleSB0byByZXR1cm4gYSBjYWNoZWQgcnVsZS5cblxuXG4gICAgdGhpcy5yYXdba2V5XSA9IGRlY2w7XG5cbiAgICBpZiAoa2V5IGluIHRoaXMuY2xhc3Nlcykge1xuICAgICAgLy8gRS5nLiBydWxlcyBpbnNpZGUgb2YgQG1lZGlhIGNvbnRhaW5lclxuICAgICAgb3B0aW9ucy5zZWxlY3RvciA9IFwiLlwiICsgZXNjYXBlKHRoaXMuY2xhc3Nlc1trZXldKTtcbiAgICB9XG5cbiAgICB2YXIgcnVsZSA9IGNyZWF0ZVJ1bGUoa2V5LCBkZWNsLCBvcHRpb25zKTtcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBudWxsO1xuICAgIHRoaXMucmVnaXN0ZXIocnVsZSk7XG4gICAgdmFyIGluZGV4ID0gb3B0aW9ucy5pbmRleCA9PT0gdW5kZWZpbmVkID8gdGhpcy5pbmRleC5sZW5ndGggOiBvcHRpb25zLmluZGV4O1xuICAgIHRoaXMuaW5kZXguc3BsaWNlKGluZGV4LCAwLCBydWxlKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZSBydWxlLlxuICAgKiBDcmVhdGUgYSBuZXcgcnVsZSBhbmQgcmVtb3ZlIG9sZCBvbmUgaW5zdGVhZCBvZiBvdmVyd3JpdGluZ1xuICAgKiBiZWNhdXNlIHdlIHdhbnQgdG8gaW52b2tlIG9uQ3JlYXRlUnVsZSBob29rIHRvIG1ha2UgcGx1Z2lucyB3b3JrLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShuYW1lLCBkZWNsLCBydWxlT3B0aW9ucykge1xuICAgIHZhciBvbGRSdWxlID0gdGhpcy5nZXQobmFtZSk7XG4gICAgdmFyIG9sZEluZGV4ID0gdGhpcy5pbmRleC5pbmRleE9mKG9sZFJ1bGUpO1xuXG4gICAgaWYgKG9sZFJ1bGUpIHtcbiAgICAgIHRoaXMucmVtb3ZlKG9sZFJ1bGUpO1xuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0gcnVsZU9wdGlvbnM7XG4gICAgaWYgKG9sZEluZGV4ICE9PSAtMSkgb3B0aW9ucyA9IF9leHRlbmRzKHt9LCBydWxlT3B0aW9ucywge1xuICAgICAgaW5kZXg6IG9sZEluZGV4XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuYWRkKG5hbWUsIGRlY2wsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBydWxlIGJ5IG5hbWUgb3Igc2VsZWN0b3IuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lT3JTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLm1hcFtuYW1lT3JTZWxlY3Rvcl07XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShydWxlKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyKHJ1bGUpO1xuICAgIGRlbGV0ZSB0aGlzLnJhd1tydWxlLmtleV07XG4gICAgdGhpcy5pbmRleC5zcGxpY2UodGhpcy5pbmRleC5pbmRleE9mKHJ1bGUpLCAxKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YocnVsZSkge1xuICAgIHJldHVybiB0aGlzLmluZGV4LmluZGV4T2YocnVsZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJ1biBgb25Qcm9jZXNzUnVsZSgpYCBwbHVnaW5zIG9uIGV2ZXJ5IHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKCkge1xuICAgIHZhciBwbHVnaW5zID0gdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zOyAvLyBXZSBuZWVkIHRvIGNsb25lIGFycmF5IGJlY2F1c2UgaWYgd2UgbW9kaWZ5IHRoZSBpbmRleCBzb21ld2hlcmUgZWxzZSBkdXJpbmcgYSBsb29wXG4gICAgLy8gd2UgZW5kIHVwIHdpdGggdmVyeSBoYXJkLXRvLXRyYWNrLWRvd24gc2lkZSBlZmZlY3RzLlxuXG4gICAgdGhpcy5pbmRleC5zbGljZSgwKS5mb3JFYWNoKHBsdWdpbnMub25Qcm9jZXNzUnVsZSwgcGx1Z2lucyk7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgcnVsZSBpbiBgLm1hcGAsIGAuY2xhc3Nlc2AgYW5kIGAua2V5ZnJhbWVzYCBtYXBzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKHJ1bGUpIHtcbiAgICB0aGlzLm1hcFtydWxlLmtleV0gPSBydWxlO1xuXG4gICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBTdHlsZVJ1bGUpIHtcbiAgICAgIHRoaXMubWFwW3J1bGUuc2VsZWN0b3JdID0gcnVsZTtcbiAgICAgIGlmIChydWxlLmlkKSB0aGlzLmNsYXNzZXNbcnVsZS5rZXldID0gcnVsZS5pZDtcbiAgICB9IGVsc2UgaWYgKHJ1bGUgaW5zdGFuY2VvZiBLZXlmcmFtZXNSdWxlICYmIHRoaXMua2V5ZnJhbWVzKSB7XG4gICAgICB0aGlzLmtleWZyYW1lc1tydWxlLm5hbWVdID0gcnVsZS5pZDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51bnJlZ2lzdGVyID0gZnVuY3Rpb24gdW5yZWdpc3RlcihydWxlKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW3J1bGUua2V5XTtcblxuICAgIGlmIChydWxlIGluc3RhbmNlb2YgU3R5bGVSdWxlKSB7XG4gICAgICBkZWxldGUgdGhpcy5tYXBbcnVsZS5zZWxlY3Rvcl07XG4gICAgICBkZWxldGUgdGhpcy5jbGFzc2VzW3J1bGUua2V5XTtcbiAgICB9IGVsc2UgaWYgKHJ1bGUgaW5zdGFuY2VvZiBLZXlmcmFtZXNSdWxlKSB7XG4gICAgICBkZWxldGUgdGhpcy5rZXlmcmFtZXNbcnVsZS5uYW1lXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZnVuY3Rpb24gdmFsdWVzIHdpdGggYSBuZXcgZGF0YS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBuYW1lO1xuICAgIHZhciBkYXRhO1xuICAgIHZhciBvcHRpb25zO1xuXG4gICAgaWYgKHR5cGVvZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdO1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV07XG4gICAgICBuYW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgdGhpcy51cGRhdGVPbmUodGhpcy5nZXQobmFtZSksIGRhdGEsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5pbmRleC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdGhpcy51cGRhdGVPbmUodGhpcy5pbmRleFtpbmRleF0sIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZSBwbHVnaW5zLCB1cGRhdGUgcnVsZSBwcm9wcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXBkYXRlT25lID0gZnVuY3Rpb24gdXBkYXRlT25lKHJ1bGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdFVwZGF0ZU9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzJG9wdGlvbnMyID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBwbHVnaW5zID0gX3RoaXMkb3B0aW9uczIuanNzLnBsdWdpbnMsXG4gICAgICAgIHNoZWV0ID0gX3RoaXMkb3B0aW9uczIuc2hlZXQ7IC8vIEl0IGlzIGEgcnVsZXMgY29udGFpbmVyIGxpa2UgZm9yIGUuZy4gQ29uZGl0aW9uYWxSdWxlLlxuXG4gICAgaWYgKHJ1bGUucnVsZXMgaW5zdGFuY2VvZiBSdWxlTGlzdCkge1xuICAgICAgcnVsZS5ydWxlcy51cGRhdGUoZGF0YSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gcnVsZS5zdHlsZTtcbiAgICBwbHVnaW5zLm9uVXBkYXRlKGRhdGEsIHJ1bGUsIHNoZWV0LCBvcHRpb25zKTsgLy8gV2UgcmVseSBvbiBhIG5ldyBgc3R5bGVgIHJlZiBpbiBjYXNlIGl0IHdhcyBtdXRhdGVkIGR1cmluZyBvblVwZGF0ZSBob29rLlxuXG4gICAgaWYgKG9wdGlvbnMucHJvY2VzcyAmJiBzdHlsZSAmJiBzdHlsZSAhPT0gcnVsZS5zdHlsZSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBydW4gdGhlIHBsdWdpbnMgaW4gY2FzZSBuZXcgYHN0eWxlYCByZWxpZXMgb24gc3ludGF4IHBsdWdpbnMuXG4gICAgICBwbHVnaW5zLm9uUHJvY2Vzc1N0eWxlKHJ1bGUuc3R5bGUsIHJ1bGUsIHNoZWV0KTsgLy8gVXBkYXRlIGFuZCBhZGQgcHJvcHMuXG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gcnVsZS5zdHlsZSkge1xuICAgICAgICB2YXIgbmV4dFZhbHVlID0gcnVsZS5zdHlsZVtwcm9wXTtcbiAgICAgICAgdmFyIHByZXZWYWx1ZSA9IHN0eWxlW3Byb3BdOyAvLyBXZSBuZWVkIHRvIHVzZSBgZm9yY2U6IHRydWVgIGJlY2F1c2UgYHJ1bGUuc3R5bGVgIGhhcyBiZWVuIHVwZGF0ZWQgZHVyaW5nIG9uVXBkYXRlIGhvb2ssIHNvIGBydWxlLnByb3AoKWAgd2lsbCBub3QgdXBkYXRlIHRoZSBDU1NPTSBydWxlLlxuICAgICAgICAvLyBXZSBkbyB0aGlzIGNvbXBhcmlzb24gdG8gYXZvaWQgdW5uZWVkZWQgYHJ1bGUucHJvcCgpYCBjYWxscywgc2luY2Ugd2UgaGF2ZSB0aGUgb2xkIGBzdHlsZWAgb2JqZWN0IGhlcmUuXG5cbiAgICAgICAgaWYgKG5leHRWYWx1ZSAhPT0gcHJldlZhbHVlKSB7XG4gICAgICAgICAgcnVsZS5wcm9wKHByb3AsIG5leHRWYWx1ZSwgZm9yY2VVcGRhdGVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZW1vdmUgcHJvcHMuXG5cblxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gc3R5bGUpIHtcbiAgICAgICAgdmFyIF9uZXh0VmFsdWUgPSBydWxlLnN0eWxlW19wcm9wXTtcbiAgICAgICAgdmFyIF9wcmV2VmFsdWUgPSBzdHlsZVtfcHJvcF07IC8vIFdlIG5lZWQgdG8gdXNlIGBmb3JjZTogdHJ1ZWAgYmVjYXVzZSBgcnVsZS5zdHlsZWAgaGFzIGJlZW4gdXBkYXRlZCBkdXJpbmcgb25VcGRhdGUgaG9vaywgc28gYHJ1bGUucHJvcCgpYCB3aWxsIG5vdCB1cGRhdGUgdGhlIENTU09NIHJ1bGUuXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgY29tcGFyaXNvbiB0byBhdm9pZCB1bm5lZWRlZCBgcnVsZS5wcm9wKClgIGNhbGxzLCBzaW5jZSB3ZSBoYXZlIHRoZSBvbGQgYHN0eWxlYCBvYmplY3QgaGVyZS5cblxuICAgICAgICBpZiAoX25leHRWYWx1ZSA9PSBudWxsICYmIF9uZXh0VmFsdWUgIT09IF9wcmV2VmFsdWUpIHtcbiAgICAgICAgICBydWxlLnByb3AoX3Byb3AsIG51bGwsIGZvcmNlVXBkYXRlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgcnVsZXMgdG8gYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcblxuICAgIHZhciBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMgPSBnZXRXaGl0ZXNwYWNlU3ltYm9scyhvcHRpb25zKSxcbiAgICAgICAgbGluZWJyZWFrID0gX2dldFdoaXRlc3BhY2VTeW1ib2xzLmxpbmVicmVhaztcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmluZGV4Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLmluZGV4W2luZGV4XTtcbiAgICAgIHZhciBjc3MgPSBydWxlLnRvU3RyaW5nKG9wdGlvbnMpOyAvLyBObyBuZWVkIHRvIHJlbmRlciBhbiBlbXB0eSBydWxlLlxuXG4gICAgICBpZiAoIWNzcyAmJiAhbGluaykgY29udGludWU7XG4gICAgICBpZiAoc3RyKSBzdHIgKz0gbGluZWJyZWFrO1xuICAgICAgc3RyICs9IGNzcztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHJldHVybiBSdWxlTGlzdDtcbn0oKTtcblxudmFyIFN0eWxlU2hlZXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHlsZVNoZWV0KHN0eWxlcywgb3B0aW9ucykge1xuICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlcGxveWVkID0gZmFsc2U7XG4gICAgdGhpcy5jbGFzc2VzID0ge307XG4gICAgdGhpcy5rZXlmcmFtZXMgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgc2hlZXQ6IHRoaXMsXG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBjbGFzc2VzOiB0aGlzLmNsYXNzZXMsXG4gICAgICBrZXlmcmFtZXM6IHRoaXMua2V5ZnJhbWVzXG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5SZW5kZXJlcikge1xuICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBvcHRpb25zLlJlbmRlcmVyKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QodGhpcy5vcHRpb25zKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZXNbbmFtZV0pO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2ggcmVuZGVyYWJsZSB0byB0aGUgcmVuZGVyIHRyZWUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5hdHRhY2ggPSBmdW5jdGlvbiBhdHRhY2goKSB7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHJldHVybiB0aGlzO1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyLmF0dGFjaCgpO1xuICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlOyAvLyBPcmRlciBpcyBpbXBvcnRhbnQsIGJlY2F1c2Ugd2UgY2FuJ3QgdXNlIGluc2VydFJ1bGUgQVBJIGlmIHN0eWxlIGVsZW1lbnQgaXMgbm90IGF0dGFjaGVkLlxuXG4gICAgaWYgKCF0aGlzLmRlcGxveWVkKSB0aGlzLmRlcGxveSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgcmVuZGVyYWJsZSBmcm9tIHJlbmRlciB0cmVlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgaWYgKCF0aGlzLmF0dGFjaGVkKSByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5yZW5kZXJlcikgdGhpcy5yZW5kZXJlci5kZXRhY2goKTtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIHJ1bGUgdG8gdGhlIGN1cnJlbnQgc3R5bGVzaGVldC5cbiAgICogV2lsbCBpbnNlcnQgYSBydWxlIGFsc28gYWZ0ZXIgdGhlIHN0eWxlc2hlZXQgaGFzIGJlZW4gcmVuZGVyZWQgZmlyc3QgdGltZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZSA9IGZ1bmN0aW9uIGFkZFJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWU7IC8vIFBsdWdpbnMgY2FuIGNyZWF0ZSBydWxlcy5cbiAgICAvLyBJbiBvcmRlciB0byBwcmVzZXJ2ZSB0aGUgcmlnaHQgb3JkZXIsIHdlIG5lZWQgdG8gcXVldWUgYWxsIGAuYWRkUnVsZWAgY2FsbHMsXG4gICAgLy8gd2hpY2ggaGFwcGVuIGFmdGVyIHRoZSBmaXJzdCBgcnVsZXMuYWRkKClgIGNhbGwuXG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhcXVldWUpIHRoaXMucXVldWUgPSBbXTtcbiAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuYWRkKG5hbWUsIGRlY2wsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgaWYgKCF0aGlzLmRlcGxveWVkKSByZXR1cm4gcnVsZTsgLy8gRG9uJ3QgaW5zZXJ0IHJ1bGUgZGlyZWN0bHkgaWYgdGhlcmUgaXMgbm8gc3RyaW5naWZpZWQgdmVyc2lvbiB5ZXQuXG4gICAgICAvLyBJdCB3aWxsIGJlIGluc2VydGVkIGFsbCB0b2dldGhlciB3aGVuIC5hdHRhY2ggaXMgY2FsbGVkLlxuXG4gICAgICBpZiAocXVldWUpIHF1ZXVlLnB1c2gocnVsZSk7ZWxzZSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcblxuICAgICAgICBpZiAodGhpcy5xdWV1ZSkge1xuICAgICAgICAgIHRoaXMucXVldWUuZm9yRWFjaCh0aGlzLmluc2VydFJ1bGUsIHRoaXMpO1xuICAgICAgICAgIHRoaXMucXVldWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydWxlO1xuICAgIH0gLy8gV2UgY2FuJ3QgYWRkIHJ1bGVzIHRvIGEgZGV0YWNoZWQgc3R5bGUgbm9kZS5cbiAgICAvLyBXZSB3aWxsIHJlZGVwbG95IHRoZSBzaGVldCBvbmNlIHVzZXIgd2lsbCBhdHRhY2ggaXQuXG5cblxuICAgIHRoaXMuZGVwbG95ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZSBhIHJ1bGUgaW4gdGhlIGN1cnJlbnQgc3R5bGVzaGVldC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVwbGFjZVJ1bGUgPSBmdW5jdGlvbiByZXBsYWNlUnVsZShuYW1lT3JTZWxlY3RvciwgZGVjbCwgb3B0aW9ucykge1xuICAgIHZhciBvbGRSdWxlID0gdGhpcy5ydWxlcy5nZXQobmFtZU9yU2VsZWN0b3IpO1xuICAgIGlmICghb2xkUnVsZSkgcmV0dXJuIHRoaXMuYWRkUnVsZShuYW1lT3JTZWxlY3RvciwgZGVjbCwgb3B0aW9ucyk7XG4gICAgdmFyIG5ld1J1bGUgPSB0aGlzLnJ1bGVzLnJlcGxhY2UobmFtZU9yU2VsZWN0b3IsIGRlY2wsIG9wdGlvbnMpO1xuXG4gICAgaWYgKG5ld1J1bGUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKG5ld1J1bGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICBpZiAoIXRoaXMuZGVwbG95ZWQpIHJldHVybiBuZXdSdWxlOyAvLyBEb24ndCByZXBsYWNlIC8gZGVsZXRlIHJ1bGUgZGlyZWN0bHkgaWYgdGhlcmUgaXMgbm8gc3RyaW5naWZpZWQgdmVyc2lvbiB5ZXQuXG4gICAgICAvLyBJdCB3aWxsIGJlIGluc2VydGVkIGFsbCB0b2dldGhlciB3aGVuIC5hdHRhY2ggaXMgY2FsbGVkLlxuXG4gICAgICBpZiAodGhpcy5yZW5kZXJlcikge1xuICAgICAgICBpZiAoIW5ld1J1bGUpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLmRlbGV0ZVJ1bGUob2xkUnVsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAob2xkUnVsZS5yZW5kZXJhYmxlKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5yZXBsYWNlUnVsZShvbGRSdWxlLnJlbmRlcmFibGUsIG5ld1J1bGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdSdWxlO1xuICAgIH0gLy8gV2UgY2FuJ3QgcmVwbGFjZSBydWxlcyB0byBhIGRldGFjaGVkIHN0eWxlIG5vZGUuXG4gICAgLy8gV2Ugd2lsbCByZWRlcGxveSB0aGUgc2hlZXQgb25jZSB1c2VyIHdpbGwgYXR0YWNoIGl0LlxuXG5cbiAgICB0aGlzLmRlcGxveWVkID0gZmFsc2U7XG4gICAgcmV0dXJuIG5ld1J1bGU7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBydWxlIGludG8gdGhlIFN0eWxlU2hlZXRcbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIGluc2VydFJ1bGUocnVsZSkge1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmluc2VydFJ1bGUocnVsZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIGFkZCBydWxlcy5cbiAgICogV2lsbCByZW5kZXIgYWxzbyBhZnRlciBTdHlsZSBTaGVldCB3YXMgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZFJ1bGVzID0gZnVuY3Rpb24gYWRkUnVsZXMoc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIGFkZGVkID0gW107XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLmFkZFJ1bGUobmFtZSwgc3R5bGVzW25hbWVdLCBvcHRpb25zKTtcbiAgICAgIGlmIChydWxlKSBhZGRlZC5wdXNoKHJ1bGUpO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRlZDtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgcnVsZSBieSBuYW1lIG9yIHNlbGVjdG9yLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRSdWxlID0gZnVuY3Rpb24gZ2V0UnVsZShuYW1lT3JTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmdldChuYW1lT3JTZWxlY3Rvcik7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHJ1bGUgYnkgbmFtZS5cbiAgICogUmV0dXJucyBgdHJ1ZWA6IGlmIHJ1bGUgaGFzIGJlZW4gZGVsZXRlZCBmcm9tIHRoZSBET00uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiBkZWxldGVSdWxlKG5hbWUpIHtcbiAgICB2YXIgcnVsZSA9IHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JyA/IG5hbWUgOiB0aGlzLnJ1bGVzLmdldChuYW1lKTtcblxuICAgIGlmICghcnVsZSB8fCAvLyBTdHlsZSBzaGVldCB3YXMgY3JlYXRlZCB3aXRob3V0IGxpbms6IHRydWUgYW5kIGF0dGFjaGVkLCBpbiB0aGlzIGNhc2Ugd2VcbiAgICAvLyB3b24ndCBiZSBhYmxlIHRvIHJlbW92ZSB0aGUgQ1NTIHJ1bGUgZnJvbSB0aGUgRE9NLlxuICAgIHRoaXMuYXR0YWNoZWQgJiYgIXJ1bGUucmVuZGVyYWJsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucmVtb3ZlKHJ1bGUpO1xuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQgJiYgcnVsZS5yZW5kZXJhYmxlICYmIHRoaXMucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmRlbGV0ZVJ1bGUocnVsZS5yZW5kZXJhYmxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YocnVsZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmluZGV4T2YocnVsZSk7XG4gIH1cbiAgLyoqXG4gICAqIERlcGxveSBwdXJlIENTUyBzdHJpbmcgdG8gYSByZW5kZXJhYmxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXBsb3kgPSBmdW5jdGlvbiBkZXBsb3koKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHRoaXMucmVuZGVyZXIuZGVwbG95KCk7XG4gICAgdGhpcy5kZXBsb3llZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZnVuY3Rpb24gdmFsdWVzIHdpdGggYSBuZXcgZGF0YS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBfdGhpcyRydWxlcztcblxuICAgIChfdGhpcyRydWxlcyA9IHRoaXMucnVsZXMpLnVwZGF0ZS5hcHBseShfdGhpcyRydWxlcywgYXJndW1lbnRzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgc2luZ2xlIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZU9uZSA9IGZ1bmN0aW9uIHVwZGF0ZU9uZShydWxlLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgdGhpcy5ydWxlcy51cGRhdGVPbmUocnVsZSwgZGF0YSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgcnVsZXMgdG8gYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy50b1N0cmluZyhvcHRpb25zKTtcbiAgfTtcblxuICByZXR1cm4gU3R5bGVTaGVldDtcbn0oKTtcblxudmFyIFBsdWdpbnNSZWdpc3RyeSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBsdWdpbnNSZWdpc3RyeSgpIHtcbiAgICB0aGlzLnBsdWdpbnMgPSB7XG4gICAgICBpbnRlcm5hbDogW10sXG4gICAgICBleHRlcm5hbDogW11cbiAgICB9O1xuICAgIHRoaXMucmVnaXN0cnkgPSB7fTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQbHVnaW5zUmVnaXN0cnkucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBDYWxsIGBvbkNyZWF0ZVJ1bGVgIGhvb2tzIGFuZCByZXR1cm4gYW4gb2JqZWN0IGlmIHJldHVybmVkIGJ5IGEgaG9vay5cbiAgICovXG4gIF9wcm90by5vbkNyZWF0ZVJ1bGUgPSBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vbkNyZWF0ZVJ1bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBydWxlID0gdGhpcy5yZWdpc3RyeS5vbkNyZWF0ZVJ1bGVbaV0obmFtZSwgZGVjbCwgb3B0aW9ucyk7XG4gICAgICBpZiAocnVsZSkgcmV0dXJuIHJ1bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uUHJvY2Vzc1J1bGVgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblByb2Nlc3NSdWxlID0gZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlKSB7XG4gICAgaWYgKHJ1bGUuaXNQcm9jZXNzZWQpIHJldHVybjtcbiAgICB2YXIgc2hlZXQgPSBydWxlLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzUnVsZS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NSdWxlW2ldKHJ1bGUsIHNoZWV0KTtcbiAgICB9XG5cbiAgICBpZiAocnVsZS5zdHlsZSkgdGhpcy5vblByb2Nlc3NTdHlsZShydWxlLnN0eWxlLCBydWxlLCBzaGVldCk7XG4gICAgcnVsZS5pc1Byb2Nlc3NlZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uUHJvY2Vzc1N0eWxlYCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25Qcm9jZXNzU3R5bGUgPSBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSwgc2hlZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzU3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJ1bGUuc3R5bGUgPSB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1N0eWxlW2ldKHJ1bGUuc3R5bGUsIHJ1bGUsIHNoZWV0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uUHJvY2Vzc1NoZWV0YCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25Qcm9jZXNzU2hlZXQgPSBmdW5jdGlvbiBvblByb2Nlc3NTaGVldChzaGVldCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NTaGVldC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NTaGVldFtpXShzaGVldCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsIGBvblVwZGF0ZWAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uVXBkYXRlID0gZnVuY3Rpb24gb25VcGRhdGUoZGF0YSwgcnVsZSwgc2hlZXQsIG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucmVnaXN0cnkub25VcGRhdGVbaV0oZGF0YSwgcnVsZSwgc2hlZXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25DaGFuZ2VWYWx1ZWAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uQ2hhbmdlVmFsdWUgPSBmdW5jdGlvbiBvbkNoYW5nZVZhbHVlKHZhbHVlLCBwcm9wLCBydWxlKSB7XG4gICAgdmFyIHByb2Nlc3NlZFZhbHVlID0gdmFsdWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25DaGFuZ2VWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvY2Vzc2VkVmFsdWUgPSB0aGlzLnJlZ2lzdHJ5Lm9uQ2hhbmdlVmFsdWVbaV0ocHJvY2Vzc2VkVmFsdWUsIHByb3AsIHJ1bGUpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9jZXNzZWRWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBwbHVnaW4uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVzZSA9IGZ1bmN0aW9uIHVzZShuZXdQbHVnaW4sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBxdWV1ZTogJ2V4dGVybmFsJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcGx1Z2lucyA9IHRoaXMucGx1Z2luc1tvcHRpb25zLnF1ZXVlXTsgLy8gQXZvaWRzIGFwcGx5aW5nIHNhbWUgcGx1Z2luIHR3aWNlLCBhdCBsZWFzdCBiYXNlZCBvbiByZWYuXG5cbiAgICBpZiAocGx1Z2lucy5pbmRleE9mKG5ld1BsdWdpbikgIT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGx1Z2lucy5wdXNoKG5ld1BsdWdpbik7XG4gICAgdGhpcy5yZWdpc3RyeSA9IFtdLmNvbmNhdCh0aGlzLnBsdWdpbnMuZXh0ZXJuYWwsIHRoaXMucGx1Z2lucy5pbnRlcm5hbCkucmVkdWNlKGZ1bmN0aW9uIChyZWdpc3RyeSwgcGx1Z2luKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHBsdWdpbikge1xuICAgICAgICBpZiAobmFtZSBpbiByZWdpc3RyeSkge1xuICAgICAgICAgIHJlZ2lzdHJ5W25hbWVdLnB1c2gocGx1Z2luW25hbWVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFVua25vd24gaG9vayBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVnaXN0cnk7XG4gICAgfSwge1xuICAgICAgb25DcmVhdGVSdWxlOiBbXSxcbiAgICAgIG9uUHJvY2Vzc1J1bGU6IFtdLFxuICAgICAgb25Qcm9jZXNzU3R5bGU6IFtdLFxuICAgICAgb25Qcm9jZXNzU2hlZXQ6IFtdLFxuICAgICAgb25DaGFuZ2VWYWx1ZTogW10sXG4gICAgICBvblVwZGF0ZTogW11cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gUGx1Z2luc1JlZ2lzdHJ5O1xufSgpO1xuXG4vKipcbiAqIFNoZWV0cyByZWdpc3RyeSB0byBhY2Nlc3MgYWxsIGluc3RhbmNlcyBpbiBvbmUgcGxhY2UuXG4gKi9cblxudmFyIFNoZWV0c1JlZ2lzdHJ5ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2hlZXRzUmVnaXN0cnkoKSB7XG4gICAgdGhpcy5yZWdpc3RyeSA9IFtdO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNoZWV0c1JlZ2lzdHJ5LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBTdHlsZSBTaGVldC5cbiAgICovXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoc2hlZXQpIHtcbiAgICB2YXIgcmVnaXN0cnkgPSB0aGlzLnJlZ2lzdHJ5O1xuICAgIHZhciBpbmRleCA9IHNoZWV0Lm9wdGlvbnMuaW5kZXg7XG4gICAgaWYgKHJlZ2lzdHJ5LmluZGV4T2Yoc2hlZXQpICE9PSAtMSkgcmV0dXJuO1xuXG4gICAgaWYgKHJlZ2lzdHJ5Lmxlbmd0aCA9PT0gMCB8fCBpbmRleCA+PSB0aGlzLmluZGV4KSB7XG4gICAgICByZWdpc3RyeS5wdXNoKHNoZWV0KTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZpbmQgYSBwb3NpdGlvbi5cblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyeS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlZ2lzdHJ5W2ldLm9wdGlvbnMuaW5kZXggPiBpbmRleCkge1xuICAgICAgICByZWdpc3RyeS5zcGxpY2UoaSwgMCwgc2hlZXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXNldCB0aGUgcmVnaXN0cnkuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5yZWdpc3RyeSA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYSBTdHlsZSBTaGVldC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHNoZWV0KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5yZWdpc3RyeS5pbmRleE9mKHNoZWV0KTtcbiAgICB0aGlzLnJlZ2lzdHJ5LnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgYWxsIGF0dGFjaGVkIHNoZWV0cyB0byBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoX3RlbXApIHtcbiAgICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICBhdHRhY2hlZCA9IF9yZWYuYXR0YWNoZWQsXG4gICAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJhdHRhY2hlZFwiXSk7XG5cbiAgICB2YXIgX2dldFdoaXRlc3BhY2VTeW1ib2xzID0gZ2V0V2hpdGVzcGFjZVN5bWJvbHMob3B0aW9ucyksXG4gICAgICAgIGxpbmVicmVhayA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5saW5lYnJlYWs7XG5cbiAgICB2YXIgY3NzID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzaGVldCA9IHRoaXMucmVnaXN0cnlbaV07XG5cbiAgICAgIGlmIChhdHRhY2hlZCAhPSBudWxsICYmIHNoZWV0LmF0dGFjaGVkICE9PSBhdHRhY2hlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNzcykgY3NzICs9IGxpbmVicmVhaztcbiAgICAgIGNzcyArPSBzaGVldC50b1N0cmluZyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTaGVldHNSZWdpc3RyeSwgW3tcbiAgICBrZXk6IFwiaW5kZXhcIixcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaGlnaGVzdCBpbmRleCBudW1iZXIuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5sZW5ndGggPT09IDAgPyAwIDogdGhpcy5yZWdpc3RyeVt0aGlzLnJlZ2lzdHJ5Lmxlbmd0aCAtIDFdLm9wdGlvbnMuaW5kZXg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNoZWV0c1JlZ2lzdHJ5O1xufSgpO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBnbG9iYWwgc2hlZXRzIHJlZ2lzdHJ5LiBPbmx5IERvbVJlbmRlcmVyIHdpbGwgYWRkIHNoZWV0cyB0byBpdC5cbiAqIE9uIHRoZSBzZXJ2ZXIgb25lIHNob3VsZCB1c2UgYW4gb3duIFNoZWV0c1JlZ2lzdHJ5IGluc3RhbmNlIGFuZCBhZGQgdGhlXG4gKiBzaGVldHMgdG8gaXQsIGJlY2F1c2UgeW91IG5lZWQgdG8gbWFrZSBzdXJlIHRvIGNyZWF0ZSBhIG5ldyByZWdpc3RyeSBmb3JcbiAqIGVhY2ggcmVxdWVzdCBpbiBvcmRlciB0byBub3QgbGVhayBzaGVldHMgYWNyb3NzIHJlcXVlc3RzLlxuICovXG5cbnZhciBzaGVldHMgPSBuZXcgU2hlZXRzUmVnaXN0cnkoKTtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuLyoqXG4gKiBOb3cgdGhhdCBgZ2xvYmFsVGhpc2AgaXMgYXZhaWxhYmxlIG9uIG1vc3QgcGxhdGZvcm1zXG4gKiAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvZ2xvYmFsVGhpcyNicm93c2VyX2NvbXBhdGliaWxpdHkpXG4gKiB3ZSBjaGVjayBmb3IgYGdsb2JhbFRoaXNgIGZpcnN0LiBgZ2xvYmFsVGhpc2AgaXMgbmVjZXNzYXJ5IGZvciBqc3NcbiAqIHRvIHJ1biBpbiBBZ29yaWMncyBzZWN1cmUgdmVyc2lvbiBvZiBKYXZhU2NyaXB0IChTRVMpLiBVbmRlciBTRVMsXG4gKiBgZ2xvYmFsVGhpc2AgZXhpc3RzLCBidXQgYHdpbmRvd2AsIGBzZWxmYCwgYW5kIGBGdW5jdGlvbigncmV0dXJuXG4gKiB0aGlzJykoKWAgYXJlIGFsbCB1bmRlZmluZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbiAqL1xudmFyIGdsb2JhbFRoaXMkMSA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PT0gTWF0aCA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIG5zID0gJzJmMWFjYzZjM2E2MDZiMDgyZTVlZWY1ZTU0NDE0ZmZiJztcbmlmIChnbG9iYWxUaGlzJDFbbnNdID09IG51bGwpIGdsb2JhbFRoaXMkMVtuc10gPSAwOyAvLyBCdW5kbGUgbWF5IGNvbnRhaW4gbXVsdGlwbGUgSlNTIHZlcnNpb25zIGF0IHRoZSBzYW1lIHRpbWUuIEluIG9yZGVyIHRvIGlkZW50aWZ5XG4vLyB0aGUgY3VycmVudCB2ZXJzaW9uIHdpdGgganVzdCBvbmUgc2hvcnQgbnVtYmVyIGFuZCB1c2UgaXQgZm9yIGNsYXNzZXMgZ2VuZXJhdGlvblxuLy8gd2UgdXNlIGEgY291bnRlci4gQWxzbyBpdCBpcyBtb3JlIGFjY3VyYXRlLCBiZWNhdXNlIHVzZXIgY2FuIG1hbnVhbGx5IHJlZXZhbHVhdGVcbi8vIHRoZSBtb2R1bGUuXG5cbnZhciBtb2R1bGVJZCA9IGdsb2JhbFRoaXMkMVtuc10rKztcblxudmFyIG1heFJ1bGVzID0gMWUxMDtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlcyB1bmlxdWUgY2xhc3MgbmFtZXMgYmFzZWQgb24gY291bnRlcnMuXG4gKiBXaGVuIG5ldyBnZW5lcmF0b3IgZnVuY3Rpb24gaXMgY3JlYXRlZCwgcnVsZSBjb3VudGVyIGlzIHJlc2V0ZWQuXG4gKiBXZSBuZWVkIHRvIHJlc2V0IHRoZSBydWxlIGNvdW50ZXIgZm9yIFNTUiBmb3IgZWFjaCByZXF1ZXN0LlxuICovXG5cbnZhciBjcmVhdGVHZW5lcmF0ZUlkID0gZnVuY3Rpb24gY3JlYXRlR2VuZXJhdGVJZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgcnVsZUNvdW50ZXIgPSAwO1xuXG4gIHZhciBnZW5lcmF0ZUlkID0gZnVuY3Rpb24gZ2VuZXJhdGVJZChydWxlLCBzaGVldCkge1xuICAgIHJ1bGVDb3VudGVyICs9IDE7XG5cbiAgICBpZiAocnVsZUNvdW50ZXIgPiBtYXhSdWxlcykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBZb3UgbWlnaHQgaGF2ZSBhIG1lbW9yeSBsZWFrLiBSdWxlIGNvdW50ZXIgaXMgYXQgXCIgKyBydWxlQ291bnRlciArIFwiLlwiKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIganNzSWQgPSAnJztcbiAgICB2YXIgcHJlZml4ID0gJyc7XG5cbiAgICBpZiAoc2hlZXQpIHtcbiAgICAgIGlmIChzaGVldC5vcHRpb25zLmNsYXNzTmFtZVByZWZpeCkge1xuICAgICAgICBwcmVmaXggPSBzaGVldC5vcHRpb25zLmNsYXNzTmFtZVByZWZpeDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoZWV0Lm9wdGlvbnMuanNzLmlkICE9IG51bGwpIHtcbiAgICAgICAganNzSWQgPSBTdHJpbmcoc2hlZXQub3B0aW9ucy5qc3MuaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm1pbmlmeSkge1xuICAgICAgLy8gVXNpbmcgXCJjXCIgYmVjYXVzZSBhIG51bWJlciBjYW4ndCBiZSB0aGUgZmlyc3QgY2hhciBpbiBhIGNsYXNzIG5hbWUuXG4gICAgICByZXR1cm4gXCJcIiArIChwcmVmaXggfHwgJ2MnKSArIG1vZHVsZUlkICsganNzSWQgKyBydWxlQ291bnRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlZml4ICsgcnVsZS5rZXkgKyBcIi1cIiArIG1vZHVsZUlkICsgKGpzc0lkID8gXCItXCIgKyBqc3NJZCA6ICcnKSArIFwiLVwiICsgcnVsZUNvdW50ZXI7XG4gIH07XG5cbiAgcmV0dXJuIGdlbmVyYXRlSWQ7XG59O1xuXG4vKipcbiAqIENhY2hlIHRoZSB2YWx1ZSBmcm9tIHRoZSBmaXJzdCB0aW1lIGEgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICovXG5cbnZhciBtZW1vaXplID0gZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICB2YXIgdmFsdWU7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF2YWx1ZSkgdmFsdWUgPSBmbigpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn07XG4vKipcbiAqIEdldCBhIHN0eWxlIHByb3BlcnR5IHZhbHVlLlxuICovXG5cblxudmFyIGdldFByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0eVZhbHVlKGNzc1J1bGUsIHByb3ApIHtcbiAgdHJ5IHtcbiAgICAvLyBTdXBwb3J0IENTU1RPTS5cbiAgICBpZiAoY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcCkge1xuICAgICAgcmV0dXJuIGNzc1J1bGUuYXR0cmlidXRlU3R5bGVNYXAuZ2V0KHByb3ApO1xuICAgIH1cblxuICAgIHJldHVybiBjc3NSdWxlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElFIG1heSB0aHJvdyBpZiBwcm9wZXJ0eSBpcyB1bmtub3duLlxuICAgIHJldHVybiAnJztcbiAgfVxufTtcbi8qKlxuICogU2V0IGEgc3R5bGUgcHJvcGVydHkuXG4gKi9cblxuXG52YXIgc2V0UHJvcGVydHkgPSBmdW5jdGlvbiBzZXRQcm9wZXJ0eShjc3NSdWxlLCBwcm9wLCB2YWx1ZSkge1xuICB0cnkge1xuICAgIHZhciBjc3NWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBjc3NWYWx1ZSA9IHRvQ3NzVmFsdWUodmFsdWUpO1xuICAgIH0gLy8gU3VwcG9ydCBDU1NUT00uXG5cblxuICAgIGlmIChjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwKSB7XG4gICAgICBjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwLnNldChwcm9wLCBjc3NWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpbmRleE9mSW1wb3J0YW50RmxhZyA9IGNzc1ZhbHVlID8gY3NzVmFsdWUuaW5kZXhPZignIWltcG9ydGFudCcpIDogLTE7XG4gICAgICB2YXIgY3NzVmFsdWVXaXRob3V0SW1wb3J0YW50RmxhZyA9IGluZGV4T2ZJbXBvcnRhbnRGbGFnID4gLTEgPyBjc3NWYWx1ZS5zdWJzdHIoMCwgaW5kZXhPZkltcG9ydGFudEZsYWcgLSAxKSA6IGNzc1ZhbHVlO1xuICAgICAgY3NzUnVsZS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBjc3NWYWx1ZVdpdGhvdXRJbXBvcnRhbnRGbGFnLCBpbmRleE9mSW1wb3J0YW50RmxhZyA+IC0xID8gJ2ltcG9ydGFudCcgOiAnJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJRSBtYXkgdGhyb3cgaWYgcHJvcGVydHkgaXMgdW5rbm93bi5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIFJlbW92ZSBhIHN0eWxlIHByb3BlcnR5LlxuICovXG5cblxudmFyIHJlbW92ZVByb3BlcnR5ID0gZnVuY3Rpb24gcmVtb3ZlUHJvcGVydHkoY3NzUnVsZSwgcHJvcCkge1xuICB0cnkge1xuICAgIC8vIFN1cHBvcnQgQ1NTVE9NLlxuICAgIGlmIChjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwKSB7XG4gICAgICBjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwLmRlbGV0ZShwcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3NzUnVsZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gRE9NRXhjZXB0aW9uIFxcXCJcIiArIGVyci5tZXNzYWdlICsgXCJcXFwiIHdhcyB0aHJvd24uIFRyaWVkIHRvIHJlbW92ZSBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wICsgXCJcXFwiLlwiKSA6IHZvaWQgMDtcbiAgfVxufTtcbi8qKlxuICogU2V0IHRoZSBzZWxlY3Rvci5cbiAqL1xuXG5cbnZhciBzZXRTZWxlY3RvciA9IGZ1bmN0aW9uIHNldFNlbGVjdG9yKGNzc1J1bGUsIHNlbGVjdG9yVGV4dCkge1xuICBjc3NSdWxlLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yVGV4dDsgLy8gUmV0dXJuIGZhbHNlIGlmIHNldHRlciB3YXMgbm90IHN1Y2Nlc3NmdWwuXG4gIC8vIEN1cnJlbnRseSB3b3JrcyBpbiBjaHJvbWUgb25seS5cblxuICByZXR1cm4gY3NzUnVsZS5zZWxlY3RvclRleHQgPT09IHNlbGVjdG9yVGV4dDtcbn07XG4vKipcbiAqIEdldHMgdGhlIGBoZWFkYCBlbGVtZW50IHVwb24gdGhlIGZpcnN0IGNhbGwgYW5kIGNhY2hlcyBpdC5cbiAqIFdlIGFzc3VtZSBpdCBjYW4ndCBiZSBudWxsLlxuICovXG5cblxudmFyIGdldEhlYWQgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKTtcbn0pO1xuLyoqXG4gKiBGaW5kIGF0dGFjaGVkIHNoZWV0IHdpdGggYW4gaW5kZXggaGlnaGVyIHRoYW4gdGhlIHBhc3NlZCBvbmUuXG4gKi9cblxuZnVuY3Rpb24gZmluZEhpZ2hlclNoZWV0KHJlZ2lzdHJ5LCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cnkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2hlZXQgPSByZWdpc3RyeVtpXTtcblxuICAgIGlmIChzaGVldC5hdHRhY2hlZCAmJiBzaGVldC5vcHRpb25zLmluZGV4ID4gb3B0aW9ucy5pbmRleCAmJiBzaGVldC5vcHRpb25zLmluc2VydGlvblBvaW50ID09PSBvcHRpb25zLmluc2VydGlvblBvaW50KSB7XG4gICAgICByZXR1cm4gc2hlZXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEZpbmQgYXR0YWNoZWQgc2hlZXQgd2l0aCB0aGUgaGlnaGVzdCBpbmRleC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmRIaWdoZXN0U2hlZXQocmVnaXN0cnksIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IHJlZ2lzdHJ5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHNoZWV0ID0gcmVnaXN0cnlbaV07XG5cbiAgICBpZiAoc2hlZXQuYXR0YWNoZWQgJiYgc2hlZXQub3B0aW9ucy5pbnNlcnRpb25Qb2ludCA9PT0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludCkge1xuICAgICAgcmV0dXJuIHNoZWV0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBGaW5kIGEgY29tbWVudCB3aXRoIFwianNzXCIgaW5zaWRlLlxuICovXG5cblxuZnVuY3Rpb24gZmluZENvbW1lbnROb2RlKHRleHQpIHtcbiAgdmFyIGhlYWQgPSBnZXRIZWFkKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGhlYWQuY2hpbGROb2Rlc1tpXTtcblxuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4ICYmIG5vZGUubm9kZVZhbHVlLnRyaW0oKSA9PT0gdGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEZpbmQgYSBub2RlIGJlZm9yZSB3aGljaCB3ZSBjYW4gaW5zZXJ0IHRoZSBzaGVldC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmRQcmV2Tm9kZShvcHRpb25zKSB7XG4gIHZhciByZWdpc3RyeSA9IHNoZWV0cy5yZWdpc3RyeTtcblxuICBpZiAocmVnaXN0cnkubGVuZ3RoID4gMCkge1xuICAgIC8vIFRyeSB0byBpbnNlcnQgYmVmb3JlIHRoZSBuZXh0IGhpZ2hlciBzaGVldC5cbiAgICB2YXIgc2hlZXQgPSBmaW5kSGlnaGVyU2hlZXQocmVnaXN0cnksIG9wdGlvbnMpO1xuXG4gICAgaWYgKHNoZWV0ICYmIHNoZWV0LnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJlbnQ6IHNoZWV0LnJlbmRlcmVyLmVsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgbm9kZTogc2hlZXQucmVuZGVyZXIuZWxlbWVudFxuICAgICAgfTtcbiAgICB9IC8vIE90aGVyd2lzZSBpbnNlcnQgYWZ0ZXIgdGhlIGxhc3QgYXR0YWNoZWQuXG5cblxuICAgIHNoZWV0ID0gZmluZEhpZ2hlc3RTaGVldChyZWdpc3RyeSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoc2hlZXQgJiYgc2hlZXQucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcmVudDogc2hlZXQucmVuZGVyZXIuZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgICBub2RlOiBzaGVldC5yZW5kZXJlci5lbGVtZW50Lm5leHRTaWJsaW5nXG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBUcnkgdG8gZmluZCBhIGNvbW1lbnQgcGxhY2Vob2xkZXIgaWYgcmVnaXN0cnkgaXMgZW1wdHkuXG5cblxuICB2YXIgaW5zZXJ0aW9uUG9pbnQgPSBvcHRpb25zLmluc2VydGlvblBvaW50O1xuXG4gIGlmIChpbnNlcnRpb25Qb2ludCAmJiB0eXBlb2YgaW5zZXJ0aW9uUG9pbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGNvbW1lbnQgPSBmaW5kQ29tbWVudE5vZGUoaW5zZXJ0aW9uUG9pbnQpO1xuXG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcmVudDogY29tbWVudC5wYXJlbnROb2RlLFxuICAgICAgICBub2RlOiBjb21tZW50Lm5leHRTaWJsaW5nXG4gICAgICB9O1xuICAgIH0gLy8gSWYgdXNlciBzcGVjaWZpZXMgYW4gaW5zZXJ0aW9uIHBvaW50IGFuZCBpdCBjYW4ndCBiZSBmb3VuZCBpbiB0aGUgZG9jdW1lbnQgLVxuICAgIC8vIGJhZCBzcGVjaWZpY2l0eSBpc3N1ZXMgbWF5IGFwcGVhci5cblxuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBJbnNlcnRpb24gcG9pbnQgXFxcIlwiICsgaW5zZXJ0aW9uUG9pbnQgKyBcIlxcXCIgbm90IGZvdW5kLlwiKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogSW5zZXJ0IHN0eWxlIGVsZW1lbnQgaW50byB0aGUgRE9NLlxuICovXG5cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGUoc3R5bGUsIG9wdGlvbnMpIHtcbiAgdmFyIGluc2VydGlvblBvaW50ID0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludDtcbiAgdmFyIG5leHROb2RlID0gZmluZFByZXZOb2RlKG9wdGlvbnMpO1xuXG4gIGlmIChuZXh0Tm9kZSAhPT0gZmFsc2UgJiYgbmV4dE5vZGUucGFyZW50KSB7XG4gICAgbmV4dE5vZGUucGFyZW50Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dE5vZGUubm9kZSk7XG4gICAgcmV0dXJuO1xuICB9IC8vIFdvcmtzIHdpdGggaWZyYW1lcyBhbmQgYW55IG5vZGUgdHlwZXMuXG5cblxuICBpZiAoaW5zZXJ0aW9uUG9pbnQgJiYgdHlwZW9mIGluc2VydGlvblBvaW50Lm5vZGVUeXBlID09PSAnbnVtYmVyJykge1xuICAgIHZhciBpbnNlcnRpb25Qb2ludEVsZW1lbnQgPSBpbnNlcnRpb25Qb2ludDtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IGluc2VydGlvblBvaW50RWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLmluc2VydEJlZm9yZShzdHlsZSwgaW5zZXJ0aW9uUG9pbnRFbGVtZW50Lm5leHRTaWJsaW5nKTtlbHNlIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICdbSlNTXSBJbnNlcnRpb24gcG9pbnQgaXMgbm90IGluIHRoZSBET00uJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZ2V0SGVhZCgpLmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cbi8qKlxuICogUmVhZCBqc3Mgbm9uY2Ugc2V0dGluZyBmcm9tIHRoZSBwYWdlIGlmIHRoZSB1c2VyIGhhcyBzZXQgaXQuXG4gKi9cblxuXG52YXIgZ2V0Tm9uY2UgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW3Byb3BlcnR5PVwiY3NwLW5vbmNlXCJdJyk7XG4gIHJldHVybiBub2RlID8gbm9kZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKSA6IG51bGw7XG59KTtcblxudmFyIF9pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShjb250YWluZXIsIHJ1bGUsIGluZGV4KSB7XG4gIHRyeSB7XG4gICAgaWYgKCdpbnNlcnRSdWxlJyBpbiBjb250YWluZXIpIHtcbiAgICAgIGNvbnRhaW5lci5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICB9IC8vIEtleWZyYW1lcyBydWxlLlxuICAgIGVsc2UgaWYgKCdhcHBlbmRSdWxlJyBpbiBjb250YWluZXIpIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZFJ1bGUocnVsZSk7XG4gICAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gXCIgKyBlcnIubWVzc2FnZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRhaW5lci5jc3NSdWxlc1tpbmRleF07XG59O1xuXG52YXIgZ2V0VmFsaWRSdWxlSW5zZXJ0aW9uSW5kZXggPSBmdW5jdGlvbiBnZXRWYWxpZFJ1bGVJbnNlcnRpb25JbmRleChjb250YWluZXIsIGluZGV4KSB7XG4gIHZhciBtYXhJbmRleCA9IGNvbnRhaW5lci5jc3NSdWxlcy5sZW5ndGg7IC8vIEluIGNhc2UgcHJldmlvdXMgaW5zZXJ0aW9uIGZhaWxzLCBwYXNzZWQgaW5kZXggbWlnaHQgYmUgd3JvbmdcblxuICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCB8fCBpbmRleCA+IG1heEluZGV4KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcmV0dXJuIG1heEluZGV4O1xuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufTtcblxudmFyIGNyZWF0ZVN0eWxlID0gZnVuY3Rpb24gY3JlYXRlU3R5bGUoKSB7XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7IC8vIFdpdGhvdXQgaXQsIElFIHdpbGwgaGF2ZSBhIGJyb2tlbiBzb3VyY2Ugb3JkZXIgc3BlY2lmaWNpdHkgaWYgd2VcbiAgLy8gaW5zZXJ0IHJ1bGVzIGFmdGVyIHdlIGluc2VydCB0aGUgc3R5bGUgdGFnLlxuICAvLyBJdCBzZWVtcyB0byBraWNrLW9mZiB0aGUgc291cmNlIG9yZGVyIHNwZWNpZmljaXR5IGFsZ29yaXRobS5cblxuICBlbC50ZXh0Q29udGVudCA9ICdcXG4nO1xuICByZXR1cm4gZWw7XG59O1xuXG52YXIgRG9tUmVuZGVyZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvLyBXaWxsIGJlIGVtcHR5IGlmIGxpbms6IHRydWUgb3B0aW9uIGlzIG5vdCBzZXQsIGJlY2F1c2VcbiAgLy8gaXQgaXMgb25seSBmb3IgdXNlIHRvZ2V0aGVyIHdpdGggaW5zZXJ0UnVsZSBBUEkuXG4gIGZ1bmN0aW9uIERvbVJlbmRlcmVyKHNoZWV0KSB7XG4gICAgdGhpcy5nZXRQcm9wZXJ0eVZhbHVlID0gZ2V0UHJvcGVydHlWYWx1ZTtcbiAgICB0aGlzLnNldFByb3BlcnR5ID0gc2V0UHJvcGVydHk7XG4gICAgdGhpcy5yZW1vdmVQcm9wZXJ0eSA9IHJlbW92ZVByb3BlcnR5O1xuICAgIHRoaXMuc2V0U2VsZWN0b3IgPSBzZXRTZWxlY3RvcjtcbiAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSBmYWxzZTtcbiAgICB0aGlzLmNzc1J1bGVzID0gW107XG4gICAgLy8gVGhlcmUgaXMgbm8gc2hlZXQgd2hlbiB0aGUgcmVuZGVyZXIgaXMgdXNlZCBmcm9tIGEgc3RhbmRhbG9uZSBTdHlsZVJ1bGUuXG4gICAgaWYgKHNoZWV0KSBzaGVldHMuYWRkKHNoZWV0KTtcbiAgICB0aGlzLnNoZWV0ID0gc2hlZXQ7XG5cbiAgICB2YXIgX3JlZiA9IHRoaXMuc2hlZXQgPyB0aGlzLnNoZWV0Lm9wdGlvbnMgOiB7fSxcbiAgICAgICAgbWVkaWEgPSBfcmVmLm1lZGlhLFxuICAgICAgICBtZXRhID0gX3JlZi5tZXRhLFxuICAgICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50O1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudCB8fCBjcmVhdGVTdHlsZSgpO1xuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtanNzJywgJycpO1xuICAgIGlmIChtZWRpYSkgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gICAgaWYgKG1ldGEpIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbWV0YScsIG1ldGEpO1xuICAgIHZhciBub25jZSA9IGdldE5vbmNlKCk7XG4gICAgaWYgKG5vbmNlKSB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IHN0eWxlIGVsZW1lbnQgaW50byByZW5kZXIgdHJlZS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gRG9tUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5hdHRhY2ggPSBmdW5jdGlvbiBhdHRhY2goKSB7XG4gICAgLy8gSW4gdGhlIGNhc2UgdGhlIGVsZW1lbnQgbm9kZSBpcyBleHRlcm5hbCBhbmQgaXQgaXMgYWxyZWFkeSBpbiB0aGUgRE9NLlxuICAgIGlmICh0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSB8fCAhdGhpcy5zaGVldCkgcmV0dXJuO1xuICAgIGluc2VydFN0eWxlKHRoaXMuZWxlbWVudCwgdGhpcy5zaGVldC5vcHRpb25zKTsgLy8gV2hlbiBydWxlcyBhcmUgaW5zZXJ0ZWQgdXNpbmcgYGluc2VydFJ1bGVgIEFQSSwgYWZ0ZXIgYHNoZWV0LmRldGFjaCgpLmF0dGFjaCgpYFxuICAgIC8vIG1vc3QgYnJvd3NlcnMgY3JlYXRlIGEgbmV3IENTU1N0eWxlU2hlZXQsIGV4Y2VwdCBvZiBhbGwgSUVzLlxuXG4gICAgdmFyIGRlcGxveWVkID0gQm9vbGVhbih0aGlzLnNoZWV0ICYmIHRoaXMuc2hlZXQuZGVwbG95ZWQpO1xuXG4gICAgaWYgKHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcyAmJiBkZXBsb3llZCkge1xuICAgICAgdGhpcy5oYXNJbnNlcnRlZFJ1bGVzID0gZmFsc2U7XG4gICAgICB0aGlzLmRlcGxveSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHN0eWxlIGVsZW1lbnQgZnJvbSByZW5kZXIgdHJlZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGV0YWNoID0gZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgIGlmICghdGhpcy5zaGVldCkgcmV0dXJuO1xuICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy5lbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTsgLy8gSW4gdGhlIG1vc3QgYnJvd3NlcnMsIHJ1bGVzIGluc2VydGVkIHVzaW5nIGluc2VydFJ1bGUoKSBBUEkgd2lsbCBiZSBsb3N0IHdoZW4gc3R5bGUgZWxlbWVudCBpcyByZW1vdmVkLlxuICAgIC8vIFRob3VnaCBJRSB3aWxsIGtlZXAgdGhlbSBhbmQgd2UgbmVlZCBhIGNvbnNpc3RlbnQgYmVoYXZpb3IuXG5cbiAgICBpZiAodGhpcy5zaGVldC5vcHRpb25zLmxpbmspIHtcbiAgICAgIHRoaXMuY3NzUnVsZXMgPSBbXTtcbiAgICAgIHRoaXMuZWxlbWVudC50ZXh0Q29udGVudCA9ICdcXG4nO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5qZWN0IENTUyBzdHJpbmcgaW50byBlbGVtZW50LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXBsb3kgPSBmdW5jdGlvbiBkZXBsb3koKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5zaGVldDtcbiAgICBpZiAoIXNoZWV0KSByZXR1cm47XG5cbiAgICBpZiAoc2hlZXQub3B0aW9ucy5saW5rKSB7XG4gICAgICB0aGlzLmluc2VydFJ1bGVzKHNoZWV0LnJ1bGVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQudGV4dENvbnRlbnQgPSBcIlxcblwiICsgc2hlZXQudG9TdHJpbmcoKSArIFwiXFxuXCI7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBSdWxlTGlzdCBpbnRvIGFuIGVsZW1lbnQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluc2VydFJ1bGVzID0gZnVuY3Rpb24gaW5zZXJ0UnVsZXMocnVsZXMsIG5hdGl2ZVBhcmVudCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMuaW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlcy5pbmRleFtpXSwgaSwgbmF0aXZlUGFyZW50KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBhIHJ1bGUgaW50byBlbGVtZW50LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShydWxlLCBpbmRleCwgbmF0aXZlUGFyZW50KSB7XG4gICAgaWYgKG5hdGl2ZVBhcmVudCA9PT0gdm9pZCAwKSB7XG4gICAgICBuYXRpdmVQYXJlbnQgPSB0aGlzLmVsZW1lbnQuc2hlZXQ7XG4gICAgfVxuXG4gICAgaWYgKHJ1bGUucnVsZXMpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBydWxlO1xuICAgICAgdmFyIGxhdGVzdE5hdGl2ZVBhcmVudCA9IG5hdGl2ZVBhcmVudDtcblxuICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gJ2NvbmRpdGlvbmFsJyB8fCBydWxlLnR5cGUgPT09ICdrZXlmcmFtZXMnKSB7XG4gICAgICAgIHZhciBfaW5zZXJ0aW9uSW5kZXggPSBnZXRWYWxpZFJ1bGVJbnNlcnRpb25JbmRleChuYXRpdmVQYXJlbnQsIGluZGV4KTsgLy8gV2UgbmVlZCB0byByZW5kZXIgdGhlIGNvbnRhaW5lciB3aXRob3V0IGNoaWxkcmVuIGZpcnN0LlxuXG5cbiAgICAgICAgbGF0ZXN0TmF0aXZlUGFyZW50ID0gX2luc2VydFJ1bGUobmF0aXZlUGFyZW50LCBwYXJlbnQudG9TdHJpbmcoe1xuICAgICAgICAgIGNoaWxkcmVuOiBmYWxzZVxuICAgICAgICB9KSwgX2luc2VydGlvbkluZGV4KTtcblxuICAgICAgICBpZiAobGF0ZXN0TmF0aXZlUGFyZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVmQ3NzUnVsZShydWxlLCBfaW5zZXJ0aW9uSW5kZXgsIGxhdGVzdE5hdGl2ZVBhcmVudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5zZXJ0UnVsZXMocGFyZW50LnJ1bGVzLCBsYXRlc3ROYXRpdmVQYXJlbnQpO1xuICAgICAgcmV0dXJuIGxhdGVzdE5hdGl2ZVBhcmVudDtcbiAgICB9XG5cbiAgICB2YXIgcnVsZVN0ciA9IHJ1bGUudG9TdHJpbmcoKTtcbiAgICBpZiAoIXJ1bGVTdHIpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0aW9uSW5kZXggPSBnZXRWYWxpZFJ1bGVJbnNlcnRpb25JbmRleChuYXRpdmVQYXJlbnQsIGluZGV4KTtcblxuICAgIHZhciBuYXRpdmVSdWxlID0gX2luc2VydFJ1bGUobmF0aXZlUGFyZW50LCBydWxlU3RyLCBpbnNlcnRpb25JbmRleCk7XG5cbiAgICBpZiAobmF0aXZlUnVsZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSB0cnVlO1xuICAgIHRoaXMucmVmQ3NzUnVsZShydWxlLCBpbnNlcnRpb25JbmRleCwgbmF0aXZlUnVsZSk7XG4gICAgcmV0dXJuIG5hdGl2ZVJ1bGU7XG4gIH07XG5cbiAgX3Byb3RvLnJlZkNzc1J1bGUgPSBmdW5jdGlvbiByZWZDc3NSdWxlKHJ1bGUsIGluZGV4LCBjc3NSdWxlKSB7XG4gICAgcnVsZS5yZW5kZXJhYmxlID0gY3NzUnVsZTsgLy8gV2Ugb25seSB3YW50IHRvIHJlZmVyZW5jZSB0aGUgdG9wIGxldmVsIHJ1bGVzLCBkZWxldGVSdWxlIEFQSSBkb2Vzbid0IHN1cHBvcnQgcmVtb3ZpbmcgbmVzdGVkIHJ1bGVzXG4gICAgLy8gbGlrZSBydWxlcyBpbnNpZGUgbWVkaWEgcXVlcmllcyBvciBrZXlmcmFtZXNcblxuICAgIGlmIChydWxlLm9wdGlvbnMucGFyZW50IGluc3RhbmNlb2YgU3R5bGVTaGVldCkge1xuICAgICAgdGhpcy5jc3NSdWxlcy5zcGxpY2UoaW5kZXgsIDAsIGNzc1J1bGUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVsZXRlUnVsZSA9IGZ1bmN0aW9uIGRlbGV0ZVJ1bGUoY3NzUnVsZSkge1xuICAgIHZhciBzaGVldCA9IHRoaXMuZWxlbWVudC5zaGVldDtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoY3NzUnVsZSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIHNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgIHRoaXMuY3NzUnVsZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGEgQ1NTIFJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKGNzc1J1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5jc3NSdWxlcy5pbmRleE9mKGNzc1J1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyBDU1MgcnVsZSBhbmQgcmVwbGFjZSB0aGUgZXhpc3Rpbmcgb25lLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXBsYWNlUnVsZSA9IGZ1bmN0aW9uIHJlcGxhY2VSdWxlKGNzc1J1bGUsIHJ1bGUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoY3NzUnVsZSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuZWxlbWVudC5zaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICB0aGlzLmNzc1J1bGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbGwgcnVsZXMgZWxlbWVudHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldFJ1bGVzID0gZnVuY3Rpb24gZ2V0UnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5zaGVldC5jc3NSdWxlcztcbiAgfTtcblxuICByZXR1cm4gRG9tUmVuZGVyZXI7XG59KCk7XG5cbnZhciBpbnN0YW5jZUNvdW50ZXIgPSAwO1xuXG52YXIgSnNzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSnNzKG9wdGlvbnMpIHtcbiAgICB0aGlzLmlkID0gaW5zdGFuY2VDb3VudGVyKys7XG4gICAgdGhpcy52ZXJzaW9uID0gXCIxMC4xMC4wXCI7XG4gICAgdGhpcy5wbHVnaW5zID0gbmV3IFBsdWdpbnNSZWdpc3RyeSgpO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGlkOiB7XG4gICAgICAgIG1pbmlmeTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBjcmVhdGVHZW5lcmF0ZUlkOiBjcmVhdGVHZW5lcmF0ZUlkLFxuICAgICAgUmVuZGVyZXI6IGlzSW5Ccm93c2VyID8gRG9tUmVuZGVyZXIgOiBudWxsLFxuICAgICAgcGx1Z2luczogW11cbiAgICB9O1xuICAgIHRoaXMuZ2VuZXJhdGVJZCA9IGNyZWF0ZUdlbmVyYXRlSWQoe1xuICAgICAgbWluaWZ5OiBmYWxzZVxuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnBsdWdpbnMudXNlKHBsdWdpbnNbaV0sIHtcbiAgICAgICAgcXVldWU6ICdpbnRlcm5hbCdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc2V0dXAob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFByZXBhcmVzIHZhcmlvdXMgb3B0aW9ucywgYXBwbGllcyBwbHVnaW5zLlxuICAgKiBTaG91bGQgbm90IGJlIHVzZWQgdHdpY2Ugb24gdGhlIHNhbWUgaW5zdGFuY2UsIGJlY2F1c2UgdGhlcmUgaXMgbm8gcGx1Z2luc1xuICAgKiBkZWR1cGxpY2F0aW9uIGxvZ2ljLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBKc3MucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXR1cCA9IGZ1bmN0aW9uIHNldHVwKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmNyZWF0ZUdlbmVyYXRlSWQgPSBvcHRpb25zLmNyZWF0ZUdlbmVyYXRlSWQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5pZCA9IF9leHRlbmRzKHt9LCB0aGlzLm9wdGlvbnMuaWQsIG9wdGlvbnMuaWQpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNyZWF0ZUdlbmVyYXRlSWQgfHwgb3B0aW9ucy5pZCkge1xuICAgICAgdGhpcy5nZW5lcmF0ZUlkID0gdGhpcy5vcHRpb25zLmNyZWF0ZUdlbmVyYXRlSWQodGhpcy5vcHRpb25zLmlkKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbnNlcnRpb25Qb2ludCAhPSBudWxsKSB0aGlzLm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgPSBvcHRpb25zLmluc2VydGlvblBvaW50O1xuXG4gICAgaWYgKCdSZW5kZXJlcicgaW4gb3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zLlJlbmRlcmVyID0gb3B0aW9ucy5SZW5kZXJlcjtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG5cblxuICAgIGlmIChvcHRpb25zLnBsdWdpbnMpIHRoaXMudXNlLmFwcGx5KHRoaXMsIG9wdGlvbnMucGx1Z2lucyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFN0eWxlIFNoZWV0LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jcmVhdGVTdHlsZVNoZWV0ID0gZnVuY3Rpb24gY3JlYXRlU3R5bGVTaGVldChzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgICAgaW5kZXggPSBfb3B0aW9ucy5pbmRleDtcblxuICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgICBpbmRleCA9IHNoZWV0cy5pbmRleCA9PT0gMCA/IDAgOiBzaGVldHMuaW5kZXggKyAxO1xuICAgIH1cblxuICAgIHZhciBzaGVldCA9IG5ldyBTdHlsZVNoZWV0KHN0eWxlcywgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIGpzczogdGhpcyxcbiAgICAgIGdlbmVyYXRlSWQ6IG9wdGlvbnMuZ2VuZXJhdGVJZCB8fCB0aGlzLmdlbmVyYXRlSWQsXG4gICAgICBpbnNlcnRpb25Qb2ludDogdGhpcy5vcHRpb25zLmluc2VydGlvblBvaW50LFxuICAgICAgUmVuZGVyZXI6IHRoaXMub3B0aW9ucy5SZW5kZXJlcixcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH0pKTtcbiAgICB0aGlzLnBsdWdpbnMub25Qcm9jZXNzU2hlZXQoc2hlZXQpO1xuICAgIHJldHVybiBzaGVldDtcbiAgfVxuICAvKipcbiAgICogRGV0YWNoIHRoZSBTdHlsZSBTaGVldCBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIHJlZ2lzdHJ5LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZW1vdmVTdHlsZVNoZWV0ID0gZnVuY3Rpb24gcmVtb3ZlU3R5bGVTaGVldChzaGVldCkge1xuICAgIHNoZWV0LmRldGFjaCgpO1xuICAgIHNoZWV0cy5yZW1vdmUoc2hlZXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBydWxlIHdpdGhvdXQgYSBTdHlsZSBTaGVldC5cbiAgICogW0RlcHJlY2F0ZWRdIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jcmVhdGVSdWxlID0gZnVuY3Rpb24gY3JlYXRlUnVsZSQxKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKHN0eWxlID09PSB2b2lkIDApIHtcbiAgICAgIHN0eWxlID0ge307XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIC8vIEVuYWJsZSBydWxlIHdpdGhvdXQgbmFtZSBmb3IgaW5saW5lIHN0eWxlcy5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVSdWxlKHVuZGVmaW5lZCwgbmFtZSwgc3R5bGUpO1xuICAgIH1cblxuICAgIHZhciBydWxlT3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAganNzOiB0aGlzLFxuICAgICAgUmVuZGVyZXI6IHRoaXMub3B0aW9ucy5SZW5kZXJlclxuICAgIH0pO1xuXG4gICAgaWYgKCFydWxlT3B0aW9ucy5nZW5lcmF0ZUlkKSBydWxlT3B0aW9ucy5nZW5lcmF0ZUlkID0gdGhpcy5nZW5lcmF0ZUlkO1xuICAgIGlmICghcnVsZU9wdGlvbnMuY2xhc3NlcykgcnVsZU9wdGlvbnMuY2xhc3NlcyA9IHt9O1xuICAgIGlmICghcnVsZU9wdGlvbnMua2V5ZnJhbWVzKSBydWxlT3B0aW9ucy5rZXlmcmFtZXMgPSB7fTtcblxuICAgIHZhciBydWxlID0gY3JlYXRlUnVsZShuYW1lLCBzdHlsZSwgcnVsZU9wdGlvbnMpO1xuXG4gICAgaWYgKHJ1bGUpIHRoaXMucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBwbHVnaW4uIFBhc3NlZCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgd2l0aCBhIHJ1bGUgaW5zdGFuY2UuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVzZSA9IGZ1bmN0aW9uIHVzZSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBsdWdpbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBwbHVnaW5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICBfdGhpcy5wbHVnaW5zLnVzZShwbHVnaW4pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBKc3M7XG59KCk7XG5cbnZhciBjcmVhdGVKc3MgPSBmdW5jdGlvbiBjcmVhdGVKc3Mob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEpzcyhvcHRpb25zKTtcbn07XG5cbi8qKlxuICogU2hlZXRzTWFuYWdlciBpcyBsaWtlIGEgV2Vha01hcCB3aGljaCBpcyBkZXNpZ25lZCB0byBjb3VudCBTdHlsZVNoZWV0XG4gKiBpbnN0YW5jZXMgYW5kIGF0dGFjaC9kZXRhY2ggYXV0b21hdGljYWxseS5cbiAqIFVzZWQgaW4gcmVhY3QtanNzLlxuICovXG5cbnZhciBTaGVldHNNYW5hZ2VyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2hlZXRzTWFuYWdlcigpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5zaGVldHMgPSBuZXcgV2Vha01hcCgpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNoZWV0c01hbmFnZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5zaGVldHMuZ2V0KGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnNoZWV0O1xuICB9O1xuXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoa2V5LCBzaGVldCkge1xuICAgIGlmICh0aGlzLnNoZWV0cy5oYXMoa2V5KSkgcmV0dXJuO1xuICAgIHRoaXMubGVuZ3RoKys7XG4gICAgdGhpcy5zaGVldHMuc2V0KGtleSwge1xuICAgICAgc2hlZXQ6IHNoZWV0LFxuICAgICAgcmVmczogMFxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5tYW5hZ2UgPSBmdW5jdGlvbiBtYW5hZ2Uoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5zaGVldHMuZ2V0KGtleSk7XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGlmIChlbnRyeS5yZWZzID09PSAwKSB7XG4gICAgICAgIGVudHJ5LnNoZWV0LmF0dGFjaCgpO1xuICAgICAgfVxuXG4gICAgICBlbnRyeS5yZWZzKys7XG4gICAgICByZXR1cm4gZW50cnkuc2hlZXQ7XG4gICAgfVxuXG4gICAgd2FybmluZyhmYWxzZSwgXCJbSlNTXSBTaGVldHNNYW5hZ2VyOiBjYW4ndCBmaW5kIHNoZWV0IHRvIG1hbmFnZVwiKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIF9wcm90by51bm1hbmFnZSA9IGZ1bmN0aW9uIHVubWFuYWdlKGtleSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuc2hlZXRzLmdldChrZXkpO1xuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBpZiAoZW50cnkucmVmcyA+IDApIHtcbiAgICAgICAgZW50cnkucmVmcy0tO1xuICAgICAgICBpZiAoZW50cnkucmVmcyA9PT0gMCkgZW50cnkuc2hlZXQuZGV0YWNoKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiU2hlZXRzTWFuYWdlcjogY2FuJ3QgZmluZCBzaGVldCB0byB1bm1hbmFnZVwiKTtcbiAgICB9XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFNoZWV0c01hbmFnZXIsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2hlZXRzTWFuYWdlcjtcbn0oKTtcblxuLyoqXG4qIEV4cG9ydCBhIGNvbnN0YW50IGluZGljYXRpbmcgaWYgdGhpcyBicm93c2VyIGhhcyBDU1NUT00gc3VwcG9ydC5cbiogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3VwZGF0ZXMvMjAxOC8wMy9jc3NvbVxuKi9cbnZhciBoYXNDU1NUT01TdXBwb3J0ID0gdHlwZW9mIENTUyA9PT0gJ29iamVjdCcgJiYgQ1NTICE9IG51bGwgJiYgJ251bWJlcicgaW4gQ1NTO1xuXG4vKipcbiAqIEV4dHJhY3RzIGEgc3R5bGVzIG9iamVjdCB3aXRoIG9ubHkgcHJvcHMgdGhhdCBjb250YWluIGZ1bmN0aW9uIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RHluYW1pY1N0eWxlcyhzdHlsZXMpIHtcbiAgdmFyIHRvID0gbnVsbDtcblxuICBmb3IgKHZhciBrZXkgaW4gc3R5bGVzKSB7XG4gICAgdmFyIHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKCF0bykgdG8gPSB7fTtcbiAgICAgIHRvW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFyIGV4dHJhY3RlZCA9IGdldER5bmFtaWNTdHlsZXModmFsdWUpO1xuXG4gICAgICBpZiAoZXh0cmFjdGVkKSB7XG4gICAgICAgIGlmICghdG8pIHRvID0ge307XG4gICAgICAgIHRvW2tleV0gPSBleHRyYWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvO1xufVxuXG4vKipcbiAqIEEgYmV0dGVyIGFic3RyYWN0aW9uIG92ZXIgQ1NTLlxuICpcbiAqIEBjb3B5cmlnaHQgT2xlZyBJc29uZW4gKFNsb2JvZHNrb2kpIC8gSXNvbmVuIDIwMTQtcHJlc2VudFxuICogQHdlYnNpdGUgaHR0cHM6Ly9naXRodWIuY29tL2Nzc2luanMvanNzXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xudmFyIGluZGV4ID0gY3JlYXRlSnNzKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuZXhwb3J0IHsgUnVsZUxpc3QsIFNoZWV0c01hbmFnZXIsIFNoZWV0c1JlZ2lzdHJ5LCBjcmVhdGVKc3MgYXMgY3JlYXRlLCBjcmVhdGVHZW5lcmF0ZUlkLCBjcmVhdGVSdWxlLCBnZXREeW5hbWljU3R5bGVzLCBoYXNDU1NUT01TdXBwb3J0LCBzaGVldHMsIHRvQ3NzVmFsdWUgfTtcbiIsIi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBTRFAgaGVscGVycy5cbmNvbnN0IFNEUFV0aWxzID0ge307XG5cbi8vIEdlbmVyYXRlIGFuIGFscGhhbnVtZXJpYyBpZGVudGlmaWVyIGZvciBjbmFtZSBvciBtaWRzLlxuLy8gVE9ETzogdXNlIFVVSURzIGluc3RlYWQ/IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2plZC85ODI4ODNcblNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEyKTtcbn07XG5cbi8vIFRoZSBSVENQIENOQU1FIHVzZWQgYnkgYWxsIHBlZXJjb25uZWN0aW9ucyBmcm9tIHRoZSBzYW1lIEpTLlxuU0RQVXRpbHMubG9jYWxDTmFtZSA9IFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllcigpO1xuXG4vLyBTcGxpdHMgU0RQIGludG8gbGluZXMsIGRlYWxpbmcgd2l0aCBib3RoIENSTEYgYW5kIExGLlxuU0RQVXRpbHMuc3BsaXRMaW5lcyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgcmV0dXJuIGJsb2IudHJpbSgpLnNwbGl0KCdcXG4nKS5tYXAobGluZSA9PiBsaW5lLnRyaW0oKSk7XG59O1xuLy8gU3BsaXRzIFNEUCBpbnRvIHNlc3Npb25wYXJ0IGFuZCBtZWRpYXNlY3Rpb25zLiBFbnN1cmVzIENSTEYuXG5TRFBVdGlscy5zcGxpdFNlY3Rpb25zID0gZnVuY3Rpb24oYmxvYikge1xuICBjb25zdCBwYXJ0cyA9IGJsb2Iuc3BsaXQoJ1xcbm09Jyk7XG4gIHJldHVybiBwYXJ0cy5tYXAoKHBhcnQsIGluZGV4KSA9PiAoaW5kZXggPiAwID9cbiAgICAnbT0nICsgcGFydCA6IHBhcnQpLnRyaW0oKSArICdcXHJcXG4nKTtcbn07XG5cbi8vIFJldHVybnMgdGhlIHNlc3Npb24gZGVzY3JpcHRpb24uXG5TRFBVdGlscy5nZXREZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICByZXR1cm4gc2VjdGlvbnMgJiYgc2VjdGlvbnNbMF07XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBpbmRpdmlkdWFsIG1lZGlhIHNlY3Rpb25zLlxuU0RQVXRpbHMuZ2V0TWVkaWFTZWN0aW9ucyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICBzZWN0aW9ucy5zaGlmdCgpO1xuICByZXR1cm4gc2VjdGlvbnM7XG59O1xuXG4vLyBSZXR1cm5zIGxpbmVzIHRoYXQgc3RhcnQgd2l0aCBhIGNlcnRhaW4gcHJlZml4LlxuU0RQVXRpbHMubWF0Y2hQcmVmaXggPSBmdW5jdGlvbihibG9iLCBwcmVmaXgpIHtcbiAgcmV0dXJuIFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYikuZmlsdGVyKGxpbmUgPT4gbGluZS5pbmRleE9mKHByZWZpeCkgPT09IDApO1xufTtcblxuLy8gUGFyc2VzIGFuIElDRSBjYW5kaWRhdGUgbGluZS4gU2FtcGxlIGlucHV0OlxuLy8gY2FuZGlkYXRlOjcwMjc4NjM1MCAyIHVkcCA0MTgxOTkwMiA4LjguOC44IDYwNzY5IHR5cCByZWxheSByYWRkciA4LjguOC44XG4vLyBycG9ydCA1NTk5NlwiXG4vLyBJbnB1dCBjYW4gYmUgcHJlZml4ZWQgd2l0aCBhPS5cblNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlID0gZnVuY3Rpb24obGluZSkge1xuICBsZXQgcGFydHM7XG4gIC8vIFBhcnNlIGJvdGggdmFyaWFudHMuXG4gIGlmIChsaW5lLmluZGV4T2YoJ2E9Y2FuZGlkYXRlOicpID09PSAwKSB7XG4gICAgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMikuc3BsaXQoJyAnKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEwKS5zcGxpdCgnICcpO1xuICB9XG5cbiAgY29uc3QgY2FuZGlkYXRlID0ge1xuICAgIGZvdW5kYXRpb246IHBhcnRzWzBdLFxuICAgIGNvbXBvbmVudDogezE6ICdydHAnLCAyOiAncnRjcCd9W3BhcnRzWzFdXSB8fCBwYXJ0c1sxXSxcbiAgICBwcm90b2NvbDogcGFydHNbMl0udG9Mb3dlckNhc2UoKSxcbiAgICBwcmlvcml0eTogcGFyc2VJbnQocGFydHNbM10sIDEwKSxcbiAgICBpcDogcGFydHNbNF0sXG4gICAgYWRkcmVzczogcGFydHNbNF0sIC8vIGFkZHJlc3MgaXMgYW4gYWxpYXMgZm9yIGlwLlxuICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzVdLCAxMCksXG4gICAgLy8gc2tpcCBwYXJ0c1s2XSA9PSAndHlwJ1xuICAgIHR5cGU6IHBhcnRzWzddLFxuICB9O1xuXG4gIGZvciAobGV0IGkgPSA4OyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBzd2l0Y2ggKHBhcnRzW2ldKSB7XG4gICAgICBjYXNlICdyYWRkcic6XG4gICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdycG9ydCc6XG4gICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCA9IHBhcnNlSW50KHBhcnRzW2kgKyAxXSwgMTApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RjcHR5cGUnOlxuICAgICAgICBjYW5kaWRhdGUudGNwVHlwZSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1ZnJhZyc6XG4gICAgICAgIGNhbmRpZGF0ZS51ZnJhZyA9IHBhcnRzW2kgKyAxXTsgLy8gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50ID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIGV4dGVuc2lvbiBoYW5kbGluZywgaW4gcGFydGljdWxhciB1ZnJhZy4gRG9uJ3Qgb3ZlcndyaXRlLlxuICAgICAgICBpZiAoY2FuZGlkYXRlW3BhcnRzW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2FuZGlkYXRlW3BhcnRzW2ldXSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZTtcbn07XG5cbi8vIFRyYW5zbGF0ZXMgYSBjYW5kaWRhdGUgb2JqZWN0IGludG8gU0RQIGNhbmRpZGF0ZSBhdHRyaWJ1dGUuXG4vLyBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdGhlIGE9IHByZWZpeCFcblNEUFV0aWxzLndyaXRlQ2FuZGlkYXRlID0gZnVuY3Rpb24oY2FuZGlkYXRlKSB7XG4gIGNvbnN0IHNkcCA9IFtdO1xuICBzZHAucHVzaChjYW5kaWRhdGUuZm91bmRhdGlvbik7XG5cbiAgY29uc3QgY29tcG9uZW50ID0gY2FuZGlkYXRlLmNvbXBvbmVudDtcbiAgaWYgKGNvbXBvbmVudCA9PT0gJ3J0cCcpIHtcbiAgICBzZHAucHVzaCgxKTtcbiAgfSBlbHNlIGlmIChjb21wb25lbnQgPT09ICdydGNwJykge1xuICAgIHNkcC5wdXNoKDIpO1xuICB9IGVsc2Uge1xuICAgIHNkcC5wdXNoKGNvbXBvbmVudCk7XG4gIH1cbiAgc2RwLnB1c2goY2FuZGlkYXRlLnByb3RvY29sLnRvVXBwZXJDYXNlKCkpO1xuICBzZHAucHVzaChjYW5kaWRhdGUucHJpb3JpdHkpO1xuICBzZHAucHVzaChjYW5kaWRhdGUuYWRkcmVzcyB8fCBjYW5kaWRhdGUuaXApO1xuICBzZHAucHVzaChjYW5kaWRhdGUucG9ydCk7XG5cbiAgY29uc3QgdHlwZSA9IGNhbmRpZGF0ZS50eXBlO1xuICBzZHAucHVzaCgndHlwJyk7XG4gIHNkcC5wdXNoKHR5cGUpO1xuICBpZiAodHlwZSAhPT0gJ2hvc3QnICYmIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyAmJlxuICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KSB7XG4gICAgc2RwLnB1c2goJ3JhZGRyJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzKTtcbiAgICBzZHAucHVzaCgncnBvcnQnKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUucmVsYXRlZFBvcnQpO1xuICB9XG4gIGlmIChjYW5kaWRhdGUudGNwVHlwZSAmJiBjYW5kaWRhdGUucHJvdG9jb2wudG9Mb3dlckNhc2UoKSA9PT0gJ3RjcCcpIHtcbiAgICBzZHAucHVzaCgndGNwdHlwZScpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS50Y3BUeXBlKTtcbiAgfVxuICBpZiAoY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKSB7XG4gICAgc2RwLnB1c2goJ3VmcmFnJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKTtcbiAgfVxuICByZXR1cm4gJ2NhbmRpZGF0ZTonICsgc2RwLmpvaW4oJyAnKTtcbn07XG5cbi8vIFBhcnNlcyBhbiBpY2Utb3B0aW9ucyBsaW5lLCByZXR1cm5zIGFuIGFycmF5IG9mIG9wdGlvbiB0YWdzLlxuLy8gU2FtcGxlIGlucHV0OlxuLy8gYT1pY2Utb3B0aW9uczpmb28gYmFyXG5TRFBVdGlscy5wYXJzZUljZU9wdGlvbnMgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHJldHVybiBsaW5lLnN1YnN0cmluZygxNCkuc3BsaXQoJyAnKTtcbn07XG5cbi8vIFBhcnNlcyBhIHJ0cG1hcCBsaW5lLCByZXR1cm5zIFJUQ1J0cENvZGRlY1BhcmFtZXRlcnMuIFNhbXBsZSBpbnB1dDpcbi8vIGE9cnRwbWFwOjExMSBvcHVzLzQ4MDAwLzJcblNEUFV0aWxzLnBhcnNlUnRwTWFwID0gZnVuY3Rpb24obGluZSkge1xuICBsZXQgcGFydHMgPSBsaW5lLnN1YnN0cmluZyg5KS5zcGxpdCgnICcpO1xuICBjb25zdCBwYXJzZWQgPSB7XG4gICAgcGF5bG9hZFR5cGU6IHBhcnNlSW50KHBhcnRzLnNoaWZ0KCksIDEwKSwgLy8gd2FzOiBpZFxuICB9O1xuXG4gIHBhcnRzID0gcGFydHNbMF0uc3BsaXQoJy8nKTtcblxuICBwYXJzZWQubmFtZSA9IHBhcnRzWzBdO1xuICBwYXJzZWQuY2xvY2tSYXRlID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTsgLy8gd2FzOiBjbG9ja3JhdGVcbiAgcGFyc2VkLmNoYW5uZWxzID0gcGFydHMubGVuZ3RoID09PSAzID8gcGFyc2VJbnQocGFydHNbMl0sIDEwKSA6IDE7XG4gIC8vIGxlZ2FjeSBhbGlhcywgZ290IHJlbmFtZWQgYmFjayB0byBjaGFubmVscyBpbiBPUlRDLlxuICBwYXJzZWQubnVtQ2hhbm5lbHMgPSBwYXJzZWQuY2hhbm5lbHM7XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vLyBHZW5lcmF0ZXMgYSBydHBtYXAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvclxuLy8gUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdHBNYXAgPSBmdW5jdGlvbihjb2RlYykge1xuICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIGNvbnN0IGNoYW5uZWxzID0gY29kZWMuY2hhbm5lbHMgfHwgY29kZWMubnVtQ2hhbm5lbHMgfHwgMTtcbiAgcmV0dXJuICdhPXJ0cG1hcDonICsgcHQgKyAnICcgKyBjb2RlYy5uYW1lICsgJy8nICsgY29kZWMuY2xvY2tSYXRlICtcbiAgICAgIChjaGFubmVscyAhPT0gMSA/ICcvJyArIGNoYW5uZWxzIDogJycpICsgJ1xcclxcbic7XG59O1xuXG4vLyBQYXJzZXMgYSBleHRtYXAgbGluZSAoaGVhZGVyZXh0ZW5zaW9uIGZyb20gUkZDIDUyODUpLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbi8vIGE9ZXh0bWFwOjIvc2VuZG9ubHkgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuU0RQVXRpbHMucGFyc2VFeHRtYXAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBpZDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICBkaXJlY3Rpb246IHBhcnRzWzBdLmluZGV4T2YoJy8nKSA+IDAgPyBwYXJ0c1swXS5zcGxpdCgnLycpWzFdIDogJ3NlbmRyZWN2JyxcbiAgICB1cmk6IHBhcnRzWzFdLFxuICAgIGF0dHJpYnV0ZXM6IHBhcnRzLnNsaWNlKDIpLmpvaW4oJyAnKSxcbiAgfTtcbn07XG5cbi8vIEdlbmVyYXRlcyBhbiBleHRtYXAgbGluZSBmcm9tIFJUQ1J0cEhlYWRlckV4dGVuc2lvblBhcmFtZXRlcnMgb3Jcbi8vIFJUQ1J0cEhlYWRlckV4dGVuc2lvbi5cblNEUFV0aWxzLndyaXRlRXh0bWFwID0gZnVuY3Rpb24oaGVhZGVyRXh0ZW5zaW9uKSB7XG4gIHJldHVybiAnYT1leHRtYXA6JyArIChoZWFkZXJFeHRlbnNpb24uaWQgfHwgaGVhZGVyRXh0ZW5zaW9uLnByZWZlcnJlZElkKSArXG4gICAgICAoaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiAmJiBoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uICE9PSAnc2VuZHJlY3YnXG4gICAgICAgID8gJy8nICsgaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvblxuICAgICAgICA6ICcnKSArXG4gICAgICAnICcgKyBoZWFkZXJFeHRlbnNpb24udXJpICtcbiAgICAgIChoZWFkZXJFeHRlbnNpb24uYXR0cmlidXRlcyA/ICcgJyArIGhlYWRlckV4dGVuc2lvbi5hdHRyaWJ1dGVzIDogJycpICtcbiAgICAgICdcXHJcXG4nO1xufTtcblxuLy8gUGFyc2VzIGEgZm10cCBsaW5lLCByZXR1cm5zIGRpY3Rpb25hcnkuIFNhbXBsZSBpbnB1dDpcbi8vIGE9Zm10cDo5NiB2YnI9b247Y25nPW9uXG4vLyBBbHNvIGRlYWxzIHdpdGggdmJyPW9uOyBjbmc9b25cblNEUFV0aWxzLnBhcnNlRm10cCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3QgcGFyc2VkID0ge307XG4gIGxldCBrdjtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyhsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCc7Jyk7XG4gIGZvciAobGV0IGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICBrdiA9IHBhcnRzW2pdLnRyaW0oKS5zcGxpdCgnPScpO1xuICAgIHBhcnNlZFtrdlswXS50cmltKCldID0ga3ZbMV07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbi8vIEdlbmVyYXRlcyBhIGZtdHAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvciBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZUZtdHAgPSBmdW5jdGlvbihjb2RlYykge1xuICBsZXQgbGluZSA9ICcnO1xuICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIGlmIChjb2RlYy5wYXJhbWV0ZXJzICYmIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmxlbmd0aCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmZvckVhY2gocGFyYW0gPT4ge1xuICAgICAgaWYgKGNvZGVjLnBhcmFtZXRlcnNbcGFyYW1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0gKyAnPScgKyBjb2RlYy5wYXJhbWV0ZXJzW3BhcmFtXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGluZSArPSAnYT1mbXRwOicgKyBwdCArICcgJyArIHBhcmFtcy5qb2luKCc7JykgKyAnXFxyXFxuJztcbiAgfVxuICByZXR1cm4gbGluZTtcbn07XG5cbi8vIFBhcnNlcyBhIHJ0Y3AtZmIgbGluZSwgcmV0dXJucyBSVENQUnRjcEZlZWRiYWNrIG9iamVjdC4gU2FtcGxlIGlucHV0OlxuLy8gYT1ydGNwLWZiOjk4IG5hY2sgcnBzaVxuU0RQVXRpbHMucGFyc2VSdGNwRmIgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcobGluZS5pbmRleE9mKCcgJykgKyAxKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHBhcnRzLnNoaWZ0KCksXG4gICAgcGFyYW1ldGVyOiBwYXJ0cy5qb2luKCcgJyksXG4gIH07XG59O1xuXG4vLyBHZW5lcmF0ZSBhPXJ0Y3AtZmIgbGluZXMgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdGNwRmIgPSBmdW5jdGlvbihjb2RlYykge1xuICBsZXQgbGluZXMgPSAnJztcbiAgbGV0IHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgfVxuICBpZiAoY29kZWMucnRjcEZlZWRiYWNrICYmIGNvZGVjLnJ0Y3BGZWVkYmFjay5sZW5ndGgpIHtcbiAgICAvLyBGSVhNRTogc3BlY2lhbCBoYW5kbGluZyBmb3IgdHJyLWludD9cbiAgICBjb2RlYy5ydGNwRmVlZGJhY2suZm9yRWFjaChmYiA9PiB7XG4gICAgICBsaW5lcyArPSAnYT1ydGNwLWZiOicgKyBwdCArICcgJyArIGZiLnR5cGUgK1xuICAgICAgKGZiLnBhcmFtZXRlciAmJiBmYi5wYXJhbWV0ZXIubGVuZ3RoID8gJyAnICsgZmIucGFyYW1ldGVyIDogJycpICtcbiAgICAgICAgICAnXFxyXFxuJztcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbGluZXM7XG59O1xuXG4vLyBQYXJzZXMgYSBSRkMgNTU3NiBzc3JjIG1lZGlhIGF0dHJpYnV0ZS4gU2FtcGxlIGlucHV0OlxuLy8gYT1zc3JjOjM3MzU5Mjg1NTkgY25hbWU6c29tZXRoaW5nXG5TRFBVdGlscy5wYXJzZVNzcmNNZWRpYSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3Qgc3AgPSBsaW5lLmluZGV4T2YoJyAnKTtcbiAgY29uc3QgcGFydHMgPSB7XG4gICAgc3NyYzogcGFyc2VJbnQobGluZS5zdWJzdHJpbmcoNywgc3ApLCAxMCksXG4gIH07XG4gIGNvbnN0IGNvbG9uID0gbGluZS5pbmRleE9mKCc6Jywgc3ApO1xuICBpZiAoY29sb24gPiAtMSkge1xuICAgIHBhcnRzLmF0dHJpYnV0ZSA9IGxpbmUuc3Vic3RyaW5nKHNwICsgMSwgY29sb24pO1xuICAgIHBhcnRzLnZhbHVlID0gbGluZS5zdWJzdHJpbmcoY29sb24gKyAxKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cy5hdHRyaWJ1dGUgPSBsaW5lLnN1YnN0cmluZyhzcCArIDEpO1xuICB9XG4gIHJldHVybiBwYXJ0cztcbn07XG5cbi8vIFBhcnNlIGEgc3NyYy1ncm91cCBsaW5lIChzZWUgUkZDIDU1NzYpLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPXNzcmMtZ3JvdXA6c2VtYW50aWNzIDEyIDM0XG5TRFBVdGlscy5wYXJzZVNzcmNHcm91cCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMykuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBzZW1hbnRpY3M6IHBhcnRzLnNoaWZ0KCksXG4gICAgc3NyY3M6IHBhcnRzLm1hcChzc3JjID0+IHBhcnNlSW50KHNzcmMsIDEwKSksXG4gIH07XG59O1xuXG4vLyBFeHRyYWN0cyB0aGUgTUlEIChSRkMgNTg4OCkgZnJvbSBhIG1lZGlhIHNlY3Rpb24uXG4vLyBSZXR1cm5zIHRoZSBNSUQgb3IgdW5kZWZpbmVkIGlmIG5vIG1pZCBsaW5lIHdhcyBmb3VuZC5cblNEUFV0aWxzLmdldE1pZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBtaWQgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1pZDonKVswXTtcbiAgaWYgKG1pZCkge1xuICAgIHJldHVybiBtaWQuc3Vic3RyaW5nKDYpO1xuICB9XG59O1xuXG4vLyBQYXJzZXMgYSBmaW5nZXJwcmludCBsaW5lIGZvciBEVExTLVNSVFAuXG5TRFBVdGlscy5wYXJzZUZpbmdlcnByaW50ID0gZnVuY3Rpb24obGluZSkge1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDE0KS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIGFsZ29yaXRobTogcGFydHNbMF0udG9Mb3dlckNhc2UoKSwgLy8gYWxnb3JpdGhtIGlzIGNhc2Utc2Vuc2l0aXZlIGluIEVkZ2UuXG4gICAgdmFsdWU6IHBhcnRzWzFdLnRvVXBwZXJDYXNlKCksIC8vIHRoZSBkZWZpbml0aW9uIGlzIHVwcGVyLWNhc2UgaW4gUkZDIDQ1NzIuXG4gIH07XG59O1xuXG4vLyBFeHRyYWN0cyBEVExTIHBhcmFtZXRlcnMgZnJvbSBTRFAgbWVkaWEgc2VjdGlvbiBvciBzZXNzaW9ucGFydC5cbi8vIEZJWE1FOiBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBmdW5jdGlvbnMgdGhpcyBzaG91bGQgb25seVxuLy8gICBnZXQgdGhlIGZpbmdlcnByaW50IGxpbmUgYXMgaW5wdXQuIFNlZSBhbHNvIGdldEljZVBhcmFtZXRlcnMuXG5TRFBVdGlscy5nZXREdGxzUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCxcbiAgICAnYT1maW5nZXJwcmludDonKTtcbiAgLy8gTm90ZTogYT1zZXR1cCBsaW5lIGlzIGlnbm9yZWQgc2luY2Ugd2UgdXNlIHRoZSAnYXV0bycgcm9sZSBpbiBFZGdlLlxuICByZXR1cm4ge1xuICAgIHJvbGU6ICdhdXRvJyxcbiAgICBmaW5nZXJwcmludHM6IGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUZpbmdlcnByaW50KSxcbiAgfTtcbn07XG5cbi8vIFNlcmlhbGl6ZXMgRFRMUyBwYXJhbWV0ZXJzIHRvIFNEUC5cblNEUFV0aWxzLndyaXRlRHRsc1BhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMsIHNldHVwVHlwZSkge1xuICBsZXQgc2RwID0gJ2E9c2V0dXA6JyArIHNldHVwVHlwZSArICdcXHJcXG4nO1xuICBwYXJhbXMuZmluZ2VycHJpbnRzLmZvckVhY2goZnAgPT4ge1xuICAgIHNkcCArPSAnYT1maW5nZXJwcmludDonICsgZnAuYWxnb3JpdGhtICsgJyAnICsgZnAudmFsdWUgKyAnXFxyXFxuJztcbiAgfSk7XG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBQYXJzZXMgYT1jcnlwdG8gbGluZXMgaW50b1xuLy8gICBodHRwczovL3Jhd2dpdC5jb20vYWJvYmEvZWRnZXJ0Yy9tYXN0ZXIvbXNvcnRjLXJzNC5odG1sI2RpY3Rpb25hcnktcnRjc3J0cHNkZXNwYXJhbWV0ZXJzLW1lbWJlcnNcblNEUFV0aWxzLnBhcnNlQ3J5cHRvTGluZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyg5KS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHRhZzogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICBjcnlwdG9TdWl0ZTogcGFydHNbMV0sXG4gICAga2V5UGFyYW1zOiBwYXJ0c1syXSxcbiAgICBzZXNzaW9uUGFyYW1zOiBwYXJ0cy5zbGljZSgzKSxcbiAgfTtcbn07XG5cblNEUFV0aWxzLndyaXRlQ3J5cHRvTGluZSA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcbiAgcmV0dXJuICdhPWNyeXB0bzonICsgcGFyYW1ldGVycy50YWcgKyAnICcgK1xuICAgIHBhcmFtZXRlcnMuY3J5cHRvU3VpdGUgKyAnICcgK1xuICAgICh0eXBlb2YgcGFyYW1ldGVycy5rZXlQYXJhbXMgPT09ICdvYmplY3QnXG4gICAgICA/IFNEUFV0aWxzLndyaXRlQ3J5cHRvS2V5UGFyYW1zKHBhcmFtZXRlcnMua2V5UGFyYW1zKVxuICAgICAgOiBwYXJhbWV0ZXJzLmtleVBhcmFtcykgK1xuICAgIChwYXJhbWV0ZXJzLnNlc3Npb25QYXJhbXMgPyAnICcgKyBwYXJhbWV0ZXJzLnNlc3Npb25QYXJhbXMuam9pbignICcpIDogJycpICtcbiAgICAnXFxyXFxuJztcbn07XG5cbi8vIFBhcnNlcyB0aGUgY3J5cHRvIGtleSBwYXJhbWV0ZXJzIGludG9cbi8vICAgaHR0cHM6Ly9yYXdnaXQuY29tL2Fib2JhL2VkZ2VydGMvbWFzdGVyL21zb3J0Yy1yczQuaHRtbCNydGNzcnRwa2V5cGFyYW0qXG5TRFBVdGlscy5wYXJzZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uKGtleVBhcmFtcykge1xuICBpZiAoa2V5UGFyYW1zLmluZGV4T2YoJ2lubGluZTonKSAhPT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHBhcnRzID0ga2V5UGFyYW1zLnN1YnN0cmluZyg3KS5zcGxpdCgnfCcpO1xuICByZXR1cm4ge1xuICAgIGtleU1ldGhvZDogJ2lubGluZScsXG4gICAga2V5U2FsdDogcGFydHNbMF0sXG4gICAgbGlmZVRpbWU6IHBhcnRzWzFdLFxuICAgIG1raVZhbHVlOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCc6JylbMF0gOiB1bmRlZmluZWQsXG4gICAgbWtpTGVuZ3RoOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCc6JylbMV0gOiB1bmRlZmluZWQsXG4gIH07XG59O1xuXG5TRFBVdGlscy53cml0ZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uKGtleVBhcmFtcykge1xuICByZXR1cm4ga2V5UGFyYW1zLmtleU1ldGhvZCArICc6J1xuICAgICsga2V5UGFyYW1zLmtleVNhbHQgK1xuICAgIChrZXlQYXJhbXMubGlmZVRpbWUgPyAnfCcgKyBrZXlQYXJhbXMubGlmZVRpbWUgOiAnJykgK1xuICAgIChrZXlQYXJhbXMubWtpVmFsdWUgJiYga2V5UGFyYW1zLm1raUxlbmd0aFxuICAgICAgPyAnfCcgKyBrZXlQYXJhbXMubWtpVmFsdWUgKyAnOicgKyBrZXlQYXJhbXMubWtpTGVuZ3RoXG4gICAgICA6ICcnKTtcbn07XG5cbi8vIEV4dHJhY3RzIGFsbCBTREVTIHBhcmFtZXRlcnMuXG5TRFBVdGlscy5nZXRDcnlwdG9QYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LFxuICAgICdhPWNyeXB0bzonKTtcbiAgcmV0dXJuIGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUNyeXB0b0xpbmUpO1xufTtcblxuLy8gUGFyc2VzIElDRSBpbmZvcm1hdGlvbiBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxuLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4vLyAgIGdldCB0aGUgaWNlLXVmcmFnIGFuZCBpY2UtcHdkIGxpbmVzIGFzIGlucHV0LlxuU0RQVXRpbHMuZ2V0SWNlUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgY29uc3QgdWZyYWcgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCxcbiAgICAnYT1pY2UtdWZyYWc6JylbMF07XG4gIGNvbnN0IHB3ZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LFxuICAgICdhPWljZS1wd2Q6JylbMF07XG4gIGlmICghKHVmcmFnICYmIHB3ZCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHVzZXJuYW1lRnJhZ21lbnQ6IHVmcmFnLnN1YnN0cmluZygxMiksXG4gICAgcGFzc3dvcmQ6IHB3ZC5zdWJzdHJpbmcoMTApLFxuICB9O1xufTtcblxuLy8gU2VyaWFsaXplcyBJQ0UgcGFyYW1ldGVycyB0byBTRFAuXG5TRFBVdGlscy53cml0ZUljZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgbGV0IHNkcCA9ICdhPWljZS11ZnJhZzonICsgcGFyYW1zLnVzZXJuYW1lRnJhZ21lbnQgKyAnXFxyXFxuJyArXG4gICAgICAnYT1pY2UtcHdkOicgKyBwYXJhbXMucGFzc3dvcmQgKyAnXFxyXFxuJztcbiAgaWYgKHBhcmFtcy5pY2VMaXRlKSB7XG4gICAgc2RwICs9ICdhPWljZS1saXRlXFxyXFxuJztcbiAgfVxuICByZXR1cm4gc2RwO1xufTtcblxuLy8gUGFyc2VzIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBhbmQgcmV0dXJucyBSVENSdHBQYXJhbWV0ZXJzLlxuU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0ge1xuICAgIGNvZGVjczogW10sXG4gICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgZmVjTWVjaGFuaXNtczogW10sXG4gICAgcnRjcDogW10sXG4gIH07XG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICBjb25zdCBtbGluZSA9IGxpbmVzWzBdLnNwbGl0KCcgJyk7XG4gIGRlc2NyaXB0aW9uLnByb2ZpbGUgPSBtbGluZVsyXTtcbiAgZm9yIChsZXQgaSA9IDM7IGkgPCBtbGluZS5sZW5ndGg7IGkrKykgeyAvLyBmaW5kIGFsbCBjb2RlY3MgZnJvbSBtbGluZVszLi5dXG4gICAgY29uc3QgcHQgPSBtbGluZVtpXTtcbiAgICBjb25zdCBydHBtYXBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoXG4gICAgICBtZWRpYVNlY3Rpb24sICdhPXJ0cG1hcDonICsgcHQgKyAnICcpWzBdO1xuICAgIGlmIChydHBtYXBsaW5lKSB7XG4gICAgICBjb25zdCBjb2RlYyA9IFNEUFV0aWxzLnBhcnNlUnRwTWFwKHJ0cG1hcGxpbmUpO1xuICAgICAgY29uc3QgZm10cHMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChcbiAgICAgICAgbWVkaWFTZWN0aW9uLCAnYT1mbXRwOicgKyBwdCArICcgJyk7XG4gICAgICAvLyBPbmx5IHRoZSBmaXJzdCBhPWZtdHA6PHB0PiBpcyBjb25zaWRlcmVkLlxuICAgICAgY29kZWMucGFyYW1ldGVycyA9IGZtdHBzLmxlbmd0aCA/IFNEUFV0aWxzLnBhcnNlRm10cChmbXRwc1swXSkgOiB7fTtcbiAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KFxuICAgICAgICBtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtZmI6JyArIHB0ICsgJyAnKVxuICAgICAgICAubWFwKFNEUFV0aWxzLnBhcnNlUnRjcEZiKTtcbiAgICAgIGRlc2NyaXB0aW9uLmNvZGVjcy5wdXNoKGNvZGVjKTtcbiAgICAgIC8vIHBhcnNlIEZFQyBtZWNoYW5pc21zIGZyb20gcnRwbWFwIGxpbmVzLlxuICAgICAgc3dpdGNoIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnUkVEJzpcbiAgICAgICAgY2FzZSAnVUxQRkVDJzpcbiAgICAgICAgICBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLnB1c2goY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogLy8gb25seSBSRUQgYW5kIFVMUEZFQyBhcmUgcmVjb2duaXplZCBhcyBGRUMgbWVjaGFuaXNtcy5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1leHRtYXA6JykuZm9yRWFjaChsaW5lID0+IHtcbiAgICBkZXNjcmlwdGlvbi5oZWFkZXJFeHRlbnNpb25zLnB1c2goU0RQVXRpbHMucGFyc2VFeHRtYXAobGluZSkpO1xuICB9KTtcbiAgY29uc3Qgd2lsZGNhcmRSdGNwRmIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtZmI6KiAnKVxuICAgIC5tYXAoU0RQVXRpbHMucGFyc2VSdGNwRmIpO1xuICBkZXNjcmlwdGlvbi5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgd2lsZGNhcmRSdGNwRmIuZm9yRWFjaChmYj0+IHtcbiAgICAgIGNvbnN0IGR1cGxpY2F0ZSA9IGNvZGVjLnJ0Y3BGZWVkYmFjay5maW5kKGV4aXN0aW5nRmVlZGJhY2sgPT4ge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdGZWVkYmFjay50eXBlID09PSBmYi50eXBlICYmXG4gICAgICAgICAgZXhpc3RpbmdGZWVkYmFjay5wYXJhbWV0ZXIgPT09IGZiLnBhcmFtZXRlcjtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFkdXBsaWNhdGUpIHtcbiAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrLnB1c2goZmIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgLy8gRklYTUU6IHBhcnNlIHJ0Y3AuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn07XG5cbi8vIEdlbmVyYXRlcyBwYXJ0cyBvZiB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gZGVzY3JpYmluZyB0aGUgY2FwYWJpbGl0aWVzIC9cbi8vIHBhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZVJ0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24oa2luZCwgY2Fwcykge1xuICBsZXQgc2RwID0gJyc7XG5cbiAgLy8gQnVpbGQgdGhlIG1saW5lLlxuICBzZHAgKz0gJ209JyArIGtpbmQgKyAnICc7XG4gIHNkcCArPSBjYXBzLmNvZGVjcy5sZW5ndGggPiAwID8gJzknIDogJzAnOyAvLyByZWplY3QgaWYgbm8gY29kZWNzLlxuICBzZHAgKz0gJyAnICsgKGNhcHMucHJvZmlsZSB8fCAnVURQL1RMUy9SVFAvU0FWUEYnKSArICcgJztcbiAgc2RwICs9IGNhcHMuY29kZWNzLm1hcChjb2RlYyA9PiB7XG4gICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVjLnBheWxvYWRUeXBlO1xuICB9KS5qb2luKCcgJykgKyAnXFxyXFxuJztcblxuICBzZHAgKz0gJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nO1xuICBzZHAgKz0gJ2E9cnRjcDo5IElOIElQNCAwLjAuMC4wXFxyXFxuJztcblxuICAvLyBBZGQgYT1ydHBtYXAgbGluZXMgZm9yIGVhY2ggY29kZWMuIEFsc28gZm10cCBhbmQgcnRjcC1mYi5cbiAgY2Fwcy5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgc2RwICs9IFNEUFV0aWxzLndyaXRlUnRwTWFwKGNvZGVjKTtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVGbXRwKGNvZGVjKTtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVSdGNwRmIoY29kZWMpO1xuICB9KTtcbiAgbGV0IG1heHB0aW1lID0gMDtcbiAgY2Fwcy5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgaWYgKGNvZGVjLm1heHB0aW1lID4gbWF4cHRpbWUpIHtcbiAgICAgIG1heHB0aW1lID0gY29kZWMubWF4cHRpbWU7XG4gICAgfVxuICB9KTtcbiAgaWYgKG1heHB0aW1lID4gMCkge1xuICAgIHNkcCArPSAnYT1tYXhwdGltZTonICsgbWF4cHRpbWUgKyAnXFxyXFxuJztcbiAgfVxuXG4gIGlmIChjYXBzLmhlYWRlckV4dGVuc2lvbnMpIHtcbiAgICBjYXBzLmhlYWRlckV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlRXh0bWFwKGV4dGVuc2lvbik7XG4gICAgfSk7XG4gIH1cbiAgLy8gRklYTUU6IHdyaXRlIGZlY01lY2hhbmlzbXMuXG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mXG4vLyBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnMuXG5TRFBVdGlscy5wYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBlbmNvZGluZ1BhcmFtZXRlcnMgPSBbXTtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBTRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMobWVkaWFTZWN0aW9uKTtcbiAgY29uc3QgaGFzUmVkID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdSRUQnKSAhPT0gLTE7XG4gIGNvbnN0IGhhc1VscGZlYyA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignVUxQRkVDJykgIT09IC0xO1xuXG4gIC8vIGZpbHRlciBhPXNzcmM6Li4uIGNuYW1lOiwgaWdub3JlIFBsYW5CLW1zaWRcbiAgY29uc3Qgc3NyY3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpXG4gICAgLmZpbHRlcihwYXJ0cyA9PiBwYXJ0cy5hdHRyaWJ1dGUgPT09ICdjbmFtZScpO1xuICBjb25zdCBwcmltYXJ5U3NyYyA9IHNzcmNzLmxlbmd0aCA+IDAgJiYgc3NyY3NbMF0uc3NyYztcbiAgbGV0IHNlY29uZGFyeVNzcmM7XG5cbiAgY29uc3QgZmxvd3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmMtZ3JvdXA6RklEJylcbiAgICAubWFwKGxpbmUgPT4ge1xuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxNykuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiBwYXJ0cy5tYXAocGFydCA9PiBwYXJzZUludChwYXJ0LCAxMCkpO1xuICAgIH0pO1xuICBpZiAoZmxvd3MubGVuZ3RoID4gMCAmJiBmbG93c1swXS5sZW5ndGggPiAxICYmIGZsb3dzWzBdWzBdID09PSBwcmltYXJ5U3NyYykge1xuICAgIHNlY29uZGFyeVNzcmMgPSBmbG93c1swXVsxXTtcbiAgfVxuXG4gIGRlc2NyaXB0aW9uLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICBpZiAoY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpID09PSAnUlRYJyAmJiBjb2RlYy5wYXJhbWV0ZXJzLmFwdCkge1xuICAgICAgbGV0IGVuY1BhcmFtID0ge1xuICAgICAgICBzc3JjOiBwcmltYXJ5U3NyYyxcbiAgICAgICAgY29kZWNQYXlsb2FkVHlwZTogcGFyc2VJbnQoY29kZWMucGFyYW1ldGVycy5hcHQsIDEwKSxcbiAgICAgIH07XG4gICAgICBpZiAocHJpbWFyeVNzcmMgJiYgc2Vjb25kYXJ5U3NyYykge1xuICAgICAgICBlbmNQYXJhbS5ydHggPSB7c3NyYzogc2Vjb25kYXJ5U3NyY307XG4gICAgICB9XG4gICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaChlbmNQYXJhbSk7XG4gICAgICBpZiAoaGFzUmVkKSB7XG4gICAgICAgIGVuY1BhcmFtID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbmNQYXJhbSkpO1xuICAgICAgICBlbmNQYXJhbS5mZWMgPSB7XG4gICAgICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXG4gICAgICAgICAgbWVjaGFuaXNtOiBoYXNVbHBmZWMgPyAncmVkK3VscGZlYycgOiAncmVkJyxcbiAgICAgICAgfTtcbiAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChlbmNvZGluZ1BhcmFtZXRlcnMubGVuZ3RoID09PSAwICYmIHByaW1hcnlTc3JjKSB7XG4gICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goe1xuICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXG4gICAgfSk7XG4gIH1cblxuICAvLyB3ZSBzdXBwb3J0IGJvdGggYj1BUyBhbmQgYj1USUFTIGJ1dCBpbnRlcnByZXQgQVMgYXMgVElBUy5cbiAgbGV0IGJhbmR3aWR0aCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2I9Jyk7XG4gIGlmIChiYW5kd2lkdGgubGVuZ3RoKSB7XG4gICAgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPVRJQVM6JykgPT09IDApIHtcbiAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHJpbmcoNyksIDEwKTtcbiAgICB9IGVsc2UgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPUFTOicpID09PSAwKSB7XG4gICAgICAvLyB1c2UgZm9ybXVsYSBmcm9tIEpTRVAgdG8gY29udmVydCBiPUFTIHRvIFRJQVMgdmFsdWUuXG4gICAgICBiYW5kd2lkdGggPSBwYXJzZUludChiYW5kd2lkdGhbMF0uc3Vic3RyaW5nKDUpLCAxMCkgKiAxMDAwICogMC45NVxuICAgICAgICAgIC0gKDUwICogNDAgKiA4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFuZHdpZHRoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbmNvZGluZ1BhcmFtZXRlcnMuZm9yRWFjaChwYXJhbXMgPT4ge1xuICAgICAgcGFyYW1zLm1heEJpdHJhdGUgPSBiYW5kd2lkdGg7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nUGFyYW1ldGVycztcbn07XG5cbi8vIHBhcnNlcyBodHRwOi8vZHJhZnQub3J0Yy5vcmcvI3J0Y3J0Y3BwYXJhbWV0ZXJzKlxuU0RQVXRpbHMucGFyc2VSdGNwUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBydGNwUGFyYW1ldGVycyA9IHt9O1xuXG4gIC8vIEdldHMgdGhlIGZpcnN0IFNTUkMuIE5vdGUgdGhhdCB3aXRoIFJUWCB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZVxuICAvLyBTU1JDcy5cbiAgY29uc3QgcmVtb3RlU3NyYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAgIC5tYXAobGluZSA9PiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKSlcbiAgICAuZmlsdGVyKG9iaiA9PiBvYmouYXR0cmlidXRlID09PSAnY25hbWUnKVswXTtcbiAgaWYgKHJlbW90ZVNzcmMpIHtcbiAgICBydGNwUGFyYW1ldGVycy5jbmFtZSA9IHJlbW90ZVNzcmMudmFsdWU7XG4gICAgcnRjcFBhcmFtZXRlcnMuc3NyYyA9IHJlbW90ZVNzcmMuc3NyYztcbiAgfVxuXG4gIC8vIEVkZ2UgdXNlcyB0aGUgY29tcG91bmQgYXR0cmlidXRlIGluc3RlYWQgb2YgcmVkdWNlZFNpemVcbiAgLy8gY29tcG91bmQgaXMgIXJlZHVjZWRTaXplXG4gIGNvbnN0IHJzaXplID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLXJzaXplJyk7XG4gIHJ0Y3BQYXJhbWV0ZXJzLnJlZHVjZWRTaXplID0gcnNpemUubGVuZ3RoID4gMDtcbiAgcnRjcFBhcmFtZXRlcnMuY29tcG91bmQgPSByc2l6ZS5sZW5ndGggPT09IDA7XG5cbiAgLy8gcGFyc2VzIHRoZSBydGNwLW11eCBhdHRy0ZZidXRlLlxuICAvLyBOb3RlIHRoYXQgRWRnZSBkb2VzIG5vdCBzdXBwb3J0IHVubXV4ZWQgUlRDUC5cbiAgY29uc3QgbXV4ID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLW11eCcpO1xuICBydGNwUGFyYW1ldGVycy5tdXggPSBtdXgubGVuZ3RoID4gMDtcblxuICByZXR1cm4gcnRjcFBhcmFtZXRlcnM7XG59O1xuXG5TRFBVdGlscy53cml0ZVJ0Y3BQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocnRjcFBhcmFtZXRlcnMpIHtcbiAgbGV0IHNkcCA9ICcnO1xuICBpZiAocnRjcFBhcmFtZXRlcnMucmVkdWNlZFNpemUpIHtcbiAgICBzZHAgKz0gJ2E9cnRjcC1yc2l6ZVxcclxcbic7XG4gIH1cbiAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLm11eCkge1xuICAgIHNkcCArPSAnYT1ydGNwLW11eFxcclxcbic7XG4gIH1cbiAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLnNzcmMgIT09IHVuZGVmaW5lZCAmJiBydGNwUGFyYW1ldGVycy5jbmFtZSkge1xuICAgIHNkcCArPSAnYT1zc3JjOicgKyBydGNwUGFyYW1ldGVycy5zc3JjICtcbiAgICAgICcgY25hbWU6JyArIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lICsgJ1xcclxcbic7XG4gIH1cbiAgcmV0dXJuIHNkcDtcbn07XG5cblxuLy8gcGFyc2VzIGVpdGhlciBhPW1zaWQ6IG9yIGE9c3NyYzouLi4gbXNpZCBsaW5lcyBhbmQgcmV0dXJuc1xuLy8gdGhlIGlkIG9mIHRoZSBNZWRpYVN0cmVhbSBhbmQgTWVkaWFTdHJlYW1UcmFjay5cblNEUFV0aWxzLnBhcnNlTXNpZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBsZXQgcGFydHM7XG4gIGNvbnN0IHNwZWMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1zaWQ6Jyk7XG4gIGlmIChzcGVjLmxlbmd0aCA9PT0gMSkge1xuICAgIHBhcnRzID0gc3BlY1swXS5zdWJzdHJpbmcoNykuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge3N0cmVhbTogcGFydHNbMF0sIHRyYWNrOiBwYXJ0c1sxXX07XG4gIH1cbiAgY29uc3QgcGxhbkIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpXG4gICAgLmZpbHRlcihtc2lkUGFydHMgPT4gbXNpZFBhcnRzLmF0dHJpYnV0ZSA9PT0gJ21zaWQnKTtcbiAgaWYgKHBsYW5CLmxlbmd0aCA+IDApIHtcbiAgICBwYXJ0cyA9IHBsYW5CWzBdLnZhbHVlLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtzdHJlYW06IHBhcnRzWzBdLCB0cmFjazogcGFydHNbMV19O1xuICB9XG59O1xuXG4vLyBTQ1RQXG4vLyBwYXJzZXMgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYgZmlyc3QgYW5kIGZhbGxzIGJhY2tcbi8vIHRvIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTA1XG5TRFBVdGlscy5wYXJzZVNjdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBtbGluZSA9IFNEUFV0aWxzLnBhcnNlTUxpbmUobWVkaWFTZWN0aW9uKTtcbiAgY29uc3QgbWF4U2l6ZUxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1heC1tZXNzYWdlLXNpemU6Jyk7XG4gIGxldCBtYXhNZXNzYWdlU2l6ZTtcbiAgaWYgKG1heFNpemVMaW5lLmxlbmd0aCA+IDApIHtcbiAgICBtYXhNZXNzYWdlU2l6ZSA9IHBhcnNlSW50KG1heFNpemVMaW5lWzBdLnN1YnN0cmluZygxOSksIDEwKTtcbiAgfVxuICBpZiAoaXNOYU4obWF4TWVzc2FnZVNpemUpKSB7XG4gICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcbiAgfVxuICBjb25zdCBzY3RwUG9ydCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c2N0cC1wb3J0OicpO1xuICBpZiAoc2N0cFBvcnQubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBwb3J0OiBwYXJzZUludChzY3RwUG9ydFswXS5zdWJzdHJpbmcoMTIpLCAxMCksXG4gICAgICBwcm90b2NvbDogbWxpbmUuZm10LFxuICAgICAgbWF4TWVzc2FnZVNpemUsXG4gICAgfTtcbiAgfVxuICBjb25zdCBzY3RwTWFwTGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHBtYXA6Jyk7XG4gIGlmIChzY3RwTWFwTGluZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHBhcnRzID0gc2N0cE1hcExpbmVzWzBdXG4gICAgICAuc3Vic3RyaW5nKDEwKVxuICAgICAgLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICBwcm90b2NvbDogcGFydHNbMV0sXG4gICAgICBtYXhNZXNzYWdlU2l6ZSxcbiAgICB9O1xuICB9XG59O1xuXG4vLyBTQ1RQXG4vLyBvdXRwdXRzIHRoZSBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiB2ZXJzaW9uIHRoYXQgYWxsIGJyb3dzZXJzXG4vLyBzdXBwb3J0IGJ5IG5vdyByZWNlaXZpbmcgaW4gdGhpcyBmb3JtYXQsIHVubGVzcyB3ZSBvcmlnaW5hbGx5IHBhcnNlZFxuLy8gYXMgdGhlIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTA1IGZvcm1hdCAoaW5kaWNhdGVkIGJ5IHRoZSBtLWxpbmVcbi8vIHByb3RvY29sIG9mIERUTFMvU0NUUCAtLSB3aXRob3V0IFVEUC8gb3IgVENQLylcblNEUFV0aWxzLndyaXRlU2N0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24obWVkaWEsIHNjdHApIHtcbiAgbGV0IG91dHB1dCA9IFtdO1xuICBpZiAobWVkaWEucHJvdG9jb2wgIT09ICdEVExTL1NDVFAnKSB7XG4gICAgb3V0cHV0ID0gW1xuICAgICAgJ209JyArIG1lZGlhLmtpbmQgKyAnIDkgJyArIG1lZGlhLnByb3RvY29sICsgJyAnICsgc2N0cC5wcm90b2NvbCArICdcXHJcXG4nLFxuICAgICAgJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nLFxuICAgICAgJ2E9c2N0cC1wb3J0OicgKyBzY3RwLnBvcnQgKyAnXFxyXFxuJyxcbiAgICBdO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IFtcbiAgICAgICdtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucG9ydCArICdcXHJcXG4nLFxuICAgICAgJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nLFxuICAgICAgJ2E9c2N0cG1hcDonICsgc2N0cC5wb3J0ICsgJyAnICsgc2N0cC5wcm90b2NvbCArICcgNjU1MzVcXHJcXG4nLFxuICAgIF07XG4gIH1cbiAgaWYgKHNjdHAubWF4TWVzc2FnZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC5wdXNoKCdhPW1heC1tZXNzYWdlLXNpemU6JyArIHNjdHAubWF4TWVzc2FnZVNpemUgKyAnXFxyXFxuJyk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbi8vIEdlbmVyYXRlIGEgc2Vzc2lvbiBJRCBmb3IgU0RQLlxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtcnRjd2ViLWpzZXAtMjAjc2VjdGlvbi01LjIuMVxuLy8gcmVjb21tZW5kcyB1c2luZyBhIGNyeXB0b2dyYXBoaWNhbGx5IHJhbmRvbSArdmUgNjQtYml0IHZhbHVlXG4vLyBidXQgcmlnaHQgbm93IHRoaXMgc2hvdWxkIGJlIGFjY2VwdGFibGUgYW5kIHdpdGhpbiB0aGUgcmlnaHQgcmFuZ2VcblNEUFV0aWxzLmdlbmVyYXRlU2Vzc2lvbklkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc3Vic3RyKDIsIDIyKTtcbn07XG5cbi8vIFdyaXRlIGJvaWxlciBwbGF0ZSBmb3Igc3RhcnQgb2YgU0RQXG4vLyBzZXNzSWQgYXJndW1lbnQgaXMgb3B0aW9uYWwgLSBpZiBub3Qgc3VwcGxpZWQgaXQgd2lsbFxuLy8gYmUgZ2VuZXJhdGVkIHJhbmRvbWx5XG4vLyBzZXNzVmVyc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gMlxuLy8gc2Vzc1VzZXIgaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvICd0aGlzaXNhZGFwdGVyb3J0YydcblNEUFV0aWxzLndyaXRlU2Vzc2lvbkJvaWxlcnBsYXRlID0gZnVuY3Rpb24oc2Vzc0lkLCBzZXNzVmVyLCBzZXNzVXNlcikge1xuICBsZXQgc2Vzc2lvbklkO1xuICBjb25zdCB2ZXJzaW9uID0gc2Vzc1ZlciAhPT0gdW5kZWZpbmVkID8gc2Vzc1ZlciA6IDI7XG4gIGlmIChzZXNzSWQpIHtcbiAgICBzZXNzaW9uSWQgPSBzZXNzSWQ7XG4gIH0gZWxzZSB7XG4gICAgc2Vzc2lvbklkID0gU0RQVXRpbHMuZ2VuZXJhdGVTZXNzaW9uSWQoKTtcbiAgfVxuICBjb25zdCB1c2VyID0gc2Vzc1VzZXIgfHwgJ3RoaXNpc2FkYXB0ZXJvcnRjJztcbiAgLy8gRklYTUU6IHNlc3MtaWQgc2hvdWxkIGJlIGFuIE5UUCB0aW1lc3RhbXAuXG4gIHJldHVybiAndj0wXFxyXFxuJyArXG4gICAgICAnbz0nICsgdXNlciArICcgJyArIHNlc3Npb25JZCArICcgJyArIHZlcnNpb24gK1xuICAgICAgICAnIElOIElQNCAxMjcuMC4wLjFcXHJcXG4nICtcbiAgICAgICdzPS1cXHJcXG4nICtcbiAgICAgICd0PTAgMFxcclxcbic7XG59O1xuXG4vLyBHZXRzIHRoZSBkaXJlY3Rpb24gZnJvbSB0aGUgbWVkaWFTZWN0aW9uIG9yIHRoZSBzZXNzaW9ucGFydC5cblNEUFV0aWxzLmdldERpcmVjdGlvbiA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgLy8gTG9vayBmb3Igc2VuZHJlY3YsIHNlbmRvbmx5LCByZWN2b25seSwgaW5hY3RpdmUsIGRlZmF1bHQgdG8gc2VuZHJlY3YuXG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3dpdGNoIChsaW5lc1tpXSkge1xuICAgICAgY2FzZSAnYT1zZW5kcmVjdic6XG4gICAgICBjYXNlICdhPXNlbmRvbmx5JzpcbiAgICAgIGNhc2UgJ2E9cmVjdm9ubHknOlxuICAgICAgY2FzZSAnYT1pbmFjdGl2ZSc6XG4gICAgICAgIHJldHVybiBsaW5lc1tpXS5zdWJzdHJpbmcoMik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBGSVhNRTogV2hhdCBzaG91bGQgaGFwcGVuIGhlcmU/XG4gICAgfVxuICB9XG4gIGlmIChzZXNzaW9ucGFydCkge1xuICAgIHJldHVybiBTRFBVdGlscy5nZXREaXJlY3Rpb24oc2Vzc2lvbnBhcnQpO1xuICB9XG4gIHJldHVybiAnc2VuZHJlY3YnO1xufTtcblxuU0RQVXRpbHMuZ2V0S2luZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgY29uc3QgbWxpbmUgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xuICByZXR1cm4gbWxpbmVbMF0uc3Vic3RyaW5nKDIpO1xufTtcblxuU0RQVXRpbHMuaXNSZWplY3RlZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICByZXR1cm4gbWVkaWFTZWN0aW9uLnNwbGl0KCcgJywgMilbMV0gPT09ICcwJztcbn07XG5cblNEUFV0aWxzLnBhcnNlTUxpbmUgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIGNvbnN0IHBhcnRzID0gbGluZXNbMF0uc3Vic3RyaW5nKDIpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAga2luZDogcGFydHNbMF0sXG4gICAgcG9ydDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICBwcm90b2NvbDogcGFydHNbMl0sXG4gICAgZm10OiBwYXJ0cy5zbGljZSgzKS5qb2luKCcgJyksXG4gIH07XG59O1xuXG5TRFBVdGlscy5wYXJzZU9MaW5lID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IGxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdvPScpWzBdO1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDIpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgdXNlcm5hbWU6IHBhcnRzWzBdLFxuICAgIHNlc3Npb25JZDogcGFydHNbMV0sXG4gICAgc2Vzc2lvblZlcnNpb246IHBhcnNlSW50KHBhcnRzWzJdLCAxMCksXG4gICAgbmV0VHlwZTogcGFydHNbM10sXG4gICAgYWRkcmVzc1R5cGU6IHBhcnRzWzRdLFxuICAgIGFkZHJlc3M6IHBhcnRzWzVdLFxuICB9O1xufTtcblxuLy8gYSB2ZXJ5IG5haXZlIGludGVycHJldGF0aW9uIG9mIGEgdmFsaWQgU0RQLlxuU0RQVXRpbHMuaXNWYWxpZFNEUCA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgaWYgKHR5cGVvZiBibG9iICE9PSAnc3RyaW5nJyB8fCBibG9iLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGluZXNbaV0ubGVuZ3RoIDwgMiB8fCBsaW5lc1tpXS5jaGFyQXQoMSkgIT09ICc9Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBUT0RPOiBjaGVjayB0aGUgbW9kaWZpZXIgYSBiaXQgbW9yZS5cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICBtb2R1bGUuZXhwb3J0cyA9IFNEUFV0aWxzO1xufVxuIiwidmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG5mdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWlzUHJvZHVjdGlvbikge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGV4dCA9IFwiV2FybmluZzogXCIgKyBtZXNzYWdlO1xuXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKHRleHQpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aHJvdyBFcnJvcih0ZXh0KTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdhcm5pbmc7XG4iLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgRmxhZ3MsIE51bWVyaWNQYXJhbWV0ZXJzIH0gZnJvbSAnLi4vQ29uZmlnL0NvbmZpZyc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG5pbXBvcnQgeyBBZmtUaW1lZE91dEV2ZW50LCBBZmtXYXJuaW5nQWN0aXZhdGVFdmVudCwgQWZrV2FybmluZ0RlYWN0aXZhdGVFdmVudCwgQWZrV2FybmluZ1VwZGF0ZUV2ZW50IH0gZnJvbSAnLi4vVXRpbC9FdmVudEVtaXR0ZXInO1xuZXhwb3J0IGNsYXNzIEFGS0NvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgcGl4ZWxTdHJlYW1pbmcsIG9uRGlzbWlzc0Fmaykge1xuICAgICAgICAvLyB0aW1lIG91dCBsb2dpYyBkZXRhaWxzXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY291bnRkb3duQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2FyblRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvdW50RG93biA9IDA7XG4gICAgICAgIHRoaXMuY291bnREb3duVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nID0gcGl4ZWxTdHJlYW1pbmc7XG4gICAgICAgIHRoaXMub25EaXNtaXNzQWZrID0gb25EaXNtaXNzQWZrO1xuICAgICAgICB0aGlzLm9uQUZLVGltZWRPdXRDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBRksgdGltZWQgb3V0LCBkaWQgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhpcyBjYWxsYmFjaz8nKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZHMgdGhhdCBvY2N1ciB3aGVuIGFuIGFmayBldmVudCBsaXN0ZW5lciBpcyBjbGlja2VkXG4gICAgICovXG4gICAgb25BZmtDbGljaygpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNvdW50RG93blRpbWVyKTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlIHx8IHRoaXMuY291bnRkb3duQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0QWZrV2FybmluZ1RpbWVyKCk7XG4gICAgICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLmRpc3BhdGNoRXZlbnQobmV3IEFma1dhcm5pbmdEZWFjdGl2YXRlRXZlbnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIHdhcm5pbmcgdGltZXIgaWYgYSB0aW1lb3V0IGlzIHNldCBncmVhdGVyIHRoYXQgMCBzZWNvbmRzXG4gICAgICovXG4gICAgc3RhcnRBZmtXYXJuaW5nVGltZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5nZXROdW1lcmljU2V0dGluZ1ZhbHVlKE51bWVyaWNQYXJhbWV0ZXJzLkFGS1RpbWVvdXRTZWNzKSA+IDAgJiZcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuQUZLRGV0ZWN0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0QWZrV2FybmluZ1RpbWVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIGFmayB3YXJuaW5nIHRpbWVyXG4gICAgICovXG4gICAgc3RvcEFma1dhcm5pbmdUaW1lcigpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb3VudGRvd25BY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMud2FyblRpbWVyKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNvdW50RG93blRpbWVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2UgdGhlIHRpbWVyIHdoaWNoIHdoZW4gZWxhcHNlZCB3aWxsIHdhcm4gdGhlIHVzZXIgdGhleSBhcmUgaW5hY3RpdmUuXG4gICAgICovXG4gICAgcGF1c2VBZmtXYXJuaW5nVGltZXIoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSB1c2VyIGludGVyYWN0cyB0aGVuIHJlc2V0IHRoZSB3YXJuaW5nIHRpbWVyLlxuICAgICAqL1xuICAgIHJlc2V0QWZrV2FybmluZ1RpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgJiYgdGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5BRktEZXRlY3Rpb24pKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy53YXJuVGltZXIpO1xuICAgICAgICAgICAgdGhpcy53YXJuVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYWN0aXZhdGVBZmtFdmVudCgpLCB0aGlzLmNvbmZpZy5nZXROdW1lcmljU2V0dGluZ1ZhbHVlKE51bWVyaWNQYXJhbWV0ZXJzLkFGS1RpbWVvdXRTZWNzKSAqIDEwMDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIEFGSyBvdmVybGF5IGFuZCBiZWdpbiB0aGUgY291bnREb3duXG4gICAgICovXG4gICAgYWN0aXZhdGVBZmtFdmVudCgpIHtcbiAgICAgICAgLy8gUGF1c2UgdGhlIHRpbWVyIHdoaWxlIHRoZSB1c2VyIGlzIGxvb2tpbmcgYXQgdGhlIGluYWN0aXZpdHkgd2FybmluZyBvdmVybGF5XG4gICAgICAgIHRoaXMucGF1c2VBZmtXYXJuaW5nVGltZXIoKTtcbiAgICAgICAgLy8gaW5zdGFudGlhdGUgYSBuZXcgb3ZlcmxheVxuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLmRpc3BhdGNoRXZlbnQobmV3IEFma1dhcm5pbmdBY3RpdmF0ZUV2ZW50KHtcbiAgICAgICAgICAgIGNvdW50RG93bjogdGhpcy5jb3VudERvd24sXG4gICAgICAgICAgICBkaXNtaXNzQWZrOiB0aGlzLm9uRGlzbWlzc0Fma1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIHVwZGF0ZSBvdXIgY291bnREb3duIHRpbWVyIGFuZCBvdmVybGF5IGNvbnRlbnRzXG4gICAgICAgIHRoaXMuY291bnREb3duID0gdGhpcy5jb25maWcuZ2V0TnVtZXJpY1NldHRpbmdWYWx1ZShOdW1lcmljUGFyYW1ldGVycy5BRktDb3VudGRvd25TZWNzKTtcbiAgICAgICAgdGhpcy5jb3VudGRvd25BY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLmRpc3BhdGNoRXZlbnQobmV3IEFma1dhcm5pbmdVcGRhdGVFdmVudCh7IGNvdW50RG93bjogdGhpcy5jb3VudERvd24gfSkpO1xuICAgICAgICAvLyBpZiB3ZSBhcmUgaW4gbG9ja2VkIG1vdXNlIGV4aXQgcG9pbnRlcmxvY2tcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkhvdmVyaW5nTW91c2VNb2RlKSkge1xuICAgICAgICAgICAgLy8gbWlub3IgaGFjayB0byBhbGxldmlhdGUgaW9zIG5vdCBzdXBwb3J0aW5nIHBvaW50ZXJsb2NrXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZXhpdFBvaW50ZXJMb2NrKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZXhpdFBvaW50ZXJMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzZXQgb3VyIGNvdW50RG93biBpbnRlcnZhbCBhY2NvcmRpbmdseVxuICAgICAgICB0aGlzLmNvdW50RG93blRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb3VudERvd24tLTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50RG93biA9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgZmFpbGVkIHRvIGNsaWNrIHNvIGhpZGUgdGhlIG92ZXJsYXkgYW5kIGRpc2Nvbm5lY3QgdGhlbS5cbiAgICAgICAgICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLmRpc3BhdGNoRXZlbnQobmV3IEFma1RpbWVkT3V0RXZlbnQoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkFGS1RpbWVkT3V0Q2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuSW5mbygnWW91IGhhdmUgYmVlbiBkaXNjb25uZWN0ZWQgZHVlIHRvIGluYWN0aXZpdHknKTtcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggb2ZmIHRoZSBhZmsgZmVhdHVyZSBhcyBzdHJlYW0gaGFzIGNsb3NlZFxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEFma1dhcm5pbmdUaW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBBZmtXYXJuaW5nVXBkYXRlRXZlbnQoeyBjb3VudERvd246IHRoaXMuY291bnREb3duIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QUZLQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuaW1wb3J0IHsgU2V0dGluZ0ZsYWcgfSBmcm9tICcuL1NldHRpbmdGbGFnJztcbmltcG9ydCB7IFNldHRpbmdOdW1iZXIgfSBmcm9tICcuL1NldHRpbmdOdW1iZXInO1xuaW1wb3J0IHsgU2V0dGluZ1RleHQgfSBmcm9tICcuL1NldHRpbmdUZXh0JztcbmltcG9ydCB7IFNldHRpbmdPcHRpb24gfSBmcm9tICcuL1NldHRpbmdPcHRpb24nO1xuaW1wb3J0IHsgU2V0dGluZ3NDaGFuZ2VkRXZlbnQgfSBmcm9tICcuLi9VdGlsL0V2ZW50RW1pdHRlcic7XG5pbXBvcnQgeyBCcm93c2VyVXRpbHMgfSBmcm9tICcuLi9VdGlsL0Jyb3dzZXJVdGlscyc7XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBmbGFncyB0aGF0IGNhbiBiZSB0b2dnbGVkIGFuZCBhcmUgY29yZSB0byBhbGwgUGl4ZWwgU3RyZWFtaW5nIGV4cGVyaWVuY2VzLlxuICogVGhlc2UgYXJlIHVzZWQgaW4gdGhlIGBDb25maWcuRmxhZ3NgIG1hcC5cbiAqL1xuZXhwb3J0IGNsYXNzIEZsYWdzIHtcbn1cbkZsYWdzLkF1dG9Db25uZWN0ID0gJ0F1dG9Db25uZWN0JztcbkZsYWdzLkF1dG9QbGF5VmlkZW8gPSAnQXV0b1BsYXlWaWRlbyc7XG5GbGFncy5BRktEZXRlY3Rpb24gPSAnVGltZW91dElmSWRsZSc7XG5GbGFncy5Ib3ZlcmluZ01vdXNlTW9kZSA9ICdIb3ZlcmluZ01vdXNlJztcbkZsYWdzLkZvcmNlTW9ub0F1ZGlvID0gJ0ZvcmNlTW9ub0F1ZGlvJztcbkZsYWdzLkZvcmNlVFVSTiA9ICdGb3JjZVRVUk4nO1xuRmxhZ3MuRmFrZU1vdXNlV2l0aFRvdWNoZXMgPSAnRmFrZU1vdXNlV2l0aFRvdWNoZXMnO1xuRmxhZ3MuSXNRdWFsaXR5Q29udHJvbGxlciA9ICdDb250cm9sc1F1YWxpdHknO1xuRmxhZ3MuTWF0Y2hWaWV3cG9ydFJlc29sdXRpb24gPSAnTWF0Y2hWaWV3cG9ydFJlcyc7XG5GbGFncy5TdGFydFZpZGVvTXV0ZWQgPSAnU3RhcnRWaWRlb011dGVkJztcbkZsYWdzLlN1cHByZXNzQnJvd3NlcktleXMgPSAnU3VwcHJlc3NCcm93c2VyS2V5cyc7XG5GbGFncy5Vc2VNaWMgPSAnVXNlTWljJztcbkZsYWdzLlVzZU1vZGFsRm9yVGV4dElucHV0ID0gJ1VzZU1vZGFsRm9yVGV4dElucHV0JztcbkZsYWdzLlVzZUNhbWVyYSA9ICdVc2VDYW1lcmEnO1xuRmxhZ3MuS2V5Ym9hcmRJbnB1dCA9ICdLZXlib2FyZElucHV0JztcbkZsYWdzLk1vdXNlSW5wdXQgPSAnTW91c2VJbnB1dCc7XG5GbGFncy5Ub3VjaElucHV0ID0gJ1RvdWNoSW5wdXQnO1xuRmxhZ3MuR2FtZXBhZElucHV0ID0gJ0dhbWVwYWRJbnB1dCc7XG5GbGFncy5YUkNvbnRyb2xsZXJJbnB1dCA9ICdYUkNvbnRyb2xsZXJJbnB1dCc7XG5GbGFncy5XYWl0Rm9yU3RyZWFtZXIgPSAnV2FpdEZvclN0cmVhbWVyJztcbkZsYWdzLkhpZGVVSSA9ICdIaWRlVUknO1xuRmxhZ3MuRW5hYmxlQ2FwdHVyZVRpbWVFeHQgPSAnRW5hYmxlQ2FwdHVyZVRpbWVFeHQnO1xuRmxhZ3MuQnJvd3NlclNlbmRPZmZlciA9ICdCcm93c2VyU2VuZE9mZmVyJztcbkZsYWdzLkxhdGVuY3lDU1YgPSAnTGF0ZW5jeUNTVic7XG5leHBvcnQgY29uc3QgaXNGbGFnSWQgPSAoaWQpID0+IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKEZsYWdzKS5zb21lKChuYW1lKSA9PiBGbGFnc1tuYW1lXSA9PT0gaWQpO1xuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgbnVtZXJpYyBwYXJhbWV0ZXJzIHRoYXQgYXJlIGNvcmUgdG8gYWxsIFBpeGVsIFN0cmVhbWluZyBleHBlcmllbmNlcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBOdW1lcmljUGFyYW1ldGVycyB7XG59XG5OdW1lcmljUGFyYW1ldGVycy5BRktUaW1lb3V0U2VjcyA9ICdBRktUaW1lb3V0Jztcbk51bWVyaWNQYXJhbWV0ZXJzLkFGS0NvdW50ZG93blNlY3MgPSAnQUZLQ291bnRkb3duJztcbk51bWVyaWNQYXJhbWV0ZXJzLk1pblFQID0gJ01pblFQJztcbk51bWVyaWNQYXJhbWV0ZXJzLk1heFFQID0gJ01heFFQJztcbk51bWVyaWNQYXJhbWV0ZXJzLk1pblF1YWxpdHkgPSAnTWluUXVhbGl0eSc7XG5OdW1lcmljUGFyYW1ldGVycy5NYXhRdWFsaXR5ID0gJ01heFF1YWxpdHknO1xuTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1pbiA9ICdDb21wYXRRdWFsaXR5TWluJztcbk51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNYXggPSAnQ29tcGF0UXVhbGl0eU1heCc7XG5OdW1lcmljUGFyYW1ldGVycy5XZWJSVENGUFMgPSAnV2ViUlRDRlBTJztcbk51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01pbkJpdHJhdGUgPSAnV2ViUlRDTWluQml0cmF0ZSc7XG5OdW1lcmljUGFyYW1ldGVycy5XZWJSVENNYXhCaXRyYXRlID0gJ1dlYlJUQ01heEJpdHJhdGUnO1xuTnVtZXJpY1BhcmFtZXRlcnMuTWF4UmVjb25uZWN0QXR0ZW1wdHMgPSAnTWF4UmVjb25uZWN0QXR0ZW1wdHMnO1xuTnVtZXJpY1BhcmFtZXRlcnMuU3RyZWFtZXJBdXRvSm9pbkludGVydmFsID0gJ1N0cmVhbWVyQXV0b0pvaW5JbnRlcnZhbCc7XG5OdW1lcmljUGFyYW1ldGVycy5LZWVwYWxpdmVEZWxheSA9ICdLZWVwYWxpdmVEZWxheSc7XG5leHBvcnQgY29uc3QgaXNOdW1lcmljSWQgPSAoaWQpID0+IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE51bWVyaWNQYXJhbWV0ZXJzKS5zb21lKChuYW1lKSA9PiBOdW1lcmljUGFyYW1ldGVyc1tuYW1lXSA9PT0gaWQpO1xuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgdGV4dHVhbCBwYXJhbWV0ZXJzIHRoYXQgYXJlIGNvcmUgdG8gYWxsIFBpeGVsIFN0cmVhbWluZyBleHBlcmllbmNlcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXh0UGFyYW1ldGVycyB7XG59XG5UZXh0UGFyYW1ldGVycy5TaWduYWxsaW5nU2VydmVyVXJsID0gJ3NzJztcbmV4cG9ydCBjb25zdCBpc1RleHRJZCA9IChpZCkgPT4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoVGV4dFBhcmFtZXRlcnMpLnNvbWUoKG5hbWUpID0+IFRleHRQYXJhbWV0ZXJzW25hbWVdID09PSBpZCk7XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBlbnVtIGJhc2VkIHBhcmFtZXRlcnMgdGhhdCBhcmUgY29yZSB0byBhbGwgUGl4ZWwgU3RyZWFtaW5nIGV4cGVyaWVuY2VzLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIE9wdGlvblBhcmFtZXRlcnMge1xufVxuT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRDb2RlYyA9ICdQcmVmZXJyZWRDb2RlYyc7XG5PcHRpb25QYXJhbWV0ZXJzLlN0cmVhbWVySWQgPSAnU3RyZWFtZXJJZCc7XG5PcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZFF1YWxpdHkgPSAnUHJlZmVycmVkUXVhbGl0eSc7XG5leHBvcnQgY29uc3QgaXNPcHRpb25JZCA9IChpZCkgPT4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT3B0aW9uUGFyYW1ldGVycykuc29tZSgobmFtZSkgPT4gT3B0aW9uUGFyYW1ldGVyc1tuYW1lXSA9PT0gaWQpO1xuZXhwb3J0IGNsYXNzIENvbmZpZyB7XG4gICAgLy8gLS0tLS0tLS0tLS0tIFNldHRpbmdzIC0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgLyogQSBtYXAgb2YgZmxhZ3MgdGhhdCBjYW4gYmUgdG9nZ2xlZCAtIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0IGluIHRoZSBhcHBsaWNhdGlvbiAtIGUuZy4gVXNlIE1pYz8gKi9cbiAgICAgICAgdGhpcy5mbGFncyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyogQSBtYXAgb2YgbnVtZXJpY2FsIHNldHRpbmdzIC0gb3B0aW9ucyB0aGF0IGNhbiBiZSBpbiB0aGUgYXBwbGljYXRpb24gLSBlLmcuIE1pbkJpdHJhdGUgKi9cbiAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyogQSBtYXAgb2YgdGV4dCBzZXR0aW5ncyAtIGUuZy4gc2lnbmFsbGluZyBzZXJ2ZXIgdXJsICovXG4gICAgICAgIHRoaXMudGV4dFBhcmFtZXRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qIEEgbWFwIG9mIGVudW0gYmFzZWQgc2V0dGluZ3MgLSBlLmcuIHByZWZlcnJlZCBjb2RlYyAqL1xuICAgICAgICB0aGlzLm9wdGlvblBhcmFtZXRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IHsgaW5pdGlhbFNldHRpbmdzLCB1c2VVcmxQYXJhbXMsIHdlYlNvY2tldFByb3RvY29scyB9ID0gY29uZmlnO1xuICAgICAgICB0aGlzLl91c2VVcmxQYXJhbXMgPSAhIXVzZVVybFBhcmFtcztcbiAgICAgICAgdGhpcy5fd2ViU29ja2V0UHJvdG9jb2xzID0gd2ViU29ja2V0UHJvdG9jb2xzO1xuICAgICAgICB0aGlzLnBvcHVsYXRlRGVmYXVsdFNldHRpbmdzKHRoaXMuX3VzZVVybFBhcmFtcywgaW5pdGlhbFNldHRpbmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiByZWFkaW5nIGNvbmZpZ3VyYXRpb24gaW5pdGlhbCB2YWx1ZXMgZnJvbSBVUkwgcGFyYW1ldGVycywgYW5kXG4gICAgICogcGVyc2lzdGluZyBjaGFuZ2VzIGluIFVSTCB3aGVuIGNoYW5nZWQuXG4gICAgICovXG4gICAgZ2V0IHVzZVVybFBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZVVybFBhcmFtcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHByb3RvY29sIG9yIGxpc3Qgb2YgcHJvdG9jb2xzIHRvIHBhc3MgdG8gdGhlIHdlYnNvY2tldCBpZiBzZXQuXG4gICAgICovXG4gICAgZ2V0IHdlYlNvY2tldFByb3RvY29scygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlYlNvY2tldFByb3RvY29scztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9wdWxhdGUgdGhlIGRlZmF1bHQgc2V0dGluZ3MgZm9yIGEgUGl4ZWwgU3RyZWFtaW5nIGFwcGxpY2F0aW9uXG4gICAgICovXG4gICAgcG9wdWxhdGVEZWZhdWx0U2V0dGluZ3ModXNlVXJsUGFyYW1zLCBzZXR0aW5ncykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGV4dCBQYXJhbWV0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRleHRQYXJhbWV0ZXJzLnNldChUZXh0UGFyYW1ldGVycy5TaWduYWxsaW5nU2VydmVyVXJsLCBuZXcgU2V0dGluZ1RleHQoVGV4dFBhcmFtZXRlcnMuU2lnbmFsbGluZ1NlcnZlclVybCwgJ1NpZ25hbGxpbmcgdXJsJywgJ1VybCBvZiB0aGUgc2lnbmFsbGluZyBzZXJ2ZXInLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIFRleHRQYXJhbWV0ZXJzLlNpZ25hbGxpbmdTZXJ2ZXJVcmwpXG4gICAgICAgICAgICA/IHNldHRpbmdzW1RleHRQYXJhbWV0ZXJzLlNpZ25hbGxpbmdTZXJ2ZXJVcmxdXG4gICAgICAgICAgICA6IChsb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyAnd3NzOi8vJyA6ICd3czovLycpICtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgK1xuICAgICAgICAgICAgICAgIC8vIGZvciByZWFkYWJpbGl0eSwgd2Ugb21pdCB0aGUgcG9ydCBpZiBpdCdzIDgwXG4gICAgICAgICAgICAgICAgKHdpbmRvdy5sb2NhdGlvbi5wb3J0ID09PSAnODAnIHx8IHdpbmRvdy5sb2NhdGlvbi5wb3J0ID09PSAnJ1xuICAgICAgICAgICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICAgICAgICAgIDogYDoke3dpbmRvdy5sb2NhdGlvbi5wb3J0fWApLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5vcHRpb25QYXJhbWV0ZXJzLnNldChPcHRpb25QYXJhbWV0ZXJzLlN0cmVhbWVySWQsIG5ldyBTZXR0aW5nT3B0aW9uKE9wdGlvblBhcmFtZXRlcnMuU3RyZWFtZXJJZCwgJ1N0cmVhbWVyIElEJywgJ1RoZSBJRCBvZiB0aGUgc3RyZWFtZXIgdG8gc3RyZWFtLicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgT3B0aW9uUGFyYW1ldGVycy5TdHJlYW1lcklkKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tPcHRpb25QYXJhbWV0ZXJzLlN0cmVhbWVySWRdXG4gICAgICAgICAgICA6ICcnLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIE9wdGlvblBhcmFtZXRlcnMuU3RyZWFtZXJJZClcbiAgICAgICAgICAgID8gW3NldHRpbmdzW09wdGlvblBhcmFtZXRlcnMuU3RyZWFtZXJJZF1dXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIGNvbnN0IGdldERlZmF1bHRWaWRlb0NvZGVjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgdmlkZW9Db2RlY3MgPSBCcm93c2VyVXRpbHMuZ2V0U3VwcG9ydGVkVmlkZW9Db2RlY3MoKTtcbiAgICAgICAgICAgIC8vIElmIG9ubHkgb25lIG9wdGlvbiwgdGhlbiBzZWxlY3QgdGhhdC5cbiAgICAgICAgICAgIGlmICh2aWRlb0NvZGVjcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlb0NvZGVjc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZpZGVvQ29kZWNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0Q29kZWMgPSB2aWRlb0NvZGVjc1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIHZpZGVvQ29kZWNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlYy5zdGFydHNXaXRoKCdIMjY0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdENvZGVjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKCdDb3VsZCBub3QgZmluZCBhbnkgcmVhc29uYWJsZSB2aWRlbyBjb2RlYyB0byBhc3NpZ24gYXMgYSBkZWZhdWx0LicpO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtYXRjaFNwZWNpZmllZENvZGVjVG9DbG9zZXN0U3VwcG9ydGVkID0gZnVuY3Rpb24gKHNwZWNpZmllZENvZGVjKSB7XG4gICAgICAgICAgICBjb25zdCBicm93c2VyU3VwcG9ydGVkQ29kZWNzID0gQnJvd3NlclV0aWxzLmdldFN1cHBvcnRlZFZpZGVvQ29kZWNzKCk7XG4gICAgICAgICAgICAvLyBDb2RlYyBzdXBwbGllZCBpbiB1cmwgcGFyYW0gaXMgYW4gZXhhY3QgbWF0Y2ggZm9yIHRoZSBicm93c2VyIGNvZGVjLlxuICAgICAgICAgICAgLy8gKGUuZy4gSDI2NCBsZXZlbC1hc3ltbWV0cnktYWxsb3dlZD0xO3BhY2tldGl6YXRpb24tbW9kZT0xO3Byb2ZpbGUtbGV2ZWwtaWQ9NDJlMDFmKVxuICAgICAgICAgICAgaWYgKGJyb3dzZXJTdXBwb3J0ZWRDb2RlY3MuaW5jbHVkZXMoc3BlY2lmaWVkQ29kZWMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwZWNpZmllZENvZGVjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIHRoZSBzdGFydCBvZiB3aGF0ZXZlciBpcyBwYXNzZWQgaW50byB0aGUgdXJsIHBhcmFtZXRlciB3aXRoIHdoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHNcbiAgICAgICAgICAgIGZvciAoY29uc3QgYnJvd3NlckNvZGVjIG9mIGJyb3dzZXJTdXBwb3J0ZWRDb2RlY3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnJvd3NlckNvZGVjLnN0YXJ0c1dpdGgoc3BlY2lmaWVkQ29kZWMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBicm93c2VyQ29kZWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZW4ndCBhYmxlIHRvIG1hdGNoLCBqdXN0IHJldHVybiB0aGUgY29kZWMgYXMgZnJvbSB0aGUgVVJMIGFzLWlzLlxuICAgICAgICAgICAgcmV0dXJuIHNwZWNpZmllZENvZGVjO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW51bSBQYXJhbWV0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvblBhcmFtZXRlcnMuc2V0KE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkQ29kZWMsIG5ldyBTZXR0aW5nT3B0aW9uKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkQ29kZWMsICdQcmVmZXJyZWQgQ29kZWMnLCAnVGhlIHByZWZlcnJlZCBjb2RlYyB0byBiZSB1c2VkIGR1cmluZyBjb2RlYyBuZWdvdGlhdGlvbicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRDb2RlYylcbiAgICAgICAgICAgID8gbWF0Y2hTcGVjaWZpZWRDb2RlY1RvQ2xvc2VzdFN1cHBvcnRlZChzZXR0aW5nc1tPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZENvZGVjXSlcbiAgICAgICAgICAgIDogZ2V0RGVmYXVsdFZpZGVvQ29kZWMoKSwgQnJvd3NlclV0aWxzLmdldFN1cHBvcnRlZFZpZGVvQ29kZWNzKCksIHVzZVVybFBhcmFtcywgbWF0Y2hTcGVjaWZpZWRDb2RlY1RvQ2xvc2VzdFN1cHBvcnRlZCkpO1xuICAgICAgICB0aGlzLm9wdGlvblBhcmFtZXRlcnMuc2V0KE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkUXVhbGl0eSwgbmV3IFNldHRpbmdPcHRpb24oT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRRdWFsaXR5LCAnUHJlZmVycmVkIFF1YWxpdHknLCAnVGhlIHByZWZlcnJlZCBxdWFsaXR5IG9mIHRoZSBzdHJlYW0gKG9ubHkgYXBwbGljYWJsZSB3aGVuIHVzaW5nIHRoZSBTRlUpJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZFF1YWxpdHkpXG4gICAgICAgICAgICA/IHNldHRpbmdzW09wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkUXVhbGl0eV1cbiAgICAgICAgICAgIDogJ0RlZmF1bHQnLCBbJ0RlZmF1bHQnXSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb29sZWFuIHBhcmFtZXRlcnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLkF1dG9Db25uZWN0LCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuQXV0b0Nvbm5lY3QsICdBdXRvIGNvbm5lY3QgdG8gc3RyZWFtJywgJ1doZXRoZXIgd2Ugc2hvdWxkIGF0dGVtcHQgdG8gYXV0byBjb25uZWN0IHRvIHRoZSBzaWduYWxsaW5nIHNlcnZlciBvciBzaG93IGEgY2xpY2sgdG8gc3RhcnQgcHJvbXB0LicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuQXV0b0Nvbm5lY3QpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLkF1dG9Db25uZWN0XVxuICAgICAgICAgICAgOiBmYWxzZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLkF1dG9QbGF5VmlkZW8sIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5BdXRvUGxheVZpZGVvLCAnQXV0byBwbGF5IHZpZGVvJywgJ1doZW4gdmlkZW8gaXMgcmVhZHkgYXV0b21hdGljYWxseSBzdGFydCBwbGF5aW5nIGl0IGFzIG9wcG9zZWQgdG8gc2hvd2luZyBhIHBsYXkgYnV0dG9uLicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuQXV0b1BsYXlWaWRlbylcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuQXV0b1BsYXlWaWRlb11cbiAgICAgICAgICAgIDogdHJ1ZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLlVzZU1pYywgbmV3IFNldHRpbmdGbGFnKEZsYWdzLlVzZU1pYywgJ1VzZSBtaWNyb3Bob25lJywgJ01ha2UgYnJvd3NlciByZXF1ZXN0IG1pY3JvcGhvbmUgYWNjZXNzIGFuZCBvcGVuIGFuIGlucHV0IGF1ZGlvIHRyYWNrLicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuVXNlTWljKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5Vc2VNaWNdXG4gICAgICAgICAgICA6IGZhbHNlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuVXNlTW9kYWxGb3JUZXh0SW5wdXQsIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5Vc2VNb2RhbEZvclRleHRJbnB1dCwgJ1VzZSBtb2RhbCBmb3IgdGV4dCBpbnB1dCcsICdXaGVuIGVudGVyaW5nIGlucHV0IGludG8gYSBzdHJlYW1lZCBVRSB0ZXh0IHdpZGdldCwgdXNlIGFuIGlucHV0IG1vZGFsLicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuVXNlTW9kYWxGb3JUZXh0SW5wdXQpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLlVzZU1vZGFsRm9yVGV4dElucHV0XVxuICAgICAgICAgICAgOiB0cnVlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuVXNlQ2FtZXJhLCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuVXNlQ2FtZXJhLCAnVXNlIHdlYmNhbScsICdNYWtlIGJyb3dzZXIgcmVxdWVzdCB3ZWJjYW0gYWNjZXNzIGFuZCBvcGVuIGEgaW5wdXQgdmlkZW8gdHJhY2suJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5Vc2VDYW1lcmEpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLlVzZUNhbWVyYV1cbiAgICAgICAgICAgIDogZmFsc2UsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5TdGFydFZpZGVvTXV0ZWQsIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5TdGFydFZpZGVvTXV0ZWQsICdTdGFydCB2aWRlbyBtdXRlZCcsICdWaWRlbyB3aWxsIHN0YXJ0IG11dGVkIGlmIHRydWUuJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5TdGFydFZpZGVvTXV0ZWQpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLlN0YXJ0VmlkZW9NdXRlZF1cbiAgICAgICAgICAgIDogZmFsc2UsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5TdXBwcmVzc0Jyb3dzZXJLZXlzLCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuU3VwcHJlc3NCcm93c2VyS2V5cywgJ1N1cHByZXNzIGJyb3dzZXIga2V5cycsICdTdXBwcmVzcyBjZXJ0YWluIGJyb3dzZXIga2V5cyB0aGF0IHdlIHVzZSBpbiBVRSwgZm9yIGV4YW1wbGUgRjUgdG8gc2hvdyBzaGFkZXIgY29tcGxleGl0eSBpbnN0ZWFkIG9mIHJlZnJlc2ggdGhlIHBhZ2UuJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5TdXBwcmVzc0Jyb3dzZXJLZXlzKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5TdXBwcmVzc0Jyb3dzZXJLZXlzXVxuICAgICAgICAgICAgOiB0cnVlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuSXNRdWFsaXR5Q29udHJvbGxlciwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLklzUXVhbGl0eUNvbnRyb2xsZXIsICdJcyBxdWFsaXR5IGNvbnRyb2xsZXI/JywgJ1RydWUgaWYgdGhpcyBwZWVyIGNvbnRyb2xzIHN0cmVhbSBxdWFsaXR5Jywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5Jc1F1YWxpdHlDb250cm9sbGVyKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5Jc1F1YWxpdHlDb250cm9sbGVyXVxuICAgICAgICAgICAgOiB0cnVlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuRm9yY2VNb25vQXVkaW8sIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5Gb3JjZU1vbm9BdWRpbywgJ0ZvcmNlIG1vbm8gYXVkaW8nLCAnRm9yY2UgYnJvd3NlciB0byByZXF1ZXN0IG1vbm8gYXVkaW8gaW4gdGhlIFNEUCcsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuRm9yY2VNb25vQXVkaW8pXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLkZvcmNlTW9ub0F1ZGlvXVxuICAgICAgICAgICAgOiBmYWxzZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLkZvcmNlVFVSTiwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLkZvcmNlVFVSTiwgJ0ZvcmNlIFRVUk4nLCAnT25seSBnZW5lcmF0ZSBUVVJOL1JlbGF5ZWQgSUNFIGNhbmRpZGF0ZXMuJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5Gb3JjZVRVUk4pXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLkZvcmNlVFVSTl1cbiAgICAgICAgICAgIDogZmFsc2UsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5BRktEZXRlY3Rpb24sIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5BRktEZXRlY3Rpb24sICdBRksgaWYgaWRsZScsICdUaW1lb3V0IHRoZSBleHBlcmllbmNlIGlmIHVzZXIgaXMgQUZLIGZvciBhIHBlcmlvZC4nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLkFGS0RldGVjdGlvbilcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuQUZLRGV0ZWN0aW9uXVxuICAgICAgICAgICAgOiBmYWxzZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLk1hdGNoVmlld3BvcnRSZXNvbHV0aW9uLCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuTWF0Y2hWaWV3cG9ydFJlc29sdXRpb24sICdNYXRjaCB2aWV3cG9ydCByZXNvbHV0aW9uJywgJ1BpeGVsIFN0cmVhbWluZyB3aWxsIGJlIGluc3RydWN0ZWQgdG8gZHluYW1pY2FsbHkgcmVzaXplIHRoZSB2aWRlbyBzdHJlYW0gdG8gbWF0Y2ggdGhlIHNpemUgb2YgdGhlIHZpZGVvIGVsZW1lbnQuJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5NYXRjaFZpZXdwb3J0UmVzb2x1dGlvbilcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuTWF0Y2hWaWV3cG9ydFJlc29sdXRpb25dXG4gICAgICAgICAgICA6IGZhbHNlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuSG92ZXJpbmdNb3VzZU1vZGUsIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5Ib3ZlcmluZ01vdXNlTW9kZSwgJ0NvbnRyb2wgU2NoZW1lOiBMb2NrZWQgTW91c2UnLCAnRWl0aGVyIGxvY2tlZCBtb3VzZSwgd2hlcmUgdGhlIHBvaW50ZXIgaXMgY29uc3VtZWQgYnkgdGhlIHZpZGVvIGFuZCBsb2NrZWQgdG8gaXQsIG9yIGhvdmVyaW5nIG1vdXNlLCB3aGVyZSB0aGUgbW91c2UgaXMgbm90IGNvbnN1bWVkLicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuSG92ZXJpbmdNb3VzZU1vZGUpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLkhvdmVyaW5nTW91c2VNb2RlXVxuICAgICAgICAgICAgOiBmYWxzZSwgdXNlVXJsUGFyYW1zLCAoaXNIb3ZlcmluZ01vdXNlLCBzZXR0aW5nKSA9PiB7XG4gICAgICAgICAgICBzZXR0aW5nLmxhYmVsID0gYENvbnRyb2wgU2NoZW1lOiAke2lzSG92ZXJpbmdNb3VzZSA/ICdIb3ZlcmluZycgOiAnTG9ja2VkJ30gTW91c2VgO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLkZha2VNb3VzZVdpdGhUb3VjaGVzLCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuRmFrZU1vdXNlV2l0aFRvdWNoZXMsICdGYWtlIG1vdXNlIHdpdGggdG91Y2hlcycsICdBIHNpbmdsZSBmaW5nZXIgdG91Y2ggaXMgY29udmVydGVkIGludG8gYSBtb3VzZSBldmVudC4gVGhpcyBhbGxvd3MgYSBub24tdG91Y2ggYXBwbGljYXRpb24gdG8gYmUgY29udHJvbGxlZCBwYXJ0aWFsbHkgdmlhIGEgdG91Y2ggZGV2aWNlLicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuRmFrZU1vdXNlV2l0aFRvdWNoZXMpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLkZha2VNb3VzZVdpdGhUb3VjaGVzXVxuICAgICAgICAgICAgOiBmYWxzZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLktleWJvYXJkSW5wdXQsIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5LZXlib2FyZElucHV0LCAnS2V5Ym9hcmQgaW5wdXQnLCAnSWYgZW5hYmxlZCwgc2VuZCBrZXlib2FyZCBldmVudHMgdG8gc3RyZWFtZXInLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLktleWJvYXJkSW5wdXQpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLktleWJvYXJkSW5wdXRdXG4gICAgICAgICAgICA6IHRydWUsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5Nb3VzZUlucHV0LCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuTW91c2VJbnB1dCwgJ01vdXNlIGlucHV0JywgJ0lmIGVuYWJsZWQsIHNlbmQgbW91c2UgZXZlbnRzIHRvIHN0cmVhbWVyJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5Nb3VzZUlucHV0KVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5Nb3VzZUlucHV0XVxuICAgICAgICAgICAgOiB0cnVlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuVG91Y2hJbnB1dCwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLlRvdWNoSW5wdXQsICdUb3VjaCBpbnB1dCcsICdJZiBlbmFibGVkLCBzZW5kIHRvdWNoIGV2ZW50cyB0byBzdHJlYW1lcicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuVG91Y2hJbnB1dClcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuVG91Y2hJbnB1dF1cbiAgICAgICAgICAgIDogdHJ1ZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLkdhbWVwYWRJbnB1dCwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLkdhbWVwYWRJbnB1dCwgJ0dhbWVwYWQgaW5wdXQnLCAnSWYgZW5hYmxlZCwgc2VuZCBnYW1lcGFkIGV2ZW50cyB0byBzdHJlYW1lcicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuR2FtZXBhZElucHV0KVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5HYW1lcGFkSW5wdXRdXG4gICAgICAgICAgICA6IHRydWUsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5YUkNvbnRyb2xsZXJJbnB1dCwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLlhSQ29udHJvbGxlcklucHV0LCAnWFIgY29udHJvbGxlciBpbnB1dCcsICdJZiBlbmFibGVkLCBzZW5kIFhSIGNvbnRyb2xsZXIgZXZlbnRzIHRvIHN0cmVhbWVyJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5YUkNvbnRyb2xsZXJJbnB1dClcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuWFJDb250cm9sbGVySW5wdXRdXG4gICAgICAgICAgICA6IHRydWUsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5XYWl0Rm9yU3RyZWFtZXIsIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5XYWl0Rm9yU3RyZWFtZXIsICdXYWl0IGZvciBzdHJlYW1lcicsICdXaWxsIGNvbnRpbnVlIHRyeWluZyB0byBjb25uZWN0IHRvIHRoZSBmaXJzdCBzdHJlYW1lciBhdmFpbGFibGUuJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5XYWl0Rm9yU3RyZWFtZXIpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLldhaXRGb3JTdHJlYW1lcl1cbiAgICAgICAgICAgIDogdHJ1ZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLkhpZGVVSSwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLkhpZGVVSSwgJ0hpZGUgdGhlIFVJIG92ZXJsYXknLCAnV2lsbCBoaWRlIGFsbCBVSSBvdmVybGF5IGRldGFpbHMnLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLkhpZGVVSSlcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuSGlkZVVJXVxuICAgICAgICAgICAgOiBmYWxzZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLkVuYWJsZUNhcHR1cmVUaW1lRXh0LCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuRW5hYmxlQ2FwdHVyZVRpbWVFeHQsICdFbmFibGUgYWJzLWNhcHR1cmUtdGltZScsICdFbmFibGVzIHRoZSBhYnMtY2FwdHVyZS10aW1lIFJUUCBoZWFkZXIgZXh0ZW5zaW9uJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5FbmFibGVDYXB0dXJlVGltZUV4dClcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuRW5hYmxlQ2FwdHVyZVRpbWVFeHRdXG4gICAgICAgICAgICA6IGZhbHNlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuQnJvd3NlclNlbmRPZmZlciwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLkJyb3dzZXJTZW5kT2ZmZXIsICdCcm93c2VyIHNlbmQgb2ZmZXIgKDQuMjcgT05MWSknLCAnQnJvd3NlciB3aWxsIGluaXRpYXRlIHRoZSBXZWJSVEMgaGFuZHNoYWtlIGJ5IHNlbmRpbmcgdGhlIG9mZmVyIHRvIHRoZSBzdHJlYW1lciAoNC4yNyBPTkxZKScsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuQnJvd3NlclNlbmRPZmZlcilcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuQnJvd3NlclNlbmRPZmZlcl1cbiAgICAgICAgICAgIDogZmFsc2UsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5MYXRlbmN5Q1NWLCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuTGF0ZW5jeUNTViwgJ0V4cG9ydCBMYXRlbmN5IENTVicsICdTaG93cyBhIGJ1dHRvbiBpbiB0aGUgc3RhdHMgcGFuZWwgdGhhdCBhbGxvd3MgdG8gcnVuIGEgbGF0ZW5jeSB0ZXN0IGFuZCBleHBvcnQgdGhlIHJlc3VsdHMgdG8gYSBDU1YgZmlsZS4nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLkxhdGVuY3lDU1YpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLkxhdGVuY3lDU1ZdXG4gICAgICAgICAgICA6IGZhbHNlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWVyaWMgcGFyYW1ldGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycy5zZXQoTnVtZXJpY1BhcmFtZXRlcnMuQUZLVGltZW91dFNlY3MsIG5ldyBTZXR0aW5nTnVtYmVyKE51bWVyaWNQYXJhbWV0ZXJzLkFGS1RpbWVvdXRTZWNzLCAnQUZLIHRpbWVvdXQnLCAnVGhlIHRpbWUgKGluIHNlY29uZHMpIGl0IHRha2VzIGZvciB0aGUgYXBwbGljYXRpb24gdG8gdGltZSBvdXQgaWYgQUZLIHRpbWVvdXQgaXMgZW5hYmxlZC4nLCAwIC8qbWluKi8sIG51bGwgLyptYXgqLywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBOdW1lcmljUGFyYW1ldGVycy5BRktUaW1lb3V0U2VjcylcbiAgICAgICAgICAgID8gc2V0dGluZ3NbTnVtZXJpY1BhcmFtZXRlcnMuQUZLVGltZW91dFNlY3NdXG4gICAgICAgICAgICA6IDEyMCAvKnZhbHVlKi8sIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzLnNldChOdW1lcmljUGFyYW1ldGVycy5BRktDb3VudGRvd25TZWNzLCBuZXcgU2V0dGluZ051bWJlcihOdW1lcmljUGFyYW1ldGVycy5BRktDb3VudGRvd25TZWNzLCAnQUZLIGNvdW50ZG93bicsICdUaGUgdGltZSAoaW4gc2Vjb25kcykgZm9yIGEgdXNlciB0byByZXNwb25kIGJlZm9yZSB0aGUgc3RyZWFtIGlzIGVuZGVkIGFmdGVyIGFuIEFGSyB0aW1lb3V0LicsIDEwIC8qbWluKi8sIG51bGwgLyptYXgqLywgMTAgLyp2YWx1ZSovLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycy5zZXQoTnVtZXJpY1BhcmFtZXRlcnMuTWF4UmVjb25uZWN0QXR0ZW1wdHMsIG5ldyBTZXR0aW5nTnVtYmVyKE51bWVyaWNQYXJhbWV0ZXJzLk1heFJlY29ubmVjdEF0dGVtcHRzLCAnTWF4IFJlY29ubmVjdHMnLCAnTWF4aW11bSBudW1iZXIgb2YgcmVjb25uZWN0cyB0aGUgYXBwbGljYXRpb24gd2lsbCBhdHRlbXB0IHdoZW4gYSBzdHJlYW1lciBkaXNjb25uZWN0cy4nLCAwIC8qbWluKi8sIDk5OSAvKm1heCovLCBzZXR0aW5ncyAmJlxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBOdW1lcmljUGFyYW1ldGVycy5NYXhSZWNvbm5lY3RBdHRlbXB0cylcbiAgICAgICAgICAgID8gc2V0dGluZ3NbTnVtZXJpY1BhcmFtZXRlcnMuTWF4UmVjb25uZWN0QXR0ZW1wdHNdXG4gICAgICAgICAgICA6IDMgLyp2YWx1ZSovLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycy5zZXQoTnVtZXJpY1BhcmFtZXRlcnMuTWluUVAsIG5ldyBTZXR0aW5nTnVtYmVyKE51bWVyaWNQYXJhbWV0ZXJzLk1pblFQLCAnTWluIFFQJywgJ1RoZSBsb3dlciBib3VuZCBmb3IgdGhlIHF1YW50aXphdGlvbiBwYXJhbWV0ZXIgKFFQKSBvZiB0aGUgZW5jb2Rlci4gMCA9IEJlc3QgcXVhbGl0eSwgNTEgPSB3b3JzdCBxdWFsaXR5LicsIDAgLyptaW4qLywgNTEgLyptYXgqLywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBOdW1lcmljUGFyYW1ldGVycy5NaW5RUClcbiAgICAgICAgICAgID8gc2V0dGluZ3NbTnVtZXJpY1BhcmFtZXRlcnMuTWluUVBdXG4gICAgICAgICAgICA6IDAgLyp2YWx1ZSovLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycy5zZXQoTnVtZXJpY1BhcmFtZXRlcnMuTWF4UVAsIG5ldyBTZXR0aW5nTnVtYmVyKE51bWVyaWNQYXJhbWV0ZXJzLk1heFFQLCAnTWF4IFFQJywgJ1RoZSB1cHBlciBib3VuZCBmb3IgdGhlIHF1YW50aXphdGlvbiBwYXJhbWV0ZXIgKFFQKSBvZiB0aGUgZW5jb2Rlci4gMCA9IEJlc3QgcXVhbGl0eSwgNTEgPSB3b3JzdCBxdWFsaXR5LicsIDAgLyptaW4qLywgNTEgLyptYXgqLywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBOdW1lcmljUGFyYW1ldGVycy5NYXhRUClcbiAgICAgICAgICAgID8gc2V0dGluZ3NbTnVtZXJpY1BhcmFtZXRlcnMuTWF4UVBdXG4gICAgICAgICAgICA6IDUxIC8qdmFsdWUqLywgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLk1pblF1YWxpdHksIG5ldyBTZXR0aW5nTnVtYmVyKE51bWVyaWNQYXJhbWV0ZXJzLk1pblF1YWxpdHksICdNaW4gUXVhbGl0eScsICdUaGUgbG93ZXIgYm91bmQgZm9yIHRoZSBxdWFsaXR5IGZhY3RvciBvZiB0aGUgZW5jb2Rlci4gMCA9IFdvcnN0IHF1YWxpdHksIDEwMCA9IEJlc3QgcXVhbGl0eS4nLCAwIC8qbWluKi8sIDEwMCAvKm1heCovLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIE51bWVyaWNQYXJhbWV0ZXJzLk1pblF1YWxpdHkpXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLk1pblF1YWxpdHldXG4gICAgICAgICAgICA6IDAgLyp2YWx1ZSovLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycy5zZXQoTnVtZXJpY1BhcmFtZXRlcnMuTWF4UXVhbGl0eSwgbmV3IFNldHRpbmdOdW1iZXIoTnVtZXJpY1BhcmFtZXRlcnMuTWF4UXVhbGl0eSwgJ01heCBRdWFsaXR5JywgJ1RoZSB1cHBlciBib3VuZCBmb3IgdGhlIHF1YWxpdHkgZmFjdG9yIG9mIHRoZSBlbmNvZGVyLiAwID0gV29yc3QgcXVhbGl0eSwgMTAwID0gQmVzdCBxdWFsaXR5LicsIDAgLyptaW4qLywgMTAwIC8qbWF4Ki8sIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgTnVtZXJpY1BhcmFtZXRlcnMuTWF4UXVhbGl0eSlcbiAgICAgICAgICAgID8gc2V0dGluZ3NbTnVtZXJpY1BhcmFtZXRlcnMuTWF4UXVhbGl0eV1cbiAgICAgICAgICAgIDogMTAwIC8qdmFsdWUqLywgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNaW4sIG5ldyBTZXR0aW5nTnVtYmVyKE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNaW4sICdNaW4gUXVhbGl0eScsICdUaGUgbG93ZXIgYm91bmQgZm9yIGVuY29kaW5nIHF1YWxpdHkuIDAgPSBXb3JzdCwgMTAwID0gQmVzdC4nLCAwIC8qbWluKi8sIDEwMCAvKm1heCovLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNaW4pXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNaW5dXG4gICAgICAgICAgICA6IDAgLyp2YWx1ZSovLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycy5zZXQoTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1heCwgbmV3IFNldHRpbmdOdW1iZXIoTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1heCwgJ01heCBRdWFsaXR5JywgJ1RoZSB1cHBlciBib3VuZCBmb3IgZW5jb2RpbmcgcXVhbGl0eS4gMCA9IFdvcnN0LCAxMDAgPSBCZXN0LicsIDAgLyptaW4qLywgMTAwIC8qbWF4Ki8sIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1heClcbiAgICAgICAgICAgID8gc2V0dGluZ3NbTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1heF1cbiAgICAgICAgICAgIDogMTAwIC8qdmFsdWUqLywgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ0ZQUywgbmV3IFNldHRpbmdOdW1iZXIoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDRlBTLCAnTWF4IEZQUycsICdUaGUgbWF4aW11bSBGUFMgdGhhdCBXZWJSVEMgd2lsbCB0cnkgdG8gdHJhbnNtaXQgZnJhbWVzIGF0LicsIDEgLyptaW4qLywgOTk5IC8qbWF4Ki8sIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDRlBTKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tOdW1lcmljUGFyYW1ldGVycy5XZWJSVENGUFNdXG4gICAgICAgICAgICA6IDYwIC8qdmFsdWUqLywgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01pbkJpdHJhdGUsIG5ldyBTZXR0aW5nTnVtYmVyKE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01pbkJpdHJhdGUsICdNaW4gQml0cmF0ZSAoa2JwcyknLCAnVGhlIG1pbmltdW0gYml0cmF0ZSB0aGF0IFdlYlJUQyBzaG91bGQgdXNlLicsIDAgLyptaW4qLywgNTAwMDAwIC8qbWF4Ki8sIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWluQml0cmF0ZSlcbiAgICAgICAgICAgID8gc2V0dGluZ3NbTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWluQml0cmF0ZV1cbiAgICAgICAgICAgIDogMCAvKnZhbHVlKi8sIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzLnNldChOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNYXhCaXRyYXRlLCBuZXcgU2V0dGluZ051bWJlcihOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNYXhCaXRyYXRlLCAnTWF4IEJpdHJhdGUgKGticHMpJywgJ1RoZSBtYXhpbXVtIGJpdHJhdGUgdGhhdCBXZWJSVEMgc2hvdWxkIHVzZS4nLCAwIC8qbWluKi8sIDUwMDAwMCAvKm1heCovLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01heEJpdHJhdGUpXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01heEJpdHJhdGVdXG4gICAgICAgICAgICA6IDAgLyp2YWx1ZSovLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycy5zZXQoTnVtZXJpY1BhcmFtZXRlcnMuU3RyZWFtZXJBdXRvSm9pbkludGVydmFsLCBuZXcgU2V0dGluZ051bWJlcihOdW1lcmljUGFyYW1ldGVycy5TdHJlYW1lckF1dG9Kb2luSW50ZXJ2YWwsICdTdHJlYW1lciBBdXRvIEpvaW4gSW50ZXJ2YWwgKG1zKScsICdEZWxheSBiZXR3ZWVuIHJldHJpZXMgd2hlbiB3YWl0aW5nIGZvciBhbiBhdmFpbGFibGUgc3RyZWFtZXIuJywgNTAwIC8qbWluKi8sIDkwMDAwMCAvKm1heCovLCBzZXR0aW5ncyAmJlxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBOdW1lcmljUGFyYW1ldGVycy5TdHJlYW1lckF1dG9Kb2luSW50ZXJ2YWwpXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLlN0cmVhbWVyQXV0b0pvaW5JbnRlcnZhbF1cbiAgICAgICAgICAgIDogMzAwMCAvKnZhbHVlKi8sIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzLnNldChOdW1lcmljUGFyYW1ldGVycy5LZWVwYWxpdmVEZWxheSwgbmV3IFNldHRpbmdOdW1iZXIoTnVtZXJpY1BhcmFtZXRlcnMuS2VlcGFsaXZlRGVsYXksICdDb25uZWN0aW9uIEtlZXBhbGl2ZSBkZWxheScsICdEZWxheSBiZXR3ZWVuIGtlZXBhbGl2ZSBwaW5ncyB0byB0aGUgc2lnbmFsbGluZyBzZXJ2ZXIuJywgMCAvKm1pbiovLCA5MDAwMDAgLyptYXgqLywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBOdW1lcmljUGFyYW1ldGVycy5LZWVwYWxpdmVEZWxheSlcbiAgICAgICAgICAgID8gc2V0dGluZ3NbTnVtZXJpY1BhcmFtZXRlcnMuS2VlcGFsaXZlRGVsYXldXG4gICAgICAgICAgICA6IDMwMDAwIC8qdmFsdWUqLywgdXNlVXJsUGFyYW1zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiB0aGUgbnVtZXJpYyBzZXR0aW5nIGlzIHRvZ2dsZWQuXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgZmxhZy5cbiAgICAgKiBAcGFyYW0gb25DaGFuZ2VkTGlzdGVuZXIgVGhlIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiB0aGUgbnVtZXJpYyB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIF9hZGRPbk51bWVyaWNTZXR0aW5nQ2hhbmdlZExpc3RlbmVyKGlkLCBvbkNoYW5nZWRMaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy5udW1lcmljUGFyYW1ldGVycy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzLmdldChpZCkuYWRkT25DaGFuZ2VkTGlzdGVuZXIob25DaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hZGRPbk9wdGlvblNldHRpbmdDaGFuZ2VkTGlzdGVuZXIoaWQsIG9uQ2hhbmdlZExpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvblBhcmFtZXRlcnMuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25QYXJhbWV0ZXJzLmdldChpZCkuYWRkT25DaGFuZ2VkTGlzdGVuZXIob25DaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIG51bWVyaWMgc2V0dGluZyB3ZSBhcmUgaW50ZXJlc3RlZCBpbiBnZXR0aW5nIGEgdmFsdWUgZm9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1lcmljIHZhbHVlIHN0b3JlZCBpbiB0aGUgcGFyYW1ldGVyIHdpdGggdGhlIHBhc3NlZCBpZC5cbiAgICAgKi9cbiAgICBnZXROdW1lcmljU2V0dGluZ1ZhbHVlKGlkKSB7XG4gICAgICAgIGlmICh0aGlzLm51bWVyaWNQYXJhbWV0ZXJzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzLmdldChpZCkubnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBubyBudW1lcmljIHNldHRpbmcgd2l0aCB0aGUgaWQgb2YgJHtpZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSB0ZXh0IHNldHRpbmcgd2UgYXJlIGludGVyZXN0ZWQgaW4gZ2V0dGluZyBhIHZhbHVlIGZvci5cbiAgICAgKiBAcmV0dXJucyBUaGUgdGV4dCB2YWx1ZSBzdG9yZWQgaW4gdGhlIHBhcmFtZXRlciB3aXRoIHRoZSBwYXNzZWQgaWQuXG4gICAgICovXG4gICAgZ2V0VGV4dFNldHRpbmdWYWx1ZShpZCkge1xuICAgICAgICBpZiAodGhpcy50ZXh0UGFyYW1ldGVycy5oYXMoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0UGFyYW1ldGVycy5nZXQoaWQpLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBubyBudW1lcmljIHNldHRpbmcgd2l0aCB0aGUgaWQgb2YgJHtpZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgbnVtYmVyIGluIHRoZSBzZXR0aW5nLlxuICAgICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIG51bWVyaWMgc2V0dGluZyB3ZSBhcmUgaW50ZXJlc3RlZCBpbi5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG51bWVyaWMgdmFsdWUgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldE51bWVyaWNTZXR0aW5nKGlkLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5udW1lcmljUGFyYW1ldGVycy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzLmdldChpZCkubnVtYmVyID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIG5vIG51bWVyaWMgc2V0dGluZyB3aXRoIHRoZSBpZCBvZiAke2lkfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiB0aGUgZmxhZyBpcyB0b2dnbGVkLlxuICAgICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIGZsYWcuXG4gICAgICogQHBhcmFtIG9uQ2hhbmdlTGlzdGVuZXIgVGhlIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBfYWRkT25TZXR0aW5nQ2hhbmdlZExpc3RlbmVyKGlkLCBvbkNoYW5nZUxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MuZ2V0KGlkKS5vbkNoYW5nZSA9IG9uQ2hhbmdlTGlzdGVuZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgY2FsbGJhY2sgdG8gZmlyZSB3aGVuIHRoZSB0ZXh0IGlzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgZmxhZy5cbiAgICAgKiBAcGFyYW0gb25DaGFuZ2VMaXN0ZW5lciBUaGUgY2FsbGJhY2sgdG8gZmlyZSB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIF9hZGRPblRleHRTZXR0aW5nQ2hhbmdlZExpc3RlbmVyKGlkLCBvbkNoYW5nZUxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHRQYXJhbWV0ZXJzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dFBhcmFtZXRlcnMuZ2V0KGlkKS5vbkNoYW5nZSA9IG9uQ2hhbmdlTGlzdGVuZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvcHRpb24gd2hpY2ggaGFzIHRoZSBnaXZlbiBpZC5cbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBvcHRpb24uXG4gICAgICogQHJldHVybnMgVGhlIFNldHRpbmdPcHRpb24gb2JqZWN0IG1hdGNoaW5nIGlkXG4gICAgICovXG4gICAgZ2V0U2V0dGluZ09wdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25QYXJhbWV0ZXJzLmdldChpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGNvbmZpZ3VyYXRpb24gZmxhZyB3aGljaCBoYXMgdGhlIGdpdmVuIGlkLlxuICAgICAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkIGZvciB0aGUgZmxhZy5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBmbGFnIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgaXNGbGFnRW5hYmxlZChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGFncy5nZXQoaWQpLmZsYWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBmbGFnIHRvIGJlIGVuYWJsZWQvZGlzYWJsZWQuXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgZmxhZyB0byB0b2dnbGUuXG4gICAgICogQHBhcmFtIGZsYWdFbmFibGVkIFRydWUgaWYgdGhlIGZsYWcgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAgICovXG4gICAgc2V0RmxhZ0VuYWJsZWQoaWQsIGZsYWdFbmFibGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5mbGFncy5oYXMoaWQpKSB7XG4gICAgICAgICAgICBMb2dnZXIuV2FybmluZyhgQ2Fubm90IHRvZ2dsZSBmbGFnIGNhbGxlZCAke2lkfSAtIGl0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBDb25maWcuZmxhZ3MgbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mbGFncy5nZXQoaWQpLmZsYWcgPSBmbGFnRW5hYmxlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHRleHQgc2V0dGluZy5cbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBzZXR0aW5nXG4gICAgICogQHBhcmFtIHNldHRpbmdWYWx1ZSBUaGUgdmFsdWUgdG8gc2V0IGluIHRoZSBzZXR0aW5nLlxuICAgICAqL1xuICAgIHNldFRleHRTZXR0aW5nKGlkLCBzZXR0aW5nVmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRleHRQYXJhbWV0ZXJzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIExvZ2dlci5XYXJuaW5nKGBDYW5ub3Qgc2V0IHRleHQgc2V0dGluZyBjYWxsZWQgJHtpZH0gLSBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgQ29uZmlnLnRleHRQYXJhbWV0ZXJzIG1hcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGV4dFBhcmFtZXRlcnMuZ2V0KGlkKS50ZXh0ID0gc2V0dGluZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgb3B0aW9uIHNldHRpbmcgbGlzdCBvZiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIHNldHRpbmdcbiAgICAgKiBAcGFyYW0gc2V0dGluZ09wdGlvbnMgVGhlIHZhbHVlcyB0aGUgc2V0dGluZyBjb3VsZCB0YWtlXG4gICAgICovXG4gICAgc2V0T3B0aW9uU2V0dGluZ09wdGlvbnMoaWQsIHNldHRpbmdPcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25QYXJhbWV0ZXJzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIExvZ2dlci5XYXJuaW5nKGBDYW5ub3Qgc2V0IHRleHQgc2V0dGluZyBjYWxsZWQgJHtpZH0gLSBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgQ29uZmlnLm9wdGlvblBhcmFtZXRlcnMgbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25QYXJhbWV0ZXJzLmdldChpZCkub3B0aW9ucyA9IHNldHRpbmdPcHRpb25zO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBvcHRpb24gZW51bSBzZXR0aW5ncyBzZWxlY3RlZCBvcHRpb24uXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgc2V0dGluZ1xuICAgICAqIEBwYXJhbSBzZXR0aW5nT3B0aW9ucyBUaGUgdmFsdWUgdG8gc2VsZWN0IG91dCBvZiBhbGwgdGhlIG9wdGlvbnNcbiAgICAgKi9cbiAgICBzZXRPcHRpb25TZXR0aW5nVmFsdWUoaWQsIHNldHRpbmdWYWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9uUGFyYW1ldGVycy5oYXMoaWQpKSB7XG4gICAgICAgICAgICBMb2dnZXIuV2FybmluZyhgQ2Fubm90IHNldCB0ZXh0IHNldHRpbmcgY2FsbGVkICR7aWR9IC0gaXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIENvbmZpZy5lbnVtUGFyYW1ldGVycyBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25TZXR0aW5nID0gdGhpcy5vcHRpb25QYXJhbWV0ZXJzLmdldChpZCk7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ09wdGlvbnMgPSBvcHRpb25TZXR0aW5nLm9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nT3B0aW9ucy5pbmNsdWRlcyhzZXR0aW5nVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdPcHRpb25zLnB1c2goc2V0dGluZ1ZhbHVlKTtcbiAgICAgICAgICAgICAgICBvcHRpb25TZXR0aW5nLm9wdGlvbnMgPSBleGlzdGluZ09wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25TZXR0aW5nLnNlbGVjdGVkID0gc2V0dGluZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbGFiZWwgZm9yIHRoZSBmbGFnLlxuICAgICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIGZsYWcuXG4gICAgICogQHBhcmFtIGxhYmVsIFRoZSBuZXcgbGFiZWwgdG8gdXNlIGZvciB0aGUgZmxhZy5cbiAgICAgKi9cbiAgICBzZXRGbGFnTGFiZWwoaWQsIGxhYmVsKSB7XG4gICAgICAgIGlmICghdGhpcy5mbGFncy5oYXMoaWQpKSB7XG4gICAgICAgICAgICBMb2dnZXIuV2FybmluZyhgQ2Fubm90IHNldCBsYWJlbCBmb3IgZmxhZyBjYWxsZWQgJHtpZH0gLSBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgQ29uZmlnLmZsYWdzIG1hcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MuZ2V0KGlkKS5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIHN1YnNldCBvZiBhbGwgc2V0dGluZ3MgaW4gb25lIGZ1bmN0aW9uIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2V0dGluZ3MgQSAocGFydGlhbCkgbGlzdCBvZiBzZXR0aW5ncyB0byBzZXRcbiAgICAgKi9cbiAgICBzZXRTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzZXR0aW5ncykpIHtcbiAgICAgICAgICAgIGlmIChpc0ZsYWdJZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGbGFnRW5hYmxlZChrZXksIHNldHRpbmdzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOdW1lcmljSWQoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TnVtZXJpY1NldHRpbmcoa2V5LCBzZXR0aW5nc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVGV4dElkKGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRleHRTZXR0aW5nKGtleSwgc2V0dGluZ3Nba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc09wdGlvbklkKGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE9wdGlvblNldHRpbmdWYWx1ZShrZXksIHNldHRpbmdzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyBBbGwgc2V0dGluZyB2YWx1ZXMgYXMgYW4gb2JqZWN0IHdpdGggc2V0dGluZyBpZHMgYXMga2V5c1xuICAgICAqL1xuICAgIGdldFNldHRpbmdzKCkge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLmZsYWdzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgc2V0dGluZ3Nba2V5XSA9IHZhbHVlLmZsYWc7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5udW1lcmljUGFyYW1ldGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzW2tleV0gPSB2YWx1ZS5udW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy50ZXh0UGFyYW1ldGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzW2tleV0gPSB2YWx1ZS50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMub3B0aW9uUGFyYW1ldGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzW2tleV0gPSB2YWx1ZS5zZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgRmxhZyBzZXR0aW5ncyBhcyBhbiBhcnJheS5cbiAgICAgKiBAcmV0dXJucyBBbGwgU2V0dGluZ0ZsYWcgb2JqZWN0c1xuICAgICAqL1xuICAgIGdldEZsYWdzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmZsYWdzLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBUZXh0IHNldHRpbmdzIGFzIGFuIGFycmF5LlxuICAgICAqIEByZXR1cm5zIEFsbCBTZXR0aW5nVGV4dCBvYmplY3RzXG4gICAgICovXG4gICAgZ2V0VGV4dFNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnRleHRQYXJhbWV0ZXJzLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBOdW1iZXIgc2V0dGluZ3MgYXMgYW4gYXJyYXkuXG4gICAgICogQHJldHVybnMgQWxsIFNldHRpbmdOdW1iZXIgb2JqZWN0c1xuICAgICAqL1xuICAgIGdldE51bWVyaWNTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5udW1lcmljUGFyYW1ldGVycy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgT3B0aW9uIHNldHRpbmdzIGFzIGFuIGFycmF5LlxuICAgICAqIEByZXR1cm5zIEFsbCBTZXR0aW5nT3B0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBnZXRPcHRpb25TZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5vcHRpb25QYXJhbWV0ZXJzLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdCBldmVudHMgd2hlbiBzZXR0aW5ncyBjaGFuZ2UuXG4gICAgICogQHBhcmFtIGV2ZW50RW1pdHRlclxuICAgICAqL1xuICAgIF9yZWdpc3Rlck9uQ2hhbmdlRXZlbnRzKGV2ZW50RW1pdHRlcikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmZsYWdzLmtleXMoKSkge1xuICAgICAgICAgICAgY29uc3QgZmxhZyA9IHRoaXMuZmxhZ3MuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAoZmxhZykge1xuICAgICAgICAgICAgICAgIGZsYWcub25DaGFuZ2VFbWl0ID0gKG5ld1ZhbHVlKSA9PiBldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgU2V0dGluZ3NDaGFuZ2VkRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBpZDogZmxhZy5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ZsYWcnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogZmxhZ1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzLmtleXMoKSkge1xuICAgICAgICAgICAgY29uc3QgbnVtYmVyID0gdGhpcy5udW1lcmljUGFyYW1ldGVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmIChudW1iZXIpIHtcbiAgICAgICAgICAgICAgICBudW1iZXIub25DaGFuZ2VFbWl0ID0gKG5ld1ZhbHVlKSA9PiBldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgU2V0dGluZ3NDaGFuZ2VkRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBpZDogbnVtYmVyLmlkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IG51bWJlclxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLnRleHRQYXJhbWV0ZXJzLmtleXMoKSkge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMudGV4dFBhcmFtZXRlcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgIHRleHQub25DaGFuZ2VFbWl0ID0gKG5ld1ZhbHVlKSA9PiBldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgU2V0dGluZ3NDaGFuZ2VkRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBpZDogdGV4dC5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGV4dFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLm9wdGlvblBhcmFtZXRlcnMua2V5cygpKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb24gPSB0aGlzLm9wdGlvblBhcmFtZXRlcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uLm9uQ2hhbmdlRW1pdCA9IChuZXdWYWx1ZSkgPT4gZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFNldHRpbmdzQ2hhbmdlZEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG9wdGlvbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ29wdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBvcHRpb25cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFRoZSBlbnVtIGFzc29jaWF0ZWQgd2l0aCB0aGUgbW91c2UgYmVpbmcgbG9ja2VkIG9yIGhvdmVyaW5nXG4gKi9cbmV4cG9ydCB2YXIgQ29udHJvbFNjaGVtZVR5cGU7XG4oZnVuY3Rpb24gKENvbnRyb2xTY2hlbWVUeXBlKSB7XG4gICAgQ29udHJvbFNjaGVtZVR5cGVbQ29udHJvbFNjaGVtZVR5cGVbXCJMb2NrZWRNb3VzZVwiXSA9IDBdID0gXCJMb2NrZWRNb3VzZVwiO1xuICAgIENvbnRyb2xTY2hlbWVUeXBlW0NvbnRyb2xTY2hlbWVUeXBlW1wiSG92ZXJpbmdNb3VzZVwiXSA9IDFdID0gXCJIb3ZlcmluZ01vdXNlXCI7XG59KShDb250cm9sU2NoZW1lVHlwZSB8fCAoQ29udHJvbFNjaGVtZVR5cGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29uZmlnLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGEgc2V0dGluZyB0aGF0IGhhcyBhIHRleHQgbGFiZWwgYW5kIGFuIGFyYml0cmFyeSBzZXR0aW5nIHZhbHVlIGl0IHN0b3Jlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNldHRpbmdCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgbGFiZWwsIGRlc2NyaXB0aW9uLCBkZWZhdWx0U2V0dGluZ1ZhbHVlLCBkZWZhdWx0T25DaGFuZ2VMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgLyogRG8gbm90aGluZywgdG8gYmUgb3ZlcnJpZGRlbi4gKi9cbiAgICB9KSB7XG4gICAgICAgIHRoaXMucGFyc2VVUkxQYXJhbXMoKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGRlZmF1bHRPbkNoYW5nZUxpc3RlbmVyO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlRW1pdCA9ICgpID0+IHtcbiAgICAgICAgICAgIC8qIERvIG5vdGhpbmcsIHRvIGJlIG92ZXJyaWRkZW4uICovXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMudmFsdWUgPSBkZWZhdWx0U2V0dGluZ1ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxhYmVsIHRleHQgZm9yIHRoZSBzZXR0aW5nLlxuICAgICAqIEBwYXJhbSBsYWJlbCBzZXR0aW5nIGxhYmVsLlxuICAgICAqL1xuICAgIHNldCBsYWJlbChpbkxhYmVsKSB7XG4gICAgICAgIHRoaXMuX2xhYmVsID0gaW5MYWJlbDtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUVtaXQodGhpcy5fdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgbGFiZWwgdGV4dCBmb3IgdGhlIHNldHRpbmcuXG4gICAgICovXG4gICAgZ2V0IGxhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGFiZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gVGhlIHNldHRpbmcncyB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzZXR0aW5nJ3Mgc3RvcmVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSBpblZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBzZXR0aW5nLlxuICAgICAqL1xuICAgIHNldCB2YWx1ZShpblZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gaW5WYWx1ZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLl92YWx1ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMub25DaGFuZ2VFbWl0KHRoaXMuX3ZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyc2lzdCB0aGUgc2V0dGluZyB2YWx1ZSBpbiBVUkwuXG4gICAgICovXG4gICAgdXBkYXRlVVJMUGFyYW1zKCkge1xuICAgICAgICBpZiAodGhpcy51c2VVcmxQYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIHNldCB1cmwgcGFyYW1zXG4gICAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVTdHJpbmcgPSB0aGlzLmdldFZhbHVlQXNTdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCBzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIF92YWx1ZV0gb2YgdXJsUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUudG9Mb3dlckNhc2UoKSA9PSB0aGlzLmlkLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsUGFyYW1zLnNldChuYW1lLCB2YWx1ZVN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2V0KSB7XG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zLnNldCh0aGlzLmlkLCB2YWx1ZVN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sICcnLCB1cmxQYXJhbXMudG9TdHJpbmcoKSAhPT0gJycgPyBgJHtsb2NhdGlvbi5wYXRobmFtZX0/JHt1cmxQYXJhbXN9YCA6IGAke2xvY2F0aW9uLnBhdGhuYW1lfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyBzdWIgdHlwZXMgdG8gcHJvdmlkZSB0aGVpciB2YWx1ZSBmb3IgdGhlIHVybCBzZWFyY2ggcGFyYW1zLlxuICAgICAqL1xuICAgIGdldFZhbHVlQXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcGFyc2VVUkxQYXJhbXMoKSB7XG4gICAgICAgIHRoaXMuX3VybFBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgcGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLl91cmxQYXJhbXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc1VSTFBhcmFtKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKSBpbiB0aGlzLl91cmxQYXJhbXM7XG4gICAgfVxuICAgIGdldFVSTFBhcmFtKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzVVJMUGFyYW0obmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91cmxQYXJhbXNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2V0dGluZ0Jhc2UuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IFNldHRpbmdCYXNlIH0gZnJvbSAnLi9TZXR0aW5nQmFzZSc7XG4vKipcbiAqIEEgYm9vbGVhbiBmbGFnIHNldHRpbmcgb2JqZWN0IHdpdGggYSB0ZXh0IGxhYmVsLlxuICovXG5leHBvcnQgY2xhc3MgU2V0dGluZ0ZsYWcgZXh0ZW5kcyBTZXR0aW5nQmFzZSB7XG4gICAgY29uc3RydWN0b3IoaWQsIGxhYmVsLCBkZXNjcmlwdGlvbiwgZGVmYXVsdEZsYWdWYWx1ZSwgdXNlVXJsUGFyYW1zLCBkZWZhdWx0T25DaGFuZ2VMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgLyogRG8gbm90aGluZywgdG8gYmUgb3ZlcnJpZGRlbi4gKi9cbiAgICB9KSB7XG4gICAgICAgIHN1cGVyKGlkLCBsYWJlbCwgZGVzY3JpcHRpb24sIGRlZmF1bHRGbGFnVmFsdWUsIGRlZmF1bHRPbkNoYW5nZUxpc3RlbmVyKTtcbiAgICAgICAgaWYgKCF1c2VVcmxQYXJhbXMgfHwgIXRoaXMuaGFzVVJMUGFyYW0odGhpcy5pZCkpIHtcbiAgICAgICAgICAgIHRoaXMuZmxhZyA9IGRlZmF1bHRGbGFnVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXJzZSBmbGFnIGZyb20gdXJsIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIGNvbnN0IHVybFBhcmFtRmxhZyA9IHRoaXMuZ2V0VVJMUGFyYW0odGhpcy5pZCk7XG4gICAgICAgICAgICB0aGlzLmZsYWcgPSB1cmxQYXJhbUZsYWcudG9Mb3dlckNhc2UoKSAhPSAnZmFsc2UnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNlVXJsUGFyYW1zID0gdXNlVXJsUGFyYW1zO1xuICAgIH1cbiAgICBnZXRWYWx1ZUFzU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGFnID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGlzIGZsYWcuXG4gICAgICovXG4gICAgZW5hYmxlKCkge1xuICAgICAgICB0aGlzLmZsYWcgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFRoZSBzZXR0aW5nJ3MgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0IGZsYWcoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc2V0dGluZydzIHN0b3JlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gaW5WYWx1ZSBUaGUgbmV3IHZhbHVlIGZvciB0aGUgc2V0dGluZy5cbiAgICAgKi9cbiAgICBzZXQgZmxhZyhpblZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBpblZhbHVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNldHRpbmdGbGFnLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBTZXR0aW5nQmFzZSB9IGZyb20gJy4vU2V0dGluZ0Jhc2UnO1xuLyoqXG4gKiBBIG51bWJlciBzZXR0aW5nIG9iamVjdCB3aXRoIGEgdGV4dCBsYWJlbC4gTWluIGFuZCBtYXggbGltaXQgdGhlIHJhbmdlIG9mIGFsbG93ZWQgdmFsdWVzLlxuICovXG5leHBvcnQgY2xhc3MgU2V0dGluZ051bWJlciBleHRlbmRzIFNldHRpbmdCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgbGFiZWwsIGRlc2NyaXB0aW9uLCBtaW4sIG1heCwgZGVmYXVsdE51bWJlciwgdXNlVXJsUGFyYW1zLCBkZWZhdWx0T25DaGFuZ2VMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgLyogRG8gbm90aGluZywgdG8gYmUgb3ZlcnJpZGRlbi4gKi9cbiAgICB9KSB7XG4gICAgICAgIHN1cGVyKGlkLCBsYWJlbCwgZGVzY3JpcHRpb24sIGRlZmF1bHROdW1iZXIsIGRlZmF1bHRPbkNoYW5nZUxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5fbWluID0gbWluO1xuICAgICAgICB0aGlzLl9tYXggPSBtYXg7XG4gICAgICAgIC8vIGF0dGVtcHQgdG8gcmVhZCB0aGUgbnVtYmVyIGZyb20gdGhlIHVybCBwYXJhbXNcbiAgICAgICAgaWYgKCF1c2VVcmxQYXJhbXMgfHwgIXRoaXMuaGFzVVJMUGFyYW0odGhpcy5pZCkpIHtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyID0gZGVmYXVsdE51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gTnVtYmVyLnBhcnNlRmxvYXQodGhpcy5nZXRVUkxQYXJhbSh0aGlzLmlkKSk7XG4gICAgICAgICAgICB0aGlzLm51bWJlciA9IE51bWJlci5pc05hTihwYXJzZWRWYWx1ZSkgPyBkZWZhdWx0TnVtYmVyIDogcGFyc2VkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VVcmxQYXJhbXMgPSB1c2VVcmxQYXJhbXM7XG4gICAgfVxuICAgIGdldFZhbHVlQXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bWJlci50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG51bWJlciB2YWx1ZSAod2lsbCBiZSBjbGFtcGVkIHdpdGhpbiByYW5nZSkuXG4gICAgICovXG4gICAgc2V0IG51bWJlcihuZXdOdW1iZXIpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuY2xhbXAobmV3TnVtYmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBzdG9yZWQuXG4gICAgICovXG4gICAgZ2V0IG51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsYW1wcyBhIG51bWJlciBiZXR3ZWVuIHRoZSBtaW4gYW5kIG1heCB2YWx1ZXMgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIGluTnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gICAgICogQHJldHVybnMgVGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIGNsYW1wKGluTnVtYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9taW4gPT0gbnVsbCAmJiB0aGlzLl9tYXggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGluTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX21pbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5fbWF4LCBpbk51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fbWF4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLl9taW4sIGluTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbih0aGlzLl9tYXgsIGluTnVtYmVyKSwgdGhpcy5fbWluKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlXG4gICAgICogQHJldHVybnMgVGhlIG1pbmltdW0gdmFsdWVcbiAgICAgKi9cbiAgICBnZXQgbWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWluO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlXG4gICAgICogQHJldHVybnMgVGhlIG1heGltdW0gdmFsdWVcbiAgICAgKi9cbiAgICBnZXQgbWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjaGFuZ2UgbGlzdGVuZXIgdG8gdGhlIG51bWJlciBvYmplY3QuXG4gICAgICovXG4gICAgYWRkT25DaGFuZ2VkTGlzdGVuZXIob25DaGFuZ2VkRnVuYykge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gb25DaGFuZ2VkRnVuYztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXR0aW5nTnVtYmVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG5pbXBvcnQgeyBTZXR0aW5nQmFzZSB9IGZyb20gJy4vU2V0dGluZ0Jhc2UnO1xuLyoqXG4gKiBBbiBPcHRpb24gc2V0dGluZyBvYmplY3Qgd2l0aCBhIHRleHQgbGFiZWwuIEFsbG93cyB5b3UgdG8gc3BlY2lmeSBhbiBhcnJheSBvZiBvcHRpb25zIGFuZCBzZWxlY3Qgb25lIG9mIHRoZW0uXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXR0aW5nT3B0aW9uIGV4dGVuZHMgU2V0dGluZ0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBsYWJlbCwgZGVzY3JpcHRpb24sIGRlZmF1bHRUZXh0VmFsdWUsIG9wdGlvbnMsIHVzZVVybFBhcmFtcywgZGVmYXVsdFVybFBhcmFtUmVzb2x2ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLyogUmV0dXJuIHRoZSBzdHJpbmcgYXMtaXMgYnkgZGVmYXVsdCAqL1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgZGVmYXVsdE9uQ2hhbmdlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIC8qIERvIG5vdGhpbmcsIHRvIGJlIG92ZXJyaWRkZW4uICovXG4gICAgfSkge1xuICAgICAgICBzdXBlcihpZCwgbGFiZWwsIGRlc2NyaXB0aW9uLCBkZWZhdWx0VGV4dFZhbHVlLCBkZWZhdWx0T25DaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX3VybFBhcmFtUmVzb2x2ZXIgPSBkZWZhdWx0VXJsUGFyYW1SZXNvbHZlcjtcbiAgICAgICAgY29uc3Qgc3RyaW5nVG9NYXRjaCA9IHRoaXMuaGFzVVJMUGFyYW0odGhpcy5pZClcbiAgICAgICAgICAgID8gdGhpcy5fdXJsUGFyYW1SZXNvbHZlcih0aGlzLmdldFVSTFBhcmFtKHRoaXMuaWQpKVxuICAgICAgICAgICAgOiBkZWZhdWx0VGV4dFZhbHVlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiBbc3RyaW5nVG9NYXRjaF07XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzdHJpbmdUb01hdGNoO1xuICAgICAgICB0aGlzLnVzZVVybFBhcmFtcyA9IHVzZVVybFBhcmFtcztcbiAgICB9XG4gICAgZ2V0VmFsdWVBc1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNoYW5nZSBsaXN0ZW5lciB0byB0aGUgc2VsZWN0IGVsZW1lbnQuXG4gICAgICovXG4gICAgYWRkT25DaGFuZ2VkTGlzdGVuZXIob25DaGFuZ2VkRnVuYykge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gb25DaGFuZ2VkRnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgQWxsIGF2YWlsYWJsZSBvcHRpb25zIGFzIGFuIGFycmF5XG4gICAgICovXG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB2YWx1ZXMgQXJyYXkgb2Ygb3B0aW9uc1xuICAgICAqL1xuICAgIHNldCBvcHRpb25zKHZhbHVlcykge1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gdmFsdWVzO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlRW1pdCh0aGlzLnNlbGVjdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgU2VsZWN0ZWQgb3B0aW9uIGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHNlbGVjdGVkIG9wdGlvbiBpZiBpdCBtYXRjaGVzIG9uZSBvZiB0aGUgYXZhaWxhYmxlIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gdmFsdWUgU2VsZWN0ZWQgb3B0aW9uXG4gICAgICovXG4gICAgc2V0IHNlbGVjdGVkKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgb3B0aW9ucyBjb250YWlucyB0aGUgdmFsdWUsIHRoZW4gc2V0IHRoYXQgYXMgc2VsZWN0ZWRcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihgQ291bGQgbm90IHNldCBcIiR7dmFsdWV9XCIgYXMgdGhlIHNlbGVjdGVkIG9wdGlvbiBmb3IgJHt0aGlzLmlkfSBiZWNhdXNlIGl0IHdhc24ndCBvbmUgb2YgdGhlIG9wdGlvbnMuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB1cmwgcGFyYW1ldGVyIHJlc29sdmVyIHRvIGRvIHNvbWUgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHN0cmluZyB2YWx1ZVxuICAgICAqIHRoYXQgaXMgZXh0cmFjdGVkIGZyb20gdGhlIHVybCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB1cmxQYXJhbSBBIGZ1bmN0aW9uIHRoYXQgdHJhbnNmb3JtcyB0aGUgZXh0cmFjdGVkIHVybCBwYXJhbWV0ZXIgc3RyaW5nIGZvciB0aGlzIHNldHRpbmcgdG8gc29tZXRoaW5nIGVsc2UuXG4gICAgICovXG4gICAgc2V0IHVybFBhcmFtUmVzb2x2ZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdXJsUGFyYW1SZXNvbHZlciA9IHZhbHVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNldHRpbmdPcHRpb24uanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IFNldHRpbmdCYXNlIH0gZnJvbSAnLi9TZXR0aW5nQmFzZSc7XG4vKipcbiAqIEEgdGV4dCBzZXR0aW5nIG9iamVjdCB3aXRoIGEgdGV4dCBsYWJlbC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNldHRpbmdUZXh0IGV4dGVuZHMgU2V0dGluZ0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBsYWJlbCwgZGVzY3JpcHRpb24sIGRlZmF1bHRUZXh0VmFsdWUsIHVzZVVybFBhcmFtcywgZGVmYXVsdE9uQ2hhbmdlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIC8qIERvIG5vdGhpbmcsIHRvIGJlIG92ZXJyaWRkZW4uICovXG4gICAgfSkge1xuICAgICAgICBzdXBlcihpZCwgbGFiZWwsIGRlc2NyaXB0aW9uLCBkZWZhdWx0VGV4dFZhbHVlLCBkZWZhdWx0T25DaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgIGlmICghdXNlVXJsUGFyYW1zIHx8ICF0aGlzLmhhc1VSTFBhcmFtKHRoaXMuaWQpKSB7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSBkZWZhdWx0VGV4dFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFyc2UgZmxhZyBmcm9tIHVybCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLmdldFVSTFBhcmFtKHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNlVXJsUGFyYW1zID0gdXNlVXJsUGFyYW1zO1xuICAgIH1cbiAgICBnZXRWYWx1ZUFzU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFRoZSBzZXR0aW5nJ3MgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHNldHRpbmcncyBzdG9yZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIGluVmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHNldHRpbmcuXG4gICAgICovXG4gICAgc2V0IHRleHQoaW5WYWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gaW5WYWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXR0aW5nVGV4dC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuLyoqXG4gKiBIYW5kbGVzIHRoZSBTZW5kaW5nIGFuZCBSZWNlaXZpbmcgb2YgbWVzc2FnZXMgdG8gdGhlIFVFIEluc3RhbmNlIHZpYSB0aGUgRGF0YSBDaGFubmVsXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhQ2hhbm5lbENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmlzUmVjZWl2aW5nRnJlZXplRnJhbWUgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlIG9mIGEgZGF0YWNoYW5uZWwgY29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IERhdGFDaGFubmVsQ29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdldERhdGFDaGFubmVsSW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBDcmVhdGUgYW5kIFNldCB1cCBhIERhdGEgQ2hhbm5lbFxuICAgICAqIEBwYXJhbSBwZWVyQ29ubmVjdGlvbiAtIFRoZSBSVEMgUGVlciBDb25uZWN0aW9uXG4gICAgICogQHBhcmFtIGxhYmVsIC0gTGFiZWwgb2YgdGhlIERhdGEgQ2hhbm5lbFxuICAgICAqIEBwYXJhbSBkYXRhY2hhbm5lbE9wdGlvbnMgLSBPcHRpb25hbCBSVEMgRGF0YUNoYW5uZWwgb3B0aW9uc1xuICAgICAqL1xuICAgIGNyZWF0ZURhdGFDaGFubmVsKHBlZXJDb25uZWN0aW9uLCBsYWJlbCwgZGF0YWNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24gPSBwZWVyQ29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB0aGlzLmRhdGFjaGFubmVsT3B0aW9ucyA9IGRhdGFjaGFubmVsT3B0aW9ucztcbiAgICAgICAgaWYgKGRhdGFjaGFubmVsT3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFjaGFubmVsT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5kYXRhY2hhbm5lbE9wdGlvbnMub3JkZXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbCA9IHRoaXMucGVlckNvbm5lY3Rpb24uY3JlYXRlRGF0YUNoYW5uZWwodGhpcy5sYWJlbCwgdGhpcy5kYXRhY2hhbm5lbE9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNldHVwRGF0YUNoYW5uZWwoKTtcbiAgICB9XG4gICAgc2V0dXBEYXRhQ2hhbm5lbCgpIHtcbiAgICAgICAgLy9XZSBXYW50IGFuIEFycmF5IEJ1ZmZlciBub3QgYSBibG9iXG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwub25vcGVuID0gKGV2KSA9PiB0aGlzLmhhbmRsZU9uT3Blbihldik7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwub25jbG9zZSA9IChldikgPT4gdGhpcy5oYW5kbGVPbkNsb3NlKGV2KTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbm1lc3NhZ2UgPSAoZXYpID0+IHRoaXMuaGFuZGxlT25NZXNzYWdlKGV2KTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbmVycm9yID0gKGV2KSA9PiB0aGlzLmhhbmRsZU9uRXJyb3IoZXYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gdGhlIERhdGEgQ2hhbm5lbCBpcyBvcGVuZWRcbiAgICAgKi9cbiAgICBoYW5kbGVPbk9wZW4oZXYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBMb2dnZXIuSW5mbyhgRGF0YSBDaGFubmVsICgke3RoaXMubGFiZWx9KSBvcGVuZWQuYCk7XG4gICAgICAgIHRoaXMub25PcGVuKChfYSA9IHRoaXMuZGF0YUNoYW5uZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYWJlbCwgZXYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gdGhlIERhdGEgQ2hhbm5lbCBpcyBjbG9zZWRcbiAgICAgKi9cbiAgICBoYW5kbGVPbkNsb3NlKGV2KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgTG9nZ2VyLkluZm8oYERhdGEgQ2hhbm5lbCAoJHt0aGlzLmxhYmVsfSkgY2xvc2VkLmApO1xuICAgICAgICB0aGlzLm9uQ2xvc2UoKF9hID0gdGhpcy5kYXRhQ2hhbm5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhYmVsLCBldik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWRcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBNZXNzYWdlIEV2ZW50XG4gICAgICovXG4gICAgaGFuZGxlT25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIC8vIEhpZ2hlciBsb2cgbGV2ZWwgdG8gcHJldmVudCBsb2cgc3BhbSB3aXRoIG1lc3NhZ2VzIHJlY2VpdmVkXG4gICAgICAgIExvZ2dlci5JbmZvKGBEYXRhIENoYW5uZWwgKCR7dGhpcy5sYWJlbH0pIG1lc3NhZ2U6ICR7ZXZlbnR9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hlbiBhbiBlcnJvciBpcyB0aHJvd25cbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBFcnJvciBFdmVudFxuICAgICAqL1xuICAgIGhhbmRsZU9uRXJyb3IoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBMb2dnZXIuSW5mbyhgRGF0YSBDaGFubmVsICgke3RoaXMubGFiZWx9KSBlcnJvcjogJHtldmVudH1gKTtcbiAgICAgICAgdGhpcy5vbkVycm9yKChfYSA9IHRoaXMuZGF0YUNoYW5uZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYWJlbCwgZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0byByZWdpc3RlciBvbk9wZW4gaGFuZGxlclxuICAgICAqIEBwYXJhbSBsYWJlbCBEYXRhIGNoYW5uZWwgbGFiZWwgKFwiZGF0YWNoYW5uZWxcIiwgXCJzZW5kLWRhdGFjaGFubmVsXCIsIFwicmVjdi1kYXRhY2hhbm5lbFwiKVxuICAgICAqIEBwYXJhbSBldiBldmVudFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBvbk9wZW4obGFiZWwsIGV2KSB7XG4gICAgICAgIC8vIGVtcHR5IGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdG8gcmVnaXN0ZXIgb25DbG9zZSBoYW5kbGVyXG4gICAgICogQHBhcmFtIGxhYmVsIERhdGEgY2hhbm5lbCBsYWJlbCAoXCJkYXRhY2hhbm5lbFwiLCBcInNlbmQtZGF0YWNoYW5uZWxcIiwgXCJyZWN2LWRhdGFjaGFubmVsXCIpXG4gICAgICogQHBhcmFtIGV2IGV2ZW50XG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIG9uQ2xvc2UobGFiZWwsIGV2KSB7XG4gICAgICAgIC8vIGVtcHR5IGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdG8gcmVnaXN0ZXIgb25FcnJvciBoYW5kbGVyXG4gICAgICogQHBhcmFtIGxhYmVsIERhdGEgY2hhbm5lbCBsYWJlbCAoXCJkYXRhY2hhbm5lbFwiLCBcInNlbmQtZGF0YWNoYW5uZWxcIiwgXCJyZWN2LWRhdGFjaGFubmVsXCIpXG4gICAgICogQHBhcmFtIGV2IGV2ZW50XG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIG9uRXJyb3IobGFiZWwsIGV2KSB7XG4gICAgICAgIC8vIGVtcHR5IGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhQ2hhbm5lbENvbnRyb2xsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42JztcbmltcG9ydCB7IERhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZWNvcmQgfSBmcm9tICcuL0RhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXN1bHRzJztcbmV4cG9ydCBjbGFzcyBEYXRhQ2hhbm5lbExhdGVuY3lUZXN0Q29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3Ioc2luaywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5pbnRlcnZhbEhhbmRsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zaW5rID0gc2luaztcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLnJlY29yZHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2VxID0gMDtcbiAgICB9XG4gICAgc3RhcnQoY29uZmlnKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnJlY29yZHMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbEhhbmRsZSA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKERhdGUubm93KCkgLSB0aGlzLnN0YXJ0VGltZSA+PSBjb25maWcuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoY29uZmlnLnJlcXVlc3RTaXplLCBjb25maWcucmVzcG9uc2VTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuYmluZCh0aGlzKSwgTWF0aC5mbG9vcigxMDAwIC8gY29uZmlnLnJwcykpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxIYW5kbGUpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxIYW5kbGUpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbEhhbmRsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5wcm9kdWNlUmVzdWx0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2R1Y2VSZXN1bHQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdFJlY29yZHMgPSBuZXcgTWFwKHRoaXMucmVjb3Jkcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWNvcmRzOiByZXN1bHRSZWNvcmRzLFxuICAgICAgICAgICAgZGF0YUNoYW5uZWxSdHQ6IE1hdGguY2VpbChBcnJheS5mcm9tKHRoaXMucmVjb3Jkcy52YWx1ZXMoKSkucmVkdWNlKChhY2MsIG5leHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjICsgKG5leHQucGxheWVyUmVjZWl2ZWRUaW1lc3RhbXAgLSBuZXh0LnBsYXllclNlbnRUaW1lc3RhbXApO1xuICAgICAgICAgICAgfSwgMCkgLyB0aGlzLnJlY29yZHMuc2l6ZSksXG4gICAgICAgICAgICBwbGF5ZXJUb1N0cmVhbWVyVGltZTogTWF0aC5jZWlsKEFycmF5LmZyb20odGhpcy5yZWNvcmRzLnZhbHVlcygpKS5yZWR1Y2UoKGFjYywgbmV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyAobmV4dC5zdHJlYW1lclJlY2VpdmVkVGltZXN0YW1wIC0gbmV4dC5wbGF5ZXJTZW50VGltZXN0YW1wKTtcbiAgICAgICAgICAgIH0sIDApIC8gdGhpcy5yZWNvcmRzLnNpemUpLFxuICAgICAgICAgICAgc3RyZWFtZXJUb1BsYXllclRpbWU6IE1hdGguY2VpbChBcnJheS5mcm9tKHRoaXMucmVjb3Jkcy52YWx1ZXMoKSkucmVkdWNlKChhY2MsIG5leHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjICsgKG5leHQucGxheWVyUmVjZWl2ZWRUaW1lc3RhbXAgLSBuZXh0LnN0cmVhbWVyU2VudFRpbWVzdGFtcCk7XG4gICAgICAgICAgICB9LCAwKSAvIHRoaXMucmVjb3Jkcy5zaXplKSxcbiAgICAgICAgICAgIGV4cG9ydExhdGVuY3lBc0NTVjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBjc3YgPSAnVGltZXN0YW1wO1JUVDtQbGF5ZXJUb1N0cmVhbWVyO1N0cmVhbWVyVG9QbGF5ZXI7XFxuJztcbiAgICAgICAgICAgICAgICByZXN1bHRSZWNvcmRzLmZvckVhY2goKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjc3YgKz0gcmVjb3JkLnBsYXllclNlbnRUaW1lc3RhbXAgKyAnOyc7XG4gICAgICAgICAgICAgICAgICAgIGNzdiArPSByZWNvcmQucGxheWVyUmVjZWl2ZWRUaW1lc3RhbXAgLSByZWNvcmQucGxheWVyU2VudFRpbWVzdGFtcCArICc7JztcbiAgICAgICAgICAgICAgICAgICAgY3N2ICs9IHJlY29yZC5zdHJlYW1lclJlY2VpdmVkVGltZXN0YW1wIC0gcmVjb3JkLnBsYXllclNlbnRUaW1lc3RhbXAgKyAnOyc7XG4gICAgICAgICAgICAgICAgICAgIGNzdiArPSByZWNvcmQucGxheWVyUmVjZWl2ZWRUaW1lc3RhbXAgLSByZWNvcmQuc3RyZWFtZXJTZW50VGltZXN0YW1wICsgJzsnO1xuICAgICAgICAgICAgICAgICAgICBjc3YgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNzdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgaXNSdW5uaW5nKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmludGVydmFsSGFuZGxlO1xuICAgIH1cbiAgICByZWNlaXZlKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcignVW5kZWZpbmVkIHJlc3BvbnNlIGZyb20gc2VydmVyJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVjb3JkID0gdGhpcy5yZWNvcmRzLmdldChyZXNwb25zZS5TZXEpO1xuICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICByZWNvcmQudXBkYXRlKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kUmVxdWVzdChyZXF1ZXN0U2l6ZSwgcmVzcG9uc2VTaXplKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3QocmVxdWVzdFNpemUsIHJlc3BvbnNlU2l6ZSk7XG4gICAgICAgIGNvbnN0IHJlY29yZCA9IG5ldyBEYXRhQ2hhbm5lbExhdGVuY3lUZXN0UmVjb3JkKHJlcXVlc3QpO1xuICAgICAgICB0aGlzLnJlY29yZHMuc2V0KHJlY29yZC5zZXEsIHJlY29yZCk7XG4gICAgICAgIHRoaXMuc2luayhyZXF1ZXN0KTtcbiAgICB9XG4gICAgY3JlYXRlUmVxdWVzdChyZXF1ZXN0U2l6ZSwgcmVzcG9uc2VTaXplKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBTZXE6IHRoaXMuc2VxKyssXG4gICAgICAgICAgICBGaWxsUmVzcG9uc2VTaXplOiByZXNwb25zZVNpemUsXG4gICAgICAgICAgICBGaWxsZXI6IHJlcXVlc3RTaXplID8gJ0EnLnJlcGVhdChyZXF1ZXN0U2l6ZSkgOiAnJ1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFDaGFubmVsTGF0ZW5jeVRlc3RDb250cm9sbGVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5leHBvcnQgY2xhc3MgRGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlY29yZCB7XG4gICAgY29uc3RydWN0b3IocmVxdWVzdCkge1xuICAgICAgICB0aGlzLnNlcSA9IHJlcXVlc3QuU2VxO1xuICAgICAgICB0aGlzLnBsYXllclNlbnRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnJlcXVlc3RGaWxsZXJTaXplID0gcmVxdWVzdC5GaWxsZXIgPyByZXF1ZXN0LkZpbGxlci5sZW5ndGggOiAwO1xuICAgIH1cbiAgICB1cGRhdGUocmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5wbGF5ZXJSZWNlaXZlZFRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuc3RyZWFtZXJSZWNlaXZlZFRpbWVzdGFtcCA9IHJlc3BvbnNlLlJlY2VpdmVkVGltZXN0YW1wO1xuICAgICAgICB0aGlzLnN0cmVhbWVyU2VudFRpbWVzdGFtcCA9IHJlc3BvbnNlLlNlbnRUaW1lc3RhbXA7XG4gICAgICAgIHRoaXMucmVzcG9uc2VGaWxsZXJTaXplID0gcmVzcG9uc2UuRmlsbGVyID8gcmVzcG9uc2UuRmlsbGVyLmxlbmd0aCA6IDA7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlc3VsdHMuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42Jztcbi8qKlxuICogQSBjbGFzcyBmb3Igc2VuZGluZyBkYXRhIGNoYW5uZWwgbWVzc2FnZXNcbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFDaGFubmVsU2VuZGVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YUNoYW5uZWxQcm92aWRlciAtIERhdGEgY2hhbm5lbCBvYmplY3QgdHlwZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRhdGFDaGFubmVsUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbFByb3ZpZGVyID0gZGF0YUNoYW5uZWxQcm92aWRlcjtcbiAgICB9XG4gICAgY2FuU2VuZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmRhdGFDaGFubmVsUHJvdmlkZXIuZ2V0RGF0YUNoYW5uZWxJbnN0YW5jZSgpLmRhdGFDaGFubmVsICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5uZWxQcm92aWRlci5nZXREYXRhQ2hhbm5lbEluc3RhbmNlKCkuZGF0YUNoYW5uZWwucmVhZHlTdGF0ZSA9PSAnb3BlbicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIERhdGEgb3ZlciB0aGUgRGF0YSBjaGFubmVsIHRvIHRoZSBVRSBJbnN0YW5jZVxuICAgICAqIEBwYXJhbSBkYXRhIC0gTWVzc2FnZSBEYXRhIEFycmF5IEJ1ZmZlclxuICAgICAqL1xuICAgIHNlbmREYXRhKGRhdGEpIHtcbiAgICAgICAgLy8gcmVzZXQgdGhlIGFmayBpbmFjdGl2aXR5XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsSW5zdGFuY2UgPSB0aGlzLmRhdGFDaGFubmVsUHJvdmlkZXIuZ2V0RGF0YUNoYW5uZWxJbnN0YW5jZSgpO1xuICAgICAgICBpZiAoZGF0YUNoYW5uZWxJbnN0YW5jZS5kYXRhQ2hhbm5lbC5yZWFkeVN0YXRlID09ICdvcGVuJykge1xuICAgICAgICAgICAgZGF0YUNoYW5uZWxJbnN0YW5jZS5kYXRhQ2hhbm5lbC5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oYE1lc3NhZ2UgU2VudDogJHtuZXcgVWludDhBcnJheShkYXRhKX1gKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRBZmtXYXJuaW5nVGltZXJPbkRhdGFTZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoYE1lc3NhZ2UgRmFpbGVkOiAke25ldyBVaW50OEFycmF5KGRhdGEpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIG92ZXJyaWRlIG1ldGhvZCBmb3IgcmVzZXR0aW5nIHRoZSBBZmsgd2FybmluZyB0aW1lciB3aGVuIGRhdGEgaXMgc2VudCBvdmVyIHRoZSBkYXRhIGNoYW5uZWxcbiAgICAgKi9cbiAgICByZXNldEFma1dhcm5pbmdUaW1lck9uRGF0YVNlbmQoKSB7XG4gICAgICAgIC8vIEJhc2UgRnVuY3Rpb25hbGl0eTogRG8gTm90aGluZ1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFDaGFubmVsU2VuZGVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIExhdGVuY3kgVGVzdCBSZXN1bHRzIERhdGFcbiAqL1xuZXhwb3J0IGNsYXNzIEluaXRpYWxTZXR0aW5ncyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuUGl4ZWxTdHJlYW1pbmdTZXR0aW5ncyA9IG5ldyBQaXhlbFN0cmVhbWluZ1NldHRpbmdzKCk7XG4gICAgICAgIHRoaXMuRW5jb2RlclNldHRpbmdzID0gbmV3IEVuY29kZXJTZXR0aW5ncygpO1xuICAgICAgICB0aGlzLldlYlJUQ1NldHRpbmdzID0gbmV3IFdlYlJUQ1NldHRpbmdzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBGUFMgYW5kIE1heEZQUyBzdGF0cyBiZXR3ZWVuIDQuMjcgYW5kIDVcbiAgICAgKi9cbiAgICB1ZUNvbXBhdGlibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLldlYlJUQ1NldHRpbmdzLk1heEZQUyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLldlYlJUQ1NldHRpbmdzLkZQUyA9IHRoaXMuV2ViUlRDU2V0dGluZ3MuTWF4RlBTO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIGNsYXNzIGZvciBoYW5kbGluZyBQaXhlbCBTdHJlYW1pbmcgZGV0YWlsc1xuICovXG5leHBvcnQgY2xhc3MgUGl4ZWxTdHJlYW1pbmdTZXR0aW5ncyB7XG59XG4vKipcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIGVuY29kZXIgc3RhdHNcbiAqL1xuZXhwb3J0IGNsYXNzIEVuY29kZXJTZXR0aW5ncyB7XG59XG4vKipcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIHdlYiBydGMgc3RhdHNcbiAqL1xuZXhwb3J0IGNsYXNzIFdlYlJUQ1NldHRpbmdzIHtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUluaXRpYWxTZXR0aW5ncy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuLyoqXG4gKiBMYXRlbmN5IFRlc3QgUmVzdWx0cyBEYXRhXG4gKi9cbmV4cG9ydCBjbGFzcyBMYXRlbmN5VGVzdFJlc3VsdHMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvL0ZpZWxkcyBTZXQgZnJvbSB0aGUgbGF0ZW5jeSBwYXlsb2FkIHJlZ2FyZGxlc3Mgb2YgdmVyc2lvblxuICAgICAgICB0aGlzLlJlY2VpcHRUaW1lTXMgPSBudWxsO1xuICAgICAgICB0aGlzLlRyYW5zbWlzc2lvblRpbWVNcyA9IG51bGw7XG4gICAgICAgIC8vRmllbGRzIFNldCBmcm9tIHRoZSBsYXRlbmN5IHBheWxvYWQgZnJvbSA0LjI3LjJcbiAgICAgICAgdGhpcy5QcmVDYXB0dXJlVGltZU1zID0gbnVsbDtcbiAgICAgICAgdGhpcy5Qb3N0Q2FwdHVyZVRpbWVNcyA9IG51bGw7XG4gICAgICAgIHRoaXMuUHJlRW5jb2RlVGltZU1zID0gbnVsbDtcbiAgICAgICAgdGhpcy5Qb3N0RW5jb2RlVGltZU1zID0gbnVsbDtcbiAgICAgICAgLy9GaWVsZHMgU2V0IGZyb20gdGhlIGxhdGVuY3kgcGF5bG9hZCBmcm9tIDUuMFxuICAgICAgICB0aGlzLkVuY29kZU1zID0gbnVsbDtcbiAgICAgICAgdGhpcy5DYXB0dXJlVG9TZW5kTXMgPSBudWxsO1xuICAgICAgICAvL0ZpZWxkcyBTZXQgd2hlbiBwcm9jZXNzZWRcbiAgICAgICAgdGhpcy50ZXN0U3RhcnRUaW1lTXMgPSAwO1xuICAgICAgICB0aGlzLmJyb3dzZXJSZWNlaXB0VGltZU1zID0gMDtcbiAgICAgICAgLy9GaWVsZHMgc2V0IGZyb20gY2FsY3VsYXRpb25zXG4gICAgICAgIHRoaXMubGF0ZW5jeUV4Y2x1ZGluZ0RlY29kZSA9IDA7XG4gICAgICAgIHRoaXMudGVzdER1cmF0aW9uID0gMDtcbiAgICAgICAgLy91ZUxhdGVuY3k6IG51bWJlciA9IDA7XG4gICAgICAgIHRoaXMubmV0d29ya0xhdGVuY3kgPSAwO1xuICAgICAgICB0aGlzLmJyb3dzZXJTZW5kTGF0ZW5jeSA9IDA7XG4gICAgICAgIHRoaXMuZnJhbWVEaXNwbGF5RGVsdGFUaW1lTXMgPSAwO1xuICAgICAgICB0aGlzLmVuZFRvRW5kTGF0ZW5jeSA9IDA7XG4gICAgICAgIC8vdWVQaXhlbFN0cmVhbUxhdGVuY3k6IG51bWJlciA9IDA7XG4gICAgICAgIHRoaXMuZW5jb2RlTGF0ZW5jeSA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIERlbHRhIFRpbWUgTWlsbGlzZWNvbmRzXG4gICAgICogQHBhcmFtIERlbHRhVGltZU1zIC0gRGVsdGEgVGltZSBNaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICBzZXRGcmFtZURpc3BsYXlEZWx0YVRpbWUoRGVsdGFUaW1lTXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJhbWVEaXNwbGF5RGVsdGFUaW1lTXMgPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5mcmFtZURpc3BsYXlEZWx0YVRpbWVNcyA9IE1hdGgucm91bmQoRGVsdGFUaW1lTXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIGVuY29kZXIgdGltZXMgYW5kIHNldCB0aGVtXG4gICAgICovXG4gICAgcHJvY2Vzc0ZpZWxkcygpIHtcbiAgICAgICAgaWYgKHRoaXMuRW5jb2RlTXMgPT0gbnVsbCAmJiAodGhpcy5QcmVFbmNvZGVUaW1lTXMgIT0gbnVsbCB8fCB0aGlzLlBvc3RFbmNvZGVUaW1lTXMgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKGBTZXR0aW5nIEVuY29kZSBNcyBcXG4gJHt0aGlzLlBvc3RFbmNvZGVUaW1lTXN9IFxcbiAke3RoaXMuUHJlRW5jb2RlVGltZU1zfWApO1xuICAgICAgICAgICAgdGhpcy5FbmNvZGVNcyA9IHRoaXMuUG9zdEVuY29kZVRpbWVNcyAtIHRoaXMuUHJlRW5jb2RlVGltZU1zO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLkNhcHR1cmVUb1NlbmRNcyA9PSBudWxsICYmXG4gICAgICAgICAgICAodGhpcy5QcmVDYXB0dXJlVGltZU1zICE9IG51bGwgfHwgdGhpcy5Qb3N0Q2FwdHVyZVRpbWVNcyAhPSBudWxsKSkge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oYFNldHRpbmcgQ2FwdHVyZVRvU2VuZE1zIE1zIFxcbiAke3RoaXMuUG9zdENhcHR1cmVUaW1lTXN9IFxcbiAke3RoaXMuUHJlQ2FwdHVyZVRpbWVNc31gKTtcbiAgICAgICAgICAgIHRoaXMuQ2FwdHVyZVRvU2VuZE1zID0gdGhpcy5Qb3N0Q2FwdHVyZVRpbWVNcyAtIHRoaXMuUHJlQ2FwdHVyZVRpbWVNcztcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxhdGVuY3lUZXN0UmVzdWx0cy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBBIGNsYXNzIGZvciBtYW5hZ2luZyB0aGUgZnJlZXplIGZyYW1lIG9iamVjdFxuICovXG5leHBvcnQgY2xhc3MgRnJlZXplRnJhbWUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIGZyZWV6ZSBmcmFtZVxuICAgICAqIEBwYXJhbSByb290RGl2IHRoZSBkaXYgdGhhdCBhIGZyZWV6ZSBmcmFtZSBlbGVtZW50IHdpbGwgYmUgaW5qZWN0ZWQgaW50b1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJvb3REaXYpIHtcbiAgICAgICAgdGhpcy5mcmVlemVGcmFtZUhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuZnJlZXplRnJhbWVXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMucm9vdERpdiA9IHJvb3REaXY7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgb3ZlcmxheVxuICAgICAgICB0aGlzLnJvb3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQuaWQgPSAnZnJlZXplRnJhbWUnO1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgdGhpcy5yb290RWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQuc3R5bGUuekluZGV4ID0gJzIwJztcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBpbWFnZSBwbGFjZSBob2xkZXJcbiAgICAgICAgdGhpcy5pbWFnZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgdGhpcy5pbWFnZUVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGltYWdlIGludG8gdGhlIHJvb3QgZWxlbWVudCBhbmQgYXBwZW5kIHRoZSBlbGVtZW50IHRvIHRoZSByb290IGRpdlxuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuaW1hZ2VFbGVtZW50KTtcbiAgICAgICAgdGhpcy5yb290RGl2LmFwcGVuZENoaWxkKHRoaXMucm9vdEVsZW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZyZWV6ZSBmcmFtZSBlbGVtZW50IGZvciBzaG93aW5nXG4gICAgICovXG4gICAgc2V0RWxlbWVudEZvclNob3coKSB7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZnJlZXplIGZyYW1lIGVsZW1lbnQgZm9yIGhpZGluZ1xuICAgICAqL1xuICAgIHNldEVsZW1lbnRGb3JIaWRlKCkge1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZnJlZXplIGZyYW1lcyBpbWFnZSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ganBlZyAtIHRoZSBmcmVlemUgZnJhbWUgaW1hZ2UgYXMgYSBieXRlIGFycmF5IGRhdGFcbiAgICAgKi9cbiAgICB1cGRhdGVJbWFnZUVsZW1lbnRTb3VyY2UoanBlZykge1xuICAgICAgICBjb25zdCBiYXNlNjQgPSBidG9hKGpwZWcucmVkdWNlKChkYXRhLCBieXRlKSA9PiBkYXRhICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSwgJycpKTtcbiAgICAgICAgdGhpcy5pbWFnZUVsZW1lbnQuc3JjID0gJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsJyArIGJhc2U2NDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBkaW1lbnNpb25zIGZvciB0aGUgZnJlZXplIGZyYW1lIGZyb20gdGhlIGVsZW1lbnQgYW5kIHJlc2l6ZSBpdFxuICAgICAqL1xuICAgIHNldERpbWVuc2lvbnNGcm9tRWxlbWVudEFuZFJlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy5mcmVlemVGcmFtZUhlaWdodCA9IHRoaXMuaW1hZ2VFbGVtZW50Lm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgIHRoaXMuZnJlZXplRnJhbWVXaWR0aCA9IHRoaXMuaW1hZ2VFbGVtZW50Lm5hdHVyYWxXaWR0aDtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzaXplIGEgZnJlZXplIGZyYW1lIGVsZW1lbnRcbiAgICAgKi9cbiAgICByZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmZyZWV6ZUZyYW1lV2lkdGggIT09IDAgJiYgdGhpcy5mcmVlemVGcmFtZUhlaWdodCAhPT0gMCkge1xuICAgICAgICAgICAgbGV0IGRpc3BsYXlXaWR0aCA9IDA7XG4gICAgICAgICAgICBsZXQgZGlzcGxheUhlaWdodCA9IDA7XG4gICAgICAgICAgICBsZXQgZGlzcGxheVRvcCA9IDA7XG4gICAgICAgICAgICBsZXQgZGlzcGxheUxlZnQgPSAwO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50QXNwZWN0UmF0aW8gPSB0aGlzLnJvb3REaXYuY2xpZW50V2lkdGggLyB0aGlzLnJvb3REaXYuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgdmlkZW9Bc3BlY3RSYXRpbyA9IHRoaXMuZnJlZXplRnJhbWVXaWR0aCAvIHRoaXMuZnJlZXplRnJhbWVIZWlnaHQ7XG4gICAgICAgICAgICBpZiAocGFyZW50QXNwZWN0UmF0aW8gPCB2aWRlb0FzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgZGlzcGxheVdpZHRoID0gdGhpcy5yb290RGl2LmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgIGRpc3BsYXlIZWlnaHQgPSBNYXRoLmZsb29yKHRoaXMucm9vdERpdi5jbGllbnRXaWR0aCAvIHZpZGVvQXNwZWN0UmF0aW8pO1xuICAgICAgICAgICAgICAgIGRpc3BsYXlUb3AgPSBNYXRoLmZsb29yKCh0aGlzLnJvb3REaXYuY2xpZW50SGVpZ2h0IC0gZGlzcGxheUhlaWdodCkgKiAwLjUpO1xuICAgICAgICAgICAgICAgIGRpc3BsYXlMZWZ0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlXaWR0aCA9IE1hdGguZmxvb3IodGhpcy5yb290RGl2LmNsaWVudEhlaWdodCAqIHZpZGVvQXNwZWN0UmF0aW8pO1xuICAgICAgICAgICAgICAgIGRpc3BsYXlIZWlnaHQgPSB0aGlzLnJvb3REaXYuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGRpc3BsYXlUb3AgPSAwO1xuICAgICAgICAgICAgICAgIGRpc3BsYXlMZWZ0ID0gTWF0aC5mbG9vcigodGhpcy5yb290RGl2LmNsaWVudFdpZHRoIC0gZGlzcGxheVdpZHRoKSAqIDAuNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJvb3RFbGVtZW50LnN0eWxlLndpZHRoID0gdGhpcy5yb290RGl2Lm9mZnNldFdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMucm9vdEVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5yb290RGl2Lm9mZnNldEhlaWdodCArICdweCc7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbGVtZW50LnN0eWxlLmxlZnQgPSAwICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMucm9vdEVsZW1lbnQuc3R5bGUudG9wID0gMCArICdweCc7XG4gICAgICAgICAgICB0aGlzLmltYWdlRWxlbWVudC5zdHlsZS53aWR0aCA9IGRpc3BsYXlXaWR0aCArICdweCc7XG4gICAgICAgICAgICB0aGlzLmltYWdlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50LnN0eWxlLmxlZnQgPSBkaXNwbGF5TGVmdCArICdweCc7XG4gICAgICAgICAgICB0aGlzLmltYWdlRWxlbWVudC5zdHlsZS50b3AgPSBkaXNwbGF5VG9wICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZyZWV6ZUZyYW1lLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG5pbXBvcnQgeyBGcmVlemVGcmFtZSB9IGZyb20gJy4vRnJlZXplRnJhbWUnO1xuLyoqXG4gKiBBIGNsYXNzIGZvciBjb250cm9sbGluZyBmcmVlemUgZnJhbWUgZnVuY3Rpb25hbGl0eVxuICovXG5leHBvcnQgY2xhc3MgRnJlZXplRnJhbWVDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBmcmVlemUgZnJhbWUgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSByb290RGl2IC0gdGhlIGRpdiB0aGF0IGEgZnJlZXplIGZyYW1lIGVsZW1lbnQgd2lsbCBiZSBpbmplY3RlZCBpbnRvXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iocm9vdERpdikge1xuICAgICAgICB0aGlzLnJlY2VpdmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLmpwZWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mcmVlemVGcmFtZURlbGF5ID0gNTA7XG4gICAgICAgIHRoaXMuZnJlZXplRnJhbWUgPSBuZXcgRnJlZXplRnJhbWUocm9vdERpdik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIGZyZWV6ZSBmcmFtZSBpZiBpdCBpcyB2YWxpZFxuICAgICAqL1xuICAgIHNob3dGcmVlemVGcmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZnJlZXplRnJhbWUuc2V0RWxlbWVudEZvclNob3coKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBmcmVlemUgZnJhbWUgYW5kIHNldCB0aGUgdmFsaWRpdHkgdG8gZmFsc2VcbiAgICAgKi9cbiAgICBoaWRlRnJlZXplRnJhbWUoKSB7XG4gICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mcmVlemVGcmFtZS5zZXRFbGVtZW50Rm9ySGlkZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGZyZWV6ZSBmcmFtZXMgaW1hZ2Ugc291cmNlIGFuZCBsb2FkIGl0XG4gICAgICogQHBhcmFtIGpwZWcgLSB0aGUgZnJlZXplIGZyYW1lIGltYWdlIGFzIGEgYnl0ZSBhcnJheSBkYXRhXG4gICAgICogQHBhcmFtIG9uTG9hZENhbGxCYWNrIC0gYSBjYWxsIGJhY2sgZm9yIG1hbmFnaW5nIGlmIHRoZSBwbGF5IG92ZXJsYXkgbmVlZHMgdG8gYmUgc2hvd24gb3Igbm90XG4gICAgICovXG4gICAgdXBkYXRlRnJlZXplRnJhbWVBbmRTaG93KGpwZWcsIG9uTG9hZENhbGxCYWNrKSB7XG4gICAgICAgIHRoaXMuZnJlZXplRnJhbWUudXBkYXRlSW1hZ2VFbGVtZW50U291cmNlKGpwZWcpO1xuICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lLmltYWdlRWxlbWVudC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lLnNldERpbWVuc2lvbnNGcm9tRWxlbWVudEFuZFJlc2l6ZSgpO1xuICAgICAgICAgICAgb25Mb2FkQ2FsbEJhY2soKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgbmV3IGZyZWV6ZSBmcmFtZSBpbWFnZSBhbmQgdXBkYXRlIGl0XG4gICAgICogQHBhcmFtIHZpZXcgLSB0aGUgZnJlZXplIGZyYW1lIGltYWdlIGFzIGEgYnl0ZSBhcnJheSBkYXRhXG4gICAgICogQHBhcmFtIG9uTG9hZENhbGxCYWNrIC0gYSBjYWxsIGJhY2sgZm9yIG1hbmFnaW5nIGlmIHRoZSBwbGF5IG92ZXJsYXkgbmVlZHMgdG8gYmUgc2hvd24gb3Igbm90XG4gICAgICovXG4gICAgcHJvY2Vzc0ZyZWV6ZUZyYW1lTWVzc2FnZSh2aWV3LCBvbkxvYWRDYWxsQmFjaykge1xuICAgICAgICAvLyBSZXNldCBmcmVlemUgZnJhbWUgaWYgd2UgZ290IGEgZnJlZXplIGZyYW1lIG1lc3NhZ2UgYW5kIHdlIGFyZSBub3QgXCJyZWNlaXZpbmdcIiB5ZXQuXG4gICAgICAgIGlmICghdGhpcy5yZWNlaXZpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucmVjZWl2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmpwZWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXh0cmFjdCB0b3RhbCBzaXplIG9mIGZyZWV6ZSBmcmFtZSAoYWNyb3NzIGFsbCBjaHVua3MpXG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ldyBEYXRhVmlldyh2aWV3LnNsaWNlKDEsIDUpLmJ1ZmZlcikuZ2V0SW50MzIoMCwgdHJ1ZSk7XG4gICAgICAgIC8vIEdldCB0aGUganBlZyBwYXJ0IG9mIHRoZSBwYXlsb2FkXG4gICAgICAgIGNvbnN0IGpwZWdCeXRlcyA9IHZpZXcuc2xpY2UoMSArIDQpO1xuICAgICAgICAvLyBBcHBlbmQgdG8gZXhpc3RpbmcganBlZyB0aGF0IGhvbGRzIHRoZSBmcmVlemUgZnJhbWVcbiAgICAgICAgaWYgKHRoaXMuanBlZykge1xuICAgICAgICAgICAgY29uc3QganBlZyA9IG5ldyBVaW50OEFycmF5KHRoaXMuanBlZy5sZW5ndGggKyBqcGVnQnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGpwZWcuc2V0KHRoaXMuanBlZywgMCk7XG4gICAgICAgICAgICBqcGVnLnNldChqcGVnQnl0ZXMsIHRoaXMuanBlZy5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5qcGVnID0ganBlZztcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBleGlzdGluZyBmcmVlemUgZnJhbWUganBlZywgbWFrZSBvbmVcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmpwZWcgPSBqcGVnQnl0ZXM7XG4gICAgICAgICAgICB0aGlzLnJlY2VpdmluZyA9IHRydWU7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbyhgcmVjZWl2ZWQgZmlyc3QgY2h1bmsgb2YgZnJlZXplIGZyYW1lOiAke3RoaXMuanBlZy5sZW5ndGh9LyR7dGhpcy5zaXplfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmlzaGVkIHJlY2VpdmluZyBmcmVlemUgZnJhbWUsIHdlIGNhbiBzaG93IGl0IG5vd1xuICAgICAgICBpZiAodGhpcy5qcGVnLmxlbmd0aCA9PT0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICB0aGlzLnJlY2VpdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbyhgcmVjZWl2ZWQgY29tcGxldGUgZnJlZXplIGZyYW1lICR7dGhpcy5zaXplfWApO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGcmVlemVGcmFtZUFuZFNob3codGhpcy5qcGVnLCBvbkxvYWRDYWxsQmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgcmVjZWl2ZWQgbW9yZSBkYXRhIHRoYW4gdGhlIGZyZWV6ZSBmcmFtZSBwYXlsb2FkIG1lc3NhZ2UgaW5kaWNhdGUgKHRoaXMgaXMgYW4gZXJyb3IpXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuanBlZy5sZW5ndGggPiB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihgcmVjZWl2ZWQgYmlnZ2VyIGZyZWV6ZSBmcmFtZSB0aGFuIGFkdmVydGlzZWQ6ICR7dGhpcy5qcGVnLmxlbmd0aH0vJHt0aGlzLnNpemV9YCk7XG4gICAgICAgICAgICB0aGlzLmpwZWcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnJlY2VpdmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJlZXplRnJhbWVDb250cm9sbGVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBkZWVwQ29weUdhbWVwYWQgfSBmcm9tICcuL0dhbWVwYWRUeXBlcyc7XG4vKipcbiAqIEdhbWVwYWQgbGF5b3V0IGNvZGVzIGVudW1cbiAqL1xuZXhwb3J0IHZhciBHYW1lcGFkTGF5b3V0O1xuKGZ1bmN0aW9uIChHYW1lcGFkTGF5b3V0KSB7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiUmlnaHRDbHVzdGVyQm90dG9tQnV0dG9uXCJdID0gMF0gPSBcIlJpZ2h0Q2x1c3RlckJvdHRvbUJ1dHRvblwiO1xuICAgIEdhbWVwYWRMYXlvdXRbR2FtZXBhZExheW91dFtcIlJpZ2h0Q2x1c3RlclJpZ2h0QnV0dG9uXCJdID0gMV0gPSBcIlJpZ2h0Q2x1c3RlclJpZ2h0QnV0dG9uXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiUmlnaHRDbHVzdGVyTGVmdEJ1dHRvblwiXSA9IDJdID0gXCJSaWdodENsdXN0ZXJMZWZ0QnV0dG9uXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiUmlnaHRDbHVzdGVyVG9wQnV0dG9uXCJdID0gM10gPSBcIlJpZ2h0Q2x1c3RlclRvcEJ1dHRvblwiO1xuICAgIEdhbWVwYWRMYXlvdXRbR2FtZXBhZExheW91dFtcIkxlZnRTaG91bGRlclwiXSA9IDRdID0gXCJMZWZ0U2hvdWxkZXJcIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJSaWdodFNob3VsZGVyXCJdID0gNV0gPSBcIlJpZ2h0U2hvdWxkZXJcIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJMZWZ0VHJpZ2dlclwiXSA9IDZdID0gXCJMZWZ0VHJpZ2dlclwiO1xuICAgIEdhbWVwYWRMYXlvdXRbR2FtZXBhZExheW91dFtcIlJpZ2h0VHJpZ2dlclwiXSA9IDddID0gXCJSaWdodFRyaWdnZXJcIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJTZWxlY3RPckJhY2tcIl0gPSA4XSA9IFwiU2VsZWN0T3JCYWNrXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiU3RhcnRPckZvcndhcmRcIl0gPSA5XSA9IFwiU3RhcnRPckZvcndhcmRcIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJMZWZ0QW5hbG9nUHJlc3NcIl0gPSAxMF0gPSBcIkxlZnRBbmFsb2dQcmVzc1wiO1xuICAgIEdhbWVwYWRMYXlvdXRbR2FtZXBhZExheW91dFtcIlJpZ2h0QW5hbG9nUHJlc3NcIl0gPSAxMV0gPSBcIlJpZ2h0QW5hbG9nUHJlc3NcIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJMZWZ0Q2x1c3RlclRvcEJ1dHRvblwiXSA9IDEyXSA9IFwiTGVmdENsdXN0ZXJUb3BCdXR0b25cIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJMZWZ0Q2x1c3RlckJvdHRvbUJ1dHRvblwiXSA9IDEzXSA9IFwiTGVmdENsdXN0ZXJCb3R0b21CdXR0b25cIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJMZWZ0Q2x1c3RlckxlZnRCdXR0b25cIl0gPSAxNF0gPSBcIkxlZnRDbHVzdGVyTGVmdEJ1dHRvblwiO1xuICAgIEdhbWVwYWRMYXlvdXRbR2FtZXBhZExheW91dFtcIkxlZnRDbHVzdGVyUmlnaHRCdXR0b25cIl0gPSAxNV0gPSBcIkxlZnRDbHVzdGVyUmlnaHRCdXR0b25cIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJDZW50cmVCdXR0b25cIl0gPSAxNl0gPSBcIkNlbnRyZUJ1dHRvblwiO1xuICAgIC8vIEF4ZXNcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJMZWZ0U3RpY2tIb3Jpem9udGFsXCJdID0gMF0gPSBcIkxlZnRTdGlja0hvcml6b250YWxcIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJMZWZ0U3RpY2tWZXJ0aWNhbFwiXSA9IDFdID0gXCJMZWZ0U3RpY2tWZXJ0aWNhbFwiO1xuICAgIEdhbWVwYWRMYXlvdXRbR2FtZXBhZExheW91dFtcIlJpZ2h0U3RpY2tIb3Jpem9udGFsXCJdID0gMl0gPSBcIlJpZ2h0U3RpY2tIb3Jpem9udGFsXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiUmlnaHRTdGlja1ZlcnRpY2FsXCJdID0gM10gPSBcIlJpZ2h0U3RpY2tWZXJ0aWNhbFwiO1xufSkoR2FtZXBhZExheW91dCB8fCAoR2FtZXBhZExheW91dCA9IHt9KSk7XG4vKipcbiAqIEhhbmRsZXMgZ2FtZXBhZCBldmVudHMgZnJvbSB0aGUgZG9jdW1lbnQgdG8gc2VuZCB0byB0aGUgc3RyZWFtZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBHYW1lcGFkQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3Ioc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlciA9IHN0cmVhbU1lc3NhZ2VDb250cm9sbGVyO1xuICAgICAgICB0aGlzLm9uR2FtZXBhZENvbm5lY3RlZExpc3RlbmVyID0gdGhpcy5vbkdhbWVwYWRDb25uZWN0ZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkdhbWVwYWREaXNjb25uZWN0ZWRMaXN0ZW5lciA9IHRoaXMub25HYW1lcGFkRGlzY29ubmVjdGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYmVmb3JlVW5sb2FkTGlzdGVuZXIgPSB0aGlzLm9uQmVmb3JlVW5sb2FkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLmJpbmQod2luZG93KTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLmJlZm9yZVVubG9hZExpc3RlbmVyKTtcbiAgICAgICAgY29uc3QgYnJvd3NlcldpbmRvdyA9IHdpbmRvdztcbiAgICAgICAgaWYgKCdHYW1lcGFkRXZlbnQnIGluIGJyb3dzZXJXaW5kb3cpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdnYW1lcGFkY29ubmVjdGVkJywgdGhpcy5vbkdhbWVwYWRDb25uZWN0ZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZ2FtZXBhZGRpc2Nvbm5lY3RlZCcsIHRoaXMub25HYW1lcGFkRGlzY29ubmVjdGVkTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdXZWJLaXRHYW1lcGFkRXZlbnQnIGluIGJyb3dzZXJXaW5kb3cpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRnYW1lcGFkY29ubmVjdGVkJywgdGhpcy5vbkdhbWVwYWRDb25uZWN0ZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0Z2FtZXBhZGRpc2Nvbm5lY3RlZCcsIHRoaXMub25HYW1lcGFkRGlzY29ubmVjdGVkTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnMgPSBbXTtcbiAgICAgICAgaWYgKG5hdmlnYXRvci5nZXRHYW1lcGFkcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBnYW1lcGFkIG9mIG5hdmlnYXRvci5nZXRHYW1lcGFkcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdhbWVwYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkdhbWVwYWRDb25uZWN0ZWQobmV3IEdhbWVwYWRFdmVudCgnZ2FtZXBhZGNvbm5lY3RlZCcsIHsgZ2FtZXBhZCB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdnYW1lcGFkY29ubmVjdGVkJywgdGhpcy5vbkdhbWVwYWRDb25uZWN0ZWRMaXN0ZW5lcik7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdnYW1lcGFkZGlzY29ubmVjdGVkJywgdGhpcy5vbkdhbWVwYWREaXNjb25uZWN0ZWRMaXN0ZW5lcik7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRnYW1lcGFkY29ubmVjdGVkJywgdGhpcy5vbkdhbWVwYWRDb25uZWN0ZWRMaXN0ZW5lcik7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRnYW1lcGFkZGlzY29ubmVjdGVkJywgdGhpcy5vbkdhbWVwYWREaXNjb25uZWN0ZWRMaXN0ZW5lcik7XG4gICAgICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzKSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlciAmJiBjb250cm9sbGVyLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0dhbWVwYWREaXNjb25uZWN0ZWQnKShbY29udHJvbGxlci5pZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnMgPSBbXTtcbiAgICB9XG4gICAgb25HYW1lcGFkUmVzcG9uc2VSZWNlaXZlZChnYW1lcGFkSWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuY29udHJvbGxlcnMpIHtcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyICYmIGNvbnRyb2xsZXIuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuaWQgPSBnYW1lcGFkSWQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25HYW1lcGFkQ29ubmVjdGVkKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGdhbWVwYWQgPSBldmVudC5nYW1lcGFkO1xuICAgICAgICBjb25zdCBuZXdDb250cm9sbGVyID0ge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlOiBkZWVwQ29weUdhbWVwYWQoZ2FtZXBhZCksXG4gICAgICAgICAgICBwcmV2U3RhdGU6IGRlZXBDb3B5R2FtZXBhZChnYW1lcGFkKSxcbiAgICAgICAgICAgIGlkOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyc1tnYW1lcGFkLmluZGV4XSA9IG5ld0NvbnRyb2xsZXI7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy51cGRhdGVTdGF0dXMoKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnR2FtZXBhZENvbm5lY3RlZCcpKCk7XG4gICAgfVxuICAgIG9uR2FtZXBhZERpc2Nvbm5lY3RlZChldmVudCkge1xuICAgICAgICBjb25zdCBnYW1lcGFkID0gZXZlbnQuZ2FtZXBhZDtcbiAgICAgICAgY29uc3QgZGVsZXRlZENvbnRyb2xsZXIgPSB0aGlzLmNvbnRyb2xsZXJzW2dhbWVwYWQuaW5kZXhdO1xuICAgICAgICBkZWxldGUgdGhpcy5jb250cm9sbGVyc1tnYW1lcGFkLmluZGV4XTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVycyA9IHRoaXMuY29udHJvbGxlcnMuZmlsdGVyKChjb250cm9sbGVyKSA9PiBjb250cm9sbGVyICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoZGVsZXRlZENvbnRyb2xsZXIuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdHYW1lcGFkRGlzY29ubmVjdGVkJykoW1xuICAgICAgICAgICAgICAgIGRlbGV0ZWRDb250cm9sbGVyLmlkXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY2FuR2FtZXBhZHMoKSB7XG4gICAgICAgIGNvbnN0IGdhbWVwYWRzID0gbmF2aWdhdG9yLmdldEdhbWVwYWRzXG4gICAgICAgICAgICA/IG5hdmlnYXRvci5nZXRHYW1lcGFkcygpXG4gICAgICAgICAgICA6IG5hdmlnYXRvci53ZWJraXRHZXRHYW1lcGFkc1xuICAgICAgICAgICAgICAgID8gbmF2aWdhdG9yLndlYmtpdEdldEdhbWVwYWRzKClcbiAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdhbWVwYWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZ2FtZXBhZHNbaV0gJiYgdGhpcy5jb250cm9sbGVyc1tnYW1lcGFkc1tpXS5pbmRleF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcnNbZ2FtZXBhZHNbaV0uaW5kZXhdLmN1cnJlbnRTdGF0ZSA9IGdhbWVwYWRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVN0YXR1cygpIHtcbiAgICAgICAgdGhpcy5zY2FuR2FtZXBhZHMoKTtcbiAgICAgICAgY29uc3QgdG9TdHJlYW1lckhhbmRsZXJzID0gdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnM7XG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBtdWx0aXBsZSBjb250cm9sbGVycyBpbiB0aGUgY2FzZSB0aGUgbXVsdGlwbGUgZ2FtZXBhZHMgYXJlIGNvbm5lY3RlZFxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXIgb2YgdGhpcy5jb250cm9sbGVycykge1xuICAgICAgICAgICAgaWYgKCFjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IHJlY2VpdmVkIGFuIGlkIChwb3NzaWJsZSBpZiB1c2luZyBhbiBvbGRlciB2ZXJzaW9uIG9mIFVFKSwgcmV0dXJuIHRvIG9yaWdpbmFsIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXJJZCA9IGNvbnRyb2xsZXIuaWQgPT09IHVuZGVmaW5lZCA/IHRoaXMuY29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKSA6IGNvbnRyb2xsZXIuaWQ7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBjb250cm9sbGVyLmN1cnJlbnRTdGF0ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udHJvbGxlci5jdXJyZW50U3RhdGUuYnV0dG9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRCdXR0b24gPSBjb250cm9sbGVyLmN1cnJlbnRTdGF0ZS5idXR0b25zW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzQnV0dG9uID0gY29udHJvbGxlci5wcmV2U3RhdGUuYnV0dG9uc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEJ1dHRvbi5wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXNzXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IEdhbWVwYWRMYXlvdXQuTGVmdFRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVFcyBsZWZ0IGFuYWxvZyBoYXMgYSBidXR0b24gaW5kZXggb2YgNVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnR2FtZXBhZEFuYWxvZycpKFtjb250cm9sbGVySWQsIDUsIGN1cnJlbnRCdXR0b24udmFsdWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09IEdhbWVwYWRMYXlvdXQuUmlnaHRUcmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVRXMgcmlnaHQgYW5hbG9nIGhhcyBhIGJ1dHRvbiBpbmRleCBvZiA2XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdHYW1lcGFkQW5hbG9nJykoW2NvbnRyb2xsZXJJZCwgNiwgY3VycmVudEJ1dHRvbi52YWx1ZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnR2FtZXBhZEJ1dHRvblByZXNzZWQnKShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNCdXR0b24ucHJlc3NlZCA/IDEgOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY3VycmVudEJ1dHRvbi5wcmVzc2VkICYmIHByZXZpb3VzQnV0dG9uLnByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsZWFzZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBHYW1lcGFkTGF5b3V0LkxlZnRUcmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVRXMgbGVmdCBhbmFsb2cgaGFzIGEgYnV0dG9uIGluZGV4IG9mIDVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0dhbWVwYWRBbmFsb2cnKShbY29udHJvbGxlcklkLCA1LCAwXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSBHYW1lcGFkTGF5b3V0LlJpZ2h0VHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVUVzIHJpZ2h0IGFuYWxvZyBoYXMgYSBidXR0b24gaW5kZXggb2YgNlxuICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnR2FtZXBhZEFuYWxvZycpKFtjb250cm9sbGVySWQsIDYsIDBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0dhbWVwYWRCdXR0b25SZWxlYXNlZCcpKFtjb250cm9sbGVySWQsIGksIDBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBnYW1lcGFkIGF4ZXMgKHdlIHdpbGwgaW5jcmVtZW50IGluIGxvdHMgb2YgMiBhcyB0aGVyZSBpcyAyIGF4ZXMgcGVyIHN0aWNrKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50U3RhdGUuYXhlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgYXhlcyBhcmUgZXZlbiBudW1iZXJlZFxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBwYXJzZUZsb2F0KGN1cnJlbnRTdGF0ZS5heGVzW2ldLnRvRml4ZWQoNCkpO1xuICAgICAgICAgICAgICAgIC8vIFZlcnRpY2FsIGF4ZXMgYXJlIG9kZCBudW1iZXJlZFxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9nYW1lcGFkLyNyZW1hcHBpbmcgR2FtZXBhZCBicm93c2VyIHNpZGUgc3RhbmRhcmQgbWFwcGluZyBoYXMgcG9zaXRpdmUgZG93biwgbmVnYXRpdmUgdXAuIFRoaXMgaXMgZG93bnJpZ2h0IGRpc2d1c3RpbmcuIFNvIHdlIGZpeCBpdC5cbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gLXBhcnNlRmxvYXQoY3VycmVudFN0YXRlLmF4ZXNbaSArIDFdLnRvRml4ZWQoNCkpO1xuICAgICAgICAgICAgICAgIC8vIFVFJ3MgYW5hbG9nIGF4ZXMgZm9sbG93IHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBicm93c2VycywgYnV0IHN0YXJ0IGF0IGluZGV4IDEgc28gd2Ugd2lsbCBvZmZzZXQgYXMgc3VjaFxuICAgICAgICAgICAgICAgIHRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0dhbWVwYWRBbmFsb2cnKShbY29udHJvbGxlcklkLCBpICsgMSwgeF0pOyAvLyBIb3Jpem9udGFsIGF4ZXMsIG9ubHkgb2Zmc2V0IGJ5IDFcbiAgICAgICAgICAgICAgICB0b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdHYW1lcGFkQW5hbG9nJykoW2NvbnRyb2xsZXJJZCwgaSArIDIsIHldKTsgLy8gVmVydGljYWwgYXhlcywgb2Zmc2V0IGJ5IHR3byAoMSB0byBtYXRjaCBVRXMgYXhlcyBjb252ZW50aW9uIGFuZCB0aGVuIGFub3RoZXIgMSBmb3IgdGhlIHZlcnRpY2FsIGF4ZXMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb250cm9sbGVySW5kZXggPSB0aGlzLmNvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcik7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJzW2NvbnRyb2xsZXJJbmRleF0ucHJldlN0YXRlID0gZGVlcENvcHlHYW1lcGFkKGN1cnJlbnRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29udHJvbGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy51cGRhdGVTdGF0dXMoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25CZWZvcmVVbmxvYWQoXykge1xuICAgICAgICAvLyBXaGVuIGEgdXNlciBuYXZpZ2F0ZXMgYXdheSBmcm9tIHRoZSBwYWdlLCB3ZSBuZWVkIHRvIGluZm9ybSBVRSBvZiBhbGwgdGhlIGRpc2Nvbm5lY3RpbmdcbiAgICAgICAgLy8gY29udHJvbGxlcnNcbiAgICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuY29udHJvbGxlcnMpIHtcbiAgICAgICAgICAgIGlmICghY29udHJvbGxlciB8fCBjb250cm9sbGVyLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnR2FtZXBhZERpc2Nvbm5lY3RlZCcpKFtjb250cm9sbGVyLmlkXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HYW1lcGFkQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBEZWVwIGNvcGllcyB0aGUgdmFsdWVzIGZyb20gYSBnYW1lcGFkIGJ5IGZpcnN0IGNvbnZlcnRpbmcgaXQgdG8gYSBKU09OIG9iamVjdCBhbmQgdGhlbiBiYWNrIHRvIGEgZ2FtZXBhZFxuICpcbiAqIEBwYXJhbSBnYW1lcGFkIHRoZSBvcmlnaW5hbCBnYW1lcGFkXG4gKiBAcmV0dXJucyBhIG5ldyBnYW1lcGFkIG9iamVjdCwgcG9wdWxhdGVkIHdpdGggdGhlIG9yaWdpbmFsIGdhbWVwYWRzIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcENvcHlHYW1lcGFkKGdhbWVwYWQpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGJ1dHRvbnM6IGdhbWVwYWQuYnV0dG9ucy5tYXAoKGIpID0+IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgcHJlc3NlZDogYi5wcmVzc2VkLFxuICAgICAgICAgICAgdG91Y2hlZDogYi50b3VjaGVkLFxuICAgICAgICAgICAgdmFsdWU6IGIudmFsdWVcbiAgICAgICAgfSkpKSxcbiAgICAgICAgYXhlczogZ2FtZXBhZC5heGVzXG4gICAgfSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2FtZXBhZFR5cGVzLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBLZXlib2FyZENvbnRyb2xsZXIgfSBmcm9tICcuL0tleWJvYXJkQ29udHJvbGxlcic7XG5pbXBvcnQgeyBNb3VzZUNvbnRyb2xsZXJMb2NrZWQgfSBmcm9tICcuL01vdXNlQ29udHJvbGxlckxvY2tlZCc7XG5pbXBvcnQgeyBNb3VzZUNvbnRyb2xsZXJIb3ZlcmluZyB9IGZyb20gJy4vTW91c2VDb250cm9sbGVySG92ZXJpbmcnO1xuaW1wb3J0IHsgVG91Y2hDb250cm9sbGVyIH0gZnJvbSAnLi9Ub3VjaENvbnRyb2xsZXInO1xuaW1wb3J0IHsgVG91Y2hDb250cm9sbGVyRmFrZSB9IGZyb20gJy4vVG91Y2hDb250cm9sbGVyRmFrZSc7XG5pbXBvcnQgeyBHYW1lcGFkQ29udHJvbGxlciB9IGZyb20gJy4vR2FtZXBhZENvbnRyb2xsZXInO1xuaW1wb3J0IHsgQ29udHJvbFNjaGVtZVR5cGUgfSBmcm9tICcuLi9Db25maWcvQ29uZmlnJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42Jztcbi8qKlxuICogQ2xhc3MgZm9yIG1ha2luZyBhbmQgc2V0dGluZyB1cCBpbnB1dCBjbGFzcyB0eXBlc1xuICovXG5leHBvcnQgY2xhc3MgSW5wdXRDbGFzc2VzRmFjdG9yeSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHRvU3RyZWFtZXJNZXNzYWdlc1Byb3ZpZGVyIC0gU3RyZWFtIG1lc3NhZ2UgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gdmlkZW9FbGVtZW50UHJvdmlkZXIgLSBWaWRlbyBQbGF5ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gY29vcmRpbmF0ZUNvbnZlcnRlciAtIEEgY29vcmRpbmF0ZUNvbnZlcnRlciBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRvU3RyZWFtZXJNZXNzYWdlc1Byb3ZpZGVyLCB2aWRlb0VsZW1lbnRQcm92aWRlciwgY29vcmRpbmF0ZUNvbnZlcnRlcikge1xuICAgICAgICB0aGlzLmFjdGl2ZUtleXMgPSBuZXcgQWN0aXZlS2V5cygpO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlc1Byb3ZpZGVyID0gdG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXI7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UHJvdmlkZXIgPSB2aWRlb0VsZW1lbnRQcm92aWRlcjtcbiAgICAgICAgdGhpcy5jb29yZGluYXRlQ29udmVydGVyID0gY29vcmRpbmF0ZUNvbnZlcnRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGJyb3dzZXIga2V5IGV2ZW50cy5cbiAgICAgKi9cbiAgICByZWdpc3RlcktleUJvYXJkKGNvbmZpZykge1xuICAgICAgICBMb2dnZXIuSW5mbygnUmVnaXN0ZXIgS2V5Ym9hcmQgRXZlbnRzJyk7XG4gICAgICAgIGNvbnN0IGtleWJvYXJkQ29udHJvbGxlciA9IG5ldyBLZXlib2FyZENvbnRyb2xsZXIodGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlciwgY29uZmlnLCB0aGlzLmFjdGl2ZUtleXMpO1xuICAgICAgICBrZXlib2FyZENvbnRyb2xsZXIucmVnaXN0ZXIoKTtcbiAgICAgICAgcmV0dXJuIGtleWJvYXJkQ29udHJvbGxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmVnaXN0ZXIgbW91c2UgZXZlbnRzIGJhc2VkIG9uIGEgY29udHJvbCB0eXBlXG4gICAgICogQHBhcmFtIGNvbnRyb2xTY2hlbWUgLSBpZiB0aGUgbW91c2UgaXMgZWl0aGVyIGhvdmVyaW5nIG9yIGxvY2tlZFxuICAgICAqL1xuICAgIHJlZ2lzdGVyTW91c2UoY29udHJvbFNjaGVtZSkge1xuICAgICAgICBMb2dnZXIuSW5mbygnUmVnaXN0ZXIgTW91c2UgRXZlbnRzJyk7XG4gICAgICAgIGxldCBtb3VzZUNvbnRyb2xsZXI7XG4gICAgICAgIGlmIChjb250cm9sU2NoZW1lID09IENvbnRyb2xTY2hlbWVUeXBlLkhvdmVyaW5nTW91c2UpIHtcbiAgICAgICAgICAgIG1vdXNlQ29udHJvbGxlciA9IG5ldyBNb3VzZUNvbnRyb2xsZXJIb3ZlcmluZyh0aGlzLnRvU3RyZWFtZXJNZXNzYWdlc1Byb3ZpZGVyLCB0aGlzLnZpZGVvRWxlbWVudFByb3ZpZGVyLCB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIsIHRoaXMuYWN0aXZlS2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtb3VzZUNvbnRyb2xsZXIgPSBuZXcgTW91c2VDb250cm9sbGVyTG9ja2VkKHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXIsIHRoaXMudmlkZW9FbGVtZW50UHJvdmlkZXIsIHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlciwgdGhpcy5hY3RpdmVLZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBtb3VzZUNvbnRyb2xsZXIucmVnaXN0ZXIoKTtcbiAgICAgICAgcmV0dXJuIG1vdXNlQ29udHJvbGxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmVnaXN0ZXIgdG91Y2ggZXZlbnRzXG4gICAgICogQHBhcmFtIGZha2VNb3VzZVRvdWNoIC0gdGhlIGZha2VkIG1vdXNlIHRvdWNoIGV2ZW50XG4gICAgICovXG4gICAgcmVnaXN0ZXJUb3VjaChmYWtlTW91c2VUb3VjaCkge1xuICAgICAgICBMb2dnZXIuSW5mbygnUmVnaXN0ZXJpbmcgVG91Y2gnKTtcbiAgICAgICAgbGV0IHRvdWNoQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKGZha2VNb3VzZVRvdWNoKSB7XG4gICAgICAgICAgICB0b3VjaENvbnRyb2xsZXIgPSBuZXcgVG91Y2hDb250cm9sbGVyRmFrZSh0aGlzLnRvU3RyZWFtZXJNZXNzYWdlc1Byb3ZpZGVyLCB0aGlzLnZpZGVvRWxlbWVudFByb3ZpZGVyLCB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG91Y2hDb250cm9sbGVyID0gbmV3IFRvdWNoQ29udHJvbGxlcih0aGlzLnRvU3RyZWFtZXJNZXNzYWdlc1Byb3ZpZGVyLCB0aGlzLnZpZGVvRWxlbWVudFByb3ZpZGVyLCB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRvdWNoQ29udHJvbGxlci5yZWdpc3RlcigpO1xuICAgICAgICByZXR1cm4gdG91Y2hDb250cm9sbGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZWdpc3RlcnMgYSBnYW1lcGFkXG4gICAgICovXG4gICAgcmVnaXN0ZXJHYW1lUGFkKCkge1xuICAgICAgICBMb2dnZXIuSW5mbygnUmVnaXN0ZXIgR2FtZSBQYWQnKTtcbiAgICAgICAgY29uc3QgZ2FtZXBhZENvbnRyb2xsZXIgPSBuZXcgR2FtZXBhZENvbnRyb2xsZXIodGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlcik7XG4gICAgICAgIGdhbWVwYWRDb250cm9sbGVyLnJlZ2lzdGVyKCk7XG4gICAgICAgIHJldHVybiBnYW1lcGFkQ29udHJvbGxlcjtcbiAgICB9XG59XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBrZWVwcyB0cmFjayBvZiBjdXJyZW50IGFjdGl2ZSBrZXlzXG4gKi9cbmV4cG9ydCBjbGFzcyBBY3RpdmVLZXlzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVLZXlzID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlS2V5cyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgYXJyYXkgb2YgYWN0aXZlIGtleXNcbiAgICAgKiBAcmV0dXJucyAtIGFuIGFycmF5IG9mIGFjdGl2ZSBrZXlzXG4gICAgICovXG4gICAgZ2V0QWN0aXZlS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlS2V5cztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnB1dENsYXNzZXNGYWN0b3J5LmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKlxuICogTmV3IGJyb3dzZXIgQVBJcyBoYXZlIG1vdmVkIGF3YXkgZnJvbSBLZXlib2FyZEV2ZW50LmtleUNvZGUgdG8gS2V5Ym9hcmRFdmVudC5Db2RlLlxuICogRm9yIGRldGFpbHMgc2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXlDb2RlI2NvbnN0YW50c19mb3Jfa2V5Y29kZV92YWx1ZVxuICogV2Ugc3RpbGwgdXNlIG9sZCBLZXlib2FyZEV2ZW50LmtleUNvZGUgaW50ZWdlcnMgaW4gdGhlIFVFIEMrKyBzaWRlLCBzbyB3ZSBuZWVkIGEgd2F5IHRvIG1hcCB0aGUgbmV3XG4gKiBzdHJpbmctYmFzZWQgS2V5Ym9hcmRFdmVudC5Db2RlIHRvIHRoZSBvbGQgaW50ZWdlcnMuXG4gKi9cbmV4cG9ydCBjb25zdCBDb2RlVG9LZXlDb2RlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgRXNjYXBlOiAyNyxcbiAgICBEaWdpdDA6IDQ4LFxuICAgIERpZ2l0MTogNDksXG4gICAgRGlnaXQyOiA1MCxcbiAgICBEaWdpdDM6IDUxLFxuICAgIERpZ2l0NDogNTIsXG4gICAgRGlnaXQ1OiA1MyxcbiAgICBEaWdpdDY6IDU0LFxuICAgIERpZ2l0NzogNTUsXG4gICAgRGlnaXQ4OiA1NixcbiAgICBEaWdpdDk6IDU3LFxuICAgIE1pbnVzOiAxNzMsXG4gICAgRXF1YWw6IDE4NyxcbiAgICBCYWNrc3BhY2U6IDgsXG4gICAgVGFiOiA5LFxuICAgIEtleVE6IDgxLFxuICAgIEtleVc6IDg3LFxuICAgIEtleUU6IDY5LFxuICAgIEtleVI6IDgyLFxuICAgIEtleVQ6IDg0LFxuICAgIEtleVk6IDg5LFxuICAgIEtleVU6IDg1LFxuICAgIEtleUk6IDczLFxuICAgIEtleU86IDc5LFxuICAgIEtleVA6IDgwLFxuICAgIEJyYWNrZXRMZWZ0OiAyMTksXG4gICAgQnJhY2tldFJpZ2h0OiAyMjEsXG4gICAgRW50ZXI6IDEzLFxuICAgIENvbnRyb2xMZWZ0OiAxNyxcbiAgICBLZXlBOiA2NSxcbiAgICBLZXlTOiA4MyxcbiAgICBLZXlEOiA2OCxcbiAgICBLZXlGOiA3MCxcbiAgICBLZXlHOiA3MSxcbiAgICBLZXlIOiA3MixcbiAgICBLZXlKOiA3NCxcbiAgICBLZXlLOiA3NSxcbiAgICBLZXlMOiA3NixcbiAgICBTZW1pY29sb246IDE4NixcbiAgICBRdW90ZTogMjIyLFxuICAgIEJhY2txdW90ZTogMTkyLFxuICAgIFNoaWZ0TGVmdDogMTYsXG4gICAgQmFja3NsYXNoOiAyMjAsXG4gICAgS2V5WjogOTAsXG4gICAgS2V5WDogODgsXG4gICAgS2V5QzogNjcsXG4gICAgS2V5VjogODYsXG4gICAgS2V5QjogNjYsXG4gICAgS2V5TjogNzgsXG4gICAgS2V5TTogNzcsXG4gICAgQ29tbWE6IDE4OCxcbiAgICBQZXJpb2Q6IDE5MCxcbiAgICBTbGFzaDogMTkxLFxuICAgIFNoaWZ0UmlnaHQ6IDI1MyxcbiAgICBBbHRMZWZ0OiAxOCxcbiAgICBTcGFjZTogMzIsXG4gICAgQ2Fwc0xvY2s6IDIwLFxuICAgIEYxOiAxMTIsXG4gICAgRjI6IDExMyxcbiAgICBGMzogMTE0LFxuICAgIEY0OiAxMTUsXG4gICAgRjU6IDExNixcbiAgICBGNjogMTE3LFxuICAgIEY3OiAxMTgsXG4gICAgRjg6IDExOSxcbiAgICBGOTogMTIwLFxuICAgIEYxMDogMTIxLFxuICAgIEYxMTogMTIyLFxuICAgIEYxMjogMTIzLFxuICAgIFBhdXNlOiAxOSxcbiAgICBTY3JvbGxMb2NrOiAxNDUsXG4gICAgTnVtcGFkRGl2aWRlOiAxMTEsXG4gICAgTnVtcGFkTXVsdGlwbHk6IDEwNixcbiAgICBOdW1wYWRTdWJ0cmFjdDogMTA5LFxuICAgIE51bXBhZEFkZDogMTA3LFxuICAgIE51bXBhZERlY2ltYWw6IDExMCxcbiAgICBOdW1wYWQ5OiAxMDUsXG4gICAgTnVtcGFkODogMTA0LFxuICAgIE51bXBhZDc6IDEwMyxcbiAgICBOdW1wYWQ2OiAxMDIsXG4gICAgTnVtcGFkNTogMTAxLFxuICAgIE51bXBhZDQ6IDEwMCxcbiAgICBOdW1wYWQzOiA5OSxcbiAgICBOdW1wYWQyOiA5OCxcbiAgICBOdW1wYWQxOiA5NyxcbiAgICBOdW1wYWQwOiA5NixcbiAgICBOdW1Mb2NrOiAxNDQsXG4gICAgQ29udHJvbFJpZ2h0OiAyNTQsXG4gICAgQWx0UmlnaHQ6IDI1NSxcbiAgICBIb21lOiAzNixcbiAgICBFbmQ6IDM1LFxuICAgIEFycm93VXA6IDM4LFxuICAgIEFycm93TGVmdDogMzcsXG4gICAgQXJyb3dSaWdodDogMzksXG4gICAgQXJyb3dEb3duOiA0MCxcbiAgICBQYWdlVXA6IDMzLFxuICAgIFBhZ2VEb3duOiAzNCxcbiAgICBJbnNlcnQ6IDQ1LFxuICAgIERlbGV0ZTogNDYsXG4gICAgQ29udGV4dE1lbnU6IDkzXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUtleUNvZGVzLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBTcGVjaWFsS2V5Q29kZXMgfSBmcm9tICcuL1NwZWNpYWxLZXlDb2Rlcyc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG5pbXBvcnQgeyBGbGFncyB9IGZyb20gJy4uL0NvbmZpZy9Db25maWcnO1xuaW1wb3J0IHsgQ29kZVRvS2V5Q29kZSB9IGZyb20gJy4vS2V5Q29kZXMnO1xuLyoqXG4gKiBIYW5kbGVzIHRoZSBLZXlib2FyZCBJbnB1dHMgZm9yIHRoZSBkb2N1bWVudFxuICovXG5leHBvcnQgY2xhc3MgS2V5Ym9hcmRDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJlYW1NZXNzYWdlQ29udHJvbGxlciwgY29uZmlnLCBhY3RpdmVLZXlzKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIgPSBzdHJlYW1NZXNzYWdlQ29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuYWN0aXZlS2V5cyA9IGFjdGl2ZUtleXM7XG4gICAgICAgIHRoaXMub25LZXlEb3duTGlzdGVuZXIgPSB0aGlzLmhhbmRsZU9uS2V5RG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uS2V5VXBMaXN0ZW5lciA9IHRoaXMuaGFuZGxlT25LZXlVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uS2V5UHJlc3NMaXN0ZW5lciA9IHRoaXMuaGFuZGxlT25LZXlQcmVzcy5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICByZWdpc3RlcigpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25LZXlEb3duTGlzdGVuZXIpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25LZXlVcExpc3RlbmVyKTtcbiAgICAgICAgLy9UaGlzIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYXMgYXQgSnVuIDEzIDIwMjFcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCB0aGlzLm9uS2V5UHJlc3NMaXN0ZW5lcik7XG4gICAgfVxuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bkxpc3RlbmVyKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uS2V5VXBMaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgdGhpcy5vbktleVByZXNzTGlzdGVuZXIpO1xuICAgIH1cbiAgICBoYW5kbGVPbktleURvd24oa2V5Ym9hcmRFdmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSB0aGlzLmdldEtleWNvZGUoa2V5Ym9hcmRFdmVudCk7XG4gICAgICAgIGlmICgha2V5Q29kZSB8fCBrZXlDb2RlID09PSAyMjkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b1N0cmVhbWVySGFuZGxlcnMgPSB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycztcbiAgICAgICAgKF9hID0gdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnS2V5RG93bicpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoW3RoaXMuZ2V0S2V5Y29kZShrZXlib2FyZEV2ZW50KSwga2V5Ym9hcmRFdmVudC5yZXBlYXQgPyAxIDogMF0pO1xuICAgICAgICBjb25zdCBhY3RpdmVLZXlzID0gdGhpcy5hY3RpdmVLZXlzLmdldEFjdGl2ZUtleXMoKTtcbiAgICAgICAgYWN0aXZlS2V5cy5wdXNoKGtleUNvZGUpO1xuICAgICAgICAvLyBCYWNrc3BhY2UgaXMgbm90IGNvbnNpZGVyZWQgYSBrZXlwcmVzcyBpbiBKYXZhU2NyaXB0IGJ1dCB3ZSBuZWVkIGl0XG4gICAgICAgIC8vIHRvIGJlIHNvIGNoYXJhY3RlcnMgbWF5IGJlIGRlbGV0ZWQgaW4gYSBVRSB0ZXh0IGVudHJ5IGZpZWxkLlxuICAgICAgICAvLyBzaW5jZSBrZXlwcmVzcyBpcyBkZXByZWNhdGVkIHdlIHJlYWxseSBzaG91bGQgYmUgc2VuZGluZyBhbGwga2V5cyB0byBrZXlwcmVzc1xuICAgICAgICAvLyBvciB3ZSBjaGFuZ2UgZXZlcnl0aGluZyB0byBoYW5kbGUgdGhlIGRlcHJlY2F0aW9uIG9mIHRoZXNlIHBhcnRzXG4gICAgICAgIGlmIChrZXlDb2RlID09PSBTcGVjaWFsS2V5Q29kZXMuYmFja1NwYWNlKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU9uS2V5UHJlc3MobmV3IEtleWJvYXJkRXZlbnQoJ2tleXByZXNzJywge1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlOiBTcGVjaWFsS2V5Q29kZXMuYmFja1NwYWNlLFxuICAgICAgICAgICAgICAgIGtleUNvZGU6IFNwZWNpYWxLZXlDb2Rlcy5iYWNrU3BhY2VcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5TdXBwcmVzc0Jyb3dzZXJLZXlzKSAmJiB0aGlzLmlzS2V5Q29kZUJyb3dzZXJLZXkoa2V5Q29kZSkpIHtcbiAgICAgICAgICAgIGtleWJvYXJkRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVPbktleVVwKGtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBrZXlDb2RlID0gdGhpcy5nZXRLZXljb2RlKGtleWJvYXJkRXZlbnQpO1xuICAgICAgICBpZiAoIWtleUNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b1N0cmVhbWVySGFuZGxlcnMgPSB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycztcbiAgICAgICAgKF9hID0gdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnS2V5VXAnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKFtrZXlDb2RlXSk7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLlN1cHByZXNzQnJvd3NlcktleXMpICYmIHRoaXMuaXNLZXlDb2RlQnJvd3NlcktleShrZXlDb2RlKSkge1xuICAgICAgICAgICAga2V5Ym9hcmRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZU9uS2V5UHJlc3Moa2V5Ym9hcmRFdmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSB0aGlzLmdldEtleWNvZGUoa2V5Ym9hcmRFdmVudCk7XG4gICAgICAgIGlmICgha2V5Q29kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvU3RyZWFtZXJIYW5kbGVycyA9IHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzO1xuICAgICAgICAoX2EgPSB0b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdLZXlQcmVzcycpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoW2tleUNvZGVdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgS2V5Y29kZSBvZiB0aGUgS2V5IHByZXNzZWRcbiAgICAgKiBAcGFyYW0ga2V5Ym9hcmRFdmVudCAtIEtleSBib2FyZCBFdmVudFxuICAgICAqIEByZXR1cm5zIC0gdGhlIGtleSBjb2RlIG9mIHRoZSBLZXlcbiAgICAgKi9cbiAgICBnZXRLZXljb2RlKGtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBrZXlDb2RlIHByb3BlcnR5IGJlY2F1c2UgYnJvd3NlciBBUEkgaXMgZGVwcmVjYXRlZCB0aGVuIHVzZSBLZXlib2FyZEV2ZW50LmNvZGUgaW5zdGVhZC5cbiAgICAgICAgLy8gU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXlDb2RlI2NvbnN0YW50c19mb3Jfa2V5Y29kZV92YWx1ZVxuICAgICAgICBpZiAoISgna2V5Q29kZScgaW4ga2V5Ym9hcmRFdmVudCkpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgdHlwZSBhc3NlcnRpb24gaGVyZSBpcyByZXF1aXJlZCBiZWNhdXNlIGlmICdrZXlDb2RlJyBkb2VzbnQgZXhpc3QgaW4ga2V5Ym9hcmRFdmVudCB0aGVuXG4gICAgICAgICAgICAvLyBpdCBjYW5ub3QgYmUgYSBLZXlib2FyZEV2ZW50IGFuZCBzbyBpdCBnZXRzIG5hcnJvd2VkIHRvICduZXZlcidcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ga2V5Ym9hcmRFdmVudDtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgS2V5Ym9hcmRFdmVudC5jb2RlIHN0cmluZyBpbnRvIGludGVnZXItYmFzZWQga2V5IGNvZGUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnMuXG4gICAgICAgICAgICBpZiAoZXZlbnQuY29kZSBpbiBDb2RlVG9LZXlDb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvZGVUb0tleUNvZGVbZXZlbnQuY29kZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuV2FybmluZyhgS2V5Ym9hcmQgY29kZSBvZiAke2V2ZW50LmNvZGV9IGlzIG5vdCBzdXBwb3J0ZWQgaW4gb3VyIG1hcHBpbmcsIGlnbm9yaW5nIHRoaXMga2V5LmApO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIG1hZGUgaXQgaGVyZSBLZXlib2FyZEV2ZW50LmtleUNvZGUgaXMgc3RpbGwgc3VwcG9ydGVkIHNvIHdlIGNhbiBzYWZlbHkgdXNlIGl0LlxuICAgICAgICBpZiAoa2V5Ym9hcmRFdmVudC5rZXlDb2RlID09PSBTcGVjaWFsS2V5Q29kZXMuc2hpZnQgJiYga2V5Ym9hcmRFdmVudC5jb2RlID09PSAnU2hpZnRSaWdodCcpIHtcbiAgICAgICAgICAgIHJldHVybiBTcGVjaWFsS2V5Q29kZXMucmlnaHRTaGlmdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXlib2FyZEV2ZW50LmtleUNvZGUgPT09IFNwZWNpYWxLZXlDb2Rlcy5jb250cm9sICYmXG4gICAgICAgICAgICBrZXlib2FyZEV2ZW50LmNvZGUgPT09ICdDb250cm9sUmlnaHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gU3BlY2lhbEtleUNvZGVzLnJpZ2h0Q29udHJvbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXlib2FyZEV2ZW50LmtleUNvZGUgPT09IFNwZWNpYWxLZXlDb2Rlcy5hbHQgJiYga2V5Ym9hcmRFdmVudC5jb2RlID09PSAnQWx0UmlnaHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gU3BlY2lhbEtleUNvZGVzLnJpZ2h0QWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGtleWJvYXJkRXZlbnQua2V5Q29kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCcm93c2VyIGtleXMgZG8gbm90IGhhdmUgYSBjaGFyQ29kZSBzbyB3ZSBvbmx5IG5lZWQgdG8gdGVzdCBrZXlDb2RlLlxuICAgICAqIEBwYXJhbSBrZXlDb2RlIC0gdGhlIGJyb3dzZXIga2V5Y29kZSBudW1iZXJcbiAgICAgKi9cbiAgICBpc0tleUNvZGVCcm93c2VyS2V5KGtleUNvZGUpIHtcbiAgICAgICAgLy8gRnVuY3Rpb24ga2V5cyBvciB0YWIga2V5IGFyZSBjb25zaWRlcmVkIFwiYnJvd3NlciBrZXlzXCIgdGhhdCB3ZSBtYXkgd2lzaCB0byBzdXBwcmVzcyBieSBwcmV2ZW50aW5nIHRoZW0gYmVpbmcgcHJvY2VzcyBieSBicm93c2VyLlxuICAgICAgICByZXR1cm4gKGtleUNvZGUgPj0gMTEyICYmIGtleUNvZGUgPD0gMTIzKSB8fCBrZXlDb2RlID09PSA5O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUtleWJvYXJkQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBNb3VzZSBCdXR0b24gRGF0YVxuICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L2J1dHRvbn1cbiAqL1xuZXhwb3J0IGNsYXNzIE1vdXNlQnV0dG9uIHtcbn1cbk1vdXNlQnV0dG9uLm1haW5CdXR0b24gPSAwOyAvLyBMZWZ0IGJ1dHRvbi5cbk1vdXNlQnV0dG9uLmF1eGlsaWFyeUJ1dHRvbiA9IDE7IC8vIFdoZWVsIGJ1dHRvbi5cbk1vdXNlQnV0dG9uLnNlY29uZGFyeUJ1dHRvbiA9IDI7IC8vIFJpZ2h0IGJ1dHRvbi5cbk1vdXNlQnV0dG9uLmZvdXJ0aEJ1dHRvbiA9IDM7IC8vIEJyb3dzZXIgQmFjayBidXR0b24uXG5Nb3VzZUJ1dHRvbi5maWZ0aEJ1dHRvbiA9IDQ7IC8vIEJyb3dzZXIgRm9yd2FyZCBidXR0b24uXG4vKipcbiAqIE1vdXNlIEJ1dHRvbiBNYXNrIERhdGFcbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9idXR0b25zfVxuICovXG5leHBvcnQgY2xhc3MgTW91c2VCdXR0b25zTWFzayB7XG59XG5Nb3VzZUJ1dHRvbnNNYXNrLnByaW1hcnlCdXR0b24gPSAxOyAvLyBMZWZ0IGJ1dHRvbi5cbk1vdXNlQnV0dG9uc01hc2suc2Vjb25kYXJ5QnV0dG9uID0gMjsgLy8gUmlnaHQgYnV0dG9uLlxuTW91c2VCdXR0b25zTWFzay5hdXhpbGlhcnlCdXR0b24gPSA0OyAvLyBXaGVlbCBidXR0b24uXG5Nb3VzZUJ1dHRvbnNNYXNrLmZvdXJ0aEJ1dHRvbiA9IDg7IC8vIEJyb3dzZXIgQmFjayBidXR0b24uXG5Nb3VzZUJ1dHRvbnNNYXNrLmZpZnRoQnV0dG9uID0gMTY7IC8vIEJyb3dzZXIgRm9yd2FyZCBidXR0b24uXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Nb3VzZUJ1dHRvbnMuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IE1vdXNlQnV0dG9uc01hc2ssIE1vdXNlQnV0dG9uIH0gZnJvbSAnLi9Nb3VzZUJ1dHRvbnMnO1xuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgbW91c2UgY29udHJvbGxlcnMuIFNpbmNlIHRoZXJlIGlzIGEgYnVuY2ggb2Ygc2hhcmVkIGJlaGF2aW91ciBiZXR3ZWVuIGxvY2tlZCBhbmRcbiAqIGhvdmVyIG1vdXNlIGNvbnRyb2xsZXJzIHRoaXMgaXMgd2hlcmUgdGhhdCBzaGFyZWQgYmVoYXZpb3VyIGxpdmVzLlxuICovXG5leHBvcnQgY2xhc3MgTW91c2VDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJlYW1NZXNzYWdlQ29udHJvbGxlciwgdmlkZW9QbGF5ZXIsIGNvb3JkaW5hdGVDb252ZXJ0ZXIsIGFjdGl2ZUtleXMpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlciA9IHN0cmVhbU1lc3NhZ2VDb250cm9sbGVyO1xuICAgICAgICB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIgPSBjb29yZGluYXRlQ29udmVydGVyO1xuICAgICAgICB0aGlzLnZpZGVvUGxheWVyID0gdmlkZW9QbGF5ZXI7XG4gICAgICAgIHRoaXMuYWN0aXZlS2V5cyA9IGFjdGl2ZUtleXM7XG4gICAgICAgIHRoaXMub25FbnRlckxpc3RlbmVyID0gdGhpcy5vbk1vdXNlRW50ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkxlYXZlTGlzdGVuZXIgPSB0aGlzLm9uTW91c2VMZWF2ZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICByZWdpc3RlcigpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlck1vdXNlRW50ZXJBbmRMZWF2ZUV2ZW50cygpO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXJNb3VzZUVudGVyQW5kTGVhdmVFdmVudHMoKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJNb3VzZUVudGVyQW5kTGVhdmVFdmVudHMoKSB7XG4gICAgICAgIGNvbnN0IHZpZGVvRWxlbWVudFBhcmVudCA9IHRoaXMudmlkZW9QbGF5ZXIuZ2V0VmlkZW9QYXJlbnRFbGVtZW50KCk7XG4gICAgICAgIHZpZGVvRWxlbWVudFBhcmVudCA9PT0gbnVsbCB8fCB2aWRlb0VsZW1lbnRQYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZGVvRWxlbWVudFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbkVudGVyTGlzdGVuZXIpO1xuICAgICAgICB2aWRlb0VsZW1lbnRQYXJlbnQgPT09IG51bGwgfHwgdmlkZW9FbGVtZW50UGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25MZWF2ZUxpc3RlbmVyKTtcbiAgICB9XG4gICAgdW5yZWdpc3Rlck1vdXNlRW50ZXJBbmRMZWF2ZUV2ZW50cygpIHtcbiAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50UGFyZW50ID0gdGhpcy52aWRlb1BsYXllci5nZXRWaWRlb1BhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgdmlkZW9FbGVtZW50UGFyZW50ID09PSBudWxsIHx8IHZpZGVvRWxlbWVudFBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uRW50ZXJMaXN0ZW5lcik7XG4gICAgICAgIHZpZGVvRWxlbWVudFBhcmVudCA9PT0gbnVsbCB8fCB2aWRlb0VsZW1lbnRQYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZGVvRWxlbWVudFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbkxlYXZlTGlzdGVuZXIpO1xuICAgIH1cbiAgICBvbk1vdXNlRW50ZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlRW50ZXInKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKCk7XG4gICAgICAgIHRoaXMucHJlc3NNb3VzZUJ1dHRvbnMoZXZlbnQuYnV0dG9ucywgZXZlbnQueCwgZXZlbnQueSk7XG4gICAgfVxuICAgIG9uTW91c2VMZWF2ZShldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VMZWF2ZScpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoKTtcbiAgICAgICAgdGhpcy5yZWxlYXNlTW91c2VCdXR0b25zKGV2ZW50LmJ1dHRvbnMsIGV2ZW50LngsIGV2ZW50LnkpO1xuICAgIH1cbiAgICByZWxlYXNlTW91c2VCdXR0b25zKGJ1dHRvbnMsIFgsIFkpIHtcbiAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoWCwgWSk7XG4gICAgICAgIGlmIChidXR0b25zICYgTW91c2VCdXR0b25zTWFzay5wcmltYXJ5QnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRNb3VzZVVwKE1vdXNlQnV0dG9uLm1haW5CdXR0b24sIGNvb3JkLngsIGNvb3JkLnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25zICYgTW91c2VCdXR0b25zTWFzay5zZWNvbmRhcnlCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1vdXNlVXAoTW91c2VCdXR0b24uc2Vjb25kYXJ5QnV0dG9uLCBjb29yZC54LCBjb29yZC55KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9ucyAmIE1vdXNlQnV0dG9uc01hc2suYXV4aWxpYXJ5QnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRNb3VzZVVwKE1vdXNlQnV0dG9uLmF1eGlsaWFyeUJ1dHRvbiwgY29vcmQueCwgY29vcmQueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbnMgJiBNb3VzZUJ1dHRvbnNNYXNrLmZvdXJ0aEJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5zZW5kTW91c2VVcChNb3VzZUJ1dHRvbi5mb3VydGhCdXR0b24sIGNvb3JkLngsIGNvb3JkLnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25zICYgTW91c2VCdXR0b25zTWFzay5maWZ0aEJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5zZW5kTW91c2VVcChNb3VzZUJ1dHRvbi5maWZ0aEJ1dHRvbiwgY29vcmQueCwgY29vcmQueSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJlc3NNb3VzZUJ1dHRvbnMoYnV0dG9ucywgWCwgWSkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb29yZCA9IHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlci50cmFuc2xhdGVVbnNpZ25lZChYLCBZKTtcbiAgICAgICAgaWYgKGJ1dHRvbnMgJiBNb3VzZUJ1dHRvbnNNYXNrLnByaW1hcnlCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1vdXNlRG93bihNb3VzZUJ1dHRvbi5tYWluQnV0dG9uLCBjb29yZC54LCBjb29yZC55KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9ucyAmIE1vdXNlQnV0dG9uc01hc2suc2Vjb25kYXJ5QnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRNb3VzZURvd24oTW91c2VCdXR0b24uc2Vjb25kYXJ5QnV0dG9uLCBjb29yZC54LCBjb29yZC55KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9ucyAmIE1vdXNlQnV0dG9uc01hc2suYXV4aWxpYXJ5QnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRNb3VzZURvd24oTW91c2VCdXR0b24uYXV4aWxpYXJ5QnV0dG9uLCBjb29yZC54LCBjb29yZC55KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9ucyAmIE1vdXNlQnV0dG9uc01hc2suZm91cnRoQnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRNb3VzZURvd24oTW91c2VCdXR0b24uZm91cnRoQnV0dG9uLCBjb29yZC54LCBjb29yZC55KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9ucyAmIE1vdXNlQnV0dG9uc01hc2suZmlmdGhCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1vdXNlRG93bihNb3VzZUJ1dHRvbi5maWZ0aEJ1dHRvbiwgY29vcmQueCwgY29vcmQueSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZE1vdXNlRG93bihidXR0b24sIFgsIFkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlRG93bicpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoW2J1dHRvbiwgWCwgWV0pO1xuICAgIH1cbiAgICBzZW5kTW91c2VVcChidXR0b24sIFgsIFkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb29yZCA9IHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlci50cmFuc2xhdGVVbnNpZ25lZChYLCBZKTtcbiAgICAgICAgKF9hID0gdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdNb3VzZVVwJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYShbYnV0dG9uLCBjb29yZC54LCBjb29yZC55XSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TW91c2VDb250cm9sbGVyLmpzLm1hcCIsImltcG9ydCB7IE1vdXNlQ29udHJvbGxlciB9IGZyb20gJy4vTW91c2VDb250cm9sbGVyJztcbi8qKlxuICogQSBtb3VzZSBjb250cm9sbGVyIHRoYXQgYWxsb3dzIHRoZSBtb3VzZSB0byBmcmVlbHkgZmxvYXQgb3ZlciB0aGUgdmlkZW8gZG9jdW1lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBNb3VzZUNvbnRyb2xsZXJIb3ZlcmluZyBleHRlbmRzIE1vdXNlQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3Ioc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIsIHZpZGVvUGxheWVyLCBjb29yZGluYXRlQ29udmVydGVyLCBhY3RpdmVLZXlzKSB7XG4gICAgICAgIHN1cGVyKHN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLCB2aWRlb1BsYXllciwgY29vcmRpbmF0ZUNvbnZlcnRlciwgYWN0aXZlS2V5cyk7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50ID0gdmlkZW9QbGF5ZXIuZ2V0VmlkZW9QYXJlbnRFbGVtZW50KCk7XG4gICAgICAgIHRoaXMub25Nb3VzZVVwTGlzdGVuZXIgPSB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VEb3duTGlzdGVuZXIgPSB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZURibENsaWNrTGlzdGVuZXIgPSB0aGlzLm9uTW91c2VEYmxDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VXaGVlbExpc3RlbmVyID0gdGhpcy5vbk1vdXNlV2hlZWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZUxpc3RlbmVyID0gdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ29udGV4dE1lbnVMaXN0ZW5lciA9IHRoaXMub25Db250ZXh0TWVudS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICByZWdpc3RlcigpIHtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXIoKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZUxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bkxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMub25Db250ZXh0TWVudUxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uTW91c2VXaGVlbExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzLm9uTW91c2VEYmxDbGlja0xpc3RlbmVyKTtcbiAgICB9XG4gICAgdW5yZWdpc3RlcigpIHtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZUxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bkxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMub25Db250ZXh0TWVudUxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uTW91c2VXaGVlbExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzLm9uTW91c2VEYmxDbGlja0xpc3RlbmVyKTtcbiAgICAgICAgc3VwZXIudW5yZWdpc3RlcigpO1xuICAgIH1cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb29yZCA9IHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlci50cmFuc2xhdGVVbnNpZ25lZChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdNb3VzZURvd24nKShbZXZlbnQuYnV0dG9uLCBjb29yZC54LCBjb29yZC55XSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIG9uTW91c2VVcChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb29yZCA9IHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlci50cmFuc2xhdGVVbnNpZ25lZChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdNb3VzZVVwJykoW2V2ZW50LmJ1dHRvbiwgY29vcmQueCwgY29vcmQueV0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBvbkNvbnRleHRNZW51KGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvb3JkID0gdGhpcy5jb29yZGluYXRlQ29udmVydGVyLnRyYW5zbGF0ZVVuc2lnbmVkKGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlci50cmFuc2xhdGVTaWduZWQoZXZlbnQubW92ZW1lbnRYLCBldmVudC5tb3ZlbWVudFkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlTW92ZScpKFtcbiAgICAgICAgICAgIGNvb3JkLngsXG4gICAgICAgICAgICBjb29yZC55LFxuICAgICAgICAgICAgZGVsdGEueCxcbiAgICAgICAgICAgIGRlbHRhLnlcbiAgICAgICAgXSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIG9uTW91c2VXaGVlbChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb29yZCA9IHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlci50cmFuc2xhdGVVbnNpZ25lZChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdNb3VzZVdoZWVsJykoW1xuICAgICAgICAgICAgZXZlbnQud2hlZWxEZWx0YSxcbiAgICAgICAgICAgIGNvb3JkLngsXG4gICAgICAgICAgICBjb29yZC55XG4gICAgICAgIF0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBvbk1vdXNlRGJsQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VEb3VibGUnKShbZXZlbnQuYnV0dG9uLCBjb29yZC54LCBjb29yZC55XSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TW91c2VDb250cm9sbGVySG92ZXJpbmcuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42JztcbmltcG9ydCB7IE1vdXNlQ29udHJvbGxlciB9IGZyb20gJy4vTW91c2VDb250cm9sbGVyJztcbi8qKlxuICogQSBtb3VzZSBjb250cm9sbGVyIHRoYXQgbG9ja3MgdGhlIG1vdXNlIHRvIHRoZSB2aWRlbyBkb2N1bWVudCBhbmQgcHJldmVudHMgaXQgZnJvbSBsZWF2aW5nIHRoZSB3aW5kb3dcbiAqL1xuZXhwb3J0IGNsYXNzIE1vdXNlQ29udHJvbGxlckxvY2tlZCBleHRlbmRzIE1vdXNlQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3Ioc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIsIHZpZGVvUGxheWVyLCBjb29yZGluYXRlQ29udmVydGVyLCBhY3RpdmVLZXlzKSB7XG4gICAgICAgIHN1cGVyKHN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLCB2aWRlb1BsYXllciwgY29vcmRpbmF0ZUNvbnZlcnRlciwgYWN0aXZlS2V5cyk7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50ID0gdmlkZW9QbGF5ZXIuZ2V0VmlkZW9QYXJlbnRFbGVtZW50KCk7XG4gICAgICAgIHRoaXMueCA9IHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy55ID0gdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IC8gMjtcbiAgICAgICAgdGhpcy5ub3JtYWxpemVkQ29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICB0aGlzLm9uUmVxdWVzdExvY2tMaXN0ZW5lciA9IHRoaXMub25SZXF1ZXN0TG9jay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTG9ja1N0YXRlQ2hhbmdlTGlzdGVuZXIgPSB0aGlzLm9uTG9ja1N0YXRlQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZVVwTGlzdGVuZXIgPSB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VEb3duTGlzdGVuZXIgPSB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZURibENsaWNrTGlzdGVuZXIgPSB0aGlzLm9uTW91c2VEYmxDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VXaGVlbExpc3RlbmVyID0gdGhpcy5vbk1vdXNlV2hlZWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZUxpc3RlbmVyID0gdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICByZWdpc3RlcigpIHtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXIoKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVxdWVzdFBvaW50ZXJMb2NrID1cbiAgICAgICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlcXVlc3RQb2ludGVyTG9jayB8fCB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5tb3pSZXF1ZXN0UG9pbnRlckxvY2s7XG4gICAgICAgIGRvY3VtZW50LmV4aXRQb2ludGVyTG9jayA9IGRvY3VtZW50LmV4aXRQb2ludGVyTG9jayB8fCBkb2N1bWVudC5tb3pFeGl0UG9pbnRlckxvY2s7XG4gICAgICAgIGlmICh0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5yZXF1ZXN0UG9pbnRlckxvY2spIHtcbiAgICAgICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vblJlcXVlc3RMb2NrTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsb2NrY2hhbmdlJywgdGhpcy5vbkxvY2tTdGF0ZUNoYW5nZUxpc3RlbmVyKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW96cG9pbnRlcmxvY2tjaGFuZ2UnLCB0aGlzLm9uTG9ja1N0YXRlQ2hhbmdlTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXBMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbk1vdXNlV2hlZWxMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5vbk1vdXNlRGJsQ2xpY2tMaXN0ZW5lcik7XG4gICAgfVxuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ZXJMb2NrRWxlbWVudCA9IGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCB8fCBkb2N1bWVudC5tb3pQb2ludGVyTG9ja0VsZW1lbnQ7XG4gICAgICAgIGlmIChkb2N1bWVudC5leGl0UG9pbnRlckxvY2sgJiYgcG9pbnRlckxvY2tFbGVtZW50ID09PSB0aGlzLnZpZGVvRWxlbWVudFBhcmVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuZXhpdFBvaW50ZXJMb2NrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uUmVxdWVzdExvY2tMaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsb2NrY2hhbmdlJywgdGhpcy5vbkxvY2tTdGF0ZUNoYW5nZUxpc3RlbmVyKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW96cG9pbnRlcmxvY2tjaGFuZ2UnLCB0aGlzLm9uTG9ja1N0YXRlQ2hhbmdlTGlzdGVuZXIpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXBMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbk1vdXNlV2hlZWxMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5vbk1vdXNlRGJsQ2xpY2tMaXN0ZW5lcik7XG4gICAgICAgIHN1cGVyLnVucmVnaXN0ZXIoKTtcbiAgICB9XG4gICAgb25SZXF1ZXN0TG9jaygpIHtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVxdWVzdFBvaW50ZXJMb2NrKCk7XG4gICAgfVxuICAgIG9uTG9ja1N0YXRlQ2hhbmdlKCkge1xuICAgICAgICBjb25zdCBwb2ludGVyTG9ja0VsZW1lbnQgPSBkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQgfHwgZG9jdW1lbnQubW96UG9pbnRlckxvY2tFbGVtZW50O1xuICAgICAgICBpZiAocG9pbnRlckxvY2tFbGVtZW50ID09PSB0aGlzLnZpZGVvRWxlbWVudFBhcmVudCkge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ1BvaW50ZXIgbG9ja2VkJyk7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ1RoZSBwb2ludGVyIGxvY2sgc3RhdHVzIGlzIG5vdyB1bmxvY2tlZCcpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIC8vIElmIG1vdXNlIGxvc2VzIGZvY3VzLCBzZW5kIGEga2V5IHVwIGZvciBhbGwgb2YgdGhlIGN1cnJlbnRseSBoZWxkLWRvd24ga2V5c1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgYXMgd2hlbiB0aGUgbW91c2UgbG9zZXMgZm9jdXMsIHRoZSB3aW5kb3dzIHN0b3BzIGxpc3RlbmluZyBmb3IgZXZlbnRzIGFuZCBhcyBzdWNoXG4gICAgICAgICAgICAvLyB0aGUga2V5dXAgbGlzdGVuZXIgd29uJ3QgZ2V0IGZpcmVkXG4gICAgICAgICAgICBjb25zdCBhY3RpdmVLZXlzID0gdGhpcy5hY3RpdmVLZXlzLmdldEFjdGl2ZUtleXMoKTtcbiAgICAgICAgICAgIGFjdGl2ZUtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdLZXlVcCcpKFtrZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VEb3duJykoW1xuICAgICAgICAgICAgZXZlbnQuYnV0dG9uLFxuICAgICAgICAgICAgLy8gV2UgdXNlIHRoZSBzdG9yZSB2YWx1ZSBvZiB0aGlzLmNvb3JkIGFzIG9wcG9zZWQgdG8gdGhlIG1vdXNlRXZlbnQueC95IGFzIHRoZSBtb3VzZUV2ZW50IGxvY2F0aW9uXG4gICAgICAgICAgICAvLyB1c2VzIHRoZSBzeXN0ZW0gY3Vyc29yIGxvY2F0aW9uIHdoaWNoIGhhc24ndCBtb3ZlZFxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkQ29vcmQueCxcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZENvb3JkLnlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIG9uTW91c2VVcChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlVXAnKShbXG4gICAgICAgICAgICBldmVudC5idXR0b24sXG4gICAgICAgICAgICAvLyBXZSB1c2UgdGhlIHN0b3JlIHZhbHVlIG9mIHRoaXMuY29vcmQgYXMgb3Bwb3NlZCB0byB0aGUgbW91c2VFdmVudC54L3kgYXMgdGhlIG1vdXNlRXZlbnQgbG9jYXRpb25cbiAgICAgICAgICAgIC8vIHVzZXMgdGhlIHN5c3RlbSBjdXJzb3IgbG9jYXRpb24gd2hpY2ggaGFzbid0IG1vdmVkXG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWRDb29yZC54LFxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkQ29vcmQueVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3R5bGVXaWR0aCA9IHRoaXMudmlkZW9QbGF5ZXIuZ2V0VmlkZW9QYXJlbnRFbGVtZW50KCkuY2xpZW50V2lkdGg7XG4gICAgICAgIGNvbnN0IHN0eWxlSGVpZ2h0ID0gdGhpcy52aWRlb1BsYXllci5nZXRWaWRlb1BhcmVudEVsZW1lbnQoKS5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHRoaXMueCArPSBldmVudC5tb3ZlbWVudFg7XG4gICAgICAgIHRoaXMueSArPSBldmVudC5tb3ZlbWVudFk7XG4gICAgICAgIHdoaWxlICh0aGlzLnggPiBzdHlsZVdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLnggLT0gc3R5bGVXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy55ID4gc3R5bGVIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMueSAtPSBzdHlsZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy54IDwgMCkge1xuICAgICAgICAgICAgdGhpcy54ICs9IHN0eWxlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMueSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMueSArPSBzdHlsZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vcm1hbGl6ZWRDb29yZCA9IHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlci50cmFuc2xhdGVVbnNpZ25lZCh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5jb29yZGluYXRlQ29udmVydGVyLnRyYW5zbGF0ZVNpZ25lZChldmVudC5tb3ZlbWVudFgsIGV2ZW50Lm1vdmVtZW50WSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VNb3ZlJykoW1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkQ29vcmQueCxcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZENvb3JkLnksXG4gICAgICAgICAgICBkZWx0YS54LFxuICAgICAgICAgICAgZGVsdGEueVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgb25Nb3VzZVdoZWVsKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VXaGVlbCcpKFtcbiAgICAgICAgICAgIGV2ZW50LndoZWVsRGVsdGEsXG4gICAgICAgICAgICAvLyBXZSB1c2UgdGhlIHN0b3JlIHZhbHVlIG9mIHRoaXMuY29vcmQgYXMgb3Bwb3NlZCB0byB0aGUgbW91c2VFdmVudC54L3kgYXMgdGhlIG1vdXNlRXZlbnQgbG9jYXRpb25cbiAgICAgICAgICAgIC8vIHVzZXMgdGhlIHN5c3RlbSBjdXJzb3IgbG9jYXRpb24gd2hpY2ggaGFzbid0IG1vdmVkXG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWRDb29yZC54LFxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkQ29vcmQueVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgb25Nb3VzZURibENsaWNrKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VEb3VibGUnKShbXG4gICAgICAgICAgICBldmVudC5idXR0b24sXG4gICAgICAgICAgICAvLyBXZSB1c2UgdGhlIHN0b3JlIHZhbHVlIG9mIHRoaXMuY29vcmQgYXMgb3Bwb3NlZCB0byB0aGUgbW91c2VFdmVudC54L3kgYXMgdGhlIG1vdXNlRXZlbnQgbG9jYXRpb25cbiAgICAgICAgICAgIC8vIHVzZXMgdGhlIHN5c3RlbSBjdXJzb3IgbG9jYXRpb24gd2hpY2ggaGFzbid0IG1vdmVkXG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWRDb29yZC54LFxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkQ29vcmQueVxuICAgICAgICBdKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Nb3VzZUNvbnRyb2xsZXJMb2NrZWQuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogUmVnaXN0ZXJzIHRoZSBTcGVjaWFsIEtleSBjb2Rlc1xuICogIE11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGggSmF2YVNjcmlwdEtleUNvZGVUb0ZLZXkgQysrIGFycmF5LlxuICogVGhlIGluZGV4IG9mIHRoZSBlbnRyeSBpbiB0aGUgYXJyYXkgaXMgdGhlIHNwZWNpYWwga2V5IGNvZGUgZ2l2ZW4gYmVsb3cuXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGVjaWFsS2V5Q29kZXMge1xufVxuU3BlY2lhbEtleUNvZGVzLmJhY2tTcGFjZSA9IDg7XG5TcGVjaWFsS2V5Q29kZXMuc2hpZnQgPSAxNjtcblNwZWNpYWxLZXlDb2Rlcy5jb250cm9sID0gMTc7XG5TcGVjaWFsS2V5Q29kZXMuYWx0ID0gMTg7XG5TcGVjaWFsS2V5Q29kZXMucmlnaHRTaGlmdCA9IDI1MztcblNwZWNpYWxLZXlDb2Rlcy5yaWdodENvbnRyb2wgPSAyNTQ7XG5TcGVjaWFsS2V5Q29kZXMucmlnaHRBbHQgPSAyNTU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TcGVjaWFsS2V5Q29kZXMuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42Jztcbi8qKlxuICogVGhlIGJhc2ljIHRvdWNoIGNvbnRyb2xsZXIgdGhhdCBoYW5kbGVzIHRoZSB0b3VjaCBldmVudHMgb24gdGhlIGRvY3VtZW50LlxuICovXG5leHBvcnQgY2xhc3MgVG91Y2hDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJlYW1NZXNzYWdlQ29udHJvbGxlciwgdmlkZW9QbGF5ZXIsIGNvb3JkaW5hdGVDb252ZXJ0ZXIpIHtcbiAgICAgICAgdGhpcy5maW5nZXJzID0gWzksIDgsIDcsIDYsIDUsIDQsIDMsIDIsIDEsIDBdO1xuICAgICAgICB0aGlzLmZpbmdlcklkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tYXhCeXRlVmFsdWUgPSAyNTU7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIgPSBzdHJlYW1NZXNzYWdlQ29udHJvbGxlcjtcbiAgICAgICAgdGhpcy52aWRlb1BsYXllciA9IHZpZGVvUGxheWVyO1xuICAgICAgICB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIgPSBjb29yZGluYXRlQ29udmVydGVyO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudCA9IHZpZGVvUGxheWVyLmdldFZpZGVvRWxlbWVudCgpO1xuICAgICAgICB0aGlzLm9uVG91Y2hTdGFydExpc3RlbmVyID0gdGhpcy5vblRvdWNoU3RhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblRvdWNoRW5kTGlzdGVuZXIgPSB0aGlzLm9uVG91Y2hFbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblRvdWNoTW92ZUxpc3RlbmVyID0gdGhpcy5vblRvdWNoTW92ZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICByZWdpc3RlcigpIHtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0TGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25Ub3VjaEVuZExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZUxpc3RlbmVyKTtcbiAgICB9XG4gICAgdW5yZWdpc3RlcigpIHtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0TGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25Ub3VjaEVuZExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZUxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmVtZW1iZXJUb3VjaCh0b3VjaCkge1xuICAgICAgICBjb25zdCBmaW5nZXIgPSB0aGlzLmZpbmdlcnMucG9wKCk7XG4gICAgICAgIGlmIChmaW5nZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ2V4aGF1c3RlZCB0b3VjaCBpZGVudGlmaWVycycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluZ2VySWRzLnNldCh0b3VjaC5pZGVudGlmaWVyLCBmaW5nZXIpO1xuICAgIH1cbiAgICBmb3JnZXRUb3VjaCh0b3VjaCkge1xuICAgICAgICB0aGlzLmZpbmdlcnMucHVzaCh0aGlzLmZpbmdlcklkcy5nZXQodG91Y2guaWRlbnRpZmllcikpO1xuICAgICAgICAvLyBTb3J0IGFycmF5IGJhY2sgaW50byBkZXNjZW5kaW5nIG9yZGVyLiBUaGlzIG1lYW5zIGlmIGZpbmdlciAnMScgd2VyZSB0byBsaWZ0IGFmdGVyIGZpbmdlciAnMCcsIHdlIHdvdWxkIGVuc3VyZSB0aGF0IDAgd2lsbCBiZSB0aGUgZmlyc3QgaW5kZXggdG8gcG9wXG4gICAgICAgIHRoaXMuZmluZ2Vycy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYiAtIGE7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpbmdlcklkcy5kZWxldGUodG91Y2guaWRlbnRpZmllcik7XG4gICAgfVxuICAgIG9uVG91Y2hTdGFydCh0b3VjaEV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdG91Y2hFdmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgdGhpcy5yZW1lbWJlclRvdWNoKHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXNbdF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdFRvdWNoRGF0YSgnVG91Y2hTdGFydCcsIHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXMpO1xuICAgICAgICB0b3VjaEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIG9uVG91Y2hFbmQodG91Y2hFdmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXRUb3VjaERhdGEoJ1RvdWNoRW5kJywgdG91Y2hFdmVudC5jaGFuZ2VkVG91Y2hlcyk7XG4gICAgICAgIC8vIFJlLWN5Y2xlIHVuaXF1ZSBpZGVudGlmaWVycyBwcmV2aW91c2x5IGFzc2lnbmVkIHRvIGVhY2ggdG91Y2guXG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdG91Y2hFdmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgdGhpcy5mb3JnZXRUb3VjaCh0b3VjaEV2ZW50LmNoYW5nZWRUb3VjaGVzW3RdKTtcbiAgICAgICAgfVxuICAgICAgICB0b3VjaEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIG9uVG91Y2hNb3ZlKHRvdWNoRXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0VG91Y2hEYXRhKCdUb3VjaE1vdmUnLCB0b3VjaEV2ZW50LnRvdWNoZXMpO1xuICAgICAgICB0b3VjaEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGVtaXRUb3VjaERhdGEodHlwZSwgdG91Y2hlcykge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLnZpZGVvUGxheWVyLmdldFZpZGVvUGFyZW50RWxlbWVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCB0b1N0cmVhbWVySGFuZGxlcnMgPSB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycztcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0b3VjaGVzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICBjb25zdCBudW1Ub3VjaGVzID0gMTsgLy8gdGhlIG51bWJlciBvZiB0b3VjaGVzIHRvIGJlIHNlbnQgdGhpcyBtZXNzYWdlXG4gICAgICAgICAgICBjb25zdCB0b3VjaCA9IHRvdWNoZXNbdF07XG4gICAgICAgICAgICBjb25zdCB4ID0gdG91Y2guY2xpZW50WCAtIG9mZnNldC5sZWZ0O1xuICAgICAgICAgICAgY29uc3QgeSA9IHRvdWNoLmNsaWVudFkgLSBvZmZzZXQudG9wO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oYEYke3RoaXMuZmluZ2VySWRzLmdldCh0b3VjaC5pZGVudGlmaWVyKX09KCR7eH0sICR7eX0pYCk7XG4gICAgICAgICAgICBjb25zdCBjb29yZCA9IHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlci50cmFuc2xhdGVVbnNpZ25lZCh4LCB5KTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RvdWNoU3RhcnQnOlxuICAgICAgICAgICAgICAgICAgICB0b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdUb3VjaFN0YXJ0JykoW1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtVG91Y2hlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkLngsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5nZXJJZHMuZ2V0KHRvdWNoLmlkZW50aWZpZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhCeXRlVmFsdWUgKiAodG91Y2guZm9yY2UgPiAwID8gdG91Y2guZm9yY2UgOiAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkLmluUmFuZ2UgPyAxIDogMFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVG91Y2hFbmQnOlxuICAgICAgICAgICAgICAgICAgICB0b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdUb3VjaEVuZCcpKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVRvdWNoZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmQueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZ2VySWRzLmdldCh0b3VjaC5pZGVudGlmaWVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF4Qnl0ZVZhbHVlICogdG91Y2guZm9yY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZC5pblJhbmdlID8gMSA6IDBcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RvdWNoTW92ZSc6XG4gICAgICAgICAgICAgICAgICAgIHRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ1RvdWNoTW92ZScpKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVRvdWNoZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmQueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZ2VySWRzLmdldCh0b3VjaC5pZGVudGlmaWVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF4Qnl0ZVZhbHVlICogKHRvdWNoLmZvcmNlID4gMCA/IHRvdWNoLmZvcmNlIDogMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZC5pblJhbmdlID8gMSA6IDBcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG91Y2hDb250cm9sbGVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBNb3VzZUJ1dHRvbiB9IGZyb20gJy4vTW91c2VCdXR0b25zJztcbi8qKlxuICogQWxsb3dzIGZvciB0aGUgdXNhZ2Ugb2YgZmFrZSB0b3VjaCBldmVudHNcbiAqL1xuZXhwb3J0IGNsYXNzIFRvdWNoQ29udHJvbGxlckZha2Uge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLCB2aWRlb1BsYXllciwgY29vcmRpbmF0ZUNvbnZlcnRlcikge1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyID0gc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMudmlkZW9QbGF5ZXIgPSB2aWRlb1BsYXllcjtcbiAgICAgICAgdGhpcy5jb29yZGluYXRlQ29udmVydGVyID0gY29vcmRpbmF0ZUNvbnZlcnRlcjtcbiAgICAgICAgdGhpcy5vblRvdWNoU3RhcnRMaXN0ZW5lciA9IHRoaXMub25Ub3VjaFN0YXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Ub3VjaEVuZExpc3RlbmVyID0gdGhpcy5vblRvdWNoRW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Ub3VjaE1vdmVMaXN0ZW5lciA9IHRoaXMub25Ub3VjaE1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnRDbGllbnRSZWN0ID0gdGhpcy52aWRlb1BsYXllci5nZXRWaWRlb1BhcmVudEVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydExpc3RlbmVyKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmRMaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmVMaXN0ZW5lcik7XG4gICAgfVxuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydExpc3RlbmVyKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmRMaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmVMaXN0ZW5lcik7XG4gICAgfVxuICAgIG9uVG91Y2hTdGFydCh0b3VjaCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkgfHwgdG91Y2gudGFyZ2V0ICE9PSB0aGlzLnZpZGVvUGxheWVyLmdldFZpZGVvRWxlbWVudCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmFrZVRvdWNoRmluZ2VyID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0X3RvdWNoID0gdG91Y2guY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICB0aGlzLmZha2VUb3VjaEZpbmdlciA9IHtcbiAgICAgICAgICAgICAgICBpZDogZmlyc3RfdG91Y2guaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICB4OiBmaXJzdF90b3VjaC5jbGllbnRYIC0gdGhpcy52aWRlb0VsZW1lbnRQYXJlbnRDbGllbnRSZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgeTogZmlyc3RfdG91Y2guY2xpZW50WSAtIHRoaXMudmlkZW9FbGVtZW50UGFyZW50Q2xpZW50UmVjdC50b3BcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB2aWRlb0VsZW1lbnRQYXJlbnQgPSB0aGlzLnZpZGVvUGxheWVyLmdldFZpZGVvUGFyZW50RWxlbWVudCgpO1xuICAgICAgICAgICAgY29uc3QgbW91c2VFdmVudCA9IG5ldyBNb3VzZUV2ZW50KCdtb3VzZWVudGVyJywgZmlyc3RfdG91Y2gpO1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50UGFyZW50LmRpc3BhdGNoRXZlbnQobW91c2VFdmVudCk7XG4gICAgICAgICAgICBjb25zdCBjb29yZCA9IHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlci50cmFuc2xhdGVVbnNpZ25lZCh0aGlzLmZha2VUb3VjaEZpbmdlci54LCB0aGlzLmZha2VUb3VjaEZpbmdlci55KTtcbiAgICAgICAgICAgIGNvbnN0IHRvU3RyZWFtZXJIYW5kbGVycyA9IHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzO1xuICAgICAgICAgICAgdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VEb3duJykoW01vdXNlQnV0dG9uLm1haW5CdXR0b24sIGNvb3JkLngsIGNvb3JkLnldKTtcbiAgICAgICAgfVxuICAgICAgICB0b3VjaC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBvblRvdWNoRW5kKHRvdWNoRXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpIHx8IHRoaXMuZmFrZVRvdWNoRmluZ2VyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aWRlb0VsZW1lbnRQYXJlbnQgPSB0aGlzLnZpZGVvUGxheWVyLmdldFZpZGVvUGFyZW50RWxlbWVudCgpO1xuICAgICAgICBjb25zdCB0b1N0cmVhbWVySGFuZGxlcnMgPSB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycztcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0b3VjaEV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b3VjaCA9IHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXNbdF07XG4gICAgICAgICAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5mYWtlVG91Y2hGaW5nZXIuaWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gdG91Y2guY2xpZW50WCAtIHRoaXMudmlkZW9FbGVtZW50UGFyZW50Q2xpZW50UmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSB0b3VjaC5jbGllbnRZIC0gdGhpcy52aWRlb0VsZW1lbnRQYXJlbnRDbGllbnRSZWN0LnRvcDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb29yZCA9IHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlci50cmFuc2xhdGVVbnNpZ25lZCh4LCB5KTtcbiAgICAgICAgICAgICAgICB0b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdNb3VzZVVwJykoW01vdXNlQnV0dG9uLm1haW5CdXR0b24sIGNvb3JkLngsIGNvb3JkLnldKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZUV2ZW50ID0gbmV3IE1vdXNlRXZlbnQoJ21vdXNlbGVhdmUnLCB0b3VjaCk7XG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50UGFyZW50LmRpc3BhdGNoRXZlbnQobW91c2VFdmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWtlVG91Y2hGaW5nZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvdWNoRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgb25Ub3VjaE1vdmUodG91Y2hFdmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkgfHwgdGhpcy5mYWtlVG91Y2hGaW5nZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvU3RyZWFtZXJIYW5kbGVycyA9IHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRvdWNoRXZlbnQudG91Y2hlcy5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgY29uc3QgdG91Y2ggPSB0b3VjaEV2ZW50LnRvdWNoZXNbdF07XG4gICAgICAgICAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5mYWtlVG91Y2hGaW5nZXIuaWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gdG91Y2guY2xpZW50WCAtIHRoaXMudmlkZW9FbGVtZW50UGFyZW50Q2xpZW50UmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSB0b3VjaC5jbGllbnRZIC0gdGhpcy52aWRlb0VsZW1lbnRQYXJlbnRDbGllbnRSZWN0LnRvcDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb29yZCA9IHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlci50cmFuc2xhdGVVbnNpZ25lZCh4LCB5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlci50cmFuc2xhdGVTaWduZWQoeCAtIHRoaXMuZmFrZVRvdWNoRmluZ2VyLngsIHkgLSB0aGlzLmZha2VUb3VjaEZpbmdlci55KTtcbiAgICAgICAgICAgICAgICB0b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdNb3VzZU1vdmUnKShbY29vcmQueCwgY29vcmQueSwgZGVsdGEueCwgZGVsdGEueV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmFrZVRvdWNoRmluZ2VyLnggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuZmFrZVRvdWNoRmluZ2VyLnkgPSB5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvdWNoRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ub3VjaENvbnRyb2xsZXJGYWtlLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBkZWVwQ29weUdhbWVwYWQgfSBmcm9tICcuL0dhbWVwYWRUeXBlcyc7XG4vKipcbiAqIFRoZSBjbGFzcyB0aGF0IGhhbmRsZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgWFIgZ2FtZXBhZHMgYW5kIGNvbnRyb2xsZXJzLlxuICovXG5leHBvcnQgY2xhc3MgWFJHYW1lcGFkQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHRvU3RyZWFtZXJNZXNzYWdlc1Byb3ZpZGVyIC0gU3RyZWFtIG1lc3NhZ2UgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlcikge1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlc1Byb3ZpZGVyID0gdG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnMgPSBbXTtcbiAgICB9XG4gICAgdXBkYXRlU3RhdHVzKHNvdXJjZSwgZnJhbWUsIHJlZlNwYWNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuZ2FtZXBhZCkge1xuICAgICAgICAgICAgY29uc3QgZ2FtZXBhZFBvc2UgPSBmcmFtZS5nZXRQb3NlKHNvdXJjZS5ncmlwU3BhY2UsIHJlZlNwYWNlKTtcbiAgICAgICAgICAgIGlmICghZ2FtZXBhZFBvc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3lzdGVtID0gMDtcbiAgICAgICAgICAgIGlmIChzb3VyY2UucHJvZmlsZXMuaW5jbHVkZXMoJ2h0Yy12aXZlJykpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlLnByb2ZpbGVzLmluY2x1ZGVzKCdvY3VsdXMtdG91Y2gnKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPICh3aWxsaWFtLmJlbGNoZXIpOiBBZGQgb3RoZXIgcHJvZmlsZXMgKFF1ZXN0LCBNaWNyb3NvZnQgTWl4ZWQgUmVhbGl0eSwgZXRjKVxuICAgICAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdYUlN5c3RlbScpKFtzeXN0ZW1dKTtcbiAgICAgICAgICAgIC8vIERlZmF1bHQ6IEFueUhhbmQgKDIpXG4gICAgICAgICAgICBsZXQgaGFuZGVkbmVzcyA9IDI7XG4gICAgICAgICAgICBzd2l0Y2ggKHNvdXJjZS5oYW5kZWRuZXNzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIGhhbmRlZG5lc3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIGhhbmRlZG5lc3MgPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNlbmQgY29udHJvbGxlciB0cmFuc2Zvcm1cbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IGdhbWVwYWRQb3NlLnRyYW5zZm9ybS5tYXRyaXg7XG4gICAgICAgICAgICBjb25zdCBtYXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIG1hdFtpXSA9IG5ldyBGbG9hdDMyQXJyYXkoW21hdHJpeFtpXV0pWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlc1Byb3ZpZGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ1hSQ29udHJvbGxlclRyYW5zZm9ybScpKFtcbiAgICAgICAgICAgICAgICBtYXRbMF0sIG1hdFs0XSwgbWF0WzhdLCBtYXRbMTJdLFxuICAgICAgICAgICAgICAgIG1hdFsxXSwgbWF0WzVdLCBtYXRbOV0sIG1hdFsxM10sXG4gICAgICAgICAgICAgICAgbWF0WzJdLCBtYXRbNl0sIG1hdFsxMF0sIG1hdFsxNF0sXG4gICAgICAgICAgICAgICAgbWF0WzNdLCBtYXRbN10sIG1hdFsxMV0sIG1hdFsxNV0sXG4gICAgICAgICAgICAgICAgaGFuZGVkbmVzc1xuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAvLyBIYW5kbGUgY29udHJvbGxlciBidXR0b25zIGFuZCBheGVzXG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sbGVyc1toYW5kZWRuZXNzXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyc1toYW5kZWRuZXNzXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlN0YXRlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBpZDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJzW2hhbmRlZG5lc3NdLnByZXZTdGF0ZSA9IGRlZXBDb3B5R2FtZXBhZChzb3VyY2UuZ2FtZXBhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJzW2hhbmRlZG5lc3NdLmN1cnJlbnRTdGF0ZSA9IGRlZXBDb3B5R2FtZXBhZChzb3VyY2UuZ2FtZXBhZCk7XG4gICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5jb250cm9sbGVyc1toYW5kZWRuZXNzXTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJTdGF0ZSA9IGNvbnRyb2xsZXIuY3VycmVudFN0YXRlO1xuICAgICAgICAgICAgY29uc3QgcHJldlN0YXRlID0gY29udHJvbGxlci5wcmV2U3RhdGU7XG4gICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYnV0dG9uc1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyU3RhdGUuYnV0dG9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJCdXR0b24gPSBjdXJyU3RhdGUuYnV0dG9uc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2QnV0dG9uID0gcHJldlN0YXRlLmJ1dHRvbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJCdXR0b24ucHJlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmVzc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1JlcGVhdCA9IHByZXZCdXR0b24ucHJlc3NlZCA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlc1Byb3ZpZGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ1hSQnV0dG9uUHJlc3NlZCcpKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRlZG5lc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZXBlYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyQnV0dG9uLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmV2QnV0dG9uLnByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdYUkJ1dHRvblJlbGVhc2VkJykoW1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGVkbmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VyckJ1dHRvbi50b3VjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvdWNoZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNSZXBlYXQgPSBwcmV2QnV0dG9uLnRvdWNoZWQgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdYUkJ1dHRvblRvdWNoZWQnKShbXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kZWRuZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVwZWF0XG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmV2QnV0dG9uLnRvdWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdYUkJ1dHRvblRvdWNoUmVsZWFzZWQnKShbXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kZWRuZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGdhbWVwYWQgYXhlc1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyU3RhdGUuYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1ckF4aXNWYWx1ZSA9IGN1cnJTdGF0ZS5heGVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZBeGlzVmFsdWUgPSBwcmV2U3RhdGUuYXhlc1tpXTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHNlbmQgYXhpcyB1cGRhdGUgaWYgdGhlcmUgaXMgYSBjaGFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoY3VyQXhpc1ZhbHVlICE9IHByZXZBeGlzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdYUkFuYWxvZycpKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRlZG5lc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyQXhpc1ZhbHVlXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcnNbaGFuZGVkbmVzc10ucHJldlN0YXRlID0gY3VyclN0YXRlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9WFJHYW1lcGFkQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgSW5ib3VuZFZpZGVvU3RhdHMsIEluYm91bmRBdWRpb1N0YXRzIH0gZnJvbSAnLi9JbmJvdW5kUlRQU3RhdHMnO1xuaW1wb3J0IHsgRGF0YUNoYW5uZWxTdGF0cyB9IGZyb20gJy4vRGF0YUNoYW5uZWxTdGF0cyc7XG5pbXBvcnQgeyBDYW5kaWRhdGVTdGF0IH0gZnJvbSAnLi9DYW5kaWRhdGVTdGF0JztcbmltcG9ydCB7IFJlbW90ZU91dGJvdW5kUlRQU3RhdHMsIE91dGJvdW5kUlRQU3RhdHMgfSBmcm9tICcuL091dEJvdW5kUlRQU3RhdHMnO1xuaW1wb3J0IHsgU2Vzc2lvblN0YXRzIH0gZnJvbSAnLi9TZXNzaW9uU3RhdHMnO1xuaW1wb3J0IHsgU3RyZWFtU3RhdHMgfSBmcm9tICcuL1N0cmVhbVN0YXRzJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42Jztcbi8qKlxuICogVGhlIEFnZ3JlZ2F0ZWQgU3RhdHMgdGhhdCBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgUlRDIFN0YXRzIFJlcG9ydFxuICovXG5leHBvcnQgY2xhc3MgQWdncmVnYXRlZFN0YXRzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbmJvdW5kVmlkZW9TdGF0cyA9IG5ldyBJbmJvdW5kVmlkZW9TdGF0cygpO1xuICAgICAgICB0aGlzLmluYm91bmRBdWRpb1N0YXRzID0gbmV3IEluYm91bmRBdWRpb1N0YXRzKCk7XG4gICAgICAgIHRoaXMuY2FuZGlkYXRlUGFpcnMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbFN0YXRzID0gbmV3IERhdGFDaGFubmVsU3RhdHMoKTtcbiAgICAgICAgdGhpcy5sb2NhbENhbmRpZGF0ZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5yZW1vdGVDYW5kaWRhdGVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMub3V0Ym91bmRWaWRlb1N0YXRzID0gbmV3IE91dGJvdW5kUlRQU3RhdHMoKTtcbiAgICAgICAgdGhpcy5vdXRib3VuZEF1ZGlvU3RhdHMgPSBuZXcgT3V0Ym91bmRSVFBTdGF0cygpO1xuICAgICAgICB0aGlzLnJlbW90ZU91dGJvdW5kQXVkaW9TdGF0cyA9IG5ldyBSZW1vdGVPdXRib3VuZFJUUFN0YXRzKCk7XG4gICAgICAgIHRoaXMucmVtb3RlT3V0Ym91bmRWaWRlb1N0YXRzID0gbmV3IFJlbW90ZU91dGJvdW5kUlRQU3RhdHMoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uU3RhdHMgPSBuZXcgU2Vzc2lvblN0YXRzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtU3RhdHMgPSBuZXcgU3RyZWFtU3RhdHMoKTtcbiAgICAgICAgdGhpcy5jb2RlY3MgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdhdGhlciBhbGwgdGhlIGluZm9ybWF0aW9uIGZyb20gdGhlIFJUQyBQZWVyIENvbm5lY3Rpb24gUmVwb3J0XG4gICAgICogQHBhcmFtIHJ0Y1N0YXRzUmVwb3J0IC0gUlRDIFN0YXRzIFJlcG9ydFxuICAgICAqL1xuICAgIHByb2Nlc3NTdGF0cyhydGNTdGF0c1JlcG9ydCkge1xuICAgICAgICB0aGlzLmxvY2FsQ2FuZGlkYXRlcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLnJlbW90ZUNhbmRpZGF0ZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5jYW5kaWRhdGVQYWlycyA9IG5ldyBBcnJheSgpO1xuICAgICAgICBydGNTdGF0c1JlcG9ydC5mb3JFYWNoKChzdGF0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gc3RhdC50eXBlO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2FuZGlkYXRlLXBhaXInOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNhbmRpZGF0ZVBhaXIoc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NlcnRpZmljYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29kZWMnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNvZGVjKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkYXRhLWNoYW5uZWwnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURhdGFDaGFubmVsKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpbmJvdW5kLXJ0cCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSW5ib3VuZFJUUChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbG9jYWwtY2FuZGlkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVMb2NhbENhbmRpZGF0ZShzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWVkaWEtc291cmNlJzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWVkaWEtcGxheW91dCc6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ291dGJvdW5kLXJ0cCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTG9jYWxPdXRib3VuZChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncGVlci1jb25uZWN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVtb3RlLWNhbmRpZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVtb3RlQ2FuZGlkYXRlKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyZW1vdGUtaW5ib3VuZC1ydHAnOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyZW1vdGUtb3V0Ym91bmQtcnRwJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZW1vdGVPdXRib3VuZChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndHJhY2snOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRyYWNrKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd0cmFuc3BvcnQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRyYW5zcG9ydChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTdHJlYW0oc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcigndW5oYW5kbGVkIFN0YXQgVHlwZScpO1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuSW5mbyhzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHN0cmVhbSBzdGF0cyBkYXRhIGZyb20gd2VicnRjXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdCAtIHRoZSBzdGF0cyBjb21pbmcgaW4gZnJvbSB3ZWJydGNcbiAgICAgKi9cbiAgICBoYW5kbGVTdHJlYW0oc3RhdCkge1xuICAgICAgICB0aGlzLnN0cmVhbVN0YXRzID0gc3RhdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgSWNlIENhbmRpZGF0ZSBQYWlyIERhdGFcbiAgICAgKiBAcGFyYW0gc3RhdCAtIHRoZSBzdGF0cyBjb21pbmcgaW4gZnJvbSBpY2UgY2FuZGlkYXRlc1xuICAgICAqL1xuICAgIGhhbmRsZUNhbmRpZGF0ZVBhaXIoc3RhdCkge1xuICAgICAgICAvLyBBZGQgdGhlIGNhbmRpZGF0ZSBwYWlyIHRvIHRoZSBjYW5kaWRhdGUgcGFpciBhcnJheVxuICAgICAgICB0aGlzLmNhbmRpZGF0ZVBhaXJzLnB1c2goc3RhdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIERhdGEgQ2hhbm5lbCBEYXRhXG4gICAgICogQHBhcmFtIHN0YXQgLSB0aGUgc3RhdHMgY29taW5nIGluIGZyb20gdGhlIGRhdGEgY2hhbm5lbFxuICAgICAqL1xuICAgIGhhbmRsZURhdGFDaGFubmVsKHN0YXQpIHtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbFN0YXRzLmJ5dGVzUmVjZWl2ZWQgPSBzdGF0LmJ5dGVzUmVjZWl2ZWQ7XG4gICAgICAgIHRoaXMuZGF0YWNoYW5uZWxTdGF0cy5ieXRlc1NlbnQgPSBzdGF0LmJ5dGVzU2VudDtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbFN0YXRzLmRhdGFDaGFubmVsSWRlbnRpZmllciA9IHN0YXQuZGF0YUNoYW5uZWxJZGVudGlmaWVyO1xuICAgICAgICB0aGlzLmRhdGFjaGFubmVsU3RhdHMuaWQgPSBzdGF0LmlkO1xuICAgICAgICB0aGlzLmRhdGFjaGFubmVsU3RhdHMubGFiZWwgPSBzdGF0LmxhYmVsO1xuICAgICAgICB0aGlzLmRhdGFjaGFubmVsU3RhdHMubWVzc2FnZXNSZWNlaXZlZCA9IHN0YXQubWVzc2FnZXNSZWNlaXZlZDtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbFN0YXRzLm1lc3NhZ2VzU2VudCA9IHN0YXQubWVzc2FnZXNTZW50O1xuICAgICAgICB0aGlzLmRhdGFjaGFubmVsU3RhdHMucHJvdG9jb2wgPSBzdGF0LnByb3RvY29sO1xuICAgICAgICB0aGlzLmRhdGFjaGFubmVsU3RhdHMuc3RhdGUgPSBzdGF0LnN0YXRlO1xuICAgICAgICB0aGlzLmRhdGFjaGFubmVsU3RhdHMudGltZXN0YW1wID0gc3RhdC50aW1lc3RhbXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIExvY2FsIEljZSBDYW5kaWRhdGUgRGF0YVxuICAgICAqIEBwYXJhbSBzdGF0IC0gbG9jYWwgc3RhdHNcbiAgICAgKi9cbiAgICBoYW5kbGVMb2NhbENhbmRpZGF0ZShzdGF0KSB7XG4gICAgICAgIGNvbnN0IGxvY2FsQ2FuZGlkYXRlID0gbmV3IENhbmRpZGF0ZVN0YXQoKTtcbiAgICAgICAgbG9jYWxDYW5kaWRhdGUubGFiZWwgPSAnbG9jYWwtY2FuZGlkYXRlJztcbiAgICAgICAgbG9jYWxDYW5kaWRhdGUuYWRkcmVzcyA9IHN0YXQuYWRkcmVzcztcbiAgICAgICAgbG9jYWxDYW5kaWRhdGUucG9ydCA9IHN0YXQucG9ydDtcbiAgICAgICAgbG9jYWxDYW5kaWRhdGUucHJvdG9jb2wgPSBzdGF0LnByb3RvY29sO1xuICAgICAgICBsb2NhbENhbmRpZGF0ZS5jYW5kaWRhdGVUeXBlID0gc3RhdC5jYW5kaWRhdGVUeXBlO1xuICAgICAgICBsb2NhbENhbmRpZGF0ZS5pZCA9IHN0YXQuaWQ7XG4gICAgICAgIGxvY2FsQ2FuZGlkYXRlLnJlbGF5UHJvdG9jb2wgPSBzdGF0LnJlbGF5UHJvdG9jb2w7XG4gICAgICAgIGxvY2FsQ2FuZGlkYXRlLnRyYW5zcG9ydElkID0gc3RhdC50cmFuc3BvcnRJZDtcbiAgICAgICAgdGhpcy5sb2NhbENhbmRpZGF0ZXMucHVzaChsb2NhbENhbmRpZGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIFJlbW90ZSBJY2UgQ2FuZGlkYXRlIERhdGFcbiAgICAgKiBAcGFyYW0gc3RhdCAtIGljZSBjYW5kaWRhdGUgc3RhdHNcbiAgICAgKi9cbiAgICBoYW5kbGVSZW1vdGVDYW5kaWRhdGUoc3RhdCkge1xuICAgICAgICBjb25zdCByZW1vdGVDYW5kaWRhdGUgPSBuZXcgQ2FuZGlkYXRlU3RhdCgpO1xuICAgICAgICByZW1vdGVDYW5kaWRhdGUubGFiZWwgPSAncmVtb3RlLWNhbmRpZGF0ZSc7XG4gICAgICAgIHJlbW90ZUNhbmRpZGF0ZS5hZGRyZXNzID0gc3RhdC5hZGRyZXNzO1xuICAgICAgICByZW1vdGVDYW5kaWRhdGUucG9ydCA9IHN0YXQucG9ydDtcbiAgICAgICAgcmVtb3RlQ2FuZGlkYXRlLnByb3RvY29sID0gc3RhdC5wcm90b2NvbDtcbiAgICAgICAgcmVtb3RlQ2FuZGlkYXRlLmlkID0gc3RhdC5pZDtcbiAgICAgICAgcmVtb3RlQ2FuZGlkYXRlLmNhbmRpZGF0ZVR5cGUgPSBzdGF0LmNhbmRpZGF0ZVR5cGU7XG4gICAgICAgIHJlbW90ZUNhbmRpZGF0ZS5yZWxheVByb3RvY29sID0gc3RhdC5yZWxheVByb3RvY29sO1xuICAgICAgICByZW1vdGVDYW5kaWRhdGUudHJhbnNwb3J0SWQgPSBzdGF0LnRyYW5zcG9ydElkO1xuICAgICAgICB0aGlzLnJlbW90ZUNhbmRpZGF0ZXMucHVzaChyZW1vdGVDYW5kaWRhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBJbmJvdW5kIFJUUCBBdWRpbyBhbmQgVmlkZW8gRGF0YVxuICAgICAqIEBwYXJhbSBzdGF0IC0gaW5ib3VuZCBydHAgc3RhdHNcbiAgICAgKi9cbiAgICBoYW5kbGVJbmJvdW5kUlRQKHN0YXQpIHtcbiAgICAgICAgc3dpdGNoIChzdGF0LmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgYml0cmF0ZSBiZXR3ZWVuIHN0YXQgdXBkYXRlc1xuICAgICAgICAgICAgICAgIGlmIChzdGF0LmJ5dGVzUmVjZWl2ZWQgPiB0aGlzLmluYm91bmRWaWRlb1N0YXRzLmJ5dGVzUmVjZWl2ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgc3RhdC50aW1lc3RhbXAgPiB0aGlzLmluYm91bmRWaWRlb1N0YXRzLnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluYm91bmRWaWRlb1N0YXRzLmJpdHJhdGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgKDggKiAoc3RhdC5ieXRlc1JlY2VpdmVkIC0gdGhpcy5pbmJvdW5kVmlkZW9TdGF0cy5ieXRlc1JlY2VpdmVkKSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0LnRpbWVzdGFtcCAtIHRoaXMuaW5ib3VuZFZpZGVvU3RhdHMudGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmJvdW5kVmlkZW9TdGF0cy5iaXRyYXRlID0gTWF0aC5mbG9vcih0aGlzLmluYm91bmRWaWRlb1N0YXRzLmJpdHJhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb3B5IG1lbWJlcnMgZnJvbSBzdGF0IGludG8gYHRoaXMuaW5ib3VuZFZpZGVvU3RhdHNgXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc3RhdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluYm91bmRWaWRlb1N0YXRzW2tleV0gPSBzdGF0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgICAgICAgICAgIGlmIChzdGF0LmJ5dGVzUmVjZWl2ZWQgPiB0aGlzLmluYm91bmRBdWRpb1N0YXRzLmJ5dGVzUmVjZWl2ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgc3RhdC50aW1lc3RhbXAgPiB0aGlzLmluYm91bmRBdWRpb1N0YXRzLnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluYm91bmRBdWRpb1N0YXRzLmJpdHJhdGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgKDggKiAoc3RhdC5ieXRlc1JlY2VpdmVkIC0gdGhpcy5pbmJvdW5kQXVkaW9TdGF0cy5ieXRlc1JlY2VpdmVkKSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0LnRpbWVzdGFtcCAtIHRoaXMuaW5ib3VuZEF1ZGlvU3RhdHMudGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmJvdW5kQXVkaW9TdGF0cy5iaXRyYXRlID0gTWF0aC5mbG9vcih0aGlzLmluYm91bmRBdWRpb1N0YXRzLmJpdHJhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb3B5IG1lbWJlcnMgZnJvbSBzdGF0IGludG8gYHRoaXMuaW5ib3VuZEF1ZGlvU3RhdHNgXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc3RhdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluYm91bmRBdWRpb1N0YXRzW2tleV0gPSBzdGF0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoYEtpbmQgc2hvdWxkIGJlIGF1ZGlvIG9yIHZpZGVvLCB3ZSBnb3QgJHtzdGF0LmtpbmR9IC0gdGhhdCdzIHVuc3VwcG9ydGVkLmApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIFwibG9jYWxcIiBvdXRib3VuZCBSVFAgQXVkaW8gYW5kIFZpZGVvIHN0YXRzLlxuICAgICAqIEBwYXJhbSBzdGF0IC0gbG9jYWwgb3V0Ym91bmQgcnRwIHN0YXRzXG4gICAgICovXG4gICAgaGFuZGxlTG9jYWxPdXRib3VuZChzdGF0KSB7XG4gICAgICAgIGNvbnN0IGxvY2FsT3V0Ym91bmRTdGF0cyA9IHN0YXQua2luZCA9PT0gJ2F1ZGlvJyA/IHRoaXMub3V0Ym91bmRBdWRpb1N0YXRzIDogdGhpcy5vdXRib3VuZFZpZGVvU3RhdHM7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5hY3RpdmUgPSBzdGF0LmFjdGl2ZTtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLmNvZGVjSWQgPSBzdGF0LmNvZGVjSWQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5ieXRlc1NlbnQgPSBzdGF0LmJ5dGVzU2VudDtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLmZyYW1lSGVpZ2h0ID0gc3RhdC5mcmFtZUhlaWdodDtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLmZyYW1lV2lkdGggPSBzdGF0LmZyYW1lV2lkdGg7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5mcmFtZXNFbmNvZGVkID0gc3RhdC5mcmFtZXNFbmNvZGVkO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMuZnJhbWVzUGVyU2Vjb25kID0gc3RhdC5mcmFtZXNQZXJTZWNvbmQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5oZWFkZXJCeXRlc1NlbnQgPSBzdGF0LmhlYWRlckJ5dGVzU2VudDtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLmlkID0gc3RhdC5pZDtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLmtleUZyYW1lc0VuY29kZWQgPSBzdGF0LmtleUZyYW1lc0VuY29kZWQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5raW5kID0gc3RhdC5raW5kO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMubWVkaWFTb3VyY2VJZCA9IHN0YXQubWVkaWFTb3VyY2VJZDtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLm1pZCA9IHN0YXQubWlkO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMubmFja0NvdW50ID0gc3RhdC5uYWNrQ291bnQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5wYWNrZXRzU2VudCA9IHN0YXQucGFja2V0c1NlbnQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5xcFN1bSA9IHN0YXQucXBTdW07XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucyA9IHN0YXQucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnM7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5xdWFsaXR5TGltaXRhdGlvblJlYXNvbiA9IHN0YXQucXVhbGl0eUxpbWl0YXRpb25SZWFzb247XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5yZW1vdGVJZCA9IHN0YXQucmVtb3RlSWQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5yZXRyYW5zbWl0dGVkQnl0ZXNTZW50ID0gc3RhdC5yZXRyYW5zbWl0dGVkQnl0ZXNTZW50O1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMucmlkID0gc3RhdC5yaWQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5zY2FsYWJpbGl0eU1vZGUgPSBzdGF0LnNjYWxhYmlsaXR5TW9kZTtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLnNzcmMgPSBzdGF0LnNzcmM7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy50YXJnZXRCaXRyYXRlID0gc3RhdC50YXJnZXRCaXRyYXRlO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMudGltZXN0YW1wID0gc3RhdC50aW1lc3RhbXA7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy50b3RhbEVuY29kZVRpbWUgPSBzdGF0LnRvdGFsRW5jb2RlVGltZTtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLnRvdGFsRW5jb2RlQnl0ZXNUYXJnZXQgPSBzdGF0LnRvdGFsRW5jb2RlQnl0ZXNUYXJnZXQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy50b3RhbFBhY2tldFNlbmREZWxheSA9IHN0YXQudG90YWxQYWNrZXRTZW5kRGVsYXk7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy50cmFuc3BvcnRJZCA9IHN0YXQudHJhbnNwb3J0SWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIFwicmVtb3RlXCIgb3V0Ym91bmQgUlRQIEF1ZGlvIGFuZCBWaWRlbyBzdGF0cy5cbiAgICAgKiBAcGFyYW0gc3RhdCAtIHJlbW90ZSBvdXRib3VuZCBydHAgc3RhdHNcbiAgICAgKi9cbiAgICBoYW5kbGVSZW1vdGVPdXRib3VuZChzdGF0KSB7XG4gICAgICAgIGNvbnN0IHJlbW90ZU91dGJvdW5kU3RhdHMgPSBzdGF0LmtpbmQgPT09ICdhdWRpbycgPyB0aGlzLnJlbW90ZU91dGJvdW5kQXVkaW9TdGF0cyA6IHRoaXMucmVtb3RlT3V0Ym91bmRWaWRlb1N0YXRzO1xuICAgICAgICByZW1vdGVPdXRib3VuZFN0YXRzLmJ5dGVzU2VudCA9IHN0YXQuYnl0ZXNTZW50O1xuICAgICAgICByZW1vdGVPdXRib3VuZFN0YXRzLmNvZGVjSWQgPSBzdGF0LmNvZGVjSWQ7XG4gICAgICAgIHJlbW90ZU91dGJvdW5kU3RhdHMuaWQgPSBzdGF0LmlkO1xuICAgICAgICByZW1vdGVPdXRib3VuZFN0YXRzLmtpbmQgPSBzdGF0LmtpbmQ7XG4gICAgICAgIHJlbW90ZU91dGJvdW5kU3RhdHMubG9jYWxJZCA9IHN0YXQubG9jYWxJZDtcbiAgICAgICAgcmVtb3RlT3V0Ym91bmRTdGF0cy5wYWNrZXRzU2VudCA9IHN0YXQucGFja2V0c1NlbnQ7XG4gICAgICAgIHJlbW90ZU91dGJvdW5kU3RhdHMucmVtb3RlVGltZXN0YW1wID0gc3RhdC5yZW1vdGVUaW1lc3RhbXA7XG4gICAgICAgIHJlbW90ZU91dGJvdW5kU3RhdHMucmVwb3J0c1NlbnQgPSBzdGF0LnJlcG9ydHNTZW50O1xuICAgICAgICByZW1vdGVPdXRib3VuZFN0YXRzLnJvdW5kVHJpcFRpbWVNZWFzdXJlbWVudHMgPSBzdGF0LnJvdW5kVHJpcFRpbWVNZWFzdXJlbWVudHM7XG4gICAgICAgIHJlbW90ZU91dGJvdW5kU3RhdHMuc3NyYyA9IHN0YXQuc3NyYztcbiAgICAgICAgcmVtb3RlT3V0Ym91bmRTdGF0cy50aW1lc3RhbXAgPSBzdGF0LnRpbWVzdGFtcDtcbiAgICAgICAgcmVtb3RlT3V0Ym91bmRTdGF0cy50b3RhbFJvdW5kVHJpcFRpbWUgPSBzdGF0LnRvdGFsUm91bmRUcmlwVGltZTtcbiAgICAgICAgcmVtb3RlT3V0Ym91bmRTdGF0cy50cmFuc3BvcnRJZCA9IHN0YXQudHJhbnNwb3J0SWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIEluYm91bmQgVmlkZW8gVHJhY2sgRGF0YVxuICAgICAqIEBwYXJhbSBzdGF0IC0gdmlkZW8gdHJhY2sgc3RhdHNcbiAgICAgKi9cbiAgICBoYW5kbGVUcmFjayhzdGF0KSB7XG4gICAgICAgIC8vIHdlIG9ubHkgd2FudCB0byBleHRyYWN0IHN0YXRzIGZyb20gdGhlIHZpZGVvIHRyYWNrXG4gICAgICAgIGlmIChzdGF0LnR5cGUgPT09ICd0cmFjaycgJiYgKHN0YXQudHJhY2tJZGVudGlmaWVyID09PSAndmlkZW9fbGFiZWwnIHx8IHN0YXQua2luZCA9PT0gJ3ZpZGVvJykpIHtcbiAgICAgICAgICAgIHRoaXMuaW5ib3VuZFZpZGVvU3RhdHMuZnJhbWVzRHJvcHBlZCA9IHN0YXQuZnJhbWVzRHJvcHBlZDtcbiAgICAgICAgICAgIHRoaXMuaW5ib3VuZFZpZGVvU3RhdHMuZnJhbWVzUmVjZWl2ZWQgPSBzdGF0LmZyYW1lc1JlY2VpdmVkO1xuICAgICAgICAgICAgdGhpcy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZUhlaWdodCA9IHN0YXQuZnJhbWVIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lV2lkdGggPSBzdGF0LmZyYW1lV2lkdGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlVHJhbnNwb3J0KHN0YXQpIHtcbiAgICAgICAgdGhpcy50cmFuc3BvcnRTdGF0cyA9IHN0YXQ7XG4gICAgfVxuICAgIGhhbmRsZUNvZGVjKHN0YXQpIHtcbiAgICAgICAgY29uc3QgY29kZWNJZCA9IHN0YXQuaWQ7XG4gICAgICAgIHRoaXMuY29kZWNzLnNldChjb2RlY0lkLCBzdGF0KTtcbiAgICB9XG4gICAgaGFuZGxlU2Vzc2lvblN0YXRpc3RpY3ModmlkZW9TdGFydFRpbWUsIGlucHV0Q29udHJvbGxlciwgdmlkZW9FbmNvZGVyQXZnUVApIHtcbiAgICAgICAgY29uc3QgZGVsdGFUaW1lID0gRGF0ZS5ub3coKSAtIHZpZGVvU3RhcnRUaW1lO1xuICAgICAgICB0aGlzLnNlc3Npb25TdGF0cy5ydW5UaW1lID0gbmV3IERhdGUoZGVsdGFUaW1lKS50b0lTT1N0cmluZygpLnN1YnN0cigxMSwgOCkudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgY29udHJvbHNTdHJlYW1JbnB1dCA9IGlucHV0Q29udHJvbGxlciA9PT0gbnVsbCA/ICdOb3Qgc2VudCB5ZXQnIDogaW5wdXRDb250cm9sbGVyID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICAgICAgdGhpcy5zZXNzaW9uU3RhdHMuY29udHJvbHNTdHJlYW1JbnB1dCA9IGNvbnRyb2xzU3RyZWFtSW5wdXQ7XG4gICAgICAgIHRoaXMuc2Vzc2lvblN0YXRzLnZpZGVvRW5jb2RlckF2Z1FQID0gdmlkZW9FbmNvZGVyQXZnUVA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdmFsdWUgY29taW5nIGluIGZyb20gb3VyIHN0YXRzIGlzIGFjdHVhbGx5IGEgbnVtYmVyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gdGhlIG51bWJlciB0byBiZSBjaGVja2VkXG4gICAgICovXG4gICAgaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBhY3RpdmUgY2FuZGlkYXRlIHBhaXJcbiAgICAgKiBAcmV0dXJucyBUaGUgY2FuZGlkYXRlIHBhaXIgdGhhdCBpcyBjdXJyZW50bHkgcmVjZWl2aW5nIGRhdGFcbiAgICAgKi9cbiAgICBnZXRBY3RpdmVDYW5kaWRhdGVQYWlyKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVQYWlycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgUlRDVHJhbnNwb3J0IHN0YXQgaXMgbm90IHVuZGVmaW5lZFxuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnRTdGF0cykge1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBjYW5kaWRhdGUgcGFpciB0aGF0IG1hdGNoZXMgdGhlIHRyYW5zcG9ydCBjYW5kaWRhdGUgcGFpciBpZFxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRQYWlyID0gdGhpcy5jYW5kaWRhdGVQYWlycy5maW5kKChjYW5kaWRhdGVQYWlyKSA9PiBjYW5kaWRhdGVQYWlyLmlkID09PSB0aGlzLnRyYW5zcG9ydFN0YXRzLnNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFBhaXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkUGFpcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIGAuc2VsZWN0ZWRgIG1lbWJlciBvZiB0aGUgY2FuZGlkYXRlIHBhaXJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRQYWlyID0gdGhpcy5jYW5kaWRhdGVQYWlycy5maW5kKChjYW5kaWRhdGVQYWlyKSA9PiBjYW5kaWRhdGVQYWlyLnNlbGVjdGVkKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkUGFpciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZFBhaXI7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BZ2dyZWdhdGVkU3RhdHMuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogSUNFIENhbmRpZGF0ZSBTdGF0IGNvbGxlY3RlZCBmcm9tIHRoZSBSVEMgU3RhdHMgUmVwb3J0XG4gKi9cbmV4cG9ydCBjbGFzcyBDYW5kaWRhdGVTdGF0IHtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbmRpZGF0ZVN0YXQuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogRGF0YSBDaGFubmVsIFN0YXRzIGNvbGxlY3RlZCBmcm9tIHRoZSBSVEMgU3RhdHMgUmVwb3J0XG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhQ2hhbm5lbFN0YXRzIHtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFDaGFubmVsU3RhdHMuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogSW5ib3VuZCBBdWRpbyBTdGF0cyBjb2xsZWN0ZWQgZnJvbSB0aGUgUlRDIFN0YXRzIFJlcG9ydFxuICovXG5leHBvcnQgY2xhc3MgSW5ib3VuZEF1ZGlvU3RhdHMge1xufVxuLyoqXG4gKiBJbmJvdW5kIFZpZGVvIFN0YXRzIGNvbGxlY3RlZCBmcm9tIHRoZSBSVEMgU3RhdHMgUmVwb3J0XG4gKi9cbmV4cG9ydCBjbGFzcyBJbmJvdW5kVmlkZW9TdGF0cyB7XG59XG4vKipcbiAqIEluYm91bmQgU3RhdHMgY29sbGVjdGVkIGZyb20gdGhlIFJUQyBTdGF0cyBSZXBvcnRcbiAqL1xuZXhwb3J0IGNsYXNzIEluYm91bmRSVFBTdGF0cyB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbmJvdW5kUlRQU3RhdHMuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogUmVwcmVzZW50cyBlaXRoZXIgYTpcbiAqIC0gc3luY2hyb25pemF0aW9uIHNvdXJjZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1J0cFJlY2VpdmVyL2dldFN5bmNocm9uaXphdGlvblNvdXJjZXNcbiAqIC0gY29udHJpYnV0aW5nIHNvdXJjZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1J0cFJlY2VpdmVyL2dldENvbnRyaWJ1dGluZ1NvdXJjZXNcbiAqIFdoaWNoIGFsc28gKGlmIGJyb3dzZXIgc3VwcG9ydHMgaXQpIG1heSBvcHRpb25hbGwgY29udGFpbiBmaWVsZHMgZm9yIGNhcHR1cmVUaW1lc3RhbXAgKyBzZW5kZXJDYXB0dXJlVGltZU9mZnNldFxuICogaWYgdGhlIGFicy1jYXB0dXJlLXRpbWUgUlRQIGhlYWRlciBleHRlbnNpb24gaXMgZW5hYmxlZCAoY3VycmVudGx5IHRoaXMgb25seSB3b3JrcyBpbiBDaHJvbWl1bSBiYXNlZCBicm93c2VycykuXG4gKi9cbmNsYXNzIFJUQ1J0cENhcHR1cmVTb3VyY2Uge1xufVxuLyoqXG4gKiBGcmFtZVRpbWluZ0luZm8gaXMgYSBDaHJvbWl1bS1zcGVjaWZpYyBzZXQgb2YgV2ViUlRDIHN0YXRzIHVzZWZ1bCBmb3IgbGF0ZW5jeSBjYWxjdWxhdGlvbi4gSXQgaXMgc3RvcmVkIGluIFdlYlJUQyBzdGF0cyBhcyBgZ29vZ1RpbWluZ0ZyYW1lSW5mb2AuXG4gKiBJdCBpcyBkZWZpbmVkIGFzIGFuIFJUUCBoZWFkZXIgZXh0ZW5zaW9uIGhlcmU6IGh0dHBzOi8vd2VicnRjLmdvb2dsZXNvdXJjZS5jb20vc3JjLysvcmVmcy9oZWFkcy9tYWluL2RvY3MvbmF0aXZlLWNvZGUvcnRwLWhkcmV4dC92aWRlby10aW1pbmcvUkVBRE1FLm1kXG4gKiBJdCBpcyBkZWZpbmVkIGluIHNvdXJjZSBjb2RlIGhlcmU6IGh0dHBzOi8vc291cmNlLmNocm9taXVtLm9yZy9jaHJvbWl1bS9jaHJvbWl1bS9zcmMvKy9tYWluOnRoaXJkX3BhcnR5L3dlYnJ0Yy9hcGkvdmlkZW8vdmlkZW9fdGltaW5nLmNjO2w9ODI7ZHJjPThkMzk5ODE3MjgyZTNjMTJlZDU0ZWIyM2VjNDJhNWU0MTgyOThlYzZcbiAqIEl0IGlzIGRpc2N1c3NlZCBieSBpdHMgYXV0aG9yIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvd2VicnRjLXByb3Zpc2lvbmFsLXN0YXRzL2lzc3Vlcy80MCNpc3N1ZWNvbW1lbnQtMTI3MjkxNjY5MlxuICogSW4gc3VtbWFyeSBpdCBhIGNvbW1hLWRlbGltaXRlZCBzdHJpbmcgdGhhdCBjb250YWlucyB0aGUgZm9sbG93aW5nIChpbiB0aGlzIG9yZGVyKTpcbiAqIDEpICBSVFAgdGltZXN0YW1wOiB0aGUgUlRQIHRpbWVzdGFtcCBvZiB0aGUgZnJhbWVcbiAqIDIpICBDYXB0dXJlIHRpbWU6IHRpbWVzdGFtcCB3aGVuIHRoaXMgZnJhbWUgd2FzIGNhcHR1cmVkXG4gKiAzKSAgRW5jb2RlIHN0YXJ0OiB0aW1lc3RhbXAgd2hlbiB0aGlzIGZyYW1lIHN0YXJ0ZWQgdG8gYmUgZW5jb2RlZFxuICogNCkgIEVuY29kZSBmaW5pc2g6IHRpbWVzdGFtcCB3aGVuIHRoaXMgZnJhbWUgZmluaXNoZWQgZW5jb2RpbmdcbiAqIDUpICBQYWNrZXRpemF0aW9uIGZpbmlzaDogdGltZXN0YW1wIHdoZW4gdGhpcyBmcmFtZSB3YXMgc3BsaXQgaW50byBwYWNrZXRzIGFuZCB3YXMgcmVhZHkgdG8gYmUgc2VudCBvdmVyIHRoZSBuZXR3b3JrXG4gKiA2KSAgUGFjZXIgZXhpdDogdGltZXN0YW1wIHdoZW4gbGFzdCBwYWNrZXQgb2YgdGhpcyBmcmFtZSB3YXMgc2VudCBvdmVyIHRoZSBuZXR3b3JrIGJ5IHRoZSBzZW5kZXIgYXQgdGhpcyB0aW1lc3RhbXBcbiAqIDcpICBOZXR3b3JrIHRpbWVzdGFtcDE6IHBsYWNlIGZvciB0aGUgU0ZVIHRvIG1hcmsgd2hlbiB0aGUgZnJhbWUgc3RhcnRlZCBiZWluZyBmb3J3YXJkZWQuIEFwcGxpY2F0aW9uIHNwZWNpZmljLlxuICogOCkgIE5ldHdvcmsgdGltZXN0YW1wMjogcGxhY2UgZm9yIHRoZSBTRlUgdG8gbWFyayB3aGVuIHRoZSBmcmFtZSBmaW5pc2hlZCBiZWluZyBmb3J3YXJkZWQuIEFwcGxpY2F0aW9uIHNwZWNpZmljLlxuICogOSkgIFJlY2VpdmUgc3RhcnQ6IHRpbWVzdGFtcCB3aGVuIHRoZSBmaXJzdCBwYWNrZXQgb2YgdGhpcyBmcmFtZSB3YXMgcmVjZWl2ZWRcbiAqIDEwKSBSZWNlaXZlIGZpbmlzaDogdGltZXN0YW1wIHdoZW4gdGhlIGxhc3QgcGFja2V0IG9mIHRoaXMgZnJhbWUgd2FzIHJlY2VpdmVkXG4gKiAxMSkgRGVjb2RlIHN0YXJ0OiAgdGltZXN0YW1wIHdoZW4gdGhlIGZyYW1lIHdhcyBwYXNzZWQgdG8gZGVjb2RlclxuICogMTIpIERlY29kZSBmaW5pc2g6ICB0aW1lc3RhbXAgd2hlbiB0aGUgZnJhbWUgd2FzIGRlY29kZWRcbiAqIDEzKSBSZW5kZXIgdGltZTogIHRpbWVzdGFtcCBvZiB0aGUgcHJvamVjdGVkIHJlbmRlciB0aW1lIGZvciB0aGlzIGZyYW1lXG4gKiAxNCkgXCJpcyBvdXRsaWVyXCI6IGEgZmxhZyBmb3IgaWYgdGhpcyBmcmFtZSBpcyBiaWdnZXIgaW4gZW5jb2RlZCBzaXplIHRoYW4gdGhlIGF2ZXJhZ2UgZnJhbWUgYnkgYXQgbGVhc3QgNXguXG4gKiAxNSkgXCJ0cmlnZ2VyZWQgYnkgdGltZXJcIjogYSBmbGFnIGZvciBpZiB0aGlzIHJlcG9ydCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB0aW1lciAoVGhlIHJlcG9ydCBpcyBzZW50IGV2ZXJ5IDIwMG1zKVxuICovXG5leHBvcnQgY2xhc3MgRnJhbWVUaW1pbmdJbmZvIHtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyBhIGNvbWJpbmF0aW9uIG9mIGxhdGVuY3kgc3RhdGlzdGljcyB1c2luZyBwdXJlbHkgV2ViUlRDIEFQSS5cbiAqL1xuZXhwb3J0IGNsYXNzIExhdGVuY3lDYWxjdWxhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyogQ2xvY2sgb2Zmc2V0IGJldHdlZW4gcGVlciBjbG9ja3MgY2Fubm90IGFsd2F5cyBiZSBjYWxjdWxhdGVkIGFzIGl0IHJlbGllcyBvZiBsYXRlc3Qgc2VuZGVyIHJlcG9ydHMuXG4gICAgICAgICAqIHNvIHdlIHN0b3JlIHRoZSBsYXN0IHRpbWUgd2UgaGFkIGEgdmFsaWQgY2xvY2sgb2Zmc2V0IGluIHRoZSBhc3N1bXB0aW9uIHRoYXQgY2xvY2tzIGhhdmVuJ3QgZHJpZnRlZCB0b28gbXVjaCBzaW5jZSB0aGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXRlc3RTZW5kZXJSZWN2Q2xvY2tPZmZzZXQgPSBudWxsO1xuICAgIH1cbiAgICBjYWxjdWxhdGUoc3RhdHMsIHJlY2VpdmVycykge1xuICAgICAgICBjb25zdCBsYXRlbmN5SW5mbyA9IG5ldyBMYXRlbmN5SW5mbygpO1xuICAgICAgICBjb25zdCBydHRNUyA9IHRoaXMuZ2V0UlRUTXMoc3RhdHMpO1xuICAgICAgICBpZiAocnR0TVMgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGF0ZW5jeUluZm8ucnR0TXMgPSBydHRNUztcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBzZW5kZXIgbGF0ZW5jeSB1c2luZyB0aGUgZmlyc3QgdmFsaWQgdmlkZW8gc3NyYy9jc3JjXG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlU291cmNlID0gdGhpcy5nZXRDYXB0dXJlU291cmNlKHJlY2VpdmVycyk7XG4gICAgICAgICAgICBpZiAoY2FwdHVyZVNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VuZGVyTGF0ZW5jeU1zID0gdGhpcy5jYWxjdWxhdGVTZW5kZXJMYXRlbmN5KHN0YXRzLCBjYXB0dXJlU291cmNlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VuZGVyTGF0ZW5jeU1zICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhdGVuY3lJbmZvLnNlbmRlckxhdGVuY3lNcyA9IHNlbmRlckxhdGVuY3lNcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1zdGF0cy8jZG9tLXJ0Y2luYm91bmRydHBzdHJlYW1zdGF0cy10b3RhbHByb2Nlc3NpbmdkZWxheVxuICAgICAgICBpZiAoc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMudG90YWxQcm9jZXNzaW5nRGVsYXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuZnJhbWVzRGVjb2RlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYXRlbmN5SW5mby5hdmVyYWdlUHJvY2Vzc2luZ0RlbGF5TXMgPVxuICAgICAgICAgICAgICAgIChzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy50b3RhbFByb2Nlc3NpbmdEZWxheSAvIHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lc0RlY29kZWQpICogMTAwMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXN0YXRzLyNkb20tcnRjaW5ib3VuZHJ0cHN0cmVhbXN0YXRzLWppdHRlcmJ1ZmZlcm1pbmltdW1kZWxheVxuICAgICAgICBpZiAoc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuaml0dGVyQnVmZmVyRGVsYXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuaml0dGVyQnVmZmVyRW1pdHRlZENvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLmF2ZXJhZ2VKaXR0ZXJCdWZmZXJEZWxheU1zID1cbiAgICAgICAgICAgICAgICAoc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuaml0dGVyQnVmZmVyRGVsYXkgL1xuICAgICAgICAgICAgICAgICAgICBzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5qaXR0ZXJCdWZmZXJFbWl0dGVkQ291bnQpICpcbiAgICAgICAgICAgICAgICAgICAgMTAwMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXN0YXRzLyNkb20tcnRjaW5ib3VuZHJ0cHN0cmVhbXN0YXRzLXRvdGFsZGVjb2RldGltZVxuICAgICAgICBpZiAoc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuZnJhbWVzRGVjb2RlZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy50b3RhbERlY29kZVRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGF0ZW5jeUluZm8uYXZlcmFnZURlY29kZUxhdGVuY3lNcyA9XG4gICAgICAgICAgICAgICAgKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLnRvdGFsRGVjb2RlVGltZSAvIHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lc0RlY29kZWQpICogMTAwMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXN0YXRzLyNkb20tcnRjaW5ib3VuZHJ0cHN0cmVhbXN0YXRzLWZyYW1lc2Fzc2VtYmxlZGZyb21tdWx0aXBsZXBhY2tldHNcbiAgICAgICAgaWYgKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLnRvdGFsQXNzZW1ibHlUaW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lc0Fzc2VtYmxlZEZyb21NdWx0aXBsZVBhY2tldHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGF0ZW5jeUluZm8uYXZlcmFnZUFzc2VtYmx5RGVsYXlNcyA9XG4gICAgICAgICAgICAgICAgKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLnRvdGFsQXNzZW1ibHlUaW1lIC9cbiAgICAgICAgICAgICAgICAgICAgc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuZnJhbWVzQXNzZW1ibGVkRnJvbU11bHRpcGxlUGFja2V0cykgKlxuICAgICAgICAgICAgICAgICAgICAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4dHJhY3QgZXh0cmEgQ2hyb21lLXNwZWNpZmljIHN0YXRzIGxpa2UgZW5jb2RpbmcgbGF0ZW5jeVxuICAgICAgICBpZiAoc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuZ29vZ1RpbWluZ0ZyYW1lSW5mbyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5nb29nVGltaW5nRnJhbWVJbmZvLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLmZyYW1lVGltaW5nID0gdGhpcy5leHRyYWN0RnJhbWVUaW1pbmdJbmZvKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmdvb2dUaW1pbmdGcmFtZUluZm8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbGN1bGF0ZSBFMkUgbGF0ZW5jeSB1c2luZyB2aWRlby10aW1pbmcgY2FwdHVyZSB0byBzZW5kIHRpbWUgKyBvbmUgd2F5IG5ldHdvcmsgbGF0ZW5jeSArIHJlY2VpdmVyLXNpZGUgbGF0ZW5jeVxuICAgICAgICBpZiAobGF0ZW5jeUluZm8uZnJhbWVUaW1pbmcgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgbGF0ZW5jeUluZm8uZnJhbWVUaW1pbmcuY2FwdHVyZVRvU2VuZExhdGVuY3lNcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBsYXRlbmN5SW5mby5hdmVyYWdlUHJvY2Vzc2luZ0RlbGF5TXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgbGF0ZW5jeUluZm8ucnR0TXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGF0ZW5jeUluZm8uYXZlcmFnZUUyRUxhdGVuY3kgPVxuICAgICAgICAgICAgICAgIGxhdGVuY3lJbmZvLmZyYW1lVGltaW5nLmNhcHR1cmVUb1NlbmRMYXRlbmN5TXMgK1xuICAgICAgICAgICAgICAgICAgICBsYXRlbmN5SW5mby5ydHRNcyAqIDAuNSArXG4gICAgICAgICAgICAgICAgICAgIGxhdGVuY3lJbmZvLmF2ZXJhZ2VQcm9jZXNzaW5nRGVsYXlNcztcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgRTJFIGxhdGVuY3kgYXMgYWJzLWNhcHR1cmUtdGltZSBjYXB0dXJlIHRvIHNlbmQgbGF0ZW5jeSArIG9uZSB3YXkgbmV0d29yayBsYXRlbmN5ICsgcmVjZWl2ZXItc2lkZSBsYXRlbmN5XG4gICAgICAgIGlmIChsYXRlbmN5SW5mby5zZW5kZXJMYXRlbmN5TXMgIT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBsYXRlbmN5SW5mby5hdmVyYWdlUHJvY2Vzc2luZ0RlbGF5TXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgbGF0ZW5jeUluZm8ucnR0TXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGF0ZW5jeUluZm8uYXZlcmFnZUUyRUxhdGVuY3kgPVxuICAgICAgICAgICAgICAgIGxhdGVuY3lJbmZvLnNlbmRlckxhdGVuY3lNcyArIGxhdGVuY3lJbmZvLnJ0dE1zICogMC41ICsgbGF0ZW5jeUluZm8uYXZlcmFnZVByb2Nlc3NpbmdEZWxheU1zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXRlbmN5SW5mbztcbiAgICB9XG4gICAgZXh0cmFjdEZyYW1lVGltaW5nSW5mbyhnb29nVGltaW5nRnJhbWVJbmZvKSB7XG4gICAgICAgIGNvbnN0IHRpbWluZ0luZm8gPSBuZXcgRnJhbWVUaW1pbmdJbmZvKCk7XG4gICAgICAgIGNvbnN0IHRpbWluZ0luZm9BcnIgPSBnb29nVGltaW5nRnJhbWVJbmZvLnNwbGl0KCcsJyk7XG4gICAgICAgIC8vIFNob3VsZCBoYXZlIGV4YWN0bHkgMTUgZWxlbWVudHMgYWNjb3JkaW5nIHRvOlxuICAgICAgICAvLyBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFpbjp0aGlyZF9wYXJ0eS93ZWJydGMvYXBpL3ZpZGVvL3ZpZGVvX3RpbWluZy5jYztsPTgyO2RyYz04ZDM5OTgxNzI4MmUzYzEyZWQ1NGViMjNlYzQyYTVlNDE4Mjk4ZWM2XG4gICAgICAgIGlmICh0aW1pbmdJbmZvQXJyLmxlbmd0aCA9PT0gMTUpIHtcbiAgICAgICAgICAgIHRpbWluZ0luZm8ucnRwVGltZXN0YW1wID0gTnVtYmVyLnBhcnNlSW50KHRpbWluZ0luZm9BcnJbMF0pO1xuICAgICAgICAgICAgdGltaW5nSW5mby5jYXB0dXJlVGltZXN0YW1wID0gTnVtYmVyLnBhcnNlSW50KHRpbWluZ0luZm9BcnJbMV0pO1xuICAgICAgICAgICAgdGltaW5nSW5mby5lbmNvZGVTdGFydFRpbWVzdGFtcCA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzJdKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8uZW5jb2RlRmluaXNoVGltZXN0YW1wID0gTnVtYmVyLnBhcnNlSW50KHRpbWluZ0luZm9BcnJbM10pO1xuICAgICAgICAgICAgdGltaW5nSW5mby5wYWNrZXRpemVyRmluaXNoVGltZXN0YW1wID0gTnVtYmVyLnBhcnNlSW50KHRpbWluZ0luZm9BcnJbNF0pO1xuICAgICAgICAgICAgdGltaW5nSW5mby5wYWNlckV4aXRUaW1lc3RhbXAgPSBOdW1iZXIucGFyc2VJbnQodGltaW5nSW5mb0Fycls1XSk7XG4gICAgICAgICAgICB0aW1pbmdJbmZvLm5ldHdvcmtUaW1lc3RhbXAxID0gTnVtYmVyLnBhcnNlSW50KHRpbWluZ0luZm9BcnJbNl0pO1xuICAgICAgICAgICAgdGltaW5nSW5mby5uZXR3b3JrVGltZXN0YW1wMiA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzddKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8ucmVjZWl2ZVN0YXJ0ID0gTnVtYmVyLnBhcnNlSW50KHRpbWluZ0luZm9BcnJbOF0pO1xuICAgICAgICAgICAgdGltaW5nSW5mby5yZWNlaXZlRmluaXNoID0gTnVtYmVyLnBhcnNlSW50KHRpbWluZ0luZm9BcnJbOV0pO1xuICAgICAgICAgICAgdGltaW5nSW5mby5kZWNvZGVTdGFydCA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzEwXSk7XG4gICAgICAgICAgICB0aW1pbmdJbmZvLmRlY29kZUZpbmlzaCA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzExXSk7XG4gICAgICAgICAgICB0aW1pbmdJbmZvLnJlbmRlclRpbWUgPSBOdW1iZXIucGFyc2VJbnQodGltaW5nSW5mb0FyclsxMl0pO1xuICAgICAgICAgICAgdGltaW5nSW5mby5pc091dGxpZXIgPSBOdW1iZXIucGFyc2VJbnQodGltaW5nSW5mb0FyclsxM10pID4gMDtcbiAgICAgICAgICAgIHRpbWluZ0luZm8uaXNUcmlnZ2VyZWRCeVRpbWVyID0gTnVtYmVyLnBhcnNlSW50KHRpbWluZ0luZm9BcnJbMTRdKSA+IDA7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgc29tZSBsYXRlbmN5IHN0YXRzXG4gICAgICAgICAgICB0aW1pbmdJbmZvLmVuY29kZXJMYXRlbmN5TXMgPSB0aW1pbmdJbmZvLmVuY29kZUZpbmlzaFRpbWVzdGFtcCAtIHRpbWluZ0luZm8uZW5jb2RlU3RhcnRUaW1lc3RhbXA7XG4gICAgICAgICAgICB0aW1pbmdJbmZvLnBhY2tldGl6ZUxhdGVuY3lNcyA9XG4gICAgICAgICAgICAgICAgdGltaW5nSW5mby5wYWNrZXRpemVyRmluaXNoVGltZXN0YW1wIC0gdGltaW5nSW5mby5lbmNvZGVGaW5pc2hUaW1lc3RhbXA7XG4gICAgICAgICAgICB0aW1pbmdJbmZvLnBhY2VyTGF0ZW5jeU1zID0gdGltaW5nSW5mby5wYWNlckV4aXRUaW1lc3RhbXAgLSB0aW1pbmdJbmZvLnBhY2tldGl6ZXJGaW5pc2hUaW1lc3RhbXA7XG4gICAgICAgICAgICB0aW1pbmdJbmZvLmNhcHR1cmVUb1NlbmRMYXRlbmN5TXMgPSB0aW1pbmdJbmZvLnBhY2VyRXhpdFRpbWVzdGFtcCAtIHRpbWluZ0luZm8uY2FwdHVyZVRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGltaW5nSW5mbztcbiAgICB9XG4gICAgY2FsY3VsYXRlU2VuZGVyTGF0ZW5jeShzdGF0cywgY2FwdHVyZVNvdXJjZSkge1xuICAgICAgICAvLyBUaGUgY2FsY3VsYXRpb24gcGVyZm9ybWVkIGluIHRoaXMgZnVuY3Rpb24gaXMgYXMgcGVyIHRoZSBwcm9jZWR1cmUgZGVmaW5lZCBoZXJlOlxuICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLWV4dGVuc2lvbnMvI2RvbS1ydGNydHBjb250cmlidXRpbmdzb3VyY2Utc2VuZGVyY2FwdHVyZXRpbWVvZmZzZXRcbiAgICAgICAgLy8gR2V0IHRoZSBzZW5kZXIgY2FwdHVyZSBpbiB0aGUgc2VuZGVyJ3MgY2xvY2tcbiAgICAgICAgY29uc3Qgc2VuZGVyQ2FwdHVyZVRpbWVzdGFtcCA9IGNhcHR1cmVTb3VyY2UuY2FwdHVyZVRpbWVzdGFtcCArIGNhcHR1cmVTb3VyY2Uuc2VuZGVyQ2FwdHVyZVRpbWVPZmZzZXQ7XG4gICAgICAgIGxldCBzZW5kUmVjdkNsb2NrT2Zmc2V0ID0gdGhpcy5jYWxjdWxhdGVTZW5kZXJSZWNlaXZlckNsb2NrT2Zmc2V0KHN0YXRzKTtcbiAgICAgICAgLy8gVXNlIGxhdGVzdCBjbG9jayBvZmZzZXQgaWYgd2UgY291bGRuJ3QgY2FsY3VsYXRlIG9uZSBub3dcbiAgICAgICAgaWYgKHNlbmRSZWN2Q2xvY2tPZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGF0ZXN0U2VuZGVyUmVjdkNsb2NrT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZW5kUmVjdkNsb2NrT2Zmc2V0ID0gdGhpcy5sYXRlc3RTZW5kZXJSZWN2Q2xvY2tPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0U2VuZGVyUmVjdkNsb2NrT2Zmc2V0ID0gc2VuZFJlY3ZDbG9ja09mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGJyaW5ncyBzZW5kZXIgY2xvY2sgcm91Z2hseSBpbmxpbmUgd2l0aCByZWN2IGNsb2NrXG4gICAgICAgIGNvbnN0IHJlY3ZDYXB0dXJlVGltZXN0YW1wTlRQID0gc2VuZGVyQ2FwdHVyZVRpbWVzdGFtcCArIHNlbmRSZWN2Q2xvY2tPZmZzZXQ7XG4gICAgICAgIC8vIEFzIGRlZmluZWQgaW4gQ2hyb21lIHNvdXJjZTogaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2V4dGVybmFsL3dlYnJ0Yy8rL21hc3Rlci9zeXN0ZW1fd3JhcHBlcnMvaW5jbHVkZS9jbG9jay5oIzI2XG4gICAgICAgIGNvbnN0IG50cDE5NzAgPSAyMjA4OTg4ODAwMDAwO1xuICAgICAgICBjb25zdCByZWN2Q2FwdHVyZVRpbWVzdGFtcCA9IHJlY3ZDYXB0dXJlVGltZXN0YW1wTlRQIC0gbnRwMTk3MDtcbiAgICAgICAgY29uc3Qgc2VuZGVyTGF0ZW5jeSA9IGNhcHR1cmVTb3VyY2UudGltZXN0YW1wIC0gcmVjdkNhcHR1cmVUaW1lc3RhbXA7XG4gICAgICAgIHJldHVybiBzZW5kZXJMYXRlbmN5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBmaXJzdCB2YWxpZCBzc3JjIG9yIGNzcmMgdGhhdCBoYXMgY2FwdHVyZSB0aW1lIGZpZWxkcyBwcmVzZW50IGZyb20gYWJzLWNhcHR1cmUtdGltZSBoZWFkZXIgZXh0ZW5zaW9uLlxuICAgICAqIEBwYXJhbSByZWNlaXZlcnMgVGhlIFJUUCByZWNldmllcnMgdGhpcyBwZWVyIGNvbm5lY3Rpb24gaGFzLlxuICAgICAqIEByZXR1cm5zIEEgc2luZ2xlIHZhbGlkIHNzcmMgb3IgY3NyYyB0aGF0IGhhcyBjYXB0dXJlIHRpbWUgZmllbGRzIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZSAoZS5nLiBpbiBub24tY2hyb21pdW0gYnJvd3NlcnMgaXQgd2lsbCBiZSBudWxsKS5cbiAgICAgKi9cbiAgICBnZXRDYXB0dXJlU291cmNlKHJlY2VpdmVycykge1xuICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdmlkZW8gcmVjZWl2ZXJzXG4gICAgICAgIHJlY2VpdmVycyA9IHJlY2VpdmVycy5maWx0ZXIoKHJlY2VpdmVyKSA9PiByZWNlaXZlci50cmFjay5raW5kID09PSAndmlkZW8nKTtcbiAgICAgICAgZm9yIChjb25zdCByZWNlaXZlciBvZiByZWNlaXZlcnMpIHtcbiAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggYWxsIHNzcmMgYW5kIGNzcmMgdG8gY2hlY2sgZm9yIGNhcHR1cmUgdGltZXN0YW1wXG4gICAgICAgICAgICAvLyBOb3RlOiBDb252ZXJzaW9uIHRvIGBhbnlgIGhlcmUgaXMgYmVjYXVzZSBUUyBkb2VzIG5vdCBoYXZlIGNhcHR1cmVUaW1lc3RhbXAgZXRjIGRlZmluZWQgaW4gdGhlIHR5cGVzXG4gICAgICAgICAgICAvLyB0aGVzZSBmaWVsZHMgb25seSBleGlzdCBpbiBDaHJvbWl1bSBjdXJyZW50bHkuXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VzID0gcmVjZWl2ZXJcbiAgICAgICAgICAgICAgICAuZ2V0U3luY2hyb25pemF0aW9uU291cmNlcygpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChyZWNlaXZlci5nZXRDb250cmlidXRpbmdTb3VyY2VzKCkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzcmMgb2Ygc291cmNlcykge1xuICAgICAgICAgICAgICAgIGlmIChzcmMuY2FwdHVyZVRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHNyYy5zZW5kZXJDYXB0dXJlVGltZU9mZnNldCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHNyYy50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXB0dXJlU3JjID0gbmV3IFJUQ1J0cENhcHR1cmVTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FwdHVyZVNyYy50aW1lc3RhbXAgPSBzcmMudGltZXN0YW1wO1xuICAgICAgICAgICAgICAgICAgICBjYXB0dXJlU3JjLmNhcHR1cmVUaW1lc3RhbXAgPSBzcmMuY2FwdHVyZVRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgY2FwdHVyZVNyYy5zZW5kZXJDYXB0dXJlVGltZU9mZnNldCA9IHNyYy5zZW5kZXJDYXB0dXJlVGltZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhcHR1cmVTcmM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjYWxjdWxhdGVTZW5kZXJSZWNlaXZlckNsb2NrT2Zmc2V0KHN0YXRzKSB7XG4gICAgICAgIC8vIFRoZSBjYWxjdWxhdGlvbiBwZXJmb3JtZWQgaW4gdGhpcyBmdW5jdGlvbiBpcyBhcyBwZXIgdGhlIHByb2NlZHVyZSBkZWZpbmVkIGhlcmU6XG4gICAgICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJydGMtZXh0ZW5zaW9ucy8jZG9tLXJ0Y3J0cGNvbnRyaWJ1dGluZ3NvdXJjZS1zZW5kZXJjYXB0dXJldGltZW9mZnNldFxuICAgICAgICBjb25zdCBoYXNSZW1vdGVPdXRib3VuZFZpZGVvU3RhdHMgPSBzdGF0cy5yZW1vdGVPdXRib3VuZFZpZGVvU3RhdHMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgc3RhdHMucmVtb3RlT3V0Ym91bmRWaWRlb1N0YXRzLnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzdGF0cy5yZW1vdGVPdXRib3VuZFZpZGVvU3RhdHMucmVtb3RlVGltZXN0YW1wICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIE5vdGU6IEFzIG9mIENocm9tZSAxMzIsIHJlbW90ZS1vdXRib3VuZC1ydHAgc3RhdHMgZm9yIHZpZGVvIGFyZSBub3QgeWV0IGltcGxlbWVudGVkIChhdWRpbyB3b3JrcykuXG4gICAgICAgIC8vIFRoaXMgY29kZXBhdGggc2hvdWxkIGFjdGl2YXRlIG9uY2UgdGhleSBkbyBiZWdpbiB0byB3b3JrLlxuICAgICAgICBpZiAoIWhhc1JlbW90ZU91dGJvdW5kVmlkZW9TdGF0cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVtb3RlU3RhdHNBcnJpdmVkVGltZXN0YW1wID0gc3RhdHMucmVtb3RlT3V0Ym91bmRWaWRlb1N0YXRzLnRpbWVzdGFtcDtcbiAgICAgICAgY29uc3QgcmVtb3RlU3RhdHNTZW50VGltZXN0YW1wID0gc3RhdHMucmVtb3RlT3V0Ym91bmRWaWRlb1N0YXRzLnJlbW90ZVRpbWVzdGFtcDtcbiAgICAgICAgY29uc3QgcnR0TXMgPSB0aGlzLmdldFJUVE1zKHN0YXRzKTtcbiAgICAgICAgaWYgKHJlbW90ZVN0YXRzQXJyaXZlZFRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICByZW1vdGVTdGF0c1NlbnRUaW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgcnR0TXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG9uZXdheURlbGF5ID0gcnR0TXMgKiAwLjU7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3RlU3RhdHNBcnJpdmVkVGltZXN0YW1wIC0gKHJlbW90ZVN0YXRzU2VudFRpbWVzdGFtcCArIG9uZXdheURlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb3VsZCBub3QgZ2V0IHN0YXRzIHRvIGNhbGN1bGF0ZSBzZW5kZXIvcmVjZWl2ZXIgY2xvY2sgb2Zmc2V0XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UlRUTXMoc3RhdHMpIHtcbiAgICAgICAgLy8gVHJ5IHRvIGdldCBpdCBmcm9tIHRoZSBhY3RpdmUgY2FuZGlkYXRlIHBhaXJcbiAgICAgICAgY29uc3QgYWN0aXZlQ2FuZGlkYXRlUGFpciA9IHN0YXRzLmdldEFjdGl2ZUNhbmRpZGF0ZVBhaXIoKTtcbiAgICAgICAgaWYgKCEhYWN0aXZlQ2FuZGlkYXRlUGFpciAmJiBhY3RpdmVDYW5kaWRhdGVQYWlyLmN1cnJlbnRSb3VuZFRyaXBUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1clJUVFNlY29uZHMgPSBhY3RpdmVDYW5kaWRhdGVQYWlyLmN1cnJlbnRSb3VuZFRyaXBUaW1lO1xuICAgICAgICAgICAgcmV0dXJuIGN1clJUVFNlY29uZHMgKiAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5leHQgdHJ5IHRvIGdldCBpdCBmcm9tIHJlbW90ZS1vdXRib3VuZC1ydHAgdmlkZW8gc3RhdHNcbiAgICAgICAgaWYgKCEhc3RhdHMucmVtb3RlT3V0Ym91bmRWaWRlb1N0YXRzICYmXG4gICAgICAgICAgICBzdGF0cy5yZW1vdGVPdXRib3VuZFZpZGVvU3RhdHMudG90YWxSb3VuZFRyaXBUaW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHN0YXRzLnJlbW90ZU91dGJvdW5kVmlkZW9TdGF0cy5yb3VuZFRyaXBUaW1lTWVhc3VyZW1lbnRzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHN0YXRzLnJlbW90ZU91dGJvdW5kVmlkZW9TdGF0cy5yb3VuZFRyaXBUaW1lTWVhc3VyZW1lbnRzID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYXZnUnR0U2Vjb25kcyA9IHN0YXRzLnJlbW90ZU91dGJvdW5kVmlkZW9TdGF0cy50b3RhbFJvdW5kVHJpcFRpbWUgL1xuICAgICAgICAgICAgICAgIHN0YXRzLnJlbW90ZU91dGJvdW5kVmlkZW9TdGF0cy5yb3VuZFRyaXBUaW1lTWVhc3VyZW1lbnRzO1xuICAgICAgICAgICAgcmV0dXJuIGF2Z1J0dFNlY29uZHMgKiAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5leHQgdHJ5IHRvIGdldCBpdCBmcm9tIHJlbW90ZS1vdXRib3VuZC1ydHAgYXVkaW8gc3RhdHNcbiAgICAgICAgaWYgKCEhc3RhdHMucmVtb3RlT3V0Ym91bmRBdWRpb1N0YXRzICYmXG4gICAgICAgICAgICBzdGF0cy5yZW1vdGVPdXRib3VuZEF1ZGlvU3RhdHMudG90YWxSb3VuZFRyaXBUaW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHN0YXRzLnJlbW90ZU91dGJvdW5kQXVkaW9TdGF0cy5yb3VuZFRyaXBUaW1lTWVhc3VyZW1lbnRzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHN0YXRzLnJlbW90ZU91dGJvdW5kQXVkaW9TdGF0cy5yb3VuZFRyaXBUaW1lTWVhc3VyZW1lbnRzID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYXZnUnR0U2Vjb25kcyA9IHN0YXRzLnJlbW90ZU91dGJvdW5kQXVkaW9TdGF0cy50b3RhbFJvdW5kVHJpcFRpbWUgL1xuICAgICAgICAgICAgICAgIHN0YXRzLnJlbW90ZU91dGJvdW5kQXVkaW9TdGF0cy5yb3VuZFRyaXBUaW1lTWVhc3VyZW1lbnRzO1xuICAgICAgICAgICAgcmV0dXJuIGF2Z1J0dFNlY29uZHMgKiAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGxhdGVuY3kgaW5mb3JtYXRpb24gY2FsY3VsYXRlZCB1c2luZyB0aGUgV2ViUlRDIEFQSS5cbiAqIE1vc3Qgc3RhdHMgYXJlIGNhbGN1bGF0ZWQgZm9sbG93aW5nIHRoZSBzcGVjOlxuICogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1zdGF0cy8jZGljdGlvbmFyeS1ydGNpbmJvdW5kcnRwc3RyZWFtc3RhdHMtbWVtYmVyc1xuICovXG5leHBvcnQgY2xhc3MgTGF0ZW5jeUluZm8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWUgdGFrZW4gZnJvbSB0aGUgbW9tZW50IGEgZnJhbWUgaXMgZG9uZSBjYXB0dXJpbmcgdG8gdGhlIG1vbWVudCBpdCBpcyBzZW50IG92ZXIgdGhlIG5ldHdvcmsuXG4gICAgICAgICAqIE5vdGU6IFRoaXMgY2FuIG9ubHkgYmUgY2FsY3VsYXRlZCBpZiBib3RoIG9mZmVyIGFuZCBhbnN3ZXIgY29udGFpbiB0aGVcbiAgICAgICAgICogdGhlIFJUUCBoZWFkZXIgZXh0ZW5zaW9uIGZvciBgdmlkZW8tdGltaW5nYCAoQ2hyb21lIG9ubHkgZm9yIG5vdylcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VuZGVyTGF0ZW5jeU1zID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWUgdGFrZW4gZnJvbSB0aGUgbW9tZW50IGEgZnJhbWUgaXMgZG9uZSBjYXB0dXJpbmcgdG8gdGhlIG1vbWVudCBpdCBpcyBzZW50IG92ZXIgdGhlIG5ldHdvcmsuXG4gICAgICAgICAqIE5vdGU6IFRoaXMgY2FuIG9ubHkgYmUgY2FsY3VsYXRlZCBpZiBib3RoIG9mZmVyIGFuZCBhbnN3ZXIgY29udGFpbiB0aGVcbiAgICAgICAgICogdGhlIFJUUCBoZWFkZXIgZXh0ZW5zaW9uIGZvciBgYWJzLWNhcHR1cmUtdGltZWAgKENocm9tZSBvbmx5IGZvciBub3cpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbmRlckxhdGVuY3lBYnNDYXB0dXJlVGltZU1zID0gdW5kZWZpbmVkO1xuICAgICAgICAvKiBUaGUgcm91bmQgdHJpcCB0aW1lIChtaWxsaXNlY29uZHMpIGJldHdlZW4gZWFjaCBzZW5kZXItPnJlY2VpdmVyLT5zZW5kZXIgKi9cbiAgICAgICAgdGhpcy5ydHRNcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyogQXZlcmFnZSB0aW1lIHRha2VuIChtaWxsaXNlY29uZHMpIGZyb20gdmlkZW8gcGFja2V0IHJlY2VpcHQgdG8gcG9zdC1kZWNvZGUuICovXG4gICAgICAgIHRoaXMuYXZlcmFnZVByb2Nlc3NpbmdEZWxheU1zID0gdW5kZWZpbmVkO1xuICAgICAgICAvKiBBdmVyYWdlIHRpbWUgdGFrZW4gKG1pbGxpc2Vjb25kcykgaW5zaWRlIHRoZSBqaXR0ZXIgYnVmZmVyICh3aGljaCBpcyBwb3N0LXJlY2VpcHQgYnV0IHByZS1kZWNvZGUpLiAqL1xuICAgICAgICB0aGlzLmF2ZXJhZ2VKaXR0ZXJCdWZmZXJEZWxheU1zID0gdW5kZWZpbmVkO1xuICAgICAgICAvKiBBdmVyYWdlIHRpbWUgdGFrZW4gKG1pbGxpc2Vjb25kcykgdG8gZGVjb2RlIGEgdmlkZW8gZnJhbWUuICovXG4gICAgICAgIHRoaXMuYXZlcmFnZURlY29kZUxhdGVuY3lNcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyogQXZlcmFnZSB0aW1lIHRha2VuIChtaWxsaXNlY29uZHMpIHRvIGJldHdlZW4gcmVjZWlwdCBvZiB0aGUgZmlyc3QgYW5kIGxhc3QgdmlkZW8gcGFja2V0IG9mIGEuICovXG4gICAgICAgIHRoaXMuYXZlcmFnZUFzc2VtYmx5RGVsYXlNcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyogVGhlIHNlbmRlciBsYXRlbmN5ICsgUlRULzIgKyBwcm9jZXNzaW5nIGRlbGF5ICovXG4gICAgICAgIHRoaXMuYXZlcmFnZUUyRUxhdGVuY3kgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qIFRpbWluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgd29yc3QgcGVyZm9ybWluZyBmcmFtZSBzaW5jZSB0aGUgbGFzdCBnZXRTdGF0cyBjYWxsIChvbmx5IHdvcmtzIG9uIENocm9tZSkgKi9cbiAgICAgICAgdGhpcy5mcmFtZVRpbWluZyA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYXRlbmN5Q2FsY3VsYXRvci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBPdXRib3VuZCBSVFAgc3RhdHMgY29sbGVjdGVkIGZyb20gdGhlIFJUQyBTdGF0cyBSZXBvcnQgdW5kZXIgYG91dGJvdW5kLXJ0cGAuXG4gKiBXcmFwcGVyIGFyb3VuZDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ091dGJvdW5kUnRwU3RyZWFtU3RhdHNcbiAqIFRoZXNlIGFyZSBzdGF0cyBmb3IgdmlkZW8gd2UgYXJlIHNlbmRpbmcgdG8gYSByZW1vdGUgcGVlci5cbiAqL1xuZXhwb3J0IGNsYXNzIE91dGJvdW5kUlRQU3RhdHMge1xufVxuLyoqXG4gKiBSZW1vdGUgb3V0Ym91bmQgc3RhdHMgY29sbGVjdGVkIGZyb20gdGhlIFJUQyBTdGF0cyBSZXBvcnQgdW5kZXIgYHJlbW90ZS1vdXRib3VuZC1ydHBgLlxuICogV3JhcHBlciBhcm91bmQ6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENSZW1vdGVPdXRib3VuZFJ0cFN0cmVhbVN0YXRzXG4gKiBUaGVzZSBhcmUgc3RhdHMgZm9yIG1lZGlhIHdlIGFyZSByZWNlaXZpbmcgZnJvbSBhIHJlbW90ZSBwZWVyLlxuICovXG5leHBvcnQgY2xhc3MgUmVtb3RlT3V0Ym91bmRSVFBTdGF0cyB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PdXRCb3VuZFJUUFN0YXRzLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42JztcbmltcG9ydCB7IE9wdGlvblBhcmFtZXRlcnMsIEZsYWdzIH0gZnJvbSAnLi4vQ29uZmlnL0NvbmZpZyc7XG5pbXBvcnQgeyBBZ2dyZWdhdGVkU3RhdHMgfSBmcm9tICcuL0FnZ3JlZ2F0ZWRTdGF0cyc7XG5pbXBvcnQgeyBwYXJzZVJ0cFBhcmFtZXRlcnMsIHNwbGl0U2VjdGlvbnMgfSBmcm9tICdzZHAnO1xuaW1wb3J0IHsgUlRDVXRpbHMgfSBmcm9tICcuLi9VdGlsL1JUQ1V0aWxzJztcbmltcG9ydCB7IFNEUFV0aWxzIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuaW1wb3J0IHsgTGF0ZW5jeUNhbGN1bGF0b3IgfSBmcm9tICcuL0xhdGVuY3lDYWxjdWxhdG9yJztcbmV4cG9ydCBjb25zdCBrQWJzQ2FwdHVyZVRpbWUgPSAnaHR0cDovL3d3dy53ZWJydGMub3JnL2V4cGVyaW1lbnRzL3J0cC1oZHJleHQvYWJzLWNhcHR1cmUtdGltZSc7XG4vKipcbiAqIEhhbmRsZXMgdGhlIFBlZXIgQ29ubmVjdGlvblxuICovXG5leHBvcnQgY2xhc3MgUGVlckNvbm5lY3Rpb25Db250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgUlRDIFBlZXIgQ29ubmVjdGlvbiBjbGllbnRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBlZXIgY29ubmVjdGlvbiBPcHRpb25zXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWcgZm9yIG91ciBQUyBleHBlcmllbmNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNvbmZpZywgcHJlZmVycmVkQ29kZWMpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuY3JlYXRlUGVlckNvbm5lY3Rpb24ob3B0aW9ucywgcHJlZmVycmVkQ29kZWMpO1xuICAgICAgICB0aGlzLmxhdGVuY3lDYWxjdWxhdG9yID0gbmV3IExhdGVuY3lDYWxjdWxhdG9yKCk7XG4gICAgfVxuICAgIGNyZWF0ZVBlZXJDb25uZWN0aW9uKG9wdGlvbnMsIHByZWZlcnJlZENvZGVjKSB7XG4gICAgICAgIC8vIFNldCB0aGUgSUNFIHRyYW5zcG9ydCB0byByZWxheSBpZiBUVVJOIGVuYWJsZWRcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuRm9yY2VUVVJOKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5pY2VUcmFuc3BvcnRQb2xpY3kgPSAncmVsYXknO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ0ZvcmNpbmcgVFVSTiB1c2FnZSBieSBzZXR0aW5nIElDRSBUcmFuc3BvcnQgUG9saWN5IGluIHBlZXIgY29ubmVjdGlvbiBjb25maWcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnVpbGQgYSBuZXcgcGVlciBjb25uZWN0aW9uIHdpdGggdGhlIG9wdGlvbnNcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbiA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlID0gKGV2KSA9PiB0aGlzLmhhbmRsZVNpZ25hbFN0YXRlQ2hhbmdlKGV2KTtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IChldikgPT4gdGhpcy5oYW5kbGVJY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UoZXYpO1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UgPSAoZXYpID0+IHRoaXMuaGFuZGxlSWNlR2F0aGVyaW5nU3RhdGVDaGFuZ2UoZXYpO1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9udHJhY2sgPSAoZXYpID0+IHRoaXMuaGFuZGxlT25UcmFjayhldik7XG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25pY2VjYW5kaWRhdGUgPSAoZXYpID0+IHRoaXMuaGFuZGxlSWNlQ2FuZGlkYXRlKGV2KTtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmRhdGFjaGFubmVsID0gKGV2KSA9PiB0aGlzLmhhbmRsZURhdGFDaGFubmVsKGV2KTtcbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVkU3RhdHMgPSBuZXcgQWdncmVnYXRlZFN0YXRzKCk7XG4gICAgICAgIHRoaXMucHJlZmVycmVkQ29kZWMgPSBwcmVmZXJyZWRDb2RlYztcbiAgICAgICAgdGhpcy51cGRhdGVDb2RlY1NlbGVjdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBvZmZlciBmb3IgdGhlIFdlYiBSVEMgaGFuZHNoYWtlIGFuZCBzZW5kIHRoZSBvZmZlciB0byB0aGUgc2lnbmFsaW5nIHNlcnZlciB2aWEgd2Vic29ja2V0XG4gICAgICogQHBhcmFtIG9mZmVyT3B0aW9ucyAtIFJUQyBPZmZlciBPcHRpb25zXG4gICAgICovXG4gICAgY3JlYXRlT2ZmZXIob2ZmZXJPcHRpb25zLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdDcmVhdGUgT2ZmZXInKTtcbiAgICAgICAgICAgIGNvbnN0IGlzTG9jYWxob3N0Q29ubmVjdGlvbiA9IGxvY2F0aW9uLmhvc3RuYW1lID09PSAnbG9jYWxob3N0JyB8fCBsb2NhdGlvbi5ob3N0bmFtZSA9PT0gJzEyNy4wLjAuMSc7XG4gICAgICAgICAgICBjb25zdCBpc0h0dHBzQ29ubmVjdGlvbiA9IGxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgICAgICAgICAgIGxldCB1c2VNaWMgPSBjb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5Vc2VNaWMpO1xuICAgICAgICAgICAgbGV0IHVzZUNhbWVyYSA9IGNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLlVzZUNhbWVyYSk7XG4gICAgICAgICAgICBpZiAoKHVzZU1pYyB8fCB1c2VDYW1lcmEpICYmICEoaXNMb2NhbGhvc3RDb25uZWN0aW9uIHx8IGlzSHR0cHNDb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHVzZU1pYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHVzZUNhbWVyYSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcignTWljcm9waG9uZSBhbmQgV2ViY2FtIGFjY2VzcyBpbiB0aGUgYnJvd3NlciB3aWxsIG5vdCB3b3JrIGlmIHlvdSBhcmUgbm90IG9uIEhUVFBTIG9yIGxvY2FsaG9zdC4gRGlzYWJsaW5nIG1pYyBhbmQgd2ViY2FtIGFjY2Vzcy4nKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoXCJGb3IgdGVzdGluZyB5b3UgY2FuIGVuYWJsZSBIVFRQIG1pY3JvcGhvbmUgYWNjZXNzIENocm9tZSBieSB2aXNpdGluZyBjaHJvbWU6Ly9mbGFncy8gYW5kIGVuYWJsaW5nICd1bnNhZmVseS10cmVhdC1pbnNlY3VyZS1vcmlnaW4tYXMtc2VjdXJlJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0dXBUcmFuc2NlaXZlcnNBc3luYyh1c2VNaWMsIHVzZUNhbWVyYSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jcmVhdGVPZmZlcihvZmZlck9wdGlvbnMpLnRoZW4oKG9mZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93VGV4dE92ZXJsYXlDb25uZWN0aW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIG9mZmVyLnNkcCA9IHRoaXMubXVuZ2VTRFAob2ZmZXIuc2RwLCB1c2VNaWMpO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TZW5kV2ViUlRDT2ZmZXIob2ZmZXIpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93VGV4dE92ZXJsYXlTZXR1cEZhaWx1cmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjZWl2ZSBvZmZlciBmcm9tIFVFIHNpZGUgYW5kIHByb2Nlc3MgaXQgYXMgdGhlIHJlbW90ZSBkZXNjcmlwdGlvbiBvZiB0aGlzIHBlZXIgY29ubmVjdGlvblxuICAgICAqL1xuICAgIHJlY2VpdmVPZmZlcihvZmZlciwgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnUmVjZWl2ZSBPZmZlcicpO1xuICAgICAgICAgICAgLy8gSWYgVUUgb3IgSlNTdHJlYW1lciBkaWQgc2VuZCBhYnMtY2FwdHVyZS10aW1lIFJUUCBoZWFkZXIgZXh0ZW5zaW9uIHRvIGEgbm9uLUNocm9tZSBicm93c2VyXG4gICAgICAgICAgICAvLyB0aGVuIHJlbW92ZSBpdCBmcm9tIHRoZSBTRFAgYmVjYXVzZSBpZiBGaXJlZm94IGRldGVjdHMgaXQgaW4gb2ZmZXIgb3IgYW5zd2VyIGl0IHdpbGwgZmFpbCB0byBjb25uZWN0XG4gICAgICAgICAgICAvLyBkdWUgaGF2aW5nIDE1IG9yIG1vcmUgaGVhZGVyIGV4dGVuc2lvbnM6IGh0dHBzOi8vbWFpbGFyY2hpdmUuaWV0Zi5vcmcvYXJjaC9tc2cvcnRjd2ViL1FSbldOdVd6R3VMUm92V2RIa29kTlA2Vk9nZy9cbiAgICAgICAgICAgIGlmICh0aGlzLmlzRmlyZWZveCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gZXhhbXBsZTogYT1leHRtYXA6MTUgaHR0cDovL3d3dy53ZWJydGMub3JnL2V4cGVyaW1lbnRzL3J0cC1oZHJleHQvYWJzLWNhcHR1cmUtdGltZVxuICAgICAgICAgICAgICAgIG9mZmVyLnNkcCA9IG9mZmVyLnNkcC5yZXBsYWNlKC9eYT1leHRtYXA6XFxkKyBodHRwOlxcL1xcL3d3d1xcLndlYnJ0Y1xcLm9yZ1xcL2V4cGVyaW1lbnRzXFwvcnRwLWhkcmV4dFxcL2Ficy1jYXB0dXJlLXRpbWVcXHJcXG4vZ20sICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYSA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcikudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRmlyZSBldmVudCBmb3Igd2hlbiByZW1vdGUgb2ZmZXIgZGVzY3JpcHRpb24gaXMgc2V0XG4gICAgICAgICAgICAgICAgdGhpcy5vblNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0xvY2FsaG9zdENvbm5lY3Rpb24gPSBsb2NhdGlvbi5ob3N0bmFtZSA9PT0gJ2xvY2FsaG9zdCcgfHwgbG9jYXRpb24uaG9zdG5hbWUgPT09ICcxMjcuMC4wLjEnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzSHR0cHNDb25uZWN0aW9uID0gbG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonO1xuICAgICAgICAgICAgICAgIGxldCB1c2VNaWMgPSBjb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5Vc2VNaWMpO1xuICAgICAgICAgICAgICAgIGxldCB1c2VDYW1lcmEgPSBjb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5Vc2VDYW1lcmEpO1xuICAgICAgICAgICAgICAgIGlmICgodXNlTWljIHx8IHVzZUNhbWVyYSkgJiYgIShpc0xvY2FsaG9zdENvbm5lY3Rpb24gfHwgaXNIdHRwc0Nvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZU1pYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB1c2VDYW1lcmEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKCdNaWNyb3Bob25lIGFuZCBXZWJjYW0gYWNjZXNzIGluIHRoZSBicm93c2VyIHdpbGwgbm90IHdvcmsgaWYgeW91IGFyZSBub3Qgb24gSFRUUFMgb3IgbG9jYWxob3N0LiBEaXNhYmxpbmcgbWljIGFuZCB3ZWJjYW0gYWNjZXNzLicpO1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoXCJGb3IgdGVzdGluZyB5b3UgY2FuIGVuYWJsZSBIVFRQIG1pY3JvcGhvbmUgYWNjZXNzIENocm9tZSBieSB2aXNpdGluZyBjaHJvbWU6Ly9mbGFncy8gYW5kIGVuYWJsaW5nICd1bnNhZmVseS10cmVhdC1pbnNlY3VyZS1vcmlnaW4tYXMtc2VjdXJlJ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIG91ciBsaXN0IG9mIHByZWZlcnJlZCBjb2RlY3MsIGluIG9yZGVyIG9mIHByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXRPcHRpb25TZXR0aW5nT3B0aW9ucyhPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZENvZGVjLCB0aGlzLmZ1enp5SW50ZXJzZWN0VUVBbmRCcm93c2VyQ29kZWNzKG9mZmVyKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR1cFRyYW5zY2VpdmVyc0FzeW5jKHVzZU1pYywgdXNlQ2FtZXJhKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3JlYXRlQW5zd2VyKCkudGhlbigoQW5zd2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICBBbnN3ZXIuc2RwID0gdGhpcy5tdW5nZVNEUChBbnN3ZXIuc2RwLCB1c2VNaWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRMb2NhbERlc2NyaXB0aW9uKEFuc3dlcik7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNldExvY2FsRGVzY3JpcHRpb24oKF9hID0gdGhpcy5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoYGNyZWF0ZUFuc3dlcigpIGZhaWxlZCAtICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBSZW1vdGUgRGVzY3JpcHRvciBmcm9tIHRoZSBzaWduYWxpbmcgc2VydmVyIHRvIHRoZSBSVEMgUGVlciBDb25uZWN0aW9uXG4gICAgICogQHBhcmFtIGFuc3dlciAtIFJUQyBTZXNzaW9uIERlc2NyaXB0b3IgZnJvbSB0aGUgU2lnbmFsaW5nIFNlcnZlclxuICAgICAqL1xuICAgIHJlY2VpdmVBbnN3ZXIoYW5zd2VyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIC8vIEFkZCBvdXIgbGlzdCBvZiBwcmVmZXJyZWQgY29kZWNzLCBpbiBvcmRlciBvZiBwcmVmZXJlbmNlXG4gICAgICAgIHRoaXMuY29uZmlnLnNldE9wdGlvblNldHRpbmdPcHRpb25zKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkQ29kZWMsIHRoaXMuZnV6enlJbnRlcnNlY3RVRUFuZEJyb3dzZXJDb2RlY3MoYW5zd2VyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIEFnZ3JlZ2F0ZWQgU3RhdHMgYW5kIHRoZW4gZmlyZSBhIG9uVmlkZW8gU3RhdHMgZXZlbnRcbiAgICAgKi9cbiAgICBnZW5lcmF0ZVN0YXRzKCkge1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmdldFN0YXRzKCkudGhlbigoc3RhdHNEYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFnZ3JlZ2F0ZWRTdGF0cy5wcm9jZXNzU3RhdHMoc3RhdHNEYXRhKTtcbiAgICAgICAgICAgIHRoaXMub25WaWRlb1N0YXRzKHRoaXMuYWdncmVnYXRlZFN0YXRzKTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBsYXRlbmN5IHVzaW5nIHN0YXRzIGFuZCB2aWRlbyByZWNlaXZlcnMgYW5kIHRoZW4gY2FsbCB0aGUgaGFuZGxpbmcgZnVuY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IGxhdGVuY3lJbmZvID0gdGhpcy5sYXRlbmN5Q2FsY3VsYXRvci5jYWxjdWxhdGUodGhpcy5hZ2dyZWdhdGVkU3RhdHMsIHRoaXMucGVlckNvbm5lY3Rpb24uZ2V0UmVjZWl2ZXJzKCkpO1xuICAgICAgICAgICAgdGhpcy5vbkxhdGVuY3lDYWxjdWxhdGVkKGxhdGVuY3lJbmZvKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJlZmVycmVkIGNvZGVjIHNlbGVjdGlvbiBiYXNlZCBvbiB3aGF0IHdhcyBhY3R1YWxseSBuZWdvdGlhdGVkXG4gICAgICAgICAgICBpZiAodGhpcy51cGRhdGVDb2RlY1NlbGVjdGlvbiAmJiAhIXRoaXMuYWdncmVnYXRlZFN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmNvZGVjSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIHF1YWxpZmllZCBjb2RlYyBuYW1lIGZyb20gdGhlIG1pbWV0eXBlIGFuZCBmbXRwXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZWNTdGF0cyA9IHRoaXMuYWdncmVnYXRlZFN0YXRzLmNvZGVjcy5nZXQodGhpcy5hZ2dyZWdhdGVkU3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuY29kZWNJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVjU3RhdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVjU2hvcnRuYW1lID0gY29kZWNTdGF0cy5taW1lVHlwZS5yZXBsYWNlKCd2aWRlby8nLCAnJyk7XG4gICAgICAgICAgICAgICAgbGV0IGZ1bGxDb2RlY05hbWUgPSBjb2RlY1Nob3J0bmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZWNTdGF0cy5zZHBGbXRwTGluZSAmJiBjb2RlY1N0YXRzLnNkcEZtdHBMaW5lLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVsbENvZGVjTmFtZSA9IGAke2NvZGVjU2hvcnRuYW1lfSAke2NvZGVjU3RhdHMuc2RwRm10cExpbmUudHJpbSgpfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbEJyb3dzZXJDb2RlY3MgPSB0aGlzLmNvbmZpZy5nZXRTZXR0aW5nT3B0aW9uKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkQ29kZWMpLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGxpc3Qgb2YgY29kZWNzIGRpcmVjdGx5IGNvbnRhaW5zIHRoZSBvbmUgdGhhdCB3YXMgbmVnb3RpYXRlZCwgc2VsZWN0IHRoYXRcbiAgICAgICAgICAgICAgICBpZiAoYWxsQnJvd3NlckNvZGVjcy5pbmNsdWRlcyhmdWxsQ29kZWNOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXRPcHRpb25TZXR0aW5nVmFsdWUoT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRDb2RlYywgZnVsbENvZGVjTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgY291bGRuJ3QgbWF0Y2ggb24gdGhlIGZ1bGwgbmFtZSwgdHJ5IHRvIG1hdGNoIG9uIGp1c3QgdGhlIGNvZGVjIHNob3J0bmFtZVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkTGlzdCA9IGFsbEJyb3dzZXJDb2RlY3MuZmlsdGVyKChvcHRpb24pID0+IG9wdGlvbi5pbmRleE9mKGNvZGVjU2hvcnRuYW1lKSAhPT0gLTEpO1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJlZExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXRPcHRpb25TZXR0aW5nVmFsdWUoT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRDb2RlYywgZmlsdGVyZWRMaXN0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIFRoZSBQZWVyIENvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vZGlmeSB0aGUgU2Vzc2lvbiBEZXNjcmlwdG9yXG4gICAgICogQHBhcmFtIHNkcCAtIFNlc3Npb24gRGVzY3JpcHRvciBhcyBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB1c2VNaWMgLSBJcyB0aGUgbWljcm9waG9uZSBpbiB1c2VcbiAgICAgKiBAcmV0dXJucyBBIG1vZGlmaWVkIFNlc3Npb24gRGVzY3JpcHRvclxuICAgICAqL1xuICAgIG11bmdlU0RQKHNkcCwgdXNlTWljKSB7XG4gICAgICAgIGxldCBtdW5nZWRTRFAgPSBzZHAucmVwbGFjZSgvKGE9Zm10cDpcXGQrIC4qbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQ9LiopXFxyXFxuL2dtLCAnJDE7eC1nb29nbGUtc3RhcnQtYml0cmF0ZT0xMDAwMDt4LWdvb2dsZS1tYXgtYml0cmF0ZT0xMDAwMDBcXHJcXG4nKTtcbiAgICAgICAgLy8gc2V0IG1heCBiaXRyYXRlIHRvIGhpZ2hlc3QgYml0cmF0ZSBPcHVzIHN1cHBvcnRzXG4gICAgICAgIGxldCBhdWRpb1NEUCA9ICdtYXhhdmVyYWdlYml0cmF0ZT01MTAwMDA7JztcbiAgICAgICAgaWYgKHVzZU1pYykge1xuICAgICAgICAgICAgLy8gc2V0IHRoZSBtYXggY2FwdHVyZSByYXRlIHRvIDQ4a2h6IChzbyB3ZSBjYW4gc2VuZCBoaWdoIHF1YWxpdHkgYXVkaW8gZnJvbSBtaWMpXG4gICAgICAgICAgICBhdWRpb1NEUCArPSAnc3Byb3AtbWF4Y2FwdHVyZXJhdGU9NDgwMDA7JztcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3JjZSBtb25vIG9yIHN0ZXJlbyBiYXNlZCBvbiB3aGV0aGVyID9mb3JjZU1vbm8gd2FzIHBhc3NlZCBvciBub3RcbiAgICAgICAgYXVkaW9TRFAgKz0gdGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5Gb3JjZU1vbm9BdWRpbykgPyAnc3RlcmVvPTA7JyA6ICdzdGVyZW89MTsnO1xuICAgICAgICAvLyBlbmFibGUgaW4tYmFuZCBmb3J3YXJkIGVycm9yIGNvcnJlY3Rpb24gZm9yIG9wdXMgYXVkaW9cbiAgICAgICAgYXVkaW9TRFAgKz0gJ3VzZWluYmFuZGZlYz0xJztcbiAgICAgICAgLy8gV2UgdXNlIHRoZSBsaW5lICd1c2VpbmJhbmRmZWM9MScgKHdoaWNoIE9wdXMgdXNlcykgdG8gc2V0IG91ciBPcHVzIHNwZWNpZmljIGF1ZGlvIHBhcmFtZXRlcnMuXG4gICAgICAgIG11bmdlZFNEUCA9IG11bmdlZFNEUC5yZXBsYWNlKCd1c2VpbmJhbmRmZWM9MScsIGF1ZGlvU0RQKTtcbiAgICAgICAgLy8gQWRkIGFicy1jYXB0dXJlLXRpbWUgUlRQIGhlYWRlciBleHRlbnNpb24gaWYgd2UgaGF2ZSBlbmFibGVkIHRoZSBzZXR0aW5nLlxuICAgICAgICAvLyBOb3RlOiBBcyBhdCBGZWIgMjAyNSwgQ2hyb21pdW0gYmFzZWQgYnJvd3NlcnMgYXJlIHRoZSBvbmx5IG9uZXMgdGhhdCBzdXBwb3J0IHRoaXMgYW5kXG4gICAgICAgIC8vIG11bmdpbmcgaXQgaW50byB0aGUgYW5zd2VyIGluIEZpcmVmb3ggd2lsbCBjYXVzZSB0aGUgY29ubmVjdGlvbiB0byBmYWlsLlxuICAgICAgICBpZiAodGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5FbmFibGVDYXB0dXJlVGltZUV4dCkgJiYgIXRoaXMuaXNGaXJlZm94KCkpIHtcbiAgICAgICAgICAgIG11bmdlZFNEUCA9IFNEUFV0aWxzLmFkZFZpZGVvSGVhZGVyRXh0ZW5zaW9uVG9TZHAobXVuZ2VkU0RQLCBrQWJzQ2FwdHVyZVRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtdW5nZWRTRFA7XG4gICAgfVxuICAgIGlzRmlyZWZveCgpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiBhIEljZSBDYW5kaWRhdGUgaXMgcmVjZWl2ZWQgYWRkIHRvIHRoZSBSVEMgUGVlciBDb25uZWN0aW9uXG4gICAgICogQHBhcmFtIGljZUNhbmRpZGF0ZSAtIFJUQyBJY2UgQ2FuZGlkYXRlIGZyb20gdGhlIFNpZ25hbGluZyBTZXJ2ZXJcbiAgICAgKi9cbiAgICBoYW5kbGVPbkljZShpY2VDYW5kaWRhdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBMb2dnZXIuSW5mbygncGVlcmNvbm5lY3Rpb24gaGFuZGxlT25JY2UnKTtcbiAgICAgICAgLy8gLy8gaWYgZm9yY2luZyBUVVJOLCByZWplY3QgYW55IGNhbmRpZGF0ZXMgbm90IHJlbGF5XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkZvcmNlVFVSTikpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIG5vIHJlbGF5IGFkZHJlc3MgaXMgZm91bmQsIGlmIHNvLCB3ZSBhcmUgYXNzdW1pbmcgaXQgbWVhbnMgbm8gVFVSTiBzZXJ2ZXJcbiAgICAgICAgICAgIGlmIChpY2VDYW5kaWRhdGUuY2FuZGlkYXRlLmluZGV4T2YoJ3JlbGF5JykgPCAwKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkluZm8oYERyb3BwaW5nIGNhbmRpZGF0ZSBiZWNhdXNlIGl0IHdhcyBub3QgVFVSTiByZWxheS4gfCBUeXBlPSAke2ljZUNhbmRpZGF0ZS50eXBlfSB8IFByb3RvY29sPSAke2ljZUNhbmRpZGF0ZS5wcm90b2NvbH0gfCBBZGRyZXNzPSR7aWNlQ2FuZGlkYXRlLmFkZHJlc3N9IHwgUG9ydD0ke2ljZUNhbmRpZGF0ZS5wb3J0fSB8YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRJY2VDYW5kaWRhdGUoaWNlQ2FuZGlkYXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgUlRDIFBlZXIgQ29ubmVjdGlvbiBTaWduYWxpbmcgc2VydmVyIHN0YXRlIENoYW5nZXNcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBTaWduYWxpbmcgU2VydmVyIFN0YXRlIENoYW5nZSBFdmVudFxuICAgICAqL1xuICAgIGhhbmRsZVNpZ25hbFN0YXRlQ2hhbmdlKHN0YXRlKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCdzaWduYWxpbmcgc3RhdGUgY2hhbmdlOiAnICsgc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgd2hlbiB0aGUgSWNlIENvbm5lY3Rpb24gU3RhdGUgQ2hhbmdlc1xuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEljZSBDb25uZWN0aW9uIFN0YXRlXG4gICAgICovXG4gICAgaGFuZGxlSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKHN0YXRlKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCdpY2UgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2U6ICcgKyBzdGF0ZSk7XG4gICAgICAgIHRoaXMub25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgd2hlbiB0aGUgSWNlIEdhdGhlcmluZyBTdGF0ZSBDaGFuZ2VzXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSWNlIEdhdGhlcmluZyBTdGF0ZSBDaGFuZ2VcbiAgICAgKi9cbiAgICBoYW5kbGVJY2VHYXRoZXJpbmdTdGF0ZUNoYW5nZShzdGF0ZSkge1xuICAgICAgICBMb2dnZXIuSW5mbygnaWNlIGdhdGhlcmluZyBzdGF0ZSBjaGFuZ2U6ICcgKyBKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIG9uVHJhY2sgbWV0aG9kXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIHdlYlJ0YyB0cmFjayBldmVudFxuICAgICAqL1xuICAgIGhhbmRsZU9uVHJhY2soZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnN0cmVhbXMubGVuZ3RoIDwgMSB8fCBldmVudC5zdHJlYW1zWzBdLmlkID09ICdwcm9iYXRvcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQudHJhY2sua2luZCA9PSAndmlkZW8nKSB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvVHJhY2sgPSBldmVudC50cmFjaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQudHJhY2sua2luZCA9PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvVHJhY2sgPSBldmVudC50cmFjaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uVHJhY2soZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIG9uUGVlckljZUNhbmRpZGF0ZVxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBwZWVyIGljZSBjYW5kaWRhdGVcbiAgICAgKi9cbiAgICBoYW5kbGVJY2VDYW5kaWRhdGUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5vblBlZXJJY2VDYW5kaWRhdGUoZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIG9uRGF0YUNoYW5uZWxcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgcGVlcidzIGRhdGEgY2hhbm5lbFxuICAgICAqL1xuICAgIGhhbmRsZURhdGFDaGFubmVsKGV2ZW50KSB7XG4gICAgICAgIHRoaXMub25EYXRhQ2hhbm5lbChldmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIG92ZXJyaWRlIG1ldGhvZCBmb3Igb25UcmFjayBmb3IgdXNlIG91dHNpZGUgb2YgdGhlIFBlZXJDb25uZWN0aW9uQ29udHJvbGxlclxuICAgICAqIEBwYXJhbSB0cmFja0V2ZW50IC0gVGhlIHdlYlJ0YyB0cmFjayBldmVudFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBvblRyYWNrKHRyYWNrRXZlbnQpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBGdW5jdGlvbmFsaXR5OiBEbyBOb3RoaW5nXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIG92ZXJyaWRlIG1ldGhvZCBmb3Igb25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UgZm9yIHVzZSBvdXRzaWRlIG9mIHRoZSBQZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgd2ViUnRjIGljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSBldmVudFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBvbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZShldmVudCkge1xuICAgICAgICAvLyBEZWZhdWx0IEZ1bmN0aW9uYWxpdHk6IERvIE5vdGhpbmdcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gb3ZlcnJpZGUgbWV0aG9kIGZvciBvblBlZXJJY2VDYW5kaWRhdGUgZm9yIHVzZSBvdXRzaWRlIG9mIHRoZSBQZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gcGVlckNvbm5lY3Rpb25JY2VFdmVudCAtIFRoZSBwZWVyIGljZSBjYW5kaWRhdGVcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb25QZWVySWNlQ2FuZGlkYXRlKHBlZXJDb25uZWN0aW9uSWNlRXZlbnQpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBGdW5jdGlvbmFsaXR5OiBEbyBOb3RoaW5nXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIG92ZXJyaWRlIG1ldGhvZCBmb3Igb25EYXRhQ2hhbm5lbCBmb3IgdXNlIG91dHNpZGUgb2YgdGhlIFBlZXJDb25uZWN0aW9uQ29udHJvbGxlclxuICAgICAqIEBwYXJhbSBkYXRhY2hhbm5lbEV2ZW50IC0gVGhlIHBlZXIncyBkYXRhIGNoYW5uZWxcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb25EYXRhQ2hhbm5lbChkYXRhY2hhbm5lbEV2ZW50KSB7XG4gICAgICAgIC8vIERlZmF1bHQgRnVuY3Rpb25hbGl0eTogRG8gTm90aGluZ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiBVRSBhbmQgYnJvd3NlciBjb2RlY3MsIHdpdGggZnV6enkgbWF0Y2hpbmcgaWYgc29tZSBwYXJhbWV0ZXJzIGFyZSBtaXNtYXRjaGVkLlxuICAgICAqIEBwYXJhbSBzZHAgVGhlIHJlbW90ZSBzZHBcbiAgICAgKiBAcmV0dXJucyBUaGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gYnJvd3NlciBzdXBwb3J0ZWQgY29kZWNzIGFuZCB1ZSBzdXBwb3J0ZWQgY29kZWNzLlxuICAgICAqL1xuICAgIGZ1enp5SW50ZXJzZWN0VUVBbmRCcm93c2VyQ29kZWNzKHNkcCkge1xuICAgICAgICAvLyBXZSB3YW50IHRvIGJ1aWxkIGFuIGFycmF5IG9mIGFsbCBzdXBwb3J0ZWQgY29kZWNzIG9uIGJvdGggc2lkZXNcbiAgICAgICAgY29uc3QgYWxsU3VwcG9ydGVkQ29kZWNzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIGNvbnN0IGFsbFVFQ29kZWNzID0gdGhpcy5wYXJzZUF2YWlsYWJsZUNvZGVjcyhzZHApO1xuICAgICAgICBjb25zdCBhbGxCcm93c2VyQ29kZWNzID0gdGhpcy5jb25maWcuZ2V0U2V0dGluZ09wdGlvbihPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZENvZGVjKS5vcHRpb25zO1xuICAgICAgICBmb3IgKGNvbnN0IHVlQ29kZWMgb2YgYWxsVUVDb2RlY3MpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGJyb3dzZXIgY29kZWNzIGRpcmVjdGx5IG1hdGNoZXMgVUUgY29kZWMgKHdpdGggcGFyYW1ldGVycyBhbmQgZXZlcnl0aGluZylcbiAgICAgICAgICAgIGlmIChhbGxCcm93c2VyQ29kZWNzLmluY2x1ZGVzKHVlQ29kZWMpKSB7XG4gICAgICAgICAgICAgICAgYWxsU3VwcG9ydGVkQ29kZWNzLnB1c2godWVDb2RlYyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgY2hlY2sgaWYgYnJvd3NlciBjb2RlYyBhdCBsZWFzdCBjb250YWlucyBhIG1hdGNoIGZvciB0aGUgVUUgY29kZWMgbmFtZSAod2l0aG91dCBwYXJhbWV0ZXJzKS5cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVlQ29kZWNOYW1lQW5kUGFyYW1zID0gdWVDb2RlYy5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVlQ29kZWNOYW1lID0gdWVDb2RlY05hbWVBbmRQYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBicm93c2VyQ29kZWMgb2YgYWxsQnJvd3NlckNvZGVjcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnJvd3NlckNvZGVjLmluY2x1ZGVzKHVlQ29kZWNOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgcGFzcyBicm93c2VyIGNvZGVjIGhlcmUgYXMgdGhleSBvcHRpb24gY29udGFpbiBleHRyYSBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsU3VwcG9ydGVkQ29kZWNzLnB1c2goYnJvd3NlckNvZGVjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxTdXBwb3J0ZWRDb2RlY3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHVwIHRyYWNrcyBvbiB0aGUgUlRDIFBlZXIgQ29ubmVjdGlvblxuICAgICAqIEBwYXJhbSB1c2VNaWMgLSBpcyBtaWMgaW4gdXNlXG4gICAgICogQHBhcmFtIHVzZUNhbWVyYSAtIGlzIHdlYmNhbSBpbiB1c2VcbiAgICAgKi9cbiAgICBzZXR1cFRyYW5zY2VpdmVyc0FzeW5jKHVzZU1pYywgdXNlQ2FtZXJhKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICAgICAgbGV0IGhhc1ZpZGVvUmVjZWl2ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNjZWl2ZXIgb2YgKF9iID0gKF9hID0gdGhpcy5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRyYW5zY2VpdmVycygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlciAmJlxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlciAmJlxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjayAmJlxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1ZpZGVvUmVjZWl2ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXR1cCBhIHRyYW5zY2VpdmVyIGZvciBzZW5kaW5nIHdlYmNhbSB2aWRlbyB0byBVRSBhbmQgcmVjZWl2aW5nIHZpZGVvIGZyb20gVUVcbiAgICAgICAgICAgIGlmICghdXNlQ2FtZXJhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNWaWRlb1JlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYyA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hZGRUcmFuc2NlaXZlcigndmlkZW8nLCB7IGRpcmVjdGlvbjogJ3JlY3Zvbmx5JyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnNldHVwVmlkZW9TZW5kZXIoaGFzVmlkZW9SZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoUlRDUnRwUmVjZWl2ZXIuZ2V0Q2FwYWJpbGl0aWVzICYmIHRoaXMucHJlZmVycmVkQ29kZWMgIT0gJycpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zY2VpdmVyIG9mIChfZSA9IChfZCA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5nZXRUcmFuc2NlaXZlcnMoKSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogW10pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zY2VpdmVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09ICd2aWRlbycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnNldENvZGVjUHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBvdXIgcHJlZmVycmVkIGNvZGVjIGZyb20gdGhlIGNvZGVjcyBvcHRpb25zIGRyb3AgZG93blxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZmVycmVkUlRQQ29kZWMgPSB0aGlzLnByZWZlcnJlZENvZGVjLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmZXJyZWRSVENSdHBDb2RlY0NhcGFiaWxpdHkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6ICd2aWRlby8nICsgcHJlZmVycmVkUlRQQ29kZWNbMF0gLyogTmFtZSAqLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9ja1JhdGU6IDkwMDAwIC8qIEFsbCBjdXJyZW50IHZpZGVvIGZvcm1hdHMgaW4gYnJvd3NlcnMgaGF2ZSA5MGtoeiBjbG9jayByYXRlICovLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNkcEZtdHBMaW5lOiBwcmVmZXJyZWRSVFBDb2RlY1sxXSA/IHByZWZlcnJlZFJUUENvZGVjWzFdIDogJydcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBhIGxpc3Qgb2YgY29kZWNzIHdlIHdpbGwgc3VwcG9ydCB3aXRoIG91ciBwcmVmZXJyZWQgb25lIGluIHRoZSBmaXJzdCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3VyU3VwcG9ydGVkQ29kZWNzID0gW3ByZWZlcnJlZFJUQ1J0cENvZGVjQ2FwYWJpbGl0eV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHbyB0aHJvdWdoIGFsbCBjb2RlY3MgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYW5kIGFkZCB0aGVtIHRvIHRoZSBsaXN0IChpbiBhbnkgb3JkZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBSVENSdHBSZWNlaXZlci5nZXRDYXBhYmlsaXRpZXMoJ3ZpZGVvJykuY29kZWNzLmZvckVhY2goKGJyb3dzZXJTdXBwb3J0ZWRDb2RlYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGFkZCBvdXIgcHJlZmVycmVkIGNvZGVjIGFnYWluLCBidXQgYWRkIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChicm93c2VyU3VwcG9ydGVkQ29kZWMubWltZVR5cGUgIT0gcHJlZmVycmVkUlRDUnRwQ29kZWNDYXBhYmlsaXR5Lm1pbWVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91clN1cHBvcnRlZENvZGVjcy5wdXNoKGJyb3dzZXJTdXBwb3J0ZWRDb2RlYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChicm93c2VyU3VwcG9ydGVkQ29kZWMgPT09IG51bGwgfHwgYnJvd3NlclN1cHBvcnRlZENvZGVjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBicm93c2VyU3VwcG9ydGVkQ29kZWMuc2RwRm10cExpbmUpICE9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcmVmZXJyZWRSVENSdHBDb2RlY0NhcGFiaWxpdHkgPT09IG51bGwgfHwgcHJlZmVycmVkUlRDUnRwQ29kZWNDYXBhYmlsaXR5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmVmZXJyZWRSVENSdHBDb2RlY0NhcGFiaWxpdHkuc2RwRm10cExpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91clN1cHBvcnRlZENvZGVjcy5wdXNoKGJyb3dzZXJTdXBwb3J0ZWRDb2RlYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIG91clN1cHBvcnRlZENvZGVjcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY29kZWMgPT09IG51bGwgfHwgY29kZWMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvZGVjLnNkcEZtdHBMaW5lKSA9PT0gdW5kZWZpbmVkIHx8IGNvZGVjLnNkcEZtdHBMaW5lID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCBkeW5hbWljYWxseSBhZGQgbWVtYmVycyB0byB0aGUgY29kZWMsIHNvIGluc3RlYWQgcmVtb3ZlIHRoZSBmaWVsZCBpZiBpdCdzIGVtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb2RlYy5zZHBGbXRwTGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5zZXRDb2RlY1ByZWZlcmVuY2VzKG91clN1cHBvcnRlZENvZGVjcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaGFzQXVkaW9SZWNlaXZlciA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0cmFuc2NlaXZlciBvZiAoX2cgPSAoX2YgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuZ2V0VHJhbnNjZWl2ZXJzKCkpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IFtdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zY2VpdmVyICYmXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY2VpdmVyICYmXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrICYmXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzQXVkaW9SZWNlaXZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldHVwIGEgdHJhbnNjZWl2ZXIgZm9yIHNlbmRpbmcgbWljIGF1ZGlvIHRvIFVFIGFuZCByZWNlaXZpbmcgYXVkaW8gZnJvbSBVRVxuICAgICAgICAgICAgaWYgKCF1c2VNaWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0F1ZGlvUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9oID0gdGhpcy5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ3JlY3Zvbmx5J1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnNldHVwQXVkaW9TZW5kZXIoaGFzQXVkaW9SZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXR1cFZpZGVvU2VuZGVyKGhhc1ZpZGVvUmVjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIC8vIHNldCB0aGUgbWVkaWEgc2VuZCBvcHRpb25zXG4gICAgICAgICAgICBjb25zdCBtZWRpYVNlbmRPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHZpZGVvOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gTm90ZSB1c2luZyB3ZWJjYW0gb24gYW5kcm9pZCBjaHJvbWUgcmVxdWlyZXMgU1NMIG9yIGNocm9tZTovL2ZsYWdzLyBcInVuc2FmZWx5LXRyZWF0LWluc2VjdXJlLW9yaWdpbi1hcy1zZWN1cmVcIlxuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEobWVkaWFTZW5kT3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1ZpZGVvUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0cmFuc2NlaXZlciBvZiAoX2IgPSAoX2EgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0VHJhbnNjZWl2ZXJzKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUlRDVXRpbHMuY2FuVHJhbnNjZWl2ZXJSZWNlaXZlVmlkZW8odHJhbnNjZWl2ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0cmFjayBvZiBzdHJlYW0uZ2V0VHJhY2tzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrLmtpbmQgJiYgdHJhY2sua2luZCA9PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kcmVjdic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHJhY2sgb2Ygc3RyZWFtLmdldFRyYWNrcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2sua2luZCAmJiB0cmFjay5raW5kID09ICd2aWRlbycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2MgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWRkVHJhbnNjZWl2ZXIodHJhY2ssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnc2VuZHJlY3YnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1ZpZGVvUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9kID0gdGhpcy5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFkZFRyYW5zY2VpdmVyKCd2aWRlbycsIHsgZGlyZWN0aW9uOiAncmVjdm9ubHknIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldHVwQXVkaW9TZW5kZXIoaGFzQXVkaW9SZWNlaXZlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgLy8gc2V0IHRoZSBhdWRpbyBvcHRpb25zIGJhc2VkIG9uIG1pYyB1c2FnZVxuICAgICAgICAgICAgY29uc3QgYXVkaW9PcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGF1dG9HYWluQ29udHJvbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiAxLFxuICAgICAgICAgICAgICAgIGVjaG9DYW5jZWxsYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxhdGVuY3k6IDAsXG4gICAgICAgICAgICAgICAgbm9pc2VTdXBwcmVzc2lvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2FtcGxlUmF0ZTogNDgwMDAsXG4gICAgICAgICAgICAgICAgc2FtcGxlU2l6ZTogMTYsXG4gICAgICAgICAgICAgICAgdm9sdW1lOiAxLjBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBzZXQgdGhlIG1lZGlhIHNlbmQgb3B0aW9uc1xuICAgICAgICAgICAgY29uc3QgbWVkaWFTZW5kT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB2aWRlbzogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXVkaW86IGF1ZGlvT3B0aW9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIE5vdGUgdXNpbmcgbWljIG9uIGFuZHJvaWQgY2hyb21lIHJlcXVpcmVzIFNTTCBvciBjaHJvbWU6Ly9mbGFncy8gXCJ1bnNhZmVseS10cmVhdC1pbnNlY3VyZS1vcmlnaW4tYXMtc2VjdXJlXCJcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKG1lZGlhU2VuZE9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNBdWRpb1JlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNjZWl2ZXIgb2YgKF9iID0gKF9hID0gdGhpcy5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRyYW5zY2VpdmVycygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJUQ1V0aWxzLmNhblRyYW5zY2VpdmVyUmVjZWl2ZUF1ZGlvKHRyYW5zY2VpdmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHJhY2sgb2Ygc3RyZWFtLmdldFRyYWNrcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFjay5raW5kICYmIHRyYWNrLmtpbmQgPT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayh0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnc2VuZHJlY3YnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRyYWNrIG9mIHN0cmVhbS5nZXRUcmFja3MoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrLmtpbmQgJiYgdHJhY2sua2luZCA9PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9jID0gdGhpcy5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFkZFRyYW5zY2VpdmVyKHRyYWNrLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ3NlbmRyZWN2J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNBdWRpb1JlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIChfZCA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hZGRUcmFuc2NlaXZlcignYXVkaW8nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdyZWN2b25seSdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW5kIG92ZXJyaWRlIGV2ZW50IGZvciB3aGVuIHRoZSB2aWRlbyBzdGF0cyBhcmUgZmlyZWRcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBBZ2dyZWdhdGVkIFN0YXRzXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIG9uVmlkZW9TdGF0cyhldmVudCkge1xuICAgICAgICAvLyBEZWZhdWx0IEZ1bmN0aW9uYWxpdHk6IERvIE5vdGhpbmdcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW5kIG92ZXJyaWRlIGV2ZW50IGZvciB3aGVuIGxhdGVuY3kgaW5mbyBpcyBjYWxjdWxhdGVkXG4gICAgICogQHBhcmFtIGxhdGVuY3lJbmZvIC0gQ2FsY3VsYXRlZCBsYXRlbmN5IGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBvbkxhdGVuY3lDYWxjdWxhdGVkKGxhdGVuY3lJbmZvKSB7XG4gICAgICAgIC8vIERlZmF1bHQgRnVuY3Rpb25hbGl0eTogRG8gTm90aGluZ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmVudCB0byBzZW5kIHRoZSBSVEMgb2ZmZXIgdG8gdGhlIFNpZ25hbGluZyBzZXJ2ZXJcbiAgICAgKiBAcGFyYW0gb2ZmZXIgLSBSVEMgT2ZmZXJcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb25TZW5kV2ViUlRDT2ZmZXIob2ZmZXIpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBGdW5jdGlvbmFsaXR5OiBEbyBOb3RoaW5nXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gcmVtb3RlIG9mZmVyIGRlc2NyaXB0aW9uIGlzIHNldC5cbiAgICAgKiBAcGFyYW0gb2ZmZXIgLSBSVEMgT2ZmZXJcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb25TZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcikge1xuICAgICAgICAvLyBEZWZhdWx0IEZ1bmN0aW9uYWxpdHk6IERvIE5vdGhpbmdcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZSB3aGVuIGxvY2FsIGRlc2NyaXB0aW9uIGFuc3dlciBpcyBzZXQuXG4gICAgICogQHBhcmFtIGFuc3dlciAtIFJUQyBBbnN3ZXJcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb25TZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcikge1xuICAgICAgICAvLyBEZWZhdWx0IEZ1bmN0aW9uYWxpdHk6IERvIE5vdGhpbmdcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gb3ZlcnJpZGUgZm9yIHNob3dpbmcgdGhlIFBlZXIgY29ubmVjdGlvbiBjb25uZWN0aW5nIE92ZXJsYXlcbiAgICAgKi9cbiAgICBzaG93VGV4dE92ZXJsYXlDb25uZWN0aW5nKCkge1xuICAgICAgICAvLyBEZWZhdWx0IEZ1bmN0aW9uYWxpdHk6IERvIE5vdGhpbmdcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gb3ZlcnJpZGUgZm9yIHNob3dpbmcgdGhlIFBlZXIgY29ubmVjdGlvbiBGYWlsZWQgb3ZlcmxheVxuICAgICAqL1xuICAgIHNob3dUZXh0T3ZlcmxheVNldHVwRmFpbHVyZSgpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBGdW5jdGlvbmFsaXR5OiBEbyBOb3RoaW5nXG4gICAgfVxuICAgIHBhcnNlQXZhaWxhYmxlQ29kZWNzKHJ0Y1Nlc3Npb25EZXNjcmlwdGlvbikge1xuICAgICAgICAvLyBObyBwb2ludCBpbiB1cGRhdGluZyB0aGUgYXZhaWxhYmxlIGNvZGVjcyBpZiBvbiBGRlxuICAgICAgICBpZiAoIVJUQ1J0cFJlY2VpdmVyLmdldENhcGFiaWxpdGllcylcbiAgICAgICAgICAgIHJldHVybiBbJ09ubHkgYXZhaWxhYmxlIG9uIENocm9tZSddO1xuICAgICAgICBjb25zdCB1ZVN1cHBvcnRlZENvZGVjcyA9IFtdO1xuICAgICAgICBjb25zdCBzZWN0aW9ucyA9IHNwbGl0U2VjdGlvbnMocnRjU2Vzc2lvbkRlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIC8vIGRpc2NhcmQgdGhlIHNlc3Npb24gaW5mb3JtYXRpb24gYXMgd2Ugb25seSB3YW50IG1lZGlhIHJlbGF0ZWQgaW5mb1xuICAgICAgICBzZWN0aW9ucy5zaGlmdCgpO1xuICAgICAgICBzZWN0aW9ucy5mb3JFYWNoKChtZWRpYVNlY3Rpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29kZWNzIH0gPSBwYXJzZVJ0cFBhcmFtZXRlcnMobWVkaWFTZWN0aW9uKTtcbiAgICAgICAgICAgIC8vIEZpbHRlciBvbmx5IGZvciBWUFggLyBIMjZYIC8gQVYxXG4gICAgICAgICAgICBjb25zdCBtYXRjaGVyID0gLyhWUFxcZHxIMjZcXGR8QVYxKS4qLztcbiAgICAgICAgICAgIGNvZGVjcy5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyID0gYy5uYW1lICtcbiAgICAgICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYy5wYXJhbWV0ZXJzIHx8IHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgocCkgPT4gcCArICc9JyArIGMucGFyYW1ldGVyc1twXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCc7Jyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaGVyLmV4ZWMoc3RyKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMubmFtZSA9PSAnVlA5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVUUgYW5zd2VycyBkb24ndCBzcGVjaWZ5IHByb2ZpbGUgYnV0IHdlIGtub3cgd2Ugd2FudCBwcm9maWxlIDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGMucGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJvZmlsZS1pZCc6ICcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlY1N0ciA9IGMubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYy5wYXJhbWV0ZXJzIHx8IHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKHApID0+IHAgKyAnPScgKyBjLnBhcmFtZXRlcnNbcF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJzsnKTtcbiAgICAgICAgICAgICAgICAgICAgdWVTdXBwb3J0ZWRDb2RlY3MucHVzaChjb2RlY1N0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdWVTdXBwb3J0ZWRDb2RlY3M7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGVlckNvbm5lY3Rpb25Db250cm9sbGVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIFNlc3Npb24gc3RhdGlzdGljc1xuICovXG5leHBvcnQgY2xhc3MgU2Vzc2lvblN0YXRzIHtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlc3Npb25TdGF0cy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBDbGFzcyB0byBob2xkIHRoZSBzdHJlYW0gc3RhdHMgZGF0YSBjb21pbmcgaW4gZnJvbSB3ZWJSdGNcbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbVN0YXRzIHtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0cmVhbVN0YXRzLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBPcHRpb25QYXJhbWV0ZXJzIH0gZnJvbSAnLi4vQ29uZmlnL0NvbmZpZyc7XG5pbXBvcnQgeyBXZWJSdGNQbGF5ZXJDb250cm9sbGVyIH0gZnJvbSAnLi4vV2ViUnRjUGxheWVyL1dlYlJ0Y1BsYXllckNvbnRyb2xsZXInO1xuaW1wb3J0IHsgRmxhZ3MsIE51bWVyaWNQYXJhbWV0ZXJzIH0gZnJvbSAnLi4vQ29uZmlnL0NvbmZpZyc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG5pbXBvcnQgeyBQaXhlbFN0cmVhbWluZ0V2ZW50RW1pdHRlciwgSW5pdGlhbFNldHRpbmdzRXZlbnQsIExhdGVuY3lDYWxjdWxhdGVkRXZlbnQsIExhdGVuY3lUZXN0UmVzdWx0RXZlbnQsIFN0YXRzUmVjZWl2ZWRFdmVudCwgU3RyZWFtTG9hZGluZ0V2ZW50LCBTdHJlYW1QcmVDb25uZWN0RXZlbnQsIFN0cmVhbVJlY29ubmVjdEV2ZW50LCBTdHJlYW1QcmVEaXNjb25uZWN0RXZlbnQsIFZpZGVvRW5jb2RlckF2Z1FQRXZlbnQsIFZpZGVvSW5pdGlhbGl6ZWRFdmVudCwgV2ViUnRjQXV0b0Nvbm5lY3RFdmVudCwgV2ViUnRjQ29ubmVjdGVkRXZlbnQsIFdlYlJ0Y0Nvbm5lY3RpbmdFdmVudCwgV2ViUnRjRGlzY29ubmVjdGVkRXZlbnQsIFdlYlJ0Y0ZhaWxlZEV2ZW50LCBXZWJSdGNTZHBFdmVudCwgRGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlc3BvbnNlRXZlbnQsIERhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXN1bHRFdmVudCwgUGxheWVyQ291bnRFdmVudCwgV2ViUnRjVENQUmVsYXlEZXRlY3RlZEV2ZW50LCBTdWJzY3JpYmVGYWlsZWRFdmVudCwgV2ViUnRjU2RwT2ZmZXJFdmVudCwgV2ViUnRjU2RwQW5zd2VyRXZlbnQgfSBmcm9tICcuLi9VdGlsL0V2ZW50RW1pdHRlcic7XG5pbXBvcnQgeyBXZWJYUkNvbnRyb2xsZXIgfSBmcm9tICcuLi9XZWJYUi9XZWJYUkNvbnRyb2xsZXInO1xuaW1wb3J0IHsgTWVzc2FnZURpcmVjdGlvbiB9IGZyb20gJy4uL1VlSW5zdGFuY2VNZXNzYWdlL1N0cmVhbU1lc3NhZ2VDb250cm9sbGVyJztcbmltcG9ydCB7IERhdGFDaGFubmVsTGF0ZW5jeVRlc3RDb250cm9sbGVyIH0gZnJvbSAnLi4vRGF0YUNoYW5uZWwvRGF0YUNoYW5uZWxMYXRlbmN5VGVzdENvbnRyb2xsZXInO1xuaW1wb3J0IHsgUlRDVXRpbHMgfSBmcm9tICcuLi9VdGlsL1JUQ1V0aWxzJztcbmltcG9ydCB7IElVUkxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9VdGlsL0lVUkxTZWFyY2hQYXJhbXMnO1xuLyoqXG4gKiBUaGUga2V5IGNsYXNzIGZvciB0aGUgYnJvd3NlciBzaWRlIG9mIGEgUGl4ZWwgU3RyZWFtaW5nIGFwcGxpY2F0aW9uLCBpdCBpbmNsdWRlczpcbiAqIFdlYlJUQyBoYW5kbGluZywgWFIgc3VwcG9ydCwgaW5wdXQgaGFuZGxpbmcsIGFuZCBlbWl0dGVycyBmb3IgbGlmZXRpbWUgYW5kIHN0YXRlIGNoYW5nZSBldmVudHMuXG4gKiBVc2VycyBhcmUgZW5jb3VyYWdlZCB0byB1c2UgdGhpcyBjbGFzcyBhcyBpcywgdGhyb3VnaCBjb21wb3NpdGlvbiwgb3IgZXh0ZW5kIGl0LiBJbiBhbnkgY2FzZSxcbiAqIHRoaXMgd2lsbCBsaWtlbHkgYmUgdGhlIGNvcmUgb2YgeW91ciBQaXhlbCBTdHJlYW1pbmcgZXhwZXJpZW5jZSBpbiB0ZXJtcyBvZiBmdW5jdGlvbmFsaXR5LlxuICovXG5leHBvcnQgY2xhc3MgUGl4ZWxTdHJlYW1pbmcge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBBIG5ld2x5IGluc3RhbnRpYXRlZCBjb25maWcgb2JqZWN0XG4gICAgICogQHBhcmFtIG92ZXJyaWRlcyAtIFBhcmFtZXRlcnMgdG8gb3ZlcnJpZGUgZGVmYXVsdCBiZWhhdmlvdXJcbiAgICAgKiByZXR1cm5zIHRoZSBiYXNlIFBpeGVsIHN0cmVhbWluZyBvYmplY3RcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIG92ZXJyaWRlcykge1xuICAgICAgICB0aGlzLmFsbG93Q29uc29sZUNvbW1hbmRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICBpZiAob3ZlcnJpZGVzID09PSBudWxsIHx8IG92ZXJyaWRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcnJpZGVzLnZpZGVvRWxlbWVudFBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5fdmlkZW9FbGVtZW50UGFyZW50ID0gb3ZlcnJpZGVzLnZpZGVvRWxlbWVudFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIgPSBuZXcgUGl4ZWxTdHJlYW1pbmdFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmVTZXR0aW5ncygpO1xuICAgICAgICAvLyBzZXR1cCBXZWJSVENcbiAgICAgICAgdGhpcy5zZXRXZWJSdGNQbGF5ZXJDb250cm9sbGVyKG5ldyBXZWJSdGNQbGF5ZXJDb250cm9sbGVyKHRoaXMuY29uZmlnLCB0aGlzKSk7XG4gICAgICAgIHRoaXMuX3dlYlhyQ29udHJvbGxlciA9IG5ldyBXZWJYUkNvbnRyb2xsZXIodGhpcy5fd2ViUnRjQ29udHJvbGxlcik7XG4gICAgICAgIHRoaXMuX3NldHVwV2ViUnRjVENQUmVsYXlEZXRlY3Rpb24gPSB0aGlzLl9zZXR1cFdlYlJ0Y1RDUFJlbGF5RGV0ZWN0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lciBmb3IgdGhlIHdlYlJ0Y0Nvbm5lY3RlZCBldmVudFxuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcignd2ViUnRjQ29ubmVjdGVkJywgKF8pID0+IHtcbiAgICAgICAgICAgIC8vIEJpbmQgdG8gdGhlIHN0YXRzIHJlY2VpdmVkIGV2ZW50XG4gICAgICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcignc3RhdHNSZWNlaXZlZCcsIHRoaXMuX3NldHVwV2ViUnRjVENQUmVsYXlEZXRlY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSB2aWRlbyBzdHJlYW0gZWxlbWVudC5cbiAgICAgKi9cbiAgICBnZXQgdmlkZW9FbGVtZW50UGFyZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ZpZGVvRWxlbWVudFBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5fdmlkZW9FbGVtZW50UGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl92aWRlb0VsZW1lbnRQYXJlbnQuaWQgPSAndmlkZW9FbGVtZW50UGFyZW50JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdmlkZW9FbGVtZW50UGFyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgdGhlIHNldHRpbmdzIHdpdGggb24gY2hhbmdlIGxpc3RlbmVycyBhbmQgYW55IGFkZGl0aW9uYWwgcGVyIGV4cGVyaWVuY2Ugc2V0dGluZ3MuXG4gICAgICovXG4gICAgY29uZmlndXJlU2V0dGluZ3MoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPblNldHRpbmdDaGFuZ2VkTGlzdGVuZXIoRmxhZ3MuSXNRdWFsaXR5Q29udHJvbGxlciwgKHdhbnRzUXVhbGl0eUNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBzZXR0aW5nIGhhcyBiZWVuIHNldCB0byB0cnVlIChlaXRoZXIgcHJvZ3JhbW1hdGljYWxseSBvciB0aGUgdXNlciBoYXMgZmxpY2tlZCB0aGUgdG9nZ2xlKVxuICAgICAgICAgICAgLy8gYW5kIHdlIGFyZW4ndCBjdXJyZW50bHkgcXVhbGl0eSBjb250cm9sbGVyLCBzZW5kIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICBpZiAod2FudHNRdWFsaXR5Q29udHJvbGxlciA9PT0gdHJ1ZSAmJiAhdGhpcy5fd2ViUnRjQ29udHJvbGxlci5pc1F1YWxpdHlDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZW5kUmVxdWVzdFF1YWxpdHlDb250cm9sT3duZXJzaGlwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25TZXR0aW5nQ2hhbmdlZExpc3RlbmVyKEZsYWdzLkFGS0RldGVjdGlvbiwgKGlzQUZLRW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZXRBZmtFbmFibGVkKGlzQUZLRW5hYmxlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25TZXR0aW5nQ2hhbmdlZExpc3RlbmVyKEZsYWdzLk1hdGNoVmlld3BvcnRSZXNvbHV0aW9uLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnZpZGVvUGxheWVyLnVwZGF0ZVZpZGVvU3RyZWFtU2l6ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihGbGFncy5Ib3ZlcmluZ01vdXNlTW9kZSwgKGlzSG92ZXJpbmdNb3VzZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0RmxhZ0xhYmVsKEZsYWdzLkhvdmVyaW5nTW91c2VNb2RlLCBgQ29udHJvbCBTY2hlbWU6ICR7aXNIb3ZlcmluZ01vdXNlID8gJ0hvdmVyaW5nJyA6ICdMb2NrZWQnfSBNb3VzZWApO1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZXRNb3VzZUlucHV0RW5hYmxlZCh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLk1vdXNlSW5wdXQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHVzZXIgaW5wdXRcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihGbGFncy5LZXlib2FyZElucHV0LCAoaXNFbmFibGVkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnNldEtleWJvYXJkSW5wdXRFbmFibGVkKGlzRW5hYmxlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25TZXR0aW5nQ2hhbmdlZExpc3RlbmVyKEZsYWdzLk1vdXNlSW5wdXQsIChpc0VuYWJsZWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2V0TW91c2VJbnB1dEVuYWJsZWQoaXNFbmFibGVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPblNldHRpbmdDaGFuZ2VkTGlzdGVuZXIoRmxhZ3MuRmFrZU1vdXNlV2l0aFRvdWNoZXMsIChfaXNGYWtlTW91c2VFbmFibGVkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnNldFRvdWNoSW5wdXRFbmFibGVkKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuVG91Y2hJbnB1dCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihGbGFncy5Ub3VjaElucHV0LCAoaXNFbmFibGVkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnNldFRvdWNoSW5wdXRFbmFibGVkKGlzRW5hYmxlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25TZXR0aW5nQ2hhbmdlZExpc3RlbmVyKEZsYWdzLkdhbWVwYWRJbnB1dCwgKGlzRW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZXRHYW1lUGFkSW5wdXRFbmFibGVkKGlzRW5hYmxlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBkaXJlY3QgcXAgc2V0dGluZ3NcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uTnVtZXJpY1NldHRpbmdDaGFuZ2VkTGlzdGVuZXIoTnVtZXJpY1BhcmFtZXRlcnMuTWluUVAsIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tICBTZW5kaW5nIE1pblFQICAtLS0tLS0tLScpO1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZW5kRW5jb2Rlck1pblFQKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7XG4gICAgICAgICAgICBjb25zdCBxdWFsaXR5ID0gTWF0aC50cnVuYygxMDAgKiAoMSAtIG5ld1ZhbHVlIC8gNTEpKTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldE51bWVyaWNTZXR0aW5nKE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNYXgsIHF1YWxpdHkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uTnVtZXJpY1NldHRpbmdDaGFuZ2VkTGlzdGVuZXIoTnVtZXJpY1BhcmFtZXRlcnMuTWF4UVAsIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tICBTZW5kaW5nIE1heFFQICAtLS0tLS0tLScpO1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZW5kRW5jb2Rlck1heFFQKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7XG4gICAgICAgICAgICBjb25zdCBxdWFsaXR5ID0gTWF0aC50cnVuYygxMDAgKiAoMSAtIG5ld1ZhbHVlIC8gNTEpKTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldE51bWVyaWNTZXR0aW5nKE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNaW4sIHF1YWxpdHkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZGlyZWN0IHF1YWxpdHkgZmFjdG9yIHNldHRpbmdzXG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPbk51bWVyaWNTZXR0aW5nQ2hhbmdlZExpc3RlbmVyKE51bWVyaWNQYXJhbWV0ZXJzLk1pblF1YWxpdHksIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tICBTZW5kaW5nIE1pblF1YWxpdHkgIC0tLS0tLS0tJyk7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnNlbmRFbmNvZGVyTWluUXVhbGl0eShuZXdWYWx1ZSk7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0TnVtZXJpY1NldHRpbmcoTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1pbiwgbmV3VmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uTnVtZXJpY1NldHRpbmdDaGFuZ2VkTGlzdGVuZXIoTnVtZXJpY1BhcmFtZXRlcnMuTWF4UXVhbGl0eSwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0gIFNlbmRpbmcgTWF4UXVhbGl0eSAgLS0tLS0tLS0nKTtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZEVuY29kZXJNYXhRdWFsaXR5KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXROdW1lcmljU2V0dGluZyhOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWF4LCBuZXdWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBuZXcgcXVhbGl0eSB2YWx1ZSB0aGF0IGdldHMgc2NhbGVkIHRvIHFwIGZvciBsZWdhY3kgcmVhc29uc1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25OdW1lcmljU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWluLCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gNTEgLSAobmV3VmFsdWUgLyAxMDApICogNTE7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0gIFNlbmRpbmcgTWluUVAgZnJvbSBxdWFsaXR5IHZhbHVlICAtLS0tLS0tLScpO1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZW5kRW5jb2Rlck1heFFQKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25OdW1lcmljU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWF4LCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gNTEgLSAobmV3VmFsdWUgLyAxMDApICogNTE7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0gIFNlbmRpbmcgTWF4UVAgZnJvbSBxdWFsaXR5IHZhbHVlICAtLS0tLS0tLScpO1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZW5kRW5jb2Rlck1pblFQKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZWJSVEMgc2V0dGluZ3NcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uTnVtZXJpY1NldHRpbmdDaGFuZ2VkTGlzdGVuZXIoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWluQml0cmF0ZSwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0gIFNlbmRpbmcgd2ViIHJ0YyBzZXR0aW5ncyAgLS0tLS0tLS0nKTtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZFdlYlJUQ01pbkJpdHJhdGUobmV3VmFsdWUgKiAxMDAwIC8qIGticHMgdG8gYnBzICovKTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25OdW1lcmljU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNYXhCaXRyYXRlLCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCctLS0tLS0tLSAgU2VuZGluZyB3ZWIgcnRjIHNldHRpbmdzICAtLS0tLS0tLScpO1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZW5kV2ViUlRDTWF4Qml0cmF0ZShuZXdWYWx1ZSAqIDEwMDAgLyoga2JwcyB0byBicHMgKi8pO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPbk51bWVyaWNTZXR0aW5nQ2hhbmdlZExpc3RlbmVyKE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ0ZQUywgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0gIFNlbmRpbmcgd2ViIHJ0YyBzZXR0aW5ncyAgLS0tLS0tLS0nKTtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZFdlYlJUQ0ZwcyhuZXdWYWx1ZSk7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uT3B0aW9uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZENvZGVjLCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl93ZWJSdGNDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZXRQcmVmZXJyZWRDb2RlYyhuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZy5fcmVnaXN0ZXJPbkNoYW5nZUV2ZW50cyh0aGlzLl9ldmVudEVtaXR0ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGlucHV0IGNvbnRyb2wgb3duZXJzaGlwXG4gICAgICogQHBhcmFtIGlucHV0Q29udHJvbE93bmVyc2hpcCAtIGRvZXMgdGhlIHVzZXIgaGF2ZSBpbnB1dCBjb250cm9sIG93bmVyc2hpcFxuICAgICAqL1xuICAgIF9vbklucHV0Q29udHJvbE93bmVyc2hpcChpbnB1dENvbnRyb2xPd25lcnNoaXApIHtcbiAgICAgICAgdGhpcy5faW5wdXRDb250cm9sbGVyID0gaW5wdXRDb250cm9sT3duZXJzaGlwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSB0aGUgV2ViUlRDUGxheWVyQ29udHJvbGxlciBpbnRlcmZhY2UgdG8gcHJvdmlkZSBXZWJSVENQbGF5ZXJDb250cm9sbGVyIGZ1bmN0aW9uYWxpdHkgd2l0aGluIHRoaXMgY2xhc3MgYW5kIHNldCB1cCBhbnl0aGluZyB0aGF0IHJlcXVpcmVzIGl0XG4gICAgICogQHBhcmFtIHdlYlJ0Y1BsYXllckNvbnRyb2xsZXIgLSBhIFdlYlJ0Y1BsYXllckNvbnRyb2xsZXIgY29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNldFdlYlJ0Y1BsYXllckNvbnRyb2xsZXIod2ViUnRjUGxheWVyQ29udHJvbGxlcikge1xuICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyID0gd2ViUnRjUGxheWVyQ29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZXRQcmVmZXJyZWRDb2RlYyh0aGlzLmNvbmZpZy5nZXRTZXR0aW5nT3B0aW9uKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkQ29kZWMpLnNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5yZXNpemVQbGF5ZXJTdHlsZSgpO1xuICAgICAgICAvLyBjb25uZWN0IGlmIGF1dG8gY29ubmVjdCBmbGFnIGlzIGVuYWJsZWRcbiAgICAgICAgdGhpcy5jaGVja0ZvckF1dG9Db25uZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdG8gc2lnbmFsaW5nIHNlcnZlci5cbiAgICAgKi9cbiAgICBjb25uZWN0KCkge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgU3RyZWFtUHJlQ29ubmVjdEV2ZW50KCkpO1xuICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLmNvbm5lY3RUb1NpZ25hbGxpbmdTZXJ2ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb25uZWN0cyB0byB0aGUgc2lnbmFsaW5nIHNlcnZlci4gSWYgY29ubmVjdGlvbiBpcyB1cCwgZGlzY29ubmVjdHMgZmlyc3RcbiAgICAgKiBiZWZvcmUgZXN0YWJsaXNoaW5nIGEgbmV3IGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICByZWNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBTdHJlYW1SZWNvbm5lY3RFdmVudCgpKTtcbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci50cnlSZWNvbm5lY3QoJ1JlY29ubmVjdGluZy4uLicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IGZyb20gdGhlIHNpZ25hbGluZyBzZXJ2ZXIgYW5kIGNsb3NlIG9wZW4gcGVlciBjb25uZWN0aW9ucy5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgU3RyZWFtUHJlRGlzY29ubmVjdEV2ZW50KCkpO1xuICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBsYXkgdGhlIHN0cmVhbS4gQ2FuIGJlIGNhbGxlZCBvbmx5IGFmdGVyIGEgcGVlciBjb25uZWN0aW9uIGhhcyBiZWVuIGVzdGFibGlzaGVkLlxuICAgICAqL1xuICAgIHBsYXkoKSB7XG4gICAgICAgIHRoaXMuX29uU3RyZWFtTG9hZGluZygpO1xuICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnBsYXlTdHJlYW0oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXV0byBjb25uZWN0IGlmIEF1dG9Db25uZWN0IGZsYWcgaXMgZW5hYmxlZFxuICAgICAqL1xuICAgIGNoZWNrRm9yQXV0b0Nvbm5lY3QoKSB7XG4gICAgICAgIC8vIHNldCB1cCBpZiB0aGUgYXV0byBwbGF5IHdpbGwgYmUgdXNlZCBvciByZWd1bGFyIGNsaWNrIHRvIHN0YXJ0XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkF1dG9Db25uZWN0KSkge1xuICAgICAgICAgICAgLy8gaWYgYXV0b3BsYXlpbmcgc2hvdyBhbiBpbmZvIG92ZXJsYXkgd2hpbGUgd2hpbGUgd2FpdGluZyBmb3IgdGhlIGNvbm5lY3Rpb24gdG8gYmVnaW5cbiAgICAgICAgICAgIHRoaXMuX29uV2ViUnRjQXV0b0Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuY29ubmVjdFRvU2lnbmFsbGluZ1NlcnZlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgdW5tdXRlIHRoZSBtaWNyb3Bob25lIHRyYWNrIHdoaWNoIGlzIHNlbnQgdG8gVW5yZWFsIEVuZ2luZS5cbiAgICAgKiBCeSBkZWZhdWx0LCB3aWxsIG9ubHkgdW5tdXRlIGFuIGV4aXN0aW5nIG1pYyB0cmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JjZUVuYWJsZSBDYW4gYmUgdXNlZCBmb3IgY2FzZXMgd2hlbiB0aGlzIG9iamVjdCB3YXNuJ3QgaW5pdGlhbGl6ZWQgd2l0aCBhIG1pYyB0cmFjay5cbiAgICAgKiBJZiB0aGlzIHBhcmFtZXRlciBpcyB0cnVlLCB0aGUgY29ubmVjdGlvbiB3aWxsIGJlIHJlc3RhcnRlZCB3aXRoIGEgbWljcm9waG9uZS5cbiAgICAgKiBXYXJuaW5nOiB0aGlzIHRha2VzIHNvbWUgdGltZSwgYXMgYSBmdWxsIHJlbmVnb3RpYXRpb24gYW5kIHJlY29ubmVjdGlvbiB3aWxsIGhhcHBlbi5cbiAgICAgKi9cbiAgICB1bm11dGVNaWNyb3Bob25lKGZvcmNlRW5hYmxlID0gZmFsc2UpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBhbiBleGlzdGluZyBtaWMgdHJhY2ssIHdlIGp1c3Qgc2V0IG11dGVkIHN0YXRlXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKCdVc2VNaWMnKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRNaWNyb3Bob25lTXV0ZWQoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcHJlLWV4aXN0aW5nIG1pYyB0cmFjaywgYW5kIGNhbGxlciBpcyBvayB3aXRoIGZ1bGwgcmVzZXQsIHdlIGVuYWJsZSBhbmQgcmVzZXRcbiAgICAgICAgaWYgKGZvcmNlRW5hYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXRGbGFnRW5hYmxlZCgnVXNlTWljJywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIHByZWZlciBub3QgdG8gZm9yY2UgYSByZWNvbm5lY3Rpb24sIGp1c3Qgd2FybiB0aGUgdXNlciB0aGF0IHRoaXMgb3BlcmF0aW9uIGRpZG4ndCBoYXBwZW5cbiAgICAgICAgTG9nZ2VyLldhcm5pbmcoJ1RyeWluZyB0byB1bm11dGUgbWljLCBidXQgUGl4ZWxTdHJlYW1pbmcgd2FzIGluaXRpYWxpemVkIHdpdGggbm8gbWljcm9waG9uZSB0cmFjay4gQ2FsbCB3aXRoIGZvcmNlRW5hYmxlID09IHRydWUgdG8gcmUtY29ubmVjdCB3aXRoIGEgbWljIHRyYWNrLicpO1xuICAgIH1cbiAgICBtdXRlTWljcm9waG9uZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoJ1VzZU1pYycpKSB7XG4gICAgICAgICAgICB0aGlzLnNldE1pY3JvcGhvbmVNdXRlZCh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSB3YXNuJ3QgYSBtaWMgdHJhY2ssIGp1c3QgbGV0IHVzZXIga25vdyB0aGVyZSdzIG5vdGhpbmcgdG8gbXV0ZVxuICAgICAgICBMb2dnZXIuSW5mbygnVHJ5aW5nIHRvIG11dGUgbWljLCBidXQgUGl4ZWxTdHJlYW1pbmcgaGFzIG5vIG1pY3JvcGhvbmUgdHJhY2ssIHNvIHNlbmRpbmcgc291bmQgaXMgYWxyZWFkeSBkaXNhYmxlZC4nKTtcbiAgICB9XG4gICAgc2V0TWljcm9waG9uZU11dGVkKG11dGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBmb3IgKGNvbnN0IHRyYW5zY2VpdmVyIG9mIChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdldFRyYW5zY2VpdmVycygpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBbXSkge1xuICAgICAgICAgICAgaWYgKFJUQ1V0aWxzLmNhblRyYW5zY2VpdmVyU2VuZEF1ZGlvKHRyYW5zY2VpdmVyKSkge1xuICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRlci50cmFjay5lbmFibGVkID0gIW11dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCB1bm11dGUgdGhlIHZpZGVvIHRyYWNrIHdoaWNoIGlzIHNlbnQgdG8gVW5yZWFsIEVuZ2luZS5cbiAgICAgKiBCeSBkZWZhdWx0LCB3aWxsIG9ubHkgdW5tdXRlIGFuIGV4aXN0aW5nIHZpZGVvIHRyYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcmNlRW5hYmxlIENhbiBiZSB1c2VkIGZvciBjYXNlcyB3aGVuIHRoaXMgb2JqZWN0IHdhc24ndCBpbml0aWFsaXplZCB3aXRoIGEgdmlkZW8gdHJhY2suXG4gICAgICogSWYgdGhpcyBwYXJhbWV0ZXIgaXMgdHJ1ZSwgdGhlIGNvbm5lY3Rpb24gd2lsbCBiZSByZXN0YXJ0ZWQgd2l0aCBhIGNhbWVyYS5cbiAgICAgKiBXYXJuaW5nOiB0aGlzIHRha2VzIHNvbWUgdGltZSwgYXMgYSBmdWxsIHJlbmVnb3RpYXRpb24gYW5kIHJlY29ubmVjdGlvbiB3aWxsIGhhcHBlbi5cbiAgICAgKi9cbiAgICB1bm11dGVDYW1lcmEoZm9yY2VFbmFibGUgPSBmYWxzZSkge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIGFuIGV4aXN0aW5nIHZpZGVvIHRyYWNrLCB3ZSBqdXN0IHNldCBtdXRlZCBzdGF0ZVxuICAgICAgICBpZiAodGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZCgnVXNlQ2FtZXJhJykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2FtZXJhTXV0ZWQoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcHJlLWV4aXN0aW5nIHZpZGVvIHRyYWNrLCBhbmQgY2FsbGVyIGlzIG9rIHdpdGggZnVsbCByZXNldCwgd2UgZW5hYmxlIGFuZCByZXNldFxuICAgICAgICBpZiAoZm9yY2VFbmFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldEZsYWdFbmFibGVkKCdVc2VDYW1lcmEnLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgcHJlZmVyIG5vdCB0byBmb3JjZSBhIHJlY29ubmVjdGlvbiwganVzdCB3YXJuIHRoZSB1c2VyIHRoYXQgdGhpcyBvcGVyYXRpb24gZGlkbid0IGhhcHBlblxuICAgICAgICBMb2dnZXIuV2FybmluZygnVHJ5aW5nIHRvIHVubXV0ZSB2aWRlbywgYnV0IFBpeGVsU3RyZWFtaW5nIHdhcyBpbml0aWFsaXplZCB3aXRoIG5vIHZpZGVvIHRyYWNrLiBDYWxsIHdpdGggZm9yY2VFbmFibGUgPT0gdHJ1ZSB0byByZS1jb25uZWN0IHdpdGggYSB2aWRlbyB0cmFjay4nKTtcbiAgICB9XG4gICAgbXV0ZUNhbWVyYSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoJ1VzZUNhbWVyYScpKSB7XG4gICAgICAgICAgICB0aGlzLnNldENhbWVyYU11dGVkKHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIHdhc24ndCBhIG1pYyB0cmFjaywganVzdCBsZXQgdXNlciBrbm93IHRoZXJlJ3Mgbm90aGluZyB0byBtdXRlXG4gICAgICAgIExvZ2dlci5JbmZvKCdUcnlpbmcgdG8gbXV0ZSBjYW1lcmEsIGJ1dCBQaXhlbFN0cmVhbWluZyBoYXMgbm8gdmlkZW8gdHJhY2ssIHNvIHNlbmRpbmcgdmlkZW8gaXMgYWxyZWFkeSBkaXNhYmxlZC4nKTtcbiAgICB9XG4gICAgc2V0Q2FtZXJhTXV0ZWQobXV0ZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGZvciAoY29uc3QgdHJhbnNjZWl2ZXIgb2YgKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5fd2ViUnRjQ29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0VHJhbnNjZWl2ZXJzKCkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFtdKSB7XG4gICAgICAgICAgICBpZiAoUlRDVXRpbHMuY2FuVHJhbnNjZWl2ZXJTZW5kVmlkZW8odHJhbnNjZWl2ZXIpKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrLmVuYWJsZWQgPSAhbXV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBlbWl0IGFuIGV2ZW50IHdoZW4gYXV0byBjb25uZWN0aW5nIG9jY3Vyc1xuICAgICAqL1xuICAgIF9vbldlYlJ0Y0F1dG9Db25uZWN0KCkge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgV2ViUnRjQXV0b0Nvbm5lY3RFdmVudCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZW1pdCBhbiBldmVudCBmb3Igd2hlbiBTRFAgbmVnb3RpYXRpb24gaXMgZnVsbHkgZmluaXNoZWQuXG4gICAgICovXG4gICAgX29uV2ViUnRjU2RwKCkge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgV2ViUnRjU2RwRXZlbnQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGVtaXQgYW4gU0RQIG9mZmVyIGFmdGVyIGl0IGhhcyBiZWVuIHNldC5cbiAgICAgKi9cbiAgICBfb25XZWJSdGNTZHBPZmZlcihvZmZlcikge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgV2ViUnRjU2RwT2ZmZXJFdmVudCh7IHNkcDogb2ZmZXIgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBlbWl0IGFuIFNEUCBhbnN3ZXIgYWZ0ZXIgaXQgaGFzIGJlZW4gc2V0LlxuICAgICAqL1xuICAgIF9vbldlYlJ0Y1NkcEFuc3dlcihhbnN3ZXIpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFdlYlJ0Y1NkcEFuc3dlckV2ZW50KHsgc2RwOiBhbnN3ZXIgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiBjYWxsIHRvIGVtaXQgYSBgbGF0ZW5jeUNhbGN1bGF0ZWRgIGV2ZW50LlxuICAgICAqL1xuICAgIF9vbkxhdGVuY3lDYWxjdWxhdGVkKGxhdGVuY3lJbmZvKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBMYXRlbmN5Q2FsY3VsYXRlZEV2ZW50KHsgbGF0ZW5jeUluZm8gfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBlbWl0cyBhIFN0cmVhbUxvYWRpbmcgZXZlbnRcbiAgICAgKi9cbiAgICBfb25TdHJlYW1Mb2FkaW5nKCkge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgU3RyZWFtTG9hZGluZ0V2ZW50KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHRoZSB2aWRlbyBpcyBkaXNjb25uZWN0ZWQgLSBlbWl0cyBnaXZlbiBldmVudFN0cmluZyBvciBhbiBvdmVycmlkZVxuICAgICAqIG1lc3NhZ2UgZnJvbSB3ZWJSdGNDb250cm9sbGVyIGlmIG9uZSBoYXMgYmVlbiBzZXRcbiAgICAgKiBAcGFyYW0gZXZlbnRTdHJpbmcgLSBhIHN0cmluZyBkZXNjcmliaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBjbG9zZWRcbiAgICAgKiBAcGFyYW0gYWxsb3dDbGlja1RvUmVjb25uZWN0IC0gdHJ1ZSBpZiB3ZSB3YW50IHRvIGFsbG93IHRoZSB1c2VyIHRvIHJldHJ5IHRoZSBjb25uZWN0aW9uIHdpdGggYSBjbGlja1xuICAgICAqL1xuICAgIF9vbkRpc2Nvbm5lY3QoZXZlbnRTdHJpbmcsIGFsbG93Q2xpY2tUb1JlY29ubmVjdCkge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgV2ViUnRjRGlzY29ubmVjdGVkRXZlbnQoe1xuICAgICAgICAgICAgZXZlbnRTdHJpbmc6IGV2ZW50U3RyaW5nLFxuICAgICAgICAgICAgYWxsb3dDbGlja1RvUmVjb25uZWN0OiBhbGxvd0NsaWNrVG9SZWNvbm5lY3RcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gV2ViIFJ0YyBpcyBjb25uZWN0aW5nXG4gICAgICovXG4gICAgX29uV2ViUnRjQ29ubmVjdGluZygpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFdlYlJ0Y0Nvbm5lY3RpbmdFdmVudCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIFdlYiBSdGMgaGFzIGNvbm5lY3RlZFxuICAgICAqL1xuICAgIF9vbldlYlJ0Y0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFdlYlJ0Y0Nvbm5lY3RlZEV2ZW50KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gV2ViIFJ0YyBmYWlscyB0byBjb25uZWN0XG4gICAgICovXG4gICAgX29uV2ViUnRjRmFpbGVkKCkge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgV2ViUnRjRmFpbGVkRXZlbnQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB3aGVuIHRoZSBWaWRlbyBoYXMgYmVlbiBJbml0aWFsaXplZFxuICAgICAqL1xuICAgIF9vblZpZGVvSW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBWaWRlb0luaXRpYWxpemVkRXZlbnQoKSk7XG4gICAgICAgIHRoaXMuX3ZpZGVvU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHVwIGZ1bmN0aW9uYWxpdHkgdG8gaGFwcGVuIHdoZW4gcmVjZWl2aW5nIGxhdGVuY3kgdGVzdCByZXN1bHRzXG4gICAgICogQHBhcmFtIGxhdGVuY3kgLSBsYXRlbmN5IHRlc3QgcmVzdWx0cyBvYmplY3RcbiAgICAgKi9cbiAgICBfb25MYXRlbmN5VGVzdFJlc3VsdChsYXRlbmN5VGltaW5ncykge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgTGF0ZW5jeVRlc3RSZXN1bHRFdmVudCh7IGxhdGVuY3lUaW1pbmdzIH0pKTtcbiAgICB9XG4gICAgX29uRGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBEYXRhQ2hhbm5lbExhdGVuY3lUZXN0UmVzcG9uc2VFdmVudCh7IHJlc3BvbnNlIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHVwIGZ1bmN0aW9uYWxpdHkgdG8gaGFwcGVuIHdoZW4gcmVjZWl2aW5nIHZpZGVvIHN0YXRpc3RpY3NcbiAgICAgKiBAcGFyYW0gdmlkZW9TdGF0cyAtIHZpZGVvIHN0YXRpc3RpY3MgYXMgYSBhZ2dyZWdhdGUgc3RhdHMgb2JqZWN0XG4gICAgICovXG4gICAgX29uVmlkZW9TdGF0cyh2aWRlb1N0YXRzKSB7XG4gICAgICAgIC8vIER1cmF0aW9uXG4gICAgICAgIGlmICghdGhpcy5fdmlkZW9TdGFydFRpbWUgfHwgdGhpcy5fdmlkZW9TdGFydFRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fdmlkZW9TdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIHZpZGVvU3RhdHMuaGFuZGxlU2Vzc2lvblN0YXRpc3RpY3ModGhpcy5fdmlkZW9TdGFydFRpbWUsIHRoaXMuX2lucHV0Q29udHJvbGxlciwgdGhpcy5fd2ViUnRjQ29udHJvbGxlci52aWRlb0F2Z1FwKTtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFN0YXRzUmVjZWl2ZWRFdmVudCh7IGFnZ3JlZ2F0ZWRTdGF0czogdmlkZW9TdGF0cyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB1cCBmdW5jdGlvbmFsaXR5IHRvIGhhcHBlbiB3aGVuIGNhbGN1bGF0aW5nIHRoZSBhdmVyYWdlIHZpZGVvIGVuY29kZXIgcXBcbiAgICAgKiBAcGFyYW0gUVAgLSB0aGUgcXVhbGl0eSBudW1iZXIgb2YgdGhlIHN0cmVhbVxuICAgICAqL1xuICAgIF9vblZpZGVvRW5jb2RlckF2Z1FQKFFQKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBWaWRlb0VuY29kZXJBdmdRUEV2ZW50KHsgYXZnUVA6IFFQIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHVwIGZ1bmN0aW9uYWxpdHkgdG8gaGFwcGVuIHdoZW4gcmVjZWl2aW5nIGFuZCBoYW5kbGluZyBpbml0aWFsIHNldHRpbmdzIGZvciB0aGUgVUUgYXBwXG4gICAgICogQHBhcmFtIHNldHRpbmdzIC0gaW5pdGlhbCBVRSBhcHAgc2V0dGluZ3NcbiAgICAgKi9cbiAgICBfb25Jbml0aWFsU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgSW5pdGlhbFNldHRpbmdzRXZlbnQoeyBzZXR0aW5ncyB9KSk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5QaXhlbFN0cmVhbWluZ1NldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLmFsbG93Q29uc29sZUNvbW1hbmRzID0gKF9hID0gc2V0dGluZ3MuUGl4ZWxTdHJlYW1pbmdTZXR0aW5ncy5BbGxvd1BpeGVsU3RyZWFtaW5nQ29tbWFuZHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dDb25zb2xlQ29tbWFuZHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy1BbGxvd1BpeGVsU3RyZWFtaW5nQ29tbWFuZHM9ZmFsc2UsIHNlbmRpbmcgYXJiaXRyYXJ5IGNvbnNvbGUgY29tbWFuZHMgZnJvbSBicm93c2VyIHRvIFVFIGlzIGRpc2FibGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVzZVVybFBhcmFtcyA9IHRoaXMuY29uZmlnLnVzZVVybFBhcmFtcztcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IElVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgICAgIExvZ2dlci5JbmZvKGB1c2luZyBVUkwgcGFyYW1ldGVycyAke3VzZVVybFBhcmFtc31gKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLkVuY29kZXJTZXR0aW5ncykge1xuICAgICAgICAgICAgLy8gaGVyZSB3ZSBzaG91bGQgZWl0aGVyIGdldCBNaW4vTWF4UVAgZnJvbSBQUzFcbiAgICAgICAgICAgIC8vIG9yIE1pbi9NYXhRdWFsaXR5IGZyb20gUFMyXG4gICAgICAgICAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gc2V0IG9uZSBzZXQgb3IgdGhlIG90aGVyIGFzIHRoZXkgY29udmVyZ2UgaW4gQ29tcGF0UXVhbGl0eU1pbi9NYXggYW5kXG4gICAgICAgICAgICAvLyB3ZSBkb250IHdhbnQgdG8gaGF2ZSB0aGVtIGNvbmZsaWN0IHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuRW5jb2RlclNldHRpbmdzLk1pblFQKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0TnVtZXJpY1NldHRpbmcoTnVtZXJpY1BhcmFtZXRlcnMuTWluUVAsIFxuICAgICAgICAgICAgICAgIC8vIElmIGEgc2V0dGluZyBpcyBzZXQgaW4gdGhlIFVSTCwgbWFrZSBzdXJlIHdlIHJlc3BlY3QgdGhhdCB2YWx1ZSBhcyBvcHBvc2VkIHRvIHdoYXQgdGhlIGFwcGxpY2F0aW9uIHNlbmRzIHVzXG4gICAgICAgICAgICAgICAgdXNlVXJsUGFyYW1zICYmIHVybFBhcmFtcy5oYXMoTnVtZXJpY1BhcmFtZXRlcnMuTWluUVApXG4gICAgICAgICAgICAgICAgICAgID8gTnVtYmVyLnBhcnNlRmxvYXQodXJsUGFyYW1zLmdldChOdW1lcmljUGFyYW1ldGVycy5NaW5RUCkpXG4gICAgICAgICAgICAgICAgICAgIDogc2V0dGluZ3MuRW5jb2RlclNldHRpbmdzLk1pblFQIHx8IDApO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldE51bWVyaWNTZXR0aW5nKE51bWVyaWNQYXJhbWV0ZXJzLk1heFFQLCB1c2VVcmxQYXJhbXMgJiYgdXJsUGFyYW1zLmhhcyhOdW1lcmljUGFyYW1ldGVycy5NYXhRUClcbiAgICAgICAgICAgICAgICAgICAgPyBOdW1iZXIucGFyc2VGbG9hdCh1cmxQYXJhbXMuZ2V0KE51bWVyaWNQYXJhbWV0ZXJzLk1heFFQKSlcbiAgICAgICAgICAgICAgICAgICAgOiBzZXR0aW5ncy5FbmNvZGVyU2V0dGluZ3MuTWF4UVAgfHwgNTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLkVuY29kZXJTZXR0aW5ncy5NaW5RdWFsaXR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0TnVtZXJpY1NldHRpbmcoTnVtZXJpY1BhcmFtZXRlcnMuTWluUXVhbGl0eSwgXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBzZXR0aW5nIGlzIHNldCBpbiB0aGUgVVJMLCBtYWtlIHN1cmUgd2UgcmVzcGVjdCB0aGF0IHZhbHVlIGFzIG9wcG9zZWQgdG8gd2hhdCB0aGUgYXBwbGljYXRpb24gc2VuZHMgdXNcbiAgICAgICAgICAgICAgICB1c2VVcmxQYXJhbXMgJiYgdXJsUGFyYW1zLmhhcyhOdW1lcmljUGFyYW1ldGVycy5NaW5RdWFsaXR5KVxuICAgICAgICAgICAgICAgICAgICA/IE51bWJlci5wYXJzZUZsb2F0KHVybFBhcmFtcy5nZXQoTnVtZXJpY1BhcmFtZXRlcnMuTWluUXVhbGl0eSkpXG4gICAgICAgICAgICAgICAgICAgIDogc2V0dGluZ3MuRW5jb2RlclNldHRpbmdzLk1pblF1YWxpdHkgfHwgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0TnVtZXJpY1NldHRpbmcoTnVtZXJpY1BhcmFtZXRlcnMuTWF4UXVhbGl0eSwgdXNlVXJsUGFyYW1zICYmIHVybFBhcmFtcy5oYXMoTnVtZXJpY1BhcmFtZXRlcnMuTWF4UXVhbGl0eSlcbiAgICAgICAgICAgICAgICAgICAgPyBOdW1iZXIucGFyc2VGbG9hdCh1cmxQYXJhbXMuZ2V0KE51bWVyaWNQYXJhbWV0ZXJzLk1heFF1YWxpdHkpKVxuICAgICAgICAgICAgICAgICAgICA6IHNldHRpbmdzLkVuY29kZXJTZXR0aW5ncy5NYXhRdWFsaXR5IHx8IDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGVzZSB0d28gYXJlIGp1c3QgdXNlZCB0byBjb252ZXJnZSBxdWFsaXR5IGFuZCBxcCBhbmQgYmVoYXZlIHNsaWdodGx5IGRpZmZlcmVudGx5IHNpbmNlIHRoZXlcbiAgICAgICAgICAgIC8vIHNob3VsZG50IGV4aXN0IGluIEVuY29kZXJTZXR0aW5nc1xuICAgICAgICAgICAgaWYgKHVzZVVybFBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmICh1cmxQYXJhbXMuaGFzKE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldE51bWVyaWNTZXR0aW5nKE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNaW4sIE51bWJlci5wYXJzZUZsb2F0KHVybFBhcmFtcy5nZXQoTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1pbikpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVybFBhcmFtcy5oYXMoTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1heCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0TnVtZXJpY1NldHRpbmcoTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1heCwgTnVtYmVyLnBhcnNlRmxvYXQodXJsUGFyYW1zLmdldChOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWF4KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MuV2ViUlRDU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldE51bWVyaWNTZXR0aW5nKE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01pbkJpdHJhdGUsIHVzZVVybFBhcmFtcyAmJiB1cmxQYXJhbXMuaGFzKE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01pbkJpdHJhdGUpXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIucGFyc2VGbG9hdCh1cmxQYXJhbXMuZ2V0KE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01pbkJpdHJhdGUpKVxuICAgICAgICAgICAgICAgIDogc2V0dGluZ3MuV2ViUlRDU2V0dGluZ3MuTWluQml0cmF0ZSAvIDEwMDAgLyogYnBzIHRvIGticHMgKi8pO1xuICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0TnVtZXJpY1NldHRpbmcoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWF4Qml0cmF0ZSwgdXNlVXJsUGFyYW1zICYmIHVybFBhcmFtcy5oYXMoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWF4Qml0cmF0ZSlcbiAgICAgICAgICAgICAgICA/IE51bWJlci5wYXJzZUZsb2F0KHVybFBhcmFtcy5nZXQoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWF4Qml0cmF0ZSkpXG4gICAgICAgICAgICAgICAgOiBzZXR0aW5ncy5XZWJSVENTZXR0aW5ncy5NYXhCaXRyYXRlIC8gMTAwMCAvKiBicHMgdG8ga2JwcyAqLyk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXROdW1lcmljU2V0dGluZyhOdW1lcmljUGFyYW1ldGVycy5XZWJSVENGUFMsIHVzZVVybFBhcmFtcyAmJiB1cmxQYXJhbXMuaGFzKE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ0ZQUylcbiAgICAgICAgICAgICAgICA/IE51bWJlci5wYXJzZUZsb2F0KHVybFBhcmFtcy5nZXQoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDRlBTKSlcbiAgICAgICAgICAgICAgICA6IHNldHRpbmdzLldlYlJUQ1NldHRpbmdzLkZQUyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHVwIGZ1bmN0aW9uYWxpdHkgdG8gaGFwcGVuIHdoZW4gc2V0dGluZyBxdWFsaXR5IGNvbnRyb2wgb3duZXJzaGlwIG9mIGEgc3RyZWFtXG4gICAgICogQHBhcmFtIGhhc1F1YWxpdHlPd25lcnNoaXAgLSBkb2VzIHRoaXMgdXNlciBoYXZlIHF1YWxpdHkgb3duZXJzaGlwIG9mIHRoZSBzdHJlYW0gdHJ1ZSAvIGZhbHNlXG4gICAgICovXG4gICAgX29uUXVhbGl0eUNvbnRyb2xPd25lcnNoaXAoaGFzUXVhbGl0eU93bmVyc2hpcCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5zZXRGbGFnRW5hYmxlZChGbGFncy5Jc1F1YWxpdHlDb250cm9sbGVyLCBoYXNRdWFsaXR5T3duZXJzaGlwKTtcbiAgICB9XG4gICAgX29uUGxheWVyQ291bnQocGxheWVyQ291bnQpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFBsYXllckNvdW50RXZlbnQoeyBjb3VudDogcGxheWVyQ291bnQgfSkpO1xuICAgIH1cbiAgICBfb25TdWJzY3JpYmVGYWlsZWQobWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgU3Vic2NyaWJlRmFpbGVkRXZlbnQoeyBtZXNzYWdlOiBtZXNzYWdlIH0pKTtcbiAgICB9XG4gICAgLy8gU2V0cyB1cCB0byBlbWl0IHRoZSB3ZWJydGMgdGNwIHJlbGF5IGRldGVjdCBldmVudFxuICAgIF9zZXR1cFdlYlJ0Y1RDUFJlbGF5RGV0ZWN0aW9uKHN0YXRzUmVjZWl2ZWRFdmVudCkge1xuICAgICAgICAvLyBHZXQgdGhlIGFjdGl2ZSBjYW5kaWRhdGUgcGFpclxuICAgICAgICBjb25zdCBhY3RpdmVDYW5kaWRhdGVQYWlyID0gc3RhdHNSZWNlaXZlZEV2ZW50LmRhdGEuYWdncmVnYXRlZFN0YXRzLmdldEFjdGl2ZUNhbmRpZGF0ZVBhaXIoKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGFjdGl2ZSBjYW5kaWRhdGUgcGFpciBpcyBub3QgbnVsbFxuICAgICAgICBpZiAoYWN0aXZlQ2FuZGlkYXRlUGFpciAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGxvY2FsIGNhbmRpZGF0ZSBhc3NpZ25lZCB0byB0aGUgYWN0aXZlIGNhbmRpZGF0ZSBwYWlyXG4gICAgICAgICAgICBjb25zdCBsb2NhbENhbmRpZGF0ZSA9IHN0YXRzUmVjZWl2ZWRFdmVudC5kYXRhLmFnZ3JlZ2F0ZWRTdGF0cy5sb2NhbENhbmRpZGF0ZXMuZmluZCgoY2FuZGlkYXRlKSA9PiBjYW5kaWRhdGUuaWQgPT0gYWN0aXZlQ2FuZGlkYXRlUGFpci5sb2NhbENhbmRpZGF0ZUlkLCBudWxsKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBsb2NhbCBjYW5kaWRhdGUgaXMgbm90IG51bGwsIGNhbmRpZGF0ZSB0eXBlIGlzIHJlbGF5IGFuZCB0aGUgcmVsYXkgcHJvdG9jb2wgaXMgdGNwXG4gICAgICAgICAgICBpZiAobG9jYWxDYW5kaWRhdGUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIGxvY2FsQ2FuZGlkYXRlLmNhbmRpZGF0ZVR5cGUgPT0gJ3JlbGF5JyAmJlxuICAgICAgICAgICAgICAgIGxvY2FsQ2FuZGlkYXRlLnJlbGF5UHJvdG9jb2wgPT0gJ3RjcCcpIHtcbiAgICAgICAgICAgICAgICAvLyBTZW5kIHRoZSB3ZWIgcnRjIHRjcCByZWxheSBkZXRlY3RlZCBldmVudFxuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBXZWJSdGNUQ1BSZWxheURldGVjdGVkRXZlbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgY2hlY2sgaXMgY29tcGxldGVkIGFuZCB0aGUgc3RhdHMgbGlzdGVuIGV2ZW50IGNhbiBiZSByZW1vdmVkXG4gICAgICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RhdHNSZWNlaXZlZCcsIHRoaXMuX3NldHVwV2ViUnRjVENQUmVsYXlEZXRlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgYSBjb25uZWN0aW9uIGxhdGVuY3kgdGVzdC5cbiAgICAgKiBOT1RFOiBUaGVyZSBhcmUgcGxhbnMgdG8gcmVmYWN0b3IgYWxsIHJlcXVlc3QqIGZ1bmN0aW9ucy4gRXhwZWN0IGNoYW5nZXMgaWYgeW91IHVzZSB0aGlzIVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcmVxdWVzdExhdGVuY3lUZXN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnNlbmRMYXRlbmN5VGVzdCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBhIGRhdGEgY2hhbm5lbCBsYXRlbmN5IHRlc3QuXG4gICAgICogTk9URTogVGhlcmUgYXJlIHBsYW5zIHRvIHJlZmFjdG9yIGFsbCByZXF1ZXN0KiBmdW5jdGlvbnMuIEV4cGVjdCBjaGFuZ2VzIGlmIHlvdSB1c2UgdGhpcyFcbiAgICAgKi9cbiAgICByZXF1ZXN0RGF0YUNoYW5uZWxMYXRlbmN5VGVzdChjb25maWcpIHtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWJSdGNDb250cm9sbGVyLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhQ2hhbm5lbExhdGVuY3lUZXN0Q29udHJvbGxlcikge1xuICAgICAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWxMYXRlbmN5VGVzdENvbnRyb2xsZXIgPSBuZXcgRGF0YUNoYW5uZWxMYXRlbmN5VGVzdENvbnRyb2xsZXIodGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZW5kRGF0YUNoYW5uZWxMYXRlbmN5VGVzdC5iaW5kKHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIpLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IERhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXN1bHRFdmVudCh7IHJlc3VsdCB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlc3BvbnNlJywgKHsgZGF0YTogeyByZXNwb25zZSB9IH0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbExhdGVuY3lUZXN0Q29udHJvbGxlci5yZWNlaXZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhQ2hhbm5lbExhdGVuY3lUZXN0Q29udHJvbGxlci5zdGFydChjb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGZvciB0aGUgVUUgYXBwbGljYXRpb24gdG8gc2hvdyBGUFMgY291bnRlci5cbiAgICAgKiBOT1RFOiBUaGVyZSBhcmUgcGxhbnMgdG8gcmVmYWN0b3IgYWxsIHJlcXVlc3QqIGZ1bmN0aW9ucy4gRXhwZWN0IGNoYW5nZXMgaWYgeW91IHVzZSB0aGlzIVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcmVxdWVzdFNob3dGcHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fd2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZFNob3dGcHMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgZm9yIGEgbmV3IElGcmFtZSBmcm9tIHRoZSBVRSBhcHBsaWNhdGlvbi5cbiAgICAgKiBOT1RFOiBUaGVyZSBhcmUgcGxhbnMgdG8gcmVmYWN0b3IgYWxsIHJlcXVlc3QqIGZ1bmN0aW9ucy4gRXhwZWN0IGNoYW5nZXMgaWYgeW91IHVzZSB0aGlzIVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcmVxdWVzdElmcmFtZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWJSdGNDb250cm9sbGVyLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZW5kSWZyYW1lUmVxdWVzdCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIHRvIFVFIGFwcGxpY2F0aW9uLiBUaGUgZGF0YSB3aWxsIGJlIHJ1biB0aHJvdWdoIEpTT04uc3RyaW5naWZ5KCkgc28gZS5nLiBzdHJpbmdzXG4gICAgICogYW5kIGFueSBzZXJpYWxpemFibGUgcGxhaW4gSlNPTiBvYmplY3RzIHdpdGggbm8gcmVjdXJyZW5jZSBjYW4gYmUgc2VudC5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHN1Y2NlZWRlZCwgZmFsc2UgaWYgcmVqZWN0ZWRcbiAgICAgKi9cbiAgICBlbWl0VUlJbnRlcmFjdGlvbihkZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmICghdGhpcy5fd2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuZW1pdFVJSW50ZXJhY3Rpb24oZGVzY3JpcHRvcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgY29tbWFuZCB0byBVRSBhcHBsaWNhdGlvbi4gQmxvY2tzIENvbnNvbGVDb21tYW5kIGRlc2NyaXB0b3JzIHVubGVzcyBVRVxuICAgICAqIGhhcyBzaWduYWxlZCB0aGF0IGl0IGFsbG93cyBjb25zb2xlIGNvbW1hbmRzLlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgc3VjY2VlZGVkLCBmYWxzZSBpZiByZWplY3RlZFxuICAgICAqL1xuICAgIGVtaXRDb21tYW5kKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWJSdGNDb250cm9sbGVyLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmFsbG93Q29uc29sZUNvbW1hbmRzICYmICdDb25zb2xlQ29tbWFuZCcgaW4gZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuZW1pdENvbW1hbmQoZGVzY3JpcHRvcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgY29uc29sZSBjb21tYW5kIHRvIFVFIGFwcGxpY2F0aW9uLiBPbmx5IGFsbG93ZWQgaWYgVUUgaGFzIHNpZ25hbGVkIHRoYXQgaXQgYWxsb3dzXG4gICAgICogY29uc29sZSBjb21tYW5kcy5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHN1Y2NlZWRlZCwgZmFsc2UgaWYgcmVqZWN0ZWRcbiAgICAgKi9cbiAgICBlbWl0Q29uc29sZUNvbW1hbmQoY29tbWFuZCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsb3dDb25zb2xlQ29tbWFuZHMgfHwgIXRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLmVtaXRDb25zb2xlQ29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRleHQgY29udGVudHMgb2YgdGhlIGN1cnJlbnRseSBmb2N1c2VkIFVFIHRleHQgYm94IHdpZGdldC5cbiAgICAgKiBAcGFyYW0gY29udGVudHMgVGhlIG5ldyBjb250ZW50cyBvZiB0aGUgVUUgdGV4dCBib3guXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbWVzc2FnZSBjb3VsZCBiZSBzZW50LlxuICAgICAqL1xuICAgIHNlbmRUZXh0Ym94RW50cnkoY29udGVudHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWJSdGNDb250cm9sbGVyLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZW5kVGV4dGJveEVudHJ5KGNvbnRlbnRzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIFVFIC0+IGJyb3dzZXIgcmVzcG9uc2UgZXZlbnQgbGlzdGVuZXJcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSByZXNwb25zZSBoYW5kbGVyXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIG1ldGhvZCB0byBiZSBhY3RpdmF0ZWQgd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWRcbiAgICAgKi9cbiAgICBhZGRSZXNwb25zZUV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5yZXNwb25zZUNvbnRyb2xsZXIuYWRkUmVzcG9uc2VFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgVUUgLT4gYnJvd3NlciByZXNwb25zZSBldmVudCBsaXN0ZW5lclxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHJlc3BvbnNlIGhhbmRsZXJcbiAgICAgKi9cbiAgICByZW1vdmVSZXNwb25zZUV2ZW50TGlzdGVuZXIobmFtZSkge1xuICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnJlc3BvbnNlQ29udHJvbGxlci5yZW1vdmVSZXNwb25zZUV2ZW50TGlzdGVuZXIobmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGEgbmV3IGV2ZW50LlxuICAgICAqIEBwYXJhbSBlIGV2ZW50XG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBkaXNwYXRjaEV2ZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhbiBldmVudCBoYW5kbGVyLlxuICAgICAqIEBwYXJhbSB0eXBlIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZXZlbnQgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0gdHlwZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlL2Rpc2FibGUgWFIgbW9kZS5cbiAgICAgKi9cbiAgICB0b2dnbGVYUigpIHtcbiAgICAgICAgdGhpcy53ZWJYckNvbnRyb2xsZXIueHJDbGlja2VkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhc3MgaW4gYSBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIHNpZ25hbGxpbmcgc2VydmVyIFVSTC5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCBpZiB5b3UgbmVlZCB0byBwcm9ncmFtbWF0aWNhbGx5IGNvbnN0cnVjdCB5b3VyIHNpZ25hbGxpbmcgc2VydmVyIFVSTC5cbiAgICAgKiBAcGFyYW0gc2lnbmFsbGluZ1VybEJ1aWxkZXJGdW5jIEEgZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgYSBzaWduYWxsaW5nIHNlcnZlciB1cmwuXG4gICAgICovXG4gICAgc2V0U2lnbmFsbGluZ1VybEJ1aWxkZXIoc2lnbmFsbGluZ1VybEJ1aWxkZXJGdW5jKSB7XG4gICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2lnbmFsbGluZ1VybEJ1aWxkZXIgPSBzaWduYWxsaW5nVXJsQnVpbGRlckZ1bmM7XG4gICAgfVxuICAgIGdldCB3ZWJSdGNDb250cm9sbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2ViUnRjQ29udHJvbGxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIGdldHRlciBmb3IgdGhlIHdlYnNvY2tldCBjb250cm9sbGVyLiBBY2Nlc3MgdG8gdGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIHNlbmRcbiAgICAgKiBjdXN0b20gd2Vic29ja2V0IG1lc3NhZ2VzLlxuICAgICAqL1xuICAgIGdldCBzaWduYWxsaW5nUHJvdG9jb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnByb3RvY29sO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZ2V0dGVyIGZvciB0aGUgd2ViWHJDb250cm9sbGVyIGNvbnRyb2xsZXIuIFVzZWQgZm9yIGFsbCBYUiBmZWF0dXJlcy5cbiAgICAgKi9cbiAgICBnZXQgd2ViWHJDb250cm9sbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2ViWHJDb250cm9sbGVyO1xuICAgIH1cbiAgICByZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKG5hbWUsIGRpcmVjdGlvbiwgaGFuZGxlcikge1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciAmJiB0eXBlb2YgaGFuZGxlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIExvZ2dlci5XYXJuaW5nKGBVbmFibGUgdG8gcmVnaXN0ZXIgYW4gdW5kZWZpbmVkIGhhbmRsZXIgZm9yICR7bmFtZX1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIgJiYgdHlwZW9mIGhhbmRsZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoZGlyZWN0aW9uLCBuYW1lLCAoZGF0YSkgPT4gdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKG5hbWUsIGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihkaXJlY3Rpb24sIG5hbWUsIChkYXRhKSA9PiBoYW5kbGVyKGRhdGEpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdG9TdHJlYW1lckhhbmRsZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnM7XG4gICAgfVxuICAgIGlzUmVjb25uZWN0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2ViUnRjQ29udHJvbGxlci5pc1JlY29ubmVjdGluZztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QaXhlbFN0cmVhbWluZy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuZXhwb3J0IGNsYXNzIFJlc3BvbnNlQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2VFdmVudExpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgcmVzcG9uc2UgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHJlc3BvbnNlIG1hcFxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIG1ldGhvZCB0byBiZSBhY3RpdmF0ZWQgd2hlbiB0aGUgcmVzcG9uc2UgaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBhZGRSZXNwb25zZUV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZUV2ZW50TGlzdGVuZXJzLnNldChuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHJlc3BvbnNlIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSByZXNwb25zZSBtYXBcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSByZXNwb25zZVxuICAgICAqL1xuICAgIHJlbW92ZVJlc3BvbnNlRXZlbnRMaXN0ZW5lcihuYW1lKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2VFdmVudExpc3RlbmVycy5kZWxldGUobmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIHJlc3BvbnNlIHdoZW4gcmVjZWl2aW5nIG9uZSBmb3JtIHRoZSBzdHJlYW1lclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gRGF0YSByZWNlaXZlZCBmcm9tIHRoZSBkYXRhIGNoYW5uZWwgd2l0aCB0aGUgY29tbWFuZCBpbiBxdWVzdGlvblxuICAgICAqL1xuICAgIG9uUmVzcG9uc2UobWVzc2FnZSkge1xuICAgICAgICBMb2dnZXIuSW5mbygnRGF0YUNoYW5uZWxSZWNlaXZlTWVzc2FnZVR5cGUuUmVzcG9uc2UnKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gbmV3IFRleHREZWNvZGVyKCd1dGYtMTYnKS5kZWNvZGUobWVzc2FnZS5zbGljZSgxKSk7XG4gICAgICAgIExvZ2dlci5JbmZvKHJlc3BvbnNlcyk7XG4gICAgICAgIHRoaXMucmVzcG9uc2VFdmVudExpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXIocmVzcG9uc2VzKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVzcG9uc2VDb250cm9sbGVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG5leHBvcnQgY2xhc3MgU2VuZE1lc3NhZ2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YUNoYW5uZWxTZW5kZXIgLSBEYXRhIGNoYW5uZWwgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gdG9TdHJlYW1lck1lc3NhZ2VzTWFwUHJvdmlkZXIgLSBTdHJlYW0gTWVzc2FnZXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkYXRhQ2hhbm5lbFNlbmRlciwgdG9TdHJlYW1lck1lc3NhZ2VzTWFwUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbFNlbmRlciA9IGRhdGFDaGFubmVsU2VuZGVyO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlc01hcFByb3ZpZGVyID0gdG9TdHJlYW1lck1lc3NhZ2VzTWFwUHJvdmlkZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBzdHJlYW1lciB0aHJvdWdoIHRoZSBkYXRhIGNoYW5uZWxcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVR5cGUgLSB0aGUgdHlwZSBvZiBtZXNzYWdlIHdlIGFyZSBzZW5kaW5nXG4gICAgICogQHBhcmFtIG1lc3NhZ2VEYXRhIC0gdGhlIG1lc3NhZ2UgZGF0YSB3ZSBhcmUgc2VuZGluZyBvdmVyIHRoZSBkYXRhIGNoYW5uZWxcbiAgICAgKiBAcmV0dXJucyAtIG5pbFxuICAgICAqL1xuICAgIHNlbmRNZXNzYWdlVG9TdHJlYW1lcihtZXNzYWdlVHlwZSwgbWVzc2FnZURhdGEpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VEYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VEYXRhID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9TdHJlYW1lck1lc3NhZ2VzID0gdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNNYXBQcm92aWRlci50b1N0cmVhbWVyTWVzc2FnZXM7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VGb3JtYXQgPSB0b1N0cmVhbWVyTWVzc2FnZXMuZ2V0KG1lc3NhZ2VUeXBlKTtcbiAgICAgICAgaWYgKG1lc3NhZ2VGb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBBdHRlbXB0ZWQgdG8gc2VuZCBhIG1lc3NhZ2UgdG8gdGhlIHN0cmVhbWVyIHdpdGggbWVzc2FnZSB0eXBlOiAke21lc3NhZ2VUeXBlfSwgYnV0IHRoZSBmcm9udGVuZCBoYXNuJ3QgYmVlbiBjb25maWd1cmVkIHRvIHNlbmQgc3VjaCBhIG1lc3NhZ2UuIENoZWNrIHlvdSd2ZSBhZGRlZCB0aGUgbWVzc2FnZSB0eXBlIGluIHlvdXIgY3BwYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2VGb3JtYXQuc3RydWN0dXJlICYmIG1lc3NhZ2VEYXRhICYmIG1lc3NhZ2VGb3JtYXQuc3RydWN0dXJlLmxlbmd0aCAhPT0gbWVzc2FnZURhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoYFByb3ZpZGVkIG1lc3NhZ2UgZGF0YSBkb2Vzbid0IG1hdGNoIGV4cGVjdGVkIGxheW91dC4gRXhwZWN0ZWQgWyAke21lc3NhZ2VGb3JtYXQuc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgLm1hcCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRvU3RyaW5nKCl9IF0gYnV0IHJlY2VpdmVkIFsgJHttZXNzYWdlRGF0YS5tYXAoKGVsZW1lbnQpID0+IHR5cGVvZiBlbGVtZW50KS50b1N0cmluZygpfSBdYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ5dGVMZW5ndGggPSAwO1xuICAgICAgICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICAvLyBPbmUgbG9vcCB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCBpbiBieXRlcyBvZiBhbGwgb2YgdGhlIHByb3ZpZGVkIGRhdGFcbiAgICAgICAgbWVzc2FnZURhdGEuZm9yRWFjaCgoZWxlbWVudCwgaWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gbWVzc2FnZUZvcm1hdC5zdHJ1Y3R1cmVbaWR4XTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgICAgICAgICAgICAgICAgYnl0ZUxlbmd0aCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgICAgICAgICAgICAgYnl0ZUxlbmd0aCArPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGggKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgICAgICAgICAgYnl0ZUxlbmd0aCArPSA4O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAvLyAyIGJ5dGVzIGZvciBzdHJpbmcgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGggKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgLy8gMiBieXRlcyBwZXIgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoICs9IDIgKiB0ZXh0RW5jb2Rlci5lbmNvZGUoZWxlbWVudCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKGJ5dGVMZW5ndGggKyAxKSk7XG4gICAgICAgIGRhdGEuc2V0VWludDgoMCwgbWVzc2FnZUZvcm1hdC5pZCk7XG4gICAgICAgIGxldCBieXRlT2Zmc2V0ID0gMTtcbiAgICAgICAgbWVzc2FnZURhdGEuZm9yRWFjaCgoZWxlbWVudCwgaWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gbWVzc2FnZUZvcm1hdC5zdHJ1Y3R1cmVbaWR4XTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRVaW50OChieXRlT2Zmc2V0LCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNldFVpbnQxNihieXRlT2Zmc2V0LCBlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SW50MTYoYnl0ZU9mZnNldCwgZWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEZsb2F0MzIoYnl0ZU9mZnNldCwgZWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIGVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0VWludDE2KGJ5dGVPZmZzZXQsIGVsZW1lbnQubGVuZ3RoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0VWludDE2KGJ5dGVPZmZzZXQsIGVsZW1lbnQuY2hhckNvZGVBdChpKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuZGF0YUNoYW5uZWxTZW5kZXIuY2FuU2VuZCgpKSB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbyhgRGF0YSBjaGFubmVsIGNhbm5vdCBzZW5kIHlldCwgc2tpcHBpbmcgc2VuZGluZyBtZXNzYWdlOiAke21lc3NhZ2VUeXBlfSAtICR7bmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIpfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWxTZW5kZXIuc2VuZERhdGEoZGF0YS5idWZmZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlbmRNZXNzYWdlQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuZXhwb3J0IGNsYXNzIFRvU3RyZWFtZXJNZXNzYWdlIHtcbn1cbmV4cG9ydCBjbGFzcyBTdHJlYW1NZXNzYWdlQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lckhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lckhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJNZXNzYWdlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9wdWxhdGUgdGhlIERlZmF1bHQgbWVzc2FnZSBwcm90b2NvbFxuICAgICAqL1xuICAgIHBvcHVsYXRlRGVmYXVsdFByb3RvY29sKCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBDb250cm9sIE1lc3NhZ2VzLiBSYW5nZSA9IDAuLjQ5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdJRnJhbWVSZXF1ZXN0Jywge1xuICAgICAgICAgICAgaWQ6IDAsXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ1JlcXVlc3RRdWFsaXR5Q29udHJvbCcsIHtcbiAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdGcHNSZXF1ZXN0Jywge1xuICAgICAgICAgICAgaWQ6IDIsXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ0F2ZXJhZ2VCaXRyYXRlUmVxdWVzdCcsIHtcbiAgICAgICAgICAgIGlkOiAzLFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdTdGFydFN0cmVhbWluZycsIHtcbiAgICAgICAgICAgIGlkOiA0LFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdTdG9wU3RyZWFtaW5nJywge1xuICAgICAgICAgICAgaWQ6IDUsXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ0xhdGVuY3lUZXN0Jywge1xuICAgICAgICAgICAgaWQ6IDYsXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsnc3RyaW5nJ11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnUmVxdWVzdEluaXRpYWxTZXR0aW5ncycsIHtcbiAgICAgICAgICAgIGlkOiA3LFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdUZXN0RWNobycsIHtcbiAgICAgICAgICAgIGlkOiA4LFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdEYXRhQ2hhbm5lbExhdGVuY3lUZXN0Jywge1xuICAgICAgICAgICAgaWQ6IDksXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICAvKlxuICAgICAgICAgKiBJbnB1dCBNZXNzYWdlcy4gUmFuZ2UgPSA1MC4uODkuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBHZW5lcmljIElucHV0IE1lc3NhZ2VzLiBSYW5nZSA9IDUwLi41OS5cbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdVSUludGVyYWN0aW9uJywge1xuICAgICAgICAgICAgaWQ6IDUwLFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3N0cmluZyddXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ0NvbW1hbmQnLCB7XG4gICAgICAgICAgICBpZDogNTEsXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsnc3RyaW5nJ11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnVGV4dGJveEVudHJ5Jywge1xuICAgICAgICAgICAgaWQ6IDUyLFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3N0cmluZyddXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBLZXlib2FyZCBJbnB1dCBNZXNzYWdlLiBSYW5nZSA9IDYwLi42OS5cbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdLZXlEb3duJywge1xuICAgICAgICAgICAgaWQ6IDYwLFxuICAgICAgICAgICAgLy8gICAgICAgICAgICBrZXlDb2RlICBpc1JlcGVhdFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3VpbnQ4JywgJ3VpbnQ4J11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnS2V5VXAnLCB7XG4gICAgICAgICAgICBpZDogNjEsXG4gICAgICAgICAgICAvLyAgICAgICAgICAgIGtleUNvZGVcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWyd1aW50OCddXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ0tleVByZXNzJywge1xuICAgICAgICAgICAgaWQ6IDYyLFxuICAgICAgICAgICAgLy8gICAgICAgICAgICBjaGFyY29kZVxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3VpbnQxNiddXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBNb3VzZSBJbnB1dCBNZXNzYWdlcy4gUmFuZ2UgPSA3MC4uNzkuXG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnTW91c2VFbnRlcicsIHtcbiAgICAgICAgICAgIGlkOiA3MCxcbiAgICAgICAgICAgIHN0cnVjdHVyZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnTW91c2VMZWF2ZScsIHtcbiAgICAgICAgICAgIGlkOiA3MSxcbiAgICAgICAgICAgIHN0cnVjdHVyZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnTW91c2VEb3duJywge1xuICAgICAgICAgICAgaWQ6IDcyLFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGJ1dHRvbiAgICAgeCAgICAgICAgIHlcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWyd1aW50OCcsICd1aW50MTYnLCAndWludDE2J11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnTW91c2VVcCcsIHtcbiAgICAgICAgICAgIGlkOiA3MyxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICBidXR0b24gICAgIHggICAgICAgICB5XG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsndWludDgnLCAndWludDE2JywgJ3VpbnQxNiddXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ01vdXNlTW92ZScsIHtcbiAgICAgICAgICAgIGlkOiA3NCxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICB4ICAgICAgICAgICB5ICAgICAgZGVsdGFYICAgIGRlbHRhWVxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3VpbnQxNicsICd1aW50MTYnLCAnaW50MTYnLCAnaW50MTYnXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdNb3VzZVdoZWVsJywge1xuICAgICAgICAgICAgaWQ6IDc1LFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGRlbHRhICAgICAgIHggICAgICAgIHlcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWydpbnQxNicsICd1aW50MTYnLCAndWludDE2J11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnTW91c2VEb3VibGUnLCB7XG4gICAgICAgICAgICBpZDogNzYsXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgYnV0dG9uICAgICB4ICAgICAgICAgeVxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3VpbnQ4JywgJ3VpbnQxNicsICd1aW50MTYnXVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVG91Y2ggSW5wdXQgTWVzc2FnZXMuIFJhbmdlID0gODAuLjg5LlxuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ1RvdWNoU3RhcnQnLCB7XG4gICAgICAgICAgICBpZDogODAsXG4gICAgICAgICAgICAvLyAgICAgICAgICBudW10b3VjaGVzKDEpICAgeCAgICAgICB5ICAgICAgICBpZHggICAgIGZvcmNlICAgICB2YWxpZFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3VpbnQ4JywgJ3VpbnQxNicsICd1aW50MTYnLCAndWludDgnLCAndWludDgnLCAndWludDgnXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdUb3VjaEVuZCcsIHtcbiAgICAgICAgICAgIGlkOiA4MSxcbiAgICAgICAgICAgIC8vICAgICAgICAgIG51bXRvdWNoZXMoMSkgICB4ICAgICAgIHkgICAgICAgIGlkeCAgICAgZm9yY2UgICAgIHZhbGlkXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsndWludDgnLCAndWludDE2JywgJ3VpbnQxNicsICd1aW50OCcsICd1aW50OCcsICd1aW50OCddXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ1RvdWNoTW92ZScsIHtcbiAgICAgICAgICAgIGlkOiA4MixcbiAgICAgICAgICAgIC8vICAgICAgICAgIG51bXRvdWNoZXMoMSkgICB4ICAgICAgIHkgICAgICAgaWR4ICAgICAgZm9yY2UgICAgIHZhbGlkXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsndWludDgnLCAndWludDE2JywgJ3VpbnQxNicsICd1aW50OCcsICd1aW50OCcsICd1aW50OCddXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBHYW1lcGFkIElucHV0IE1lc3NhZ2VzLiBSYW5nZSA9IDkwLi45OVxuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ0dhbWVwYWRDb25uZWN0ZWQnLCB7XG4gICAgICAgICAgICBpZDogOTMsXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ0dhbWVwYWRCdXR0b25QcmVzc2VkJywge1xuICAgICAgICAgICAgaWQ6IDkwLFxuICAgICAgICAgICAgLy8gICAgICAgICBjdHJsZXJJZCAgIGJ1dHRvbiAgaXNSZXBlYXRcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWyd1aW50OCcsICd1aW50OCcsICd1aW50OCddXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ0dhbWVwYWRCdXR0b25SZWxlYXNlZCcsIHtcbiAgICAgICAgICAgIGlkOiA5MSxcbiAgICAgICAgICAgIC8vICAgICAgICAgY3RybGVySWQgICBidXR0b24gIGlzUmVwZWF0KDApXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsndWludDgnLCAndWludDgnLCAndWludDgnXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdHYW1lcGFkQW5hbG9nJywge1xuICAgICAgICAgICAgaWQ6IDkyLFxuICAgICAgICAgICAgLy8gICAgICAgICBjdHJsZXJJZCAgIGJ1dHRvbiAgYW5hbG9nVmFsdWVcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWyd1aW50OCcsICd1aW50OCcsICdkb3VibGUnXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdHYW1lcGFkRGlzY29ubmVjdGVkJywge1xuICAgICAgICAgICAgaWQ6IDk0LFxuICAgICAgICAgICAgLy8gICAgICAgICAgY3RybGVySWRcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWyd1aW50OCddXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCgwLCAnUXVhbGl0eUNvbnRyb2xPd25lcnNoaXAnKTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJNZXNzYWdlcy5zZXQoMSwgJ1Jlc3BvbnNlJyk7XG4gICAgICAgIHRoaXMuZnJvbVN0cmVhbWVyTWVzc2FnZXMuc2V0KDIsICdDb21tYW5kJyk7XG4gICAgICAgIHRoaXMuZnJvbVN0cmVhbWVyTWVzc2FnZXMuc2V0KDMsICdGcmVlemVGcmFtZScpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCg0LCAnVW5mcmVlemVGcmFtZScpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCg1LCAnVmlkZW9FbmNvZGVyQXZnUVAnKTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJNZXNzYWdlcy5zZXQoNiwgJ0xhdGVuY3lUZXN0Jyk7XG4gICAgICAgIHRoaXMuZnJvbVN0cmVhbWVyTWVzc2FnZXMuc2V0KDcsICdJbml0aWFsU2V0dGluZ3MnKTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJNZXNzYWdlcy5zZXQoOCwgJ0ZpbGVFeHRlbnNpb24nKTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJNZXNzYWdlcy5zZXQoOSwgJ0ZpbGVNaW1lVHlwZScpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCgxMCwgJ0ZpbGVDb250ZW50cycpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCgxMSwgJ1Rlc3RFY2hvJyk7XG4gICAgICAgIHRoaXMuZnJvbVN0cmVhbWVyTWVzc2FnZXMuc2V0KDEyLCAnSW5wdXRDb250cm9sT3duZXJzaGlwJyk7XG4gICAgICAgIHRoaXMuZnJvbVN0cmVhbWVyTWVzc2FnZXMuc2V0KDEzLCAnR2FtZXBhZFJlc3BvbnNlJyk7XG4gICAgICAgIHRoaXMuZnJvbVN0cmVhbWVyTWVzc2FnZXMuc2V0KDE0LCAnRGF0YUNoYW5uZWxMYXRlbmN5VGVzdCcpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCgyNTUsICdQcm90b2NvbCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIG1lc3NhZ2UgaGFuZGxlclxuICAgICAqIEBwYXJhbSBtZXNzYWdlRGlyZWN0aW9uIC0gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbWVzc2FnZTsgdG9TdHJlYW1lciBvciBmcm9tU3RyZWFtZXJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVR5cGUgLSB0aGUgdHlwZSBvZiB0aGUgbWVzc2FnZVxuICAgICAqIEBwYXJhbSBtZXNzYWdlSGFuZGxlciAtIHRoZSBmdW5jdGlvbiBvciBtZXRob2QgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGlzIGhhbmRsZXIgaXMgY2FsbGVkXG4gICAgICovXG4gICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihtZXNzYWdlRGlyZWN0aW9uLCBtZXNzYWdlVHlwZSwgbWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lcjpcbiAgICAgICAgICAgICAgICB0aGlzLnRvU3RyZWFtZXJIYW5kbGVycy5zZXQobWVzc2FnZVR5cGUsIG1lc3NhZ2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXI6XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJIYW5kbGVycy5zZXQobWVzc2FnZVR5cGUsIG1lc3NhZ2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkluZm8oYFVua25vd24gbWVzc2FnZSBkaXJlY3Rpb24gJHttZXNzYWdlRGlyZWN0aW9ufWApO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgZW51bSBmb3IgbWVzc2FnZSBkaXJlY3Rpb25zXG4gKi9cbmV4cG9ydCB2YXIgTWVzc2FnZURpcmVjdGlvbjtcbihmdW5jdGlvbiAoTWVzc2FnZURpcmVjdGlvbikge1xuICAgIE1lc3NhZ2VEaXJlY3Rpb25bTWVzc2FnZURpcmVjdGlvbltcIlRvU3RyZWFtZXJcIl0gPSAwXSA9IFwiVG9TdHJlYW1lclwiO1xuICAgIE1lc3NhZ2VEaXJlY3Rpb25bTWVzc2FnZURpcmVjdGlvbltcIkZyb21TdHJlYW1lclwiXSA9IDFdID0gXCJGcm9tU3RyZWFtZXJcIjtcbn0pKE1lc3NhZ2VEaXJlY3Rpb24gfHwgKE1lc3NhZ2VEaXJlY3Rpb24gPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmV4cG9ydCBjbGFzcyBUb1N0cmVhbWVyTWVzc2FnZXNDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gc2VuZE1lc3NhZ2VDb250cm9sbGVyIC0gU3RyZWFtIG1lc3NhZ2UgY29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlbmRNZXNzYWdlQ29udHJvbGxlcikge1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlciA9IHNlbmRNZXNzYWdlQ29udHJvbGxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBSZXF1ZXN0IHRvIFRha2UgUXVhbGl0eSBDb250cm9sIHRvIHRoZSBVRSBJbnN0YW5jZVxuICAgICAqL1xuICAgIFNlbmRSZXF1ZXN0UXVhbGl0eUNvbnRyb2woKSB7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignUmVxdWVzdFF1YWxpdHlDb250cm9sJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgTWF4IEZQUyBSZXF1ZXN0IHRvIHRoZSBVRSBJbnN0YW5jZVxuICAgICAqL1xuICAgIFNlbmRNYXhGcHNSZXF1ZXN0KCkge1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0Zwc1JlcXVlc3QnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBBdmVyYWdlIEJpdHJhdGUgUmVxdWVzdCB0byB0aGUgVUUgSW5zdGFuY2VcbiAgICAgKi9cbiAgICBTZW5kQXZlcmFnZUJpdHJhdGVSZXF1ZXN0KCkge1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0F2ZXJhZ2VCaXRyYXRlUmVxdWVzdCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgU3RhcnQgU3RyZWFtaW5nIE1lc3NhZ2UgdG8gdGhlIFVFIEluc3RhbmNlXG4gICAgICovXG4gICAgU2VuZFN0YXJ0U3RyZWFtaW5nKCkge1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1N0YXJ0U3RyZWFtaW5nJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBTdG9wIFN0cmVhbWluZyBNZXNzYWdlIHRvIHRoZSBVRSBJbnN0YW5jZVxuICAgICAqL1xuICAgIFNlbmRTdG9wU3RyZWFtaW5nKCkge1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1N0b3BTdHJlYW1pbmcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIFJlcXVlc3QgSW5pdGlhbCBTZXR0aW5ncyB0byB0aGUgVUUgSW5zdGFuY2VcbiAgICAgKi9cbiAgICBTZW5kUmVxdWVzdEluaXRpYWxTZXR0aW5ncygpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdSZXF1ZXN0SW5pdGlhbFNldHRpbmdzJyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG9TdHJlYW1lck1lc3NhZ2VzQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuZXhwb3J0IGNsYXNzIEJyb3dzZXJVdGlscyB7XG4gICAgc3RhdGljIGdldFN1cHBvcnRlZFZpZGVvQ29kZWNzKCkge1xuICAgICAgICBjb25zdCBicm93c2VyU3VwcG9ydGVkQ29kZWNzID0gW107XG4gICAgICAgIC8vIFRyeSBnZXQgdGhlIGluZm8gbmVlZGVkIGZyb20gdGhlIFJUQ1J0cFJlY2VpdmVyLiBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIG9uIGNocm9tZVxuICAgICAgICBpZiAoIVJUQ1J0cFJlY2VpdmVyLmdldENhcGFiaWxpdGllcykge1xuICAgICAgICAgICAgTG9nZ2VyLldhcm5pbmcoJ1JUQ1J0cFJlY2VpdmVyLmdldENhcGFiaWxpdGllcyBBUEkgaXMgbm90IGF2YWlsYWJsZSBpbiB5b3VyIGJyb3dzZXIsIGRlZmF1bHRpbmcgdG8gZ3Vlc3MgdGhhdCB3ZSBzdXBwb3J0IEguMjY0LicpO1xuICAgICAgICAgICAgYnJvd3NlclN1cHBvcnRlZENvZGVjcy5wdXNoKCdIMjY0IGxldmVsLWFzeW1tZXRyeS1hbGxvd2VkPTE7cGFja2V0aXphdGlvbi1tb2RlPTE7cHJvZmlsZS1sZXZlbC1pZD00MmUwMWYnKTtcbiAgICAgICAgICAgIHJldHVybiBicm93c2VyU3VwcG9ydGVkQ29kZWNzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdGNoZXIgPSAvKFZQXFxkfEgyNlxcZHxBVjEpLiovO1xuICAgICAgICBjb25zdCBjYXBhYmlsaXRpZXMgPSBSVENSdHBSZWNlaXZlci5nZXRDYXBhYmlsaXRpZXMoJ3ZpZGVvJyk7XG4gICAgICAgIGlmICghY2FwYWJpbGl0aWVzKSB7XG4gICAgICAgICAgICBicm93c2VyU3VwcG9ydGVkQ29kZWNzLnB1c2goJ0gyNjQgbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQ9MTtwYWNrZXRpemF0aW9uLW1vZGU9MTtwcm9maWxlLWxldmVsLWlkPTQyZTAxZicpO1xuICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXJTdXBwb3J0ZWRDb2RlY3M7XG4gICAgICAgIH1cbiAgICAgICAgY2FwYWJpbGl0aWVzLmNvZGVjcy5mb3JFYWNoKChjb2RlYykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RyID0gY29kZWMubWltZVR5cGUuc3BsaXQoJy8nKVsxXSArICcgJyArIChjb2RlYy5zZHBGbXRwTGluZSB8fCAnJyk7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXIuZXhlYyhzdHIpO1xuICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYnJvd3NlclN1cHBvcnRlZENvZGVjcy5wdXNoKHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYnJvd3NlclN1cHBvcnRlZENvZGVjcztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ccm93c2VyVXRpbHMuanMubWFwIiwiLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBBRksgZGlzY29ubmVjdCBpcyBhYm91dCB0byBoYXBwZW4uXG4gKiBDYW4gYmUgY2FuY2VsbGVkIGJ5IGNhbGxpbmcgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHByb3ZpZGVkIGFzIHBhcnQgb2YgdGhlIGV2ZW50LlxuICovXG5leHBvcnQgY2xhc3MgQWZrV2FybmluZ0FjdGl2YXRlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignYWZrV2FybmluZ0FjdGl2YXRlJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB0aGUgQUZLIGRpc2Nvbm5lY3QgY291bnRkb3duIGlzIHVwZGF0ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBBZmtXYXJuaW5nVXBkYXRlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignYWZrV2FybmluZ1VwZGF0ZScpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gQUZLIHdhcm5pbmcgaXMgZGVhY3RpdmF0ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBBZmtXYXJuaW5nRGVhY3RpdmF0ZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignYWZrV2FybmluZ0RlYWN0aXZhdGUnKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIEFGSyBjb3VudGRvd24gcmVhY2hlcyAwIGFuZCB0aGUgdXNlciBpcyBkaXNjb25uZWN0ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBBZmtUaW1lZE91dEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignYWZrVGltZWRPdXQnKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHdlIHJlY2VpdmUgbmV3IHZpZGVvIHF1YWxpdHkgdmFsdWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBWaWRlb0VuY29kZXJBdmdRUEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ3ZpZGVvRW5jb2RlckF2Z1FQJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXIgYSBXZWJSdGMgY29ubmVjdGlvbiBoYXMgYmVlbiBuZWdvdGlhdGVkLlxuICovXG5leHBvcnQgY2xhc3MgV2ViUnRjU2RwRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCd3ZWJSdGNTZHAnKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBhZnRlciB0aGUgU0RQIGFuc3dlciBpcyBzZXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJSdGNTZHBBbnN3ZXJFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCd3ZWJSdGNTZHBBbnN3ZXInKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBhZnRlciB0aGUgU0RQIG9mZmVyIGlzIHNldC5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYlJ0Y1NkcE9mZmVyRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignd2ViUnRjU2RwT2ZmZXInKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIGF1dG8gY29ubmVjdGluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYlJ0Y0F1dG9Db25uZWN0RXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCd3ZWJSdGNBdXRvQ29ubmVjdCcpO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gc2VuZGluZyBhIFdlYlJ0YyBvZmZlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYlJ0Y0Nvbm5lY3RpbmdFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3dlYlJ0Y0Nvbm5lY3RpbmcnKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIFdlYlJ0YyBjb25uZWN0aW9uIGhhcyBiZWVuIGVzdGFibGlzaGVkLlxuICovXG5leHBvcnQgY2xhc3MgV2ViUnRjQ29ubmVjdGVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCd3ZWJSdGNDb25uZWN0ZWQnKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBpZiBXZWJSdGMgY29ubmVjdGlvbiBoYXMgZmFpbGVkLlxuICovXG5leHBvcnQgY2xhc3MgV2ViUnRjRmFpbGVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCd3ZWJSdGNGYWlsZWQnKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBpZiBXZWJSdGMgY29ubmVjdGlvbiBpcyBkaXNjb25uZWN0ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJSdGNEaXNjb25uZWN0ZWRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCd3ZWJSdGNEaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIFJUQ0RhdGFDaGFubmVsIGlzIG9wZW5lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFDaGFubmVsT3BlbkV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ2RhdGFDaGFubmVsT3BlbicpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gUlRDRGF0YUNoYW5uZWwgaXMgY2xvc2VkLlxuICovXG5leHBvcnQgY2xhc3MgRGF0YUNoYW5uZWxDbG9zZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ2RhdGFDaGFubmVsQ2xvc2UnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBvbiBSVENEYXRhQ2hhbm5lbCBlcnJvcnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhQ2hhbm5lbEVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignZGF0YUNoYW5uZWxFcnJvcicpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gdGhlIHZpZGVvIHN0cmVhbSBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFZpZGVvSW5pdGlhbGl6ZWRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3ZpZGVvSW5pdGlhbGl6ZWQnKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHZpZGVvIHN0cmVhbSBsb2FkaW5nIHN0YXJ0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbUxvYWRpbmdFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbUxvYWRpbmcnKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHZpZGVvIHN0cmVhbSBsb2FkaW5nIGhhcyBmaW5pc2hlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbVByZUNvbm5lY3RFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbUNvbm5lY3QnKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHZpZGVvIHN0cmVhbSBoYXMgc3RvcHBlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbVByZURpc2Nvbm5lY3RFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbURpc2Nvbm5lY3QnKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHZpZGVvIHN0cmVhbSBpcyByZWNvbm5lY3RpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1SZWNvbm5lY3RFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbVJlY29ubmVjdCcpO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIGlmIHRoZXJlIGFyZSBlcnJvcnMgbG9hZGluZyB0aGUgdmlkZW8gc3RyZWFtLlxuICovXG5leHBvcnQgY2xhc3MgUGxheVN0cmVhbUVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigncGxheVN0cmVhbUVycm9yJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgYmVmb3JlIHRyeWluZyB0byBzdGFydCB2aWRlbyBwbGF5YmFjay5cbiAqL1xuZXhwb3J0IGNsYXNzIFBsYXlTdHJlYW1FdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3BsYXlTdHJlYW0nKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBpZiB0aGUgYnJvd3NlciByZWplY3RzIHZpZGVvIHBsYXliYWNrLiBDYW4gaGFwcGVuIGZvciBleGFtcGxlIGlmXG4gKiB2aWRlbyBhdXRvLXBsYXkgd2l0aG91dCB1c2VyIGludGVyYWN0aW9uIGlzIHJlZnVzZWQgYnkgdGhlIGJyb3dzZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBQbGF5U3RyZWFtUmVqZWN0ZWRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdwbGF5U3RyZWFtUmVqZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHJlY2VpdmluZyBhIGZ1bGwgRnJlZXplRnJhbWUgaW1hZ2UgZnJvbSBVRS5cbiAqL1xuZXhwb3J0IGNsYXNzIExvYWRGcmVlemVGcmFtZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ2xvYWRGcmVlemVGcmFtZScpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gcmVjZWl2aW5nIFVuZnJlZXplRnJhbWUgbWVzc2FnZSBmcm9tIFVFIGFuZCB2aWRlbyBwbGF5YmFjayBpcyBhYm91dCB0byBiZSByZXN1bWVkLlxuICovXG5leHBvcnQgY2xhc3MgSGlkZUZyZWV6ZUZyYW1lRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdoaWRlRnJlZXplRnJhbWUnKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHJlY2VpdmluZyBXZWJSVEMgc3RhdGlzdGljcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXRzUmVjZWl2ZWRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdzdGF0c1JlY2VpdmVkJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBzdHJlYW1lciBsaXN0IGNoYW5nZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1lckxpc3RNZXNzYWdlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignc3RyZWFtZXJMaXN0TWVzc2FnZScpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gYSBzdWJzY3JpYmVkIHRvIHN0cmVhbWVyJ3MgaWQgY2hhbmdlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbWVySURDaGFuZ2VkTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ1N0cmVhbWVySURDaGFuZ2VkTWVzc2FnZScpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gcmVjZWl2aW5nIGxhdGVuY3kgdGVzdCByZXN1bHRzLlxuICovXG5leHBvcnQgY2xhc3MgTGF0ZW5jeVRlc3RSZXN1bHRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdsYXRlbmN5VGVzdFJlc3VsdCcpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIGV2ZXJ5dGltZSBsYXRlbmN5IGlzIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIFdlYlJUQyBzdGF0cyBBUEkuXG4gKi9cbmV4cG9ydCBjbGFzcyBMYXRlbmN5Q2FsY3VsYXRlZEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ2xhdGVuY3lDYWxjdWxhdGVkJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB3ZSByZWNlaXZlIHRoZSBcIm9uU2NyZWVuS2V5Ym9hcmRcIiBjb21tYW5kIGZyb20gVUUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTaG93T25TY3JlZW5LZXlib2FyZEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ3Nob3dPblNjcmVlbktleWJvYXJkJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiByZWNlaXZpbmcgZGF0YSBjaGFubmVsIGxhdGVuY3kgdGVzdCByZXNwb25zZSBmcm9tIHNlcnZlci5cbiAqIFRoaXMgZXZlbnQgaXMgaGFuZGxlZCBieSBEYXRhQ2hhbm5lbExhdGVuY3lUZXN0Q29udHJvbGxlclxuICovXG5leHBvcnQgY2xhc3MgRGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlc3BvbnNlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignZGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlc3BvbnNlJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBkYXRhIGNoYW5uZWwgbGF0ZW5jeSB0ZXN0IHJlc3VsdHMgYXJlIHJlYWR5LlxuICovXG5leHBvcnQgY2xhc3MgRGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlc3VsdEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ2RhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXN1bHQnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU3Vic2NyaWJlRmFpbGVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignc3Vic2NyaWJlRmFpbGVkJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiByZWNlaXZpbmcgaW5pdGlhbCBzZXR0aW5ncyBmcm9tIFVFLlxuICovXG5leHBvcnQgY2xhc3MgSW5pdGlhbFNldHRpbmdzRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignaW5pdGlhbFNldHRpbmdzJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBQaXhlbFN0cmVhbWluZyBzZXR0aW5ncyBjaGFuZ2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXR0aW5nc0NoYW5nZWRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdzZXR0aW5nc0NoYW5nZWQnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEV2ZW50IGVtaXR0ZWQgd2hlbiBhbiBYUiBTZXNzaW9uIHN0YXJ0c1xuICovXG5leHBvcnQgY2xhc3MgWHJTZXNzaW9uU3RhcnRlZEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigneHJTZXNzaW9uU3RhcnRlZCcpO1xuICAgIH1cbn1cbi8qKlxuICogRXZlbnQgZW1pdHRlZCB3aGVuIGFuIFhSIFNlc3Npb24gZW5kc1xuICovXG5leHBvcnQgY2xhc3MgWHJTZXNzaW9uRW5kZWRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3hyU2Vzc2lvbkVuZGVkJyk7XG4gICAgfVxufVxuLyoqXG4gKiBFdmVudCBlbWl0dGVkIHdoZW4gYW4gWFIgRnJhbWUgaXMgY29tcGxldGVcbiAqL1xuZXhwb3J0IGNsYXNzIFhyRnJhbWVFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCd4ckZyYW1lJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiByZWNlaXZpbmcgYSBwbGF5ZXIgY291bnQgZnJvbSB0aGUgc2lnbmFsbGluZyBzZXJ2ZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFBsYXllckNvdW50RXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigncGxheWVyQ291bnQnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHRoZSB3ZWJSVEMgY29ubmVjdGlvbnMgaXMgcmVsYXllZCBvdmVyIFRDUC5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYlJ0Y1RDUFJlbGF5RGV0ZWN0ZWRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3dlYlJ0Y1RDUFJlbGF5RGV0ZWN0ZWQnKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUGl4ZWxTdHJlYW1pbmdFdmVudEVtaXR0ZXIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggYSBuZXcgZXZlbnQuXG4gICAgICogQHBhcmFtIGUgZXZlbnRcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQoZSkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZGlzcGF0Y2hFdmVudChlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYW4gZXZlbnQgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0gdHlwZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZXZlbnQgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0gdHlwZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50RW1pdHRlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBwb3B1bGF0ZSBmaWxlIGluZm9ybWF0aW9uIGZyb20gYnl0ZSBidWZmZXJzLlxuICovXG5leHBvcnQgY2xhc3MgRmlsZVV0aWwge1xuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBhIGZpbGVzIGV4dGVuc2lvbiB3aGVuIHJlY2VpdmVkIG92ZXIgZGF0YSBjaGFubmVsXG4gICAgICogQHBhcmFtIHZpZXcgLSB0aGUgZmlsZSBleHRlbnNpb24gZGF0YVxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRFeHRlbnNpb25Gcm9tQnl0ZXModmlldywgZmlsZSkge1xuICAgICAgICAvLyBSZXNldCBmaWxlIGlmIHdlIGdvdCBhIGZpbGUgbWVzc2FnZSBhbmQgd2UgYXJlIG5vdCBcInJlY2VpdmluZ1wiIGl0IHlldFxuICAgICAgICBpZiAoIWZpbGUucmVjZWl2aW5nKSB7XG4gICAgICAgICAgICBmaWxlLm1pbWV0eXBlID0gJyc7XG4gICAgICAgICAgICBmaWxlLmV4dGVuc2lvbiA9ICcnO1xuICAgICAgICAgICAgZmlsZS5yZWNlaXZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgZmlsZS52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgZmlsZS5jaHVua3MgPSAwO1xuICAgICAgICAgICAgZmlsZS5kYXRhID0gW107XG4gICAgICAgICAgICBmaWxlLnRpbWVzdGFtcFN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnUmVjZWl2ZWQgZmlyc3QgY2h1bmsgb2YgZmlsZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbkFzU3RyaW5nID0gbmV3IFRleHREZWNvZGVyKCd1dGYtMTYnKS5kZWNvZGUodmlldy5zbGljZSgxKSk7XG4gICAgICAgIExvZ2dlci5JbmZvKGV4dGVuc2lvbkFzU3RyaW5nKTtcbiAgICAgICAgZmlsZS5leHRlbnNpb24gPSBleHRlbnNpb25Bc1N0cmluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIGEgZmlsZXMgbWltZSB0eXBlIHdoZW4gcmVjZWl2ZWQgb3ZlciBkYXRhIGNoYW5uZWxcbiAgICAgKiBAcGFyYW0gdmlldyAtIHRoZSBmaWxlIG1pbWUgdHlwZSBkYXRhXG4gICAgICovXG4gICAgc3RhdGljIHNldE1pbWVUeXBlRnJvbUJ5dGVzKHZpZXcsIGZpbGUpIHtcbiAgICAgICAgLy8gUmVzZXQgZmlsZSBpZiB3ZSBnb3QgYSBmaWxlIG1lc3NhZ2UgYW5kIHdlIGFyZSBub3QgXCJyZWNlaXZpbmdcIiBpdCB5ZXRcbiAgICAgICAgaWYgKCFmaWxlLnJlY2VpdmluZykge1xuICAgICAgICAgICAgZmlsZS5taW1ldHlwZSA9ICcnO1xuICAgICAgICAgICAgZmlsZS5leHRlbnNpb24gPSAnJztcbiAgICAgICAgICAgIGZpbGUucmVjZWl2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGZpbGUudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZpbGUuY2h1bmtzID0gMDtcbiAgICAgICAgICAgIGZpbGUuZGF0YSA9IFtdO1xuICAgICAgICAgICAgZmlsZS50aW1lc3RhbXBTdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ1JlY2VpdmVkIGZpcnN0IGNodW5rIG9mIGZpbGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW1lQXNTdHJpbmcgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi0xNicpLmRlY29kZSh2aWV3LnNsaWNlKDEpKTtcbiAgICAgICAgTG9nZ2VyLkluZm8obWltZUFzU3RyaW5nKTtcbiAgICAgICAgZmlsZS5taW1ldHlwZSA9IG1pbWVBc1N0cmluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIGEgZmlsZXMgY29udGVudHMgd2hlbiByZWNlaXZlZCBvdmVyIGRhdGEgY2hhbm5lbFxuICAgICAqIEBwYXJhbSB2aWV3IC0gdGhlIGZpbGUgY29udGVudHMgZGF0YVxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRDb250ZW50c0Zyb21CeXRlcyh2aWV3LCBmaWxlKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgcmVjZWl2ZWQgdGhlIGluaXRpYWwgc2V0dXAgaW5zdHJ1Y3Rpb25zLCByZXR1cm5cbiAgICAgICAgaWYgKCFmaWxlLnJlY2VpdmluZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdHlwZVNpemUgPSAxO1xuICAgICAgICBjb25zdCBpbnRTaXplID0gNDtcbiAgICAgICAgY29uc3QgbWF4TWVzc2FnZVNpemUgPSAxNiAqIDEwMjQ7XG4gICAgICAgIGNvbnN0IGhlYWRlclNpemUgPSB0eXBlU2l6ZSArIGludFNpemU7XG4gICAgICAgIGNvbnN0IG1heFBheWxvYWRTaXplID0gbWF4TWVzc2FnZVNpemUgLSBoZWFkZXJTaXplO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdG90YWwgbnVtYmVyIG9mIGNodW5rcyBmcm9tIHRoZSB0b3RhbCBmaWxlIHNpemVcbiAgICAgICAgZmlsZS5jaHVua3MgPSBNYXRoLmNlaWwobmV3IERhdGFWaWV3KHZpZXcuc2xpY2UodHlwZVNpemUsIGhlYWRlclNpemUpLmJ1ZmZlcikuZ2V0SW50MzIoMCwgdHJ1ZSkgLyBtYXhQYXlsb2FkU2l6ZSk7XG4gICAgICAgIC8vIEdldCB0aGUgZmlsZSBwYXJ0IG9mIHRoZSBwYXlsb2FkXG4gICAgICAgIGNvbnN0IGZpbGVCeXRlcyA9IHZpZXcuc2xpY2UoaGVhZGVyU2l6ZSk7XG4gICAgICAgIC8vIEFwcGVuZCB0byBleGlzdGluZyBkYXRhIHRoYXQgaG9sZHMgdGhlIGZpbGVcbiAgICAgICAgZmlsZS5kYXRhLnB1c2goZmlsZUJ5dGVzKTtcbiAgICAgICAgLy8gVW5jb21tZW50IGZvciBkZWJ1Z1xuICAgICAgICBMb2dnZXIuSW5mbyhgUmVjZWl2ZWQgZmlsZSBjaHVuazogJHtmaWxlLmRhdGEubGVuZ3RofS8ke2ZpbGUuY2h1bmtzfWApO1xuICAgICAgICBpZiAoZmlsZS5kYXRhLmxlbmd0aCA9PT0gZmlsZS5jaHVua3MpIHtcbiAgICAgICAgICAgIGZpbGUucmVjZWl2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBmaWxlLnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdSZWNlaXZlZCBjb21wbGV0ZSBmaWxlJyk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2ZlckR1cmF0aW9uID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBmaWxlLnRpbWVzdGFtcFN0YXJ0O1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmZXJCaXRyYXRlID0gTWF0aC5yb3VuZCgoZmlsZS5jaHVua3MgKiBtYXhNZXNzYWdlU2l6ZSkgLyB0cmFuc2ZlckR1cmF0aW9uKTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKGBBdmVyYWdlIHRyYW5zZmVyIGJpdHJhdGU6ICR7dHJhbnNmZXJCaXRyYXRlfWtiL3Mgb3ZlciAke3RyYW5zZmVyRHVyYXRpb24gLyAxMDAwfSBzZWNvbmRzYCk7XG4gICAgICAgICAgICAvLyBGaWxlIHJlY29uc3RydWN0aW9uXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEV4YW1wbGUgY29kZSB0byByZWNvbnN0cnVjdCB0aGUgZmlsZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoaXMgY29kZSByZWNvbnN0cnVjdHMgdGhlIHJlY2VpdmVkIGRhdGEgaW50byB0aGUgb3JpZ2luYWwgZmlsZSBiYXNlZCBvbiB0aGUgbWltZSB0eXBlIGFuZCBleHRlbnNpb24gcHJvdmlkZWQgYW5kIHRoZW4gZG93bmxvYWRzIHRoZSByZWNvbnN0cnVjdGVkIGZpbGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgcmVjZWl2ZWQgPSBuZXcgQmxvYihmaWxlLmRhdGEsIHsgdHlwZTogZmlsZS5taW1ldHlwZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgICBhLnNldEF0dHJpYnV0ZSgnaHJlZicsIFVSTC5jcmVhdGVPYmplY3RVUkwocmVjZWl2ZWQpKTtcbiAgICAgICAgICAgIGEuc2V0QXR0cmlidXRlKCdkb3dubG9hZCcsIGB0cmFuc2Zlci4ke2ZpbGUuZXh0ZW5zaW9ufWApO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoYSk7XG4gICAgICAgICAgICAvLyBpZiB5b3UgYXJlIHNvIGluY2xpbmVkIHRvIG1ha2UgaXQgYXV0by1kb3dubG9hZCwgZG8gc29tZXRoaW5nIGxpa2U6IGEuY2xpY2soKTtcbiAgICAgICAgICAgIGEucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlsZS5kYXRhLmxlbmd0aCA+IGZpbGUuY2h1bmtzKSB7XG4gICAgICAgICAgICBmaWxlLnJlY2VpdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBSZWNlaXZlZCBiaWdnZXIgZmlsZSB0aGFuIGFkdmVydGlzZWQ6ICR7ZmlsZS5kYXRhLmxlbmd0aH0vJHtmaWxlLmNodW5rc31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSB0ZW1wbGF0ZSBmb3IgYSBkb3dubG9hZGVkIGZpbGVcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVUZW1wbGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWltZXR5cGUgPSAnJztcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSAnJztcbiAgICAgICAgdGhpcy5yZWNlaXZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaHVua3MgPSAwO1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgdGhpcy52YWxpZCA9IGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbGVVdGlsLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIEEgY2FzZSBpbnNlbnNpdGl2ZSwgcGFydGlhbCBpbXBsZW1lbnRhdGlvbiBvZiBVUkxTZWFyY2hQYXJhbXNcbiAqL1xuZXhwb3J0IGNsYXNzIElVUkxTZWFyY2hQYXJhbXMge1xuICAgIGNvbnN0cnVjdG9yKHNlYXJjaCkge1xuICAgICAgICB0aGlzLl91cmxQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhzZWFyY2gpO1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgdXJsUGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLl91cmxQYXJhbXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhcyhuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCkgaW4gdGhpcy5fdXJsUGFyYW1zO1xuICAgIH1cbiAgICBnZXQobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91cmxQYXJhbXNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JVVJMU2VhcmNoUGFyYW1zLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIENvbnZlcnRzIGNvb3JkaW5hdGVzIGZyb20gZWxlbWVudCByZWxhdGl2ZSBjb29yZGluYXRlcyB0byB2YWx1ZXMgbm9ybWFsaXplZCB3aXRoaW4gdGhlIHZhbHVlIHJhbmdlIG9mIGEgc2hvcnQgKGFuZCBiYWNrIGFnYWluKVxuICovXG5leHBvcnQgY2xhc3MgSW5wdXRDb29yZFRyYW5zbGF0b3Ige1xuICAgIC8vIHdlIGRvbnQgdXNlIGEgY29uc3RydWN0b3IgaGVyZSBiZWNhdXNlIHRoZSBvYmplY3QgaXMgY3JlYXRlZCBhbmQgcGFzc2VkIGFyb3VuZCB0byB2YXJpb3VzIGxvY2F0aW9uc1xuICAgIC8vIHBvc3NpYmx5IGJlZm9yZSB0aGlzIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgcmVjb25maWd1cmUocGxheWVyU2l6ZSwgdmlkZW9TaXplKSB7XG4gICAgICAgIGNvbnN0IHBsYXllckFzcGVjdFJhdGlvID0gcGxheWVyU2l6ZS5oZWlnaHQgLyBwbGF5ZXJTaXplLndpZHRoO1xuICAgICAgICBjb25zdCB2aWRlb0FzcGVjdFJhdGlvID0gdmlkZW9TaXplLmhlaWdodCAvIHZpZGVvU2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy5wbGF5ZXJJc0xhcmdlciA9IHBsYXllckFzcGVjdFJhdGlvID4gdmlkZW9Bc3BlY3RSYXRpbztcbiAgICAgICAgdGhpcy5wbGF5ZXJTaXplID0gcGxheWVyU2l6ZTtcbiAgICAgICAgdGhpcy5yYXRpbyA9IHRoaXMucGxheWVySXNMYXJnZXJcbiAgICAgICAgICAgID8gcGxheWVyQXNwZWN0UmF0aW8gLyB2aWRlb0FzcGVjdFJhdGlvXG4gICAgICAgICAgICA6IHZpZGVvQXNwZWN0UmF0aW8gLyBwbGF5ZXJBc3BlY3RSYXRpbztcbiAgICB9XG4gICAgdHJhbnNsYXRlVW5zaWduZWQoeCwgeSkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkWCA9IHRoaXMucGxheWVySXNMYXJnZXJcbiAgICAgICAgICAgID8geCAvIHRoaXMucGxheWVyU2l6ZS53aWR0aFxuICAgICAgICAgICAgOiB0aGlzLnJhdGlvICogKHggLyB0aGlzLnBsYXllclNpemUud2lkdGggLSAwLjUpICsgMC41O1xuICAgICAgICBjb25zdCBub3JtYWxpemVkWSA9IHRoaXMucGxheWVySXNMYXJnZXJcbiAgICAgICAgICAgID8gdGhpcy5yYXRpbyAqICh5IC8gdGhpcy5wbGF5ZXJTaXplLmhlaWdodCAtIDAuNSkgKyAwLjVcbiAgICAgICAgICAgIDogeSAvIHRoaXMucGxheWVyU2l6ZS5oZWlnaHQ7XG4gICAgICAgIGlmIChub3JtYWxpemVkWCA8IDAuMCB8fCBub3JtYWxpemVkWCA+IDEuMCB8fCBub3JtYWxpemVkWSA8IDAuMCB8fCBub3JtYWxpemVkWSA+IDEuMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5SYW5nZTogZmFsc2UsIHg6IDY1NTM1LCB5OiA2NTUzNSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5SYW5nZTogdHJ1ZSwgeDogbm9ybWFsaXplZFggKiA2NTUzNiwgeTogbm9ybWFsaXplZFkgKiA2NTUzNiB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW5zbGF0ZVNpZ25lZCh4LCB5KSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRYID0gdGhpcy5wbGF5ZXJJc0xhcmdlclxuICAgICAgICAgICAgPyB4IC8gKDAuNSAqIHRoaXMucGxheWVyU2l6ZS53aWR0aClcbiAgICAgICAgICAgIDogKHRoaXMucmF0aW8gKiB4KSAvICgwLjUgKiB0aGlzLnBsYXllclNpemUud2lkdGgpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkWSA9IHRoaXMucGxheWVySXNMYXJnZXJcbiAgICAgICAgICAgID8gKHRoaXMucmF0aW8gKiB5KSAvICgwLjUgKiB0aGlzLnBsYXllclNpemUuaGVpZ2h0KVxuICAgICAgICAgICAgOiB5IC8gKDAuNSAqIHRoaXMucGxheWVyU2l6ZS5oZWlnaHQpO1xuICAgICAgICByZXR1cm4geyB4OiBub3JtYWxpemVkWCAqIDMyNzY3LCB5OiBub3JtYWxpemVkWSAqIDMyNzY3IH07XG4gICAgfVxuICAgIHVudHJhbnNsYXRlVW5zaWduZWQoeCwgeSkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkWCA9IHRoaXMucGxheWVySXNMYXJnZXIgPyB4IC8gNjU1MzYgOiAoeCAvIDY1NTM2IC0gMC41KSAvIHRoaXMucmF0aW8gKyAwLjU7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRZID0gdGhpcy5wbGF5ZXJJc0xhcmdlciA/ICh5IC8gNjU1MzYgLSAwLjUpIC8gdGhpcy5yYXRpbyArIDAuNSA6IHkgLyA2NTUzNjtcbiAgICAgICAgcmV0dXJuIHsgeDogbm9ybWFsaXplZFggKiB0aGlzLnBsYXllclNpemUud2lkdGgsIHk6IG5vcm1hbGl6ZWRZICogdGhpcy5wbGF5ZXJTaXplLmhlaWdodCB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlucHV0Q29vcmRUcmFuc2xhdG9yLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5leHBvcnQgY2xhc3MgUlRDVXRpbHMge1xuICAgIHN0YXRpYyBpc1ZpZGVvVHJhbnNjZWl2ZXIodHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuVHJhbnNjZWl2ZXJSZWNlaXZlVmlkZW8odHJhbnNjZWl2ZXIpIHx8IHRoaXMuY2FuVHJhbnNjZWl2ZXJTZW5kVmlkZW8odHJhbnNjZWl2ZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgY2FuVHJhbnNjZWl2ZXJSZWNlaXZlVmlkZW8odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuICghIXRyYW5zY2VpdmVyICYmXG4gICAgICAgICAgICAodHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnIHx8IHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3JlY3Zvbmx5JykgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY2VpdmVyICYmXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjayAmJlxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sua2luZCA9PT0gJ3ZpZGVvJyk7XG4gICAgfVxuICAgIHN0YXRpYyBjYW5UcmFuc2NlaXZlclNlbmRWaWRlbyh0cmFuc2NlaXZlcikge1xuICAgICAgICByZXR1cm4gKCEhdHJhbnNjZWl2ZXIgJiZcbiAgICAgICAgICAgICh0cmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdzZW5kcmVjdicgfHwgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZG9ubHknKSAmJlxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZGVyICYmXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2sgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRlci50cmFjay5raW5kID09PSAndmlkZW8nKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQXVkaW9UcmFuc2NlaXZlcih0cmFuc2NlaXZlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW5UcmFuc2NlaXZlclJlY2VpdmVBdWRpbyh0cmFuc2NlaXZlcikgfHwgdGhpcy5jYW5UcmFuc2NlaXZlclNlbmRBdWRpbyh0cmFuc2NlaXZlcik7XG4gICAgfVxuICAgIHN0YXRpYyBjYW5UcmFuc2NlaXZlclJlY2VpdmVBdWRpbyh0cmFuc2NlaXZlcikge1xuICAgICAgICByZXR1cm4gKCEhdHJhbnNjZWl2ZXIgJiZcbiAgICAgICAgICAgICh0cmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdzZW5kcmVjdicgfHwgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAncmVjdm9ubHknKSAmJlxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIucmVjZWl2ZXIgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrICYmXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAnYXVkaW8nKTtcbiAgICB9XG4gICAgc3RhdGljIGNhblRyYW5zY2VpdmVyU2VuZEF1ZGlvKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiAoISF0cmFuc2NlaXZlciAmJlxuICAgICAgICAgICAgKHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2JyB8fCB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdzZW5kb25seScpICYmXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kZXIgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRlci50cmFjayAmJlxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrLmtpbmQgPT09ICdhdWRpbycpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJUQ1V0aWxzLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG4vKipcbiAqIFZpZGVvIFBsYXllciBDb250cm9sbGVyIGhhbmRsZXMgdGhlIGNyZWF0aW9uIG9mIHRoZSB2aWRlbyBIVE1MIGVsZW1lbnQgYW5kIGFsbCBoYW5kbGVyc1xuICovXG5leHBvcnQgY2xhc3MgU3RyZWFtQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZpZGVvRWxlbWVudFByb3ZpZGVyIFZpZGVvIFBsYXllciBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZpZGVvRWxlbWVudFByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UHJvdmlkZXIgPSB2aWRlb0VsZW1lbnRQcm92aWRlcjtcbiAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdBdWRpbycpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFByb3ZpZGVyLnNldEF1ZGlvRWxlbWVudCh0aGlzLmF1ZGlvRWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hlbiB0aGUgUGVlciBjb25uZWN0aW9uIGhhcyBhIHRyYWNrIGV2ZW50XG4gICAgICogQHBhcmFtIHJ0Y1RyYWNrRXZlbnQgLSBSVEMgVHJhY2sgRXZlbnRcbiAgICAgKi9cbiAgICBoYW5kbGVPblRyYWNrKHJ0Y1RyYWNrRXZlbnQpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ2hhbmRsZU9uVHJhY2sgJyArIEpTT04uc3RyaW5naWZ5KHJ0Y1RyYWNrRXZlbnQuc3RyZWFtcykpO1xuICAgICAgICAvLyBEbyBub3QgYWRkIHRoZSB0cmFjayBpZiB0aGUgSUQgaXMgYHByb2JhdG9yYCBhcyB0aGlzIGlzIHNwZWNpYWwgdHJhY2sgY3JlYXRlZCBieSBtZWRpYXNvdXAgZm9yIGJpdHJhdGUgcHJvYmluZy5cbiAgICAgICAgLy8gUmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL0VwaWNHYW1lc0V4dC9QaXhlbFN0cmVhbWluZ0luZnJhc3RydWN0dXJlL3B1bGwvODYgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgaWYgKHJ0Y1RyYWNrRXZlbnQuc3RyZWFtcy5sZW5ndGggPCAxIHx8IHJ0Y1RyYWNrRXZlbnQuc3RyZWFtc1swXS5pZCA9PSAncHJvYmF0b3InKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50ID0gdGhpcy52aWRlb0VsZW1lbnRQcm92aWRlci5nZXRWaWRlb0VsZW1lbnQoKTtcbiAgICAgICAgaWYgKHJ0Y1RyYWNrRXZlbnQudHJhY2spIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdHb3QgdHJhY2sgLSAnICtcbiAgICAgICAgICAgICAgICBydGNUcmFja0V2ZW50LnRyYWNrLmtpbmQgK1xuICAgICAgICAgICAgICAgICcgaWQ9JyArXG4gICAgICAgICAgICAgICAgcnRjVHJhY2tFdmVudC50cmFjay5pZCArXG4gICAgICAgICAgICAgICAgJyByZWFkeVN0YXRlPScgK1xuICAgICAgICAgICAgICAgIHJ0Y1RyYWNrRXZlbnQudHJhY2sucmVhZHlTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ0Y1RyYWNrRXZlbnQudHJhY2sua2luZCA9PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB0aGlzLkNyZWF0ZUF1ZGlvVHJhY2socnRjVHJhY2tFdmVudC5zdHJlYW1zWzBdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydGNUcmFja0V2ZW50LnRyYWNrLmtpbmQgPT0gJ3ZpZGVvJyAmJlxuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNyY09iamVjdCAhPT0gcnRjVHJhY2tFdmVudC5zdHJlYW1zWzBdKSB7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gcnRjVHJhY2tFdmVudC5zdHJlYW1zWzBdO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ1NldCB2aWRlbyBzb3VyY2UgZnJvbSB2aWRlbyB0cmFjayBvbnRyYWNrLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGF1ZGlvIGRldmljZSB3aGVuIHJlY2VpdmluZyBhbiBSVENUcmFja0V2ZW50IHdpdGggdGhlIGtpbmQgb2YgXCJhdWRpb1wiXG4gICAgICogQHBhcmFtIGF1ZGlvTWVkaWFTdHJlYW0gLSBBdWRpbyBNZWRpYSBzdHJlYW0gdHJhY2tcbiAgICAgKi9cbiAgICBDcmVhdGVBdWRpb1RyYWNrKGF1ZGlvTWVkaWFTdHJlYW0pIHtcbiAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50ID0gdGhpcy52aWRlb0VsZW1lbnRQcm92aWRlci5nZXRWaWRlb0VsZW1lbnQoKTtcbiAgICAgICAgLy8gZG8gbm90aGluZyB0aGUgdmlkZW8gaGFzIHRoZSBzYW1lIG1lZGlhIHN0cmVhbSBhcyB0aGUgYXVkaW8gdHJhY2sgd2UgaGF2ZSBoZXJlICh0aGV5IGFyZSBsaW5rZWQpXG4gICAgICAgIGlmICh2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID09IGF1ZGlvTWVkaWFTdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB2aWRlbyBlbGVtZW50IGhhcyBzb21lIG90aGVyIG1lZGlhIHN0cmVhbSB0aGF0IGlzIG5vdCBhc3NvY2lhdGVkIHdpdGggdGhpcyBhdWRpbyB0cmFja1xuICAgICAgICBlbHNlIGlmICh2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ICYmIHZpZGVvRWxlbWVudC5zcmNPYmplY3QgIT09IGF1ZGlvTWVkaWFTdHJlYW0pIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBhdWRpbyBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudC5zcmNPYmplY3QgPSBhdWRpb01lZGlhU3RyZWFtO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ0NyZWF0ZWQgbmV3IGF1ZGlvIGVsZW1lbnQgdG8gcGxheSBzZXBhcmF0ZSBhdWRpbyBzdHJlYW0uJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdHJlYW1Db250cm9sbGVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBGbGFncyB9IGZyb20gJy4uL0NvbmZpZy9Db25maWcnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuLyoqXG4gKiBUaGUgdmlkZW8gcGxheWVyIGh0bWwgZWxlbWVudFxuICovXG5leHBvcnQgY2xhc3MgVmlkZW9QbGF5ZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2aWRlb0VsZW1lbnRQYXJlbnQgdGhlIGh0bWwgZGl2IHRoZSB0aGUgdmlkZW8gcGxheWVyIHdpbGwgYmUgaW5qZWN0ZWQgaW50b1xuICAgICAqIEBwYXJhbSBjb25maWcgdGhlIGFwcGxpY2F0aW9ucyBjb25maWd1cmF0aW9uLiBXZSdyZSBpbnRlcmVzdGVkIGluIHRoZSBzdGFydFZpZGVvTXV0ZWQgZmxhZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZpZGVvRWxlbWVudFBhcmVudCwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMubGFzdFRpbWVSZXNpemVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LmlkID0gJ3N0cmVhbWluZ1ZpZGVvJztcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQuZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5wbGF5c0lubGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhbGwnO1xuICAgICAgICB2aWRlb0VsZW1lbnRQYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy52aWRlb0VsZW1lbnQpO1xuICAgICAgICB0aGlzLm9uUmVzaXplUGxheWVyQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmVzb2x1dGlvbiBjaGFuZ2VkLCByZXN0eWxpbmcgcGxheWVyLCBkaWQgeW91IGZvcmdldCB0byBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uPycpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uTWF0Y2hWaWV3cG9ydFJlc29sdXRpb25DYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXNvbHV0aW9uIGNoYW5nZWQgYW5kIG1hdGNoIHZpZXdwb3J0IHJlc29sdXRpb24gaXMgdHVybmVkIG9uLCBkaWQgeW91IGZvcmdldCB0byBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uPycpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBzZXQgcGxheSBmb3IgdmlkZW8gKGFuZCBhdWRpbylcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1ZGlvRWxlbWVudCAhPSB1bmRlZmluZWQgJiYgdGhpcy5hdWRpb0VsZW1lbnQucGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnQucGxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudmlkZW9FbGVtZW50LnBhdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnBsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQub25sb2FkZWRtZXRhZGF0YSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25WaWRlb0luaXRpYWxpemVkKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHNldCByZXNpemUgZXZlbnRzIHRvIHRoZSB3aW5kb3dzIGlmIGl0IGlzIHJlc2l6ZWQgb3IgaXRzIG9yaWVudGF0aW9uIGlzIGNoYW5nZWRcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpID0+IHRoaXMucmVzaXplUGxheWVyU3R5bGUoKSwgdHJ1ZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsICgpID0+IHRoaXMub25PcmllbnRhdGlvbkNoYW5nZSgpKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQuc3JjID0gJyc7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnNyY09iamVjdCA9IG51bGw7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBpZiAodGhpcy5hdWRpb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50LnNyYyA9ICcnO1xuICAgICAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnQuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEF1ZGlvRWxlbWVudChhdWRpb0VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnQgPSBhdWRpb0VsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIHZpZGVvIGVsZW1lbnQgd2l0aCBhbnkgYXBwbGljYXRpb24gY29uZmlnIGFuZCBwbGF5cyB0aGUgdmlkZW8gZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgZm9yIGlmIHBsYXlpbmcgdGhlIHZpZGVvIHdhcyBzdWNjZXNzZnVsIG9yIG5vdC5cbiAgICAgKi9cbiAgICBwbGF5KCkge1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5tdXRlZCA9IHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuU3RhcnRWaWRlb011dGVkKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQuYXV0b3BsYXkgPSB0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkF1dG9QbGF5VmlkZW8pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWRlb0VsZW1lbnQucGxheSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2aWRlbyBlbGVtZW50IGlzIHBhdXNlZC5cbiAgICAgKi9cbiAgICBpc1BhdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9FbGVtZW50LnBhdXNlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgLSB3aGV0aGVyIHRoZSB2aWRlbyBlbGVtZW50IGlzIHBsYXlpbmcuXG4gICAgICovXG4gICAgaXNWaWRlb1JlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWRlb0VsZW1lbnQucmVhZHlTdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmlkZW9FbGVtZW50LnJlYWR5U3RhdGUgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2aWRlbyBlbGVtZW50IGhhcyBhIHZhbGlkIHZpZGVvIHNvdXJjZSAoc3JjT2JqZWN0KS5cbiAgICAgKi9cbiAgICBoYXNWaWRlb1NvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9FbGVtZW50LnNyY09iamVjdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmlkZW9FbGVtZW50LnNyY09iamVjdCAhPT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGNvbnRleHQgb2YgdGhlIGh0bWwgdmlkZW8gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIC0gdGhlIGN1cnJlbnQgY29udGV4dCBvZiB0aGUgdmlkZW8gZWxlbWVudFxuICAgICAqL1xuICAgIGdldFZpZGVvRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9FbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgY29udGV4dCBvZiB0aGUgaHRtbCB2aWRlbyBlbGVtZW50cyBwYXJlbnRcbiAgICAgKiBAcmV0dXJucyAtIHRoZSBjdXJyZW50IGNvbnRleHQgb2YgdGhlIHZpZGVvIGVsZW1lbnRzIHBhcmVudFxuICAgICAqL1xuICAgIGdldFZpZGVvUGFyZW50RWxlbWVudCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy52aWRlb0VsZW1lbnQucGFyZW50RWxlbWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIFZpZGVvIEVsZW1lbnRzIHNyYyBvYmplY3QgdHJhY2tzIHRvIGVuYWJsZVxuICAgICAqIEBwYXJhbSBlbmFibGVkIC0gRW5hYmxlIFRyYWNrcyBvbiB0aGUgU3JjIE9iamVjdFxuICAgICAqL1xuICAgIHNldFZpZGVvRW5hYmxlZChlbmFibGVkKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSB0ZW1wb3JhcnkgaGFjayB1bnRpbCB0eXBlIHNjcmlwdHMgdmlkZW8gZWxlbWVudCBpcyB1cGRhdGVkIHRvIHJlZmxlY3QgdGhlIG5lZWQgZm9yIHRyYWNrcyBvbiBhIGh0bWwgdmlkZW8gZWxlbWVudFxuICAgICAgICBjb25zdCB2aWRlb0VsZW1lbnQgPSB0aGlzLnZpZGVvRWxlbWVudDtcbiAgICAgICAgdmlkZW9FbGVtZW50LnNyY09iamVjdFxuICAgICAgICAgICAgLmdldFRyYWNrcygpXG4gICAgICAgICAgICAuZm9yRWFjaCgodHJhY2spID0+ICh0cmFjay5lbmFibGVkID0gZW5hYmxlZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBvdmVycmlkZSBmb3Igd2hlbiB0aGUgdmlkZW8gaGFzIGJlZW4gaW5pdGlhbGl6ZWQgd2l0aCBhIHNyY09iamVjdFxuICAgICAqL1xuICAgIG9uVmlkZW9Jbml0aWFsaXplZCgpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBGdW5jdGlvbmFsaXR5OiBEbyBOb3RoaW5nXG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9uIHRoZSBvcmllbnRhdGlvbiBjaGFuZ2Ugb2YgYSB3aW5kb3cgY2xlYXIgdGhlIHRpbWVvdXRcbiAgICAgKi9cbiAgICBvbk9yaWVudGF0aW9uQ2hhbmdlKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5vcmllbnRhdGlvbkNoYW5nZVRpbWVvdXQpO1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uQ2hhbmdlVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplUGxheWVyU3R5bGUoKTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzaXplcyB0aGUgcGxheWVyIHN0eWxlIGJhc2VkIG9uIHRoZSB3aW5kb3cgaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAqIEByZXR1cm5zIC0gbmlsIGlmIHJlcXVpcmVtZW50cyBhcmUgc2F0aXNmaWVkXG4gICAgICovXG4gICAgcmVzaXplUGxheWVyU3R5bGUoKSB7XG4gICAgICAgIGNvbnN0IHZpZGVvRWxlbWVudFBhcmVudCA9IHRoaXMuZ2V0VmlkZW9QYXJlbnRFbGVtZW50KCk7XG4gICAgICAgIGlmICghdmlkZW9FbGVtZW50UGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVWaWRlb1N0cmVhbVNpemUoKTtcbiAgICAgICAgaWYgKHZpZGVvRWxlbWVudFBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZpeGVkLXNpemUnKSkge1xuICAgICAgICAgICAgdGhpcy5vblJlc2l6ZVBsYXllckNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29udHJvbHMgZm9yIHJlc2l6aW5nIHRoZSBwbGF5ZXJcbiAgICAgICAgdGhpcy5yZXNpemVQbGF5ZXJTdHlsZVRvRmlsbFBhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5vblJlc2l6ZVBsYXllckNhbGxiYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIHBsYXllciBlbGVtZW50IHRvIGZpbGwgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgICovXG4gICAgcmVzaXplUGxheWVyU3R5bGVUb0ZpbGxQYXJlbnRFbGVtZW50KCkge1xuICAgICAgICBjb25zdCB2aWRlb0VsZW1lbnRQYXJlbnQgPSB0aGlzLmdldFZpZGVvUGFyZW50RWxlbWVudCgpO1xuICAgICAgICAvL1ZpZGVvIGlzIG5vdCBpbml0aWFsaXplZCB5ZXQgc28gc2V0IHZpZGVvRWxlbWVudFBhcmVudCB0byBzaXplIG9mIHBhcmVudCBlbGVtZW50XG4gICAgICAgIGNvbnN0IHN0eWxlV2lkdGggPSAnMTAwJSc7XG4gICAgICAgIGNvbnN0IHN0eWxlSGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICBjb25zdCBzdHlsZVRvcCA9IDA7XG4gICAgICAgIGNvbnN0IHN0eWxlTGVmdCA9IDA7XG4gICAgICAgIHZpZGVvRWxlbWVudFBhcmVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3RvcDogJyArXG4gICAgICAgICAgICBzdHlsZVRvcCArXG4gICAgICAgICAgICAncHg7IGxlZnQ6ICcgK1xuICAgICAgICAgICAgc3R5bGVMZWZ0ICtcbiAgICAgICAgICAgICdweDsgd2lkdGg6ICcgK1xuICAgICAgICAgICAgc3R5bGVXaWR0aCArXG4gICAgICAgICAgICAnOyBoZWlnaHQ6ICcgK1xuICAgICAgICAgICAgc3R5bGVIZWlnaHQgK1xuICAgICAgICAgICAgJzsgY3Vyc29yOiBkZWZhdWx0OycpO1xuICAgIH1cbiAgICB1cGRhdGVWaWRlb1N0cmVhbVNpemUoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5NYXRjaFZpZXdwb3J0UmVzb2x1dGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgaWYgKG5vdyAtIHRoaXMubGFzdFRpbWVSZXNpemVkID4gMzAwKSB7XG4gICAgICAgICAgICBjb25zdCB2aWRlb0VsZW1lbnRQYXJlbnQgPSB0aGlzLmdldFZpZGVvUGFyZW50RWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKCF2aWRlb0VsZW1lbnRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uTWF0Y2hWaWV3cG9ydFJlc29sdXRpb25DYWxsYmFjayh2aWRlb0VsZW1lbnRQYXJlbnQuY2xpZW50V2lkdGgsIHZpZGVvRWxlbWVudFBhcmVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5sYXN0VGltZVJlc2l6ZWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdSZXNpemluZyB0b28gb2Z0ZW4gLSBza2lwcGluZycpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dEhhbmRsZSk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVRpbWVvdXRIYW5kbGUgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLnVwZGF0ZVZpZGVvU3RyZWFtU2l6ZSgpLCAxMDApO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmlkZW9QbGF5ZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IFdlYlNvY2tldFRyYW5zcG9ydCwgTG9nZ2VyLCBTaWduYWxsaW5nUHJvdG9jb2wsIE1lc3NhZ2VzLCBNZXNzYWdlSGVscGVycywgS2VlcGFsaXZlTW9uaXRvciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42JztcbmltcG9ydCB7IFN0cmVhbUNvbnRyb2xsZXIgfSBmcm9tICcuLi9WaWRlb1BsYXllci9TdHJlYW1Db250cm9sbGVyJztcbmltcG9ydCB7IEZyZWV6ZUZyYW1lQ29udHJvbGxlciB9IGZyb20gJy4uL0ZyZWV6ZUZyYW1lL0ZyZWV6ZUZyYW1lQ29udHJvbGxlcic7XG5pbXBvcnQgeyBBRktDb250cm9sbGVyIH0gZnJvbSAnLi4vQUZLL0FGS0NvbnRyb2xsZXInO1xuaW1wb3J0IHsgRGF0YUNoYW5uZWxDb250cm9sbGVyIH0gZnJvbSAnLi4vRGF0YUNoYW5uZWwvRGF0YUNoYW5uZWxDb250cm9sbGVyJztcbmltcG9ydCB7IFBlZXJDb25uZWN0aW9uQ29udHJvbGxlciB9IGZyb20gJy4uL1BlZXJDb25uZWN0aW9uQ29udHJvbGxlci9QZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXInO1xuaW1wb3J0IHsgRmxhZ3MsIENvbnRyb2xTY2hlbWVUeXBlLCBUZXh0UGFyYW1ldGVycywgT3B0aW9uUGFyYW1ldGVycywgTnVtZXJpY1BhcmFtZXRlcnMgfSBmcm9tICcuLi9Db25maWcvQ29uZmlnJztcbmltcG9ydCB7IEluaXRpYWxTZXR0aW5ncyB9IGZyb20gJy4uL0RhdGFDaGFubmVsL0luaXRpYWxTZXR0aW5ncyc7XG5pbXBvcnQgeyBMYXRlbmN5VGVzdFJlc3VsdHMgfSBmcm9tICcuLi9EYXRhQ2hhbm5lbC9MYXRlbmN5VGVzdFJlc3VsdHMnO1xuaW1wb3J0IHsgRmlsZVRlbXBsYXRlLCBGaWxlVXRpbCB9IGZyb20gJy4uL1V0aWwvRmlsZVV0aWwnO1xuaW1wb3J0IHsgSW5wdXRDbGFzc2VzRmFjdG9yeSB9IGZyb20gJy4uL0lucHV0cy9JbnB1dENsYXNzZXNGYWN0b3J5JztcbmltcG9ydCB7IFZpZGVvUGxheWVyIH0gZnJvbSAnLi4vVmlkZW9QbGF5ZXIvVmlkZW9QbGF5ZXInO1xuaW1wb3J0IHsgU3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIsIE1lc3NhZ2VEaXJlY3Rpb24gfSBmcm9tICcuLi9VZUluc3RhbmNlTWVzc2FnZS9TdHJlYW1NZXNzYWdlQ29udHJvbGxlcic7XG5pbXBvcnQgeyBSZXNwb25zZUNvbnRyb2xsZXIgfSBmcm9tICcuLi9VZUluc3RhbmNlTWVzc2FnZS9SZXNwb25zZUNvbnRyb2xsZXInO1xuaW1wb3J0IHsgU2VuZE1lc3NhZ2VDb250cm9sbGVyIH0gZnJvbSAnLi4vVWVJbnN0YW5jZU1lc3NhZ2UvU2VuZE1lc3NhZ2VDb250cm9sbGVyJztcbmltcG9ydCB7IFRvU3RyZWFtZXJNZXNzYWdlc0NvbnRyb2xsZXIgfSBmcm9tICcuLi9VZUluc3RhbmNlTWVzc2FnZS9Ub1N0cmVhbWVyTWVzc2FnZXNDb250cm9sbGVyJztcbmltcG9ydCB7IERhdGFDaGFubmVsU2VuZGVyIH0gZnJvbSAnLi4vRGF0YUNoYW5uZWwvRGF0YUNoYW5uZWxTZW5kZXInO1xuaW1wb3J0IHsgSW5wdXRDb29yZFRyYW5zbGF0b3IgfSBmcm9tICcuLi9VdGlsL0lucHV0Q29vcmRUcmFuc2xhdG9yJztcbmltcG9ydCB7IERhdGFDaGFubmVsQ2xvc2VFdmVudCwgRGF0YUNoYW5uZWxFcnJvckV2ZW50LCBEYXRhQ2hhbm5lbE9wZW5FdmVudCwgSGlkZUZyZWV6ZUZyYW1lRXZlbnQsIExvYWRGcmVlemVGcmFtZUV2ZW50LCBQbGF5U3RyZWFtRXJyb3JFdmVudCwgUGxheVN0cmVhbUV2ZW50LCBQbGF5U3RyZWFtUmVqZWN0ZWRFdmVudCwgU2hvd09uU2NyZWVuS2V5Ym9hcmRFdmVudCwgU3RyZWFtZXJMaXN0TWVzc2FnZUV2ZW50LCBTdHJlYW1lcklEQ2hhbmdlZE1lc3NhZ2VFdmVudCB9IGZyb20gJy4uL1V0aWwvRXZlbnRFbWl0dGVyJztcbmltcG9ydCB7IElVUkxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9VdGlsL0lVUkxTZWFyY2hQYXJhbXMnO1xuaW1wb3J0IHsgQnJvd3NlclV0aWxzIH0gZnJvbSAnLi4vVXRpbC9Ccm93c2VyVXRpbHMnO1xuLyoqXG4gKiBFbnRyeSBwb2ludCBmb3IgdGhlIFdlYlJUQyBQbGF5ZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFdlYlJ0Y1BsYXllckNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIHRoZSBmcm9udGVuZCBjb25maWcgb2JqZWN0XG4gICAgICogQHBhcmFtIHBpeGVsU3RyZWFtaW5nIC0gdGhlIFBpeGVsU3RyZWFtaW5nIG9iamVjdFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgcGl4ZWxTdHJlYW1pbmcpIHtcbiAgICAgICAgdGhpcy5zaG91bGRTaG93UGxheU92ZXJsYXkgPSB0cnVlO1xuICAgICAgICB0aGlzLmF1dG9Kb2luVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nID0gcGl4ZWxTdHJlYW1pbmc7XG4gICAgICAgIHRoaXMucmVzcG9uc2VDb250cm9sbGVyID0gbmV3IFJlc3BvbnNlQ29udHJvbGxlcigpO1xuICAgICAgICB0aGlzLmZpbGUgPSBuZXcgRmlsZVRlbXBsYXRlKCk7XG4gICAgICAgIHRoaXMuc2RwQ29uc3RyYWludHMgPSB7XG4gICAgICAgICAgICBvZmZlclRvUmVjZWl2ZUF1ZGlvOiB0cnVlLFxuICAgICAgICAgICAgb2ZmZXJUb1JlY2VpdmVWaWRlbzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICAvLyBzZXQgdXAgdGhlIGFmayBsb2dpYyBjbGFzcyBhbmQgY29ubmVjdCB1cCBpdHMgbWV0aG9kIGZvciBjbG9zaW5nIHRoZSBzaWduYWxpbmcgc2VydmVyXG4gICAgICAgIHRoaXMuYWZrQ29udHJvbGxlciA9IG5ldyBBRktDb250cm9sbGVyKHRoaXMuY29uZmlnLCB0aGlzLnBpeGVsU3RyZWFtaW5nLCB0aGlzLm9uQWZrVHJpZ2dlcmVkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFma0NvbnRyb2xsZXIub25BRktUaW1lZE91dENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVNpZ25hbGluZ1NlcnZlcignWW91IGhhdmUgYmVlbiBkaXNjb25uZWN0ZWQgZHVlIHRvIGluYWN0aXZpdHkuJywgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lQ29udHJvbGxlciA9IG5ldyBGcmVlemVGcmFtZUNvbnRyb2xsZXIodGhpcy5waXhlbFN0cmVhbWluZy52aWRlb0VsZW1lbnRQYXJlbnQpO1xuICAgICAgICB0aGlzLnZpZGVvUGxheWVyID0gbmV3IFZpZGVvUGxheWVyKHRoaXMucGl4ZWxTdHJlYW1pbmcudmlkZW9FbGVtZW50UGFyZW50LCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIHRoaXMudmlkZW9QbGF5ZXIub25WaWRlb0luaXRpYWxpemVkID0gKCkgPT4gdGhpcy5oYW5kbGVWaWRlb0luaXRpYWxpemVkKCk7XG4gICAgICAgIC8vIFdoZW4gaW4gbWF0Y2ggdmlld3BvcnQgcmVzb2x1dGlvbiBtb2RlLCB3aGVuIHRoZSBicm93c2VyIHZpZXdwb3J0IGlzIHJlc2l6ZWQgd2Ugc2VuZCBhIHJlc2l6ZSBjb21tYW5kIGJhY2sgdG8gVUUuXG4gICAgICAgIHRoaXMudmlkZW9QbGF5ZXIub25NYXRjaFZpZXdwb3J0UmVzb2x1dGlvbkNhbGxiYWNrID0gKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICAgICAgJ1Jlc29sdXRpb24uV2lkdGgnOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAnUmVzb2x1dGlvbi5IZWlnaHQnOiBoZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0NvbW1hbmQnKShbSlNPTi5zdHJpbmdpZnkoZGVzY3JpcHRvcildKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRXZlcnkgdGltZSB2aWRlbyBwbGF5ZXIgaXMgcmVzaXplZCBpbiBicm93c2VyIHdlIG5lZWQgdG8gcmVpbml0aWFsaXplIHRoZSBtb3VzZSBjb29yZGluYXRlIGNvbnZlcnNpb24gYW5kIGZyZWV6ZSBmcmFtZSBzaXppbmcgbG9naWMuXG4gICAgICAgIHRoaXMudmlkZW9QbGF5ZXIub25SZXNpemVQbGF5ZXJDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0VXBNb3VzZUFuZEZyZWV6ZUZyYW1lKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IG5ldyBTdHJlYW1Db250cm9sbGVyKHRoaXMudmlkZW9QbGF5ZXIpO1xuICAgICAgICB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIgPSBuZXcgSW5wdXRDb29yZFRyYW5zbGF0b3IoKTtcbiAgICAgICAgdGhpcy5zZW5kcmVjdkRhdGFDaGFubmVsQ29udHJvbGxlciA9IG5ldyBEYXRhQ2hhbm5lbENvbnRyb2xsZXIoKTtcbiAgICAgICAgdGhpcy5yZWN2RGF0YUNoYW5uZWxDb250cm9sbGVyID0gbmV3IERhdGFDaGFubmVsQ29udHJvbGxlcigpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRGF0YUNoYW5uZWxFdmVudEVtaXR0ZXJzKHRoaXMuc2VuZHJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRGF0YUNoYW5uZWxFdmVudEVtaXR0ZXJzKHRoaXMucmVjdkRhdGFDaGFubmVsQ29udHJvbGxlcik7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWxTZW5kZXIgPSBuZXcgRGF0YUNoYW5uZWxTZW5kZXIodGhpcy5zZW5kcmVjdkRhdGFDaGFubmVsQ29udHJvbGxlcik7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWxTZW5kZXIucmVzZXRBZmtXYXJuaW5nVGltZXJPbkRhdGFTZW5kID0gKCkgPT4gdGhpcy5hZmtDb250cm9sbGVyLnJlc2V0QWZrV2FybmluZ1RpbWVyKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIgPSBuZXcgU3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIoKTtcbiAgICAgICAgLy8gc2V0IHVwIHdlYnNvY2tldCBtZXRob2RzXG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3IFdlYlNvY2tldFRyYW5zcG9ydChjb25maWcud2ViU29ja2V0UHJvdG9jb2xzKTtcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IG5ldyBTaWduYWxsaW5nUHJvdG9jb2wodGhpcy50cmFuc3BvcnQpO1xuICAgICAgICB0aGlzLnByb3RvY29sLmFkZExpc3RlbmVyKE1lc3NhZ2VzLmNvbmZpZy50eXBlTmFtZSwgKG1zZykgPT4gdGhpcy5oYW5kbGVPbkNvbmZpZ01lc3NhZ2UobXNnKSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wuYWRkTGlzdGVuZXIoTWVzc2FnZXMucGluZy50eXBlTmFtZSwgKG1zZykgPT4gdGhpcy5oYW5kbGVQaW5nTWVzc2FnZShtc2cpKTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC5hZGRMaXN0ZW5lcihNZXNzYWdlcy5zdHJlYW1lckxpc3QudHlwZU5hbWUsIChtc2cpID0+IHRoaXMuaGFuZGxlU3RyZWFtZXJMaXN0TWVzc2FnZShtc2cpKTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC5hZGRMaXN0ZW5lcihNZXNzYWdlcy5zdWJzY3JpYmVGYWlsZWQudHlwZU5hbWUsIChtc2cpID0+IHRoaXMuaGFuZGxlU3Vic2NyaWJlRmFpbGVkTWVzc2FnZShtc2cpKTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC5hZGRMaXN0ZW5lcihNZXNzYWdlcy5zdHJlYW1lcklkQ2hhbmdlZC50eXBlTmFtZSwgKG1zZykgPT4gdGhpcy5oYW5kbGVTdHJlYW1lcklEQ2hhbmdlZE1lc3NhZ2UobXNnKSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wuYWRkTGlzdGVuZXIoTWVzc2FnZXMucGxheWVyQ291bnQudHlwZU5hbWUsIChtc2cpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBsYXllckNvdW50TWVzc2FnZSA9IG1zZztcbiAgICAgICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuX29uUGxheWVyQ291bnQocGxheWVyQ291bnRNZXNzYWdlLmNvdW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wuYWRkTGlzdGVuZXIoTWVzc2FnZXMuYW5zd2VyLnR5cGVOYW1lLCAobXNnKSA9PiB0aGlzLmhhbmRsZVdlYlJ0Y0Fuc3dlcihtc2cpKTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC5hZGRMaXN0ZW5lcihNZXNzYWdlcy5vZmZlci50eXBlTmFtZSwgKG1zZykgPT4gdGhpcy5oYW5kbGVXZWJSdGNPZmZlcihtc2cpKTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC5hZGRMaXN0ZW5lcihNZXNzYWdlcy5wZWVyRGF0YUNoYW5uZWxzLnR5cGVOYW1lLCAobXNnKSA9PiB0aGlzLmhhbmRsZVdlYlJ0Y1NGVVBlZXJEYXRhY2hhbm5lbHMobXNnKSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wuYWRkTGlzdGVuZXIoTWVzc2FnZXMuaWNlQ2FuZGlkYXRlLnR5cGVOYW1lLCAobXNnKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpY2VDYW5kaWRhdGVNZXNzYWdlID0gbXNnO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVJY2VDYW5kaWRhdGUoaWNlQ2FuZGlkYXRlTWVzc2FnZS5jYW5kaWRhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC50cmFuc3BvcnQuYWRkTGlzdGVuZXIoJ29wZW4nLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBCcm93c2VyU2VuZE9mZmVyID0gdGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5Ccm93c2VyU2VuZE9mZmVyKTtcbiAgICAgICAgICAgIGlmICghQnJvd3NlclNlbmRPZmZlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBNZXNzYWdlSGVscGVycy5jcmVhdGVNZXNzYWdlKE1lc3NhZ2VzLmxpc3RTdHJlYW1lcnMpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdG9jb2wuc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHQgPSAwO1xuICAgICAgICAgICAgdGhpcy5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC50cmFuc3BvcnQuYWRkTGlzdGVuZXIoJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gZG9udCByZWFsbHkgbmVlZCB0byBkbyBhbnl0aGluZyBoZXJlIHNpbmNlIHRoZSBjbG9zZSBldmVudCBzaG91bGQgZm9sbG93LlxuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBHb3QgYSB0cmFuc3BvcnQgZXJyb3IuYCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3RvY29sLnRyYW5zcG9ydC5hZGRMaXN0ZW5lcignY2xvc2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIHdoZW4gd2UgcmVmcmVzaCB0aGUgcGFnZSBkdXJpbmcgYSBzdHJlYW0gd2UgZ2V0IHRoZSBnb2luZyBhd2F5IGNvZGUuXG4gICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgZG9uJ3Qgd2FudCB0byByZWNvbm5lY3Qgc2luY2Ugd2UncmUgbmF2aWdhdGluZyBhd2F5LlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnQvY29kZVxuICAgICAgICAgICAgLy8gbGlzdHMgYWxsIHRoZSBjb2Rlcy5cbiAgICAgICAgICAgIGNvbnN0IENPREVfR09JTkdfQVdBWSA9IDEwMDE7XG4gICAgICAgICAgICBjb25zdCBtYXhSZWNvbm5lY3RBdHRlbXB0cyA9IHRoaXMuY29uZmlnLmdldE51bWVyaWNTZXR0aW5nVmFsdWUoTnVtZXJpY1BhcmFtZXRlcnMuTWF4UmVjb25uZWN0QXR0ZW1wdHMpO1xuICAgICAgICAgICAgY29uc3QgYXR0ZW1wdHNMZWZ0ID0gdGhpcy5yZWNvbm5lY3RBdHRlbXB0IDwgbWF4UmVjb25uZWN0QXR0ZW1wdHM7XG4gICAgICAgICAgICBjb25zdCByZWNvbm5lY3RFbmFibGVkID0gdGhpcy5mb3JjZVJlY29ubmVjdCB8fCAodGhpcy5lbmFibGVBdXRvUmVjb25uZWN0ICYmIG1heFJlY29ubmVjdEF0dGVtcHRzID4gMCAmJiBhdHRlbXB0c0xlZnQpO1xuICAgICAgICAgICAgY29uc3Qgd2lsbFRyeVJlY29ubmVjdCA9IHJlY29ubmVjdEVuYWJsZWQgJiYgZXZlbnQuY29kZSAhPSBDT0RFX0dPSU5HX0FXQVk7XG4gICAgICAgICAgICBjb25zdCBhbGxvd0NsaWNrVG9SZWNvbm5lY3QgPSAhd2lsbFRyeVJlY29ubmVjdDtcbiAgICAgICAgICAgIGNvbnN0IGRpc2Nvbm5lY3RNZXNzYWdlID0gdGhpcy5kaXNjb25uZWN0TWVzc2FnZSA/IHRoaXMuZGlzY29ubmVjdE1lc3NhZ2UgOiBldmVudC5yZWFzb247XG4gICAgICAgICAgICB0aGlzLmZvcmNlUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgbGlzdCBvZiBhbGwgcG9zc2libGUgY29kZWNzIG9uIGRpc2Nvbm5lY3Qgc28gdGhhdCBpZiB0aGUgbmV4dCBjb25uZWN0aW9uIGhhcyBcIk5lZ290aWF0ZUNvZGVjc1wiIG9uXG4gICAgICAgICAgICAvLyB0aGVuIGFsbCBjb2RlY3MgY2FuIGJlIG5lZ290aWF0ZWRcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmdldFNldHRpbmdPcHRpb24oT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRDb2RlYykub3B0aW9ucyA9XG4gICAgICAgICAgICAgICAgQnJvd3NlclV0aWxzLmdldFN1cHBvcnRlZFZpZGVvQ29kZWNzKCk7XG4gICAgICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbkRpc2Nvbm5lY3QoZGlzY29ubmVjdE1lc3NhZ2UsIGFsbG93Q2xpY2tUb1JlY29ubmVjdCk7XG4gICAgICAgICAgICB0aGlzLmFma0NvbnRyb2xsZXIuc3RvcEFma1dhcm5pbmdUaW1lcigpO1xuICAgICAgICAgICAgLy8gc3RvcCBzZW5kaW5nIHN0YXRzIG9uIGludGVydmFsIGlmIHdlIGhhdmUgY2xvc2VkIG91ciBjb25uZWN0aW9uXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0c1RpbWVySGFuZGxlICYmIHRoaXMuc3RhdHNUaW1lckhhbmRsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5zdGF0c1RpbWVySGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBzdHJlYW0gcXVhbGl0eSBpY29uLlxuICAgICAgICAgICAgdGhpcy5zZXRWaWRlb0VuY29kZXJBdmdRUCgwKTtcbiAgICAgICAgICAgIC8vIHVucmVnaXN0ZXIgYWxsIGlucHV0IGRldmljZSBldmVudCBoYW5kbGVycyBvbiBkaXNjb25uZWN0XG4gICAgICAgICAgICB0aGlzLnNldFRvdWNoSW5wdXRFbmFibGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuc2V0TW91c2VJbnB1dEVuYWJsZWQoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5zZXRLZXlib2FyZElucHV0RW5hYmxlZChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnNldEdhbWVQYWRJbnB1dEVuYWJsZWQoZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHdpbGxUcnlSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBuZWVkIGEgc21hbGwgZGVsYXkgaGVyZSB0byBwcmV2ZW50IHJlY29ubmVjdCBzcGFtbWluZ1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHQrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1JlY29ubmVjdChldmVudC5yZWFzb24pO1xuICAgICAgICAgICAgICAgIH0sIDIwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gc2V0IHVwIHRoZSBmaW5hbCB3ZWJSdGMgcGxheWVyIGNvbnRyb2xsZXIgbWV0aG9kcyBmcm9tIHdpdGhpbiBvdXIgYXBwbGljYXRpb24gc28gYSBjb25uZWN0aW9uIGNhbiBiZSBhY3RpdmF0ZWRcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIgPSBuZXcgU2VuZE1lc3NhZ2VDb250cm9sbGVyKHRoaXMuZGF0YUNoYW5uZWxTZW5kZXIsIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlc0NvbnRyb2xsZXIgPSBuZXcgVG9TdHJlYW1lck1lc3NhZ2VzQ29udHJvbGxlcih0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlcik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5wb3B1bGF0ZURlZmF1bHRQcm90b2NvbCgpO1xuICAgICAgICB0aGlzLmlucHV0Q2xhc3Nlc0ZhY3RvcnkgPSBuZXcgSW5wdXRDbGFzc2VzRmFjdG9yeSh0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLCB0aGlzLnZpZGVvUGxheWVyLCB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIpO1xuICAgICAgICB0aGlzLmlzVXNpbmdTRlUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1VzaW5nU1ZDID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNRdWFsaXR5Q29udHJvbGxlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByZWZlcnJlZENvZGVjID0gJyc7XG4gICAgICAgIHRoaXMuZW5hYmxlQXV0b1JlY29ubmVjdCA9IHRydWU7XG4gICAgICAgIHRoaXMuZm9yY2VSZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0ID0gMDtcbiAgICAgICAgdGhpcy5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25PcHRpb25TZXR0aW5nQ2hhbmdlZExpc3RlbmVyKE9wdGlvblBhcmFtZXRlcnMuU3RyZWFtZXJJZCwgKHN0cmVhbWVyaWQpID0+IHtcbiAgICAgICAgICAgIGlmIChzdHJlYW1lcmlkID09PSB1bmRlZmluZWQgfHwgc3RyZWFtZXJpZCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjbG9zZSB0aGUgY3VycmVudCBwZWVyIGNvbm5lY3Rpb24gYW5kIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLnBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5jcmVhdGVQZWVyQ29ubmVjdGlvbih0aGlzLnBlZXJDb25maWcsIHRoaXMucHJlZmVycmVkQ29kZWMpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVkU3RyZWFtID0gc3RyZWFtZXJpZDtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBNZXNzYWdlSGVscGVycy5jcmVhdGVNZXNzYWdlKE1lc3NhZ2VzLnN1YnNjcmliZSwgeyBzdHJlYW1lcklkOiBzdHJlYW1lcmlkIH0pO1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbC5zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPbk9wdGlvblNldHRpbmdDaGFuZ2VkTGlzdGVuZXIoT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRRdWFsaXR5LCAocHJlZmVycmVkUXVhbGl0eSkgPT4ge1xuICAgICAgICAgICAgaWYgKHByZWZlcnJlZFF1YWxpdHkgPT09IHVuZGVmaW5lZCB8fCBwcmVmZXJyZWRRdWFsaXR5ID09PSAnJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtZXNzYWdlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNVc2luZ1NWQykge1xuICAgICAgICAgICAgICAgIC8vIFVzZXIgaXMgdXNpbmcgU1ZDIHNvIHNlbGVjdGVkIHF1YWxpdHkgd2lsbCBiZSBvZiB0aGUgZm9ybSBTeFR5KGgpLiBKdXN0IGV4dHJhY3QgdGhlIHggYW5kIHkgbnVtYmVyc1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlSGVscGVycy5jcmVhdGVNZXNzYWdlKE1lc3NhZ2VzLmxheWVyUHJlZmVyZW5jZSwge1xuICAgICAgICAgICAgICAgICAgICBzcGF0aWFsTGF5ZXI6ICtwcmVmZXJyZWRRdWFsaXR5WzFdIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcG9yYWxMYXllcjogK3ByZWZlcnJlZFF1YWxpdHlbM10gLSAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBVc2VyIGlzIG5vdCB1c2luZyBTVkMgc28gdGhlIHNlbGVjdGVkIHF1YWxpdHkgd2lsbCBiZSBlaXRoZXIgTG93LCBNZWRpdW0gb3IgSGlnaCBzbyB3ZSBleHRyYWN0IHRoZSBhcHByb3ByaWF0ZSBzcGF0aWFsIGxheWVyIGluZGV4XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsUXVhbGl0aWVzID0gdGhpcy5jb25maWcuZ2V0U2V0dGluZ09wdGlvbihPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZFF1YWxpdHkpLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVhbGl0eUluZGV4ID0gYWxsUXVhbGl0aWVzLmluZGV4T2YocHJlZmVycmVkUXVhbGl0eSk7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VIZWxwZXJzLmNyZWF0ZU1lc3NhZ2UoTWVzc2FnZXMubGF5ZXJQcmVmZXJlbmNlLCB7XG4gICAgICAgICAgICAgICAgICAgIHNwYXRpYWxMYXllcjogcXVhbGl0eUluZGV4LFxuICAgICAgICAgICAgICAgICAgICB0ZW1wb3JhbExheWVyOiAwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb3RvY29sLnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRWaWRlb0VuY29kZXJBdmdRUCgtMSk7XG4gICAgICAgIHRoaXMuc2lnbmFsbGluZ1VybEJ1aWxkZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaWduYWxsaW5nU2VydmVyVXJsID0gdGhpcy5jb25maWcuZ2V0VGV4dFNldHRpbmdWYWx1ZShUZXh0UGFyYW1ldGVycy5TaWduYWxsaW5nU2VydmVyVXJsKTtcbiAgICAgICAgICAgIHJldHVybiBzaWduYWxsaW5nU2VydmVyVXJsO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgdmlkZW8gcGxheWVyIGFuZCBtYWtlcyBzdXJlIHJlc291cmNlcyBhcmUgZnJlZWQuIFRoaXMgaGVscHMgdG8gcHJldmVudCB0aGUgaXNzdWUgaW4gY2hyb21lXG4gICAgICogd2hlcmUgaXQgcmVmdXNlcyB0byBtYWtlIG5ldyB2aWRlbyBwbGF5ZXJzLlxuICAgICAqL1xuICAgIGRlc3Ryb3lWaWRlb1BsYXllcigpIHtcbiAgICAgICAgdGhpcy52aWRlb1BsYXllci5kZXN0cm95KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWRcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBNZXNzYWdlIEV2ZW50XG4gICAgICovXG4gICAgaGFuZGxlT25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShldmVudC5kYXRhKTtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ01lc3NhZ2UgaW5jb21pbmc6JyArIG1lc3NhZ2UpO1xuICAgICAgICAvL3RyeSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5mcm9tU3RyZWFtZXJNZXNzYWdlcy5nZXQobWVzc2FnZVswXSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIuZnJvbVN0cmVhbWVySGFuZGxlcnMuZ2V0KG1lc3NhZ2VUeXBlKShldmVudC5kYXRhKTtcbiAgICAgICAgLy99IGNhdGNoIChlKSB7XG4gICAgICAgIC8vTG9nZ2VyLkVycm9yKExvZ2dlci5HZXRTdGFja1RyYWNlKCksIGBDdXN0b20gZGF0YSBjaGFubmVsIG1lc3NhZ2Ugd2l0aCBtZXNzYWdlIHR5cGUgdGhhdCBpcyB1bmtub3duIHRvIHRoZSBQaXhlbCBTdHJlYW1pbmcgcHJvdG9jb2wuIERvZXMgeW91ciBQaXhlbFN0cmVhbWluZ1Byb3RvY29sIG5lZWQgdXBkYXRpbmc/IFRoZSBtZXNzYWdlIHR5cGUgd2FzOiAke21lc3NhZ2VbMF19YCk7XG4gICAgICAgIC8vfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBtZXNzYWdlIGFsbCBoYW5kbGVyc1xuICAgICAqL1xuICAgIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXJzKCkge1xuICAgICAgICAvLyBGcm9tIFN0cmVhbWVyXG4gICAgICAgIC8vIE1lc3NhZ2UgZXZlbnRzIGZyb20gdGhlIHN0cmVhbWVyIGhhdmUgYSBkYXRhIHR5cGUgb2YgQXJyYXlCdWZmZXIgYXMgd2UgZm9yY2UgdGhpcyB0eXBlIGluIHRoZSBEYXRhY2hhbm5lbENvbnRyb2xsZXJcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCAnUXVhbGl0eUNvbnRyb2xPd25lcnNoaXAnLCAoZGF0YSkgPT4gdGhpcy5vblF1YWxpdHlDb250cm9sT3duZXJzaGlwKGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCAnUmVzcG9uc2UnLCAoZGF0YSkgPT4gdGhpcy5yZXNwb25zZUNvbnRyb2xsZXIub25SZXNwb25zZShkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ0NvbW1hbmQnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkNvbW1hbmQoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsICdGcmVlemVGcmFtZScsIChkYXRhKSA9PiB0aGlzLm9uRnJlZXplRnJhbWVNZXNzYWdlKGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCAnVW5mcmVlemVGcmFtZScsICgpID0+IHRoaXMuaW52YWxpZGF0ZUZyZWV6ZUZyYW1lQW5kRW5hYmxlVmlkZW8oKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ1ZpZGVvRW5jb2RlckF2Z1FQJywgKGRhdGEpID0+IHRoaXMuaGFuZGxlVmlkZW9FbmNvZGVyQXZnUVAoZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsICdMYXRlbmN5VGVzdCcsIChkYXRhKSA9PiB0aGlzLmhhbmRsZUxhdGVuY3lUZXN0UmVzdWx0KGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCAnRGF0YUNoYW5uZWxMYXRlbmN5VGVzdCcsIChkYXRhKSA9PiB0aGlzLmhhbmRsZURhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXNwb25zZShkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ0luaXRpYWxTZXR0aW5ncycsIChkYXRhKSA9PiB0aGlzLmhhbmRsZUluaXRpYWxTZXR0aW5ncyhkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ0ZpbGVFeHRlbnNpb24nLCAoZGF0YSkgPT4gdGhpcy5vbkZpbGVFeHRlbnNpb24oZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsICdGaWxlTWltZVR5cGUnLCAoZGF0YSkgPT4gdGhpcy5vbkZpbGVNaW1lVHlwZShkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ0ZpbGVDb250ZW50cycsIChkYXRhKSA9PiB0aGlzLm9uRmlsZUNvbnRlbnRzKGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCAnVGVzdEVjaG8nLCAoKSA9PiB7XG4gICAgICAgICAgICAvKiBEbyBub3RoaW5nICovXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsICdJbnB1dENvbnRyb2xPd25lcnNoaXAnLCAoZGF0YSkgPT4gdGhpcy5vbklucHV0Q29udHJvbE93bmVyc2hpcChkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ0dhbWVwYWRSZXNwb25zZScsIChkYXRhKSA9PiB0aGlzLm9uR2FtZXBhZFJlc3BvbnNlKGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCAnTXVsdGlwbGV4ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAvKiBEbyBub3RoaW5nIGFzIHRoaXMgbWVzc2FnZSB0eXBlIGlzIHVzZWQgb25seSBieSB0aGUgU0ZVICovXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsICdQcm90b2NvbCcsIChkYXRhKSA9PiB0aGlzLm9uUHJvdG9jb2xNZXNzYWdlKGRhdGEpKTtcbiAgICAgICAgLy8gVG8gU3RyZWFtZXJcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ0lGcmFtZVJlcXVlc3QnLCAoKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0lGcmFtZVJlcXVlc3QnKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdSZXF1ZXN0UXVhbGl0eUNvbnRyb2wnLCAoKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1JlcXVlc3RRdWFsaXR5Q29udHJvbCcpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ0Zwc1JlcXVlc3QnLCAoKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0Zwc1JlcXVlc3QnKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdBdmVyYWdlQml0cmF0ZVJlcXVlc3QnLCAoKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0F2ZXJhZ2VCaXRyYXRlUmVxdWVzdCcpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1N0YXJ0U3RyZWFtaW5nJywgKCkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdTdGFydFN0cmVhbWluZycpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1N0b3BTdHJlYW1pbmcnLCAoKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1N0b3BTdHJlYW1pbmcnKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdMYXRlbmN5VGVzdCcsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0xhdGVuY3lUZXN0JywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnUmVxdWVzdEluaXRpYWxTZXR0aW5ncycsICgpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignUmVxdWVzdEluaXRpYWxTZXR0aW5ncycpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1Rlc3RFY2hvJywgKCkgPT4ge1xuICAgICAgICAgICAgLyogRG8gbm90aGluZyAqL1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1VJSW50ZXJhY3Rpb24nLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdVSUludGVyYWN0aW9uJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnQ29tbWFuZCcsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0NvbW1hbmQnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdUZXh0Ym94RW50cnknLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdUZXh0Ym94RW50cnknLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdLZXlEb3duJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignS2V5RG93bicsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ0tleVVwJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignS2V5VXAnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdLZXlQcmVzcycsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0tleVByZXNzJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnTW91c2VFbnRlcicsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ01vdXNlRW50ZXInLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdNb3VzZUxlYXZlJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignTW91c2VMZWF2ZScsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ01vdXNlRG93bicsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ01vdXNlRG93bicsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ01vdXNlVXAnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdNb3VzZVVwJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnTW91c2VNb3ZlJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignTW91c2VNb3ZlJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnTW91c2VXaGVlbCcsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ01vdXNlV2hlZWwnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdNb3VzZURvdWJsZScsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ01vdXNlRG91YmxlJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnVG91Y2hTdGFydCcsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1RvdWNoU3RhcnQnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdUb3VjaEVuZCcsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1RvdWNoRW5kJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnVG91Y2hNb3ZlJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignVG91Y2hNb3ZlJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnR2FtZXBhZENvbm5lY3RlZCcsICgpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignR2FtZXBhZENvbm5lY3RlZCcpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ0dhbWVwYWRCdXR0b25QcmVzc2VkJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignR2FtZXBhZEJ1dHRvblByZXNzZWQnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdHYW1lcGFkQnV0dG9uUmVsZWFzZWQnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdHYW1lcGFkQnV0dG9uUmVsZWFzZWQnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdHYW1lcGFkQW5hbG9nJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignR2FtZXBhZEFuYWxvZycsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ0dhbWVwYWREaXNjb25uZWN0ZWQnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdHYW1lcGFkRGlzY29ubmVjdGVkJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnWFJFeWVWaWV3cycsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1hSRXllVmlld3MnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdYUkhNRFRyYW5zZm9ybScsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1hSSE1EVHJhbnNmb3JtJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnWFJDb250cm9sbGVyVHJhbnNmb3JtJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignWFJDb250cm9sbGVyVHJhbnNmb3JtJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnWFJTeXN0ZW0nLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdYUlN5c3RlbScsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1hSQnV0dG9uVG91Y2hlZCcsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1hSQnV0dG9uVG91Y2hlZCcsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1hSQnV0dG9uVG91Y2hSZWxlYXNlZCcsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1hSQnV0dG9uVG91Y2hSZWxlYXNlZCcsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1hSQnV0dG9uUHJlc3NlZCcsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1hSQnV0dG9uUHJlc3NlZCcsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1hSQnV0dG9uUmVsZWFzZWQnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdYUkJ1dHRvblJlbGVhc2VkJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnWFJBbmFsb2cnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdYUkFuYWxvZycsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ0NoYW5uZWxSZWxheVN0YXR1cycsICgpID0+IHtcbiAgICAgICAgICAgIC8qIERvIG5vdGhpbmcgYXMgdGhpcyBtZXNzYWdlIHR5cGUgaXMgdXNlZCBvbmx5IGJ5IHRoZSBTRlUgKi9cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdNdWx0aXBsZXhlZCcsICgpID0+IHtcbiAgICAgICAgICAgIC8qIERvIG5vdGhpbmcgYXMgdGhpcyBtZXNzYWdlIHR5cGUgaXMgdXNlZCBvbmx5IGJ5IHRoZSBTRlUgKi9cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlIHRoZSBsb2dpYyBhc3NvY2lhdGVkIHdpdGggYSBjb21tYW5kIGZyb20gVUVcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgICAqL1xuICAgIG9uQ29tbWFuZChtZXNzYWdlKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCdEYXRhQ2hhbm5lbFJlY2VpdmVNZXNzYWdlVHlwZS5Db21tYW5kJyk7XG4gICAgICAgIGNvbnN0IGNvbW1hbmRBc1N0cmluZyA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTE2JykuZGVjb2RlKG1lc3NhZ2Uuc2xpY2UoMSkpO1xuICAgICAgICBMb2dnZXIuSW5mbygnRGF0YSBDaGFubmVsIENvbW1hbmQ6ICcgKyBjb21tYW5kQXNTdHJpbmcpO1xuICAgICAgICBjb25zdCBjb21tYW5kID0gSlNPTi5wYXJzZShjb21tYW5kQXNTdHJpbmcpO1xuICAgICAgICAvLyBIYW5kbGUgXCJvblNjcmVlbktleWJvYXJkXCIgZXZlbnRcbiAgICAgICAgaWYgKGNvbW1hbmQuY29tbWFuZCA9PT0gJ29uU2NyZWVuS2V5Ym9hcmQnKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU9uU2NyZWVuS2V5Ym9hcmRDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZU9uU2NyZWVuS2V5Ym9hcmRDb21tYW5kKGNvbW1hbmQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgc2hvd09uU2NyZWVuS2V5Ym9hcmQ6IChfYSA9IGNvbW1hbmQuc2hvd09uU2NyZWVuS2V5Ym9hcmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWUsXG4gICAgICAgICAgICB4OiAoX2IgPSBjb21tYW5kLngpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDAsXG4gICAgICAgICAgICB5OiAoX2MgPSBjb21tYW5kLnkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDAsXG4gICAgICAgICAgICBjb250ZW50czogKF9kID0gY29tbWFuZC5jb250ZW50cykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJydcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBTaG93T25TY3JlZW5LZXlib2FyZEV2ZW50KGRhdGEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhIHByb3RvY29sIG1lc3NhZ2UgcmVjZWl2ZWQgZnJvbSB0aGUgc3RyZWFtZXJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSB0aGUgbWVzc2FnZSBkYXRhIGZyb20gdGhlIHN0cmVhbWVyXG4gICAgICovXG4gICAgb25Qcm90b2NvbE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2xTdHJpbmcgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi0xNicpLmRlY29kZShtZXNzYWdlLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sSlNPTiA9IEpTT04ucGFyc2UocHJvdG9jb2xTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvdG9jb2xKU09OLCAnRGlyZWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoJ01hbGZvcm1lZCBwcm90b2NvbCByZWNlaXZlZC4gRW5zdXJlIHRoZSBwcm90b2NvbCBtZXNzYWdlIGNvbnRhaW5zIGEgZGlyZWN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBwcm90b2NvbEpTT04uRGlyZWN0aW9uO1xuICAgICAgICAgICAgZGVsZXRlIHByb3RvY29sSlNPTi5EaXJlY3Rpb247XG4gICAgICAgICAgICBMb2dnZXIuSW5mbyhgUmVjZWl2ZWQgbmV3ICR7ZGlyZWN0aW9uID09IE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyID8gJ0Zyb21TdHJlYW1lcicgOiAnVG9TdHJlYW1lcid9IHByb3RvY29sLiBVcGRhdGluZyBleGlzdGluZyBwcm90b2NvbC4uLmApO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocHJvdG9jb2xKU09OKS5mb3JFYWNoKChtZXNzYWdlVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwcm90b2NvbEpTT05bbWVzc2FnZVR5cGVdO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgbWVzc2FnZSBjb250YWlucyBhbGwgdGhlIHJlbGV2YW50IHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2lkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoYFRvU3RyZWFtZXItPiR7bWVzc2FnZVR5cGV9IHByb3RvY29sIGRlZmluaXRpb24gd2FzIG1hbGZvcm1lZCBhcyBpdCBkaWRuJ3QgY29udGFpbiBhdCBsZWFzdCBhbiBpZFxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmluaXRpb24gd2FzOiAke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2UsIG51bGwsIDIpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBpbiBhIGZvckVhY2ggaXMgZXF1aXZhbGVudCB0byBhIGNvbnRpbnVlIGluIGEgbm9ybWFsIGZvciBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVUU1LjEgYW5kIFVFNS4yIGRvbid0IHNlbmQgYSBzdHJ1Y3R1cmUgZm9yIHRoZXNlIG1lc3NhZ2UgdHlwZXMsIGJ1dCB0aGV5IGFjdHVhbGx5IGRvIGhhdmUgYSBzdHJ1Y3R1cmUgc28gaWdub3JlIHVwZGF0aW5nIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlVHlwZSA9PT0gJ1VJSW50ZXJhY3Rpb24nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVR5cGUgPT09ICdDb21tYW5kJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VUeXBlID09PSAnTGF0ZW5jeVRlc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldChtZXNzYWdlVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSByZWdpc3RlcmVkIGEgaGFuZGxlciBmb3IgdGhpcyBtZXNzYWdlIHR5cGUgd2UgY2FuIGFkZCBpdCB0byBvdXIgc3VwcG9ydGVkIG1lc3NhZ2VzLiBpZSByZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKC4uLilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQobWVzc2FnZVR5cGUsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBUaGVyZSB3YXMgbm8gcmVnaXN0ZXJlZCBoYW5kbGVyIGZvciBcIiR7bWVzc2FnZVR5cGV9XCIgLSB0cnkgYWRkaW5nIG9uZSB1c2luZyByZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgXCIke21lc3NhZ2VUeXBlfVwiLCBteUhhbmRsZXIpYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIG1lc3NhZ2UgY29udGFpbnMgYWxsIHRoZSByZWxldmFudCBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdpZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBGcm9tU3RyZWFtZXItPiR7bWVzc2FnZVR5cGV9IHByb3RvY29sIGRlZmluaXRpb24gd2FzIG1hbGZvcm1lZCBhcyBpdCBkaWRuJ3QgY29udGFpbiBhdCBsZWFzdCBhbiBpZFxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmluaXRpb24gd2FzOiAke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2UsIG51bGwsIDIpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBpbiBhIGZvckVhY2ggaXMgZXF1aXZhbGVudCB0byBhIGNvbnRpbnVlIGluIGEgbm9ybWFsIGZvciBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIuZnJvbVN0cmVhbWVySGFuZGxlcnMuZ2V0KG1lc3NhZ2VUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIHJlZ2lzdGVyZWQgYSBoYW5kbGVyIGZvciB0aGlzIG1lc3NhZ2UgdHlwZS4gaWUgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlciguLi4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5mcm9tU3RyZWFtZXJNZXNzYWdlcy5zZXQobWVzc2FnZS5pZCwgbWVzc2FnZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBUaGVyZSB3YXMgbm8gcmVnaXN0ZXJlZCBoYW5kbGVyIGZvciBcIiR7bWVzc2FnZX1cIiAtIHRyeSBhZGRpbmcgb25lIHVzaW5nIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsIFwiJHttZXNzYWdlVHlwZX1cIiwgbXlIYW5kbGVyKWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoYFVua25vd24gZGlyZWN0aW9uOiAke2RpcmVjdGlvbn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE9uY2UgdGhlIHByb3RvY29sIGhhcyBiZWVuIHJlY2VpdmVkLCB3ZSBjYW4gc2VuZCBvdXIgY29udHJvbCBtZXNzYWdlc1xuICAgICAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNDb250cm9sbGVyLlNlbmRSZXF1ZXN0SW5pdGlhbFNldHRpbmdzKCk7XG4gICAgICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlc0NvbnRyb2xsZXIuU2VuZFJlcXVlc3RRdWFsaXR5Q29udHJvbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbyhlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGFuIGlucHV0IGNvbnRyb2wgbWVzc2FnZSB3aGVuIGl0IGlzIHJlY2VpdmVkIGZyb20gdGhlIHN0cmVhbWVyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIGlucHV0IGNvbnRyb2wgbWVzc2FnZVxuICAgICAqL1xuICAgIG9uSW5wdXRDb250cm9sT3duZXJzaGlwKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuICAgICAgICBMb2dnZXIuSW5mbygnRGF0YUNoYW5uZWxSZWNlaXZlTWVzc2FnZVR5cGUuSW5wdXRDb250cm9sT3duZXJzaGlwJyk7XG4gICAgICAgIGNvbnN0IGlucHV0Q29udHJvbE93bmVyc2hpcCA9IG5ldyBCb29sZWFuKHZpZXdbMV0pLnZhbHVlT2YoKTtcbiAgICAgICAgTG9nZ2VyLkluZm8oYFJlY2VpdmVkIGlucHV0IGNvbnRyb2xsZXIgbWVzc2FnZSAtIHdpbGwgeW91ciBpbnB1dCBjb250cm9sIHRoZSBzdHJlYW06ICR7aW5wdXRDb250cm9sT3duZXJzaGlwfWApO1xuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbklucHV0Q29udHJvbE93bmVyc2hpcChpbnB1dENvbnRyb2xPd25lcnNoaXApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlXG4gICAgICovXG4gICAgb25HYW1lcGFkUmVzcG9uc2UobWVzc2FnZSkge1xuICAgICAgICBjb25zdCByZXNwb25zZVN0cmluZyA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTE2JykuZGVjb2RlKG1lc3NhZ2Uuc2xpY2UoMSkpO1xuICAgICAgICBjb25zdCByZXNwb25zZUpTT04gPSBKU09OLnBhcnNlKHJlc3BvbnNlU3RyaW5nKTtcbiAgICAgICAgdGhpcy5nYW1lUGFkQ29udHJvbGxlci5vbkdhbWVwYWRSZXNwb25zZVJlY2VpdmVkKHJlc3BvbnNlSlNPTi5jb250cm9sbGVySWQpO1xuICAgIH1cbiAgICBvbkFma1RyaWdnZXJlZCgpIHtcbiAgICAgICAgdGhpcy5hZmtDb250cm9sbGVyLm9uQWZrQ2xpY2soKTtcbiAgICAgICAgLy8gaWYgdGhlIHN0cmVhbSBpcyBwYXVzZWQgcGxheSBpdCwgaWYgd2UgY2FuXG4gICAgICAgIGlmICh0aGlzLnZpZGVvUGxheWVyLmlzUGF1c2VkKCkgJiYgdGhpcy52aWRlb1BsYXllci5oYXNWaWRlb1NvdXJjZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnBsYXlTdHJlYW0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgd2hldGhlciB3ZSBzaG91bGQgdGltZW91dCB3aGVuIGFmay5cbiAgICAgKiBAcGFyYW0gYWZrRW5hYmxlZCBJZiB0cnVlIHdlIHRpbWVvdXQgd2hlbiBpZGxlIGZvciBzb21lIGdpdmVuIGFtb3VudCBvZiB0aW1lLlxuICAgICAqL1xuICAgIHNldEFma0VuYWJsZWQoYWZrRW5hYmxlZCkge1xuICAgICAgICBpZiAoYWZrRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5vbkFma1RyaWdnZXJlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZmtDb250cm9sbGVyLnN0b3BBZmtXYXJuaW5nVGltZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IGEgcmVjb25uZWN0aW9uIHRvIHRoZSBzaWduYWxsaW5nIHNlcnZlci4gTWFudWFsIHRyaWdnZXJcbiAgICAgKi9cbiAgICB0cnlSZWNvbm5lY3QobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmZvcmNlUmVjb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kb1JlY29ubmVjdChtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgYWN0dWFsIHJlY29ubmVjdCB3b3JrLiBVc2VkIGJ5IHRoZSBhdXRvIHJlY29ubmVjdCBmZWF0dXJlIHRvIHNraXAgdGhlIG1hbnVhbCBmbGFnLlxuICAgICAqL1xuICAgIGRvUmVjb25uZWN0KG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gd2ViU29ja2V0Q29udHJvbGxlciByZXR1cm4gaW1tZWRpYXRlbHkgb3IgdGhpcyB3aWxsIG5vdCB3b3JrXG4gICAgICAgIGlmICghdGhpcy5wcm90b2NvbCkge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ1RoaXMgcGxheWVyIGhhcyBubyBwcm90b2NvbCBjb25uZWN0aW9uLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAvLyBpZiB0aGUgY29ubmVjdGlvbiBpcyBvcGVuLCBmaXJzdCBjbG9zZSBpdCBhbmQgZm9yY2UgYSByZWNvbm5lY3QuXG4gICAgICAgIGlmICh0aGlzLnByb3RvY29sLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb3JjZVJlY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdE1lc3NhZ2UgPSBgJHttZXNzYWdlfSBSZWNvbm5lY3RpbmcuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xvc2VTaWduYWxpbmdTZXJ2ZXIobWVzc2FnZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbldlYlJ0Y0F1dG9Db25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RUb1NpZ25hbGxpbmdTZXJ2ZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIGZyZWV6ZSBmcmFtZSBpZiBpdCBpcyByZXF1aXJlZCBvdGhlcndpc2Ugc2hvd3MgdGhlIHBsYXkgb3ZlcmxheVxuICAgICAqL1xuICAgIGxvYWRGcmVlemVGcmFtZU9yU2hvd1BsYXlPdmVybGF5KCkge1xuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLmRpc3BhdGNoRXZlbnQobmV3IExvYWRGcmVlemVGcmFtZUV2ZW50KHtcbiAgICAgICAgICAgIHNob3VsZFNob3dQbGF5T3ZlcmxheTogdGhpcy5zaG91bGRTaG93UGxheU92ZXJsYXksXG4gICAgICAgICAgICBpc1ZhbGlkOiB0aGlzLmZyZWV6ZUZyYW1lQ29udHJvbGxlci52YWxpZCxcbiAgICAgICAgICAgIGpwZWdEYXRhOiB0aGlzLmZyZWV6ZUZyYW1lQ29udHJvbGxlci5qcGVnXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkU2hvd1BsYXlPdmVybGF5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnc2hvd2luZyBwbGF5IG92ZXJsYXknKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplUGxheWVyU3R5bGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdzaG93aW5nIGZyZWV6ZSBmcmFtZScpO1xuICAgICAgICAgICAgdGhpcy5mcmVlemVGcmFtZUNvbnRyb2xsZXIuc2hvd0ZyZWV6ZUZyYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvUGxheWVyLnNldFZpZGVvRW5hYmxlZChmYWxzZSk7XG4gICAgICAgIH0sIHRoaXMuZnJlZXplRnJhbWVDb250cm9sbGVyLmZyZWV6ZUZyYW1lRGVsYXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBmcmVlemUgZnJhbWUgYW5kIGxvYWQgaXRcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgZnJlZXplIGZyYW1lIGRhdGEgaW4gYnl0ZXNcbiAgICAgKi9cbiAgICBvbkZyZWV6ZUZyYW1lTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCdEYXRhQ2hhbm5lbFJlY2VpdmVNZXNzYWdlVHlwZS5GcmVlemVGcmFtZScpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuZnJlZXplRnJhbWVDb250cm9sbGVyLnByb2Nlc3NGcmVlemVGcmFtZU1lc3NhZ2UodmlldywgKCkgPT4gdGhpcy5sb2FkRnJlZXplRnJhbWVPclNob3dQbGF5T3ZlcmxheSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRoZSB2aWRlbyBhZnRlciBoaWRpbmcgYSBmcmVlemUgZnJhbWVcbiAgICAgKi9cbiAgICBpbnZhbGlkYXRlRnJlZXplRnJhbWVBbmRFbmFibGVWaWRlbygpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ0RhdGFDaGFubmVsUmVjZWl2ZU1lc3NhZ2VUeXBlLkZyZWV6ZUZyYW1lJyk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBIaWRlRnJlZXplRnJhbWVFdmVudCgpKTtcbiAgICAgICAgICAgIHRoaXMuZnJlZXplRnJhbWVDb250cm9sbGVyLmhpZGVGcmVlemVGcmFtZSgpO1xuICAgICAgICB9LCB0aGlzLmZyZWV6ZUZyYW1lQ29udHJvbGxlci5mcmVlemVGcmFtZURlbGF5KTtcbiAgICAgICAgaWYgKHRoaXMudmlkZW9QbGF5ZXIuZ2V0VmlkZW9FbGVtZW50KCkpIHtcbiAgICAgICAgICAgIHRoaXMudmlkZW9QbGF5ZXIuc2V0VmlkZW9FbmFibGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXAgZGF0YWNoYW5uZWwgZGF0YSBmb3IgcHJvY2Vzc2luZyBmaWxlIGV4dGVuc2lvblxuICAgICAqIEBwYXJhbSBkYXRhIHRoZSBmaWxlIGV4dGVuc2lvbiBkYXRhXG4gICAgICovXG4gICAgb25GaWxlRXh0ZW5zaW9uKGRhdGEpIHtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICBGaWxlVXRpbC5zZXRFeHRlbnNpb25Gcm9tQnl0ZXModmlldywgdGhpcy5maWxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcCBkYXRhY2hhbm5lbCBkYXRhIGZvciBwcm9jZXNzaW5nIHRoZSBmaWxlIG1pbWUgdHlwZVxuICAgICAqIEBwYXJhbSBkYXRhIHRoZSBmaWxlIG1pbWUgdHlwZSBkYXRhXG4gICAgICovXG4gICAgb25GaWxlTWltZVR5cGUoZGF0YSkge1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgIEZpbGVVdGlsLnNldE1pbWVUeXBlRnJvbUJ5dGVzKHZpZXcsIHRoaXMuZmlsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXAgZGF0YWNoYW5uZWwgZGF0YSBmb3IgcHJvY2Vzc2luZyB0aGUgZmlsZSBjb250ZW50c1xuICAgICAqIEBwYXJhbSBkYXRhIHRoZSBmaWxlIGNvbnRlbnRzIGRhdGFcbiAgICAgKi9cbiAgICBvbkZpbGVDb250ZW50cyhkYXRhKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgRmlsZVV0aWwuc2V0Q29udGVudHNGcm9tQnl0ZXModmlldywgdGhpcy5maWxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGxheXMgdGhlIHN0cmVhbSBhdWRpbyBhbmQgdmlkZW8gc291cmNlIGFuZCBzZXRzIHVwIG90aGVyIHBpZWNlcyB3aGlsZSB0aGUgc3RyZWFtIHN0YXJ0c1xuICAgICAqL1xuICAgIHBsYXlTdHJlYW0oKSB7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5nZXRWaWRlb0VsZW1lbnQoKSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdDb3VsZCBub3QgcGxheSB2aWRlbyBzdHJlYW0gYmVjYXVzZSB0aGUgdmlkZW8gcGxheWVyIHdhcyBub3QgaW5pdGlhbGl6ZWQgY29ycmVjdGx5Lic7XG4gICAgICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLmRpc3BhdGNoRXZlbnQobmV3IFBsYXlTdHJlYW1FcnJvckV2ZW50KHsgbWVzc2FnZSB9KSk7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAvLyBjbG9zZSB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgdGhpcy5jbG9zZVNpZ25hbGluZ1NlcnZlcignU3RyZWFtIG5vdCBpbml0aWFsaXplZCBjb3JyZWN0bHknLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmhhc1ZpZGVvU291cmNlKCkpIHtcbiAgICAgICAgICAgIExvZ2dlci5XYXJuaW5nKCdDYW5ub3QgcGxheSBzdHJlYW0sIHRoZSB2aWRlbyBlbGVtZW50IGhhcyBubyBzcmNPYmplY3QgdG8gcGxheS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFRvdWNoSW5wdXRFbmFibGVkKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuVG91Y2hJbnB1dCkpO1xuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLmRpc3BhdGNoRXZlbnQobmV3IFBsYXlTdHJlYW1FdmVudCgpKTtcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtQ29udHJvbGxlci5hdWRpb0VsZW1lbnQuc3JjT2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydE11dGVkID0gdGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5TdGFydFZpZGVvTXV0ZWQpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLmF1ZGlvRWxlbWVudC5tdXRlZCA9IHN0YXJ0TXV0ZWQ7XG4gICAgICAgICAgICBpZiAoc3RhcnRNdXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGxheVZpZGVvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuYXVkaW9FbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIC5wbGF5KClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXlWaWRlbygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgob25SZWplY3RlZFJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuSW5mbyhvblJlamVjdGVkUmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ0Jyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhdXRvcGxheWluZyB2aWRlbyB3aXRob3V0IGludGVyYWN0aW9uIC0gdG8gcmVzb2x2ZSB0aGlzIHdlIGFyZSBnb2luZyB0byBzaG93IHRoZSBwbGF5IGJ1dHRvbiBvdmVybGF5LicpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLmRpc3BhdGNoRXZlbnQobmV3IFBsYXlTdHJlYW1SZWplY3RlZEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogb25SZWplY3RlZFJlYXNvblxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBsYXlWaWRlbygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hvdWxkU2hvd1BsYXlPdmVybGF5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZnJlZXplRnJhbWVDb250cm9sbGVyLnNob3dGcmVlemVGcmFtZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGF5cyB0aGUgdmlkZW8gc3RyZWFtXG4gICAgICovXG4gICAgcGxheVZpZGVvKCkge1xuICAgICAgICAvLyBoYW5kbGUgcGxheSgpIHdpdGggcHJvbWlzZSBhcyBpdCBpcyBhbiBhc3luY2hyb25vdXMgY2FsbFxuICAgICAgICB0aGlzLnZpZGVvUGxheWVyLnBsYXkoKS5jYXRjaCgob25SZWplY3RlZFJlYXNvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtQ29udHJvbGxlci5hdWRpb0VsZW1lbnQuc3JjT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLmF1ZGlvRWxlbWVudC5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTG9nZ2VyLkluZm8ob25SZWplY3RlZFJlYXNvbik7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGF1dG9wbGF5aW5nIHZpZGVvIHdpdGhvdXQgaW50ZXJhY3Rpb24gLSB0byByZXNvbHZlIHRoaXMgd2UgYXJlIGdvaW5nIHRvIHNob3cgdGhlIHBsYXkgYnV0dG9uIG92ZXJsYXkuJyk7XG4gICAgICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLmRpc3BhdGNoRXZlbnQobmV3IFBsYXlTdHJlYW1SZWplY3RlZEV2ZW50KHsgcmVhc29uOiBvblJlamVjdGVkUmVhc29uIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0aGUgdmlkZW8gdG8gcGxheSBhdXRvbWF0aWNhbGx5IGlmIGVuYWJsZUF1dG9wbGF5IGlzIHRydWVcbiAgICAgKi9cbiAgICBhdXRvUGxheVZpZGVvT3JTZXRVcFBsYXlPdmVybGF5KCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5BdXRvUGxheVZpZGVvKSkge1xuICAgICAgICAgICAgLy8gYXR0ZW1wdCB0byBwbGF5IHRoZSB2aWRlb1xuICAgICAgICAgICAgdGhpcy5wbGF5U3RyZWFtKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNpemVQbGF5ZXJTdHlsZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRvIHRoZSBTaWduYWxpbmcgc2VydmVyXG4gICAgICovXG4gICAgY29ubmVjdFRvU2lnbmFsbGluZ1NlcnZlcigpIHtcbiAgICAgICAgdGhpcy5sb2NhbGx5Q2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5hYmxlQXV0b1JlY29ubmVjdCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdE1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBjb25zdCBzaWduYWxsaW5nVXJsID0gdGhpcy5zaWduYWxsaW5nVXJsQnVpbGRlcigpO1xuICAgICAgICB0aGlzLnByb3RvY29sLmNvbm5lY3Qoc2lnbmFsbGluZ1VybCk7XG4gICAgICAgIGNvbnN0IGtlZXBhbGl2ZURlbGF5ID0gdGhpcy5jb25maWcuZ2V0TnVtZXJpY1NldHRpbmdWYWx1ZShOdW1lcmljUGFyYW1ldGVycy5LZWVwYWxpdmVEZWxheSk7XG4gICAgICAgIGlmIChrZWVwYWxpdmVEZWxheSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlID0gbmV3IEtlZXBhbGl2ZU1vbml0b3IodGhpcy5wcm90b2NvbCwga2VlcGFsaXZlRGVsYXkpO1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmUub25UaW1lb3V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwaW5nIGZhaWxzIGp1c3QgZGlzY29ubmVjdFxuICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihgUHJvdG9jb2wgdGltZW91dGApO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdG9jb2wuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIHdpbGwgc3RhcnQgdGhlIGhhbmRzaGFrZSB0byB0aGUgc2lnbmFsbGluZyBzZXJ2ZXJcbiAgICAgKiBAcGFyYW0gcGVlckNvbmZpZyAgLSBSVEMgQ29uZmlndXJhdGlvbiBPcHRpb25zIGZyb20gdGhlIFNpZ25hbGluZyBzZXJ2ZXJcbiAgICAgKiBAcmVtYXJrIFJUQyBQZWVyIENvbm5lY3Rpb24gb24gSWNlIENhbmRpZGF0ZSBldmVudCBoYXZlIGl0IGhhbmRsZWQgYnkgaGFuZGxlIFNlbmQgSWNlIENhbmRpZGF0ZVxuICAgICAqL1xuICAgIHN0YXJ0U2Vzc2lvbihwZWVyQ29uZmlnKSB7XG4gICAgICAgIHRoaXMucGVlckNvbmZpZyA9IHBlZXJDb25maWc7XG4gICAgICAgIC8vIGNoZWNrIGZvciBmb3JjaW5nIHR1cm5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuRm9yY2VUVVJOKSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGEgdHVybiBzZXJ2ZXJcbiAgICAgICAgICAgIGNvbnN0IGhhc1R1cm5TZXJ2ZXIgPSB0aGlzLmNoZWNrVHVyblNlcnZlckF2YWlsYWJpbGl0eShwZWVyQ29uZmlnKTtcbiAgICAgICAgICAgIC8vIGNsb3NlIGFuZCBlcnJvciBpZiB0dXJuIGlzIGZvcmNlZCBhbmQgdGhlcmUgaXMgbm8gdHVybiBzZXJ2ZXJcbiAgICAgICAgICAgIGlmICghaGFzVHVyblNlcnZlcikge1xuICAgICAgICAgICAgICAgIExvZ2dlci5JbmZvKCdObyB0dXJuIHNlcnZlciB3YXMgZm91bmQgaW4gdGhlIFBlZXIgQ29ubmVjdGlvbiBPcHRpb25zLiBUVVJOIGNhbm5vdCBiZSBmb3JjZWQsIGNsb3NpbmcgY29ubmVjdGlvbi4gUGxlYXNlIHVzZSBTVFVOIGluc3RlYWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlU2lnbmFsaW5nU2VydmVyKCdUVVJOIGNhbm5vdCBiZSBmb3JjZWQsIGNsb3NpbmcgY29ubmVjdGlvbi4gUGxlYXNlIHVzZSBTVFVOIGluc3RlYWQuJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgdXAgdGhlIHBlZXIgY29ubmVjdGlvbiBjb250cm9sbGVyXG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyID0gbmV3IFBlZXJDb25uZWN0aW9uQ29udHJvbGxlcih0aGlzLnBlZXJDb25maWcsIHRoaXMuY29uZmlnLCB0aGlzLnByZWZlcnJlZENvZGVjKTtcbiAgICAgICAgLy8gc2V0IHVwIHBlZXIgY29ubmVjdGlvbiBjb250cm9sbGVyIHZpZGVvIHN0YXRzXG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLm9uVmlkZW9TdGF0cyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVWaWRlb1N0YXRzKGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyogU2V0IGV2ZW50IGhhbmRsZXIgZm9yIGxhdGVuY3kgaW5mb3JtYXRpb24gaXMgY2FsY3VsYXRlZCwgaGFuZGxlIHRoZSBldmVudCBieSBwcm9wb2dhdGluZyB0byB0aGUgUGl4ZWxTdHJlYW1pbmcgQVBJICovXG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLm9uTGF0ZW5jeUNhbGN1bGF0ZWQgPSAobGF0ZW5jeUluZm8pID0+IHtcbiAgICAgICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuX29uTGF0ZW5jeUNhbGN1bGF0ZWQobGF0ZW5jeUluZm8pO1xuICAgICAgICB9O1xuICAgICAgICAvKiBXaGVuIG91ciBQZWVyQ29ubmVjdGlvbiB3YW50cyB0byBzZW5kIGFuIG9mZmVyIGNhbGwgb3VyIGhhbmRsZXIgKi9cbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIub25TZW5kV2ViUlRDT2ZmZXIgPSAob2ZmZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2VuZFdlYlJUQ09mZmVyKG9mZmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyogU2V0IGV2ZW50IGhhbmRsZXIgZm9yIHdoZW4gbG9jYWwgZGVzY3JpcHRpb24gaXMgc2V0ICovXG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLm9uU2V0TG9jYWxEZXNjcmlwdGlvbiA9IChzZHApID0+IHtcbiAgICAgICAgICAgIGlmIChzZHAudHlwZSA9PT0gJ29mZmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU2VuZFdlYlJUQ09mZmVyKHNkcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZHAudHlwZSA9PT0gJ2Fuc3dlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNlbmRXZWJSVENBbnN3ZXIoc2RwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihgUGVlckNvbm5lY3Rpb25Db250cm9sbGVyIG9uU2V0TG9jYWxEZXNjcmlwdGlvbiB3YXMgY2FsbGVkIHdpdGggdW5leHBlY3RlZCB0eXBlICR7c2RwLnR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qIEV2ZW50IGhhbmRsZXIgZm9yIHdoZW4gUGVlckNvbm5lY3Rpb24ncyByZW1vdGUgZGVzY3JpcHRpb24gaXMgc2V0ICovXG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLm9uU2V0UmVtb3RlRGVzY3JpcHRpb24gPSAoc2RwKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2RwLnR5cGUgPT09ICdvZmZlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbldlYlJ0Y1NkcE9mZmVyKHNkcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZHAudHlwZSA9PT0gJ2Fuc3dlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbldlYlJ0Y1NkcEFuc3dlcihzZHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBQZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIgb25TZXRSZW1vdGVEZXNjcmlwdGlvbiB3YXMgY2FsbGVkIHdpdGggdW5leHBlY3RlZCB0eXBlICR7c2RwLnR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qIFdoZW4gdGhlIFBlZXIgQ29ubmVjdGlvbiBpY2UgY2FuZGlkYXRlIGlzIGFkZGVkIGhhdmUgaXQgaGFuZGxlZCAqL1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5vblBlZXJJY2VDYW5kaWRhdGUgPSAocGVlckNvbm5lY3Rpb25JY2VFdmVudCkgPT4gdGhpcy5oYW5kbGVTZW5kSWNlQ2FuZGlkYXRlKHBlZXJDb25uZWN0aW9uSWNlRXZlbnQpO1xuICAgICAgICAvKiBXaGVuIHRoZSBQZWVyIENvbm5lY3Rpb24gaGFzIGEgZGF0YSBjaGFubmVsIGNyZWF0ZWQgZm9yIGl0IGJ5IHRoZSBicm93c2VyLCBoYW5kbGUgaXQgKi9cbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIub25EYXRhQ2hhbm5lbCA9IChkYXRhY2hhbm5lbEV2ZW50KSA9PiB0aGlzLmhhbmRsZURhdGFDaGFubmVsKGRhdGFjaGFubmVsRXZlbnQpO1xuICAgICAgICAvLyBzZXQgdXAgd2ViUnRjIHRleHQgb3ZlcmxheXNcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIuc2hvd1RleHRPdmVybGF5Q29ubmVjdGluZyA9ICgpID0+IHRoaXMucGl4ZWxTdHJlYW1pbmcuX29uV2ViUnRjQ29ubmVjdGluZygpO1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5zaG93VGV4dE92ZXJsYXlTZXR1cEZhaWx1cmUgPSAoKSA9PiB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbldlYlJ0Y0ZhaWxlZCgpO1xuICAgICAgICBsZXQgd2ViUnRjQ29ubmVjdGVkU2VudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIEJyb3dzZXJzIGVtaXQgXCJjb25uZWN0ZWRcIiB3aGVuIGdldHRpbmcgZmlyc3QgY29ubmVjdGlvbiBhbmQgXCJjb21wbGV0ZWRcIiB3aGVuIGZpbmlzaGluZ1xuICAgICAgICAgICAgLy8gY2FuZGlkYXRlIGNoZWNraW5nLiBIb3dldmVyLCBzb21ldGltZXMgYnJvd3NlcnMgY2FuIHNraXAgXCJjb25uZWN0ZWRcIiBhbmQgb25seSBlbWl0IFwiY29tcGxldGVkXCIuXG4gICAgICAgICAgICAvLyBUaGVyZWZvcmUgbmVlZCB0byBjaGVjayBib3RoIGNhc2VzIGFuZCBlbWl0IG9uV2ViUnRjQ29ubmVjdGVkIG9ubHkgb25jZSBvbiB0aGUgZmlyc3QgaGl0LlxuICAgICAgICAgICAgaWYgKCF3ZWJSdGNDb25uZWN0ZWRTZW50ICYmXG4gICAgICAgICAgICAgICAgWydjb25uZWN0ZWQnLCAnY29tcGxldGVkJ10uaW5jbHVkZXModGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIucGVlckNvbm5lY3Rpb24uaWNlQ29ubmVjdGlvblN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuX29uV2ViUnRjQ29ubmVjdGVkKCk7XG4gICAgICAgICAgICAgICAgd2ViUnRjQ29ubmVjdGVkU2VudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qIFJUQyBQZWVyIENvbm5lY3Rpb24gb24gVHJhY2sgZXZlbnQgLT4gaGFuZGxlIG9uIHRyYWNrICovXG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLm9uVHJhY2sgPSAodHJhY2tFdmVudCkgPT4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmhhbmRsZU9uVHJhY2sodHJhY2tFdmVudCk7XG4gICAgICAgIGNvbnN0IEJyb3dzZXJTZW5kT2ZmZXIgPSB0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkJyb3dzZXJTZW5kT2ZmZXIpO1xuICAgICAgICBpZiAoQnJvd3NlclNlbmRPZmZlcikge1xuICAgICAgICAgICAgLy8gSWYgYnJvd3NlciBpcyBzZW5kaW5nIHRoZSBvZmZlciwgY3JlYXRlIGFuIG9mZmVyIGFuZCBzZW5kIGl0IHRvIHRoZSBzdHJlYW1lclxuICAgICAgICAgICAgdGhpcy5zZW5kcmVjdkRhdGFDaGFubmVsQ29udHJvbGxlci5jcmVhdGVEYXRhQ2hhbm5lbCh0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5wZWVyQ29ubmVjdGlvbiwgJ2NpcnJ1cycsIHRoaXMuZGF0YWNoYW5uZWxPcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZHJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIuaGFuZGxlT25NZXNzYWdlID0gKGV2KSA9PiB0aGlzLmhhbmRsZU9uTWVzc2FnZShldik7XG4gICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5jcmVhdGVPZmZlcih0aGlzLnNkcENvbnN0cmFpbnRzLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBwZWVyIGNvbm5lY3Rpb24gb3B0aW9ucyBmb3IgYSB0dXJuIHNlcnZlciBhbmQgcmV0dXJucyB0cnVlIG9yIGZhbHNlXG4gICAgICovXG4gICAgY2hlY2tUdXJuU2VydmVyQXZhaWxhYmlsaXR5KG9wdGlvbnMpIHtcbiAgICAgICAgLy8gaWYgaWNlU2VydmVycyBpcyBlbXB0eSByZXR1cm4gZmFsc2UgdGhpcyBzaG91bGQgbm90IGJlIHRoZSBnZW5lcmFsIHVzZSBjYXNlIGJ1dCBpcyBoZXJlIGluY2FzZVxuICAgICAgICBpZiAoIW9wdGlvbnMuaWNlU2VydmVycykge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ0EgdHVybiBzZXZlciB3YXMgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHRoZSBpY2Ugc2VydmVycyB0byBjaGVjayBmb3IgYSB0dXJuIHVybFxuICAgICAgICBmb3IgKGNvbnN0IGljZVNlcnZlciBvZiBvcHRpb25zLmljZVNlcnZlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdXJsIG9mIGljZVNlcnZlci51cmxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVybC5pbmNsdWRlcygndHVybicpKSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5JbmZvKGBBIHR1cm4gc2V2ZXIgd2FzIGZvdW5kIGF0ICR7dXJsfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTG9nZ2VyLkluZm8oJ0EgdHVybiBzZXZlciB3YXMgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIGEgQ29uZmlnIE1lc3NhZ2UgaXMgcmVjZWl2ZWQgY29udGFpbnMgdGhlIFBlZXIgQ29ubmVjdGlvbiBPcHRpb25zIHJlcXVpcmVkIChTVFVOIGFuZCBUVVJOIFNlcnZlciBJbmZvKVxuICAgICAqIEBwYXJhbSBtZXNzYWdlQ29uZmlnIC0gQ29uZmlnIE1lc3NhZ2UgcmVjZWl2ZWQgZnJvbSB0aGUgc2lnbmFsaW5nIHNlcnZlclxuICAgICAqL1xuICAgIGhhbmRsZU9uQ29uZmlnTWVzc2FnZShtZXNzYWdlQ29uZmlnKSB7XG4gICAgICAgIHRoaXMucmVzaXplUGxheWVyU3R5bGUoKTtcbiAgICAgICAgLy8gVGVsbCB0aGUgV2ViUnRjQ29udHJvbGxlciB0byBzdGFydCBhIHNlc3Npb24gd2l0aCB0aGUgcGVlciBvcHRpb25zIHNlbnQgZnJvbSB0aGUgc2lnbmFsaW5nIHNlcnZlclxuICAgICAgICB0aGlzLnN0YXJ0U2Vzc2lvbihtZXNzYWdlQ29uZmlnLnBlZXJDb25uZWN0aW9uT3B0aW9ucyk7XG4gICAgfVxuICAgIGhhbmRsZVBpbmdNZXNzYWdlKHBpbmdNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMucHJvdG9jb2wuc2VuZE1lc3NhZ2UoTWVzc2FnZUhlbHBlcnMuY3JlYXRlTWVzc2FnZShNZXNzYWdlcy5wb25nLCB7IHRpbWU6IHBpbmdNZXNzYWdlLnRpbWUgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gdGhlIHNpZ25hbGxpbmcgc2VydmVyIGdpdmVzIHVzIHRoZSBsaXN0IG9mIHN0cmVhbWVyIGlkcy5cbiAgICAgKi9cbiAgICBoYW5kbGVTdHJlYW1lckxpc3RNZXNzYWdlKG1lc3NhZ2VTdHJlYW1lckxpc3QpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oYEdvdCBzdHJlYW1lciBsaXN0ICR7bWVzc2FnZVN0cmVhbWVyTGlzdC5pZHN9YCk7XG4gICAgICAgIGxldCB3YW50ZWRTdHJlYW1lcklkID0gJyc7XG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBzZWxlY3RlZCBzdHJlYW1lciBpZCBvcHRpb25cbiAgICAgICAgY29uc3Qgc3RyZWFtZXJJRE9wdGlvbiA9IHRoaXMuY29uZmlnLmdldFNldHRpbmdPcHRpb24oT3B0aW9uUGFyYW1ldGVycy5TdHJlYW1lcklkKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdTZWxlY3Rpb24gPSBzdHJlYW1lcklET3B0aW9uLnNlbGVjdGVkLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICBpZiAoZXhpc3RpbmdTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gc2VsZWN0ZWQgb3B0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgd2FudGVkU3RyZWFtZXJJZCA9IHN0cmVhbWVySURPcHRpb24uc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHRoZSBzdHJlYW1lcnMgdG8gdGhlIFVJXG4gICAgICAgIGNvbnN0IHNldHRpbmdPcHRpb25zID0gWy4uLm1lc3NhZ2VTdHJlYW1lckxpc3QuaWRzXTsgLy8gY29weSB0aGUgb3JpZ2luYWwgbWVzc2FnZVN0cmVhbWVyTGlzdC5pZHNcbiAgICAgICAgc2V0dGluZ09wdGlvbnMudW5zaGlmdCgnJyk7IC8vIGFkZCBhbiBlbXB0eSBvcHRpb24gYXQgdGhlIHRvcFxuICAgICAgICB0aGlzLmNvbmZpZy5zZXRPcHRpb25TZXR0aW5nT3B0aW9ucyhPcHRpb25QYXJhbWV0ZXJzLlN0cmVhbWVySWQsIHNldHRpbmdPcHRpb25zKTtcbiAgICAgICAgbGV0IGF1dG9TZWxlY3RlZFN0cmVhbWVySWQgPSAnJztcbiAgICAgICAgY29uc3Qgd2FpdEZvclN0cmVhbWVyID0gdGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5XYWl0Rm9yU3RyZWFtZXIpO1xuICAgICAgICBjb25zdCByZWNvbm5lY3RMaW1pdCA9IHRoaXMuY29uZmlnLmdldE51bWVyaWNTZXR0aW5nVmFsdWUoTnVtZXJpY1BhcmFtZXRlcnMuTWF4UmVjb25uZWN0QXR0ZW1wdHMpO1xuICAgICAgICBjb25zdCByZWNvbm5lY3REZWxheSA9IHRoaXMuY29uZmlnLmdldE51bWVyaWNTZXR0aW5nVmFsdWUoTnVtZXJpY1BhcmFtZXRlcnMuU3RyZWFtZXJBdXRvSm9pbkludGVydmFsKTtcbiAgICAgICAgLy8gZmlyc3Qgd2UgZmlndXJlIG91dCBhIHdhbnRlZCBzdHJlYW1lciBpZCB0aHJvdWdoIHZhcmlvdXMgbWVhbnNcbiAgICAgICAgY29uc3QgdXNlVXJsUGFyYW1zID0gdGhpcy5jb25maWcudXNlVXJsUGFyYW1zO1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgSVVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICAgICAgaWYgKHVzZVVybFBhcmFtcyAmJiB1cmxQYXJhbXMuaGFzKE9wdGlvblBhcmFtZXRlcnMuU3RyZWFtZXJJZCkpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlJ3ZlIHNldCB0aGUgc3RyZWFtZXIgaWQgb24gdGhlIHVybCB3ZSBvbmx5IHdhbnQgdGhhdCBzdHJlYW1lciBpZFxuICAgICAgICAgICAgd2FudGVkU3RyZWFtZXJJZCA9IHVybFBhcmFtcy5nZXQoT3B0aW9uUGFyYW1ldGVycy5TdHJlYW1lcklkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN1YnNjcmliZWRTdHJlYW0pIHtcbiAgICAgICAgICAgIC8vIHdlIHdlcmUgcHJldmlvdXNseSBzdWJzY3JpYmVkIHRvIGEgc3RyZWFtZXIsIHdlIHdhbnQgdGhhdFxuICAgICAgICAgICAgd2FudGVkU3RyZWFtZXJJZCA9IHRoaXMuc3Vic2NyaWJlZFN0cmVhbTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3cgbGV0cyBzZWUgaWYgd2UgY2FuIHBpY2sgaXQuXG4gICAgICAgIGlmICh3YW50ZWRTdHJlYW1lcklkICYmIG1lc3NhZ2VTdHJlYW1lckxpc3QuaWRzLmluY2x1ZGVzKHdhbnRlZFN0cmVhbWVySWQpKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgd2FudGVkIHN0cmVhbSBpcyBpbiB0aGUgbGlzdC4gd2UgcGljayB0aGF0XG4gICAgICAgICAgICBhdXRvU2VsZWN0ZWRTdHJlYW1lcklkID0gd2FudGVkU3RyZWFtZXJJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoIXdhbnRlZFN0cmVhbWVySWQgfHwgIXdhaXRGb3JTdHJlYW1lcikgJiYgbWVzc2FnZVN0cmVhbWVyTGlzdC5pZHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgaWYgd2UncmUgbm90IHdhaXRpbmcgZm9yIHRoZSB3YW50ZWQgc3RyZWFtZXIgYW5kIHRoZXJlJ3Mgb25seSBvbmUgc3RyZWFtZXIsIGNvbm5lY3QgdG8gaXRcbiAgICAgICAgICAgIGF1dG9TZWxlY3RlZFN0cmVhbWVySWQgPSBtZXNzYWdlU3RyZWFtZXJMaXN0Lmlkc1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBmb3VuZCBhIHN0cmVhbWVyIGlkIHRvIGF1dG8gc2VsZWN0LCBzZWxlY3QgaXRcbiAgICAgICAgaWYgKGF1dG9TZWxlY3RlZFN0cmVhbWVySWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdCA9IDA7XG4gICAgICAgICAgICB0aGlzLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXRPcHRpb25TZXR0aW5nVmFsdWUoT3B0aW9uUGFyYW1ldGVycy5TdHJlYW1lcklkLCBhdXRvU2VsZWN0ZWRTdHJlYW1lcklkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIGF1dG8gc2VsZWN0ZWQgc3RyZWFtZXIuXG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSB3YWl0aW5nIGZvciBhIHN0cmVhbWVyIHRoZW4gdHJ5IHJlY29ubmVjdGluZ1xuICAgICAgICAgICAgaWYgKHdhaXRGb3JTdHJlYW1lcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlY29ubmVjdEF0dGVtcHQgPCByZWNvbm5lY3RMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdGlsbCByZWNvbm5lY3RzIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHQrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1JlY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm90b2NvbC5zZW5kTWVzc2FnZShNZXNzYWdlSGVscGVycy5jcmVhdGVNZXNzYWdlKE1lc3NhZ2VzLmxpc3RTdHJlYW1lcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVjb25uZWN0RGVsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UndmUgZXhoYXVzdGVkIG91ciByZWNvbm5lY3QgYXR0ZW1wdHMsIHJldHVybiB0byBtYWluIHNjcmVlblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlQXV0b1JlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBkaXNwYXRjaCB0aGlzIGV2ZW50IGZpbmFsbHlcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBTdHJlYW1lckxpc3RNZXNzYWdlRXZlbnQoe1xuICAgICAgICAgICAgbWVzc2FnZVN0cmVhbWVyTGlzdCxcbiAgICAgICAgICAgIGF1dG9TZWxlY3RlZFN0cmVhbWVySWQsXG4gICAgICAgICAgICB3YW50ZWRTdHJlYW1lcklkXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgaGFuZGxlU3Vic2NyaWJlRmFpbGVkTWVzc2FnZShzdWJzY3JpYmVGYWlsZWRNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdCA9IDA7XG4gICAgICAgIHRoaXMuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbmFibGVBdXRvUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuX29uU3Vic2NyaWJlRmFpbGVkKHN1YnNjcmliZUZhaWxlZE1lc3NhZ2UubWVzc2FnZSk7XG4gICAgfVxuICAgIGhhbmRsZVN0cmVhbWVySURDaGFuZ2VkTWVzc2FnZShzdHJlYW1lcklEQ2hhbmdlZE1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbmV3SUQgPSBzdHJlYW1lcklEQ2hhbmdlZE1lc3NhZ2UubmV3SUQ7XG4gICAgICAgIC8vIG5lZWQgdG8gZWRpdCB0aGUgc2VsZWN0ZWQgc3RyZWFtZXIgaW4gdGhlIHNldHRpbmdzIGxpc3RcbiAgICAgICAgY29uc3Qgc3RyZWFtZXJMaXN0T3B0aW9ucyA9IHRoaXMuY29uZmlnLmdldFNldHRpbmdPcHRpb24oT3B0aW9uUGFyYW1ldGVycy5TdHJlYW1lcklkKTtcbiAgICAgICAgLy8gdGVtcG9yYXJpbHkgcHJldmVudCBvbkNoYW5nZSBmcm9tIGZpcmluZyAoaXQgd291bGQgdHJ5IHRvIHN1YnNjcmliZSB0byB0aGUgc3RyZWFtZXIgYWdhaW4pXG4gICAgICAgIGNvbnN0IG9sZE9uQ2hhbmdlID0gc3RyZWFtZXJMaXN0T3B0aW9ucy5vbkNoYW5nZTtcbiAgICAgICAgc3RyZWFtZXJMaXN0T3B0aW9ucy5vbkNoYW5nZSA9ICgpID0+IHsgfTtcbiAgICAgICAgLy8gY2hhbmdlIHRoZSBzZWxlY3RlZCBlbnRyeS5cbiAgICAgICAgY29uc3Qgc3RyZWFtZXJMaXN0ID0gc3RyZWFtZXJMaXN0T3B0aW9ucy5vcHRpb25zO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmVhbWVyTGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHN0cmVhbWVyTGlzdFtpXSA9PSB0aGlzLnN1YnNjcmliZWRTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1lckxpc3RbaV0gPSBuZXdJRDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgdGhlIGxpc3RcbiAgICAgICAgc3RyZWFtZXJMaXN0T3B0aW9ucy5vcHRpb25zID0gc3RyZWFtZXJMaXN0O1xuICAgICAgICAvLyB1cGRhdGUgdGhlIHNlbGVjdGVkIGVudHJ5XG4gICAgICAgIHN0cmVhbWVyTGlzdE9wdGlvbnMuc2VsZWN0ZWQgPSBuZXdJRDtcbiAgICAgICAgLy8gcmVzdG9yZSB0aGUgb2xkIGNoYW5nZSBub3RpZmllci5cbiAgICAgICAgc3RyZWFtZXJMaXN0T3B0aW9ucy5vbkNoYW5nZSA9IG9sZE9uQ2hhbmdlO1xuICAgICAgICAvLyByZW1lbWJlciB3aGljaCBzdHJlYW0gd2UncmUgc3Vic2NyaWJlIHRvXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlZFN0cmVhbSA9IHN0cmVhbWVySURDaGFuZ2VkTWVzc2FnZS5uZXdJRDtcbiAgICAgICAgLy8gbm90aWZ5IGFueSBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBTdHJlYW1lcklEQ2hhbmdlZE1lc3NhZ2VFdmVudCh7XG4gICAgICAgICAgICBuZXdJRFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgUlRDIEFuc3dlciBmcm9tIHRoZSBzaWduYWxpbmcgc2VydmVyXG4gICAgICogQHBhcmFtIEFuc3dlciAtIEFuc3dlciBTRFAgZnJvbSB0aGUgcGVlci5cbiAgICAgKi9cbiAgICBoYW5kbGVXZWJSdGNBbnN3ZXIoQW5zd2VyKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKGBHb3QgYW5zd2VyIHNkcCAke0Fuc3dlci5zZHB9YCk7XG4gICAgICAgIGNvbnN0IHNkcEFuc3dlciA9IHtcbiAgICAgICAgICAgIHNkcDogQW5zd2VyLnNkcCxcbiAgICAgICAgICAgIHR5cGU6ICdhbnN3ZXInXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLnJlY2VpdmVBbnN3ZXIoc2RwQW5zd2VyKTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb3N0V2VicnRjTmVnb3RpYXRpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBSVEMgb2ZmZXIgZnJvbSBhIFdlYlJUQyBwZWVyIChyZWNlaXZlZCB0aHJvdWdoIHRoZSBzaWduYWxsaW5nIHNlcnZlcikuXG4gICAgICogQHBhcmFtIE9mZmVyIC0gT2ZmZXIgU0RQIGZyb20gdGhlIHBlZXIuXG4gICAgICovXG4gICAgaGFuZGxlV2ViUnRjT2ZmZXIoT2ZmZXIpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oYEdvdCBvZmZlciBzZHAgJHtPZmZlci5zZHB9YCk7XG4gICAgICAgIHRoaXMuaXNVc2luZ1NGVSA9IE9mZmVyLnNmdSA/IE9mZmVyLnNmdSA6IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVXNpbmdTVkMgPSBPZmZlci5zY2FsYWJpbGl0eU1vZGUgPyBPZmZlci5zY2FsYWJpbGl0eU1vZGUgIT0gJ0wxVDEnIDogZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmlzVXNpbmdTRlUgfHwgdGhpcy5pc1VzaW5nU1ZDKSB7XG4gICAgICAgICAgICAvLyBEaXNhYmxlIG5lZ290aWF0aW5nIHdpdGggdGhlIHNmdSBhcyB0aGUgc2Z1IG9ubHkgc3VwcG9ydHMgb25lIGNvZGVjIGF0IGEgdGltZVxuICAgICAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIucHJlZmVycmVkQ29kZWMgPSAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBOT1RFOiBUaGVzZSB0d28gc2V0dGluZ3MgY29uZmlndXJhdGlvbnMgYXJlIGRvbmUgb3V0c2lkZSBvZiBhbiBpZih0aGlzLmlzVXNpbmdTRlUpIHNvIHRoYXQgdXNlcnNcbiAgICAgICAgLy8gY2FuIHN3aXRjaCBiZXR3ZWVuIGEgZGVmYXVsdCBhbmQgU0ZVIHN0cmVhbSBhbmQgaGF2ZSB0aGUgc2V0dGluZ3MgcmVjb25maWd1cmUgYXBwcm9wcmlhdGVseVxuICAgICAgICBjb25zdCBzY2FsYWJpbGl0eU1vZGUgPSBPZmZlci5zY2FsYWJpbGl0eU1vZGUgPyBPZmZlci5zY2FsYWJpbGl0eU1vZGUgOiAnTDFUMSc7XG4gICAgICAgIGxldCBhdmFpbGFibGVRdWFsaXRpZXMgPSBbJ0RlZmF1bHQnXTtcbiAgICAgICAgaWYgKHRoaXMuaXNVc2luZ1NGVSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVXNpbmdTVkMpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2VyIGlzIHVzaW5nIGFuIFNGVSB3aXRob3V0IGFueSB0ZW1wb3JhbCBzY2FsYWJpbGl0eS4gSnVzdCBvZmZlciBlYXNpbHkgcmVhZGFibGUgbmFtZXNcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVRdWFsaXRpZXMgPSBbJ0xvdycsICdNZWRpdW0nLCAnSGlnaCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlciBpcyB1c2luZyBTVkMuIEdlbmVyYXRlIGFsbCBhdmFpbGFibGUgb3B0aW9ucy5cbiAgICAgICAgICAgICAgICBhdmFpbGFibGVRdWFsaXRpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhTcGF0aWFsTGF5ZXJzID0gK3NjYWxhYmlsaXR5TW9kZVsxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhUZW1wb3JhbExheWVycyA9ICtzY2FsYWJpbGl0eU1vZGVbM107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcyA9IDE7IHMgPD0gbWF4U3BhdGlhbExheWVyczsgcysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHQgPSAxOyB0IDw9IG1heFRlbXBvcmFsTGF5ZXJzOyB0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZVF1YWxpdGllcy5wdXNoKGBTJHtzfVQke3R9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBwb3NzaWJsZSB2aWRlbyBxdWFsaXR5IG9wdGlvbnNcbiAgICAgICAgdGhpcy5jb25maWcuc2V0T3B0aW9uU2V0dGluZ09wdGlvbnMoT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRRdWFsaXR5LCBhdmFpbGFibGVRdWFsaXRpZXMpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHNlbGVjdGVkIHZpZGVvIHF1YWxpdHkgd2l0aCB0aGUgaGlnaGVzdCBwb3NzaWJsZSByZXNvbHV0aW9uXG4gICAgICAgIHRoaXMuY29uZmlnLnNldE9wdGlvblNldHRpbmdWYWx1ZShPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZFF1YWxpdHksIGF2YWlsYWJsZVF1YWxpdGllcy5zbGljZSgtMSlbMF0pO1xuICAgICAgICBjb25zdCBzZHBPZmZlciA9IHtcbiAgICAgICAgICAgIHNkcDogT2ZmZXIuc2RwLFxuICAgICAgICAgICAgdHlwZTogJ29mZmVyJ1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5yZWNlaXZlT2ZmZXIoc2RwT2ZmZXIsIHRoaXMuY29uZmlnKTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb3N0V2VicnRjTmVnb3RpYXRpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHdoZW4gdGhlIFNGVSBwcm92aWRlcyB0aGUgcGVlciB3aXRoIGl0cyBkYXRhIGNoYW5uZWxzXG4gICAgICogQHBhcmFtIERhdGFDaGFubmVscyAtIFRoZSBtZXNzYWdlIGZyb20gdGhlIFNGVSBjb250YWluaW5nIHRoZSBkYXRhIGNoYW5uZWxzIGlkc1xuICAgICAqL1xuICAgIGhhbmRsZVdlYlJ0Y1NGVVBlZXJEYXRhY2hhbm5lbHMoRGF0YUNoYW5uZWxzKSB7XG4gICAgICAgIGNvbnN0IFNlbmRPcHRpb25zID0ge1xuICAgICAgICAgICAgb3JkZXJlZDogdHJ1ZSxcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogRGF0YUNoYW5uZWxzLnNlbmRTdHJlYW1JZFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1bmlkaXJlY3Rpb25hbCA9IERhdGFDaGFubmVscy5zZW5kU3RyZWFtSWQgIT0gRGF0YUNoYW5uZWxzLnJlY3ZTdHJlYW1JZDtcbiAgICAgICAgdGhpcy5zZW5kcmVjdkRhdGFDaGFubmVsQ29udHJvbGxlci5jcmVhdGVEYXRhQ2hhbm5lbCh0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5wZWVyQ29ubmVjdGlvbiwgdW5pZGlyZWN0aW9uYWwgPyAnc2VuZC1kYXRhY2hhbm5lbCcgOiAnZGF0YWNoYW5uZWwnLCBTZW5kT3B0aW9ucyk7XG4gICAgICAgIGlmICh1bmlkaXJlY3Rpb25hbCkge1xuICAgICAgICAgICAgY29uc3QgUmVjdk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgb3JkZXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlkOiBEYXRhQ2hhbm5lbHMucmVjdlN0cmVhbUlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5yZWN2RGF0YUNoYW5uZWxDb250cm9sbGVyLmNyZWF0ZURhdGFDaGFubmVsKHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLnBlZXJDb25uZWN0aW9uLCAncmVjdi1kYXRhY2hhbm5lbCcsIFJlY3ZPcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMucmVjdkRhdGFDaGFubmVsQ29udHJvbGxlci5oYW5kbGVPbk9wZW4gPSAoKSA9PiB0aGlzLnByb3RvY29sLnNlbmRNZXNzYWdlKE1lc3NhZ2VIZWxwZXJzLmNyZWF0ZU1lc3NhZ2UoTWVzc2FnZXMucGVlckRhdGFDaGFubmVsc1JlYWR5KSk7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSB1bmktZGlyZWN0aW9uYWwsIG9ubHkgdGhlIHJlY3YgZGF0YSBjaGFubmVsIHNob3VsZCBoYW5kbGUgaW5jb21pbmcgbWVzc2FnZXNcbiAgICAgICAgICAgIHRoaXMucmVjdkRhdGFDaGFubmVsQ29udHJvbGxlci5oYW5kbGVPbk1lc3NhZ2UgPSAoZXYpID0+IHRoaXMuaGFuZGxlT25NZXNzYWdlKGV2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVsc2Ugb3VyIHByaW1hcnkgZGF0YWNoYW5uZWwgaXMgc2VuZC9yZWN2IHNvIGl0IGNhbiBoYW5kbGUgaW5jb21pbmcgbWVzc2FnZXNcbiAgICAgICAgICAgIHRoaXMuc2VuZHJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIuaGFuZGxlT25NZXNzYWdlID0gKGV2KSA9PiB0aGlzLmhhbmRsZU9uTWVzc2FnZShldik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlUG9zdFdlYnJ0Y05lZ290aWF0aW9uKCkge1xuICAgICAgICAvLyBzdGFydCB0aGUgYWZrIHdhcm5pbmcgdGltZXIgYXMgUFMgaXMgbm93IHJ1bm5pbmdcbiAgICAgICAgdGhpcy5hZmtDb250cm9sbGVyLnN0YXJ0QWZrV2FybmluZ1RpbWVyKCk7XG4gICAgICAgIC8vIHNob3cgdGhlIG92ZXJsYXkgdGhhdCB3ZSBoYXZlIG5lZ290aWF0ZWQgYSBjb25uZWN0aW9uXG4gICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuX29uV2ViUnRjU2RwKCk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRzVGltZXJIYW5kbGUgJiYgdGhpcy5zdGF0c1RpbWVySGFuZGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuc3RhdHNUaW1lckhhbmRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0c1RpbWVySGFuZGxlID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHRoaXMuZ2V0U3RhdHMoKSwgMTAwMCk7XG4gICAgICAgIC8qICAqL1xuICAgICAgICB0aGlzLnNldE1vdXNlSW5wdXRFbmFibGVkKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuTW91c2VJbnB1dCkpO1xuICAgICAgICB0aGlzLnNldEtleWJvYXJkSW5wdXRFbmFibGVkKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuS2V5Ym9hcmRJbnB1dCkpO1xuICAgICAgICB0aGlzLnNldEdhbWVQYWRJbnB1dEVuYWJsZWQodGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5HYW1lcGFkSW5wdXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3Igd2hlbiBhIHJlbW90ZSBJQ0UgY2FuZGlkYXRlIGlzIHJlY2VpdmVkLlxuICAgICAqIEBwYXJhbSBpY2VDYW5kaWRhdGVJbml0IC0gSW5pdGlhbGl6YXRpb24gZGF0YSB1c2VkIHRvIG1ha2UgdGhlIGFjdHVhbCBJQ0UgQ2FuZGlkYXRlLlxuICAgICAqL1xuICAgIGhhbmRsZUljZUNhbmRpZGF0ZShpY2VDYW5kaWRhdGVJbml0KSB7XG4gICAgICAgIExvZ2dlci5JbmZvKGBSZW1vdGUgSUNFIGNhbmRpZGF0ZSBpbmZvcm1hdGlvbiByZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeShpY2VDYW5kaWRhdGVJbml0KX1gKTtcbiAgICAgICAgLy8gV2UgYXJlIHVzaW5nIFwiYnVuZGxlXCIgcG9saWN5IGZvciBtZWRpYSBsaW5lcyBzbyB3ZSByZW1vdmUgdGhlIHNkcE1pZCBhbmQgc2RwTUxpbmVJbmRleCBhdHRyaWJ1dGVzXG4gICAgICAgIC8vIGZyb20gSUNFIGNhbmRpZGF0ZXMgYXMgdGhlc2UgYXJlIGxlZ2FjeSBhdHRyaWJ1dGVzIGZvciB3aGVuIGJ1bmRsZSBpcyBub3QgdXNlZC5cbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgZG8gdGhpcyB0aGUgYnJvd3NlciBtYXkgYmUgdW5hYmxlIHRvIGZvcm0gYSBtZWRpYSBjb25uZWN0aW9uXG4gICAgICAgIC8vIGJlY2F1c2Ugc29tZSBicm93c2VycyBhcmUgYnJpdHRsZSBpZiB0aGUgYnVuZGxlIG1hc3RlciAoZS5nLiBjb21tb25seSBtaWQ9MCkgZG9lc24ndCBnZXQgYSBjYW5kaWRhdGUgZmlyc3QuXG4gICAgICAgIGNvbnN0IHJlbW90ZUljZUNhbmRpZGF0ZSA9IG5ldyBSVENJY2VDYW5kaWRhdGUoe1xuICAgICAgICAgICAgY2FuZGlkYXRlOiBpY2VDYW5kaWRhdGVJbml0LmNhbmRpZGF0ZSxcbiAgICAgICAgICAgIHNkcE1pZDogJydcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLmhhbmRsZU9uSWNlKHJlbW90ZUljZUNhbmRpZGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIGljZSBDYW5kaWRhdGUgdG8gdGhlIHNpZ25hbGluZyBzZXJ2ZXIgdmlhIHdlYnNvY2tldFxuICAgICAqIEBwYXJhbSBpY2VFdmVudCAtIFJUQyBQZWVyIENvbm5lY3Rpb25JY2VFdmVudCkge1xuICAgICAqL1xuICAgIGhhbmRsZVNlbmRJY2VDYW5kaWRhdGUoaWNlRXZlbnQpIHtcbiAgICAgICAgaWYgKGljZUV2ZW50LmNhbmRpZGF0ZSAmJiBpY2VFdmVudC5jYW5kaWRhdGUuY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbyhgTG9jYWwgSUNFIGNhbmRpZGF0ZSBnZW5lcmF0ZWQ6IGAgKyBKU09OLnN0cmluZ2lmeShpY2VFdmVudC5jYW5kaWRhdGUpKTtcbiAgICAgICAgICAgIHRoaXMucHJvdG9jb2wuc2VuZE1lc3NhZ2UoTWVzc2FnZUhlbHBlcnMuY3JlYXRlTWVzc2FnZShNZXNzYWdlcy5pY2VDYW5kaWRhdGUsIHsgY2FuZGlkYXRlOiBpY2VFdmVudC5jYW5kaWRhdGUgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIGljZSBDYW5kaWRhdGUgdG8gdGhlIHNpZ25hbGluZyBzZXJ2ZXIgdmlhIHdlYnNvY2tldFxuICAgICAqIEBwYXJhbSBpY2VFdmVudCAtIFJUQyBQZWVyIENvbm5lY3Rpb25JY2VFdmVudCkge1xuICAgICAqL1xuICAgIGhhbmRsZURhdGFDaGFubmVsKGRhdGFjaGFubmVsRXZlbnQpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ0RhdGEgY2hhbm5lbCBjcmVhdGVkIGZvciB1cyBieSBicm93c2VyIGFzIHdlIGFyZSBhIHJlY2VpdmluZyBwZWVyLicpO1xuICAgICAgICB0aGlzLnNlbmRyZWN2RGF0YUNoYW5uZWxDb250cm9sbGVyLmRhdGFDaGFubmVsID0gZGF0YWNoYW5uZWxFdmVudC5jaGFubmVsO1xuICAgICAgICAvLyBEYXRhIGNoYW5uZWwgd2FzIGNyZWF0ZWQgZm9yIHVzLCBzbyB3ZSBqdXN0IG5lZWQgdG8gc2V0dXAgaXRzIGNhbGxiYWNrcyBhbmQgYXJyYXkgdHlwZVxuICAgICAgICB0aGlzLnNlbmRyZWN2RGF0YUNoYW5uZWxDb250cm9sbGVyLnNldHVwRGF0YUNoYW5uZWwoKTtcbiAgICAgICAgdGhpcy5zZW5kcmVjdkRhdGFDaGFubmVsQ29udHJvbGxlci5oYW5kbGVPbk1lc3NhZ2UgPSAoZXYpID0+IHRoaXMuaGFuZGxlT25NZXNzYWdlKGV2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCB0aGUgUlRDIE9mZmVyIFNlc3Npb24gdG8gdGhlIFNpZ25hbGluZyBzZXJ2ZXIgdmlhIHdlYnNvY2tldFxuICAgICAqIEBwYXJhbSBvZmZlciAtIFJUQyBTZXNzaW9uIERlc2NyaXB0aW9uXG4gICAgICovXG4gICAgaGFuZGxlU2VuZFdlYlJUQ09mZmVyKG9mZmVyKSB7XG4gICAgICAgIGlmIChvZmZlci50eXBlICE9PSAnb2ZmZXInKSB7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoYGhhbmRsZVNlbmRXZWJSVENPZmZlciB3YXMgY2FsbGVkIHdpdGggdHlwZSAke29mZmVyLnR5cGV9IC0gaXQgb25seSBleHBlY3RzIFwib2ZmZXJcImApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIExvZ2dlci5JbmZvKCdTZW5kaW5nIHRoZSBvZmZlciB0byB0aGUgU2VydmVyJyk7XG4gICAgICAgIGNvbnN0IGV4dHJhUGFyYW1zID0ge1xuICAgICAgICAgICAgc2RwOiBvZmZlci5zZHAsXG4gICAgICAgICAgICBtaW5CaXRyYXRlQnBzOiAxMDAwICogdGhpcy5jb25maWcuZ2V0TnVtZXJpY1NldHRpbmdWYWx1ZShOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNaW5CaXRyYXRlKSxcbiAgICAgICAgICAgIG1heEJpdHJhdGVCcHM6IDEwMDAgKiB0aGlzLmNvbmZpZy5nZXROdW1lcmljU2V0dGluZ1ZhbHVlKE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01heEJpdHJhdGUpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvdG9jb2wuc2VuZE1lc3NhZ2UoTWVzc2FnZUhlbHBlcnMuY3JlYXRlTWVzc2FnZShNZXNzYWdlcy5vZmZlciwgZXh0cmFQYXJhbXMpKTtcbiAgICAgICAgLy8gU2VuZCBvZmZlciBiYWNrIHRvIFBpeGVsIFN0cmVhbWluZyBtYWluIGNsYXNzIGZvciBldmVudCBkaXNwYXRjaFxuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbldlYlJ0Y1NkcE9mZmVyKG9mZmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCB0aGUgUlRDIE9mZmVyIFNlc3Npb24gdG8gdGhlIFNpZ25hbGluZyBzZXJ2ZXIgdmlhIHdlYnNvY2tldFxuICAgICAqIEBwYXJhbSBhbnN3ZXIgLSBSVEMgU2Vzc2lvbiBEZXNjcmlwdGlvblxuICAgICAqL1xuICAgIGhhbmRsZVNlbmRXZWJSVENBbnN3ZXIoYW5zd2VyKSB7XG4gICAgICAgIGlmIChhbnN3ZXIudHlwZSAhPT0gJ2Fuc3dlcicpIHtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihgaGFuZGxlU2VuZFdlYlJUQ0Fuc3dlciB3YXMgY2FsbGVkIHdpdGggdHlwZSAke2Fuc3dlci50eXBlfSAtIGl0IG9ubHkgZXhwZWN0cyBcImFuc3dlclwiYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgTG9nZ2VyLkluZm8oJ1NlbmRpbmcgdGhlIGFuc3dlciB0byB0aGUgU2VydmVyJyk7XG4gICAgICAgIGNvbnN0IGV4dHJhUGFyYW1zID0ge1xuICAgICAgICAgICAgc2RwOiBhbnN3ZXIuc2RwLFxuICAgICAgICAgICAgbWluQml0cmF0ZUJwczogMTAwMCAqIHRoaXMuY29uZmlnLmdldE51bWVyaWNTZXR0aW5nVmFsdWUoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWluQml0cmF0ZSksXG4gICAgICAgICAgICBtYXhCaXRyYXRlQnBzOiAxMDAwICogdGhpcy5jb25maWcuZ2V0TnVtZXJpY1NldHRpbmdWYWx1ZShOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNYXhCaXRyYXRlKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb3RvY29sLnNlbmRNZXNzYWdlKE1lc3NhZ2VIZWxwZXJzLmNyZWF0ZU1lc3NhZ2UoTWVzc2FnZXMuYW5zd2VyLCBleHRyYVBhcmFtcykpO1xuICAgICAgICBpZiAodGhpcy5pc1VzaW5nU0ZVKSB7XG4gICAgICAgICAgICB0aGlzLnByb3RvY29sLnNlbmRNZXNzYWdlKE1lc3NhZ2VIZWxwZXJzLmNyZWF0ZU1lc3NhZ2UoTWVzc2FnZXMuZGF0YUNoYW5uZWxSZXF1ZXN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VuZCBhbnN3ZXIgYmFjayB0byBQaXhlbCBTdHJlYW1pbmcgbWFpbiBjbGFzcyBmb3IgZXZlbnQgZGlzcGF0Y2hcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25XZWJSdGNTZHBBbnN3ZXIoYW5zd2VyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmcmVlemUgZnJhbWUgb3ZlcmxheSB0byB0aGUgcGxheWVyIGRpdlxuICAgICAqL1xuICAgIHNldFVwTW91c2VBbmRGcmVlemVGcmFtZSgpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRpbmcgYW5kIG5vcm1hbGl6aW5nIHBvc2l0aW9ucyBkZXBlbmRzIG9uIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBwbGF5ZXIuXG4gICAgICAgIGNvbnN0IHBsYXllckVsZW1lbnQgPSB0aGlzLnZpZGVvUGxheWVyLmdldFZpZGVvUGFyZW50RWxlbWVudCgpO1xuICAgICAgICBjb25zdCB2aWRlb0VsZW1lbnQgPSB0aGlzLnZpZGVvUGxheWVyLmdldFZpZGVvRWxlbWVudCgpO1xuICAgICAgICB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIucmVjb25maWd1cmUoeyB3aWR0aDogcGxheWVyRWxlbWVudC5jbGllbnRXaWR0aCwgaGVpZ2h0OiBwbGF5ZXJFbGVtZW50LmNsaWVudEhlaWdodCB9LCB7IHdpZHRoOiB2aWRlb0VsZW1lbnQudmlkZW9XaWR0aCwgaGVpZ2h0OiB2aWRlb0VsZW1lbnQudmlkZW9IZWlnaHQgfSk7XG4gICAgICAgIHRoaXMuZnJlZXplRnJhbWVDb250cm9sbGVyLmZyZWV6ZUZyYW1lLnJlc2l6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgQ29ubmVjdGlvbiB0byB0aGUgc2lnbmFsaW5nIHNlcnZlclxuICAgICAqL1xuICAgIGNsb3NlU2lnbmFsaW5nU2VydmVyKG1lc3NhZ2UsIGFsbG93UmVjb25uZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5sb2NhbGx5Q2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbmFibGVBdXRvUmVjb25uZWN0ID0gYWxsb3dSZWNvbm5lY3Q7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAoX2EgPSB0aGlzLnByb3RvY29sKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgxMDAwLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIHBlZXIgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGNsb3NlUGVlckNvbm5lY3Rpb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSBhbGwgY29ubmVjdGlvbnNcbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZVNpZ25hbGluZ1NlcnZlcignJywgZmFsc2UpO1xuICAgICAgICB0aGlzLmNsb3NlUGVlckNvbm5lY3Rpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmlyZXMgYSBWaWRlbyBTdGF0cyBFdmVudCBpbiB0aGUgUlRDIFBlZXIgQ29ubmVjdGlvblxuICAgICAqL1xuICAgIGdldFN0YXRzKCkge1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5nZW5lcmF0ZVN0YXRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBMYXRlbmN5IFRlc3QgUmVxdWVzdCB0byB0aGUgVUUgSW5zdGFuY2VcbiAgICAgKi9cbiAgICBzZW5kTGF0ZW5jeVRlc3QoKSB7XG4gICAgICAgIHRoaXMubGF0ZW5jeVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTGF0ZW5jeVRlc3QnKShbXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgU3RhcnRUaW1lOiB0aGlzLmxhdGVuY3lTdGFydFRpbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgRGF0YSBDaGFubmVsIExhdGVuY3kgVGVzdCBSZXF1ZXN0IHRvIHRoZSBVRSBJbnN0YW5jZVxuICAgICAqL1xuICAgIHNlbmREYXRhQ2hhbm5lbExhdGVuY3lUZXN0KGRlc2NyaXB0b3IpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdEYXRhQ2hhbm5lbExhdGVuY3lUZXN0JykoW1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoZGVzY3JpcHRvcilcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIE1pblFQIGVuY29kZXIgc2V0dGluZyB0byB0aGUgVUUgSW5zdGFuY2UuXG4gICAgICogQHBhcmFtIG1pblFQIC0gVGhlIGxvd2VyIGJvdW5kIGZvciBRUCB3aGVuIGVuY29kaW5nXG4gICAgICogdmFsaWQgdmFsdWVzIGFyZSAoMS01MSkgd2hlcmU6XG4gICAgICogMSA9IEJlc3QgcXVhbGl0eSBidXQgaGlnaGVzdCBiaXRyYXRlLlxuICAgICAqIDUxID0gV29yc3QgcXVhbGl0eSBidXQgbG93ZXN0IGJpdHJhdGUuXG4gICAgICogQnkgZGVmYXVsdCB0aGUgbWluUVAgaXMgMSBtZWFuaW5nIHRoZSBlbmNvZGVyIGlzIGZyZWVcbiAgICAgKiB0byBhaW0gZm9yIHRoZSBiZXN0IHF1YWxpdHkgaXQgY2FuIG9uIHRoZSBnaXZlbiBuZXR3b3JrIGxpbmsuXG4gICAgICovXG4gICAgc2VuZEVuY29kZXJNaW5RUChtaW5RUCkge1xuICAgICAgICBMb2dnZXIuSW5mbyhgTWluUVA9JHttaW5RUH1cXG5gKTtcbiAgICAgICAgaWYgKG1pblFQICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnQ29tbWFuZCcpKFtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICdFbmNvZGVyLk1pblFQJzogbWluUVBcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCB0aGUgTWF4UVAgZW5jb2RlciBzZXR0aW5nIHRvIHRoZSBVRSBJbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gbWF4UVAgLSBUaGUgdXBwZXIgYm91bmQgZm9yIFFQIHdoZW4gZW5jb2RpbmdcbiAgICAgKiB2YWxpZCB2YWx1ZXMgYXJlICgxLTUxKSB3aGVyZTpcbiAgICAgKiAxID0gQmVzdCBxdWFsaXR5IGJ1dCBoaWdoZXN0IGJpdHJhdGUuXG4gICAgICogNTEgPSBXb3JzdCBxdWFsaXR5IGJ1dCBsb3dlc3QgYml0cmF0ZS5cbiAgICAgKiBCeSBkZWZhdWx0IHRoZSBtYXhRUCBpcyA1MSBtZWFuaW5nIHRoZSBlbmNvZGVyIGlzIGZyZWVcbiAgICAgKiB0byBkcm9wIHF1YWxpdHkgYXMgbG93IGFzIG5lZWRlZCBvbiB0aGUgZ2l2ZW4gbmV0d29yayBsaW5rLlxuICAgICAqL1xuICAgIHNlbmRFbmNvZGVyTWF4UVAobWF4UVApIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oYE1heFFQPSR7bWF4UVB9XFxuYCk7XG4gICAgICAgIGlmIChtYXhRUCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0NvbW1hbmQnKShbXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAnRW5jb2Rlci5NYXhRUCc6IG1heFFQXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIE1pblF1YWxpdHkgZW5jb2RlciBzZXR0aW5nIHRvIHRoZSBVRSBJbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gbWluUXVhbGl0eSAtIFRoZSBsb3dlciBib3VuZCBmb3IgcXVhbGl0eSB3aGVuIGVuY29kaW5nXG4gICAgICogdmFsaWQgdmFsdWVzIGFyZSAoMC0xMDApIHdoZXJlOlxuICAgICAqIDAgPSBXb3JzdCBxdWFsaXR5LlxuICAgICAqIDEwMCA9IEJlc3QgcXVhbGl0eS5cbiAgICAgKi9cbiAgICBzZW5kRW5jb2Rlck1pblF1YWxpdHkobWluUXVhbGl0eSkge1xuICAgICAgICBMb2dnZXIuSW5mbyhgTWluUXVhbGl0eT0ke21pblF1YWxpdHl9XFxuYCk7XG4gICAgICAgIGlmIChtaW5RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnQ29tbWFuZCcpKFtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICdFbmNvZGVyLk1pblF1YWxpdHknOiBtaW5RdWFsaXR5XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIE1heFF1YWxpdHkgZW5jb2RlciBzZXR0aW5nIHRvIHRoZSBVRSBJbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gbWF4UXVhbGl0eSAtIFRoZSB1cHBlciBib3VuZCBmb3IgcXVhbGl0eSB3aGVuIGVuY29kaW5nXG4gICAgICogdmFsaWQgdmFsdWVzIGFyZSAoMC0xMDApIHdoZXJlOlxuICAgICAqIDAgPSBXb3JzdCBxdWFsaXR5LlxuICAgICAqIDEwMCA9IEJlc3QgcXVhbGl0eS5cbiAgICAgKi9cbiAgICBzZW5kRW5jb2Rlck1heFF1YWxpdHkobWF4UXVhbGl0eSkge1xuICAgICAgICBMb2dnZXIuSW5mbyhgTWF4UXVhbGl0eT0ke21heFF1YWxpdHl9XFxuYCk7XG4gICAgICAgIGlmIChtYXhRdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnQ29tbWFuZCcpKFtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICdFbmNvZGVyLk1heFF1YWxpdHknOiBtYXhRdWFsaXR5XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIHsgV2ViUlRDLk1pbkJpdHJhdGU6IFNvbWVOdW1iZXIgfX0gY29tbWFuZCB0byBVRSB0byBzZXRcbiAgICAgKiB0aGUgbWluaW11bSBiaXRyYXRlIHRoYXQgd2UgYWxsb3cgV2ViUlRDIHRvIHVzZVxuICAgICAqIChub3RlIHNldHRpbmcgdGhpcyB0b28gaGlnaCBpbiBwb29yIG5ldHdvcmtzIGNhbiBiZSBwcm9ibGVtYXRpYykuXG4gICAgICogQHBhcmFtIG1pbkJpdHJhdGUgLSBUaGUgbWluaW11bSBiaXRyYXRlIHdlIHdvdWxkIGxpa2UgV2ViUlRDIHRvIG5vdCBmYWxsIGJlbG93LlxuICAgICAqL1xuICAgIHNlbmRXZWJSVENNaW5CaXRyYXRlKG1pbkJpdHJhdGUpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oYFdlYlJUQyBNaW4gQml0cmF0ZT0ke21pbkJpdHJhdGV9YCk7XG4gICAgICAgIGlmIChtaW5CaXRyYXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnQ29tbWFuZCcpKFtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICdXZWJSVEMuTWluQml0cmF0ZSc6IG1pbkJpdHJhdGVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCB0aGUgeyBXZWJSVEMuTWF4Qml0cmF0ZTogU29tZU51bWJlciB9fSBjb21tYW5kIHRvIFVFIHRvIHNldFxuICAgICAqIHRoZSBtaW5pbXVtIGJpdHJhdGUgdGhhdCB3ZSBhbGxvdyBXZWJSVEMgdG8gdXNlXG4gICAgICogKG5vdGUgc2V0dGluZyB0aGlzIHRvbyBsb3cgY291bGQgcmVzdWx0IGluIGJsb2NreSB2aWRlbykuXG4gICAgICogQHBhcmFtIG1pbkJpdHJhdGUgLSBUaGUgbWluaW11bSBiaXRyYXRlIHdlIHdvdWxkIGxpa2UgV2ViUlRDIHRvIG5vdCBmYWxsIGJlbG93LlxuICAgICAqL1xuICAgIHNlbmRXZWJSVENNYXhCaXRyYXRlKG1heEJpdHJhdGUpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oYFdlYlJUQyBNYXggQml0cmF0ZT0ke21heEJpdHJhdGV9YCk7XG4gICAgICAgIGlmIChtYXhCaXRyYXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnQ29tbWFuZCcpKFtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICdXZWJSVEMuTWF4Qml0cmF0ZSc6IG1heEJpdHJhdGVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCB0aGUgeyBXZWJSVEMuRnBzOiBTb21lTnVtYmVyIH19IFVFIDUuMCtcbiAgICAgKiBhbmQgeyBXZWJSVEMuTWF4RnBzIH0gVUUgNC4yNyBjb21tYW5kIHRvIHNldFxuICAgICAqIHRoZSBtYXhpbXVtIGZwcyB3ZSB3b3VsZCBsaWtlIFdlYlJUQyB0byBzdHJlYW0gYXQuXG4gICAgICogQHBhcmFtIGZwcyAtIFRoZSBtYXhpbXVtIHN0cmVhbSBmcHMuXG4gICAgICovXG4gICAgc2VuZFdlYlJUQ0ZwcyhmcHMpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oYFdlYlJUQyBGUFM9JHtmcHN9YCk7XG4gICAgICAgIGlmIChmcHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdDb21tYW5kJykoW1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHsgJ1dlYlJUQy5GcHMnOiBmcHMgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLyogVE9ETzogUmVtb3ZlIHdoZW4gVUUgNC4yNyB1bnN1cHBvcnRlZC4gKi9cbiAgICAgICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnQ29tbWFuZCcpKFtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7ICdXZWJSVEMuTWF4RnBzJzogZnBzIH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyB0aGUgVUkgRGVzY3JpcHRvciBgc3RhdCBmcHNgIHRvIHRoZSBVRSBJbnN0YW5jZVxuICAgICAqL1xuICAgIHNlbmRTaG93RnBzKCkge1xuICAgICAgICBMb2dnZXIuSW5mbygnLS0tLSAgIFNlbmRpbmcgc2hvdyBzdGF0IHRvIFVFICAgLS0tLScpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0NvbW1hbmQnKShbSlNPTi5zdHJpbmdpZnkoeyAnc3RhdC5mcHMnOiAnJyB9KV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGFuIElmcmFtZSByZXF1ZXN0IHRvIHRoZSBzdHJlYW1lclxuICAgICAqL1xuICAgIHNlbmRJZnJhbWVSZXF1ZXN0KCkge1xuICAgICAgICBMb2dnZXIuSW5mbygnLS0tLSAgIFNlbmRpbmcgUmVxdWVzdCBmb3IgYW4gSUZyYW1lICAtLS0tJyk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnSUZyYW1lUmVxdWVzdCcpKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBVSUludGVyYWN0aW9uIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBlbWl0VUlJbnRlcmFjdGlvbihkZXNjcmlwdG9yKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCctLS0tICAgU2VuZGluZyBjdXN0b20gVUlJbnRlcmFjdGlvbiBtZXNzYWdlICAgLS0tLScpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ1VJSW50ZXJhY3Rpb24nKShbSlNPTi5zdHJpbmdpZnkoZGVzY3JpcHRvcildKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIENvbW1hbmQgbWVzc2FnZVxuICAgICAqL1xuICAgIGVtaXRDb21tYW5kKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0gICBTZW5kaW5nIGN1c3RvbSBDb21tYW5kIG1lc3NhZ2UgICAtLS0tJyk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnQ29tbWFuZCcpKFtKU09OLnN0cmluZ2lmeShkZXNjcmlwdG9yKV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgY29uc29sZSBjb21tYW5kIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBlbWl0Q29uc29sZUNvbW1hbmQoY29tbWFuZCkge1xuICAgICAgICBMb2dnZXIuSW5mbygnLS0tLSAgIFNlbmRpbmcgY3VzdG9tIENvbW1hbmQ6Q29uc29sZUNvbW1hbmQgbWVzc2FnZSAgIC0tLS0nKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdDb21tYW5kJykoW1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIENvbnNvbGVDb21tYW5kOiBjb21tYW5kXG4gICAgICAgICAgICB9KVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSByZXF1ZXN0IHRvIHRoZSBVRSBJbnN0YW5jZSB0byBoYXZlIG93bmVyc2hpcCBvZiBRdWFsaXR5XG4gICAgICovXG4gICAgc2VuZFJlcXVlc3RRdWFsaXR5Q29udHJvbE93bmVyc2hpcCgpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0gICBTZW5kaW5nIFJlcXVlc3QgdG8gQ29udHJvbCBRdWFsaXR5ICAtLS0tJyk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzQ29udHJvbGxlci5TZW5kUmVxdWVzdFF1YWxpdHlDb250cm9sKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBgVGV4dEJveEVudHJ5YCBtZXNzYWdlIGJhY2sgdG8gVUUuXG4gICAgICogQHBhcmFtIGNvbnRlbnRzIFRoZSBuZXcgY29udGVudHMgb2YgdGhlIFVFIHNpZGUgdGV4dCBib3guXG4gICAgICovXG4gICAgc2VuZFRleHRib3hFbnRyeShjb250ZW50cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIExvZ2dlci5JbmZvKCctLS0tICAgU2VuZGluZyBUZXh0Ym94RW50cnkgbWVzc2FnZSAgLS0tLScpO1xuICAgICAgICAoX2EgPSB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ1RleHRib3hFbnRyeScpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoW2NvbnRlbnRzXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hlbiBhIExhdGVuY3kgVGVzdCBSZXN1bHQgYXJlIHJlY2VpdmVkIGZyb20gdGhlIFVFIEluc3RhbmNlXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBMYXRlbmN5IFRlc3QgVGltaW5nc1xuICAgICAqL1xuICAgIGhhbmRsZUxhdGVuY3lUZXN0UmVzdWx0KG1lc3NhZ2UpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ0RhdGFDaGFubmVsUmVjZWl2ZU1lc3NhZ2VUeXBlLmxhdGVuY3lUZXN0Jyk7XG4gICAgICAgIGNvbnN0IGxhdGVuY3lBc1N0cmluZyA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTE2JykuZGVjb2RlKG1lc3NhZ2Uuc2xpY2UoMSkpO1xuICAgICAgICBjb25zdCBsYXRlbmN5VGVzdFJlc3VsdHMgPSBuZXcgTGF0ZW5jeVRlc3RSZXN1bHRzKCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24obGF0ZW5jeVRlc3RSZXN1bHRzLCBKU09OLnBhcnNlKGxhdGVuY3lBc1N0cmluZykpO1xuICAgICAgICBsYXRlbmN5VGVzdFJlc3VsdHMucHJvY2Vzc0ZpZWxkcygpO1xuICAgICAgICBsYXRlbmN5VGVzdFJlc3VsdHMudGVzdFN0YXJ0VGltZU1zID0gdGhpcy5sYXRlbmN5U3RhcnRUaW1lO1xuICAgICAgICBsYXRlbmN5VGVzdFJlc3VsdHMuYnJvd3NlclJlY2VpcHRUaW1lTXMgPSBEYXRlLm5vdygpO1xuICAgICAgICBsYXRlbmN5VGVzdFJlc3VsdHMubGF0ZW5jeUV4Y2x1ZGluZ0RlY29kZSA9IH5+KGxhdGVuY3lUZXN0UmVzdWx0cy5icm93c2VyUmVjZWlwdFRpbWVNcyAtIGxhdGVuY3lUZXN0UmVzdWx0cy50ZXN0U3RhcnRUaW1lTXMpO1xuICAgICAgICBsYXRlbmN5VGVzdFJlc3VsdHMudGVzdER1cmF0aW9uID0gfn4obGF0ZW5jeVRlc3RSZXN1bHRzLlRyYW5zbWlzc2lvblRpbWVNcyAtIGxhdGVuY3lUZXN0UmVzdWx0cy5SZWNlaXB0VGltZU1zKTtcbiAgICAgICAgbGF0ZW5jeVRlc3RSZXN1bHRzLm5ldHdvcmtMYXRlbmN5ID0gfn4obGF0ZW5jeVRlc3RSZXN1bHRzLmxhdGVuY3lFeGNsdWRpbmdEZWNvZGUgLSBsYXRlbmN5VGVzdFJlc3VsdHMudGVzdER1cmF0aW9uKTtcbiAgICAgICAgaWYgKGxhdGVuY3lUZXN0UmVzdWx0cy5mcmFtZURpc3BsYXlEZWx0YVRpbWVNcyAmJiBsYXRlbmN5VGVzdFJlc3VsdHMuYnJvd3NlclJlY2VpcHRUaW1lTXMpIHtcbiAgICAgICAgICAgIGxhdGVuY3lUZXN0UmVzdWx0cy5lbmRUb0VuZExhdGVuY3kgPSB+fihsYXRlbmN5VGVzdFJlc3VsdHMuZnJhbWVEaXNwbGF5RGVsdGFUaW1lTXMgK1xuICAgICAgICAgICAgICAgIGxhdGVuY3lUZXN0UmVzdWx0cy5uZXR3b3JrTGF0ZW5jeSxcbiAgICAgICAgICAgICAgICArbGF0ZW5jeVRlc3RSZXN1bHRzLkNhcHR1cmVUb1NlbmRNcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25MYXRlbmN5VGVzdFJlc3VsdChsYXRlbmN5VGVzdFJlc3VsdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gYSBEYXRhIENoYW5uZWwgTGF0ZW5jeSBUZXN0IFJlc3BvbnNlIGlzIHJlY2VpdmVkIGZyb20gdGhlIFVFIEluc3RhbmNlXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBEYXRhIENoYW5uZWwgTGF0ZW5jeSBUZXN0IFJlc3BvbnNlXG4gICAgICovXG4gICAgaGFuZGxlRGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlc3BvbnNlKG1lc3NhZ2UpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ0RhdGFDaGFubmVsUmVjZWl2ZU1lc3NhZ2VUeXBlLmRhdGFDaGFubmVsTGF0ZW5jeVJlc3BvbnNlJyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlQXNTdHJpbmcgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi0xNicpLmRlY29kZShtZXNzYWdlLnNsaWNlKDEpKTtcbiAgICAgICAgY29uc3QgbGF0ZW5jeVRlc3RSZXNwb25zZSA9IEpTT04ucGFyc2UocmVzcG9uc2VBc1N0cmluZyk7XG4gICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuX29uRGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlc3BvbnNlKGxhdGVuY3lUZXN0UmVzcG9uc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gdGhlIEVuY29kZXIgYW5kIFdlYiBSVEMgU2V0dGluZ3MgYXJlIHJlY2VpdmVkIGZyb20gdGhlIFVFIEluc3RhbmNlXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbml0aWFsIEVuY29kZXIgYW5kIFdlYiBSVEMgU2V0dGluZ3NcbiAgICAgKi9cbiAgICBoYW5kbGVJbml0aWFsU2V0dGluZ3MobWVzc2FnZSkge1xuICAgICAgICBMb2dnZXIuSW5mbygnRGF0YUNoYW5uZWxSZWNlaXZlTWVzc2FnZVR5cGUuSW5pdGlhbFNldHRpbmdzJyk7XG4gICAgICAgIGNvbnN0IHBheWxvYWRBc1N0cmluZyA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTE2JykuZGVjb2RlKG1lc3NhZ2Uuc2xpY2UoMSkpO1xuICAgICAgICBjb25zdCBwYXJzZWRJbml0aWFsU2V0dGluZ3MgPSBKU09OLnBhcnNlKHBheWxvYWRBc1N0cmluZyk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxTZXR0aW5ncyA9IG5ldyBJbml0aWFsU2V0dGluZ3MoKTtcbiAgICAgICAgaWYgKHBhcnNlZEluaXRpYWxTZXR0aW5ncy5FbmNvZGVyKSB7XG4gICAgICAgICAgICBpbml0aWFsU2V0dGluZ3MuRW5jb2RlclNldHRpbmdzID0gcGFyc2VkSW5pdGlhbFNldHRpbmdzLkVuY29kZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZEluaXRpYWxTZXR0aW5ncy5XZWJSVEMpIHtcbiAgICAgICAgICAgIGluaXRpYWxTZXR0aW5ncy5XZWJSVENTZXR0aW5ncyA9IHBhcnNlZEluaXRpYWxTZXR0aW5ncy5XZWJSVEM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZEluaXRpYWxTZXR0aW5ncy5QaXhlbFN0cmVhbWluZykge1xuICAgICAgICAgICAgaW5pdGlhbFNldHRpbmdzLlBpeGVsU3RyZWFtaW5nU2V0dGluZ3MgPSBwYXJzZWRJbml0aWFsU2V0dGluZ3MuUGl4ZWxTdHJlYW1pbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZEluaXRpYWxTZXR0aW5ncy5Db25maWdPcHRpb25zICYmXG4gICAgICAgICAgICBwYXJzZWRJbml0aWFsU2V0dGluZ3MuQ29uZmlnT3B0aW9ucy5EZWZhdWx0VG9Ib3ZlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXRGbGFnRW5hYmxlZChGbGFncy5Ib3ZlcmluZ01vdXNlTW9kZSwgISFwYXJzZWRJbml0aWFsU2V0dGluZ3MuQ29uZmlnT3B0aW9ucy5EZWZhdWx0VG9Ib3Zlcik7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdGlhbFNldHRpbmdzLnVlQ29tcGF0aWJsZSgpO1xuICAgICAgICBMb2dnZXIuSW5mbyhwYXlsb2FkQXNTdHJpbmcpO1xuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbkluaXRpYWxTZXR0aW5ncyhpbml0aWFsU2V0dGluZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gdGhlIFF1YW50aXphdGlvbiBQYXJhbWV0ZXIgYXJlIHJlY2VpdmVkIGZyb20gdGhlIFVFIEluc3RhbmNlXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBFbmNvZGVycyBRdWFudGl6YXRpb24gUGFyYW1ldGVyXG4gICAgICovXG4gICAgaGFuZGxlVmlkZW9FbmNvZGVyQXZnUVAobWVzc2FnZSkge1xuICAgICAgICBMb2dnZXIuSW5mbygnRGF0YUNoYW5uZWxSZWNlaXZlTWVzc2FnZVR5cGUuVmlkZW9FbmNvZGVyQXZnUVAnKTtcbiAgICAgICAgY29uc3QgQXZnUVAgPSBOdW1iZXIobmV3IFRleHREZWNvZGVyKCd1dGYtMTYnKS5kZWNvZGUobWVzc2FnZS5zbGljZSgxKSkpO1xuICAgICAgICB0aGlzLnNldFZpZGVvRW5jb2RlckF2Z1FQKEF2Z1FQKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIHRoZSB2aWRlbyBlbGVtZW50IGhhcyBiZWVuIGxvYWRlZCB3aXRoIGEgc3JjT2JqZWN0XG4gICAgICovXG4gICAgaGFuZGxlVmlkZW9Jbml0aWFsaXplZCgpIHtcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25WaWRlb0luaXRpYWxpemVkKCk7XG4gICAgICAgIC8vIGVpdGhlciBhdXRvcGxheSB0aGUgdmlkZW8gb3Igc2V0IHVwIHRoZSBwbGF5IG92ZXJsYXlcbiAgICAgICAgdGhpcy5hdXRvUGxheVZpZGVvT3JTZXRVcFBsYXlPdmVybGF5KCk7XG4gICAgICAgIHRoaXMucmVzaXplUGxheWVyU3R5bGUoKTtcbiAgICAgICAgdGhpcy52aWRlb1BsYXllci51cGRhdGVWaWRlb1N0cmVhbVNpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmxhZyBzZXQgaWYgdGhlIHVzZXIgaGFzIFF1YWxpdHkgT3duZXJzaGlwXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBEb2VzIHRoZSBjdXJyZW50IGNsaWVudCBoYXZlIFF1YWxpdHkgT3duZXJzaGlwXG4gICAgICovXG4gICAgb25RdWFsaXR5Q29udHJvbE93bmVyc2hpcChtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ0RhdGFDaGFubmVsUmVjZWl2ZU1lc3NhZ2VUeXBlLlF1YWxpdHlDb250cm9sT3duZXJzaGlwJyk7XG4gICAgICAgIHRoaXMuaXNRdWFsaXR5Q29udHJvbGxlciA9IG5ldyBCb29sZWFuKHZpZXdbMV0pLnZhbHVlT2YoKTtcbiAgICAgICAgTG9nZ2VyLkluZm8oYFJlY2VpdmVkIHF1YWxpdHkgY29udHJvbGxlciBtZXNzYWdlLCB3aWxsIGNvbnRyb2wgcXVhbGl0eTogJHt0aGlzLmlzUXVhbGl0eUNvbnRyb2xsZXJ9YCk7XG4gICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuX29uUXVhbGl0eUNvbnRyb2xPd25lcnNoaXAodGhpcy5pc1F1YWxpdHlDb250cm9sbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIHRoZSBBZ2dyZWdhdGVkIHN0YXRzIGFyZSBDb2xsZWN0ZWRcbiAgICAgKiBAcGFyYW0gc3RhdHMgLSBBZ2dyZWdhdGVkIFN0YXRzXG4gICAgICovXG4gICAgaGFuZGxlVmlkZW9TdGF0cyhzdGF0cykge1xuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vblZpZGVvU3RhdHMoc3RhdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBSZXNpemUgdGhlIFZpZGVvIFBsYXllciBlbGVtZW50XG4gICAgICovXG4gICAgcmVzaXplUGxheWVyU3R5bGUoKSB7XG4gICAgICAgIHRoaXMudmlkZW9QbGF5ZXIucmVzaXplUGxheWVyU3R5bGUoKTtcbiAgICB9XG4gICAgc2V0UHJlZmVycmVkQ29kZWMoY29kZWMpIHtcbiAgICAgICAgdGhpcy5wcmVmZXJyZWRDb2RlYyA9IGNvZGVjO1xuICAgICAgICBpZiAodGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLnByZWZlcnJlZENvZGVjID0gY29kZWM7XG4gICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci51cGRhdGVDb2RlY1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFZpZGVvRW5jb2RlckF2Z1FQKGF2Z1FQKSB7XG4gICAgICAgIHRoaXMudmlkZW9BdmdRcCA9IGF2Z1FQO1xuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vblZpZGVvRW5jb2RlckF2Z1FQKHRoaXMudmlkZW9BdmdRcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGVuYWJsZXMvZGlzYWJsZXMga2V5Ym9hcmQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICovXG4gICAgc2V0S2V5Ym9hcmRJbnB1dEVuYWJsZWQoaXNFbmFibGVkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5rZXlib2FyZENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bnJlZ2lzdGVyKCk7XG4gICAgICAgIGlmIChpc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMua2V5Ym9hcmRDb250cm9sbGVyID0gdGhpcy5pbnB1dENsYXNzZXNGYWN0b3J5LnJlZ2lzdGVyS2V5Qm9hcmQodGhpcy5jb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGVuYWJsZXMvZGlzYWJsZXMgbW91c2UgZXZlbnQgbGlzdGVuZXJzXG4gICAgICovXG4gICAgc2V0TW91c2VJbnB1dEVuYWJsZWQoaXNFbmFibGVkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5tb3VzZUNvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bnJlZ2lzdGVyKCk7XG4gICAgICAgIGlmIChpc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlTW9kZSA9IHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuSG92ZXJpbmdNb3VzZU1vZGUpXG4gICAgICAgICAgICAgICAgPyBDb250cm9sU2NoZW1lVHlwZS5Ib3ZlcmluZ01vdXNlXG4gICAgICAgICAgICAgICAgOiBDb250cm9sU2NoZW1lVHlwZS5Mb2NrZWRNb3VzZTtcbiAgICAgICAgICAgIHRoaXMubW91c2VDb250cm9sbGVyID0gdGhpcy5pbnB1dENsYXNzZXNGYWN0b3J5LnJlZ2lzdGVyTW91c2UobW91c2VNb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBlbmFibGVzL2Rpc2FibGVzIHRvdWNoIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIHNldFRvdWNoSW5wdXRFbmFibGVkKGlzRW5hYmxlZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMudG91Y2hDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudW5yZWdpc3RlcigpO1xuICAgICAgICBpZiAoaXNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRvdWNoQ29udHJvbGxlciA9IHRoaXMuaW5wdXRDbGFzc2VzRmFjdG9yeS5yZWdpc3RlclRvdWNoKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuRmFrZU1vdXNlV2l0aFRvdWNoZXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBlbmFibGVzL2Rpc2FibGVzIGdhbWUgcGFkIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIHNldEdhbWVQYWRJbnB1dEVuYWJsZWQoaXNFbmFibGVkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5nYW1lUGFkQ29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVucmVnaXN0ZXIoKTtcbiAgICAgICAgaWYgKGlzRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5nYW1lUGFkQ29udHJvbGxlciA9IHRoaXMuaW5wdXRDbGFzc2VzRmFjdG9yeS5yZWdpc3RlckdhbWVQYWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3RlckRhdGFDaGFubmVsRXZlbnRFbWl0dGVycyhkYXRhQ2hhbm5lbCkge1xuICAgICAgICBkYXRhQ2hhbm5lbC5vbk9wZW4gPSAobGFiZWwsIGV2ZW50KSA9PiB0aGlzLnBpeGVsU3RyZWFtaW5nLmRpc3BhdGNoRXZlbnQobmV3IERhdGFDaGFubmVsT3BlbkV2ZW50KHsgbGFiZWwsIGV2ZW50IH0pKTtcbiAgICAgICAgZGF0YUNoYW5uZWwub25DbG9zZSA9IChsYWJlbCwgZXZlbnQpID0+IHRoaXMucGl4ZWxTdHJlYW1pbmcuZGlzcGF0Y2hFdmVudChuZXcgRGF0YUNoYW5uZWxDbG9zZUV2ZW50KHsgbGFiZWwsIGV2ZW50IH0pKTtcbiAgICAgICAgZGF0YUNoYW5uZWwub25FcnJvciA9IChsYWJlbCwgZXZlbnQpID0+IHRoaXMucGl4ZWxTdHJlYW1pbmcuZGlzcGF0Y2hFdmVudChuZXcgRGF0YUNoYW5uZWxFcnJvckV2ZW50KHsgbGFiZWwsIGV2ZW50IH0pKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihuYW1lLCBkaXJlY3Rpb24sIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIgJiYgdHlwZW9mIGhhbmRsZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBMb2dnZXIuV2FybmluZyhgVW5hYmxlIHRvIHJlZ2lzdGVyIGhhbmRsZXIgZm9yICR7bmFtZX0gYXMgbm8gaGFuZGxlciB3YXMgcGFzc2VkYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKGRpcmVjdGlvbiwgbmFtZSwgKGRhdGEpID0+IHR5cGVvZiBoYW5kbGVyID09PSAndW5kZWZpbmVkJyAmJiBkaXJlY3Rpb24gPT09IE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lclxuICAgICAgICAgICAgPyB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIobmFtZSwgZGF0YSlcbiAgICAgICAgICAgIDogaGFuZGxlcihkYXRhKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2ViUnRjUGxheWVyQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuaW1wb3J0IHsgWFJHYW1lcGFkQ29udHJvbGxlciB9IGZyb20gJy4uL0lucHV0cy9YUkdhbWVwYWRDb250cm9sbGVyJztcbmltcG9ydCB7IFhyRnJhbWVFdmVudCB9IGZyb20gJy4uL1V0aWwvRXZlbnRFbWl0dGVyJztcbmltcG9ydCB7IEZsYWdzIH0gZnJvbSAnLi4vQ29uZmlnL0NvbmZpZyc7XG5leHBvcnQgY2xhc3MgV2ViWFJDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih3ZWJSdGNQbGF5ZXJDb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMueHJWaWV3ZXJQb3NlID0gbnVsbDtcbiAgICAgICAgLy8gVXNlZCBmb3IgY29tcGFyaXNvbnMgdG8gZW5zdXJlIHR3byBudW1iZXJzIGFyZSBjbG9zZSBlbm91Z2guXG4gICAgICAgIHRoaXMuRVBTSUxPTiA9IDAuMDAwMDAwMTtcbiAgICAgICAgdGhpcy52aWRlb1RleHR1cmUgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXZWaWRlb1dpZHRoID0gMDtcbiAgICAgICAgdGhpcy5wcmV2VmlkZW9IZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLmxlZnRWaWV3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yaWdodFZpZXcgPSBudWxsO1xuICAgICAgICAvLyBTdG9yZSB0aGUgSE1EIGRhdGEgd2UgaGF2ZSBsYXN0IHNlbnQgKG5vdCBhbGwgb2YgaXQgaXMgbmVlZGVkIGV2ZXJ5IGZyYW1lIHVubGVzcyBpdCBjaGFuZ2VzKVxuICAgICAgICB0aGlzLmxhc3RTZW50TGVmdEV5ZVByb2ogPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RTZW50UmlnaHRFeWVQcm9qID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VudFJlbGF0aXZlTGVmdEV5ZVBvcyA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFNlbnRSZWxhdGl2ZVJpZ2h0RXllUG9zID0gbnVsbDtcbiAgICAgICAgdGhpcy54clNlc3Npb24gPSBudWxsO1xuICAgICAgICB0aGlzLndlYlJ0Y0NvbnRyb2xsZXIgPSB3ZWJSdGNQbGF5ZXJDb250cm9sbGVyO1xuICAgICAgICB0aGlzLnhyR2FtZXBhZENvbnRyb2xsZXIgPSBuZXcgWFJHYW1lcGFkQ29udHJvbGxlcih0aGlzLndlYlJ0Y0NvbnRyb2xsZXIuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLm9uU2Vzc2lvbkVuZGVkID0gbmV3IEV2ZW50VGFyZ2V0KCk7XG4gICAgICAgIHRoaXMub25TZXNzaW9uU3RhcnRlZCA9IG5ldyBFdmVudFRhcmdldCgpO1xuICAgICAgICB0aGlzLm9uRnJhbWUgPSBuZXcgRXZlbnRUYXJnZXQoKTtcbiAgICB9XG4gICAgeHJDbGlja2VkKCkge1xuICAgICAgICBpZiAoIXRoaXMueHJTZXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAoIW5hdmlnYXRvci54cikge1xuICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgWFIuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmF2aWdhdG9yLnhyXG4gICAgICAgICAgICAgICAgLyogUmVxdWVzdCBpbW1lcnNpdmUtdnIgc2Vzc2lvbiB3aXRob3V0IGFueSBvcHRpb25hbCBmZWF0dXJlcy4gKi9cbiAgICAgICAgICAgICAgICAucmVxdWVzdFNlc3Npb24oJ2ltbWVyc2l2ZS12cicsIHsgb3B0aW9uYWxGZWF0dXJlczogW10gfSlcbiAgICAgICAgICAgICAgICAudGhlbigoc2Vzc2lvbikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25YclNlc3Npb25TdGFydGVkKHNlc3Npb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnhyU2Vzc2lvbi5lbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblhyU2Vzc2lvbkVuZGVkKCkge1xuICAgICAgICBMb2dnZXIuSW5mbygnWFIgU2Vzc2lvbiBlbmRlZCcpO1xuICAgICAgICB0aGlzLnhyU2Vzc2lvbiA9IG51bGw7XG4gICAgICAgIHRoaXMub25TZXNzaW9uRW5kZWQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3hyU2Vzc2lvbkVuZGVkJykpO1xuICAgIH1cbiAgICBpbml0R0woKSB7XG4gICAgICAgIGlmICh0aGlzLmdsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRoaXMuZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywge1xuICAgICAgICAgICAgeHJDb21wYXRpYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgb3VyIGNsZWFyIGNvbG9yXG4gICAgICAgIHRoaXMuZ2wuY2xlYXJDb2xvcigwLjAsIDAuMCwgMC4wLCAxKTtcbiAgICB9XG4gICAgaW5pdFNoYWRlcnMoKSB7XG4gICAgICAgIC8vIHNoYWRlciBzb3VyY2UgY29kZVxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XG5cbiAgICAgICAgLy8gdmFyeWluZ3NcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XG5cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYV9wb3NpdGlvbi54LCBhX3Bvc2l0aW9uLnksIDAsIDEpO1xuICAgICAgICAgICAvLyBwYXNzIHRoZSB0ZXhDb29yZCB0byB0aGUgZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgICAgIC8vIFRoZSBHUFUgd2lsbCBpbnRlcnBvbGF0ZSB0aGlzIHZhbHVlIGJldHdlZW4gcG9pbnRzLlxuICAgICAgICAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgICBjb25zdCBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cbiAgICAgICAgLy8gb3VyIHRleHR1cmVcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcblxuICAgICAgICAvLyB0aGUgdGV4Q29vcmRzIHBhc3NlZCBpbiBmcm9tIHRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgICAgICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcblxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgICAvLyBzZXR1cCB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHRoaXMuZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgICAgIHRoaXMuZ2wuc2hhZGVyU291cmNlKHZlcnRleFNoYWRlciwgdmVydGV4U2hhZGVyU291cmNlKTtcbiAgICAgICAgdGhpcy5nbC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gICAgICAgIC8vIHNldHVwIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHRoaXMuZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICAgICAgdGhpcy5nbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcbiAgICAgICAgdGhpcy5nbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICAgICAgLy8gc2V0dXAgR0xTTCBwcm9ncmFtXG4gICAgICAgIGNvbnN0IHNoYWRlclByb2dyYW0gPSB0aGlzLmdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIoc2hhZGVyUHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICAgICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIoc2hhZGVyUHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHNoYWRlclByb2dyYW0pO1xuICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0oc2hhZGVyUHJvZ3JhbSk7XG4gICAgICAgIC8vIGxvb2sgdXAgd2hlcmUgdmVydGV4IGRhdGEgbmVlZHMgdG8gZ29cbiAgICAgICAgdGhpcy5wb3NpdGlvbkxvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbihzaGFkZXJQcm9ncmFtLCAnYV9wb3NpdGlvbicpO1xuICAgICAgICB0aGlzLnRleGNvb3JkTG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHNoYWRlclByb2dyYW0sICdhX3RleENvb3JkJyk7XG4gICAgfVxuICAgIHVwZGF0ZVZpZGVvVGV4dHVyZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvVGV4dHVyZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIG91ciB0ZXh0dXJlIHRoYXQgd2UgdXNlIGluIG91ciBzaGFkZXJcbiAgICAgICAgICAgIC8vIGFuZCBiaW5kIGl0IG9uY2UgYmVjYXVzZSB3ZSBuZXZlciB1c2UgYW55IG90aGVyIHRleHR1cmUuXG4gICAgICAgICAgICB0aGlzLnZpZGVvVGV4dHVyZSA9IHRoaXMuZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMudmlkZW9UZXh0dXJlKTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgcGFyYW1ldGVycyBzbyB3ZSBjYW4gcmVuZGVyIGFueSBzaXplIGltYWdlLlxuICAgICAgICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfUywgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5nbC5MSU5FQVIpO1xuICAgICAgICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMuZ2wuTElORUFSKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aWRlb0hlaWdodCA9IHRoaXMud2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci5nZXRWaWRlb0VsZW1lbnQoKS52aWRlb0hlaWdodDtcbiAgICAgICAgY29uc3QgdmlkZW9XaWR0aCA9IHRoaXMud2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci5nZXRWaWRlb0VsZW1lbnQoKS52aWRlb1dpZHRoO1xuICAgICAgICBpZiAodGhpcy5wcmV2VmlkZW9IZWlnaHQgIT0gdmlkZW9IZWlnaHQgfHwgdGhpcy5wcmV2VmlkZW9XaWR0aCAhPSB2aWRlb1dpZHRoKSB7XG4gICAgICAgICAgICAvLyBEbyBmdWxsIHVwZGF0ZSBvZiB0ZXh0dXJlIGlmIGRpbWVuc2lvbnMgZG8gbm90IG1hdGNoXG4gICAgICAgICAgICB0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFXzJELCAwLCB0aGlzLmdsLlJHQkEsIHZpZGVvV2lkdGgsIHZpZGVvSGVpZ2h0LCAwLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgdGhpcy53ZWJSdGNDb250cm9sbGVyLnZpZGVvUGxheWVyLmdldFZpZGVvRWxlbWVudCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGRpbWVuc2lvbnMgbWF0Y2gganVzdCB1cGRhdGUgdGhlIHN1YiByZWdpb25cbiAgICAgICAgICAgIHRoaXMuZ2wudGV4U3ViSW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHZpZGVvV2lkdGgsIHZpZGVvSGVpZ2h0LCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgdGhpcy53ZWJSdGNDb250cm9sbGVyLnZpZGVvUGxheWVyLmdldFZpZGVvRWxlbWVudCgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgcHJldiB2aWRlbyB3aWR0aC9oZWlnaHRcbiAgICAgICAgdGhpcy5wcmV2VmlkZW9IZWlnaHQgPSB2aWRlb0hlaWdodDtcbiAgICAgICAgdGhpcy5wcmV2VmlkZW9XaWR0aCA9IHZpZGVvV2lkdGg7XG4gICAgfVxuICAgIGluaXRCdWZmZXJzKCkge1xuICAgICAgICAvLyBDcmVhdGUgb3V0IHBvc2l0aW9uIGJ1ZmZlciBhbmQgaXRzIHZlcnRleCBzaGFkZXIgYXR0cmlidXRlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGJ1ZmZlciB0byBwdXQgdGhlIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgcGxhbmUgd2Ugd2lsbCBkcmF3IHRoZSB2aWRlbyBzdHJlYW0gb250b1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICAvLyBCaW5kIHRoZSBwb3NpdGlvbiBidWZmZXJcbiAgICAgICAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy5wb3NpdGlvbkJ1ZmZlcik7XG4gICAgICAgICAgICAvLyBFbmFibGUgYHBvc2l0aW9uTG9jYXRpb25gIHRvIGJlIHVzZWQgYXMgdmVydGV4IHNoYWRlciBhdHRyaWJ1dGVcbiAgICAgICAgICAgIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5wb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IHBvc2l0aW9ucyBhcmUgcGFzc2VkIGluIGNsaXAtc3BhY2UgY29vcmRpbmF0ZXMgWy0xLi4xXSBzbyBubyBuZWVkIHRvIGNvbnZlcnQgaW4tc2hhZGVyXG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgICAgICAgICAgLTEuMCwgMS4wLFxuICAgICAgICAgICAgICAgIDEuMCwgMS4wLFxuICAgICAgICAgICAgICAgIC0xLjAsIC0xLjAsXG4gICAgICAgICAgICAgICAgLTEuMCwgLTEuMCxcbiAgICAgICAgICAgICAgICAxLjAsIDEuMCxcbiAgICAgICAgICAgICAgICAxLjAsIC0xLjBcbiAgICAgICAgICAgIF0pLCB0aGlzLmdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgICAgIC8vIFRlbGwgcG9zaXRpb24gYXR0cmlidXRlIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyIGhvdyB0byBnZXQgZGF0YSBvdXQgb2YgdGhlIGJvdW5kIGJ1ZmZlciAodGhlIHBvc2l0aW9uQnVmZmVyKVxuICAgICAgICAgICAgdGhpcy5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMucG9zaXRpb25Mb2NhdGlvbiwgMiAvKnNpemUqLywgdGhpcy5nbC5GTE9BVCAvKnR5cGUqLywgZmFsc2UgLypub3JtYWxpemUqLywgMCAvKnN0cmlkZSovLCAwIC8qb2Zmc2V0Ki8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBvdXIgdGV4dHVyZSBjb29yZGluYXRlIGJ1ZmZlcnMgZm9yIGFjY2Vzc2luZyBvdXIgdGV4dHVyZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnRleGNvb3JkQnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICAgIC8vIEJpbmQgdGhlIHRleHR1cmUgY29vcmRpbmF0ZSBidWZmZXJcbiAgICAgICAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy50ZXhjb29yZEJ1ZmZlcik7XG4gICAgICAgICAgICAvLyBFbmFibGUgYHRleGNvb3JkTG9jYXRpb25gIHRvIGJlIHVzZWQgYXMgYSB2ZXJ0ZXggc2hhZGVyIGF0dHJpYnV0ZVxuICAgICAgICAgICAgdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLnRleGNvb3JkTG9jYXRpb24pO1xuICAgICAgICAgICAgLy8gVGhlIHRleHR1cmUgY29vcmRpbmF0ZXMgdG8gYXBwbHkgZm9yIHJlY3RhbmdsZSB3ZSBhcmUgZHJhd2luZ1xuICAgICAgICAgICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFswLjAsIDAuMCwgMS4wLCAwLjAsIDAuMCwgMS4wLCAwLjAsIDEuMCwgMS4wLCAwLjAsIDEuMCwgMS4wXSksIHRoaXMuZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICAgICAgLy8gVGVsbCB0ZXh0dXJlIGNvb3JkaW5hdGUgYXR0cmlidXRlIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyIGhvdyB0byBnZXQgZGF0YSBvdXQgb2YgdGhlIGJvdW5kIGJ1ZmZlciAodGhlIHRleGNvb3JkQnVmZmVyKVxuICAgICAgICAgICAgdGhpcy5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMudGV4Y29vcmRMb2NhdGlvbiwgMiAvKnNpemUqLywgdGhpcy5nbC5GTE9BVCAvKnR5cGUqLywgZmFsc2UgLypub3JtYWxpemUqLywgMCAvKnN0cmlkZSovLCAwIC8qb2Zmc2V0Ki8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uWHJTZXNzaW9uU3RhcnRlZChzZXNzaW9uKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCdYUiBTZXNzaW9uIHN0YXJ0ZWQnKTtcbiAgICAgICAgdGhpcy54clNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICB0aGlzLnhyU2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uWHJTZXNzaW9uRW5kZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEluaXRpYWxpemF0aW9uXG4gICAgICAgIHRoaXMuaW5pdEdMKCk7XG4gICAgICAgIHRoaXMuaW5pdFNoYWRlcnMoKTtcbiAgICAgICAgdGhpcy5pbml0QnVmZmVycygpO1xuICAgICAgICBzZXNzaW9uLnJlcXVlc3RSZWZlcmVuY2VTcGFjZSgnbG9jYWwnKS50aGVuKChyZWZTcGFjZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy54clJlZlNwYWNlID0gcmVmU3BhY2U7XG4gICAgICAgICAgICAvLyBTZXQgdXAgb3VyIGJhc2UgbGF5ZXIgKGkuZS4gYSBwcm9qZWN0aW9uIGxheWVyIHRoYXQgZmlsbHMgdGhlIGVudGlyZSBYUiB2aWV3cG9ydCkuXG4gICAgICAgICAgICB0aGlzLnhyU2Vzc2lvbi51cGRhdGVSZW5kZXJTdGF0ZSh7XG4gICAgICAgICAgICAgICAgYmFzZUxheWVyOiBuZXcgWFJXZWJHTExheWVyKHRoaXMueHJTZXNzaW9uLCB0aGlzLmdsKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGFyZ2V0IGZyYW1lcmF0ZSB0byA5MCBmcHMgaWYgOTAgZnBzIGlzIHN1cHBvcnRlZCBpbiB0aGlzIFhSIGRldmljZVxuICAgICAgICAgICAgaWYgKHRoaXMueHJTZXNzaW9uLnN1cHBvcnRlZEZyYW1lUmF0ZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZyYW1lUmF0ZSBvZiB0aGlzLnhyU2Vzc2lvbi5zdXBwb3J0ZWRGcmFtZVJhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZVJhdGUgPT0gOTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24udXBkYXRlVGFyZ2V0RnJhbWVSYXRlKDkwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJpbmRpbmcgdG8gZWFjaCBuZXcgZnJhbWUgdG8gZ2V0IGxhdGVzdCBYUiB1cGRhdGVzXG4gICAgICAgICAgICB0aGlzLnhyU2Vzc2lvbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5vblhyRnJhbWUuYmluZCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uU2Vzc2lvblN0YXJ0ZWQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3hyU2Vzc2lvblN0YXJ0ZWQnKSk7XG4gICAgfVxuICAgIGFyZUFycmF5c0VxdWFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoZWxlbWVudCwgaW5kZXgpID0+IE1hdGguYWJzKGVsZW1lbnQgLSBiW2luZGV4XSkgPD0gdGhpcy5FUFNJTE9OKSk7XG4gICAgfVxuICAgIGFyZVBvaW50c0VxdWFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLmFicyhhLnggLSBiLngpID49IHRoaXMuRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYS55IC0gYi55KSA+PSB0aGlzLkVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEueiAtIGIueikgPj0gdGhpcy5FUFNJTE9OKTtcbiAgICB9XG4gICAgc2VuZFhSRGF0YVRvVUUoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlZnRWaWV3ID09IG51bGwgfHwgdGhpcy5yaWdodFZpZXcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHNlbGVjdGl2ZWx5IHNlbmQgZWl0aGVyIHRoZSBgWFJFeWVWaWV3c2Agb3IgYFhSSE1EVHJhbnNmb3JtYFxuICAgICAgICAvLyBtZXNzYWdlcyBvdmVyIHRoZSBkYXRhY2hhbm5lbC4gVGhlIHJlYXNvbiBmb3IgdGhpcyBzZWxlY3RpdmUgc2VuZGluZyBpcyB0aGF0XG4gICAgICAgIC8vIHRoZSBgWFJFeWVWaWV3c2AgaXMgYSBtdWNoIGxhcmdlciBtZXNzYWdlIGFuZCBjaGFuZ2VzIGluZnJlcXVlbnRseSAoZS5nLiBvbmx5IHdoZW4gdXNlciBjaGFuZ2VzIGhlYWRzZXQgSVBEKS5cbiAgICAgICAgLy8gVGhlcmVmb3JlLCB3ZSBvbmx5IG5lZWQgdG8gc2VuZCBpdCBvbmNlIG9uIHN0YXJ0dXAgYW5kIHRoZW4gYW55IHRpbWUgaXQgY2hhbmdlcy5cbiAgICAgICAgLy8gVGhlIHJlc3Qgb2YgdGhlIHRpbWUgd2UgY2FuIHNlbmQgdGhlIGBYUkhNRFRyYW5zZm9ybWAgbWVzc2FnZS5cbiAgICAgICAgbGV0IHNob3VsZFNlbmRFeWVWaWV3cyA9IHRoaXMubGFzdFNlbnRMZWZ0RXllUHJvaiA9PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLmxhc3RTZW50UmlnaHRFeWVQcm9qID09IG51bGwgfHxcbiAgICAgICAgICAgIHRoaXMubGFzdFNlbnRSZWxhdGl2ZUxlZnRFeWVQb3MgPT0gbnVsbCB8fFxuICAgICAgICAgICAgdGhpcy5sYXN0U2VudFJlbGF0aXZlUmlnaHRFeWVQb3MgPT0gbnVsbDtcbiAgICAgICAgY29uc3QgbGVmdEV5ZVRyYW5zID0gdGhpcy5sZWZ0Vmlldy50cmFuc2Zvcm0ubWF0cml4O1xuICAgICAgICBjb25zdCBsZWZ0RXllUHJvaiA9IHRoaXMubGVmdFZpZXcucHJvamVjdGlvbk1hdHJpeDtcbiAgICAgICAgY29uc3QgcmlnaHRFeWVUcmFucyA9IHRoaXMucmlnaHRWaWV3LnRyYW5zZm9ybS5tYXRyaXg7XG4gICAgICAgIGNvbnN0IHJpZ2h0RXllUHJvaiA9IHRoaXMucmlnaHRWaWV3LnByb2plY3Rpb25NYXRyaXg7XG4gICAgICAgIGNvbnN0IGhtZFRyYW5zID0gdGhpcy54clZpZXdlclBvc2UudHJhbnNmb3JtLm1hdHJpeDtcbiAgICAgICAgLy8gQ2hlY2sgaWYgcHJvamVjdGlvbiBtYXRyaWNlcyBoYXZlIGNoYW5nZWRcbiAgICAgICAgaWYgKCFzaG91bGRTZW5kRXllVmlld3MgJiYgdGhpcy5sYXN0U2VudExlZnRFeWVQcm9qICE9IG51bGwgJiYgdGhpcy5sYXN0U2VudFJpZ2h0RXllUHJvaiAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0RXllUHJvalVuY2hhbmdlZCA9IHRoaXMuYXJlQXJyYXlzRXF1YWwobGVmdEV5ZVByb2osIHRoaXMubGFzdFNlbnRMZWZ0RXllUHJvaik7XG4gICAgICAgICAgICBjb25zdCByaWdodEV5ZVByb2pVbmNoYW5nZWQgPSB0aGlzLmFyZUFycmF5c0VxdWFsKHJpZ2h0RXllUHJvaiwgdGhpcy5sYXN0U2VudFJpZ2h0RXllUHJvaik7XG4gICAgICAgICAgICBzaG91bGRTZW5kRXllVmlld3MgPSBsZWZ0RXllUHJvalVuY2hhbmdlZCA9PSBmYWxzZSB8fCByaWdodEV5ZVByb2pVbmNoYW5nZWQgPT0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVmdEV5ZVJlbGF0aXZlUG9zID0gbmV3IERPTVBvaW50UmVhZE9ubHkodGhpcy5sZWZ0Vmlldy50cmFuc2Zvcm0ucG9zaXRpb24ueCAtIHRoaXMueHJWaWV3ZXJQb3NlLnRyYW5zZm9ybS5wb3NpdGlvbi54LCB0aGlzLmxlZnRWaWV3LnRyYW5zZm9ybS5wb3NpdGlvbi55IC0gdGhpcy54clZpZXdlclBvc2UudHJhbnNmb3JtLnBvc2l0aW9uLnksIHRoaXMubGVmdFZpZXcudHJhbnNmb3JtLnBvc2l0aW9uLnogLSB0aGlzLnhyVmlld2VyUG9zZS50cmFuc2Zvcm0ucG9zaXRpb24ueiwgMS4wKTtcbiAgICAgICAgY29uc3QgcmlnaHRFeWVSZWxhdGl2ZVBvcyA9IG5ldyBET01Qb2ludFJlYWRPbmx5KHRoaXMubGVmdFZpZXcudHJhbnNmb3JtLnBvc2l0aW9uLnggLSB0aGlzLnhyVmlld2VyUG9zZS50cmFuc2Zvcm0ucG9zaXRpb24ueCwgdGhpcy5sZWZ0Vmlldy50cmFuc2Zvcm0ucG9zaXRpb24ueSAtIHRoaXMueHJWaWV3ZXJQb3NlLnRyYW5zZm9ybS5wb3NpdGlvbi55LCB0aGlzLmxlZnRWaWV3LnRyYW5zZm9ybS5wb3NpdGlvbi56IC0gdGhpcy54clZpZXdlclBvc2UudHJhbnNmb3JtLnBvc2l0aW9uLnosIDEuMCk7XG4gICAgICAgIC8vIENoZWNrIGlmIHJlbGF0aXZlIGV5ZSBwb3MgaGFzIGNoYW5nZWQgKGUuZyBJUEQgY2hhbmdlZClcbiAgICAgICAgaWYgKCFzaG91bGRTZW5kRXllVmlld3MgJiZcbiAgICAgICAgICAgIHRoaXMubGFzdFNlbnRSZWxhdGl2ZUxlZnRFeWVQb3MgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdGhpcy5sYXN0U2VudFJlbGF0aXZlUmlnaHRFeWVQb3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbGVmdEV5ZVBvc1VuY2hhbmdlZCA9IHRoaXMuYXJlUG9pbnRzRXF1YWwobGVmdEV5ZVJlbGF0aXZlUG9zLCB0aGlzLmxhc3RTZW50UmVsYXRpdmVMZWZ0RXllUG9zKTtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0RXllUG9zVW5jaGFuZ2VkID0gdGhpcy5hcmVQb2ludHNFcXVhbChyaWdodEV5ZVJlbGF0aXZlUG9zLCB0aGlzLmxhc3RTZW50UmVsYXRpdmVSaWdodEV5ZVBvcyk7XG4gICAgICAgICAgICBzaG91bGRTZW5kRXllVmlld3MgPSBsZWZ0RXllUG9zVW5jaGFuZ2VkID09IGZhbHNlIHx8IHJpZ2h0RXllUG9zVW5jaGFuZ2VkID09IGZhbHNlO1xuICAgICAgICAgICAgLy8gTm90ZTogV2UgYXJlIG5vdCBjaGVja2luZyBpZiBFeWVWaWV3IHJvdGF0aW9uIGNoYW5nZXMgKGFzIGZhciBhcyBJIGtub3cgbm8gSE1EIHN1cHBvcnRzIGNoYW5naW5nIHRoaXMgdmFsdWUgYXQgcnVudGltZSkuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFNlbmRFeWVWaWV3cykge1xuICAgICAgICAgICAgLy8gc2VuZCB0cmFuc2Zvcm0gKDR4NCkgYW5kIHByb2plY3Rpb24gbWF0cml4ICg0eDQpIGRhdGEgZm9yIGVhY2ggZXllIChsZWZ0IGZpcnN0LCB0aGVuIHJpZ2h0KVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICB0aGlzLndlYlJ0Y0NvbnRyb2xsZXIuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnWFJFeWVWaWV3cycpKFtcbiAgICAgICAgICAgICAgICAvLyBMZWZ0IGV5ZSA0eDQgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAgICAgICAgICAgIGxlZnRFeWVUcmFuc1swXSwgbGVmdEV5ZVRyYW5zWzRdLCBsZWZ0RXllVHJhbnNbOF0sIGxlZnRFeWVUcmFuc1sxMl0sXG4gICAgICAgICAgICAgICAgbGVmdEV5ZVRyYW5zWzFdLCBsZWZ0RXllVHJhbnNbNV0sIGxlZnRFeWVUcmFuc1s5XSwgbGVmdEV5ZVRyYW5zWzEzXSxcbiAgICAgICAgICAgICAgICBsZWZ0RXllVHJhbnNbMl0sIGxlZnRFeWVUcmFuc1s2XSwgbGVmdEV5ZVRyYW5zWzEwXSwgbGVmdEV5ZVRyYW5zWzE0XSxcbiAgICAgICAgICAgICAgICBsZWZ0RXllVHJhbnNbM10sIGxlZnRFeWVUcmFuc1s3XSwgbGVmdEV5ZVRyYW5zWzExXSwgbGVmdEV5ZVRyYW5zWzE1XSxcbiAgICAgICAgICAgICAgICAvLyBMZWZ0IGV5ZSA0eDQgcHJvamVjdGlvbiBtYXRyaXhcbiAgICAgICAgICAgICAgICBsZWZ0RXllUHJvalswXSwgbGVmdEV5ZVByb2pbNF0sIGxlZnRFeWVQcm9qWzhdLCBsZWZ0RXllUHJvalsxMl0sXG4gICAgICAgICAgICAgICAgbGVmdEV5ZVByb2pbMV0sIGxlZnRFeWVQcm9qWzVdLCBsZWZ0RXllUHJvals5XSwgbGVmdEV5ZVByb2pbMTNdLFxuICAgICAgICAgICAgICAgIGxlZnRFeWVQcm9qWzJdLCBsZWZ0RXllUHJvals2XSwgbGVmdEV5ZVByb2pbMTBdLCBsZWZ0RXllUHJvalsxNF0sXG4gICAgICAgICAgICAgICAgbGVmdEV5ZVByb2pbM10sIGxlZnRFeWVQcm9qWzddLCBsZWZ0RXllUHJvalsxMV0sIGxlZnRFeWVQcm9qWzE1XSxcbiAgICAgICAgICAgICAgICAvLyBSaWdodCBleWUgNHg0IHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgICAgICAgICAgICByaWdodEV5ZVRyYW5zWzBdLCByaWdodEV5ZVRyYW5zWzRdLCByaWdodEV5ZVRyYW5zWzhdLCByaWdodEV5ZVRyYW5zWzEyXSxcbiAgICAgICAgICAgICAgICByaWdodEV5ZVRyYW5zWzFdLCByaWdodEV5ZVRyYW5zWzVdLCByaWdodEV5ZVRyYW5zWzldLCByaWdodEV5ZVRyYW5zWzEzXSxcbiAgICAgICAgICAgICAgICByaWdodEV5ZVRyYW5zWzJdLCByaWdodEV5ZVRyYW5zWzZdLCByaWdodEV5ZVRyYW5zWzEwXSwgcmlnaHRFeWVUcmFuc1sxNF0sXG4gICAgICAgICAgICAgICAgcmlnaHRFeWVUcmFuc1szXSwgcmlnaHRFeWVUcmFuc1s3XSwgcmlnaHRFeWVUcmFuc1sxMV0sIHJpZ2h0RXllVHJhbnNbMTVdLFxuICAgICAgICAgICAgICAgIC8vIHJpZ2h0IGV5ZSA0eDQgcHJvamVjdGlvbiBtYXRyaXhcbiAgICAgICAgICAgICAgICByaWdodEV5ZVByb2pbMF0sIHJpZ2h0RXllUHJvals0XSwgcmlnaHRFeWVQcm9qWzhdLCByaWdodEV5ZVByb2pbMTJdLFxuICAgICAgICAgICAgICAgIHJpZ2h0RXllUHJvalsxXSwgcmlnaHRFeWVQcm9qWzVdLCByaWdodEV5ZVByb2pbOV0sIHJpZ2h0RXllUHJvalsxM10sXG4gICAgICAgICAgICAgICAgcmlnaHRFeWVQcm9qWzJdLCByaWdodEV5ZVByb2pbNl0sIHJpZ2h0RXllUHJvalsxMF0sIHJpZ2h0RXllUHJvalsxNF0sXG4gICAgICAgICAgICAgICAgcmlnaHRFeWVQcm9qWzNdLCByaWdodEV5ZVByb2pbN10sIHJpZ2h0RXllUHJvalsxMV0sIHJpZ2h0RXllUHJvalsxNV0sXG4gICAgICAgICAgICAgICAgLy8gSE1EIDR4NCB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICBobWRUcmFuc1swXSwgaG1kVHJhbnNbNF0sIGhtZFRyYW5zWzhdLCBobWRUcmFuc1sxMl0sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbMV0sIGhtZFRyYW5zWzVdLCBobWRUcmFuc1s5XSwgaG1kVHJhbnNbMTNdLFxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzJdLCBobWRUcmFuc1s2XSwgaG1kVHJhbnNbMTBdLCBobWRUcmFuc1sxNF0sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbM10sIGhtZFRyYW5zWzddLCBobWRUcmFuc1sxMV0sIGhtZFRyYW5zWzE1XSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdGhpcy5sYXN0U2VudExlZnRFeWVQcm9qID0gbGVmdEV5ZVByb2o7XG4gICAgICAgICAgICB0aGlzLmxhc3RTZW50UmlnaHRFeWVQcm9qID0gcmlnaHRFeWVQcm9qO1xuICAgICAgICAgICAgdGhpcy5sYXN0U2VudFJlbGF0aXZlTGVmdEV5ZVBvcyA9IGxlZnRFeWVSZWxhdGl2ZVBvcztcbiAgICAgICAgICAgIHRoaXMubGFzdFNlbnRSZWxhdGl2ZVJpZ2h0RXllUG9zID0gcmlnaHRFeWVSZWxhdGl2ZVBvcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IG5lZWQgdG8gdGhlIGVudGlyZSBleWUgdmlld3MgYmVpbmcgc2VudCBqdXN0IHNlbmQgdGhlIEhNRCB0cmFuc2Zvcm1cbiAgICAgICAgICAgIHRoaXMud2ViUnRjQ29udHJvbGxlci5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdYUkhNRFRyYW5zZm9ybScpKFtcbiAgICAgICAgICAgICAgICAvLyBITUQgNHg0IHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzBdLFxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzRdLFxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzhdLFxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzEyXSxcbiAgICAgICAgICAgICAgICBobWRUcmFuc1sxXSxcbiAgICAgICAgICAgICAgICBobWRUcmFuc1s1XSxcbiAgICAgICAgICAgICAgICBobWRUcmFuc1s5XSxcbiAgICAgICAgICAgICAgICBobWRUcmFuc1sxM10sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbMl0sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbNl0sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbMTBdLFxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzE0XSxcbiAgICAgICAgICAgICAgICBobWRUcmFuc1szXSxcbiAgICAgICAgICAgICAgICBobWRUcmFuc1s3XSxcbiAgICAgICAgICAgICAgICBobWRUcmFuc1sxMV0sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbMTVdXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblhyRnJhbWUodGltZSwgZnJhbWUpIHtcbiAgICAgICAgdGhpcy54clZpZXdlclBvc2UgPSBmcmFtZS5nZXRWaWV3ZXJQb3NlKHRoaXMueHJSZWZTcGFjZSk7XG4gICAgICAgIGlmICh0aGlzLnhyVmlld2VyUG9zZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cygpO1xuICAgICAgICAgICAgaWYgKHRoaXMubGVmdFZpZXcgPT0gbnVsbCB8fCB0aGlzLnJpZ2h0VmlldyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZW5kWFJEYXRhVG9VRSgpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWRlb1RleHR1cmUoKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2ViUnRjQ29udHJvbGxlci5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5YUkNvbnRyb2xsZXJJbnB1dCkpIHtcbiAgICAgICAgICAgIHRoaXMueHJTZXNzaW9uLmlucHV0U291cmNlcy5mb3JFYWNoKChzb3VyY2UsIF9pbmRleCwgX2FycmF5KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy54ckdhbWVwYWRDb250cm9sbGVyLnVwZGF0ZVN0YXR1cyhzb3VyY2UsIGZyYW1lLCB0aGlzLnhyUmVmU3BhY2UpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54clNlc3Npb24ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0aW1lLCBmcmFtZSkgPT4gdGhpcy5vblhyRnJhbWUodGltZSwgZnJhbWUpKTtcbiAgICAgICAgdGhpcy5vbkZyYW1lLmRpc3BhdGNoRXZlbnQobmV3IFhyRnJhbWVFdmVudCh7IHRpbWUsIGZyYW1lIH0pKTtcbiAgICB9XG4gICAgdXBkYXRlVmlld3MoKSB7XG4gICAgICAgIGlmICghdGhpcy54clZpZXdlclBvc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHZpZXcgb2YgdGhpcy54clZpZXdlclBvc2Uudmlld3MpIHtcbiAgICAgICAgICAgIGlmICh2aWV3LmV5ZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0VmlldyA9IHZpZXc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2aWV3LmV5ZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMucmlnaHRWaWV3ID0gdmlldztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5nbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJpbmQgdGhlIGZyYW1lYnVmZmVyIHRvIHRoZSBiYXNlIGxheWVyJ3MgZnJhbWVidWZmZXJcbiAgICAgICAgY29uc3QgZ2xMYXllciA9IHRoaXMueHJTZXNzaW9uLnJlbmRlclN0YXRlLmJhc2VMYXllcjtcbiAgICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgZ2xMYXllci5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIC8vIFNldCB0aGUgcmVsZXZhbnQgcG9ydGlvbiBvZiBjbGlwIHNwYWNlXG4gICAgICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgZ2xMYXllci5mcmFtZWJ1ZmZlcldpZHRoLCBnbExheWVyLmZyYW1lYnVmZmVySGVpZ2h0KTtcbiAgICAgICAgLy8gRHJhdyB0aGUgcmVjdGFuZ2xlIHdlIHdpbGwgc2hvdyB0aGUgdmlkZW8gc3RyZWFtIHRleHR1cmUgb25cbiAgICAgICAgdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZ2wuVFJJQU5HTEVTIC8qcHJpbWl0aXZlVHlwZSovLCAwIC8qb2Zmc2V0Ki8sIDYgLypjb3VudCovKTtcbiAgICB9XG4gICAgc3RhdGljIGlzU2Vzc2lvblN1cHBvcnRlZChtb2RlKSB7XG4gICAgICAgIGlmIChsb2NhdGlvbi5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdXZWJYUiByZXF1aXJlcyBodHRwcywgaWYgeW91IHdhbnQgV2ViWFIgdXNlIGh0dHBzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYXZpZ2F0b3IueHIpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IueHIuaXNTZXNzaW9uU3VwcG9ydGVkKG1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdlYlhSQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgRmxhZ3MsIExvZ2dlciwgT3B0aW9uUGFyYW1ldGVycyB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nZnJvbnRlbmQtdWU1LjYnO1xuaW1wb3J0IHsgQ29ubmVjdE92ZXJsYXkgfSBmcm9tICcuLi9PdmVybGF5L0Nvbm5lY3RPdmVybGF5JztcbmltcG9ydCB7IERpc2Nvbm5lY3RPdmVybGF5IH0gZnJvbSAnLi4vT3ZlcmxheS9EaXNjb25uZWN0T3ZlcmxheSc7XG5pbXBvcnQgeyBQbGF5T3ZlcmxheSB9IGZyb20gJy4uL092ZXJsYXkvUGxheU92ZXJsYXknO1xuaW1wb3J0IHsgSW5mb092ZXJsYXkgfSBmcm9tICcuLi9PdmVybGF5L0luZm9PdmVybGF5JztcbmltcG9ydCB7IEVycm9yT3ZlcmxheSB9IGZyb20gJy4uL092ZXJsYXkvRXJyb3JPdmVybGF5JztcbmltcG9ydCB7IEFGS092ZXJsYXkgfSBmcm9tICcuLi9PdmVybGF5L0FGS092ZXJsYXknO1xuaW1wb3J0IHsgQ29udHJvbHMgfSBmcm9tICcuLi9VSS9Db250cm9scyc7XG5pbXBvcnQgeyBMYWJlbGxlZEJ1dHRvbiB9IGZyb20gJy4uL1VJL0xhYmVsbGVkQnV0dG9uJztcbmltcG9ydCB7IFNldHRpbmdzUGFuZWwgfSBmcm9tICcuLi9VSS9TZXR0aW5nc1BhbmVsJztcbmltcG9ydCB7IFN0YXRzUGFuZWwgfSBmcm9tICcuLi9VSS9TdGF0c1BhbmVsJztcbmltcG9ydCB7IFZpZGVvUXBJbmRpY2F0b3IgfSBmcm9tICcuLi9VSS9WaWRlb1FwSW5kaWNhdG9yJztcbmltcG9ydCB7IENvbmZpZ1VJIH0gZnJvbSAnLi4vQ29uZmlnL0NvbmZpZ1VJJztcbmltcG9ydCB7IEVkaXRUZXh0TW9kYWwgfSBmcm9tICcuLi9VSS9FZGl0VGV4dE1vZGFsJztcbmltcG9ydCB7IFVJRWxlbWVudENyZWF0aW9uTW9kZSwgaXNQYW5lbEVuYWJsZWQsIEV4dHJhRmxhZ3MgfSBmcm9tICcuLi9VSS9VSUNvbmZpZ3VyYXRpb25UeXBlcyc7XG5pbXBvcnQgeyBGdWxsU2NyZWVuSWNvbkV4dGVybmFsIH0gZnJvbSAnLi4vVUkvRnVsbHNjcmVlbkljb24nO1xuLyoqXG4gKiBBbiBBcHBsaWNhdGlvbiBpcyBhIGNvbWJpbmF0aW9uIG9mIFVJIGVsZW1lbnRzIHRvIGRpc3BsYXkgYW5kIG1hbmFnZSBhIFdlYlJUQyBQaXhlbCBTdHJlYW1pbmdcbiAqIGNvbm5lY3Rpb24uIEl0IGluY2x1ZGVzIGZlYXR1cmVzIGZvciBjb250cm9sbGluZyBhIHN0cmVhbSB3aXRoIG1vdXNlIGFuZCBrZXlib2FyZCxcbiAqIG1hbmFnaW5nIGNvbm5lY3Rpb24gZW5kcG9pbnRzLCBhcyB3ZWxsIGFzIGRpc3BsYXlpbmcgc3RhdHMgYW5kIG90aGVyIGluZm9ybWF0aW9uIGFib3V0IGl0LlxuICovXG5leHBvcnQgY2xhc3MgQXBwbGljYXRpb24ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gSW5pdGlhbGl6YXRpb24gb3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5lZGl0VGV4dE1vZGFsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gb3B0aW9ucy5zdHJlYW07XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgY3JlYXRlIHVpIGZlYXR1cmVzIG5vdyBzbyBjcmVhdGlvbiB0aW1lIGlzIGtub3duXG4gICAgICAgIHRoaXMuX3VpRmVhdHVyZUVsZW1lbnQgPSB0aGlzLmNyZWF0ZVVJRmVhdHVyZXNFbGVtZW50KCk7XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgY3JlYXRlIHJvb3QgZWxlbWVudCBub3cgc28gY3JlYXRpb24gdGltZSBpcyBrbm93blxuICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IHRoaXMuY3JlYXRlUm9vdEVsZW1lbnQodGhpcy5zdHJlYW0sIHRoaXMuX3VpRmVhdHVyZUVsZW1lbnQpO1xuICAgICAgICB0aGlzLm9uQ29sb3JNb2RlQ2hhbmdlZCA9IG9wdGlvbnMub25Db2xvck1vZGVDaGFuZ2VkO1xuICAgICAgICB0aGlzLmNvbmZpZ1VJID0gbmV3IENvbmZpZ1VJKHRoaXMuc3RyZWFtLmNvbmZpZyk7XG4gICAgICAgIHRoaXMuY3JlYXRlT3ZlcmxheXMoKTtcbiAgICAgICAgaWYgKGlzUGFuZWxFbmFibGVkKG9wdGlvbnMuc3RhdHNQYW5lbENvbmZpZykpIHtcbiAgICAgICAgICAgIC8vIEFkZCBzdGF0cyBwYW5lbFxuICAgICAgICAgICAgdGhpcy5zdGF0c1BhbmVsID0gbmV3IFN0YXRzUGFuZWwob3B0aW9ucy5zdGF0c1BhbmVsQ29uZmlnLCB0aGlzLnN0cmVhbS5jb25maWcpO1xuICAgICAgICAgICAgdGhpcy51aUZlYXR1cmVzRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnN0YXRzUGFuZWwucm9vdEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BhbmVsRW5hYmxlZChvcHRpb25zLnNldHRpbmdzUGFuZWxDb25maWcpKSB7XG4gICAgICAgICAgICAvLyBBZGQgc2V0dGluZ3MgcGFuZWxcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NQYW5lbCA9IG5ldyBTZXR0aW5nc1BhbmVsKCk7XG4gICAgICAgICAgICB0aGlzLnVpRmVhdHVyZXNFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc2V0dGluZ3NQYW5lbC5yb290RWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZVNldHRpbmdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLnZpZGVvUXBJbmRpY2F0b3JDb25maWcgfHwgIW9wdGlvbnMudmlkZW9RcEluZGljYXRvckNvbmZpZy5kaXNhYmxlSW5kaWNhdG9yKSB7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIHZpZGVvIHN0cmVhbSBRUCBpbmRpY2F0b3JcbiAgICAgICAgICAgIHRoaXMudmlkZW9RcEluZGljYXRvciA9IG5ldyBWaWRlb1FwSW5kaWNhdG9yKG9wdGlvbnMudmlkZW9RcEluZGljYXRvckNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLnVpRmVhdHVyZXNFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudmlkZW9RcEluZGljYXRvci5yb290RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcmVhdGVCdXR0b25zKCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJDYWxsYmFja3MoKTtcbiAgICAgICAgdGhpcy5zaG93Q29ubmVjdE9yQXV0b0Nvbm5lY3RPdmVybGF5cygpO1xuICAgICAgICB0aGlzLnNldENvbG9yTW9kZSh0aGlzLmNvbmZpZ1VJLmlzQ3VzdG9tRmxhZ0VuYWJsZWQoRXh0cmFGbGFncy5MaWdodE1vZGUpKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uY29uZmlnLl9hZGRPblNldHRpbmdDaGFuZ2VkTGlzdGVuZXIoRmxhZ3MuSGlkZVVJLCAoaXNFbmFibGVkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl91aUZlYXR1cmVFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSBpc0VuYWJsZWQgPyAnaGlkZGVuJyA6ICd2aXNpYmxlJztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLnN0cmVhbS5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5IaWRlVUkpKSB7XG4gICAgICAgICAgICB0aGlzLl91aUZlYXR1cmVFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVPdmVybGF5cygpIHtcbiAgICAgICAgLy8gYnVpbGQgYWxsIG9mIHRoZSBvdmVybGF5c1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RPdmVybGF5ID0gbmV3IERpc2Nvbm5lY3RPdmVybGF5KHRoaXMuc3RyZWFtLnZpZGVvRWxlbWVudFBhcmVudCk7XG4gICAgICAgIHRoaXMuY29ubmVjdE92ZXJsYXkgPSBuZXcgQ29ubmVjdE92ZXJsYXkodGhpcy5zdHJlYW0udmlkZW9FbGVtZW50UGFyZW50KTtcbiAgICAgICAgdGhpcy5wbGF5T3ZlcmxheSA9IG5ldyBQbGF5T3ZlcmxheSh0aGlzLnN0cmVhbS52aWRlb0VsZW1lbnRQYXJlbnQpO1xuICAgICAgICB0aGlzLmluZm9PdmVybGF5ID0gbmV3IEluZm9PdmVybGF5KHRoaXMuc3RyZWFtLnZpZGVvRWxlbWVudFBhcmVudCk7XG4gICAgICAgIHRoaXMuZXJyb3JPdmVybGF5ID0gbmV3IEVycm9yT3ZlcmxheSh0aGlzLnN0cmVhbS52aWRlb0VsZW1lbnRQYXJlbnQpO1xuICAgICAgICB0aGlzLmFma092ZXJsYXkgPSBuZXcgQUZLT3ZlcmxheSh0aGlzLnN0cmVhbS52aWRlb0VsZW1lbnRQYXJlbnQpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RPdmVybGF5Lm9uQWN0aW9uKCgpID0+IHRoaXMuc3RyZWFtLnJlY29ubmVjdCgpKTtcbiAgICAgICAgLy8gQnVpbGQgdGhlIHdlYlJ0YyBjb25uZWN0IG92ZXJsYXkgRXZlbnQgTGlzdGVuZXIgYW5kIHNob3cgdGhlIGNvbm5lY3Qgb3ZlcmxheVxuICAgICAgICB0aGlzLmNvbm5lY3RPdmVybGF5Lm9uQWN0aW9uKCgpID0+IHRoaXMuc3RyZWFtLmNvbm5lY3QoKSk7XG4gICAgICAgIC8vIHNldCB1cCB0aGUgcGxheSBvdmVybGF5cyBhY3Rpb25cbiAgICAgICAgdGhpcy5wbGF5T3ZlcmxheS5vbkFjdGlvbigoKSA9PiB0aGlzLnN0cmVhbS5wbGF5KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgYnV0dG9uIGNsaWNrIGZ1bmN0aW9ucyBhbmQgYnV0dG9uIGZ1bmN0aW9uYWxpdHlcbiAgICAgKi9cbiAgICBjcmVhdGVCdXR0b25zKCkge1xuICAgICAgICBjb25zdCBpc0lwaG9uZSA9IC9pUGhvbmUvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIGNvbnN0IGlzSXBhZCA9IC9pUGFkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpIHx8XG4gICAgICAgICAgICAoL01hY2ludG9zaC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAnb250b3VjaGVuZCcgaW4gZG9jdW1lbnQpO1xuICAgICAgICBjb25zdCBpc1NhZmFyaSA9IG5hdmlnYXRvci52ZW5kb3IgJiZcbiAgICAgICAgICAgIG5hdmlnYXRvci52ZW5kb3IuaW5kZXhPZignQXBwbGUnKSA+IC0xICYmXG4gICAgICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50ICYmXG4gICAgICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0NyaU9TJykgPT0gLTEgJiZcbiAgICAgICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRnhpT1MnKSA9PSAtMTtcbiAgICAgICAgLy8gSW4gc29tZSBjYXNlcyB3ZSB3YW50IHRvIGRpc2FibGUgZnVsbHNjcmVlbiBidXR0b24gaWYgaXQgaXMgbm90IGV4cGxpY2l0bHkgcmVxdWVzdGVkOlxuICAgICAgICAvLyBJUGhvbmUgZG9lcyBub3Qgc3VwcG9ydCBmdWxsc2NyZWVuIEFQSSBhcyBhdCAyOHRoIEp1bHkgMjAyNCAoc2VlOiBodHRwczovL2Nhbml1c2UuY29tL2Z1bGxzY3JlZW4pIHNvIGlmXG4gICAgICAgIC8vIHdlIGFyZSBvbiBJUGhvbmUgYW5kIHVzZXIgaGFzIG5vdCBzcGVjaWZpZWQgZXhwbGljaXRseSBjb25maWd1cmVkIFVJIGNvbmZpZyBmb3JcbiAgICAgICAgLy8gZnVsbHNjcmVlbiBidXR0b24gdGhlbiB3ZSBzaG91bGQgZGlzYWJsZSB0aGlzIGJ1dHRvbiBhcyBpdCBkb2Vzbid0IHdvcmsuXG4gICAgICAgIC8vIEFkZGl0aW9uYWxseSBpUGFkIG9uIG5vbi1TYWZhcmkgYnJvd3NlcnMgZG9lc24ndCByZWFsbHkgYWxsb3cgdG91Y2ggaW5wdXRzIGFuZCBmdWxsc2NyZWVuIHZpZGVvIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgIC8vIElmIHlvdSBkbyB0aGlzIHRoZSB2aWRlbyBnZXRzIGRyYWdnZWQgb2ZmIGJhY2sgdG8gbm9ybWFsIG5vbi1mdWxsc2NyZWVuIHZpZGVvIGFuZCB0aGVuIHRoZSB2aWRlbyBpcyBwYXVzZWQuXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL0VwaWNHYW1lc0V4dC9QaXhlbFN0cmVhbWluZ0luZnJhc3RydWN0dXJlL2lzc3Vlcy8yMTlcbiAgICAgICAgY29uc3QgZGlzYWJsZUZ1bGxzY3JlZW5CdXR0b24gPSBpc0lwaG9uZSB8fCAoIWlzU2FmYXJpICYmIGlzSXBhZCk7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmZ1bGxTY3JlZW5Db250cm9sc0NvbmZpZyA9PT0gdW5kZWZpbmVkICYmIGRpc2FibGVGdWxsc2NyZWVuQnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLmZ1bGxTY3JlZW5Db250cm9sc0NvbmZpZyA9IHsgY3JlYXRpb25Nb2RlOiBVSUVsZW1lbnRDcmVhdGlvbk1vZGUuRGlzYWJsZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRyb2xzVUlDb25maWcgPSB7XG4gICAgICAgICAgICBzdGF0c0J1dHRvblR5cGU6IHRoaXMuX29wdGlvbnMuc3RhdHNQYW5lbENvbmZpZ1xuICAgICAgICAgICAgICAgID8gdGhpcy5fb3B0aW9ucy5zdGF0c1BhbmVsQ29uZmlnLnZpc2liaWxpdHlCdXR0b25Db25maWdcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNldHRpbmdzQnV0dG9uVHlwZTogdGhpcy5fb3B0aW9ucy5zZXR0aW5nc1BhbmVsQ29uZmlnXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9vcHRpb25zLnNldHRpbmdzUGFuZWxDb25maWcudmlzaWJpbGl0eUJ1dHRvbkNvbmZpZ1xuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZnVsbHNjcmVlbkJ1dHRvblR5cGU6IHRoaXMuX29wdGlvbnMuZnVsbFNjcmVlbkNvbnRyb2xzQ29uZmlnLFxuICAgICAgICAgICAgeHJJY29uVHlwZTogdGhpcy5fb3B0aW9ucy54ckNvbnRyb2xzQ29uZmlnLFxuICAgICAgICAgICAgaGlkZUNvbnRyb2xzSW5GdWxsc2NyZWVuOiB0aGlzLl9vcHRpb25zLmhpZGVDb250cm9sc0luRnVsbHNjcmVlblxuICAgICAgICB9O1xuICAgICAgICAvLyBTZXR1cCBjb250cm9sc1xuICAgICAgICBjb25zdCBjb250cm9scyA9IG5ldyBDb250cm9scyhjb250cm9sc1VJQ29uZmlnKTtcbiAgICAgICAgdGhpcy51aUZlYXR1cmVzRWxlbWVudC5hcHBlbmRDaGlsZChjb250cm9scy5yb290RWxlbWVudCk7XG4gICAgICAgIC8vIFdoZW4gd2UgZnVsbHNjcmVlbiB3ZSB3YW50IHRoaXMgZWxlbWVudCB0byBiZSB0aGUgcm9vdFxuICAgICAgICBjb25zdCBmdWxsU2NyZWVuQnV0dG9uID0gXG4gICAgICAgIC8vIERlcGVuZGluZyBvbiBpZiB3ZSdyZSBjcmVhdGluZyBhbiBpbnRlcm5hbCBidXR0b24sIG9yIHVzaW5nIGFuIGV4dGVybmFsIG9uZVxuICAgICAgICAhIXRoaXMuX29wdGlvbnMuZnVsbFNjcmVlbkNvbnRyb2xzQ29uZmlnICYmXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLmZ1bGxTY3JlZW5Db250cm9sc0NvbmZpZy5jcmVhdGlvbk1vZGUgPT09IFVJRWxlbWVudENyZWF0aW9uTW9kZS5Vc2VDdXN0b21FbGVtZW50XG4gICAgICAgICAgICA/IC8vIEVpdGhlciBjcmVhdGUgYSBmdWxsc2NyZWVuIGNsYXNzIGJhc2VkIG9uIHRoZSBleHRlcm5hbCBidXR0b25cbiAgICAgICAgICAgICAgICBuZXcgRnVsbFNjcmVlbkljb25FeHRlcm5hbCh0aGlzLl9vcHRpb25zLmZ1bGxTY3JlZW5Db250cm9sc0NvbmZpZy5jdXN0b21FbGVtZW50KVxuICAgICAgICAgICAgOiAvLyBPciB1c2UgdGhlIG9uZSBjcmVhdGVkIGJ5IHRoZSBDb250cm9scyBpbml0aWFsaXplciBlYXJsaWVyXG4gICAgICAgICAgICAgICAgY29udHJvbHMuZnVsbHNjcmVlbkljb247XG4gICAgICAgIGlmIChmdWxsU2NyZWVuQnV0dG9uKSB7XG4gICAgICAgICAgICBmdWxsU2NyZWVuQnV0dG9uLmZ1bGxzY3JlZW5FbGVtZW50ID0gL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICAgICAgICAgICAgICA/IHRoaXMuc3RyZWFtLnZpZGVvRWxlbWVudFBhcmVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKVswXVxuICAgICAgICAgICAgICAgIDogdGhpcy5yb290RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgc2V0dGluZ3MgYnV0dG9uIHRvIGNvbnRyb2xzXG4gICAgICAgIGNvbnN0IHNldHRpbmdzQnV0dG9uID0gY29udHJvbHMuc2V0dGluZ3NJY29uXG4gICAgICAgICAgICA/IGNvbnRyb2xzLnNldHRpbmdzSWNvbi5yb290RWxlbWVudFxuICAgICAgICAgICAgOiB0aGlzLl9vcHRpb25zLnNldHRpbmdzUGFuZWxDb25maWcudmlzaWJpbGl0eUJ1dHRvbkNvbmZpZy5jdXN0b21FbGVtZW50O1xuICAgICAgICBpZiAoc2V0dGluZ3NCdXR0b24pXG4gICAgICAgICAgICBzZXR0aW5nc0J1dHRvbi5vbmNsaWNrID0gKCkgPT4gdGhpcy5zZXR0aW5nc0NsaWNrZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3NQYW5lbClcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NQYW5lbC5zZXR0aW5nc0Nsb3NlQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB0aGlzLnNldHRpbmdzQ2xpY2tlZCgpO1xuICAgICAgICAvLyBBZGQgV2ViWFIgYnV0dG9uIHRvIGNvbnRyb2xzXG4gICAgICAgIGNvbnN0IHhyQnV0dG9uID0gY29udHJvbHMueHJJY29uXG4gICAgICAgICAgICA/IGNvbnRyb2xzLnhySWNvbi5yb290RWxlbWVudFxuICAgICAgICAgICAgOiB0aGlzLl9vcHRpb25zLnhyQ29udHJvbHNDb25maWcuY3JlYXRpb25Nb2RlID09PSBVSUVsZW1lbnRDcmVhdGlvbk1vZGUuVXNlQ3VzdG9tRWxlbWVudFxuICAgICAgICAgICAgICAgID8gdGhpcy5fb3B0aW9ucy54ckNvbnRyb2xzQ29uZmlnLmN1c3RvbUVsZW1lbnRcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHhyQnV0dG9uKVxuICAgICAgICAgICAgeHJCdXR0b24ub25jbGljayA9ICgpID0+IHRoaXMuc3RyZWFtLnRvZ2dsZVhSKCk7XG4gICAgICAgIC8vIHNldHVwIHRoZSBzdGF0cy9pbmZvIGJ1dHRvblxuICAgICAgICBjb25zdCBzdGF0c0J1dHRvbiA9IGNvbnRyb2xzLnN0YXRzSWNvblxuICAgICAgICAgICAgPyBjb250cm9scy5zdGF0c0ljb24ucm9vdEVsZW1lbnRcbiAgICAgICAgICAgIDogdGhpcy5fb3B0aW9ucy5zdGF0c1BhbmVsQ29uZmlnLnZpc2liaWxpdHlCdXR0b25Db25maWcuY3VzdG9tRWxlbWVudDtcbiAgICAgICAgaWYgKHN0YXRzQnV0dG9uKVxuICAgICAgICAgICAgc3RhdHNCdXR0b24ub25jbGljayA9ICgpID0+IHRoaXMuc3RhdHNDbGlja2VkKCk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRzUGFuZWwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHNQYW5lbC5zdGF0c0Nsb3NlQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB0aGlzLnN0YXRzQ2xpY2tlZCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBjb21tYW5kIGJ1dHRvbnMgKGlmIHdlIGhhdmUgc29tZXdoZXJlIHRvIGFkZCB0aGVtIHRvKVxuICAgICAgICBpZiAodGhpcy5zZXR0aW5nc1BhbmVsKSB7XG4gICAgICAgICAgICAvLyBBZGQgYnV0dG9uIGZvciB0b2dnbGUgZnBzXG4gICAgICAgICAgICBjb25zdCBzaG93RlBTQnV0dG9uID0gbmV3IExhYmVsbGVkQnV0dG9uKCdTaG93IEZQUycsICdUb2dnbGUnKTtcbiAgICAgICAgICAgIHNob3dGUFNCdXR0b24uYWRkT25DbGlja0xpc3RlbmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5yZXF1ZXN0U2hvd0ZwcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBZGQgYnV0dG9uIGZvciByZXN0YXJ0IHN0cmVhbVxuICAgICAgICAgICAgY29uc3QgcmVzdGFydFN0cmVhbUJ1dHRvbiA9IG5ldyBMYWJlbGxlZEJ1dHRvbignUmVzdGFydCBTdHJlYW0nLCAnUmVzdGFydCcpO1xuICAgICAgICAgICAgcmVzdGFydFN0cmVhbUJ1dHRvbi5hZGRPbkNsaWNrTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBZGQgYnV0dG9uIGZvciByZXF1ZXN0IGtleWZyYW1lXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0S2V5ZnJhbWVCdXR0b24gPSBuZXcgTGFiZWxsZWRCdXR0b24oJ1JlcXVlc3Qga2V5ZnJhbWUnLCAnUmVxdWVzdCcpO1xuICAgICAgICAgICAgcmVxdWVzdEtleWZyYW1lQnV0dG9uLmFkZE9uQ2xpY2tMaXN0ZW5lcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucmVxdWVzdElmcmFtZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjb21tYW5kc1NlY3Rpb25FbGVtID0gdGhpcy5jb25maWdVSS5idWlsZFNlY3Rpb25XaXRoSGVhZGluZyh0aGlzLnNldHRpbmdzUGFuZWwuc2V0dGluZ3NDb250ZW50RWxlbWVudCwgJ0NvbW1hbmRzJyk7XG4gICAgICAgICAgICBjb21tYW5kc1NlY3Rpb25FbGVtLmFwcGVuZENoaWxkKHNob3dGUFNCdXR0b24ucm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgY29tbWFuZHNTZWN0aW9uRWxlbS5hcHBlbmRDaGlsZChyZXF1ZXN0S2V5ZnJhbWVCdXR0b24ucm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgY29tbWFuZHNTZWN0aW9uRWxlbS5hcHBlbmRDaGlsZChyZXN0YXJ0U3RyZWFtQnV0dG9uLnJvb3RFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgdGhlIHNldHRpbmdzIHdpdGggb24gY2hhbmdlIGxpc3RlbmVycyBhbmQgYW55IGFkZGl0aW9uYWwgcGVyIGV4cGVyaWVuY2Ugc2V0dGluZ3MuXG4gICAgICovXG4gICAgY29uZmlndXJlU2V0dGluZ3MoKSB7XG4gICAgICAgIC8vIFRoaXMgYnVpbGRzIGFsbCB0aGUgc2V0dGluZ3Mgc2VjdGlvbnMgYW5kIGZsYWdzIHVuZGVyIHRoaXMgYHNldHRpbmdzQ29udGVudGAgZWxlbWVudC5cbiAgICAgICAgdGhpcy5jb25maWdVSS5wb3B1bGF0ZVNldHRpbmdzRWxlbWVudCh0aGlzLnNldHRpbmdzUGFuZWwuc2V0dGluZ3NDb250ZW50RWxlbWVudCwgdGhpcy5fb3B0aW9ucy5zZXR0aW5nc1BhbmVsQ29uZmlnKTtcbiAgICAgICAgdGhpcy5jb25maWdVSS5hZGRDdXN0b21GbGFnT25TZXR0aW5nQ2hhbmdlZExpc3RlbmVyKEV4dHJhRmxhZ3MuTGlnaHRNb2RlLCAoaXNMaWdodE1vZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnVUkuc2V0Q3VzdG9tRmxhZ0xhYmVsKEV4dHJhRmxhZ3MuTGlnaHRNb2RlLCBgQ29sb3IgU2NoZW1lOiAke2lzTGlnaHRNb2RlID8gJ0xpZ2h0JyA6ICdEYXJrJ30gTW9kZWApO1xuICAgICAgICAgICAgdGhpcy5zZXRDb2xvck1vZGUoaXNMaWdodE1vZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVnaXN0ZXJDYWxsYmFja3MoKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2Fma1dhcm5pbmdBY3RpdmF0ZScsICh7IGRhdGE6IHsgY291bnREb3duLCBkaXNtaXNzQWZrIH0gfSkgPT4gdGhpcy5zaG93QWZrT3ZlcmxheShjb3VudERvd24sIGRpc21pc3NBZmspKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignYWZrV2FybmluZ1VwZGF0ZScsICh7IGRhdGE6IHsgY291bnREb3duIH0gfSkgPT4gdGhpcy5hZmtPdmVybGF5LnVwZGF0ZUNvdW50ZG93bihjb3VudERvd24pKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignYWZrV2FybmluZ0RlYWN0aXZhdGUnLCAoKSA9PiB0aGlzLmFma092ZXJsYXkuaGlkZSgpKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignYWZrVGltZWRPdXQnLCAoKSA9PiB0aGlzLmFma092ZXJsYXkuaGlkZSgpKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcigndmlkZW9FbmNvZGVyQXZnUVAnLCAoeyBkYXRhOiB7IGF2Z1FQIH0gfSkgPT4gdGhpcy5vblZpZGVvRW5jb2RlckF2Z1FQKGF2Z1FQKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYlJ0Y1NkcCcsICgpID0+IHRoaXMub25XZWJSdGNTZHAoKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYlJ0Y0F1dG9Db25uZWN0JywgKCkgPT4gdGhpcy5vbldlYlJ0Y0F1dG9Db25uZWN0KCkpO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCd3ZWJSdGNDb25uZWN0aW5nJywgKCkgPT4gdGhpcy5vbldlYlJ0Y0Nvbm5lY3RpbmcoKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYlJ0Y0Nvbm5lY3RlZCcsICgpID0+IHRoaXMub25XZWJSdGNDb25uZWN0ZWQoKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYlJ0Y0ZhaWxlZCcsICgpID0+IHRoaXMub25XZWJSdGNGYWlsZWQoKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYlJ0Y0Rpc2Nvbm5lY3RlZCcsICh7IGRhdGE6IHsgZXZlbnRTdHJpbmcsIGFsbG93Q2xpY2tUb1JlY29ubmVjdCB9IH0pID0+IHRoaXMub25EaXNjb25uZWN0KGV2ZW50U3RyaW5nLCBhbGxvd0NsaWNrVG9SZWNvbm5lY3QpKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcigndmlkZW9Jbml0aWFsaXplZCcsICgpID0+IHRoaXMub25WaWRlb0luaXRpYWxpemVkKCkpO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdzdHJlYW1Mb2FkaW5nJywgKCkgPT4gdGhpcy5vblN0cmVhbUxvYWRpbmcoKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlTdHJlYW1FcnJvcicsICh7IGRhdGE6IHsgbWVzc2FnZSB9IH0pID0+IHRoaXMub25QbGF5U3RyZWFtRXJyb3IobWVzc2FnZSkpO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdwbGF5U3RyZWFtJywgKCkgPT4gdGhpcy5vblBsYXlTdHJlYW0oKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlTdHJlYW1SZWplY3RlZCcsICh7IGRhdGE6IHsgcmVhc29uIH0gfSkgPT4gdGhpcy5vblBsYXlTdHJlYW1SZWplY3RlZChyZWFzb24pKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignbG9hZEZyZWV6ZUZyYW1lJywgKHsgZGF0YTogeyBzaG91bGRTaG93UGxheU92ZXJsYXkgfSB9KSA9PiB0aGlzLm9uTG9hZEZyZWV6ZUZyYW1lKHNob3VsZFNob3dQbGF5T3ZlcmxheSkpO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdzdGF0c1JlY2VpdmVkJywgKHsgZGF0YTogeyBhZ2dyZWdhdGVkU3RhdHMgfSB9KSA9PiB0aGlzLm9uU3RhdHNSZWNlaXZlZChhZ2dyZWdhdGVkU3RhdHMpKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignbGF0ZW5jeUNhbGN1bGF0ZWQnLCAoeyBkYXRhOiB7IGxhdGVuY3lJbmZvIH0gfSkgPT4gdGhpcy5vbkxhdGVuY3lVcGRhdGUobGF0ZW5jeUluZm8pKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignbGF0ZW5jeVRlc3RSZXN1bHQnLCAoeyBkYXRhOiB7IGxhdGVuY3lUaW1pbmdzIH0gfSkgPT4gdGhpcy5vbkxhdGVuY3lUZXN0UmVzdWx0cyhsYXRlbmN5VGltaW5ncykpO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdkYXRhQ2hhbm5lbExhdGVuY3lUZXN0UmVzdWx0JywgKHsgZGF0YTogeyByZXN1bHQgfSB9KSA9PiB0aGlzLm9uRGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlc3VsdHMocmVzdWx0KSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ3N0cmVhbWVyTGlzdE1lc3NhZ2UnLCAoeyBkYXRhOiB7IG1lc3NhZ2VTdHJlYW1lckxpc3QsIGF1dG9TZWxlY3RlZFN0cmVhbWVySWQsIHdhbnRlZFN0cmVhbWVySWQgfSB9KSA9PiB0aGlzLmhhbmRsZVN0cmVhbWVyTGlzdE1lc3NhZ2UobWVzc2FnZVN0cmVhbWVyTGlzdCwgYXV0b1NlbGVjdGVkU3RyZWFtZXJJZCwgd2FudGVkU3RyZWFtZXJJZCkpO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdzdWJzY3JpYmVGYWlsZWQnLCAoeyBkYXRhOiB7IG1lc3NhZ2UgfSB9KSA9PiB0aGlzLmhhbmRsZVN1YnNjcmliZUZhaWxlZE1lc3NhZ2UobWVzc2FnZSkpO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdzZXR0aW5nc0NoYW5nZWQnLCAoZXZlbnQpID0+IHRoaXMub25TZXR0aW5nc0NoYW5nZWQoZXZlbnQpKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcigncGxheWVyQ291bnQnLCAoeyBkYXRhOiB7IGNvdW50IH0gfSkgPT4gdGhpcy5vblBsYXllckNvdW50KGNvdW50KSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYlJ0Y1RDUFJlbGF5RGV0ZWN0ZWQnLCAoKSA9PiBMb2dnZXIuV2FybmluZyhgU3RyZWFtIHF1YWlsdHkgZGVncmFkZWQgZHVlIHRvIG5ldHdvcmsgZW52aXJvbWVudCwgc3RyZWFtIGlzIHJlbGF5ZWQgb3ZlciBUQ1AuYCkpO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdzaG93T25TY3JlZW5LZXlib2FyZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gT25seSBzaG93IHRoZSBlZGl0IHRleHQgbW9kYWwgaWYgdGhlIGZsYWcgaXMgZW5hYmxlZFxuICAgICAgICAgICAgaWYgKCF0aGlzLnN0cmVhbS5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5Vc2VNb2RhbEZvclRleHRJbnB1dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBldnREYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChldnREYXRhLnNob3dPblNjcmVlbktleWJvYXJkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RWRpdFRleHRNb2RhbChldnREYXRhLmNvbnRlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJvb3RFbGVtZW50IG9mIHRoZSBhcHBsaWNhdGlvbiwgdmlkZW8gc3RyZWFtIGFuZCBhbGwgVUkgYXJlIGNoaWxkcmVuIG9mIHRoaXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICBnZXQgcm9vdEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gdGhpcy5jcmVhdGVSb290RWxlbWVudCh0aGlzLnN0cmVhbSwgdGhpcy51aUZlYXR1cmVzRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RFbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSByb290IGVsZW1lbnQgZm9yIHRoZSBQaXhlbCBTdHJlYW1pbmcgVUkuXG4gICAgICogTm90ZTogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSB0aGUgUGl4ZWwgU3RyZWFtaW5nIG9iamVjdCBpcyBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSBwaXhlbHN0cmVhbWluZyAtIFRoZSBQaXhlbCBTdHJlYW1pbmcgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB1aUZlYXR1cmVzRWxlbSAtIFRoZSBlbGVtZW50IGhvbGRpbmcgYWxsIHRoZSBjdXN0b20gVUkgZmVhdHVyZXMuXG4gICAgICogQHJldHVybnMgQSBkaXYgd2l0aCB0aGUgaWQgI3BsYXllclVJIHBvcHVsYXRlZCB3aXRoIHZpZGVvRWxlbWVudFBhcmVudCBhbmQgdWlGZWF0dXJlRWxlbWVudC5cbiAgICAgKi9cbiAgICBjcmVhdGVSb290RWxlbWVudChwaXhlbHN0cmVhbWluZywgdWlGZWF0dXJlc0VsZW0pIHtcbiAgICAgICAgY29uc3QgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBlbGVtLmlkID0gJ3BsYXllclVJJztcbiAgICAgICAgZWxlbS5jbGFzc0xpc3QuYWRkKCdub3NlbGVjdCcpO1xuICAgICAgICBpZiAocGl4ZWxzdHJlYW1pbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY3JlYXRlIHJvb3QgZWxlbWVudCBwcm9wZXJseSAtIHBpeGVsc3RyZWFtaW5nIG9iamVjdCB3YXMgdW5kZWZpbmVkLiBBcmUgeW91IGNhbGxpbmcgdGhpcyB0b28gZWFybHk/Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBpeGVsc3RyZWFtaW5nLnZpZGVvRWxlbWVudFBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjcmVhdGUgcm9vdCBlbGVtZW50IHByb3Blcmx5IC0gdmlkZW9FbGVtZW50UGFyZW50IG9iamVjdCB3YXMgdW5kZWZpbmVkLiBBcmUgeW91IGNhbGxpbmcgdGhpcyB0b28gZWFybHk/Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpRmVhdHVyZXNFbGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNyZWF0ZSByb290IGVsZW1lbnQgcHJvcGVybHkgLSB1aUZlYXR1cmVzRWxlbWVudCBvYmplY3Qgd2FzIHVuZGVmaW5lZC4gQXJlIHlvdSBjYWxsaW5nIHRoaXMgdG9vIGVhcmx5PycpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQocGl4ZWxzdHJlYW1pbmcudmlkZW9FbGVtZW50UGFyZW50KTtcbiAgICAgICAgZWxlbS5hcHBlbmRDaGlsZCh1aUZlYXR1cmVzRWxlbSk7XG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBlbGVtZW50IHRoYXQgY29udGFpbnMgYWxsIHRoZSBVSSBmZWF0dXJlcywgbGlrZSB0aGUgc3RhdHMgYW5kIHNldHRpbmdzIHBhbmVscy5cbiAgICAgKi9cbiAgICBnZXQgdWlGZWF0dXJlc0VsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdWlGZWF0dXJlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fdWlGZWF0dXJlRWxlbWVudCA9IHRoaXMuY3JlYXRlVUlGZWF0dXJlc0VsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdWlGZWF0dXJlRWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgVUkgZmVhdHVyZXMgZWxlbWVudCBmb3IgaG9sZGluZyBhbGwgdGhlIGN1c3RvbSBVSSBmZWF0dXJlcy5cbiAgICAgKiBAcmV0dXJucyBBIGRpdiB3aXRoIHRoZSBpZCAjdWlGZWF0dXJlcy5cbiAgICAgKi9cbiAgICBjcmVhdGVVSUZlYXR1cmVzRWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBlbGVtLmlkID0gJ3VpRmVhdHVyZXMnO1xuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIGRpc2Nvbm5lY3Qgb3ZlcmxheVxuICAgICAqIEBwYXJhbSB1cGRhdGVUZXh0IC0gdGhlIHRleHQgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgb3ZlcmxheVxuICAgICAqL1xuICAgIHNob3dEaXNjb25uZWN0T3ZlcmxheSh1cGRhdGVUZXh0KSB7XG4gICAgICAgIHRoaXMuaGlkZUN1cnJlbnRPdmVybGF5KCk7XG4gICAgICAgIHRoaXMudXBkYXRlRGlzY29ubmVjdE92ZXJsYXkodXBkYXRlVGV4dCk7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdE92ZXJsYXkuc2hvdygpO1xuICAgICAgICB0aGlzLmN1cnJlbnRPdmVybGF5ID0gdGhpcy5kaXNjb25uZWN0T3ZlcmxheTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBkaXNjb25uZWN0IG92ZXJsYXlzIHNwYW4gdGV4dFxuICAgICAqIEBwYXJhbSB1cGRhdGVUZXh0IC0gdGhlIG5ldyBjb3VudGRvd24gbnVtYmVyXG4gICAgICovXG4gICAgdXBkYXRlRGlzY29ubmVjdE92ZXJsYXkodXBkYXRlVGV4dCkge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RPdmVybGF5LnVwZGF0ZSh1cGRhdGVUZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIHRoZSBkaXNjb25uZWN0IG92ZXJsYXlzIGFjdGlvblxuICAgICAqL1xuICAgIG9uRGlzY29ubmVjdGlvbkFjdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0T3ZlcmxheS5hY3RpdmF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgY3VycmVudCBvdmVybGF5XG4gICAgICovXG4gICAgaGlkZUN1cnJlbnRPdmVybGF5KCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50T3ZlcmxheSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRPdmVybGF5LmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE92ZXJsYXkgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBjb25uZWN0IG92ZXJsYXlcbiAgICAgKi9cbiAgICBzaG93Q29ubmVjdE92ZXJsYXkoKSB7XG4gICAgICAgIHRoaXMuaGlkZUN1cnJlbnRPdmVybGF5KCk7XG4gICAgICAgIHRoaXMuY29ubmVjdE92ZXJsYXkuc2hvdygpO1xuICAgICAgICB0aGlzLmN1cnJlbnRPdmVybGF5ID0gdGhpcy5jb25uZWN0T3ZlcmxheTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIHBsYXkgb3ZlcmxheVxuICAgICAqL1xuICAgIHNob3dQbGF5T3ZlcmxheSgpIHtcbiAgICAgICAgdGhpcy5oaWRlQ3VycmVudE92ZXJsYXkoKTtcbiAgICAgICAgdGhpcy5wbGF5T3ZlcmxheS5zaG93KCk7XG4gICAgICAgIHRoaXMuY3VycmVudE92ZXJsYXkgPSB0aGlzLnBsYXlPdmVybGF5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgdGV4dCBvdmVybGF5XG4gICAgICogQHBhcmFtIHRleHQgLSB0aGUgdGV4dCB0aGF0IHdpbGwgYmUgc2hvd24gaW4gdGhlIG92ZXJsYXlcbiAgICAgKi9cbiAgICBzaG93VGV4dE92ZXJsYXkodGV4dCkge1xuICAgICAgICB0aGlzLmhpZGVDdXJyZW50T3ZlcmxheSgpO1xuICAgICAgICB0aGlzLmluZm9PdmVybGF5LnVwZGF0ZSh0ZXh0KTtcbiAgICAgICAgdGhpcy5pbmZvT3ZlcmxheS5zaG93KCk7XG4gICAgICAgIHRoaXMuY3VycmVudE92ZXJsYXkgPSB0aGlzLmluZm9PdmVybGF5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgZXJyb3Igb3ZlcmxheVxuICAgICAqIEBwYXJhbSB0ZXh0IC0gdGhlIHRleHQgdGhhdCB3aWxsIGJlIHNob3duIGluIHRoZSBvdmVybGF5XG4gICAgICovXG4gICAgc2hvd0Vycm9yT3ZlcmxheSh0ZXh0KSB7XG4gICAgICAgIHRoaXMuaGlkZUN1cnJlbnRPdmVybGF5KCk7XG4gICAgICAgIHRoaXMuZXJyb3JPdmVybGF5LnVwZGF0ZSh0ZXh0KTtcbiAgICAgICAgdGhpcy5lcnJvck92ZXJsYXkuc2hvdygpO1xuICAgICAgICB0aGlzLmN1cnJlbnRPdmVybGF5ID0gdGhpcy5lcnJvck92ZXJsYXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIG9yIGhpZGVzIHRoZSBzZXR0aW5ncyBwYW5lbCBpZiBjbGlja2VkXG4gICAgICovXG4gICAgc2V0dGluZ3NDbGlja2VkKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuc3RhdHNQYW5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhpZGUoKTtcbiAgICAgICAgdGhpcy5zZXR0aW5nc1BhbmVsLnRvZ2dsZVZpc2liaWxpdHkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3Mgb3IgaGlkZXMgdGhlIHN0YXRzIHBhbmVsIGlmIGNsaWNrZWRcbiAgICAgKi9cbiAgICBzdGF0c0NsaWNrZWQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5zZXR0aW5nc1BhbmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGlkZSgpO1xuICAgICAgICB0aGlzLnN0YXRzUGFuZWwudG9nZ2xlVmlzaWJpbGl0eSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIGNvbm5lY3Qgb3ZlcmxheXMgYWN0aW9uXG4gICAgICovXG4gICAgb25Db25uZWN0QWN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbm5lY3RPdmVybGF5LmFjdGl2YXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyB0aGUgcGxheSBvdmVybGF5cyBhY3Rpb25cbiAgICAgKi9cbiAgICBvblBsYXlBY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucGxheU92ZXJsYXkuYWN0aXZhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIGFmayBvdmVybGF5XG4gICAgICogQHBhcmFtIGNvdW50RG93biAtIHRoZSBjb3VudGRvd24gbnVtYmVyIGZvciB0aGUgYWZrIGNvdW50ZG93blxuICAgICAqL1xuICAgIHNob3dBZmtPdmVybGF5KGNvdW50RG93biwgZGlzbWlzc0Fmaykge1xuICAgICAgICB0aGlzLmhpZGVDdXJyZW50T3ZlcmxheSgpO1xuICAgICAgICB0aGlzLmFma092ZXJsYXkudXBkYXRlQ291bnRkb3duKGNvdW50RG93bik7XG4gICAgICAgIHRoaXMuYWZrT3ZlcmxheS5vbkFjdGlvbigoKSA9PiBkaXNtaXNzQWZrKCkpO1xuICAgICAgICB0aGlzLmFma092ZXJsYXkuc2hvdygpO1xuICAgICAgICB0aGlzLmN1cnJlbnRPdmVybGF5ID0gdGhpcy5hZmtPdmVybGF5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBDb25uZWN0IE92ZXJsYXkgb3IgYXV0byBjb25uZWN0XG4gICAgICovXG4gICAgc2hvd0Nvbm5lY3RPckF1dG9Db25uZWN0T3ZlcmxheXMoKSB7XG4gICAgICAgIC8vIHNldCB1cCBpZiB0aGUgYXV0byBwbGF5IHdpbGwgYmUgdXNlZCBvciByZWd1bGFyIGNsaWNrIHRvIHN0YXJ0XG4gICAgICAgIGlmICghdGhpcy5zdHJlYW0uY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuQXV0b0Nvbm5lY3QpKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dDb25uZWN0T3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIHdlYlJ0Y0F1dG9Db25uZWN0IE92ZXJsYXkgYW5kIGNvbm5lY3RcbiAgICAgKi9cbiAgICBvbldlYlJ0Y0F1dG9Db25uZWN0KCkge1xuICAgICAgICB0aGlzLnNob3dUZXh0T3ZlcmxheSgnQXV0byBDb25uZWN0aW5nIE5vdycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgZnVuY3Rpb25hbGl0eSB0byBoYXBwZW4gd2hlbiByZWNlaXZpbmcgYSB3ZWJSVEMgYW5zd2VyXG4gICAgICovXG4gICAgb25XZWJSdGNTZHAoKSB7XG4gICAgICAgIHRoaXMuc2hvd1RleHRPdmVybGF5KCdXZWJSVEMgQ29ubmVjdGlvbiBOZWdvdGlhdGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIGEgdGV4dCBvdmVybGF5IHRvIGFsZXJ0IHRoZSB1c2VyIHRoZSBzdHJlYW0gaXMgY3VycmVudGx5IGxvYWRpbmdcbiAgICAgKi9cbiAgICBvblN0cmVhbUxvYWRpbmcoKSB7XG4gICAgICAgIC8vIGJ1aWxkIHRoZSBzcGlubmVyIHNwYW5cbiAgICAgICAgY29uc3Qgc3Bpbm5lclNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHNwaW5uZXJTcGFuLmNsYXNzTmFtZSA9ICd2aXN1YWxseS1oaWRkZW4nO1xuICAgICAgICBzcGlubmVyU3Bhbi5pbm5lckhUTUwgPSAnTG9hZGluZy4uLic7XG4gICAgICAgIC8vIGJ1aWxkIHRoZSBzcGlubmVyIGRpdlxuICAgICAgICBjb25zdCBzcGlubmVyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHNwaW5uZXJEaXYuaWQgPSAnbG9hZGluZy1zcGlubmVyJztcbiAgICAgICAgc3Bpbm5lckRpdi5jbGFzc05hbWUgPSAnc3Bpbm5lci1ib3JkZXIgbXMtMic7XG4gICAgICAgIHNwaW5uZXJEaXYuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3N0YXR1cycpO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIHNwaW5uZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgICAgc3Bpbm5lckRpdi5hcHBlbmRDaGlsZChzcGlubmVyU3Bhbik7XG4gICAgICAgIHRoaXMuc2hvd1RleHRPdmVybGF5KCdMb2FkaW5nIFN0cmVhbSAnICsgc3Bpbm5lckRpdi5vdXRlckhUTUwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHRoZSB2aWRlbyBpcyBkaXNjb25uZWN0ZWQgLSBkaXNwbGF5cyB0aGUgZXJyb3Igb3ZlcmxheSBhbmQgcmVzZXRzIHRoZSBidXR0b25zIHN0cmVhbSB0b29scyB1cG9uIGRpc2Nvbm5lY3RcbiAgICAgKiBAcGFyYW0gZXZlbnRTdHJpbmcgLSB0aGUgZXZlbnQgdGV4dCB0aGF0IHdpbGwgYmUgc2hvd24gaW4gdGhlIG92ZXJsYXlcbiAgICAgKiBAcGFyYW0gYWxsb3dDbGlja1RvUmVjb25uZWN0IC0gdHJ1ZSBpZiB3ZSB3YW50IHRvIGFsbG93IHRoZSB1c2VyIHRvIGNsaWNrIHRvIHJlY29ubmVjdC4gT3RoZXJ3aXNlIGl0J3MganVzdCBhIG1lc3NhZ2UuXG4gICAgICovXG4gICAgb25EaXNjb25uZWN0KGV2ZW50U3RyaW5nLCBhbGxvd0NsaWNrVG9SZWNvbm5lY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvdmVybGF5TWVzc2FnZSA9ICdEaXNjb25uZWN0ZWQnICsgKGV2ZW50U3RyaW5nID8gYDogJHtldmVudFN0cmluZ31gIDogJy4nKTtcbiAgICAgICAgaWYgKGFsbG93Q2xpY2tUb1JlY29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5zaG93RGlzY29ubmVjdE92ZXJsYXkoYCR7b3ZlcmxheU1lc3NhZ2V9IENsaWNrIFRvIFJlc3RhcnQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3dFcnJvck92ZXJsYXkob3ZlcmxheU1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpc2FibGUgc3RhcnRpbmcgYSBsYXRlbmN5IGNoZWNrc1xuICAgICAgICAoX2EgPSB0aGlzLnN0YXRzUGFuZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbkRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIFdlYiBSdGMgaXMgY29ubmVjdGluZ1xuICAgICAqL1xuICAgIG9uV2ViUnRjQ29ubmVjdGluZygpIHtcbiAgICAgICAgdGhpcy5zaG93VGV4dE92ZXJsYXkoJ1N0YXJ0aW5nIGNvbm5lY3Rpb24gdG8gc2VydmVyLCBwbGVhc2Ugd2FpdCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gV2ViIFJ0YyBoYXMgY29ubmVjdGVkXG4gICAgICovXG4gICAgb25XZWJSdGNDb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuc2hvd1RleHRPdmVybGF5KCdXZWJSVEMgY29ubmVjdGVkLCB3YWl0aW5nIGZvciB2aWRlbycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gV2ViIFJ0YyBmYWlscyB0byBjb25uZWN0XG4gICAgICovXG4gICAgb25XZWJSdGNGYWlsZWQoKSB7XG4gICAgICAgIHRoaXMuc2hvd0Vycm9yT3ZlcmxheSgnVW5hYmxlIHRvIHNldHVwIHZpZGVvJyk7XG4gICAgfVxuICAgIG9uTG9hZEZyZWV6ZUZyYW1lKHNob3VsZFNob3dQbGF5T3ZlcmxheSkge1xuICAgICAgICBpZiAoc2hvdWxkU2hvd1BsYXlPdmVybGF5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnc2hvd2luZyBwbGF5IG92ZXJsYXknKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1BsYXlPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25QbGF5U3RyZWFtKCkge1xuICAgICAgICB0aGlzLmhpZGVDdXJyZW50T3ZlcmxheSgpO1xuICAgIH1cbiAgICBvblBsYXlTdHJlYW1FcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuc2hvd0Vycm9yT3ZlcmxheShtZXNzYWdlKTtcbiAgICB9XG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuICAgIG9uUGxheVN0cmVhbVJlamVjdGVkKG9uUmVqZWN0ZWRSZWFzb24pIHtcbiAgICAgICAgdGhpcy5zaG93UGxheU92ZXJsYXkoKTtcbiAgICB9XG4gICAgb25WaWRlb0luaXRpYWxpemVkKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5zdHJlYW0uY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuQXV0b1BsYXlWaWRlbykpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd1BsYXlPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5zdGF0c1BhbmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25WaWRlb0luaXRpYWxpemVkKHRoaXMuc3RyZWFtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHVwIGZ1bmN0aW9uYWxpdHkgdG8gaGFwcGVuIHdoZW4gY2FsY3VsYXRpbmcgdGhlIGF2ZXJhZ2UgdmlkZW8gZW5jb2RlciBxcFxuICAgICAqIEBwYXJhbSBRUCAtIHRoZSBxdWFsaXR5IG51bWJlciBvZiB0aGUgc3RyZWFtXG4gICAgICovXG4gICAgb25WaWRlb0VuY29kZXJBdmdRUChRUCkge1xuICAgICAgICAvLyBVcGRhdGUgaW50ZXJuYWwgUVAgaW5kaWNhdG9yIGlmIG9uZSBpcyBwcmVzZW50XG4gICAgICAgIGlmICh0aGlzLnZpZGVvUXBJbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudmlkZW9RcEluZGljYXRvci51cGRhdGVRcFRvb2x0aXAoUVApO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uSW5pdGlhbFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHNldHRpbmdzLlBpeGVsU3RyZWFtaW5nU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuc3RhdHNQYW5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZ3VyZShzZXR0aW5ncy5QaXhlbFN0cmVhbWluZ1NldHRpbmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblN0YXRzUmVjZWl2ZWQoYWdncmVnYXRlZFN0YXRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gR3JhYiBhbGwgc3RhdHMgd2UgY2FuIG9mZiB0aGUgYWdncmVnYXRlZCBzdGF0c1xuICAgICAgICAoX2EgPSB0aGlzLnN0YXRzUGFuZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYW5kbGVTdGF0cyhhZ2dyZWdhdGVkU3RhdHMpO1xuICAgIH1cbiAgICBvbkxhdGVuY3lVcGRhdGUobGF0ZW5jeUluZm8pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnN0YXRzUGFuZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYW5kbGVMYXRlbmN5SW5mbyhsYXRlbmN5SW5mbyk7XG4gICAgfVxuICAgIG9uTGF0ZW5jeVRlc3RSZXN1bHRzKGxhdGVuY3lUaW1pbmdzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5zdGF0c1BhbmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGF0ZW5jeVRlc3QuaGFuZGxlVGVzdFJlc3VsdChsYXRlbmN5VGltaW5ncyk7XG4gICAgfVxuICAgIG9uRGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlc3VsdHMocmVzdWx0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5zdGF0c1BhbmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YUNoYW5uZWxMYXRlbmN5VGVzdC5oYW5kbGVUZXN0UmVzdWx0KHJlc3VsdCk7XG4gICAgfVxuICAgIG9uUGxheWVyQ291bnQocGxheWVyQ291bnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnN0YXRzUGFuZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYW5kbGVQbGF5ZXJDb3VudChwbGF5ZXJDb3VudCk7XG4gICAgfVxuICAgIGhhbmRsZVN0cmVhbWVyTGlzdE1lc3NhZ2UobWVzc2FnZVN0cmVhbWluZ0xpc3QsIGF1dG9TZWxlY3RlZFN0cmVhbWVySWQsIHdhbnRlZFN0cmVhbWVySWQpIHtcbiAgICAgICAgY29uc3Qgd2FpdEZvclN0cmVhbWVyID0gdGhpcy5zdHJlYW0uY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuV2FpdEZvclN0cmVhbWVyKTtcbiAgICAgICAgY29uc3QgaXNSZWNvbm5lY3RpbmcgPSB0aGlzLnN0cmVhbS5pc1JlY29ubmVjdGluZygpO1xuICAgICAgICBsZXQgbWVzc2FnZSA9IG51bGw7XG4gICAgICAgIGxldCBhbGxvd1Jlc3RhcnQgPSB0cnVlO1xuICAgICAgICBpZiAoIWF1dG9TZWxlY3RlZFN0cmVhbWVySWQpIHtcbiAgICAgICAgICAgIGlmICh3YWl0Rm9yU3RyZWFtZXIgJiYgd2FudGVkU3RyZWFtZXJJZCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1JlY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFdhaXRpbmcgZm9yICR7d2FudGVkU3RyZWFtZXJJZH0gdG8gYmVjb21lIGF2YWlsYWJsZS5gO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1Jlc3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgR2F2ZSB1cCB3YWl0aW5nIGZvciAke3dhbnRlZFN0cmVhbWVySWR9IHRvIGJlY29tZSBhdmFpbGFibGUuIENsaWNrIHRvIHRyeSBhZ2FpbmA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlU3RyZWFtaW5nTGlzdC5pZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgIG9yIHNlbGVjdCBhIHN0cmVhbWVyIGZyb20gdGhlIHNldHRpbmdzIG1lbnUuYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhbGxvd1Jlc3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VTdHJlYW1pbmdMaXN0Lmlkcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1JlY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFdhaXRpbmcgZm9yIGEgc3RyZWFtZXIgdG8gYmVjb21lIGF2YWlsYWJsZS5gO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1Jlc3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTm8gc3RyZWFtZXJzIGF2YWlsYWJsZS4gQ2xpY2sgdG8gdHJ5IGFnYWluLmA7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93UmVzdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBNdWx0aXBsZSBzdHJlYW1lcnMgYXZhaWxhYmxlLiBTZWxlY3Qgb25lIGZyb20gdGhlIHNldHRpbmdzIG1lbnUuYDtcbiAgICAgICAgICAgICAgICBhbGxvd1Jlc3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxvd1Jlc3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dEaXNjb25uZWN0T3ZlcmxheShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1RleHRPdmVybGF5KG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVN1YnNjcmliZUZhaWxlZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0aGlzLnNob3dEaXNjb25uZWN0T3ZlcmxheShgU3Vic2NyaWJlIGZhaWxlZDogXCIke21lc3NhZ2V9XCIgQ2xpY2sgdG8gdHJ5IGFnYWluYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBsaWdodC9kYXJrIGNvbG9yIG1vZGVcbiAgICAgKiBAcGFyYW0gaXNMaWdodE1vZGUgLSBzaG91bGQgd2UgdXNlIGEgbGlnaHQgb3IgZGFyayBjb2xvciBzY2hlbWVcbiAgICAgKi9cbiAgICBzZXRDb2xvck1vZGUoaXNMaWdodE1vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMub25Db2xvck1vZGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ29sb3JNb2RlQ2hhbmdlZChpc0xpZ2h0TW9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvd0VkaXRUZXh0TW9kYWwodWVUZXh0Ym94Q29udGVudHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIG1vZGFsXG4gICAgICAgIChfYSA9IHRoaXMuZWRpdFRleHRNb2RhbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJvb3RFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAvLyBNYWtlIGEgbmV3IG1vZGFsIGZvciBlZGl0aW5nIHRoZSBVRSB0ZXh0Ym94IG9uIHRoZSBicm93c2VyIHNpZGVcbiAgICAgICAgdGhpcy5lZGl0VGV4dE1vZGFsID0gbmV3IEVkaXRUZXh0TW9kYWwoKTtcbiAgICAgICAgLy8gQWRkIGl0IHRvIHRoZSByb290IG9mIHRoZSBQaXhlbCBTdHJlYW1pbmcgYXBwbGljYXRpb25cbiAgICAgICAgdGhpcy5yb290RWxlbWVudC5hcHBlbmQodGhpcy5lZGl0VGV4dE1vZGFsLnJvb3RFbGVtZW50KTtcbiAgICAgICAgLy8gQWRkIHRoZSB0ZXh0IGNvbnRlbnQgZnJvbSBVRSBzaWRlIGFuZCBzdW1tb24gb24tc2NyZWVuIGtleWJvYXJkXG4gICAgICAgIHRoaXMuZWRpdFRleHRNb2RhbC5zaG93TW9kYWwodWVUZXh0Ym94Q29udGVudHMpO1xuICAgICAgICAvLyBCaW5kIHRvIHRoZSBjb25maXJtIGV2ZW50XG4gICAgICAgIHRoaXMuZWRpdFRleHRNb2RhbC5ldmVudHMuYWRkRXZlbnRMaXN0ZW5lcignZWRpdENvbmZpcm1lZCcsIChldnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRUZXh0RXZlbnQgPSBldnQ7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5zZW5kVGV4dGJveEVudHJ5KGVkaXRUZXh0RXZlbnQuY29uZmlybWVkVGV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvblNldHRpbmdzQ2hhbmdlZChldmVudCkge1xuICAgICAgICAvLyBQYXNzIHRoZSBldmVudCBkaXJlY3RseSBvbnRvIHRoZSBjb25maWdVSS4gVGhpcyB3aWxsIGRvIHRoaW5ncyBsaWtlIHVwZGF0aW5nIHRoZSBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgICAgLy8gYXMgd2VsbCBhcyB0aGUgc2VsZWN0ZWQgdmFsdWVcbiAgICAgICAgdGhpcy5jb25maWdVSS5vblNldHRpbmdzQ2hhbmdlZChldmVudCk7XG4gICAgICAgIGNvbnN0IHsgXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgZGF0YTogeyBpZCwgdGFyZ2V0LCB0eXBlIH0gfSA9IGV2ZW50O1xuICAgICAgICAvLyBFeHBsaWNpdGx5IGhhbmRsZSBzcGVjaWZpYyBzZXR0aW5nIGJlaGF2aW91clxuICAgICAgICBpZiAoaWQgPT0gT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRRdWFsaXR5KSB7XG4gICAgICAgICAgICBjb25zdCBwcmVmZXJyZWRRdWFsaXR5T3B0aW9uID0gdGhpcy5zdHJlYW0uY29uZmlnLmdldFNldHRpbmdPcHRpb24oT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRRdWFsaXR5KTtcbiAgICAgICAgICAgIGlmIChbLi4ucHJlZmVycmVkUXVhbGl0eU9wdGlvbi5vcHRpb25zXS5pbmNsdWRlcygnRGVmYXVsdCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdVSS5kaXNhYmxlU2V0dGluZyhPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZFF1YWxpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdVSS5lbmFibGVTZXR0aW5nKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkUXVhbGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcHBsaWNhdGlvbi5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgVGV4dFBhcmFtZXRlcnMsIE9wdGlvblBhcmFtZXRlcnMsIEZsYWdzLCBOdW1lcmljUGFyYW1ldGVycywgU2V0dGluZ0ZsYWcsIExvZ2dlciwgaXNGbGFnSWQsIGlzTnVtZXJpY0lkLCBpc1RleHRJZCwgaXNPcHRpb25JZCB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nZnJvbnRlbmQtdWU1LjYnO1xuaW1wb3J0IHsgU2V0dGluZ1VJRmxhZyB9IGZyb20gJy4vU2V0dGluZ1VJRmxhZyc7XG5pbXBvcnQgeyBTZXR0aW5nVUlOdW1iZXIgfSBmcm9tICcuL1NldHRpbmdVSU51bWJlcic7XG5pbXBvcnQgeyBTZXR0aW5nVUlUZXh0IH0gZnJvbSAnLi9TZXR0aW5nVUlUZXh0JztcbmltcG9ydCB7IFNldHRpbmdVSU9wdGlvbiB9IGZyb20gJy4vU2V0dGluZ1VJT3B0aW9uJztcbmltcG9ydCB7IEV4dHJhRmxhZ3MsIGlzU2VjdGlvbkVuYWJsZWQsIGlzU2V0dGluZ0VuYWJsZWQsIFNldHRpbmdzU2VjdGlvbnMgfSBmcm9tICcuLi9VSS9VSUNvbmZpZ3VyYXRpb25UeXBlcyc7XG5leHBvcnQgY2xhc3MgQ29uZmlnVUkge1xuICAgIC8vIC0tLS0tLS0tLS0tLSBTZXR0aW5ncyAtLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLmN1c3RvbUZsYWdzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiBBIG1hcCBvZiBmbGFncyB0aGF0IGNhbiBiZSB0b2dnbGVkIC0gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQgaW4gdGhlIGFwcGxpY2F0aW9uIC0gZS5nLiBVc2UgTWljPyAqL1xuICAgICAgICB0aGlzLmZsYWdzVWkgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qIEEgbWFwIG9mIG51bWVyaWNhbCBzZXR0aW5ncyAtIG9wdGlvbnMgdGhhdCBjYW4gYmUgaW4gdGhlIGFwcGxpY2F0aW9uIC0gZS5nLiBNaW5CaXRyYXRlICovXG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnNVaSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyogQSBtYXAgb2YgdGV4dCBzZXR0aW5ncyAtIGUuZy4gc2lnbmFsbGluZyBzZXJ2ZXIgdXJsICovXG4gICAgICAgIHRoaXMudGV4dFBhcmFtZXRlcnNVaSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyogQSBtYXAgb2YgZW51bSBiYXNlZCBzZXR0aW5ncyAtIGUuZy4gcHJlZmVycmVkIGNvZGVjICovXG4gICAgICAgIHRoaXMub3B0aW9uUGFyYW1ldGVyc1VpID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNyZWF0ZUN1c3RvbVVJU2V0dGluZ3MoY29uZmlnLnVzZVVybFBhcmFtcyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJTZXR0aW5nc1VJQ29tcG9uZW50cyhjb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgY3VzdG9tIFVJIHNldHRpbmdzIHRoYXQgYXJlIG5vdCBwcm92aWRlZCBieSB0aGUgUGl4ZWwgU3RyZWFtaW5nIGxpYnJhcnkuXG4gICAgICovXG4gICAgY3JlYXRlQ3VzdG9tVUlTZXR0aW5ncyh1c2VVcmxQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5jdXN0b21GbGFncy5zZXQoRXh0cmFGbGFncy5MaWdodE1vZGUsIG5ldyBTZXR0aW5nRmxhZyhFeHRyYUZsYWdzLkxpZ2h0TW9kZSwgJ0NvbG9yIFNjaGVtZTogRGFyayBNb2RlJywgJ1BhZ2Ugc3R5bGluZyB3aWxsIGJlIGVpdGhlciBsaWdodCBvciBkYXJrJywgZmFsc2UgLyppZiB3YW50IHRvIHVzZSBzeXN0ZW0gcHJlZjogKHdpbmRvdy5tYXRjaE1lZGlhICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGxpZ2h0KScpLm1hdGNoZXMpKi8sIHVzZVVybFBhcmFtcywgKGlzTGlnaHRNb2RlLCBzZXR0aW5nKSA9PiB7XG4gICAgICAgICAgICBzZXR0aW5nLmxhYmVsID0gYENvbG9yIFNjaGVtZTogJHtpc0xpZ2h0TW9kZSA/ICdMaWdodCcgOiAnRGFyayd9IE1vZGVgO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgVUkgd3JhcHBlciBjb21wb25lbnRzIGZvciBlYWNoIHNldHRpbmcgZWxlbWVudCBpbiBjb25maWcuXG4gICAgICogQHBhcmFtIGNvbmZpZyAtXG4gICAgICovXG4gICAgcmVnaXN0ZXJTZXR0aW5nc1VJQ29tcG9uZW50cyhjb25maWcpIHtcbiAgICAgICAgZm9yIChjb25zdCBzZXR0aW5nIG9mIGNvbmZpZy5nZXRGbGFncygpKSB7XG4gICAgICAgICAgICB0aGlzLmZsYWdzVWkuc2V0KHNldHRpbmcuaWQsIG5ldyBTZXR0aW5nVUlGbGFnKHNldHRpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHNldHRpbmcgb2YgQXJyYXkuZnJvbSh0aGlzLmN1c3RvbUZsYWdzLnZhbHVlcygpKSkge1xuICAgICAgICAgICAgdGhpcy5mbGFnc1VpLnNldChzZXR0aW5nLmlkLCBuZXcgU2V0dGluZ1VJRmxhZyhzZXR0aW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzZXR0aW5nIG9mIGNvbmZpZy5nZXRUZXh0U2V0dGluZ3MoKSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0UGFyYW1ldGVyc1VpLnNldChzZXR0aW5nLmlkLCBuZXcgU2V0dGluZ1VJVGV4dChzZXR0aW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzZXR0aW5nIG9mIGNvbmZpZy5nZXROdW1lcmljU2V0dGluZ3MoKSkge1xuICAgICAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVyc1VpLnNldChzZXR0aW5nLmlkLCBuZXcgU2V0dGluZ1VJTnVtYmVyKHNldHRpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHNldHRpbmcgb2YgY29uZmlnLmdldE9wdGlvblNldHRpbmdzKCkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uUGFyYW1ldGVyc1VpLnNldChzZXR0aW5nLmlkLCBuZXcgU2V0dGluZ1VJT3B0aW9uKHNldHRpbmcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlIERPTSBlbGVtZW50cyBmb3IgYSBzZXR0aW5ncyBzZWN0aW9uIHdpdGggYSBoZWFkaW5nLlxuICAgICAqIEBwYXJhbSBzZXR0aW5nc0VsZW0gLSBUaGUgcGFyZW50IGNvbnRhaW5lciBmb3Igb3VyIERPTSBlbGVtZW50cy5cbiAgICAgKiBAcGFyYW0gc2VjdGlvbkhlYWRpbmcgLSBUaGUgaGVhZGluZyBlbGVtZW50IHRvIGdvIGludG8gdGhlIHNlY3Rpb24uXG4gICAgICogQHJldHVybnMgVGhlIGNvbnN0cnVjdGVkIERPTSBlbGVtZW50IGZvciB0aGUgc2VjdGlvbi5cbiAgICAgKi9cbiAgICBidWlsZFNlY3Rpb25XaXRoSGVhZGluZyhzZXR0aW5nc0VsZW0sIHNlY3Rpb25IZWFkaW5nKSB7XG4gICAgICAgIC8vIG1ha2Ugc2VjdGlvbiBlbGVtZW50XG4gICAgICAgIGNvbnN0IHNlY3Rpb25FbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VjdGlvbicpO1xuICAgICAgICBzZWN0aW9uRWxlbS5jbGFzc0xpc3QuYWRkKCdzZXR0aW5nc0NvbnRhaW5lcicpO1xuICAgICAgICAvLyBtYWtlIHNlY3Rpb24gaGVhZGluZ1xuICAgICAgICBjb25zdCBwc1NldHRpbmdzSGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHBzU2V0dGluZ3NIZWFkZXIuY2xhc3NMaXN0LmFkZCgnc2V0dGluZ3NIZWFkZXInKTtcbiAgICAgICAgcHNTZXR0aW5nc0hlYWRlci5jbGFzc0xpc3QuYWRkKCdzZXR0aW5ncy10ZXh0Jyk7XG4gICAgICAgIHBzU2V0dGluZ3NIZWFkZXIudGV4dENvbnRlbnQgPSBzZWN0aW9uSGVhZGluZztcbiAgICAgICAgLy8gYWRkIHNlY3Rpb24gYW5kIGhlYWRpbmcgdG8gcGFyZW50IHNldHRpbmdzIGVsZW1lbnRcbiAgICAgICAgc2VjdGlvbkVsZW0uYXBwZW5kQ2hpbGQocHNTZXR0aW5nc0hlYWRlcik7XG4gICAgICAgIHNldHRpbmdzRWxlbS5hcHBlbmRDaGlsZChzZWN0aW9uRWxlbSk7XG4gICAgICAgIHJldHVybiBzZWN0aW9uRWxlbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0dXAgZmxhZ3Mgd2l0aCB0aGVpciBkZWZhdWx0IHZhbHVlcyBhbmQgYWRkIHRoZW0gdG8gdGhlIGBDb25maWcuZmxhZ3NgIG1hcC5cbiAgICAgKiBAcGFyYW0gc2V0dGluZ3NFbGVtIC0gLSBUaGUgZWxlbWVudCB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgaW5kaXZpZHVhbCBzZXR0aW5ncyBzZWN0aW9ucywgZmxhZ3MsIGFuZCBzbyBvbi5cbiAgICAgKi9cbiAgICBwb3B1bGF0ZVNldHRpbmdzRWxlbWVudChzZXR0aW5nc0VsZW0sIHNldHRpbmdzQ29uZmlnKSB7XG4gICAgICAgIGlmIChpc1NlY3Rpb25FbmFibGVkKHNldHRpbmdzQ29uZmlnLCBTZXR0aW5nc1NlY3Rpb25zLlBpeGVsU3RyZWFtaW5nKSkge1xuICAgICAgICAgICAgLyogU2V0dXAgYWxsIFBpeGVsIFN0cmVhbWluZyBzcGVjaWZpYyBzZXR0aW5ncyAqL1xuICAgICAgICAgICAgY29uc3QgcHNTZXR0aW5nc1NlY3Rpb24gPSB0aGlzLmJ1aWxkU2VjdGlvbldpdGhIZWFkaW5nKHNldHRpbmdzRWxlbSwgU2V0dGluZ3NTZWN0aW9ucy5QaXhlbFN0cmVhbWluZyk7XG4gICAgICAgICAgICAvLyBtYWtlIHNldHRpbmdzIHNob3cgdXAgaW4gRE9NXG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgVGV4dFBhcmFtZXRlcnMuU2lnbmFsbGluZ1NlcnZlclVybCkpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGV4dChwc1NldHRpbmdzU2VjdGlvbiwgdGhpcy50ZXh0UGFyYW1ldGVyc1VpLmdldChUZXh0UGFyYW1ldGVycy5TaWduYWxsaW5nU2VydmVyVXJsKSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgRmxhZ3MuQnJvd3NlclNlbmRPZmZlcikpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nRmxhZyhwc1NldHRpbmdzU2VjdGlvbiwgdGhpcy5mbGFnc1VpLmdldChGbGFncy5Ccm93c2VyU2VuZE9mZmVyKSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgT3B0aW9uUGFyYW1ldGVycy5TdHJlYW1lcklkKSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdPcHRpb24ocHNTZXR0aW5nc1NlY3Rpb24sIHRoaXMub3B0aW9uUGFyYW1ldGVyc1VpLmdldChPcHRpb25QYXJhbWV0ZXJzLlN0cmVhbWVySWQpKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBGbGFncy5BdXRvQ29ubmVjdCkpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nRmxhZyhwc1NldHRpbmdzU2VjdGlvbiwgdGhpcy5mbGFnc1VpLmdldChGbGFncy5BdXRvQ29ubmVjdCkpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIEZsYWdzLkF1dG9QbGF5VmlkZW8pKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ0ZsYWcocHNTZXR0aW5nc1NlY3Rpb24sIHRoaXMuZmxhZ3NVaS5nZXQoRmxhZ3MuQXV0b1BsYXlWaWRlbykpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIEZsYWdzLlVzZU1pYykpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nRmxhZyhwc1NldHRpbmdzU2VjdGlvbiwgdGhpcy5mbGFnc1VpLmdldChGbGFncy5Vc2VNaWMpKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBGbGFncy5Vc2VDYW1lcmEpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ0ZsYWcocHNTZXR0aW5nc1NlY3Rpb24sIHRoaXMuZmxhZ3NVaS5nZXQoRmxhZ3MuVXNlQ2FtZXJhKSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgRmxhZ3MuU3RhcnRWaWRlb011dGVkKSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdGbGFnKHBzU2V0dGluZ3NTZWN0aW9uLCB0aGlzLmZsYWdzVWkuZ2V0KEZsYWdzLlN0YXJ0VmlkZW9NdXRlZCkpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIEZsYWdzLklzUXVhbGl0eUNvbnRyb2xsZXIpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ0ZsYWcocHNTZXR0aW5nc1NlY3Rpb24sIHRoaXMuZmxhZ3NVaS5nZXQoRmxhZ3MuSXNRdWFsaXR5Q29udHJvbGxlcikpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIEZsYWdzLkZvcmNlTW9ub0F1ZGlvKSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdGbGFnKHBzU2V0dGluZ3NTZWN0aW9uLCB0aGlzLmZsYWdzVWkuZ2V0KEZsYWdzLkZvcmNlTW9ub0F1ZGlvKSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgRmxhZ3MuRm9yY2VUVVJOKSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdGbGFnKHBzU2V0dGluZ3NTZWN0aW9uLCB0aGlzLmZsYWdzVWkuZ2V0KEZsYWdzLkZvcmNlVFVSTikpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIEZsYWdzLlN1cHByZXNzQnJvd3NlcktleXMpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ0ZsYWcocHNTZXR0aW5nc1NlY3Rpb24sIHRoaXMuZmxhZ3NVaS5nZXQoRmxhZ3MuU3VwcHJlc3NCcm93c2VyS2V5cykpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIEZsYWdzLkFGS0RldGVjdGlvbikpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nRmxhZyhwc1NldHRpbmdzU2VjdGlvbiwgdGhpcy5mbGFnc1VpLmdldChGbGFncy5BRktEZXRlY3Rpb24pKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBGbGFncy5XYWl0Rm9yU3RyZWFtZXIpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ0ZsYWcocHNTZXR0aW5nc1NlY3Rpb24sIHRoaXMuZmxhZ3NVaS5nZXQoRmxhZ3MuV2FpdEZvclN0cmVhbWVyKSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgTnVtZXJpY1BhcmFtZXRlcnMuQUZLVGltZW91dFNlY3MpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ051bWVyaWMocHNTZXR0aW5nc1NlY3Rpb24sIHRoaXMubnVtZXJpY1BhcmFtZXRlcnNVaS5nZXQoTnVtZXJpY1BhcmFtZXRlcnMuQUZLVGltZW91dFNlY3MpKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBOdW1lcmljUGFyYW1ldGVycy5BRktDb3VudGRvd25TZWNzKSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdOdW1lcmljKHBzU2V0dGluZ3NTZWN0aW9uLCB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzVWkuZ2V0KE51bWVyaWNQYXJhbWV0ZXJzLkFGS0NvdW50ZG93blNlY3MpKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBOdW1lcmljUGFyYW1ldGVycy5NYXhSZWNvbm5lY3RBdHRlbXB0cykpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nTnVtZXJpYyhwc1NldHRpbmdzU2VjdGlvbiwgdGhpcy5udW1lcmljUGFyYW1ldGVyc1VpLmdldChOdW1lcmljUGFyYW1ldGVycy5NYXhSZWNvbm5lY3RBdHRlbXB0cykpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIE51bWVyaWNQYXJhbWV0ZXJzLlN0cmVhbWVyQXV0b0pvaW5JbnRlcnZhbCkpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nTnVtZXJpYyhwc1NldHRpbmdzU2VjdGlvbiwgdGhpcy5udW1lcmljUGFyYW1ldGVyc1VpLmdldChOdW1lcmljUGFyYW1ldGVycy5TdHJlYW1lckF1dG9Kb2luSW50ZXJ2YWwpKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBOdW1lcmljUGFyYW1ldGVycy5LZWVwYWxpdmVEZWxheSkpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nTnVtZXJpYyhwc1NldHRpbmdzU2VjdGlvbiwgdGhpcy5udW1lcmljUGFyYW1ldGVyc1VpLmdldChOdW1lcmljUGFyYW1ldGVycy5LZWVwYWxpdmVEZWxheSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NlY3Rpb25FbmFibGVkKHNldHRpbmdzQ29uZmlnLCBTZXR0aW5nc1NlY3Rpb25zLlVJKSkge1xuICAgICAgICAgICAgLyogU2V0dXAgYWxsIHZpZXcvdWkgcmVsYXRlZCBzZXR0aW5ncyB1bmRlciB0aGlzIHNlY3Rpb24gKi9cbiAgICAgICAgICAgIGNvbnN0IHZpZXdTZXR0aW5nc1NlY3Rpb24gPSB0aGlzLmJ1aWxkU2VjdGlvbldpdGhIZWFkaW5nKHNldHRpbmdzRWxlbSwgU2V0dGluZ3NTZWN0aW9ucy5VSSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgRmxhZ3MuTWF0Y2hWaWV3cG9ydFJlc29sdXRpb24pKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ0ZsYWcodmlld1NldHRpbmdzU2VjdGlvbiwgdGhpcy5mbGFnc1VpLmdldChGbGFncy5NYXRjaFZpZXdwb3J0UmVzb2x1dGlvbikpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIEZsYWdzLkhvdmVyaW5nTW91c2VNb2RlKSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdGbGFnKHZpZXdTZXR0aW5nc1NlY3Rpb24sIHRoaXMuZmxhZ3NVaS5nZXQoRmxhZ3MuSG92ZXJpbmdNb3VzZU1vZGUpKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBFeHRyYUZsYWdzLkxpZ2h0TW9kZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nRmxhZyh2aWV3U2V0dGluZ3NTZWN0aW9uLCB0aGlzLmZsYWdzVWkuZ2V0KEV4dHJhRmxhZ3MuTGlnaHRNb2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2VjdGlvbkVuYWJsZWQoc2V0dGluZ3NDb25maWcsIFNldHRpbmdzU2VjdGlvbnMuSW5wdXQpKSB7XG4gICAgICAgICAgICAvKiBTZXR1cCBhbGwgZW5jb2RlciByZWxhdGVkIHNldHRpbmdzIHVuZGVyIHRoaXMgc2VjdGlvbiAqL1xuICAgICAgICAgICAgY29uc3QgaW5wdXRTZXR0aW5nc1NlY3Rpb24gPSB0aGlzLmJ1aWxkU2VjdGlvbldpdGhIZWFkaW5nKHNldHRpbmdzRWxlbSwgU2V0dGluZ3NTZWN0aW9ucy5JbnB1dCk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgRmxhZ3MuS2V5Ym9hcmRJbnB1dCkpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nRmxhZyhpbnB1dFNldHRpbmdzU2VjdGlvbiwgdGhpcy5mbGFnc1VpLmdldChGbGFncy5LZXlib2FyZElucHV0KSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgRmxhZ3MuTW91c2VJbnB1dCkpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nRmxhZyhpbnB1dFNldHRpbmdzU2VjdGlvbiwgdGhpcy5mbGFnc1VpLmdldChGbGFncy5Nb3VzZUlucHV0KSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgRmxhZ3MuRmFrZU1vdXNlV2l0aFRvdWNoZXMpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ0ZsYWcoaW5wdXRTZXR0aW5nc1NlY3Rpb24sIHRoaXMuZmxhZ3NVaS5nZXQoRmxhZ3MuRmFrZU1vdXNlV2l0aFRvdWNoZXMpKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBGbGFncy5Ub3VjaElucHV0KSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdGbGFnKGlucHV0U2V0dGluZ3NTZWN0aW9uLCB0aGlzLmZsYWdzVWkuZ2V0KEZsYWdzLlRvdWNoSW5wdXQpKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBGbGFncy5HYW1lcGFkSW5wdXQpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ0ZsYWcoaW5wdXRTZXR0aW5nc1NlY3Rpb24sIHRoaXMuZmxhZ3NVaS5nZXQoRmxhZ3MuR2FtZXBhZElucHV0KSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgRmxhZ3MuWFJDb250cm9sbGVySW5wdXQpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ0ZsYWcoaW5wdXRTZXR0aW5nc1NlY3Rpb24sIHRoaXMuZmxhZ3NVaS5nZXQoRmxhZ3MuWFJDb250cm9sbGVySW5wdXQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTZWN0aW9uRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgU2V0dGluZ3NTZWN0aW9ucy5FbmNvZGVyKSkge1xuICAgICAgICAgICAgLyogU2V0dXAgYWxsIGVuY29kZXIgcmVsYXRlZCBzZXR0aW5ncyB1bmRlciB0aGlzIHNlY3Rpb24gKi9cbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXJTZXR0aW5nc1NlY3Rpb24gPSB0aGlzLmJ1aWxkU2VjdGlvbldpdGhIZWFkaW5nKHNldHRpbmdzRWxlbSwgU2V0dGluZ3NTZWN0aW9ucy5FbmNvZGVyKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWluKSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdOdW1lcmljKGVuY29kZXJTZXR0aW5nc1NlY3Rpb24sIHRoaXMubnVtZXJpY1BhcmFtZXRlcnNVaS5nZXQoTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1pbikpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNYXgpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ051bWVyaWMoZW5jb2RlclNldHRpbmdzU2VjdGlvbiwgdGhpcy5udW1lcmljUGFyYW1ldGVyc1VpLmdldChOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWF4KSk7XG4gICAgICAgICAgICBjb25zdCBwcmVmZXJyZWRDb2RlY09wdGlvbiA9IHRoaXMub3B0aW9uUGFyYW1ldGVyc1VpLmdldChPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZENvZGVjKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZENvZGVjKSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdPcHRpb24oZW5jb2RlclNldHRpbmdzU2VjdGlvbiwgdGhpcy5vcHRpb25QYXJhbWV0ZXJzVWkuZ2V0KE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkQ29kZWMpKTtcbiAgICAgICAgICAgIGlmIChwcmVmZXJyZWRDb2RlY09wdGlvbiAmJlxuICAgICAgICAgICAgICAgIFsuLi5wcmVmZXJyZWRDb2RlY09wdGlvbi5zZWxlY3Rvci5vcHRpb25zXVxuICAgICAgICAgICAgICAgICAgICAubWFwKChvKSA9PiBvLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAuaW5jbHVkZXMoJ09ubHkgYXZhaWxhYmxlIG9uIENocm9tZScpKSB7XG4gICAgICAgICAgICAgICAgcHJlZmVycmVkQ29kZWNPcHRpb24uZGlzYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkUXVhbGl0eSkpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nT3B0aW9uKGVuY29kZXJTZXR0aW5nc1NlY3Rpb24sIHRoaXMub3B0aW9uUGFyYW1ldGVyc1VpLmdldChPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZFF1YWxpdHkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTZWN0aW9uRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgU2V0dGluZ3NTZWN0aW9ucy5XZWJSVEMpKSB7XG4gICAgICAgICAgICAvKiBTZXR1cCBhbGwgd2VicnRjIHJlbGF0ZWQgc2V0dGluZ3MgdW5kZXIgdGhpcyBzZWN0aW9uICovXG4gICAgICAgICAgICBjb25zdCB3ZWJydGNTZXR0aW5nc1NlY3Rpb24gPSB0aGlzLmJ1aWxkU2VjdGlvbldpdGhIZWFkaW5nKHNldHRpbmdzRWxlbSwgU2V0dGluZ3NTZWN0aW9ucy5XZWJSVEMpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ0ZQUykpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nTnVtZXJpYyh3ZWJydGNTZXR0aW5nc1NlY3Rpb24sIHRoaXMubnVtZXJpY1BhcmFtZXRlcnNVaS5nZXQoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDRlBTKSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWluQml0cmF0ZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nTnVtZXJpYyh3ZWJydGNTZXR0aW5nc1NlY3Rpb24sIHRoaXMubnVtZXJpY1BhcmFtZXRlcnNVaS5nZXQoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWluQml0cmF0ZSkpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01heEJpdHJhdGUpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ051bWVyaWMod2VicnRjU2V0dGluZ3NTZWN0aW9uLCB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzVWkuZ2V0KE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01heEJpdHJhdGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBTZXR0aW5nVGV4dCBlbGVtZW50IHRvIGEgcGFydGljdWxhciBzZXR0aW5ncyBzZWN0aW9uIGluIHRoZSBET00gYW5kIHJlZ2lzdGVycyB0aGF0IHRleHQgaW4gdGhlIHRleHQgc2V0dGluZ3MgbWFwLlxuICAgICAqIEBwYXJhbSBzZXR0aW5nc1NlY3Rpb24gLSBUaGUgc2V0dGluZ3Mgc2VjdGlvbiBIVE1MIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHNldHRpbmdUZXh0IC0gVGhlIHRleHR1YWwgc2V0dGluZ3Mgb2JqZWN0LlxuICAgICAqL1xuICAgIGFkZFNldHRpbmdUZXh0KHNldHRpbmdzU2VjdGlvbiwgc2V0dGluZ1RleHQpIHtcbiAgICAgICAgaWYgKHNldHRpbmdUZXh0KSB7XG4gICAgICAgICAgICBzZXR0aW5nc1NlY3Rpb24uYXBwZW5kQ2hpbGQoc2V0dGluZ1RleHQucm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy50ZXh0UGFyYW1ldGVyc1VpLnNldChzZXR0aW5nVGV4dC5zZXR0aW5nLmlkLCBzZXR0aW5nVGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgU2V0dGluZ0ZsYWcgZWxlbWVudCB0byBhIHBhcnRpY3VsYXIgc2V0dGluZ3Mgc2VjdGlvbiBpbiB0aGUgRE9NIGFuZCByZWdpc3RlcnMgdGhhdCBmbGFnIGluIHRoZSBDb25maWcuZmxhZyBtYXAuXG4gICAgICogQHBhcmFtIHNldHRpbmdzU2VjdGlvbiAtIFRoZSBzZXR0aW5ncyBzZWN0aW9uIEhUTUwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gc2V0dGluZ0ZsYWcgLSBUaGUgc2V0dGluZ3MgZmxhZyBvYmplY3QuXG4gICAgICovXG4gICAgYWRkU2V0dGluZ0ZsYWcoc2V0dGluZ3NTZWN0aW9uLCBzZXR0aW5nRmxhZykge1xuICAgICAgICBpZiAoc2V0dGluZ0ZsYWcpIHtcbiAgICAgICAgICAgIHNldHRpbmdzU2VjdGlvbi5hcHBlbmRDaGlsZChzZXR0aW5nRmxhZy5yb290RWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmZsYWdzVWkuc2V0KHNldHRpbmdGbGFnLnNldHRpbmcuaWQsIHNldHRpbmdGbGFnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBudW1lcmljIHNldHRpbmcgZWxlbWVudCB0byBhIHBhcnRpY3VsYXIgc2V0dGluZ3Mgc2VjdGlvbiBpbiB0aGUgRE9NIGFuZCByZWdpc3RlcnMgdGhhdCBmbGFnIGluIHRoZSBDb25maWcubnVtZXJpY1BhcmFtZXRlcnMgbWFwLlxuICAgICAqIEBwYXJhbSBzZXR0aW5nc1NlY3Rpb24gLSBUaGUgc2V0dGluZ3Mgc2VjdGlvbiBIVE1MIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHNldHRpbmdGbGFnIC0gVGhlIHNldHRpbmdzIGZsYWcgb2JqZWN0LlxuICAgICAqL1xuICAgIGFkZFNldHRpbmdOdW1lcmljKHNldHRpbmdzU2VjdGlvbiwgc2V0dGluZykge1xuICAgICAgICBpZiAoc2V0dGluZykge1xuICAgICAgICAgICAgc2V0dGluZ3NTZWN0aW9uLmFwcGVuZENoaWxkKHNldHRpbmcucm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVyc1VpLnNldChzZXR0aW5nLnNldHRpbmcuaWQsIHNldHRpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBlbnVtIGJhc2VkIHNldHRpbmdzIGVsZW1lbnQgdG8gYSBwYXJ0aWN1bGFyIHNldHRpbmdzIHNlY3Rpb24gaW4gdGhlIERPTSBhbmQgcmVnaXN0ZXJzIHRoYXQgZmxhZyBpbiB0aGUgQ29uZmlnLmVudW1QYXJhbWV0ZXJzIG1hcC5cbiAgICAgKiBAcGFyYW0gc2V0dGluZ3NTZWN0aW9uIC0gVGhlIHNldHRpbmdzIHNlY3Rpb24gSFRNTCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSBzZXR0aW5nRmxhZyAtIFRoZSBzZXR0aW5ncyBmbGFnIG9iamVjdC5cbiAgICAgKi9cbiAgICBhZGRTZXR0aW5nT3B0aW9uKHNldHRpbmdzU2VjdGlvbiwgc2V0dGluZykge1xuICAgICAgICBpZiAoc2V0dGluZykge1xuICAgICAgICAgICAgc2V0dGluZ3NTZWN0aW9uLmFwcGVuZENoaWxkKHNldHRpbmcucm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25QYXJhbWV0ZXJzVWkuc2V0KHNldHRpbmcuc2V0dGluZy5pZCwgc2V0dGluZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25TZXR0aW5nc0NoYW5nZWQoeyBkYXRhOiB7IGlkLCB0YXJnZXQsIHR5cGUgfSB9KSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnZmxhZycpIHtcbiAgICAgICAgICAgIGNvbnN0IF9pZCA9IGlkO1xuICAgICAgICAgICAgY29uc3QgX3RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmcgPSB0aGlzLmZsYWdzVWkuZ2V0KF9pZCk7XG4gICAgICAgICAgICBpZiAoc2V0dGluZykge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nLmZsYWcgIT09IF90YXJnZXQuZmxhZykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nLmZsYWcgPSBfdGFyZ2V0LmZsYWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nLmxhYmVsICE9PSBfdGFyZ2V0LmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmcubGFiZWwgPSBfdGFyZ2V0LmxhYmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29uc3QgX2lkID0gaWQ7XG4gICAgICAgICAgICBjb25zdCBfdGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZyA9IHRoaXMubnVtZXJpY1BhcmFtZXRlcnNVaS5nZXQoX2lkKTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmcubnVtYmVyICE9PSBfdGFyZ2V0Lm51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nLm51bWJlciA9IF90YXJnZXQubnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZy5sYWJlbCAhPT0gX3RhcmdldC5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nLmxhYmVsID0gX3RhcmdldC5sYWJlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBjb25zdCBfaWQgPSBpZDtcbiAgICAgICAgICAgIGNvbnN0IF90YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nID0gdGhpcy50ZXh0UGFyYW1ldGVyc1VpLmdldChfaWQpO1xuICAgICAgICAgICAgaWYgKHNldHRpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZy50ZXh0ICE9PSBfdGFyZ2V0LnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZy50ZXh0ID0gX3RhcmdldC50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZy5sYWJlbCAhPT0gX3RhcmdldC5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nLmxhYmVsID0gX3RhcmdldC5sYWJlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ29wdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IF9pZCA9IGlkO1xuICAgICAgICAgICAgY29uc3QgX3RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmcgPSB0aGlzLm9wdGlvblBhcmFtZXRlcnNVaS5nZXQoX2lkKTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdWlPcHRpb25zID0gc2V0dGluZy5vcHRpb25zO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldE9wdGlvbnMgPSBfdGFyZ2V0Lm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKHVpT3B0aW9ucy5sZW5ndGggIT09IHRhcmdldE9wdGlvbnMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgICF1aU9wdGlvbnMuZXZlcnkoKHZhbHVlKSA9PiB0YXJnZXRPcHRpb25zLmluY2x1ZGVzKHZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZy5vcHRpb25zID0gX3RhcmdldC5vcHRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZy5zZWxlY3RlZCAhPT0gX3RhcmdldC5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nLnNlbGVjdGVkID0gX3RhcmdldC5zZWxlY3RlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmcubGFiZWwgIT09IF90YXJnZXQubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZy5sYWJlbCA9IF90YXJnZXQubGFiZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiB0aGUgZmxhZyBpcyB0b2dnbGVkLlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgZmxhZy5cbiAgICAgKiBAcGFyYW0gb25DaGFuZ2VMaXN0ZW5lciAtIFRoZSBjYWxsYmFjayB0byBmaXJlIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuXG4gICAgICovXG4gICAgYWRkQ3VzdG9tRmxhZ09uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihpZCwgb25DaGFuZ2VMaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy5jdXN0b21GbGFncy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbUZsYWdzLmdldChpZCkub25DaGFuZ2UgPSBvbkNoYW5nZUxpc3RlbmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbGFiZWwgZm9yIHRoZSBmbGFnLlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgZmxhZy5cbiAgICAgKiBAcGFyYW0gbGFiZWwgLSBUaGUgbmV3IGxhYmVsIHRvIHVzZSBmb3IgdGhlIGZsYWcuXG4gICAgICovXG4gICAgc2V0Q3VzdG9tRmxhZ0xhYmVsKGlkLCBsYWJlbCkge1xuICAgICAgICBpZiAoIXRoaXMuY3VzdG9tRmxhZ3MuaGFzKGlkKSkge1xuICAgICAgICAgICAgTG9nZ2VyLldhcm5pbmcoYENhbm5vdCBzZXQgbGFiZWwgZm9yIGZsYWcgY2FsbGVkICR7aWR9IC0gaXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIENvbmZpZy5mbGFncyBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbUZsYWdzLmdldChpZCkubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3NVaS5nZXQoaWQpLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgY29uZmlndXJhdGlvbiBmbGFnIHdoaWNoIGhhcyB0aGUgZ2l2ZW4gaWQuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIHVuaXF1ZSBpZCBmb3IgdGhlIGZsYWcuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZmxhZyBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGlzQ3VzdG9tRmxhZ0VuYWJsZWQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tRmxhZ3MuZ2V0KGlkKS5mbGFnO1xuICAgIH1cbiAgICBkaXNhYmxlU2V0dGluZyhpZCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmIChpc0ZsYWdJZChpZCkpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuZmxhZ3NVaS5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzYWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTnVtZXJpY0lkKGlkKSkge1xuICAgICAgICAgICAgKF9iID0gdGhpcy5udW1lcmljUGFyYW1ldGVyc1VpLmdldChpZCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNUZXh0SWQoaWQpKSB7XG4gICAgICAgICAgICAoX2MgPSB0aGlzLnRleHRQYXJhbWV0ZXJzVWkuZ2V0KGlkKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRpc2FibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09wdGlvbklkKGlkKSkge1xuICAgICAgICAgICAgKF9kID0gdGhpcy5vcHRpb25QYXJhbWV0ZXJzVWkuZ2V0KGlkKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmRpc2FibGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbmFibGVTZXR0aW5nKGlkKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgaWYgKGlzRmxhZ0lkKGlkKSkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5mbGFnc1VpLmdldChpZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbmFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc051bWVyaWNJZChpZCkpIHtcbiAgICAgICAgICAgIChfYiA9IHRoaXMubnVtZXJpY1BhcmFtZXRlcnNVaS5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZW5hYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNUZXh0SWQoaWQpKSB7XG4gICAgICAgICAgICAoX2MgPSB0aGlzLnRleHRQYXJhbWV0ZXJzVWkuZ2V0KGlkKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmVuYWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT3B0aW9uSWQoaWQpKSB7XG4gICAgICAgICAgICAoX2QgPSB0aGlzLm9wdGlvblBhcmFtZXRlcnNVaS5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZW5hYmxlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25maWdVSS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhIHNldHRpbmcgdGhhdCBoYXMgYSB0ZXh0IGxhYmVsLCBhbiBhcmJpdHJhcnkgc2V0dGluZyB2YWx1ZSBpdCBzdG9yZXMsIGFuIGEgSFRNTCBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyB0aGlzIHNldHRpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXR0aW5nVUlCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5nKSB7XG4gICAgICAgIHRoaXMuX3NldHRpbmcgPSBzZXR0aW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgc2V0dGluZyBjb21wb25lbnQuXG4gICAgICovXG4gICAgZ2V0IHNldHRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBSZXR1cm4gb3IgY3JlYXRlcyBhIEhUTUwgZWxlbWVudCB0aGF0IHJlcHJlc2VudHMgdGhpcyBzZXR0aW5nIGluIHRoZSBET00uXG4gICAgICovXG4gICAgZ2V0IHJvb3RFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290RWxlbWVudDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXR0aW5nVUlCYXNlLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBTZXR0aW5nVUlCYXNlIH0gZnJvbSAnLi9TZXR0aW5nVUlCYXNlJztcbmV4cG9ydCBjbGFzcyBTZXR0aW5nVUlGbGFnIGV4dGVuZHMgU2V0dGluZ1VJQmFzZSB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZykge1xuICAgICAgICBzdXBlcihzZXR0aW5nKTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IHNldHRpbmcubGFiZWw7XG4gICAgICAgIHRoaXMuZmxhZyA9IHNldHRpbmcuZmxhZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIHNldHRpbmcgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGdldCBzZXR0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZztcbiAgICB9XG4gICAgZ2V0IHNldHRpbmdzVGV4dEVsZW0oKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2V0dGluZ3NUZXh0RWxlbSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NUZXh0RWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NUZXh0RWxlbS5pbm5lclRleHQgPSB0aGlzLnNldHRpbmcuX2xhYmVsO1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NUZXh0RWxlbS50aXRsZSA9IHRoaXMuc2V0dGluZy5kZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3NUZXh0RWxlbTtcbiAgICB9XG4gICAgZ2V0IGNoZWNrYm94KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NoZWNrYm94KSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICB0aGlzLl9jaGVja2JveC50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgICAgICAgIC8vIEJsb2NrIGtleXByZXNzL3VwL2Rvd24gcHJvcG9nYXRpb24gZnJvbSB0ZXh0IGZpZWxkIHR5cGluZyBnb2luZyB0byBVRVxuICAgICAgICAgICAgdGhpcy5fY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrYm94O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBSZXR1cm4gb3IgY3JlYXRlcyBhIEhUTUwgZWxlbWVudCB0aGF0IHJlcHJlc2VudHMgdGhpcyBzZXR0aW5nIGluIHRoZSBET00uXG4gICAgICovXG4gICAgZ2V0IHJvb3RFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgcm9vdCBkaXYgd2l0aCBcInNldHRpbmdcIiBjc3MgY2xhc3NcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5pZCA9IHRoaXMuc2V0dGluZy5pZDtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3NldHRpbmcnKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBkaXYgZWxlbWVudCB0byBjb250YWluIG91ciBzZXR0aW5nJ3MgdGV4dFxuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zZXR0aW5nc1RleHRFbGVtKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBsYWJlbCBlbGVtZW50IHRvIHdyYXAgb3V0IGlucHV0IHR5cGVcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXJMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgICB3cmFwcGVyTGFiZWwuY2xhc3NMaXN0LmFkZCgndGdsLXN3aXRjaCcpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQod3JhcHBlckxhYmVsKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBpbnB1dCB0eXBlPWNoZWNrYm94XG4gICAgICAgICAgICB0aGlzLmNoZWNrYm94LnRpdGxlID0gdGhpcy5zZXR0aW5nLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgdGhpcy5jaGVja2JveC5jbGFzc0xpc3QuYWRkKCd0Z2wnKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tib3guY2xhc3NMaXN0LmFkZCgndGdsLWZsYXQnKTtcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgc2xpZGVyLmNsYXNzTGlzdC5hZGQoJ3RnbC1zbGlkZXInKTtcbiAgICAgICAgICAgIHdyYXBwZXJMYWJlbC5hcHBlbmRDaGlsZCh0aGlzLmNoZWNrYm94KTtcbiAgICAgICAgICAgIHdyYXBwZXJMYWJlbC5hcHBlbmRDaGlsZChzbGlkZXIpO1xuICAgICAgICAgICAgLy8gc2V0dXAgb24gY2hhbmdlIGZyb20gY2hlY2tib3hcbiAgICAgICAgICAgIHRoaXMuY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmcuZmxhZyAhPT0gdGhpcy5jaGVja2JveC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZy5mbGFnID0gdGhpcy5jaGVja2JveC5jaGVja2VkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmcudXBkYXRlVVJMUGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RFbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHNldHRpbmcncyBzdG9yZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIGluVmFsdWUgLSBUaGUgbmV3IHZhbHVlIGZvciB0aGUgc2V0dGluZy5cbiAgICAgKi9cbiAgICBzZXQgZmxhZyhpblZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tib3guY2hlY2tlZCA9IGluVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB2YWx1ZVxuICAgICAqL1xuICAgIGdldCBmbGFnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja2JveC5jaGVja2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxhYmVsIHRleHQgZm9yIHRoZSBzZXR0aW5nLlxuICAgICAqIEBwYXJhbSBsYWJlbCAtIHNldHRpbmcgbGFiZWwuXG4gICAgICovXG4gICAgc2V0IGxhYmVsKGluTGFiZWwpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5nc1RleHRFbGVtLmlubmVyVGV4dCA9IGluTGFiZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBsYWJlbFxuICAgICAqL1xuICAgIGdldCBsYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3NUZXh0RWxlbS5pbm5lclRleHQ7XG4gICAgfVxuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tib3guZGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBlbmFibGUoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tib3guZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXR0aW5nVUlGbGFnLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2Zyb250ZW5kLXVlNS42JztcbmltcG9ydCB7IFNldHRpbmdVSUJhc2UgfSBmcm9tICcuL1NldHRpbmdVSUJhc2UnO1xuLyoqXG4gKiBBIG51bWJlciBzcGlubmVyIHdpdGggYSB0ZXh0IGxhYmVsIGJlc2lkZSBpdC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNldHRpbmdVSU51bWJlciBleHRlbmRzIFNldHRpbmdVSUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmcpIHtcbiAgICAgICAgc3VwZXIoc2V0dGluZyk7XG4gICAgICAgIHRoaXMubGFiZWwgPSB0aGlzLnNldHRpbmcubGFiZWw7XG4gICAgICAgIHRoaXMubnVtYmVyID0gdGhpcy5zZXR0aW5nLm51bWJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIHNldHRpbmcgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGdldCBzZXR0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZztcbiAgICB9XG4gICAgZ2V0IHNldHRpbmdzVGV4dEVsZW0oKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2V0dGluZ3NUZXh0RWxlbSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NUZXh0RWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5nc1RleHRFbGVtLmlubmVyVGV4dCA9IHRoaXMuc2V0dGluZy5sYWJlbDtcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzVGV4dEVsZW0udGl0bGUgPSB0aGlzLnNldHRpbmcuZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzVGV4dEVsZW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSFRNTElucHV0RWxlbWVudCBmb3IgdGhlIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBnZXQgc3Bpbm5lcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zcGlubmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9zcGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgIHRoaXMuX3NwaW5uZXIudHlwZSA9ICdudW1iZXInO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZy5taW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NwaW5uZXIubWluID0gdGhpcy5zZXR0aW5nLm1pbi50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZy5tYXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NwaW5uZXIubWF4ID0gdGhpcy5zZXR0aW5nLm1heC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3Bpbm5lci52YWx1ZSA9IHRoaXMuc2V0dGluZy5udW1iZXIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuX3NwaW5uZXIudGl0bGUgPSB0aGlzLnNldHRpbmcuZGVzY3JpcHRpb247XG4gICAgICAgICAgICB0aGlzLl9zcGlubmVyLmNsYXNzTGlzdC5hZGQoJ2Zvcm0tY29udHJvbCcpO1xuICAgICAgICAgICAgLy8gQmxvY2sga2V5cHJlc3MvdXAvZG93biBwcm9wb2dhdGlvbiBmcm9tIHRleHQgZmllbGQgdHlwaW5nIGdvaW5nIHRvIFVFXG4gICAgICAgICAgICB0aGlzLnNwaW5uZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zcGlubmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3Bpbm5lci5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3Bpbm5lcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgUmV0dXJuIG9yIGNyZWF0ZXMgYSBIVE1MIGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIHRoaXMgc2V0dGluZyBpbiB0aGUgRE9NLlxuICAgICAqL1xuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIHJvb3QgZGl2IHdpdGggXCJzZXR0aW5nXCIgY3NzIGNsYXNzXG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2V0dGluZycpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZm9ybS1ncm91cCcpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIGRpdiBlbGVtZW50IHRvIGNvbnRhaW4gb3VyIHNldHRpbmcncyB0ZXh0XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNldHRpbmdzVGV4dEVsZW0pO1xuICAgICAgICAgICAgLy8gY3JlYXRlIGxhYmVsIGVsZW1lbnQgdG8gd3JhcCBvdXQgaW5wdXQgdHlwZVxuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zcGlubmVyKTtcbiAgICAgICAgICAgIC8vIHNldHVwIG9uY2hhbmdlXG4gICAgICAgICAgICB0aGlzLnNwaW5uZXIub25jaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dEVsZW0gPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBOdW1iZXIucGFyc2VGbG9hdChpbnB1dEVsZW0udmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4ocGFyc2VkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5XYXJuaW5nKGBDb3VsZCBub3QgcGFyc2UgdmFsdWUgY2hhbmdlIGludG8gYSB2YWxpZCBudW1iZXIgLSB2YWx1ZSB3YXMgJHtpbnB1dEVsZW0udmFsdWV9LCByZXNldHRpbmcgdmFsdWUgdG8gJHt0aGlzLnNldHRpbmcubWlufWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5nLm51bWJlciAhPT0gdGhpcy5zZXR0aW5nLm1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nLm51bWJlciA9IHRoaXMuc2V0dGluZy5taW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmcubnVtYmVyICE9PSBwYXJzZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nLm51bWJlciA9IHBhcnNlZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nLnVwZGF0ZVVSTFBhcmFtcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbnVtYmVyIGluIHRoZSBzcGlubmVyICh3aWxsIGJlIGNsYW1wZWQgd2l0aGluIHJhbmdlKS5cbiAgICAgKi9cbiAgICBzZXQgbnVtYmVyKG5ld051bWJlcikge1xuICAgICAgICB0aGlzLnNwaW5uZXIudmFsdWUgPSB0aGlzLnNldHRpbmcuY2xhbXAobmV3TnVtYmVyKS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdmFsdWVcbiAgICAgKi9cbiAgICBnZXQgbnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gK3RoaXMuc3Bpbm5lci52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsYWJlbCB0ZXh0IGZvciB0aGUgc2V0dGluZy5cbiAgICAgKiBAcGFyYW0gbGFiZWwgLSBzZXR0aW5nIGxhYmVsLlxuICAgICAqL1xuICAgIHNldCBsYWJlbChpbkxhYmVsKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NUZXh0RWxlbS5pbm5lclRleHQgPSBpbkxhYmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgbGFiZWxcbiAgICAgKi9cbiAgICBnZXQgbGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzVGV4dEVsZW0uaW5uZXJUZXh0O1xuICAgIH1cbiAgICBkaXNhYmxlKCkge1xuICAgICAgICB0aGlzLnNwaW5uZXIuZGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBlbmFibGUoKSB7XG4gICAgICAgIHRoaXMuc3Bpbm5lci5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNldHRpbmdVSU51bWJlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgU2V0dGluZ1VJQmFzZSB9IGZyb20gJy4vU2V0dGluZ1VJQmFzZSc7XG5leHBvcnQgY2xhc3MgU2V0dGluZ1VJT3B0aW9uIGV4dGVuZHMgU2V0dGluZ1VJQmFzZSB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZykge1xuICAgICAgICBzdXBlcihzZXR0aW5nKTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IHRoaXMuc2V0dGluZy5sYWJlbDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5zZXR0aW5nLm9wdGlvbnM7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnNldHRpbmcuc2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBzZXR0aW5nIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBnZXQgc2V0dGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmc7XG4gICAgfVxuICAgIGdldCBzZWxlY3RvcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdG9yLmNsYXNzTGlzdC5hZGQoJ2Zvcm0tY29udHJvbCcpO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0b3IuY2xhc3NMaXN0LmFkZCgnc2V0dGluZ3Mtb3B0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdG9yO1xuICAgIH1cbiAgICBnZXQgc2V0dGluZ3NUZXh0RWxlbSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zZXR0aW5nc1RleHRFbGVtKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5nc1RleHRFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5nc1RleHRFbGVtLmlubmVyVGV4dCA9IHRoaXMuc2V0dGluZy5sYWJlbDtcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzVGV4dEVsZW0udGl0bGUgPSB0aGlzLnNldHRpbmcuZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzVGV4dEVsZW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbGFiZWwgdGV4dCBmb3IgdGhlIHNldHRpbmcuXG4gICAgICogQHBhcmFtIGxhYmVsIC0gc2V0dGluZyBsYWJlbC5cbiAgICAgKi9cbiAgICBzZXQgbGFiZWwoaW5MYWJlbCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzVGV4dEVsZW0uaW5uZXJUZXh0ID0gaW5MYWJlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGxhYmVsXG4gICAgICovXG4gICAgZ2V0IGxhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc1RleHRFbGVtLmlubmVyVGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgUmV0dXJuIG9yIGNyZWF0ZXMgYSBIVE1MIGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIHRoaXMgc2V0dGluZyBpbiB0aGUgRE9NLlxuICAgICAqL1xuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIHJvb3QgZGl2IHdpdGggXCJzZXR0aW5nXCIgY3NzIGNsYXNzXG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuaWQgPSB0aGlzLnNldHRpbmcuaWQ7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzZXR0aW5nJyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmb3JtLWdyb3VwJyk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgZGl2IGVsZW1lbnQgdG8gY29udGFpbiBvdXIgc2V0dGluZydzIHRleHRcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc2V0dGluZ3NUZXh0RWxlbSk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgbGFiZWwgZWxlbWVudCB0byB3cmFwIG91dCBpbnB1dCB0eXBlXG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQod3JhcHBlckxhYmVsKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBzZWxlY3QgZWxlbWVudFxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rvci50aXRsZSA9IHRoaXMuc2V0dGluZy5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIHdyYXBwZXJMYWJlbC5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdG9yKTtcbiAgICAgICAgICAgIC8vIHNldHVwIG9uIGNoYW5nZSBmcm9tIHNlbGVjdG9yXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yLm9uY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmcuc2VsZWN0ZWQgIT09IHRoaXMuc2VsZWN0b3IudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nLnNlbGVjdGVkID0gdGhpcy5zZWxlY3Rvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nLnVwZGF0ZVVSTFBhcmFtcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBCbG9jayBrZXlwcmVzcy91cC9kb3duIHByb3BvZ2F0aW9uIGZyb20gdGV4dCBmaWVsZCB0eXBpbmcgZ29pbmcgdG8gVUVcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290RWxlbWVudDtcbiAgICB9XG4gICAgc2V0IG9wdGlvbnModmFsdWVzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnNlbGVjdG9yLm9wdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IucmVtb3ZlKGkpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3B0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICAgICAgICBvcHQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIG9wdC5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IuYXBwZW5kQ2hpbGQob3B0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXMuc2VsZWN0b3Iub3B0aW9uc10ubWFwKChvKSA9PiBvLnZhbHVlKTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkKHZhbHVlKSB7XG4gICAgICAgIC8vIEEgdXNlciBtYXkgbm90IHNwZWNpZnkgdGhlIGZ1bGwgcG9zc2libGUgdmFsdWUgc28gd2UgaW5zdGVhZCB1c2UgdGhlIGNsb3Nlc3QgbWF0Y2guXG4gICAgICAgIC8vIGVnID94eHg9SDI2NCB3b3VsZCBzZWxlY3QgJ0gyNjQgbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQ9MTtwYWNrZXRpemF0aW9uLW1vZGU9MTtwcm9maWxlLWxldmVsLWlkPTQyMDAxZidcbiAgICAgICAgY29uc3QgZmlsdGVyZWRMaXN0ID0gdGhpcy5vcHRpb25zLmZpbHRlcigob3B0aW9uKSA9PiBvcHRpb24uaW5kZXhPZih2YWx1ZSkgIT09IC0xKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IudmFsdWUgPSBmaWx0ZXJlZExpc3RbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rvci52YWx1ZTtcbiAgICB9XG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5kaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNldHRpbmdVSU9wdGlvbi5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgU2V0dGluZ1VJQmFzZSB9IGZyb20gJy4vU2V0dGluZ1VJQmFzZSc7XG5leHBvcnQgY2xhc3MgU2V0dGluZ1VJVGV4dCBleHRlbmRzIFNldHRpbmdVSUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmcpIHtcbiAgICAgICAgc3VwZXIoc2V0dGluZyk7XG4gICAgICAgIHRoaXMubGFiZWwgPSB0aGlzLnNldHRpbmcubGFiZWw7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMuc2V0dGluZy50ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgc2V0dGluZyBjb21wb25lbnQuXG4gICAgICovXG4gICAgZ2V0IHNldHRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5nO1xuICAgIH1cbiAgICBnZXQgc2V0dGluZ3NUZXh0RWxlbSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zZXR0aW5nc1RleHRFbGVtKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5nc1RleHRFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5nc1RleHRFbGVtLmlubmVyVGV4dCA9IHRoaXMuc2V0dGluZy5sYWJlbDtcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzVGV4dEVsZW0udGl0bGUgPSB0aGlzLnNldHRpbmcuZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzVGV4dEVsZW07XG4gICAgfVxuICAgIGdldCB0ZXh0Ym94KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHRib3gpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHRib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgdGhpcy5fdGV4dGJveC5jbGFzc0xpc3QuYWRkKCdmb3JtLWNvbnRyb2wnKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHRib3gudHlwZSA9ICd0ZXh0Ym94JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dGJveDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgUmV0dXJuIG9yIGNyZWF0ZXMgYSBIVE1MIGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIHRoaXMgc2V0dGluZyBpbiB0aGUgRE9NLlxuICAgICAqL1xuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIHJvb3QgZGl2IHdpdGggXCJzZXR0aW5nXCIgY3NzIGNsYXNzXG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuaWQgPSB0aGlzLnNldHRpbmcuaWQ7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzZXR0aW5nJyk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgZGl2IGVsZW1lbnQgdG8gY29udGFpbiBvdXIgc2V0dGluZydzIHRleHRcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc2V0dGluZ3NUZXh0RWxlbSk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgbGFiZWwgZWxlbWVudCB0byB3cmFwIG91dCBpbnB1dCB0eXBlXG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQod3JhcHBlckxhYmVsKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBpbnB1dCB0eXBlPWNoZWNrYm94XG4gICAgICAgICAgICB0aGlzLnRleHRib3gudGl0bGUgPSB0aGlzLnNldHRpbmcuZGVzY3JpcHRpb247XG4gICAgICAgICAgICB3cmFwcGVyTGFiZWwuYXBwZW5kQ2hpbGQodGhpcy50ZXh0Ym94KTtcbiAgICAgICAgICAgIC8vIHNldHVwIG9uIGNoYW5nZSBmcm9tIGNoZWNrYm94XG4gICAgICAgICAgICB0aGlzLnRleHRib3guYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5nLnRleHQgIT09IHRoaXMudGV4dGJveC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmcudGV4dCA9IHRoaXMudGV4dGJveC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nLnVwZGF0ZVVSTFBhcmFtcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQmxvY2sga2V5cHJlc3MvdXAvZG93biBwcm9wb2dhdGlvbiBmcm9tIHRleHQgZmllbGQgdHlwaW5nIGdvaW5nIHRvIFVFXG4gICAgICAgICAgICB0aGlzLnRleHRib3guYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50ZXh0Ym94LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudGV4dGJveC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc2V0dGluZydzIHN0b3JlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gaW5WYWx1ZSAtIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBzZXR0aW5nLlxuICAgICAqL1xuICAgIHNldCB0ZXh0KGluVmFsdWUpIHtcbiAgICAgICAgdGhpcy50ZXh0Ym94LnZhbHVlID0gaW5WYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlXG4gICAgICovXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHRib3gudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbGFiZWwgdGV4dCBmb3IgdGhlIHNldHRpbmcuXG4gICAgICogQHBhcmFtIGxhYmVsIC0gc2V0dGluZyBsYWJlbC5cbiAgICAgKi9cbiAgICBzZXQgbGFiZWwoaW5MYWJlbCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzVGV4dEVsZW0uaW5uZXJUZXh0ID0gaW5MYWJlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGxhYmVsXG4gICAgICovXG4gICAgZ2V0IGxhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc1RleHRFbGVtLmlubmVyVGV4dDtcbiAgICB9XG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgdGhpcy50ZXh0Ym94LmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZW5hYmxlKCkge1xuICAgICAgICB0aGlzLnRleHRib3guZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXR0aW5nVUlUZXh0LmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBBY3Rpb25PdmVybGF5IH0gZnJvbSAnLi9BY3Rpb25PdmVybGF5Jztcbi8qKlxuICogU2hvdyBhbiBvdmVybGF5IGZvciB3aGVuIHRoZSBzZXNzaW9uIGlzIHVuYXR0ZW5kZWQsIGl0IGJlZ2lucyBhIGNvdW50ZG93biB0aW1lciwgd2hpY2ggd2hlbiBlbGFwc2VkIHdpbGwgZGlzY29ubmVjdCB0aGUgc3RyZWFtLlxuICovXG5leHBvcnQgY2xhc3MgQUZLT3ZlcmxheSBleHRlbmRzIEFjdGlvbk92ZXJsYXkge1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHJvb3QgZWxlbWVudCBvZiB0aGlzIG92ZXJsYXkuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVJvb3RFbGVtZW50KCkge1xuICAgICAgICBjb25zdCBhZmtPdmVybGF5SHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBhZmtPdmVybGF5SHRtbC5pZCA9ICdhZmtPdmVybGF5JztcbiAgICAgICAgYWZrT3ZlcmxheUh0bWwuY2xhc3NOYW1lID0gJ2NsaWNrYWJsZVN0YXRlJztcbiAgICAgICAgcmV0dXJuIGFma092ZXJsYXlIdG1sO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBjb250ZW50IGVsZW1lbnQgb2YgdGhpcyBvdmVybGF5LCB3aGljaCBjb250YWluIHNvbWUgdGV4dCBmb3IgYW4gYWZrIGNvdW50IGRvd24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUNvbnRlbnRFbGVtZW50KCkge1xuICAgICAgICBjb25zdCBhZmtPdmVybGF5SHRtbElubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGFma092ZXJsYXlIdG1sSW5uZXIuaWQgPSAnYWZrT3ZlcmxheUlubmVyJztcbiAgICAgICAgYWZrT3ZlcmxheUh0bWxJbm5lci5pbm5lckhUTUwgPVxuICAgICAgICAgICAgJzxjZW50ZXI+Tm8gYWN0aXZpdHkgZGV0ZWN0ZWQ8YnI+RGlzY29ubmVjdGluZyBpbiA8c3BhbiBpZD1cImFma0NvdW50RG93bk51bWJlclwiPjwvc3Bhbj4gc2Vjb25kczxicj5DbGljayB0byBjb250aW51ZTxicj48L2NlbnRlcj4nO1xuICAgICAgICByZXR1cm4gYWZrT3ZlcmxheUh0bWxJbm5lcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGFuIEFmayBvdmVybGF5XG4gICAgICogQHBhcmFtIHBhcmVudEVsZW1lbnQgLSB0aGUgZWxlbWVudCB0aGlzIG92ZXJsYXkgd2lsbCBiZSBpbnNlcnRlZCBpbnRvXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iocm9vdERpdikge1xuICAgICAgICBzdXBlcihyb290RGl2LCBBRktPdmVybGF5LmNyZWF0ZVJvb3RFbGVtZW50KCksIEFGS092ZXJsYXkuY3JlYXRlQ29udGVudEVsZW1lbnQoKSk7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGNvdW50IGRvd24gc3BhbnMgbnVtYmVyIGZvciB0aGUgb3ZlcmxheVxuICAgICAqIEBwYXJhbSBjb3VudGRvd24gLSB0aGUgY291bnQgZG93biBudW1iZXIgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgc3BhbiBmb3IgdXBkYXRpbmdcbiAgICAgKi9cbiAgICB1cGRhdGVDb3VudGRvd24oY291bnRkb3duKSB7XG4gICAgICAgIHRoaXMudGV4dEVsZW1lbnQuaW5uZXJIVE1MID0gYDxjZW50ZXI+Tm8gYWN0aXZpdHkgZGV0ZWN0ZWQ8YnI+RGlzY29ubmVjdGluZyBpbiA8c3BhbiBpZD1cImFma0NvdW50RG93bk51bWJlclwiPiR7Y291bnRkb3dufTwvc3Bhbj4gc2Vjb25kczxicj5DbGljayB0byBjb250aW51ZTxicj48L2NlbnRlcj5gO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFGS092ZXJsYXkuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nZnJvbnRlbmQtdWU1LjYnO1xuaW1wb3J0IHsgT3ZlcmxheUJhc2UgfSBmcm9tICcuL0Jhc2VPdmVybGF5Jztcbi8qKlxuICogQ2xhc3MgZm9yIHRoZSBiYXNlIGFjdGlvbiBvdmVybGF5IHN0cnVjdHVyZVxuICovXG5leHBvcnQgY2xhc3MgQWN0aW9uT3ZlcmxheSBleHRlbmRzIE92ZXJsYXlCYXNlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4gYWN0aW9uIG92ZXJsYXlcbiAgICAgKiBAcGFyYW0gcm9vdERpdiAtIHRoZSByb290IGVsZW1lbnQgdGhpcyBvdmVybGF5IHdpbGwgYmUgaW5zZXJ0ZWQgaW50b1xuICAgICAqIEBwYXJhbSByb290RWxlbWVudCAtIHRoZSByb290IGVsZW1lbnQgdGhhdCBpcyB0aGUgb3ZlcmxheVxuICAgICAqIEBwYXJhbSBjb250ZW50RWxlbWVudCAtIGFuIGVsZW1lbnQgdGhhdCBjb250YWlucyB0ZXh0IGZvciB0aGUgYWN0aW9uIG92ZXJsYXlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihyb290RGl2LCByb290RWxlbWVudCwgY29udGVudEVsZW1lbnQpIHtcbiAgICAgICAgc3VwZXIocm9vdERpdiwgcm9vdEVsZW1lbnQsIGNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgdGhpcy5vbkFjdGlvbkNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgLyogZG8gbm90aGluZyAqLyBMb2dnZXIuSW5mbygnRGlkIHlvdSBmb3JnZXQgdG8gc2V0IHRoZSBvbkFjdGlvbiBjYWxsYmFjayBpbiB5b3VyIG92ZXJsYXk/Jyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgdGV4dCBvdmVybGF5cyBpbm5lciB0ZXh0XG4gICAgICogQHBhcmFtIHRleHQgLSB0aGUgdXBkYXRlIHRleHQgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgb3ZlcmxheVxuICAgICAqL1xuICAgIHVwZGF0ZSh0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0ICE9IG51bGwgfHwgdGV4dCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dEVsZW1lbnQuaW5uZXJIVE1MID0gdGV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBtZXRob2QgYXMgYW4gZXZlbnQgZW1pdHRlciBjYWxsYmFja1xuICAgICAqIEBwYXJhbSBjYWxsQmFjayAtIHRoZSBtZXRob2QgdGhhdCBpcyB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZFxuICAgICAqL1xuICAgIG9uQWN0aW9uKGNhbGxCYWNrKSB7XG4gICAgICAgIHRoaXMub25BY3Rpb25DYWxsYmFjayA9IGNhbGxCYWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZSBhbiBldmVudCB0aGF0IGlzIGF0dGFjaGVkIHRvIHRoZSBldmVudCBlbWl0dGVyXG4gICAgICovXG4gICAgYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMub25BY3Rpb25DYWxsYmFjaygpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjdGlvbk92ZXJsYXkuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogQ2xhc3MgZm9yIHRoZSBiYXNlIG92ZXJsYXkgc3RydWN0dXJlXG4gKi9cbmV4cG9ydCBjbGFzcyBPdmVybGF5QmFzZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGFuIG92ZXJsYXlcbiAgICAgKiBAcGFyYW0gcm9vdERpdiAtIHRoZSByb290IGVsZW1lbnQgdGhpcyBvdmVybGF5IHdpbGwgYmUgaW5zZXJ0ZWQgaW50b1xuICAgICAqIEBwYXJhbSByb290RWxlbWVudCAtIHRoZSByb290IGVsZW1lbnQgdGhhdCBpcyB0aGUgb3ZlcmxheVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJvb3REaXYsIHJvb3RFbGVtZW50LCB0ZXh0RWxlbWVudCkge1xuICAgICAgICB0aGlzLnJvb3REaXYgPSByb290RGl2O1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50ID0gcm9vdEVsZW1lbnQ7XG4gICAgICAgIHRoaXMudGV4dEVsZW1lbnQgPSB0ZXh0RWxlbWVudDtcbiAgICAgICAgdGhpcy5yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnRleHRFbGVtZW50KTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHRoaXMucm9vdERpdi5hcHBlbmRDaGlsZCh0aGlzLnJvb3RFbGVtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgb3ZlcmxheVxuICAgICAqL1xuICAgIHNob3coKSB7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuU3RhdGUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgb3ZlcmxheVxuICAgICAqL1xuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnaGlkZGVuU3RhdGUnKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlT3ZlcmxheS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgQWN0aW9uT3ZlcmxheSB9IGZyb20gJy4vQWN0aW9uT3ZlcmxheSc7XG4vKipcbiAqIE92ZXJsYXkgc2hvd24gZHVyaW5nIGNvbm5lY3Rpb24sIGhhcyBhIGJ1dHRvbiB0aGF0IGNhbiBiZSBjbGlja2VkIHRvIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbm5lY3RPdmVybGF5IGV4dGVuZHMgQWN0aW9uT3ZlcmxheSB7XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgcm9vdCBlbGVtZW50IG9mIHRoaXMgb3ZlcmxheS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUm9vdEVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbm5lY3RFbGVtLmlkID0gJ2Nvbm5lY3RPdmVybGF5JztcbiAgICAgICAgY29ubmVjdEVsZW0uY2xhc3NOYW1lID0gJ2NsaWNrYWJsZVN0YXRlJztcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RFbGVtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBjb250ZW50IGVsZW1lbnQgb2YgdGhpcyBvdmVybGF5LCB3aGljaCBjb250YWluIHdoYXRldmVyIGNvbnRlbnQgdGhpcyBlbGVtZW50IGNvbnRhaW5zLCBsaWtlIHRleHQgb3IgYSBidXR0b24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUNvbnRlbnRFbGVtZW50KCkge1xuICAgICAgICBjb25zdCBjb25uZWN0Q29udGVudEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29ubmVjdENvbnRlbnRFbGVtLmlkID0gJ2Nvbm5lY3RCdXR0b24nO1xuICAgICAgICBjb25uZWN0Q29udGVudEVsZW0uaW5uZXJIVE1MID0gJ0NsaWNrIHRvIHN0YXJ0JztcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RDb250ZW50RWxlbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgY29ubmVjdCBvdmVybGF5IHdpdGggYSBjb25uZWN0aW9uIGJ1dHRvbi5cbiAgICAgKiBAcGFyYW0gcGFyZW50RWxlbSAtIHRoZSBwYXJlbnQgZWxlbWVudCB0aGlzIG92ZXJsYXkgd2lsbCBiZSBpbnNlcnRlZCBpbnRvLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudEVsZW0pIHtcbiAgICAgICAgc3VwZXIocGFyZW50RWxlbSwgQ29ubmVjdE92ZXJsYXkuY3JlYXRlUm9vdEVsZW1lbnQoKSwgQ29ubmVjdE92ZXJsYXkuY3JlYXRlQ29udGVudEVsZW1lbnQoKSk7XG4gICAgICAgIC8vIGFkZCB0aGUgbmV3IGV2ZW50IGxpc3RlbmVyXG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbm5lY3RPdmVybGF5LmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBBY3Rpb25PdmVybGF5IH0gZnJvbSAnLi9BY3Rpb25PdmVybGF5Jztcbi8qKlxuICogT3ZlcmxheSBzaG93biBkdXJpbmcgZGlzY29ubmVjdGlvbiwgaGFzIGEgcmVjb25uZWN0aW9uIGVsZW1lbnQgdGhhdCBjYW4gYmUgY2xpY2tlZCB0byByZWNvbm5lY3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBEaXNjb25uZWN0T3ZlcmxheSBleHRlbmRzIEFjdGlvbk92ZXJsYXkge1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHJvb3QgZWxlbWVudCBvZiB0aGlzIG92ZXJsYXkuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVJvb3RFbGVtZW50KCkge1xuICAgICAgICBjb25zdCBkaXNjb25uZWN0T3ZlcmxheUh0bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGlzY29ubmVjdE92ZXJsYXlIdG1sLmlkID0gJ2Rpc2Nvbm5lY3RPdmVybGF5JztcbiAgICAgICAgZGlzY29ubmVjdE92ZXJsYXlIdG1sLmNsYXNzTmFtZSA9ICdjbGlja2FibGVTdGF0ZSc7XG4gICAgICAgIHJldHVybiBkaXNjb25uZWN0T3ZlcmxheUh0bWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGNvbnRlbnQgZWxlbWVudCBvZiB0aGlzIG92ZXJsYXksIHdoaWNoIGNvbnRhaW4gd2hhdGV2ZXIgY29udGVudCB0aGlzIGVsZW1lbnQgY29udGFpbnMsIGxpa2UgdGV4dCBvciBhIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQ29udGVudEVsZW1lbnQoKSB7XG4gICAgICAgIC8vIGJ1aWxkIHRoZSBpbm5lciBodG1sIGNvbnRhaW5lclxuICAgICAgICBjb25zdCBkaXNjb25uZWN0T3ZlcmxheUh0bWxDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGlzY29ubmVjdE92ZXJsYXlIdG1sQ29udGFpbmVyLmlkID0gJ2Rpc2Nvbm5lY3RCdXR0b24nO1xuICAgICAgICBkaXNjb25uZWN0T3ZlcmxheUh0bWxDb250YWluZXIuaW5uZXJIVE1MID0gJ0NsaWNrIFRvIFJlc3RhcnQnO1xuICAgICAgICByZXR1cm4gZGlzY29ubmVjdE92ZXJsYXlIdG1sQ29udGFpbmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBkaXNjb25uZWN0IG92ZXJsYXkgd2l0aCBhIHJldHJ5IGNvbm5lY3Rpb24gaWNvbi5cbiAgICAgKiBAcGFyYW0gcGFyZW50RWxlbSAtIHRoZSBwYXJlbnQgZWxlbWVudCB0aGlzIG92ZXJsYXkgd2lsbCBiZSBpbnNlcnRlZCBpbnRvLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudEVsZW0pIHtcbiAgICAgICAgc3VwZXIocGFyZW50RWxlbSwgRGlzY29ubmVjdE92ZXJsYXkuY3JlYXRlUm9vdEVsZW1lbnQoKSwgRGlzY29ubmVjdE92ZXJsYXkuY3JlYXRlQ29udGVudEVsZW1lbnQoKSk7XG4gICAgICAgIC8vIGFkZCB0aGUgbmV3IGV2ZW50IGxpc3RlbmVyXG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpc2Nvbm5lY3RPdmVybGF5LmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBUZXh0T3ZlcmxheSB9IGZyb20gJy4vVGV4dE92ZXJsYXknO1xuLyoqXG4gKiBHZW5lcmljIG92ZXJsYXkgdXNlZCB0byBzaG93IHRleHR1YWwgZXJyb3IgaW5mbyB0byB0aGUgdXNlci5cbiAqL1xuZXhwb3J0IGNsYXNzIEVycm9yT3ZlcmxheSBleHRlbmRzIFRleHRPdmVybGF5IHtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCByb290IGVsZW1lbnQgb2YgdGhpcyBvdmVybGF5LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSb290RWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgZXJyb3JPdmVybGF5SHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBlcnJvck92ZXJsYXlIdG1sLmlkID0gJ2Vycm9yT3ZlcmxheSc7XG4gICAgICAgIGVycm9yT3ZlcmxheUh0bWwuY2xhc3NOYW1lID0gJ3RleHREaXNwbGF5U3RhdGUnO1xuICAgICAgICByZXR1cm4gZXJyb3JPdmVybGF5SHRtbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgY29udGVudCBlbGVtZW50IG9mIHRoaXMgb3ZlcmxheSwgd2hpY2ggY29udGFpbiB3aGF0ZXZlciBjb250ZW50IHRoaXMgZWxlbWVudCBjb250YWlucywgbGlrZSB0ZXh0IG9yIGEgYnV0dG9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVDb250ZW50RWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgZXJyb3JPdmVybGF5SHRtbElubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGVycm9yT3ZlcmxheUh0bWxJbm5lci5pZCA9ICdlcnJvck92ZXJsYXlJbm5lcic7XG4gICAgICAgIHJldHVybiBlcnJvck92ZXJsYXlIdG1sSW5uZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIGNvbm5lY3Qgb3ZlcmxheSB3aXRoIGEgY29ubmVjdGlvbiBidXR0b24uXG4gICAgICogQHBhcmFtIHBhcmVudEVsZW0gLSB0aGUgcGFyZW50IGVsZW1lbnQgdGhpcyBvdmVybGF5IHdpbGwgYmUgaW5zZXJ0ZWQgaW50by5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRFbGVtKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudEVsZW0sIEVycm9yT3ZlcmxheS5jcmVhdGVSb290RWxlbWVudCgpLCBFcnJvck92ZXJsYXkuY3JlYXRlQ29udGVudEVsZW1lbnQoKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXJyb3JPdmVybGF5LmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBUZXh0T3ZlcmxheSB9IGZyb20gJy4vVGV4dE92ZXJsYXknO1xuLyoqXG4gKiBHZW5lcmljIG92ZXJsYXkgdXNlZCB0byBzaG93IHRleHR1YWwgaW5mbyB0byB0aGUgdXNlci5cbiAqL1xuZXhwb3J0IGNsYXNzIEluZm9PdmVybGF5IGV4dGVuZHMgVGV4dE92ZXJsYXkge1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHJvb3QgZWxlbWVudCBvZiB0aGlzIG92ZXJsYXkuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVJvb3RFbGVtZW50KCkge1xuICAgICAgICBjb25zdCBpbmZvT3ZlcmxheUh0bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaW5mb092ZXJsYXlIdG1sLmlkID0gJ2luZm9PdmVybGF5JztcbiAgICAgICAgaW5mb092ZXJsYXlIdG1sLmNsYXNzTmFtZSA9ICd0ZXh0RGlzcGxheVN0YXRlJztcbiAgICAgICAgcmV0dXJuIGluZm9PdmVybGF5SHRtbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgY29udGVudCBlbGVtZW50IG9mIHRoaXMgb3ZlcmxheSwgd2hpY2ggY29udGFpbiB3aGF0ZXZlciBjb250ZW50IHRoaXMgZWxlbWVudCBjb250YWlucywgbGlrZSB0ZXh0IG9yIGEgYnV0dG9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVDb250ZW50RWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgaW5mb092ZXJsYXlIdG1sSW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaW5mb092ZXJsYXlIdG1sSW5uZXIuaWQgPSAnbWVzc2FnZU92ZXJsYXlJbm5lcic7XG4gICAgICAgIHJldHVybiBpbmZvT3ZlcmxheUh0bWxJbm5lcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgY29ubmVjdCBvdmVybGF5IHdpdGggYSBjb25uZWN0aW9uIGJ1dHRvbi5cbiAgICAgKiBAcGFyYW0gcGFyZW50RWxlbSAtIHRoZSBwYXJlbnQgZWxlbWVudCB0aGlzIG92ZXJsYXkgd2lsbCBiZSBpbnNlcnRlZCBpbnRvLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudEVsZW0pIHtcbiAgICAgICAgc3VwZXIocGFyZW50RWxlbSwgSW5mb092ZXJsYXkuY3JlYXRlUm9vdEVsZW1lbnQoKSwgSW5mb092ZXJsYXkuY3JlYXRlQ29udGVudEVsZW1lbnQoKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5mb092ZXJsYXkuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IEFjdGlvbk92ZXJsYXkgfSBmcm9tICcuL0FjdGlvbk92ZXJsYXknO1xuLyoqXG4gKiBPdmVybGF5IHNob3duIHdoZW4gc3RyZWFtIGlzIHJlYWR5IHRvIHBsYXkuXG4gKi9cbmV4cG9ydCBjbGFzcyBQbGF5T3ZlcmxheSBleHRlbmRzIEFjdGlvbk92ZXJsYXkge1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHJvb3QgZWxlbWVudCBvZiB0aGlzIG92ZXJsYXkuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVJvb3RFbGVtZW50KCkge1xuICAgICAgICBjb25zdCBwbGF5RWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwbGF5RWxlbS5pZCA9ICdwbGF5T3ZlcmxheSc7XG4gICAgICAgIHBsYXlFbGVtLmNsYXNzTmFtZSA9ICdjbGlja2FibGVTdGF0ZSc7XG4gICAgICAgIHJldHVybiBwbGF5RWxlbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgY29udGVudCBlbGVtZW50IG9mIHRoaXMgb3ZlcmxheSwgd2hpY2ggY29udGFpbiB3aGF0ZXZlciBjb250ZW50IHRoaXMgZWxlbWVudCBjb250YWlucywgbGlrZSB0ZXh0IG9yIGEgYnV0dG9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVDb250ZW50RWxlbWVudCgpIHtcbiAgICAgICAgLy8gdG9kbzogY2hhbmdlIHRoaXMgdG8gYW4gc3ZnXG4gICAgICAgIGNvbnN0IHBsYXlPdmVybGF5SHRtbElubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIHBsYXlPdmVybGF5SHRtbElubmVyLmlkID0gJ3BsYXlCdXR0b24nO1xuICAgICAgICBwbGF5T3ZlcmxheUh0bWxJbm5lci5zcmMgPVxuICAgICAgICAgICAgJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBUEVBQUFENUNBWUFBQUQybU5Oa0FBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBWmRFVllkRk52Wm5SM1lYSmxBSEJoYVc1MExtNWxkQ0EwTGpBdU1qSHhJR21WQUFBU2drbEVRVlI0WHUyZEM3QmRWWDJIcVVDQ0lSQVNDUGpBRklRUkVCUkJCU1JZYkZPdDhsSXJGVVdSRnFYV3NUNXdiSXRVcUZXczBLcUlNUEtvWUVXcFJTMDZLRGpTMUJlVkZrVlFiQ3crd0NmaUF3R2hDS1dQOVB1WnRVMjR1VGU1OXp6MjJZL3ZtL25Ha1h0ejdqbHJyOStzZGZaZWEvMDNXYjE2OVF0eEdXNjJpWWkwRDhMN05id1lqOEVkY2RQeUl4RnBBNFQyUC9GLzhVYThDSS9HaFBuWHlxK0lTSk1ockFseHhYOWhSdVlMOFNoOFNQazFFV2txQkhYZEVGZmNnNnZ3M2ZoczNLYjh1b2cwRFFJNlhZZ3I4ck92WXNKOE9NNHYvMHhFbWtJSjZvYjRQOHpJZkFOZWdDdlFNSXMwQlFLNXNSQlhKTXkvd0l6TTUrQnlYRkJlUmtRbUJVR2NiWWpYNVM1TW1NL0FBM0NMOG5JaVVqY0VjSkFRVjl5Qlg4YS93U2VpejVoRjZvYmdEUlBpa0dmTUNmT1g4RFRjdTd5MGlOUUJvUnMyeEJYL2czZGl3dndtM0tuOENSRVpKNFJ0VkNHdXFNS2N1OWtuNHhKMDlaZkl1Q0Jnb3c1eHlKM3NUTE56QXl3cndGNkoyNk5oRmhrMUJHc2NJVjZYaFBsdXZBNlB4eDNLbnhhUlVVQ294aDNpaW9RNXo1bi9CWS9GSmVVdGlNZ3dFS2E2UWx5Uk1OK0huOEhuNFpibHJZaklJQkNpdWtNYzhwMjVXczZaTUQrenZCMFJtU3NFYUJJaG5rcmV3NVY0RUhyQ2lNaGNLQUZxQ3YrTmwrSit1QkM5bXkyeU1RaEtrMEpja2UvTTc4R3N5MDZZSDFUZXJvaE1oWUEwTWNRVlA4Tno4VURjQ2wyYkxUSVZndEhrRUZkOEQ4L0UvWEZyZEdRV3FTQVFiUWh4eUtPcG0vQjAzQWM5TWtna0VJYTJoTGdpTjc4UzVsUHgwYmdJdlFFbS9ZVUF0QzNFRlFuenpmZ251RGM2elpaK1FzZHZhNGpYNVN2NGF0d1hIWm1sWDlEaHV4RGlrQzJRbjhkWFlVYm1SZVVqaW5RYk9udFhRbHlSVFJhZndsZGd3cnhWK2FnaTNZUk8zclVRVi93Y1YrTEw4REhveVp6U1RlamNYUTF4UmM3L3VoeXpsM2t2M0x4OGRKRnVRS2Z1ZW9oRG5qRm5aUDRvL2o3bTBaUUg0RXMzb0RQM0ljUVYyZjZZTUYrQ09aamdVZWlaMmRKdTZNUjlDdkc2M0lMdng0ek1DZk84MGlRaTdZTE8yOWNRVjN3YjM0c3BzcjRydW1CRTJnV2R0dThoRGxuOTlTMU1YZVlYNE02bGVVU2FEeDNXRUs4bFJkWVQ1bFIvelBsZm5zd3B6WWVPYW9qWEo0Y1NmQjNQdytmZ3R1ZzBXNW9KbmRNUVQwL3VaR2VhWFpWeWZUWnVWNXBOcERuUU1RM3h4c2swTzlVZno4WkRjZHZTZkNLVGh3NXBpR2RQMmlvRjQ5NkpUMGMzV2Nqa0tSMVQ1a1lXakNUTTc4RGZRaGVNeU9TZ0F4cml3Y2gzNWxSL3ZBYlB3T1hvelMrcEh6cWVJUjZPYWwxMnd2eDJmQnk2eVVMcWd3NW5pRWREd3B5UitWcE1rZlhzbUhJcHA0d2ZPcG9oSGoyMzRSZndGTndEbldiTCtLQ0RHZUx4a0pINXAzZzF2ZzUzSzAwdU1scm9YSVo0dkdUQlNNSjhGZVprem1XbDZVVkdBNTNLRU5mRC9aaXlOQ215bnZPL0ZwZExJREljZENaRFhDOFptZk9kK2Qvd0plalpYekljZENKRFhEOTV4cHdqZG5QK1Y3NHpINFd1L3BMQm9QTVk0c21TTU4rRktiSitCQnBtbVJ0MEdrUGNEQkxtdS9GamVBaTZsRk5tQjUzRkVEZUhUTFB6YUNvajgwZHdCZnFNV1RZTW5jUVFONWVzQVBzdzdsY3VsOGo2MEVFTWNmUEpEYkQzWVU3bDNLeGNPcEUxMENrTWNUdklWRHZmbWMvRTNYRUx0UHFqR09LV2toVmdwK0dlbUREN3ZiblAwQUVNY1h0SmtmVTM0R054QVRveTl4RXV2Q0Z1UDZ2d0pNeU9xWVhsMGtwZjRLSWI0bTVRbmN5WlRSYXBaR0dZK3dJWDJ4QjNpM3Z4T3N3bWkxM1FhWGJYNFFJYjRtNlNZM2EvaU1kaDdtWWI1cTdDaFRYRTNhWGFhTEVTcTdyTVc1WkxMMTJCaTJxSSs4RTllRGttekx1aFllNEtYRXhEM0I4eU10K09sK0tMMENMclhZQ0xhSWo3UjhKOEsxNkNSNlBMT2RzTUY4OFE5NWZzbVBvUlhvelB4ZHpOZHZWWDIrQ2lHV0xKemErRU9YV1pqOFNkMEFQdzJ3SVh5eEJMcVBZeTM0TG5ZOEs4REExejArRWlHV0taU2dKOUk3NExVMlI5UjNTYTNWUzRPSVpZWnFKYXlua1dwc2o2dzB1M2tTYkJoVEhFc2pIdXd4c3dwVndQdzZXbCswZ1Q0SUlZWXBrTm1XS25yMXlQcWY1NEtHNVZ1cEZNa25KaFJHWkx3cHpWWDZuKytEWjhHcnBqYXBKd0FReXhERUxDbkIxVHFXVHgxL2dVZEdTZUJEUzhJWlpCU1pCanp2NzZQUDRWSG9TR3VVNW9jRU1zb3lCaFRzRzRWSDk4SXg2QTgwczNrM0ZDUXh0aUdTVlpNUElUL0N3bXpQdWh6NWpIQ1Exc2lHVWNaQ2xud3Z4cFBBWDNMRjFPUmcyTmE0aGxYR1NLblFVakNmTm44UFg0Q055MGREOFpCVFNvSVpaeGt6QlhJL1BuOEFUTXVtekRQQXBvU0VNc2RaRXc1enZ6RHpIVDdKZGp3dXpaWDhOQUF4cGltUVNaWmlmTW44VGo4YUdsUzhwY29mRU1zVXlLak13NWxUT25qSHdjYzJUUWt0STFaYmJRYUlaWUprM0NuRTBXR1ptdndPZWgrNWhuQzQxbGlLVXBWQ056d3Z3SlBCeTkrYlV4YUNSRExFMGpZYjRmVS8weDAreUQ4Y0dseThwVWFCeERMRTBrUWE3Q2ZDZm1NTDhEMFNOMnAwS2pHR0pwT2dsenRXZ2toL2s5Q1QxaXQ0TEdNTVRTRmhMbUxCckozZXh6Y0ovU2pmc05EV0dJcFkwazBEL0FNL0dScFR2M0V4ckFFRXVicVZhQW5ZNUxzWDkzcy9uUWhsaTZRTFVGOG5XWUkzYm5ZVCtXYy9KQkRiRjBoZXFPOWpmd2xmaEluSS9kRGpNZjBCQkxGMG1ZcjhOc3NraU5xUzJ3bTJIbWd4bGk2VEo1enB3amcvNFFkOGJ1TFJyaFF4bGk2UU01WmpkSEJoMkgrYzdjblVVamZCaERMSDBoVSt5N2NDVStIN09YZVY2SlFudmhReGhpNlJzSmMwYm15L0JaK01zYllDVVM3WU0zYjRpbHJ5VE0yUUw1UVV6QnVIeG5idDgwbXpkdGlFVldyNzROTDhLVWNrMlI5ZmFNekx4WlF5eXlob3pNV2NwNUlmNHVKc3pOUDV5QU4ybUlSUjVJVm4vZGpPZmhFZGpzdy94NGM0WllaSHJ5alBrbVBCc1B3WWVWMkRRTDNwZ2hGcG1aVExGelpGRENuTHJNejhEdHNUa2JMWGd6aGxoazR5VE0yY3U4Q3JOaktpTnp3ano1T2xPOENVTXNNamNTNXF6TGZndW15UHIySlU2VGdUZGdpRVVHb3lxeW5yck12NDJUT1RPYlAyeUlSUVluMCt3czVid2FVOHIxTjNIckVxOTY0QThhWXBIaFNaanZ3QlNNUzVnUHducldaZk9IRExISTZNZ3o1aHl4bTRKeGY0a0g0SGpEekI4d3hDS2pKMkhPTlB1ZjhjOXhIeHpQWG1aZTJCQ0xqSWRNc1dNcVdmd1Rub2lQd2RHT3pMeWdJUllaUHdselZXUHF0YmdYam1iQkNDOWtpRVhxSTgrWXM4bmljbndON2xhaU9EaThpQ0VXcVplTXlsbVhuVENuWUZ4TzV0eXhSSEx1OEk4TnNjaGtTSml6THZ2N21KSDVwYmdZNTdaamluOWdpRVVtU3pVeWZ3OVRaUDFZM0xaRWRPUHd5NFpZcEJra3pLbisrQjM4S0I2RjI1V296Z3kvWkloRm1rWENuTE8vdm9zZndwd3lzcWhFZG4zNG9TRVdhU1lKOHk4dzArd1A0R0c0L29JUi9xTWhGbWsyVlpnenpVNllzMk5xN1Q1bS9vOGhGbWtIQ1hPMlB5Yk1GK08rK0NCRExOSXVFdVNzeTg1MzVsdnhaRU1zMGo2cVdzelpKYlhVRUl1MGkxdndyWmhxRlp2NW5WaWtQV1RxZkE1bUY5UUREK2ZqUHhoaWtlYVI3Nzd4ZHJ3QW4xQWl1ejc4MEJDTE5JdnNkTXFCQXFrTnRSdzNYQmVLWHpERUlwTW5vMjdDZXpkZWlrL0dCU1dtRzRaZk5NUWlreVBoelhycFZHWE02UjhyY0c3bFZma0hobGlrZmhMZTdGektvNktWK0h1NDVtN3pYT0VmR21LUmVza2U0b1QzazNnTWJsbmlPQmk4Z0NFV3FZZU12RC9HSy9GNDNLSEVjRGg0SVVNc01sNXl3K3BIbUxPb1g0YURIOFV6SGJ5Z0lSWVpEL25lbTVIM0tqd0JkOExSVjFIa1JRMnh5R2pKM2VhY05aMWlheWZocitQNDZobno0b1pZWkRSazJwendwaDdUWCtDdU9QNzZ4ZndSUXl3eUhObFZWSVgzVkh4OGlWYzk4QWNOc2NqZ1pKRkd5cHErR2ZmSHdaNzFEZ04vMUJDTHpKMmY0Ny9pV3pCbFRJZDcxanNNL0hGRExESTdjcmY1SHJ3RzM0WUhZNzBGeGFlRE4yR0lSVFpNd3B2amNLN0ZkK0JUY2ZMaHJlRE5HR0tSbWNuSWV6MitFdy9GaFRpM01pdmpoamRraUVYV0owZkVmaFhQd21maTRoS1o1c0diTThRaWE4bjY1bFg0TGt6bGhZZVZxRFFYM3FRaEZsbnpyUGMvOEZ6TXRzQmwyS3hwODB6d1JnMng5SjBjeG40ZXBvQlpsa2pXLzZ4M0dIakRobGo2U0paSTVnVEo5K0R6TWVIZHZNU2lYZkRHRGJIMGlXcGJZTXFnSkx5N1lMdEczcW53QVF5eDlJVnNDN3dFWDRDNzQvaDJGdFVKSDhRUVM5ZkpVVGc1UWZJNDNBUG5sZTdmRGZoQWhsaTZTbzUvL1JpK0dCUGV5YTF2SGlkOE1FTXNYU01IMFgwQ1g0Sjc0Y0xTM2JzSkg5QVFTMWZJVGF2czZmMVZlTEVkejNxSGdROXBpS1h0WkhOQzFqZm5FTHBmVHB1eCsrR3Q0TU1hWW1rcm1UWi9HVitMQ1crM3A4MHp3UWMzeE5JMnNrVHlCc3doZEh0aWM3WUZUZ0lhd0JCTG03Z1JUOEhINGRiWW4ybnpUTkFJaGxqYVFDcmt2d2tUM3R5d0d2OHBrbTJCeGpERTBsUnlva2JPc2pvRFV5RS9ONndNNzFSb0ZFTXNUU1BodlJQZmpZL0dCZWkwZVNab0hFTXNUZUoyL0FEdWcrM2NWVlEzTkpRaGxpYVFrZmNmOFNub3FEc1hhREJETEpNaWo0cnV4Y3Z3YWVqSU93ZzBuQ0dXdXNueXlJVDNDandNKzdsSVkxVFFnSVpZNmlBM3F6THlabWRSU24wZWljMDlRYkpOMEpDR1dNWkp3cHVSOXc3OEVyNFF1N2tsY0ZMUW9JWll4a1hxOU9adWMyb1daWE5DdjVkSGpnc2ExaERMcUtuQ20ycUIyWnp3ME5MZFpCelF3SVpZUmtXbXpUL0RoUGRFM0tWME14a25OTFFobG1ISjk5NkVOd1hIc2praHE2eGNIbGtYTkxZaGxrRkplSFBES2h2eXN6a2g0VzMzOGE5dGhFWTN4REpYOHFnb0d4TVMzdFRwZlN6T0wxMUs2b2JHTjhReVd4TGVMSS9NdERtbFB2ZEhwODJUaG90Z2lHVTJaT1N0d3JzQ1hTTFpGTGdZaGxnMnhGMlljNnpPeHFlakN6V2FCaGZGRU10MHBNajJWekIxZWcvQkphWExTTlBnNGhoaXFjamQ1aXpVU0lYOGxQcDhGaTR0WFVXYUNoZkpFRXRJaGZ3VTJiNFFVMlI3TzNSZmJ4dmdRaG5pZnBPRDE3K0pDVzlLZlM1Rjd6aTNDUzZZSWU0bk9YajlXL2gzZUF3K3ZIUUphUnRjUEVQY0wvS3M5MmE4Q0kvRlhkRnBjNXZoQWhyaS92QjkvSHY4QTN3VXVrU3lDM0FoRFhIMytTbitBeDZQcVpEdkVza3V3UVUxeE4ya09nb25KMGltMUdjMkoyeFJMcnQwQ1M2c0llNFcxYzZpajJORzNsUk9tRmN1dDNRUkxyQWg3ZzRKNzVYNFI3ZzNHdDQrd0lVMnhPMG4wK1pQNGFzd0JjZGMzOXdudU9DR3VMM2tXZS9uOERXNEx5NHFsMVg2QkJmZUVMZVRMK0FKK0FUY0JuM1cyMWU0K0lhNFBlU084OWZ3VC9HSnVBaGRJdGwzNkFTR3VQbGtaOUczOGZXWW8zQXk4aHBlV1FPZHdSQTNseHdCZXhPK0dWUHEwN0luc2o1MERFUGNUTEsrK2UyWWM2d1dvOTk1Wlhyb0hJYTRXZHlLT1Fwbk9XYmF2R201VkNMVFF5Y3h4TTBncDBpZWowL0czTEF5dkRJNzZDeUdlSEpVeCtHOEh3OUV3eXR6aDA1amlDZEREcUs3SEEvQWhlaDNYaGtNT284aHJwZTA5NmZ4ZDlEOXZESThwVlBKK0xrWFA0dlBRYWZNTWpyb1VJWjRmT1E3YjlZM1g0VTV4OG9pMnpKNjZGaUdlUFJrZVdST2tmd2lIb2VlM1N6amd3NW1pRWREUnQxNEQrYnc5WmZqRHFXWlJjWUhIYzBRRDA5MUZFNk9nUDB6OU9CMXFRODZteUVlbkt4dFRuZ3o4cjRCSFhtbGZ1aDRobmp1Skx3cDlabHFnYWZoN3FVNVJlcUhEbWlJWjArbXpWa2VlUU8rRlI5Zm1sRmtjdEFSRGZIc1NKM2VmOGRxWjVHSDBFa3pvRE1hNHBuSjNlYTBUMDdUT0FlenZubEJhVHFSWmxBNnFUeVFoRGRybTFmaEJYZ3dHbDVwSm5ST1E3eVc2amx2d3Z0ZWZBWnVYcHBLcEptVVRpdHJwODBwOVpuMXpROHVUU1RTYk9pc2ZROXhwczJwa0ovd1BoZTNLMDBqMGc3b3RIME44ZjM0ZFh3ZkhvMFcyWloyUXVmdFk0aXpQREtuYWJ3SUg0RWUveXJ0aFE3Y2x4Qm5sZFVQOEJKOE1TYTg3dXVWOWtOSDducUljNFpWd3ZzaGZDa3VROE1yM1lFTzNkVVFaNG5rRC9IRG1GS2ZlNVNQTE5JdDZOeGRESEhDK3hGOEJhYnNpU092ZEJjNmVKZENmQnRlaGdsdmltejdyRmU2RHgyOUN5SE9RbzByOE5XWU9yMFcyWmIrUUlkdmE0aXpSRExQZWxkaTZ2U20xT2ZDOHJGRStnTWR2NDBoem51K0dsTWhmei9jRWowT1Ivb0puYjlOSWM1N3ZRWlB4Q2VoSTY5SUNVYlR5ZG5OMStMSm1QQXVLVzlmUkFoRWswT2NaNzNYWXc2aE93Zzl2MWxrS2dTanFTSE81b1JUOFRkd0ticStXV1E2Q0VlVFFwdzd6bG1vY1RxbVRtL09iN2JvbU1pR0lDUk5DSEdtelQvQnN6Q2xQalB5dXNwS1pEWVFsa21IK01mNHQ3Z2N0MGVuelNKemdkQk1Lc1FKNzBYNFZIVGtGUmtVd2xOM2lGTTU0WU40S0c2TEhrUW5NZ3lFcUs0UTUxbnZwWmp3WnVRMXZDS2pnRERWRWVJcjhYQk1lTDNiTERKS0NOVzRRcHlSOXpvOEFyZEJiMWlKakFQQ05lb1FKN3lwRm5nc3prYzNKb2lNRTBJMnFoRG5XVzhLanYweHVqRkJwQzRJM0RBaHpncXJIRVNYVXAvWjAvdVE4cklpVWhjRWI1QVFKN3ozNFRmd0pOeTV2SnlJMUEwQm5HMklFOXlZc2lmZndUZml6dWgzWHBGSlFnaG5FK0o4MzAxNHY0dXBrTDhyK3FoSXBBa1F4ZzJGT09ITnp6TnRQaGYzUkVkZWtTWlJRanFWVEp0emd1U05lRDRlV0g1ZFJKb0dBWjBhNHJ2eG0zZ2hya0NuelNKTmhwQldJYzcvcGxwZ3dwdWRSWjdkTE5JR0NPdnRKYndYNDJHNHVQeElSTm9Bb1UyZDNpTnhVZmxQSXRJYU50bmsvd0VHQm9NZHBFQ0dIQUFBQUFCSlJVNUVya0pnZ2c9PSc7XG4gICAgICAgIHBsYXlPdmVybGF5SHRtbElubmVyLmFsdCA9ICdTdGFydCBTdHJlYW1pbmcnO1xuICAgICAgICByZXR1cm4gcGxheU92ZXJsYXlIdG1sSW5uZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIGNvbm5lY3Qgb3ZlcmxheSB3aXRoIGEgY29ubmVjdGlvbiBidXR0b24uXG4gICAgICogQHBhcmFtIHBhcmVudEVsZW0gLSB0aGUgcGFyZW50IGVsZW1lbnQgdGhpcyBvdmVybGF5IHdpbGwgYmUgaW5zZXJ0ZWQgaW50by5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRFbGVtKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudEVsZW0sIFBsYXlPdmVybGF5LmNyZWF0ZVJvb3RFbGVtZW50KCksIFBsYXlPdmVybGF5LmNyZWF0ZUNvbnRlbnRFbGVtZW50KCkpO1xuICAgICAgICAvLyBhZGQgdGhlIG5ldyBldmVudCBsaXN0ZW5lclxuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QbGF5T3ZlcmxheS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgT3ZlcmxheUJhc2UgfSBmcm9tICcuL0Jhc2VPdmVybGF5Jztcbi8qKlxuICogQ2xhc3MgZm9yIHRoZSB0ZXh0IG92ZXJsYXkgYmFzZVxuICovXG5leHBvcnQgY2xhc3MgVGV4dE92ZXJsYXkgZXh0ZW5kcyBPdmVybGF5QmFzZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgdGV4dCBvdmVybGF5XG4gICAgICogQHBhcmFtIHJvb3REaXYgLSB0aGUgcm9vdCBlbGVtZW50IHRoaXMgb3ZlcmxheSB3aWxsIGJlIGluc2VydGVkIGludG9cbiAgICAgKiBAcGFyYW0gcm9vdEVsZW1lbnQgLSB0aGUgcm9vdCBlbGVtZW50IHRoYXQgaXMgdGhlIG92ZXJsYXlcbiAgICAgKiBAcGFyYW0gdGV4dEVsZW1lbnQgLSBhbiBlbGVtZW50IHRoYXQgY29udGFpbnMgdGV4dCBmb3IgdGhlIGFjdGlvbiBvdmVybGF5XG4gICAgICovXG4gICAgY29uc3RydWN0b3Iocm9vdERpdiwgcm9vdEVsZW1lbnQsIHRleHRFbGVtZW50KSB7XG4gICAgICAgIHN1cGVyKHJvb3REaXYsIHJvb3RFbGVtZW50LCB0ZXh0RWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgdGV4dCBvdmVybGF5cyBpbm5lciB0ZXh0XG4gICAgICogQHBhcmFtIHRleHQgLSB0aGUgdXBkYXRlIHRleHQgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgb3ZlcmxheVxuICAgICAqL1xuICAgIHVwZGF0ZSh0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0ICE9IG51bGwgfHwgdGV4dCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dEVsZW1lbnQuaW5uZXJIVE1MID0gdGV4dDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHRPdmVybGF5LmpzLm1hcCIsIi8qIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICovXG5pbXBvcnQganNzIGZyb20gJ2pzcyc7XG5pbXBvcnQgZ2xvYmFsIGZyb20gJ2pzcy1wbHVnaW4tZ2xvYmFsJztcbmltcG9ydCBjYW1lbENhc2UgZnJvbSAnanNzLXBsdWdpbi1jYW1lbC1jYXNlJztcbmV4cG9ydCBjbGFzcyBQaXhlbFN0cmVhbWluZ0FwcGxpY2F0aW9uU3R5bGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0TGlnaHRNb2RlUGFsZXR0ZSA9IHtcbiAgICAgICAgICAgICctLWNvbG9yMCc6ICcjZTJlMGRkODAnLFxuICAgICAgICAgICAgJy0tY29sb3IxJzogJyNGRkZGRkYnLFxuICAgICAgICAgICAgJy0tY29sb3IyJzogJyMwMDAwMDAnLFxuICAgICAgICAgICAgJy0tY29sb3IzJzogJyMwNTg1ZmUnLFxuICAgICAgICAgICAgJy0tY29sb3I0JzogJyMzNWIzNTAnLFxuICAgICAgICAgICAgJy0tY29sb3I1JzogJyNmZmFiMDAnLFxuICAgICAgICAgICAgJy0tY29sb3I2JzogJyNlMWUyZGQnLFxuICAgICAgICAgICAgJy0tY29sb3I3JzogJyNjM2M0YmYnXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVmYXVsdERhcmtNb2RlUGFsZXR0ZSA9IHtcbiAgICAgICAgICAgICctLWNvbG9yMCc6ICcjMWQxZjIyZTAnLFxuICAgICAgICAgICAgJy0tY29sb3IxJzogJyMwMDAwMDAnLFxuICAgICAgICAgICAgJy0tY29sb3IyJzogJyNGRkZGRkYnLFxuICAgICAgICAgICAgJy0tY29sb3IzJzogJyMwNTg1ZmUnLFxuICAgICAgICAgICAgJy0tY29sb3I0JzogJyMzNWIzNTAnLFxuICAgICAgICAgICAgJy0tY29sb3I1JzogJyNmZmFiMDAnLFxuICAgICAgICAgICAgJy0tY29sb3I2JzogJyMxZTFkMjInLFxuICAgICAgICAgICAgJy0tY29sb3I3JzogJyMzYzNiNDAnXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0eWxlcyA9IHtcbiAgICAgICAgICAgICc6cm9vdCc6IHtcbiAgICAgICAgICAgICAgICAnLS1jb2xvcjAnOiAnIzFkMWYyMmUwJyxcbiAgICAgICAgICAgICAgICAnLS1jb2xvcjEnOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgICAgJy0tY29sb3IyJzogJyNGRkZGRkYnLFxuICAgICAgICAgICAgICAgICctLWNvbG9yMyc6ICcjMDU4NWZlJyxcbiAgICAgICAgICAgICAgICAnLS1jb2xvcjQnOiAnIzM1YjM1MCcsXG4gICAgICAgICAgICAgICAgJy0tY29sb3I1JzogJyNmZmFiMDAnLFxuICAgICAgICAgICAgICAgICctLWNvbG9yNic6ICcjMWUxZDIyJyxcbiAgICAgICAgICAgICAgICAnLS1jb2xvcjcnOiAnIzNjM2I0MCcsXG4gICAgICAgICAgICAgICAgJy0tY29sb3I4JzogJyM0MTAwOGMnLFxuICAgICAgICAgICAgICAgICctLWNvbG9yOSc6ICcjM2UwMDcwJyxcbiAgICAgICAgICAgICAgICAnLS1jb2xvcjEwJzogJyMyZTAwNTInLFxuICAgICAgICAgICAgICAgICctLWNvbG9yMTEnOiAncmdiYSg2NSwwLDEzOSwxKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLm5vc2VsZWN0Jzoge1xuICAgICAgICAgICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjcGxheWVyVUknOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjdmlkZW9FbGVtZW50UGFyZW50Jzoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndmFyKC0tY29sb3IxKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI3VpRmVhdHVyZXMnOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICB6SW5kZXg6ICczMCcsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgY29sb3I6ICd2YXIoLS1jb2xvcjIpJyxcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5VaVRvb2wgLnRvb2x0aXB0ZXh0Jzoge1xuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnYXV0bycsXG4gICAgICAgICAgICAgICAgY29sb3I6ICd2YXIoLS1jb2xvcjIpJyxcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzE1cHgnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcwcHggMTBweCcsXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogXCInTW9udHNlcnJhdCcsIHNhbnMtc2VyaWZcIixcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzAuNzVyZW0nLFxuICAgICAgICAgICAgICAgIGxldHRlclNwYWNpbmc6ICcwLjc1cHgnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIHRvcDogJzAnLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMjUlKScsXG4gICAgICAgICAgICAgICAgbGVmdDogJzEyNSUnLFxuICAgICAgICAgICAgICAgIHpJbmRleDogJzIwJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcuVWlUb29sOmhvdmVyIC50b29sdGlwdGV4dCc6IHtcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiAndmlzaWJsZScsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndmFyKC0tY29sb3I3KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI2Nvbm5lY3Rpb24gLnRvb2x0aXB0ZXh0Jzoge1xuICAgICAgICAgICAgICAgIHRvcDogJzEyNSUnLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTI1JSknLFxuICAgICAgICAgICAgICAgIGxlZnQ6ICcwJyxcbiAgICAgICAgICAgICAgICB6SW5kZXg6ICcyMCcsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzVweCAxMHB4J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjY29ubmVjdGlvbic6IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICBib3R0b206ICc4JScsXG4gICAgICAgICAgICAgICAgbGVmdDogJzUlJyxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBcIidNaWNocm9tYScsIHNhbnMtc2VyaWZcIixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICczcmVtJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogJzNyZW0nLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdhbGwnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyNzZXR0aW5ncy1wYW5lbCAudG9vbHRpcHRleHQnOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICB0b3A6ICcxMjUlJyxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC01MCUpJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiAnMCcsXG4gICAgICAgICAgICAgICAgekluZGV4OiAnMjAnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc1cHggMTBweCcsXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAnM3B4IHNvbGlkIHZhcigtLWNvbG9yMyknLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnbWF4LWNvbnRlbnQnLFxuICAgICAgICAgICAgICAgIGZhbGxiYWNrczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJ21heC1jb250ZW50J1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6ICczcHggc29saWQgdmFyKC0tY29sb3IzKSdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzVweCAxMHB4J1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6SW5kZXg6ICcyMCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogJzAnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTUwJSknXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogJzEyNSUnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI2NvbnRyb2xzJzoge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIHRvcDogJzMlJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiAnMiUnLFxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IFwiJ01pY2hyb21hJywgc2Fucy1zZXJpZlwiLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdhbGwnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI2NvbnRyb2xzPionOiB7XG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiAnMC41cmVtJyxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc1MCUnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMnJlbScsXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodDogJzEuNzVyZW0nLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcwLjVyZW0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyNjb250cm9scyAjYWRkaXRpb25hbGluZm8nOiB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBcIidNb250c2VycmF0Jywgc2Fucy1zZXJpZlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyNmdWxsc2NyZWVuLWJ0bic6IHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMC42cmVtICFpbXBvcnRhbnQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyNtaW5pbWl6ZUljb24nOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyNzZXR0aW5nc0J0biwgI3N0YXRzQnRuJzoge1xuICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyN1aUZlYXR1cmVzIGJ1dHRvbic6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd2YXIoLS1jb2xvcjcpJyxcbiAgICAgICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQgdmFyKC0tY29sb3I3KScsXG4gICAgICAgICAgICAgICAgY29sb3I6ICd2YXIoLS1jb2xvcjIpJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogJzNyZW0nLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJzNyZW0nLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcwLjVyZW0nLFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI3VpRmVhdHVyZXMgYnV0dG9uOmhvdmVyJzoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3ZhcigtLWNvbG9yMyknLFxuICAgICAgICAgICAgICAgIGJvcmRlcjogJzNweCBzb2xpZCB2YXIoLS1jb2xvcjMpJyxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnMC4yNXMgZWFzZScsXG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6ICcwLjU1cmVtJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nVG9wOiAnMC41NXJlbSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI3VpRmVhdHVyZXMgYnV0dG9uOmFjdGl2ZSc6IHtcbiAgICAgICAgICAgICAgICBib3JkZXI6ICczcHggc29saWQgdmFyKC0tY29sb3IzKScsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndmFyKC0tY29sb3I3KScsXG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6ICcwLjU1cmVtJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nVG9wOiAnMC41NXJlbSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLmJ0bi1mbGF0Jzoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3ZhcigtLWNvbG9yMiknLFxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IFwiJ01vbnRzZXJyYXQnXCIsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgICAgICAgICAgIGJvcmRlcjogJzNweCBzb2xpZCB2YXIoLS1jb2xvcjMpJyxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICcxcmVtJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzAuNzVyZW0nLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAnMC41cmVtJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nUmlnaHQ6ICcwLjVyZW0nLFxuICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLmJ0bi1mbGF0OmhvdmVyJzoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3ZhcigtLWNvbG9yMyknLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICdlYXNlIDAuM3MnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5idG4tZmxhdDpkaXNhYmxlZCc6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAndmFyKC0tY29sb3I3KScsXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICd2YXIoLS1jb2xvcjMpJyxcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3ZhcigtLWNvbG9yMyknLFxuICAgICAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5idG4tZmxhdDphY3RpdmUnOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5idG4tZmxhdDpmb2N1cyc6IHtcbiAgICAgICAgICAgICAgICBvdXRsaW5lOiAnbm9uZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI3VpRmVhdHVyZXMgaW1nJzoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLnBhbmVsLXdyYXAnOiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgdG9wOiAnMCcsXG4gICAgICAgICAgICAgICAgYm90dG9tOiAnMCcsXG4gICAgICAgICAgICAgICAgcmlnaHQ6ICcwJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogJzIwdncnLFxuICAgICAgICAgICAgICAgIG1heFdpZHRoOiAnOTB2dycsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgxMDAlKScsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJy4zcyBlYXNlLW91dCcsXG4gICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ2FsbCcsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dZOiAnYXV0bycsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dYOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd2YXIoLS1jb2xvcjApJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcucGFuZWwtd3JhcC12aXNpYmxlJzoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCUpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcucGFuZWwnOiB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dZOiAnYXV0bycsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzFlbSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI3NldHRpbmdzSGVhZGluZywgI3N0YXRzSGVhZGluZyc6IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzJlbScsXG4gICAgICAgICAgICAgICAgbWFyZ2luQmxvY2tTdGFydDogJzAuNjdlbScsXG4gICAgICAgICAgICAgICAgbWFyZ2luQmxvY2tFbmQ6ICcwLjY3ZW0nLFxuICAgICAgICAgICAgICAgIG1hcmdpbklubGluZVN0YXJ0OiAnMHB4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW5JbmxpbmVFbmQ6ICcwcHgnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcwIDAgMCAycmVtJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjc2V0dGluZ3NDbG9zZSwgI3N0YXRzQ2xvc2UnOiB7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAnMC41cmVtJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nVG9wOiAnMC41cmVtJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAnMC41cmVtJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nUmlnaHQ6ICcwLjVyZW0nLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMmVtJyxcbiAgICAgICAgICAgICAgICBmbG9hdDogJ3JpZ2h0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjc2V0dGluZ3NDbG9zZTphZnRlciwgI3N0YXRzQ2xvc2U6YWZ0ZXInOiB7XG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6ICcwLjVyZW0nLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdcIlxcXFwwMGQ3XCInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyNzZXR0aW5nc0Nsb3NlOmhvdmVyLCAjc3RhdHNDbG9zZTpob3Zlcic6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3ZhcigtLWNvbG9yMyknLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICdlYXNlIDAuM3MnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyNzZXR0aW5nc0NvbnRlbnQsICNzdGF0c0NvbnRlbnQnOiB7XG4gICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogJzJyZW0nLFxuICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiAnMnJlbSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLnNldHRpbmcnOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246ICdyb3cnLFxuICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzAuMTVyZW0gMTBweCAwLjE1cmVtIDEwcHgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5zZXR0aW5ncy10ZXh0Jzoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAndmFyKC0tY29sb3IyKScsXG4gICAgICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ25vcm1hbCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLnNldHRpbmdzLW9wdGlvbic6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcbiAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjY29ubmVjdE92ZXJsYXksICNwbGF5T3ZlcmxheSwgI2luZm9PdmVybGF5LCAjZXJyb3JPdmVybGF5LCAjYWZrT3ZlcmxheSwgI2Rpc2Nvbm5lY3RPdmVybGF5Jzoge1xuICAgICAgICAgICAgICAgIHpJbmRleDogJzMwJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3ZhcigtLWNvbG9yMiknLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMS44ZW0nLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndmFyKC0tY29sb3IxKScsXG4gICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIHRleHRUcmFuc2Zvcm06ICd1cHBlcmNhc2UnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5jbGlja2FibGVTdGF0ZSc6IHtcbiAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy50ZXh0RGlzcGxheVN0YXRlJzoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcuaGlkZGVuU3RhdGUnOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyNwbGF5QnV0dG9uLCAjY29ubmVjdEJ1dHRvbic6IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICB6SW5kZXg6ICczMCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnaW1nI3BsYXlCdXR0b24nOiB7XG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6ICcyNDFweCcsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxMCUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyN1aUludGVyYWN0aW9uJzoge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyNVSUludGVyYWN0aW9uQnV0dG9uQm91bmRhcnknOiB7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzJweCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI1VJSW50ZXJhY3Rpb25CdXR0b24nOiB7XG4gICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLmJ0bi1vdmVybGF5Jzoge1xuICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy50Z2wtc3dpdGNoJzoge1xuICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy50Z2wtc3dpdGNoIC50Z2wnOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy50Z2wsIC50Z2w6YWZ0ZXIsIC50Z2w6YmVmb3JlLCAudGdsICosIC50Z2wgKjphZnRlciwgLnRnbCAqOmJlZm9yZSwgLnRnbCsudGdsLXNsaWRlcic6IHtcbiAgICAgICAgICAgICAgICAnLXdlYmtpdC1ib3gtc2l6aW5nJzogJ2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy50Z2w6Oi1tb3otc2VsZWN0aW9uLCAudGdsOmFmdGVyOjotbW96LXNlbGVjdGlvbiwgLnRnbDpiZWZvcmU6Oi1tb3otc2VsZWN0aW9uLCAudGdsICo6Oi1tb3otc2VsZWN0aW9uLCAudGdsICo6YWZ0ZXI6Oi1tb3otc2VsZWN0aW9uLCAudGdsICo6YmVmb3JlOjotbW96LXNlbGVjdGlvbiwgLnRnbCsudGdsLXNsaWRlcjo6LW1vei1zZWxlY3Rpb24nOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ25vbmUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy50Z2w6OnNlbGVjdGlvbiwgLnRnbDphZnRlcjo6c2VsZWN0aW9uLCAudGdsOmJlZm9yZTo6c2VsZWN0aW9uLCAudGdsICo6OnNlbGVjdGlvbiwgLnRnbCAqOmFmdGVyOjpzZWxlY3Rpb24sIC50Z2wgKjpiZWZvcmU6OnNlbGVjdGlvbiwgLnRnbCsudGdsLXNsaWRlcjo6c2VsZWN0aW9uJzoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICdub25lJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcudGdsLXNsaWRlcic6IHt9LFxuICAgICAgICAgICAgJy50Z2wrLnRnbC1zbGlkZXInOiB7XG4gICAgICAgICAgICAgICAgb3V0bGluZTogJzAnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICc0MHB4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxOHB4JyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgICAgICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLnRnbCsudGdsLXNsaWRlcjphZnRlciwgLnRnbCsudGdsLXNsaWRlcjpiZWZvcmUnOiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnXCJcIicsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICc1MCUnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy50Z2wrLnRnbC1zbGlkZXI6YWZ0ZXInOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogJzAnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy50Z2wrLnRnbC1zbGlkZXI6YmVmb3JlJzoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcudGdsLWZsYXQrLnRnbC1zbGlkZXInOiB7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzJweCcsXG4gICAgICAgICAgICAgICAgJy13ZWJraXQtdHJhbnNpdGlvbic6ICdhbGwgLjJzIGVhc2UnLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICdhbGwgLjJzIGVhc2UnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICd2YXIoLS1jb2xvcjYpJyxcbiAgICAgICAgICAgICAgICBib3JkZXI6ICczcHggc29saWQgdmFyKC0tY29sb3I3KScsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnMmVtJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcudGdsLWZsYXQrLnRnbC1zbGlkZXI6YWZ0ZXInOiB7XG4gICAgICAgICAgICAgICAgJy13ZWJraXQtdHJhbnNpdGlvbic6ICdhbGwgLjJzIGVhc2UnLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICdhbGwgLjJzIGVhc2UnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICd2YXIoLS1jb2xvcjcpJyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnXCJcIicsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnMWVtJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcudGdsLWZsYXQ6Y2hlY2tlZCsudGdsLXNsaWRlcic6IHtcbiAgICAgICAgICAgICAgICBib3JkZXI6ICczcHggc29saWQgdmFyKC0tY29sb3IzKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLnRnbC1mbGF0OmNoZWNrZWQrLnRnbC1zbGlkZXI6YWZ0ZXInOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogJzUwJScsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ3ZhcigtLWNvbG9yMyknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5idG4tYXBwbHknOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrICFpbXBvcnRhbnQnLFxuICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnNDAlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcuZm9ybS1jb250cm9sJzoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3ZhcigtLWNvbG9yNyknLFxuICAgICAgICAgICAgICAgIGJvcmRlcjogJzJweCBzb2xpZCB2YXIoLS1jb2xvcjcpJyxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAndmFyKC0tY29sb3IyKScsXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiAncmlnaHQnLFxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdpbmhlcml0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcuZm9ybS1jb250cm9sOmhvdmVyJzoge1xuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAndmFyKC0tY29sb3I3KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLmZvcm0tZ3JvdXAnOiB7XG4gICAgICAgICAgICAgICAgcGFkZGluZ1RvcDogJzRweCcsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2dyaWQnLFxuICAgICAgICAgICAgICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnM6ICc4MCUgMjAlJyxcbiAgICAgICAgICAgICAgICByb3dHYXA6ICc0cHgnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodDogJzEwcHgnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAnMTBweCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLmZvcm0tZ3JvdXAgbGFiZWwnOiB7XG4gICAgICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ25vcm1hbCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLnNldHRpbmdzQ29udGFpbmVyJzoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206ICcxcHggc29saWQgdmFyKC0tY29sb3I3KScsXG4gICAgICAgICAgICAgICAgcGFkZGluZ1RvcDogJzEwcHgnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b206ICcxMHB4J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcuc2V0dGluZ3NDb250YWluZXI+IDpmaXJzdC1jaGlsZCc6IHtcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6ICc0cHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogJzRweCcsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246ICdyb3cnLFxuICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdiYXNlbGluZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLmNvbGxhcHNlJzoge1xuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAnNSUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyNzdHJlYW1Ub29scyc6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b21SaWdodFJhZGl1czogJzVweCcsXG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tTGVmdFJhZGl1czogJzVweCcsXG4gICAgICAgICAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIHRvcDogJzAnLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAnMiUnLFxuICAgICAgICAgICAgICAgIHpJbmRleDogJzEwMCcsXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAnNHB4IHNvbGlkIHZhcigtLWNvbG91cjgpJyxcbiAgICAgICAgICAgICAgICBib3JkZXJUb3BXaWR0aDogJzBweCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLnNldHRpbmdzSGVhZGVyJzoge1xuICAgICAgICAgICAgICAgIGZvbnRTdHlsZTogJ2l0YWxpYydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI3N0cmVhbVRvb2xzSGVhZGVyJzoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAncm93JyxcbiAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ3NwYWNlLWJldHdlZW4nLFxuICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogJzFweCBzb2xpZCB2YXIoLS1jb2xvdXI4KScsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndmFyKC0tY29sb3I3KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLnN0cmVhbVRvb2xzJzoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3ZhcigtLWNvbG9yMiknLFxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6ICd2YXIoLS1idXR0b25Gb250KScsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2xpZ2h0ZXInLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAndmFyKC0tY29sb3I3KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLnN0cmVhbVRvb2xzLXNob3duPiNzdHJlYW1Ub29sc1NldHRpbmdzLCAuc3RyZWFtVG9vbHMtc2hvd24+I3N0cmVhbVRvb2xzU3RhdHMnOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjc3RyZWFtVG9vbHNUb2dnbGUnOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjcXVhbGl0eVN0YXR1cyc6IHtcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzM3cHgnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodDogJzRweCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLnN2Z0ljb24nOiB7XG4gICAgICAgICAgICAgICAgZmlsbDogJ3ZhcigtLWNvbG9yMiknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5tb2RhbCc6IHtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogJzEwMHZ3JyxcbiAgICAgICAgICAgICAgICBtaW5IZWlnaHQ6ICcxMDB2aCcsXG4gICAgICAgICAgICAgICAgbGVmdDogJzAnLFxuICAgICAgICAgICAgICAgIHRvcDogJzAnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgY29sb3I6ICd2YXIoLS1jb2xvcjIpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcuaW5uZXJNb2RhbCc6IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogJzUwMHB4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICczMDBweCcsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndmFyKC0tY29sb3IwKScsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsXG4gICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnMC43NWVtJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcubW9kYWxCdG5Db250YWluZXInOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246ICdyb3cnLFxuICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYXJvdW5kJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdUb3A6ICcxZW0nLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b206ICcxZW0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5tb2RhbFRleHRBcmVhJzoge1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2xlZnQnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnOTUlJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICByZXNpemU6ICdub25lJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzFyZW0nLFxuICAgICAgICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCB2YXIoLS1jb2xvcjIpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcubW9kYWxUZXh0QXJlYTpmb2N1cy12aXNpYmxlJzoge1xuICAgICAgICAgICAgICAgIG91dGxpbmU6ICdub25lICFpbXBvcnRhbnQnLFxuICAgICAgICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCB2YXIoLS1jb2xvcjMpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcubW9kYWwgLmJ0bi1mbGF0Jzoge1xuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMS4wcmVtJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IGN1c3RvbVN0eWxlcywgbGlnaHRNb2RlUGFsZXR0ZSwgZGFya01vZGVQYWxldHRlLCBqc3NJbnNlcnRpb25Qb2ludCB9ID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XG4gICAgICAgIC8vIE9uZSB0aW1lIHNldHVwIHdpdGggZGVmYXVsdCBwbHVnaW5zIGFuZCBzZXR0aW5ncy5cbiAgICAgICAgY29uc3QganNzT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC8vIEpTUyBoYXMgbWFueSBpbnRlcmVzdGluZyBwbHVnaW5zIHdlIG1heSB3aXNoIHRvIHR1cm4gb25cbiAgICAgICAgICAgIC8vcGx1Z2luczogW2Z1bmN0aW9ucygpLCB0ZW1wbGF0ZSgpLCBnbG9iYWwoKSwgZXh0ZW5kKCksIG5lc3RlZCgpLCBjb21wb3NlKCksIGNhbWVsQ2FzZSgpLCBkZWZhdWx0VW5pdChvcHRpb25zLmRlZmF1bHRVbml0KSwgZXhwYW5kKCksIHZlbmRvclByZWZpeGVyKCksIHByb3BzU29ydCgpXVxuICAgICAgICAgICAgcGx1Z2luczogW2dsb2JhbCgpLCBjYW1lbENhc2UoKV0sXG4gICAgICAgICAgICBpbnNlcnRpb25Qb2ludDoganNzSW5zZXJ0aW9uUG9pbnRcbiAgICAgICAgfTtcbiAgICAgICAganNzLnNldHVwKGpzc09wdGlvbnMpO1xuICAgICAgICB0aGlzLmN1c3RvbVN0eWxlcyA9IGN1c3RvbVN0eWxlcztcbiAgICAgICAgdGhpcy5saWdodE1vZGVQYWxldHRlID0gbGlnaHRNb2RlUGFsZXR0ZSAhPT0gbnVsbCAmJiBsaWdodE1vZGVQYWxldHRlICE9PSB2b2lkIDAgPyBsaWdodE1vZGVQYWxldHRlIDogdGhpcy5kZWZhdWx0TGlnaHRNb2RlUGFsZXR0ZTtcbiAgICAgICAgdGhpcy5kYXJrTW9kZVBhbGV0dGUgPSBkYXJrTW9kZVBhbGV0dGUgIT09IG51bGwgJiYgZGFya01vZGVQYWxldHRlICE9PSB2b2lkIDAgPyBkYXJrTW9kZVBhbGV0dGUgOiB0aGlzLmRlZmF1bHREYXJrTW9kZVBhbGV0dGU7XG4gICAgfVxuICAgIGFwcGx5U3R5bGVTaGVldCgpIHtcbiAgICAgICAgLy8gVG9kbzogcmVmYWN0b3IgY29kZWJhc2UgdG8gdXNlIGpzcyBhdCBhIGNvbXBvbmVudCBsZXZlbCwgY2xhc3NlcyBjYW4gYmUgZ3JhYmJlZCBsaWtlIHNvOlxuICAgICAgICAvL2NvbnN0IHtwaXhlbFN0cmVhbWluZ0NsYXNzZXN9ID0ganNzLmNyZWF0ZVN0eWxlU2hlZXQoc3R5bGVzKS5hdHRhY2goKTtcbiAgICAgICAgLy8gYXR0YWNoIGdlbmVyYXRlZCBzdHlsZSBzaGVldCB0byBwYWdlXG4gICAgICAgIGpzcy5jcmVhdGVTdHlsZVNoZWV0KHtcbiAgICAgICAgICAgICdAZ2xvYmFsJzogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRTdHlsZXMpLCB0aGlzLmN1c3RvbVN0eWxlcylcbiAgICAgICAgfSkuYXR0YWNoKCk7XG4gICAgfVxuICAgIGFwcGx5UGFsZXR0ZShwYWxldHRlKSB7XG4gICAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignOnJvb3QnKTtcbiAgICAgICAgcm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJy0tY29sb3IwJywgcGFsZXR0ZVsnLS1jb2xvcjAnXSk7XG4gICAgICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCctLWNvbG9yMScsIHBhbGV0dGVbJy0tY29sb3IxJ10pO1xuICAgICAgICByb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1jb2xvcjInLCBwYWxldHRlWyctLWNvbG9yMiddKTtcbiAgICAgICAgcm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJy0tY29sb3IzJywgcGFsZXR0ZVsnLS1jb2xvcjMnXSk7XG4gICAgICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCctLWNvbG9yNCcsIHBhbGV0dGVbJy0tY29sb3I0J10pO1xuICAgICAgICByb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1jb2xvcjUnLCBwYWxldHRlWyctLWNvbG9yNSddKTtcbiAgICAgICAgcm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJy0tY29sb3I2JywgcGFsZXR0ZVsnLS1jb2xvcjYnXSk7XG4gICAgICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCctLWNvbG9yNycsIHBhbGV0dGVbJy0tY29sb3I3J10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHBsYXllcnMgY29sb3IgdmFyaWFibGVzXG4gICAgICogQHBhcmFtIGlzTGlnaHRNb2RlIC0gc2hvdWxkIHdlIHVzZSBhIGxpZ2h0IG9yIGRhcmsgY29sb3Igc2NoZW1lXG4gICAgICovXG4gICAgc2V0Q29sb3JNb2RlKGlzTGlnaHRNb2RlKSB7XG4gICAgICAgIGlmIChpc0xpZ2h0TW9kZSkge1xuICAgICAgICAgICAgdGhpcy5hcHBseVBhbGV0dGUodGhpcy5saWdodE1vZGVQYWxldHRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlQYWxldHRlKHRoaXMuZGFya01vZGVQYWxldHRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBpeGVsU3RyZWFtaW5nQXBwbGljYXRpb25TdHlsZXMuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IEZ1bGxTY3JlZW5JY29uIH0gZnJvbSAnLi9GdWxsc2NyZWVuSWNvbic7XG5pbXBvcnQgeyBTZXR0aW5nc0ljb24gfSBmcm9tICcuL1NldHRpbmdzSWNvbic7XG5pbXBvcnQgeyBTdGF0c0ljb24gfSBmcm9tICcuL1N0YXRzSWNvbic7XG5pbXBvcnQgeyBYUkljb24gfSBmcm9tICcuL1hSSWNvbic7XG5pbXBvcnQgeyBXZWJYUkNvbnRyb2xsZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2Zyb250ZW5kLXVlNS42JztcbmltcG9ydCB7IFVJRWxlbWVudENyZWF0aW9uTW9kZSB9IGZyb20gJy4uL1VJL1VJQ29uZmlndXJhdGlvblR5cGVzJztcbi8vIElmIHRoZXJlIGlzbid0IGEgdHlwZSBwcm92aWRlZCwgZGVmYXVsdCBiZWhhdmlvdXIgaXMgdG8gY3JlYXRlIHRoZSBlbGVtZW50LlxuZnVuY3Rpb24gc2hvdWxkQ3JlYXRlQnV0dG9uKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSA9PSB1bmRlZmluZWQgPyB0cnVlIDogdHlwZS5jcmVhdGlvbk1vZGUgPT09IFVJRWxlbWVudENyZWF0aW9uTW9kZS5DcmVhdGVEZWZhdWx0RWxlbWVudDtcbn1cbi8qKlxuICogRWxlbWVudCBjb250YWluaW5nIHZhcmlvdXMgY29udHJvbHMgbGlrZSBzdGF0cywgc2V0dGluZ3MsIGZ1bGxzY3JlZW4uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cm9scyB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IHRoZSBjb250cm9sc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgaWYgKCFjb25maWcgfHwgc2hvdWxkQ3JlYXRlQnV0dG9uKGNvbmZpZy5zdGF0c0J1dHRvblR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRzSWNvbiA9IG5ldyBTdGF0c0ljb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbmZpZyB8fCBzaG91bGRDcmVhdGVCdXR0b24oY29uZmlnLnNldHRpbmdzQnV0dG9uVHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NJY29uID0gbmV3IFNldHRpbmdzSWNvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29uZmlnIHx8IHNob3VsZENyZWF0ZUJ1dHRvbihjb25maWcuZnVsbHNjcmVlbkJ1dHRvblR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLmZ1bGxzY3JlZW5JY29uID0gbmV3IEZ1bGxTY3JlZW5JY29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25maWcgfHwgc2hvdWxkQ3JlYXRlQnV0dG9uKGNvbmZpZy54ckljb25UeXBlKSkge1xuICAgICAgICAgICAgdGhpcy54ckljb24gPSBuZXcgWFJJY29uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGNvbnRyb2xzLlxuICAgICAqL1xuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmlkID0gJ2NvbnRyb2xzJztcbiAgICAgICAgICAgIGlmICh0aGlzLmZ1bGxzY3JlZW5JY29uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5mdWxsc2NyZWVuSWNvbi5yb290RWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5nc0ljb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNldHRpbmdzSWNvbi5yb290RWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0c0ljb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnN0YXRzSWNvbi5yb290RWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy54ckljb24pIHtcbiAgICAgICAgICAgICAgICB2b2lkIFdlYlhSQ29udHJvbGxlci5pc1Nlc3Npb25TdXBwb3J0ZWQoJ2ltbWVyc2l2ZS12cicpLnRoZW4oKHN1cHBvcnRlZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnhySWNvbi5yb290RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCB0aGlzLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RFbGVtZW50O1xuICAgIH1cbiAgICBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGlzSW5GdWxsc2NyZWVuID0gISFkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudDtcbiAgICAgICAgaWYgKGlzSW5GdWxsc2NyZWVuICYmICgoX2EgPSB0aGlzLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhpZGVDb250cm9sc0luRnVsbHNjcmVlbikpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250cm9scy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdmcm9udGVuZC11ZTUuNic7XG5pbXBvcnQgeyBTdGF0c1NlY3Rpb25zIH0gZnJvbSAnLi9VSUNvbmZpZ3VyYXRpb25UeXBlcyc7XG4vKipcbiAqIERhdGFDaGFubmVsIExhdGVuY3kgdGVzdCBVSSBlbGVtZW50cyBhbmQgcmVzdWx0cyBoYW5kbGluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFDaGFubmVsTGF0ZW5jeVRlc3Qge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnV0dG9uIGNvbnRhaW5pbmcgdGhlIHN0YXRzIGljb24uXG4gICAgICovXG4gICAgZ2V0IHJvb3RFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlY3Rpb24nKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3NldHRpbmdzQ29udGFpbmVyJyk7XG4gICAgICAgICAgICAvLyBtYWtlIGhlYWRpbmdcbiAgICAgICAgICAgIGNvbnN0IGhlYWRpbmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGhlYWRpbmcuaWQgPSAnZGF0YUNoYW5uZWxMYXRlbmN5VGVzdEhlYWRlcic7XG4gICAgICAgICAgICBoZWFkaW5nLmNsYXNzTGlzdC5hZGQoJ3NldHRpbmdzLXRleHQnKTtcbiAgICAgICAgICAgIGhlYWRpbmcuY2xhc3NMaXN0LmFkZCgnc2V0dGluZ3NIZWFkZXInKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKGhlYWRpbmcpO1xuICAgICAgICAgICAgY29uc3QgaGVhZGluZ1RleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGhlYWRpbmdUZXh0LmlubmVySFRNTCA9IFN0YXRzU2VjdGlvbnMuRGF0YUNoYW5uZWxMYXRlbmN5VGVzdDtcbiAgICAgICAgICAgIGhlYWRpbmcuYXBwZW5kQ2hpbGQoaGVhZGluZ1RleHQpO1xuICAgICAgICAgICAgaGVhZGluZy5hcHBlbmRDaGlsZCh0aGlzLmxhdGVuY3lUZXN0QnV0dG9uKTtcbiAgICAgICAgICAgIC8vIG1ha2UgdGVzdCByZXN1bHRzIGVsZW1lbnRcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHNQYXJlbnRFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICByZXN1bHRzUGFyZW50RWxlbS5pZCA9ICdkYXRhQ2hhbm5lbExhdGVuY3lUZXN0Q29udGFpbmVyJztcbiAgICAgICAgICAgIHJlc3VsdHNQYXJlbnRFbGVtLmNsYXNzTGlzdC5hZGQoJ2Qtbm9uZScpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQocmVzdWx0c1BhcmVudEVsZW0pO1xuICAgICAgICAgICAgcmVzdWx0c1BhcmVudEVsZW0uYXBwZW5kQ2hpbGQodGhpcy5sYXRlbmN5VGVzdFJlc3VsdHNFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBsYXRlbmN5VGVzdFJlc3VsdHNFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xhdGVuY3lUZXN0UmVzdWx0c0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lUZXN0UmVzdWx0c0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lUZXN0UmVzdWx0c0VsZW1lbnQuaWQgPSAnZGF0YUNoYW5uZWxMYXRlbmN5U3RhdHNSZXN1bHRzJztcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lUZXN0UmVzdWx0c0VsZW1lbnQuY2xhc3NMaXN0LmFkZCgnU3RhdHNSZXN1bHQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbGF0ZW5jeVRlc3RSZXN1bHRzRWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGxhdGVuY3lUZXN0QnV0dG9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xhdGVuY3lUZXN0QnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbi50eXBlID0gJ2J1dHRvbic7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbi52YWx1ZSA9ICdSdW4gVGVzdCc7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbi5pZCA9ICdidG4tc3RhcnQtZGF0YS1jaGFubmVsLWxhdGVuY3ktdGVzdCc7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdzdHJlYW1Ub29scy1idXR0b24nKTtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lUZXN0QnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2J0bi1mbGF0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhdGVuY3lUZXN0QnV0dG9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb3B1bGF0ZSB0aGUgVUkgYmFzZWQgb24gdGhlIGxhdGVuY3kgdGVzdCdzIHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIFRoZSBsYXRlbmN5IHRlc3QgcmVzdWx0cy5cbiAgICAgKi9cbiAgICBoYW5kbGVUZXN0UmVzdWx0KHJlc3VsdCkge1xuICAgICAgICBMb2dnZXIuSW5mbyhKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIHdlIGhhdmUgcmVzdWx0cywgTmFOIHdvdWxkIG1lYW4gdGhhdCBVRSB2ZXJzaW9uIHdlIHRhbGsgdG8gZG9lc24ndCBzdXBwb3J0IG91ciB0ZXN0XG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNOYU4ocmVzdWx0LmRhdGFDaGFubmVsUnR0KSkge1xuICAgICAgICAgICAgdGhpcy5sYXRlbmN5VGVzdFJlc3VsdHNFbGVtZW50LmlubmVySFRNTCA9ICc8ZGl2Pk5vdCBzdXBwb3J0ZWQ8L2Rpdj4nO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYXRlbmN5U3RhdHNJbm5lckhUTUwgPSAnJztcbiAgICAgICAgbGF0ZW5jeVN0YXRzSW5uZXJIVE1MICs9ICc8ZGl2PkRhdGEgY2hhbm5lbCBSVFQgKG1zKTogJyArIHJlc3VsdC5kYXRhQ2hhbm5lbFJ0dCArICc8L2Rpdj4nO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VwYXJhdGUgcGF0aCB0aW1lIGRpc2NvdmVyeSB3b3JrcyBvbmx5IHdoZW4gVUUgYW5kIFBsYXllciBjbG9ja3MgaGF2ZSBiZWVuIHN5bmNocm9uaXplZC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChyZXN1bHQucGxheWVyVG9TdHJlYW1lclRpbWUgPj0gMCAmJiByZXN1bHQuc3RyZWFtZXJUb1BsYXllclRpbWUgPj0gMCkge1xuICAgICAgICAgICAgbGF0ZW5jeVN0YXRzSW5uZXJIVE1MICs9XG4gICAgICAgICAgICAgICAgJzxkaXY+UGxheWVyIHRvIFN0cmVhbWVyIHBhdGggKG1zKTogJyArIHJlc3VsdC5wbGF5ZXJUb1N0cmVhbWVyVGltZSArICc8L2Rpdj4nO1xuICAgICAgICAgICAgbGF0ZW5jeVN0YXRzSW5uZXJIVE1MICs9XG4gICAgICAgICAgICAgICAgJzxkaXY+U3RyZWFtZXIgdG8gUGxheWVyIHBhdGggKG1zKTogJyArIHJlc3VsdC5zdHJlYW1lclRvUGxheWVyVGltZSArICc8L2Rpdj4nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF0ZW5jeVRlc3RSZXN1bHRzRWxlbWVudC5pbm5lckhUTUwgPSBsYXRlbmN5U3RhdHNJbm5lckhUTUw7XG4gICAgICAgIC8vc2V0dXAgYnV0dG9uIHRvIGRvd25sb2FkIHRoZSBkZXRhaWxlZCByZXN1bHRzXG4gICAgICAgIGNvbnN0IGRvd25sb2FkQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgZG93bmxvYWRCdXR0b24udHlwZSA9ICdidXR0b24nO1xuICAgICAgICBkb3dubG9hZEJ1dHRvbi52YWx1ZSA9ICdEb3dubG9hZCc7XG4gICAgICAgIGRvd25sb2FkQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3N0cmVhbVRvb2xzLWJ1dHRvbicpO1xuICAgICAgICBkb3dubG9hZEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdidG4tZmxhdCcpO1xuICAgICAgICBkb3dubG9hZEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IG5ldyBCbG9iKFtyZXN1bHQuZXhwb3J0TGF0ZW5jeUFzQ1NWKCldLCB7IHR5cGU6ICd0ZXh0L3BsYWluJyB9KTtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuICAgICAgICAgICAgYS5ocmVmID0gdXJsO1xuICAgICAgICAgICAgYS5kb3dubG9hZCA9ICdkYXRhX2NoYW5uZWxfbGF0ZW5jeV90ZXN0X3Jlc3VsdHMuY3N2JztcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7XG4gICAgICAgICAgICBhLmNsaWNrKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGEpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sYXRlbmN5VGVzdFJlc3VsdHNFbGVtZW50LmFwcGVuZENoaWxkKGRvd25sb2FkQnV0dG9uKTtcbiAgICB9XG4gICAgaGFuZGxlVGVzdFN0YXJ0KCkge1xuICAgICAgICB0aGlzLmxhdGVuY3lUZXN0UmVzdWx0c0VsZW1lbnQuaW5uZXJIVE1MID0gJzxkaXY+VGVzdCBpbiBwcm9ncmVzczwvZGl2Pic7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0YUNoYW5uZWxMYXRlbmN5VGVzdC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gRXZlbnQgZmlyZWQgd2hlbiBcIkNvbmZpcm1cIiBidXR0b24gaXMgY2xpY2tlZFxuZXhwb3J0IGNsYXNzIEVkaXRDb25maXJtZWRFdmVudCBleHRlbmRzIEN1c3RvbUV2ZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maXJtZWRUZXh0KSB7XG4gICAgICAgIHN1cGVyKCdlZGl0Q29uZmlybWVkJywge1xuICAgICAgICAgICAgZGV0YWlsOiBjb25maXJtZWRUZXh0LFxuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlybWVkVGV4dCA9IGNvbmZpcm1lZFRleHQ7XG4gICAgfVxufVxuLyoqXG4gKiBBIG1vZGFsIHRoYXQgaXMgc2hvd24gd2hlbiBhIFVFIHdpZGdldCBpcyB0b3VjaGVkIG9uIG1vYmlsZS5cbiAqIG9yXG4gKiBBIGhpZGRlbiAob2Zmc2NyZWVuKSBpbnB1dCBmaWVsZCB0aGF0IGlzIHNob3duIG9uIG5vbi10b3VjaCBkZXZpY2VzIChlLmcuIERlc2t0b3ApXG4gKiB3aGVuIGEgVUUgd2lkZ2V0IGlzIGNsaWNrZWQuIFRoZSBoaWRkZW4gdGV4dCBmaWVsZCBpcyB1c2VkIHNvIG5vbi1sYXRpbiBjaGFyYWN0ZXJcbiAqIGlucHV0IGNhbiBiZSBjb21wb3NlZCB1c2luZyBJTUUgYXNzaXN0YW5jZSAod2hpY2ggcmVxdWlyZXMgYW4gaW5wdXQgZmllbGQpLlxuICpcbiAqIFRoZSByZWFzb24gdGhpcyBtb2RhbCBpcyByZXF1aXJlZCBpcyB0aGF0IG9uIG1vYmlsZSB0eXBpbmcgdXNlc1xuICogYW4gb24tc2NyZWVuIGtleWJvYXJkLCB3aGljaCByZXF1aXJlcyBhIHZhbGlkIGlucHV0IHRleHQgYXJlYS9pbnB1dFxuICogdG8gYmUgZm9jdXNlZCB0byBzdW1tb24gaXQuIFRoZXJlZm9yZSB3ZSBzaG93IHRoaXMgbW9kYWwgd2hpY2ggaGFzXG4gKiB0aGUgY29udGVudHMgb2YgdGhlIFVFIHdpZGdldCwgcG9wdWxhdGUgaXRzIHRleHQgYXJlYSB3aXRoIHRoZSBjb250ZW50c1xuICogb2YgdGhlIFVFIHdpZGdldCwgdGhlbiBmb2N1cyB0aGUgdGV4dCBhcmVhIHRvIGZpbmFsbHkgc3VtbW9uIHRoZSBuYXRpdmVcbiAqIG9uLXNjcmVlbiBrZXlib2FyZC5cbiAqXG4gKiBUaGUgbW9kYWwgYWxzbyBjb250YWluczpcbiAqIDEpIEEgY2FuY2VsIGJ1dHRvbiAtIHRoaXMgY2xvc2VzIHRoZSBtb2RhbFxuICogMikgQSBjb25maXJtIGJ1dHRvbiAtIHRoaXMgc3VibWl0cyB0aGUgZWRpdCBiYWNrIHRvIHRoZSBVRSBzaWRlXG4gKi9cbmV4cG9ydCBjbGFzcyBFZGl0VGV4dE1vZGFsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSB0aGlzLnJvb3RFbGVtZW50O1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRUYXJnZXQoKTtcbiAgICB9XG4gICAgLy8gQmluZCB0byB0aGlzIGlmIHlvdSB3YW50IHRvIGhhbmRsZSBlZGl0IGNvbmZpcm1lZFxuICAgIGdldCBldmVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHM7XG4gICAgfVxuICAgIHNob3dNb2RhbChleGlzdGluZ1RleHRBcmVhQ29udGVudHMpIHtcbiAgICAgICAgaWYgKGV4aXN0aW5nVGV4dEFyZWFDb250ZW50cykge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBudWxsIHRlcm1pbmF0b3JzIGZyb20gdGhlIHN0cmluZ1xuICAgICAgICAgICAgZXhpc3RpbmdUZXh0QXJlYUNvbnRlbnRzID0gZXhpc3RpbmdUZXh0QXJlYUNvbnRlbnRzLnJlcGxhY2UoL1xcMC9nLCAnJyk7XG4gICAgICAgICAgICB0aGlzLnRleHRBcmVhLnZhbHVlID0gZXhpc3RpbmdUZXh0QXJlYUNvbnRlbnRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJyaW5nIGZvY3VzIHRvIHRoZSB0ZXh0IGFyZWEuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBtYWtlIHRoZSBvbi1zY3JlZW4ga2V5Ym9hcmQgc2hvdyBpZiB3ZSBhcmVcbiAgICAgICAgLy8gYSBkZXZpY2UgdGhhdCBoYXMgYSBuYXRpdmUgb24tc2NyZWVuIGtleWJvYXJkLlxuICAgICAgICAvLyBJZiB3ZSBhcmUgb24gYSBub24tdG91Y2ggZGV2aWNlIHRoaXMgd2lsbCBnaXZlIElNRSBhIHZhbGlkXG4gICAgICAgIC8vIGlucHV0IGZpZWxkIHRvIHdvcmsgd2l0aC5cbiAgICAgICAgdGhpcy50ZXh0QXJlYS5mb2N1cygpO1xuICAgICAgICAvLyBQdXQgY3Vyc29yIHRvIHRoZSBlbmQgb2YgdGhlIHRleHRhcmVhXG4gICAgICAgIHRoaXMudGV4dEFyZWEuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnRleHRBcmVhLnZhbHVlLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByb290IGVsZW1lbnQgdGhhdCBjb250YWlucyBlaXRoZXIgdGhlIG1vZGFsIChtb2JpbGUpIG9yIGhpZGRlbiB0ZXh0IGlucHV0IChkZXNrdG9wKVxuICAgICAqL1xuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ21vZGFsJyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmlubmVyTW9kYWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290RWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGlubmVyTW9kYWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5faW5uZXJNb2RhbCkge1xuICAgICAgICAgICAgdGhpcy5faW5uZXJNb2RhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5faW5uZXJNb2RhbC5jbGFzc0xpc3QuYWRkKCdpbm5lck1vZGFsJyk7XG4gICAgICAgICAgICB0aGlzLl9pbm5lck1vZGFsLmFwcGVuZENoaWxkKHRoaXMuZWRpdFRleHRIZWFkaW5nKTtcbiAgICAgICAgICAgIHRoaXMuX2lubmVyTW9kYWwuYXBwZW5kQ2hpbGQodGhpcy50ZXh0QXJlYSk7XG4gICAgICAgICAgICB0aGlzLl9pbm5lck1vZGFsLmFwcGVuZENoaWxkKHRoaXMubW9kYWxCdG5Db250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lck1vZGFsO1xuICAgIH1cbiAgICBnZXQgZWRpdFRleHRIZWFkaW5nKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2VkaXRUZXh0SGVhZGluZykge1xuICAgICAgICAgICAgdGhpcy5fZWRpdFRleHRIZWFkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcbiAgICAgICAgICAgIHRoaXMuX2VkaXRUZXh0SGVhZGluZy5pbm5lclRleHQgPSAnRWRpdCBUZXh0JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZWRpdFRleHRIZWFkaW5nO1xuICAgIH1cbiAgICBnZXQgdGV4dEFyZWEoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGV4dEFyZWEpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHRBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHRBcmVhLmNsYXNzTGlzdC5hZGQoJ2Zvcm0tY29udHJvbCcpO1xuICAgICAgICAgICAgdGhpcy5fdGV4dEFyZWEuY2xhc3NMaXN0LmFkZCgnbW9kYWxUZXh0QXJlYScpO1xuICAgICAgICAgICAgdGhpcy5fdGV4dEFyZWEudGl0bGUgPSAnRWRpdCBUZXh0IEFyZWEnO1xuICAgICAgICAgICAgdGhpcy5fdGV4dEFyZWEucGxhY2Vob2xkZXIgPSAnVUUgdGV4dCB3aWRnZXQgdmFsdWUgaGVyZS4uLic7XG4gICAgICAgICAgICAvLyBXaGVuIGtleWJvYXJkIGlzIHR5cGVkIGludG8gd2Ugd2FudCB0byBlbnN1cmUga2V5cyBhcmUgbm90IHNlbnQgYmFjayB0byBVRSB1bnRpbCB3ZSBjb25maXJtLlxuICAgICAgICAgICAgdGhpcy50ZXh0QXJlYS5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRleHRBcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudGV4dEFyZWEuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRleHRBcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEFyZWE7XG4gICAgfVxuICAgIGdldCBtb2RhbEJ0bkNvbnRhaW5lcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tb2RhbEJ0bkNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fbW9kYWxCdG5Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX21vZGFsQnRuQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ21vZGFsQnRuQ29udGFpbmVyJyk7XG4gICAgICAgICAgICB0aGlzLl9tb2RhbEJ0bkNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNhbmNlbEJ0bik7XG4gICAgICAgICAgICB0aGlzLl9tb2RhbEJ0bkNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNvbmZpcm1CdG4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RhbEJ0bkNvbnRhaW5lcjtcbiAgICB9XG4gICAgZ2V0IGNhbmNlbEJ0bigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYW5jZWxCdG4pIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbEJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsQnRuLmNsYXNzTGlzdC5hZGQoJ2J0bi1mbGF0Jyk7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxCdG4uaW5uZXJUZXh0ID0gJ0NhbmNlbCc7XG4gICAgICAgICAgICAvLyBXaGVuIGNhbmNlbCBpcyBjbGlja2VkLCByZW1vdmUgdGhpcyBtb2RhbCBmcm9tIHRoZSBET01cbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdEVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBjbGljay90YXAgZG9lcyBub3QgZ28gYmFjayB0byBVRVxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbmNlbEJ0bjtcbiAgICB9XG4gICAgZ2V0IGNvbmZpcm1CdG4oKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29uZmlybUJ0bikge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlybUJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgdGhpcy5fY29uZmlybUJ0bi5jbGFzc0xpc3QuYWRkKCdidG4tZmxhdCcpO1xuICAgICAgICAgICAgdGhpcy5fY29uZmlybUJ0bi5pbm5lclRleHQgPSAnQ29uZmlybSc7XG4gICAgICAgICAgICAvLyBXaGVuIGNvbmZpcm0gaXMgY2xpY2tlZCwgcmVtb3ZlIGZyb20gRE9NIGFuZCBzZW5kIHRoZSBjb250ZW50cyBvZiB0ZXh0YXJlYSB0byBVRVxuICAgICAgICAgICAgdGhpcy5fY29uZmlybUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQobmV3IEVkaXRDb25maXJtZWRFdmVudCh0aGlzLnRleHRBcmVhLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290RWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGNsaWNrL3RhcCBkb2VzIG5vdCBnbyBiYWNrIHRvIFVFXG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlybUJ0bjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FZGl0VGV4dE1vZGFsLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFuIGVsZW1lbnQgKGkuZS4gYnV0dG9uKSB0aGF0LCB3aGVuIGNsaWNrZWQsIHdpbGwgdG9nZ2xlIGZ1bGxzY3JlZW4gb2YgYSBnaXZlbiBlbGVtZW50LlxuICogQ2FuIGJlIGluaXRpYWxpemVkIHdpdGggYW55IEhUTUxFbGVtZW50LCBpZiBpdCBpcyBzZXQgYXMgcm9vdEVsZW1lbnQgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICovXG5leHBvcnQgY2xhc3MgRnVsbFNjcmVlbkljb25CYXNlIHtcbiAgICBnZXQgcm9vdEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290RWxlbWVudDtcbiAgICB9XG4gICAgc2V0IHJvb3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5vbmNsaWNrID0gKCkgPT4gdGhpcy50b2dnbGVGdWxsc2NyZWVuKCk7XG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gZWxlbWVudDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaXNGdWxsc2NyZWVuID0gZmFsc2U7XG4gICAgICAgIC8vIHNldCB1cCB0aGUgZnVsbCBzY3JlZW4gZXZlbnRzXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLCAoKSA9PiB0aGlzLm9uRnVsbHNjcmVlbkNoYW5nZSgpLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLCAoKSA9PiB0aGlzLm9uRnVsbHNjcmVlbkNoYW5nZSgpLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCAoKSA9PiB0aGlzLm9uRnVsbHNjcmVlbkNoYW5nZSgpLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ01TRnVsbHNjcmVlbkNoYW5nZScsICgpID0+IHRoaXMub25GdWxsc2NyZWVuQ2hhbmdlKCksIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIGRvY3VtZW50IG9yIGZ1bGxzY3JlZW5FbGVtZW50IGZ1bGxzY3JlZW4uXG4gICAgICovXG4gICAgdG9nZ2xlRnVsbHNjcmVlbigpIHtcbiAgICAgICAgLy8gaWYgYWxyZWFkeSBmdWxsIHNjcmVlbjsgZXhpdFxuICAgICAgICAvLyBlbHNlIGdvIGZ1bGxzY3JlZW5cbiAgICAgICAgaWYgKGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICAgICAgICBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCB8fFxuICAgICAgICAgICAgZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnQgfHxcbiAgICAgICAgICAgIGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5leGl0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50Lm1zRXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmZ1bGxzY3JlZW5FbGVtZW50O1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsZW1lbnQucmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbGVtZW50Lm1velJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5tb3pSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxlbWVudC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnQubXNSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubXNSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxlbWVudC53ZWJraXRFbnRlckZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LndlYmtpdEVudGVyRnVsbHNjcmVlbigpOyAvL2ZvciBpcGhvbmUgdGhpcyBjb2RlIHdvcmtlZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub25GdWxsc2NyZWVuQ2hhbmdlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGZ1bGxzY3JlZW4gYnV0dG9uIG9uIGNoYW5nZVxuICAgICAqL1xuICAgIG9uRnVsbHNjcmVlbkNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5pc0Z1bGxzY3JlZW4gPVxuICAgICAgICAgICAgZG9jdW1lbnQud2Via2l0SXNGdWxsU2NyZWVuIHx8XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQubW96RnVsbFNjcmVlbiB8fFxuICAgICAgICAgICAgICAgIChkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50ICYmIGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVsZW1lbnQgIT09IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgKGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50ICYmIGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50ICE9PSBudWxsKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIEZ1bGxTY3JlZW5JY29uQmFzZSB0aGF0IHVzZXMgYW4gZXh0ZXJuYWxseVxuICogcHJvdmlkZWQgSFRNTEVsZW1lbnQgZm9yIHRvZ2dsaW5nIGZ1bGwgc2NyZWVuLlxuICovXG5leHBvcnQgY2xhc3MgRnVsbFNjcmVlbkljb25FeHRlcm5hbCBleHRlbmRzIEZ1bGxTY3JlZW5JY29uQmFzZSB7XG4gICAgY29uc3RydWN0b3IoZXh0ZXJuYWxCdXR0b24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yb290RWxlbWVudCA9IGV4dGVybmFsQnV0dG9uO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgZnVsbHNjcmVlbiBpY29uIHRoYXQgY29udGFpbnMgYSBidXR0b24gYW5kIHN2Z3MgZm9yIGVhY2ggc3RhdGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBGdWxsU2NyZWVuSWNvbiBleHRlbmRzIEZ1bGxTY3JlZW5JY29uQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgY3JlYXRlZEJ1dHRvbi50eXBlID0gJ2J1dHRvbic7XG4gICAgICAgIGNyZWF0ZWRCdXR0b24uY2xhc3NMaXN0LmFkZCgnVWlUb29sJyk7XG4gICAgICAgIGNyZWF0ZWRCdXR0b24uaWQgPSAnZnVsbHNjcmVlbi1idG4nO1xuICAgICAgICBjcmVhdGVkQnV0dG9uLmFwcGVuZENoaWxkKHRoaXMubWF4aW1pemVJY29uKTtcbiAgICAgICAgY3JlYXRlZEJ1dHRvbi5hcHBlbmRDaGlsZCh0aGlzLm1pbmltaXplSWNvbik7XG4gICAgICAgIGNyZWF0ZWRCdXR0b24uYXBwZW5kQ2hpbGQodGhpcy50b29sdGlwVGV4dCk7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQgPSBjcmVhdGVkQnV0dG9uO1xuICAgIH1cbiAgICBnZXQgdG9vbHRpcFRleHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9vbHRpcFRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFRleHQuY2xhc3NMaXN0LmFkZCgndG9vbHRpcHRleHQnKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBUZXh0LmlubmVySFRNTCA9ICdGdWxsc2NyZWVuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdG9vbHRpcFRleHQ7XG4gICAgfVxuICAgIGdldCBtYXhpbWl6ZUljb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWF4aW1pemVJY29uKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXhpbWl6ZUljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3N2ZycpO1xuICAgICAgICAgICAgdGhpcy5fbWF4aW1pemVJY29uLnNldEF0dHJpYnV0ZU5TKG51bGwsICdpZCcsICdtYXhpbWl6ZUljb24nKTtcbiAgICAgICAgICAgIHRoaXMuX21heGltaXplSWNvbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsICcwcHgnKTtcbiAgICAgICAgICAgIHRoaXMuX21heGltaXplSWNvbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneScsICcwcHgnKTtcbiAgICAgICAgICAgIHRoaXMuX21heGltaXplSWNvbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndmlld0JveCcsICcwIDAgMzg0Ljk3IDM4NC45NycpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIHN2ZyBncm91cCBmb3IgdGhlIHBhdGhzXG4gICAgICAgICAgICBjb25zdCBzdmdHcm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnZycpO1xuICAgICAgICAgICAgc3ZnR3JvdXAuY2xhc3NMaXN0LmFkZCgnc3ZnSWNvbicpO1xuICAgICAgICAgICAgdGhpcy5fbWF4aW1pemVJY29uLmFwcGVuZENoaWxkKHN2Z0dyb3VwKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBwYXRocyBmb3IgdGhlIGljb24gaXRzZWxmLCBvbmUgZm9yIGVhY2ggY29ybmVyXG4gICAgICAgICAgICBjb25zdCBwYXRoMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncGF0aCcpO1xuICAgICAgICAgICAgcGF0aDEuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCAnTTM4NC45NywxMi4wM2MwLTYuNzEzLTUuMzE3LTEyLjAzLTEyLjAzLTEyLjAzSDI2NC44NDdjLTYuODMzLDAtMTEuOTIyLDUuMzktMTEuOTM0LDEyLjIyM2MwLDYuODIxLDUuMTAxLDExLjgzOCwxMS45MzQsMTEuODM4aDk2LjA2MmwtMC4xOTMsOTYuNTE5YzAsNi44MzMsNS4xOTcsMTIuMDMsMTIuMDMsMTIuMDNjNi44MzMtMC4wMTIsMTIuMDMtNS4xOTcsMTIuMDMtMTIuMDNsMC4xOTMtMTA4LjM2OWMwLTAuMDM2LTAuMDEyLTAuMDYtMC4wMTItMC4wODRDMzg0Ljk1OCwxMi4wOSwzODQuOTcsMTIuMDY2LDM4NC45NywxMi4wM3onKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGgyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdwYXRoJyk7XG4gICAgICAgICAgICBwYXRoMi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsICdNMTIwLjQ5NiwwSDEyLjQwM2MtMC4wMzYsMC0wLjA2LDAuMDEyLTAuMDk2LDAuMDEyQzEyLjI4MywwLjAxMiwxMi4yNDcsMCwxMi4yMjMsMEM1LjUxLDAsMC4xOTIsNS4zMTcsMC4xOTIsMTIuMDNMMCwxMjAuMzk5YzAsNi44MzMsNS4zOSwxMS45MzQsMTIuMjIzLDExLjkzNGM2LjgyMSwwLDExLjgzOC01LjEwMSwxMS44MzgtMTEuOTM0bDAuMTkyLTk2LjMzOWg5Ni4yNDJjNi44MzMsMCwxMi4wMy01LjE5NywxMi4wMy0xMi4wM0MxMzIuNTE0LDUuMTk3LDEyNy4zMTcsMCwxMjAuNDk2LDB6Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXRoMyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncGF0aCcpO1xuICAgICAgICAgICAgcGF0aDMuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCAnTTEyMC4xMjMsMzYwLjkwOUgyNC4wNjF2LTk2LjI0MmMwLTYuODMzLTUuMTk3LTEyLjAzLTEyLjAzLTEyLjAzUzAsMjU3LjgzMywwLDI2NC42Njd2MTA4LjA5MmMwLDAuMDM2LDAuMDEyLDAuMDYsMC4wMTIsMC4wODRjMCwwLjAzNi0wLjAxMiwwLjA2LTAuMDEyLDAuMDk2YzAsNi43MTMsNS4zMTcsMTIuMDMsMTIuMDMsMTIuMDNoMTA4LjA5MmM2LjgzMywwLDExLjkyMi01LjM5LDExLjkzNC0xMi4yMjNDMTMyLjA1NywzNjUuOTI2LDEyNi45NTYsMzYwLjkwOSwxMjAuMTIzLDM2MC45MDl6Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXRoNCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncGF0aCcpO1xuICAgICAgICAgICAgcGF0aDQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCAnTTM3Mi43NDcsMjUyLjkxM2MtNi44MzMsMC0xMS44NSw1LjEwMS0xMS44MzgsMTEuOTM0djk2LjA2MmgtOTYuMjQyYy02LjgzMywwLTEyLjAzLDUuMTk3LTEyLjAzLDEyLjAzczUuMTk3LDEyLjAzLDEyLjAzLDEyLjAzaDEwOC4wOTJjMC4wMzYsMCwwLjA2LTAuMDEyLDAuMDg0LTAuMDEyYzAuMDM2LTAuMDEyLDAuMDYsMC4wMTIsMC4wOTYsMC4wMTJjNi43MTMsMCwxMi4wMy01LjMxNywxMi4wMy0xMi4wM1YyNjQuODQ3QzM4NC45NywyNTguMDE0LDM3OS41OCwyNTIuOTEzLDM3Mi43NDcsMjUyLjkxM3onKTtcbiAgICAgICAgICAgIHN2Z0dyb3VwLmFwcGVuZENoaWxkKHBhdGgxKTtcbiAgICAgICAgICAgIHN2Z0dyb3VwLmFwcGVuZENoaWxkKHBhdGgyKTtcbiAgICAgICAgICAgIHN2Z0dyb3VwLmFwcGVuZENoaWxkKHBhdGgzKTtcbiAgICAgICAgICAgIHN2Z0dyb3VwLmFwcGVuZENoaWxkKHBhdGg0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbWF4aW1pemVJY29uO1xuICAgIH1cbiAgICBnZXQgbWluaW1pemVJY29uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX21pbmltaXplSWNvbikge1xuICAgICAgICAgICAgdGhpcy5fbWluaW1pemVJY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgICAgICAgICAgIHRoaXMuX21pbmltaXplSWNvbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaWQnLCAnbWluaW1pemVJY29uJyk7XG4gICAgICAgICAgICB0aGlzLl9taW5pbWl6ZUljb24uc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gnLCAnMHB4Jyk7XG4gICAgICAgICAgICB0aGlzLl9taW5pbWl6ZUljb24uc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLCAnMHB4Jyk7XG4gICAgICAgICAgICB0aGlzLl9taW5pbWl6ZUljb24uc2V0QXR0cmlidXRlTlMobnVsbCwgJ3ZpZXdCb3gnLCAnMCAwIDM4NS4zMzEgMzg1LjMzMScpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIHN2ZyBncm91cCBmb3IgdGhlIHBhdGhzXG4gICAgICAgICAgICBjb25zdCBzdmdHcm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnZycpO1xuICAgICAgICAgICAgc3ZnR3JvdXAuY2xhc3NMaXN0LmFkZCgnc3ZnSWNvbicpO1xuICAgICAgICAgICAgdGhpcy5fbWluaW1pemVJY29uLmFwcGVuZENoaWxkKHN2Z0dyb3VwKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBwYXRocyBmb3IgdGhlIGljb24gaXRzZWxmLCBvbmUgZm9yIGVhY2ggY29ybmVyXG4gICAgICAgICAgICBjb25zdCBwYXRoMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncGF0aCcpO1xuICAgICAgICAgICAgcGF0aDEuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCAnTTI2NC45NDMsMTU2LjY2NWgxMDguMjczYzYuODMzLDAsMTEuOTM0LTUuMzksMTEuOTM0LTEyLjIxMWMwLTYuODMzLTUuMTAxLTExLjg1LTExLjkzNC0xMS44MzhoLTk2LjI0MlYzNi4xODFjMC02LjgzMy01LjE5Ny0xMi4wMy0xMi4wMy0xMi4wM3MtMTIuMDMsNS4xOTctMTIuMDMsMTIuMDN2MTA4LjI3M2MwLDAuMDM2LDAuMDEyLDAuMDYsMC4wMTIsMC4wODRjMCwwLjAzNi0wLjAxMiwwLjA2LTAuMDEyLDAuMDk2QzI1Mi45MTMsMTUxLjM0NywyNTguMjMsMTU2LjY3NywyNjQuOTQzLDE1Ni42NjV6Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXRoMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncGF0aCcpO1xuICAgICAgICAgICAgcGF0aDIuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCAnTTEyMC4yOTEsMjQuMjQ3Yy02LjgyMSwwLTExLjgzOCw1LjExMy0xMS44MzgsMTEuOTM0djk2LjI0MkgxMi4wM2MtNi44MzMsMC0xMi4wMyw1LjE5Ny0xMi4wMywxMi4wM2MwLDYuODMzLDUuMTk3LDEyLjAzLDEyLjAzLDEyLjAzaDEwOC4yNzNjMC4wMzYsMCwwLjA2LTAuMDEyLDAuMDg0LTAuMDEyYzAuMDM2LDAsMC4wNiwwLjAxMiwwLjA5NiwwLjAxMmM2LjcxMywwLDEyLjAzLTUuMzE3LDEyLjAzLTEyLjAzVjM2LjE4MUMxMzIuNTE0LDI5LjM2LDEyNy4xMjQsMjQuMjU5LDEyMC4yOTEsMjQuMjQ3eicpO1xuICAgICAgICAgICAgY29uc3QgcGF0aDMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3BhdGgnKTtcbiAgICAgICAgICAgIHBhdGgzLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ00xMjAuMzg3LDIyOC42NjZIMTIuMTE1Yy02LjgzMywwLjAxMi0xMS45MzQsNS4zOS0xMS45MzQsMTIuMjIzYzAsNi44MzMsNS4xMDEsMTEuODUsMTEuOTM0LDExLjgzOGg5Ni4yNDJ2OTYuNDIzYzAsNi44MzMsNS4xOTcsMTIuMDMsMTIuMDMsMTIuMDNjNi44MzMsMCwxMi4wMy01LjE5NywxMi4wMy0xMi4wM1YyNDAuODc3YzAtMC4wMzYtMC4wMTItMC4wNi0wLjAxMi0wLjA4NGMwLTAuMDM2LDAuMDEyLTAuMDYsMC4wMTItMC4wOTZDMTMyLjQxOCwyMzMuOTgzLDEyNy4xLDIyOC42NjYsMTIwLjM4NywyMjguNjY2eicpO1xuICAgICAgICAgICAgY29uc3QgcGF0aDQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3BhdGgnKTtcbiAgICAgICAgICAgIHBhdGg0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ00zNzMuMywyMjguNjY2SDI2NS4wMjhjLTAuMDM2LDAtMC4wNiwwLjAxMi0wLjA4NCwwLjAxMmMtMC4wMzYsMC0wLjA2LTAuMDEyLTAuMDk2LTAuMDEyYy02LjcxMywwLTEyLjAzLDUuMzE3LTEyLjAzLDEyLjAzdjEwOC4yNzNjMCw2LjgzMyw1LjM5LDExLjkyMiwxMi4yMjMsMTEuOTM0YzYuODIxLDAuMDEyLDExLjgzOC01LjEwMSwxMS44MzgtMTEuOTIydi05Ni4yNDJIMzczLjNjNi44MzMsMCwxMi4wMy01LjE5NywxMi4wMy0xMi4wM1MzODAuMTM0LDIyOC42NzgsMzczLjMsMjI4LjY2NnonKTtcbiAgICAgICAgICAgIHN2Z0dyb3VwLmFwcGVuZENoaWxkKHBhdGgxKTtcbiAgICAgICAgICAgIHN2Z0dyb3VwLmFwcGVuZENoaWxkKHBhdGgyKTtcbiAgICAgICAgICAgIHN2Z0dyb3VwLmFwcGVuZENoaWxkKHBhdGgzKTtcbiAgICAgICAgICAgIHN2Z0dyb3VwLmFwcGVuZENoaWxkKHBhdGg0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbWluaW1pemVJY29uO1xuICAgIH1cbiAgICBvbkZ1bGxzY3JlZW5DaGFuZ2UoKSB7XG4gICAgICAgIHN1cGVyLm9uRnVsbHNjcmVlbkNoYW5nZSgpO1xuICAgICAgICBjb25zdCBtaW5pbWl6ZSA9IHRoaXMubWluaW1pemVJY29uO1xuICAgICAgICBjb25zdCBtYXhpbWl6ZSA9IHRoaXMubWF4aW1pemVJY29uO1xuICAgICAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIG1pbmltaXplLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcbiAgICAgICAgICAgIC8vaW9zIGRpc2FwcGVhcmluZyBzdmcgZml4XG4gICAgICAgICAgICBtaW5pbWl6ZS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKDAsIDApJztcbiAgICAgICAgICAgIG1heGltaXplLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtaW5pbWl6ZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgbWF4aW1pemUuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICAgICAgLy9pb3MgZGlzYXBwZWFyaW5nIHN2ZyBmaXhcbiAgICAgICAgICAgIG1heGltaXplLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMCwgMCknO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnVsbHNjcmVlbkljb24uanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogQSBidXR0b24gd2l0aCBhIHRleHQgbGFiZWwgYmVzaWRlIGl0LlxuICovXG5leHBvcnQgY2xhc3MgTGFiZWxsZWRCdXR0b24ge1xuICAgIGNvbnN0cnVjdG9yKGxhYmVsLCBidXR0b25UZXh0KSB7XG4gICAgICAgIHRoaXMuX2xhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMuX2J1dHRvblRleHQgPSBidXR0b25UZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjbGljayBsaXN0ZW5lciB0byB0aGUgYnV0dG9uIGVsZW1lbnQuXG4gICAgICovXG4gICAgYWRkT25DbGlja0xpc3RlbmVyKG9uQ2xpY2tGdW5jKSB7XG4gICAgICAgIHRoaXMuYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGlja0Z1bmMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEhUTUxJbnB1dEVsZW1lbnQgZm9yIHRoZSBidXR0b24uXG4gICAgICovXG4gICAgZ2V0IGJ1dHRvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9idXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMuX2J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICB0aGlzLl9idXR0b24udHlwZSA9ICdidXR0b24nO1xuICAgICAgICAgICAgdGhpcy5fYnV0dG9uLnZhbHVlID0gdGhpcy5fYnV0dG9uVGV4dDtcbiAgICAgICAgICAgIHRoaXMuX2J1dHRvbi5jbGFzc0xpc3QuYWRkKCdvdmVybGF5LWJ1dHRvbicpO1xuICAgICAgICAgICAgdGhpcy5fYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2J0bi1mbGF0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1dHRvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgUmV0dXJuIG9yIGNyZWF0ZXMgYSBIVE1MIGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIHRoaXMgc2V0dGluZyBpbiB0aGUgRE9NLlxuICAgICAqL1xuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIHJvb3QgZGl2IHdpdGggXCJzZXR0aW5nXCIgY3NzIGNsYXNzXG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2V0dGluZycpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIGRpdiBlbGVtZW50IHRvIGNvbnRhaW4gb3VyIHNldHRpbmcncyB0ZXh0XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc1RleHRFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBzZXR0aW5nc1RleHRFbGVtLmlubmVyVGV4dCA9IHRoaXMuX2xhYmVsO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2V0dGluZ3NUZXh0RWxlbSk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgbGFiZWwgZWxlbWVudCB0byB3cmFwIG91dCBpbnB1dCB0eXBlXG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgd3JhcHBlckxhYmVsLmNsYXNzTGlzdC5hZGQoJ2J0bi1vdmVybGF5Jyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5hcHBlbmRDaGlsZCh3cmFwcGVyTGFiZWwpO1xuICAgICAgICAgICAgd3JhcHBlckxhYmVsLmFwcGVuZENoaWxkKHRoaXMuYnV0dG9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGFiZWxsZWRCdXR0b24uanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nZnJvbnRlbmQtdWU1LjYnO1xuaW1wb3J0IHsgU3RhdHNTZWN0aW9ucyB9IGZyb20gJy4vVUlDb25maWd1cmF0aW9uVHlwZXMnO1xuLyoqXG4gKiBMYXRlbmN5IHRlc3QgVUkgZWxlbWVudHMgYW5kIHJlc3VsdHMgaGFuZGxpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBMYXRlbmN5VGVzdCB7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0aGUgYnV0dG9uIGNvbnRhaW5pbmcgdGhlIHN0YXRzIGljb24uXG4gICAgICovXG4gICAgZ2V0IHJvb3RFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlY3Rpb24nKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3NldHRpbmdzQ29udGFpbmVyJyk7XG4gICAgICAgICAgICAvLyBtYWtlIGhlYWRpbmdcbiAgICAgICAgICAgIGNvbnN0IGhlYWRpbmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGhlYWRpbmcuaWQgPSAnbGF0ZW5jeVRlc3RIZWFkZXInO1xuICAgICAgICAgICAgaGVhZGluZy5jbGFzc0xpc3QuYWRkKCdzZXR0aW5ncy10ZXh0Jyk7XG4gICAgICAgICAgICBoZWFkaW5nLmNsYXNzTGlzdC5hZGQoJ3NldHRpbmdzSGVhZGVyJyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5hcHBlbmRDaGlsZChoZWFkaW5nKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRpbmdUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBoZWFkaW5nVGV4dC5pbm5lckhUTUwgPSBTdGF0c1NlY3Rpb25zLkxhdGVuY3lUZXN0O1xuICAgICAgICAgICAgaGVhZGluZy5hcHBlbmRDaGlsZChoZWFkaW5nVGV4dCk7XG4gICAgICAgICAgICBoZWFkaW5nLmFwcGVuZENoaWxkKHRoaXMubGF0ZW5jeVRlc3RCdXR0b24pO1xuICAgICAgICAgICAgLy8gbWFrZSB0ZXN0IHJlc3VsdHMgZWxlbWVudFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0c1BhcmVudEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHJlc3VsdHNQYXJlbnRFbGVtLmlkID0gJ2xhdGVuY3lUZXN0Q29udGFpbmVyJztcbiAgICAgICAgICAgIHJlc3VsdHNQYXJlbnRFbGVtLmNsYXNzTGlzdC5hZGQoJ2Qtbm9uZScpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQocmVzdWx0c1BhcmVudEVsZW0pO1xuICAgICAgICAgICAgcmVzdWx0c1BhcmVudEVsZW0uYXBwZW5kQ2hpbGQodGhpcy5sYXRlbmN5VGVzdFJlc3VsdHNFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBsYXRlbmN5VGVzdFJlc3VsdHNFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xhdGVuY3lUZXN0UmVzdWx0c0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lUZXN0UmVzdWx0c0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lUZXN0UmVzdWx0c0VsZW1lbnQuaWQgPSAnbGF0ZW5jeVN0YXRzUmVzdWx0cyc7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdFJlc3VsdHNFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ1N0YXRzUmVzdWx0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhdGVuY3lUZXN0UmVzdWx0c0VsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBsYXRlbmN5VGVzdEJ1dHRvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24udHlwZSA9ICdidXR0b24nO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24udmFsdWUgPSAnUnVuIFRlc3QnO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24uaWQgPSAnYnRuLXN0YXJ0LWxhdGVuY3ktdGVzdCc7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdzdHJlYW1Ub29scy1idXR0b24nKTtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lUZXN0QnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2J0bi1mbGF0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhdGVuY3lUZXN0QnV0dG9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb3B1bGF0ZSB0aGUgVUkgYmFzZWQgb24gdGhlIGxhdGVuY3kgdGVzdCdzIHJlc3VsdHMuXG4gICAgICogQHBhcmFtIGxhdGVuY3lUaW1pbmdzIC0gVGhlIGxhdGVuY3kgdGVzdCByZXN1bHRzLlxuICAgICAqL1xuICAgIGhhbmRsZVRlc3RSZXN1bHQobGF0ZW5jeVRpbWluZ3MpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oSlNPTi5zdHJpbmdpZnkobGF0ZW5jeVRpbWluZ3MpKTtcbiAgICAgICAgbGV0IGxhdGVuY3lTdGF0c0lubmVySFRNTCA9ICcnO1xuICAgICAgICBpZiAobGF0ZW5jeVRpbWluZ3MubmV0d29ya0xhdGVuY3kgIT09IHVuZGVmaW5lZCAmJiBsYXRlbmN5VGltaW5ncy5uZXR3b3JrTGF0ZW5jeSA+IDApIHtcbiAgICAgICAgICAgIGxhdGVuY3lTdGF0c0lubmVySFRNTCArPSAnPGRpdj5OZXQgbGF0ZW5jeSBSVFQgKG1zKTogJyArIGxhdGVuY3lUaW1pbmdzLm5ldHdvcmtMYXRlbmN5ICsgJzwvZGl2Pic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhdGVuY3lUaW1pbmdzLkVuY29kZU1zICE9PSB1bmRlZmluZWQgJiYgbGF0ZW5jeVRpbWluZ3MuRW5jb2RlTXMgPiAwKSB7XG4gICAgICAgICAgICBsYXRlbmN5U3RhdHNJbm5lckhUTUwgKz0gJzxkaXY+VUUgRW5jb2RlIChtcyk6ICcgKyBsYXRlbmN5VGltaW5ncy5FbmNvZGVNcyArICc8L2Rpdj4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXRlbmN5VGltaW5ncy5DYXB0dXJlVG9TZW5kTXMgIT09IHVuZGVmaW5lZCAmJiBsYXRlbmN5VGltaW5ncy5DYXB0dXJlVG9TZW5kTXMgPiAwKSB7XG4gICAgICAgICAgICBsYXRlbmN5U3RhdHNJbm5lckhUTUwgKz0gJzxkaXY+VUUgQ2FwdHVyZSAobXMpOiAnICsgbGF0ZW5jeVRpbWluZ3MuQ2FwdHVyZVRvU2VuZE1zICsgJzwvZGl2Pic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhdGVuY3lUaW1pbmdzLmJyb3dzZXJTZW5kTGF0ZW5jeSAhPT0gdW5kZWZpbmVkICYmIGxhdGVuY3lUaW1pbmdzLmJyb3dzZXJTZW5kTGF0ZW5jeSA+IDApIHtcbiAgICAgICAgICAgIGxhdGVuY3lTdGF0c0lubmVySFRNTCArPVxuICAgICAgICAgICAgICAgICc8ZGl2PkJyb3dzZXIgc2VuZCBsYXRlbmN5IChtcyk6ICcgKyBsYXRlbmN5VGltaW5ncy5icm93c2VyU2VuZExhdGVuY3kgKyAnPC9kaXY+JztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF0ZW5jeVRpbWluZ3MuZnJhbWVEaXNwbGF5RGVsdGFUaW1lTXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgbGF0ZW5jeVRpbWluZ3MuYnJvd3NlclJlY2VpcHRUaW1lTXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGF0ZW5jeVN0YXRzSW5uZXJIVE1MICs9XG4gICAgICAgICAgICAgICAgbGF0ZW5jeVRpbWluZ3MuZnJhbWVEaXNwbGF5RGVsdGFUaW1lTXMgJiYgbGF0ZW5jeVRpbWluZ3MuYnJvd3NlclJlY2VpcHRUaW1lTXNcbiAgICAgICAgICAgICAgICAgICAgPyAnPGRpdj5Ccm93c2VyIHJlY2VpdmUgbGF0ZW5jeSAobXMpOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhdGVuY3lUaW1pbmdzLmZyYW1lRGlzcGxheURlbHRhVGltZU1zICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nXG4gICAgICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhdGVuY3lUaW1pbmdzLmxhdGVuY3lFeGNsdWRpbmdEZWNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGF0ZW5jeVN0YXRzSW5uZXJIVE1MICs9XG4gICAgICAgICAgICAgICAgJzxkaXY+VG90YWwgbGF0ZW5jeSAoZXhjbHVkaW5nIGJyb3dzZXIpIChtcyk6ICcgK1xuICAgICAgICAgICAgICAgICAgICBsYXRlbmN5VGltaW5ncy5sYXRlbmN5RXhjbHVkaW5nRGVjb2RlICtcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2Pic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhdGVuY3lUaW1pbmdzLmVuZFRvRW5kTGF0ZW5jeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYXRlbmN5U3RhdHNJbm5lckhUTUwgKz0gbGF0ZW5jeVRpbWluZ3MuZW5kVG9FbmRMYXRlbmN5XG4gICAgICAgICAgICAgICAgPyAnPGRpdj5Ub3RhbCBsYXRlbmN5IChtcyk6ICcgKyBsYXRlbmN5VGltaW5ncy5lbmRUb0VuZExhdGVuY3kgKyAnPC9kaXY+J1xuICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXRlbmN5VGVzdFJlc3VsdHNFbGVtZW50LmlubmVySFRNTCA9IGxhdGVuY3lTdGF0c0lubmVySFRNTDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYXRlbmN5VGVzdC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyLCBTZXR0aW5nTnVtYmVyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdmcm9udGVuZC11ZTUuNic7XG5pbXBvcnQgeyBTZXR0aW5nVUlOdW1iZXIgfSBmcm9tICcuLi9Db25maWcvU2V0dGluZ1VJTnVtYmVyJztcbi8qKlxuICogU2Vzc2lvbiB0ZXN0IFVJIGVsZW1lbnRzIGFuZCByZXN1bHRzIGhhbmRsaW5nLlxuICogQ3JlYXRlcyBhIGJ1dHRvbiB0byBzdGFydCB0aGUgdGVzdCBhbmQgY29sbGVjdHMgc3RhdHMgYW5kIGxhdGVuY3kgaW5mbyBkdXJpbmcgdGhlIHRlc3QuXG4gKiBBZnRlciB0aGUgdGVzdCBpcyBmaW5pc2hlZCwgaXQgZ2VuZXJhdGVzIENTViBmaWxlcyBmb3Igc3RhdHMgYW5kIGxhdGVuY3kgaW5mby5cbiAqIFRoZSB0ZXN0IHJ1bnMgZm9yIGEgc3BlY2lmaWVkIHRpbWUgZnJhbWUsIHdoaWNoIGNhbiBiZSBzZXQgaW4gdGhlIFVJLlxuICovXG5leHBvcnQgY2xhc3MgU2Vzc2lvblRlc3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmlzQ29sbGVjdGluZ1N0YXRzID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2UgdGhlIGVsZW1lbnRzIGZvciB0aGUgc2Vzc2lvbiB0ZXN0OiBlLmcuIGJ1dHRvbiBhbmQgdGVzdCB0aW1lIGlucHV0LlxuICAgICAqL1xuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWN0aW9uJyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzZXR0aW5nc0NvbnRhaW5lcicpO1xuICAgICAgICAgICAgLy8gbWFrZSBoZWFkaW5nXG4gICAgICAgICAgICBjb25zdCBoZWFkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBoZWFkaW5nLmlkID0gJ2xhdGVuY3lUZXN0SGVhZGVyJztcbiAgICAgICAgICAgIGhlYWRpbmcuY2xhc3NMaXN0LmFkZCgnc2V0dGluZ3MtdGV4dCcpO1xuICAgICAgICAgICAgaGVhZGluZy5jbGFzc0xpc3QuYWRkKCdzZXR0aW5nc0hlYWRlcicpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQoaGVhZGluZyk7XG4gICAgICAgICAgICBjb25zdCBoZWFkaW5nVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaGVhZGluZ1RleHQuaW5uZXJIVE1MID0gJ1Nlc3Npb24gVGVzdCc7XG4gICAgICAgICAgICBoZWFkaW5nLmFwcGVuZENoaWxkKGhlYWRpbmdUZXh0KTtcbiAgICAgICAgICAgIC8vIG1ha2UgdGVzdCByZXN1bHRzIGVsZW1lbnRcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHNQYXJlbnRFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICByZXN1bHRzUGFyZW50RWxlbS5pZCA9ICdsYXRlbmN5VGVzdENvbnRhaW5lcic7XG4gICAgICAgICAgICByZXN1bHRzUGFyZW50RWxlbS5jbGFzc0xpc3QuYWRkKCdkLW5vbmUnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHJlc3VsdHNQYXJlbnRFbGVtKTtcbiAgICAgICAgICAgIHRoaXMuX3Rlc3RUaW1lRnJhbWVTZXR0aW5nID0gbmV3IFNldHRpbmdOdW1iZXIoJ1Rlc3RUaW1lRnJhbWUnLCAnVGVzdCBUaW1lIEZyYW1lJywgJ0hvdyBsb25nIHRoZSB0ZXN0IHJ1bnMgZm9yIChzZWNvbmRzKScsIDAgLyptaW4qLywgMzYwMCAvKm1heCovLCA2MCAvKmRlZmF1bHQqLywgZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgdGVzdFRpbWVGcmFtZVNldHRpbmcgPSBuZXcgU2V0dGluZ1VJTnVtYmVyKHRoaXMuX3Rlc3RUaW1lRnJhbWVTZXR0aW5nKTtcbiAgICAgICAgICAgIHJlc3VsdHNQYXJlbnRFbGVtLmFwcGVuZENoaWxkKHRlc3RUaW1lRnJhbWVTZXR0aW5nLnJvb3RFbGVtZW50KTtcbiAgICAgICAgICAgIHJlc3VsdHNQYXJlbnRFbGVtLmFwcGVuZENoaWxkKHRoaXMubGF0ZW5jeVRlc3RCdXR0b24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290RWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGxhdGVuY3lUZXN0QnV0dG9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xhdGVuY3lUZXN0QnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbi50eXBlID0gJ2J1dHRvbic7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbi52YWx1ZSA9ICdSdW4gVGVzdCc7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbi5pZCA9ICdidG4tc3RhcnQtbGF0ZW5jeS10ZXN0JztcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lUZXN0QnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3N0cmVhbVRvb2xzLWJ1dHRvbicpO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24uY2xhc3NMaXN0LmFkZCgnYnRuLWZsYXQnKTtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lUZXN0QnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlbmN5UmVjb3JkcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDb2xsZWN0aW5nU3RhdHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lUZXN0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbi52YWx1ZSA9ICdSdW5uaW5nLi4uJztcbiAgICAgICAgICAgICAgICBMb2dnZXIuSW5mbyhgU3RhcnRpbmcgc2Vzc2lvbiB0ZXN0LiBEdXJhdGlvbjogWyR7dGhpcy5fdGVzdFRpbWVGcmFtZVNldHRpbmcubnVtYmVyfV1gKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNvbGxlY3RpbmdGaW5pc2hlZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbi52YWx1ZSA9ICdSdW4gVGVzdCc7XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5fdGVzdFRpbWVGcmFtZVNldHRpbmcubnVtYmVyICogMTAwMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbjtcbiAgICB9XG4gICAgaGFuZGxlU3RhdHMoc3RhdHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29sbGVjdGluZ1N0YXRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHNDb3B5ID0gc3RydWN0dXJlZENsb25lKHN0YXRzKTtcbiAgICAgICAgdGhpcy5yZWNvcmRzLnB1c2goc3RhdHNDb3B5KTtcbiAgICB9XG4gICAgaGFuZGxlTGF0ZW5jeUluZm8obGF0ZW5jeUluZm8pIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29sbGVjdGluZ1N0YXRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF0ZW5jeUluZm9Db3B5ID0gc3RydWN0dXJlZENsb25lKGxhdGVuY3lJbmZvKTtcbiAgICAgICAgdGhpcy5sYXRlbmN5UmVjb3Jkcy5wdXNoKGxhdGVuY3lJbmZvQ29weSk7XG4gICAgfVxuICAgIG9uQ29sbGVjdGluZ0ZpbmlzaGVkKCkge1xuICAgICAgICB0aGlzLmlzQ29sbGVjdGluZ1N0YXRzID0gZmFsc2U7XG4gICAgICAgIExvZ2dlci5JbmZvKGBGaW5pc2hlZCBzZXNzaW9uIHRlc3RgKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZVN0YXRzQ3N2KCk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVMYXRlbmN5Q3N2KCk7XG4gICAgfVxuICAgIGdlbmVyYXRlU3RhdHNDc3YoKSB7XG4gICAgICAgIGNvbnN0IGNzdkhlYWRlciA9IFtdO1xuICAgICAgICB0aGlzLnJlY29yZHMuZm9yRWFjaCgocmVjb3JkKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgaW4gcmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gcmVjb3JkW2ldO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvYmoubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5VmFsID0gb2JqW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIGFycmF5VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzdkhlYWRlci5pbmRleE9mKGAke2l9LiR7an0uJHtrfWApID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3ZIZWFkZXIucHVzaChgJHtpfS4ke2p9LiR7a31gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaiBpbiBvYmoua2V5cygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXBWYWwgPSBvYmouZ2V0KGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIG1hcFZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3ZIZWFkZXIuaW5kZXhPZihgJHtpfS4ke2p9LiR7a31gKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3N2SGVhZGVyLnB1c2goYCR7aX0uJHtqfS4ke2t9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGogaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3N2SGVhZGVyLmluZGV4T2YoYCR7aX0uJHtqfWApID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzdkhlYWRlci5wdXNoKGAke2l9LiR7an1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjc3ZCb2R5ID0gJyc7XG4gICAgICAgIHRoaXMucmVjb3Jkcy5mb3JFYWNoKChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgIGNzdkhlYWRlci5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNzdkJvZHkgKz0gYFwiJHtmaWVsZC5zcGxpdCgnLicpLnJlZHVjZSgobywgaykgPT4gb1trXSwgcmVjb3JkKX1cIixgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICBjc3ZCb2R5ICs9IGBcIlwiLGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjc3ZCb2R5ICs9IGBcXG5gO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmlsZSA9IG5ldyBCbG9iKFtgJHtjc3ZIZWFkZXIuam9pbignLCcpfVxcbiR7Y3N2Qm9keX1gXSwgeyB0eXBlOiAndGV4dC9wbGFpbicgfSk7XG4gICAgICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XG4gICAgICAgIGEuaHJlZiA9IHVybDtcbiAgICAgICAgYS5kb3dubG9hZCA9ICdzdGF0cy5jc3YnO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO1xuICAgICAgICBhLmNsaWNrKCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhKTtcbiAgICAgICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICBnZW5lcmF0ZUxhdGVuY3lDc3YoKSB7XG4gICAgICAgIGNvbnN0IGNzdkhlYWRlciA9IFtdO1xuICAgICAgICB0aGlzLmxhdGVuY3lSZWNvcmRzLmZvckVhY2goKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIGluIHJlY29yZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHJlY29yZFtpXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBqIGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzdkhlYWRlci5pbmRleE9mKGAke2l9LiR7an1gKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3ZIZWFkZXIucHVzaChgJHtpfS4ke2p9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3N2SGVhZGVyLmluZGV4T2YoYCR7aX1gKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3N2SGVhZGVyLnB1c2goYCR7aX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgY3N2Qm9keSA9ICcnO1xuICAgICAgICB0aGlzLmxhdGVuY3lSZWNvcmRzLmZvckVhY2goKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgY3N2SGVhZGVyLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY3N2Qm9keSArPSBgXCIke2ZpZWxkLnNwbGl0KCcuJykucmVkdWNlKChvLCBrKSA9PiBvW2tdLCByZWNvcmQpfVwiLGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIGNzdkJvZHkgKz0gYFwiXCIsYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNzdkJvZHkgKz0gYFxcbmA7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmaWxlID0gbmV3IEJsb2IoW2Ake2NzdkhlYWRlci5qb2luKCcsJyl9XFxuJHtjc3ZCb2R5fWBdLCB7IHR5cGU6ICd0ZXh0L3BsYWluJyB9KTtcbiAgICAgICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcbiAgICAgICAgYS5ocmVmID0gdXJsO1xuICAgICAgICBhLmRvd25sb2FkID0gJ2xhdGVuY3kuY3N2JztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTtcbiAgICAgICAgYS5jbGljaygpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYSk7XG4gICAgICAgICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXNzaW9uVGVzdC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBTZXR0aW5ncyBpY29uIHRoYXQgY2FuIGJlIGNsaWNrZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXR0aW5nc0ljb24ge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGhlIGJ1dHRvbiBjb250YWluaW5nIHRoZSBzZXR0aW5ncyBpY29uLlxuICAgICAqL1xuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnR5cGUgPSAnYnV0dG9uJztcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ1VpVG9vbCcpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuaWQgPSAnc2V0dGluZ3NCdG4nO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zZXR0aW5nc0ljb24pO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy50b29sdGlwVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RFbGVtZW50O1xuICAgIH1cbiAgICBnZXQgdG9vbHRpcFRleHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9vbHRpcFRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFRleHQuY2xhc3NMaXN0LmFkZCgndG9vbHRpcHRleHQnKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBUZXh0LmlubmVySFRNTCA9ICdTZXR0aW5ncyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rvb2x0aXBUZXh0O1xuICAgIH1cbiAgICBnZXQgc2V0dGluZ3NJY29uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3NldHRpbmdzSWNvbikge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NJY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzSWNvbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaWQnLCAnc2V0dGluZ3NJY29uJyk7XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5nc0ljb24uc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gnLCAnMHB4Jyk7XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5nc0ljb24uc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLCAnMHB4Jyk7XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5nc0ljb24uc2V0QXR0cmlidXRlTlMobnVsbCwgJ3ZpZXdCb3gnLCAnMCAwIDQ3OC43MDMgNDc4LjcwMycpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIHN2ZyBncm91cCBmb3IgdGhlIHBhdGhzXG4gICAgICAgICAgICBjb25zdCBzdmdHcm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnZycpO1xuICAgICAgICAgICAgc3ZnR3JvdXAuY2xhc3NMaXN0LmFkZCgnc3ZnSWNvbicpO1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NJY29uLmFwcGVuZENoaWxkKHN2Z0dyb3VwKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBwYXRocyBmb3IgdGhlIGljb24gaXRzZWxmLCB0aGUgaW5uZXIgYW5kIG91dCBwYXRoIG9mIGEgY29nXG4gICAgICAgICAgICBjb25zdCBwYXRoMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncGF0aCcpO1xuICAgICAgICAgICAgcGF0aDEuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCAnTTQ1NC4yLDE4OS4xMDFsLTMzLjYtNS43Yy0zLjUtMTEuMy04LTIyLjItMTMuNS0zMi42bDE5LjgtMjcuN2M4LjQtMTEuOCw3LjEtMjcuOS0zLjItMzguMWwtMjkuOC0yOS44XFxcblx0XHRcdGMtNS42LTUuNi0xMy04LjctMjAuOS04LjdjLTYuMiwwLTEyLjEsMS45LTE3LjEsNS41bC0yNy44LDE5LjhjLTEwLjgtNS43LTIyLjEtMTAuNC0zMy44LTEzLjlsLTUuNi0zMy4yXFxcblx0XHRcdGMtMi40LTE0LjMtMTQuNy0yNC43LTI5LjItMjQuN2gtNDIuMWMtMTQuNSwwLTI2LjgsMTAuNC0yOS4yLDI0LjdsLTUuOCwzNGMtMTEuMiwzLjUtMjIuMSw4LjEtMzIuNSwxMy43bC0yNy41LTE5LjhcXFxuXHRcdFx0Yy01LTMuNi0xMS01LjUtMTcuMi01LjVjLTcuOSwwLTE1LjQsMy4xLTIwLjksOC43bC0yOS45LDI5LjhjLTEwLjIsMTAuMi0xMS42LDI2LjMtMy4yLDM4LjFsMjAsMjguMVxcXG5cdFx0XHRjLTUuNSwxMC41LTkuOSwyMS40LTEzLjMsMzIuN2wtMzMuMiw1LjZjLTE0LjMsMi40LTI0LjcsMTQuNy0yNC43LDI5LjJ2NDIuMWMwLDE0LjUsMTAuNCwyNi44LDI0LjcsMjkuMmwzNCw1LjhcXFxuXHRcdFx0YzMuNSwxMS4yLDguMSwyMi4xLDEzLjcsMzIuNWwtMTkuNywyNy40Yy04LjQsMTEuOC03LjEsMjcuOSwzLjIsMzguMWwyOS44LDI5LjhjNS42LDUuNiwxMyw4LjcsMjAuOSw4LjdjNi4yLDAsMTIuMS0xLjksMTcuMS01LjVcXFxuXHRcdFx0bDI4LjEtMjBjMTAuMSw1LjMsMjAuNyw5LjYsMzEuNiwxM2w1LjYsMzMuNmMyLjQsMTQuMywxNC43LDI0LjcsMjkuMiwyNC43aDQyLjJjMTQuNSwwLDI2LjgtMTAuNCwyOS4yLTI0LjdsNS43LTMzLjZcXFxuXHRcdFx0YzExLjMtMy41LDIyLjItOCwzMi42LTEzLjVsMjcuNywxOS44YzUsMy42LDExLDUuNSwxNy4yLDUuNWwwLDBjNy45LDAsMTUuMy0zLjEsMjAuOS04LjdsMjkuOC0yOS44YzEwLjItMTAuMiwxMS42LTI2LjMsMy4yLTM4LjFcXFxuXHRcdFx0bC0xOS44LTI3LjhjNS41LTEwLjUsMTAuMS0yMS40LDEzLjUtMzIuNmwzMy42LTUuNmMxNC4zLTIuNCwyNC43LTE0LjcsMjQuNy0yOS4ydi00Mi4xXFxcblx0XHRcdEM0NzguOSwyMDMuODAxLDQ2OC41LDE5MS41MDEsNDU0LjIsMTg5LjEwMXogTTQ1MS45LDI2MC40MDFjMCwxLjMtMC45LDIuNC0yLjIsMi42bC00Miw3Yy01LjMsMC45LTkuNSw0LjgtMTAuOCw5LjlcXFxuXHRcdFx0Yy0zLjgsMTQuNy05LjYsMjguOC0xNy40LDQxLjljLTIuNyw0LjYtMi41LDEwLjMsMC42LDE0LjdsMjQuNywzNC44YzAuNywxLDAuNiwyLjUtMC4zLDMuNGwtMjkuOCwyOS44Yy0wLjcsMC43LTEuNCwwLjgtMS45LDAuOFxcXG5cdFx0XHRjLTAuNiwwLTEuMS0wLjItMS41LTAuNWwtMzQuNy0yNC43Yy00LjMtMy4xLTEwLjEtMy4zLTE0LjctMC42Yy0xMy4xLDcuOC0yNy4yLDEzLjYtNDEuOSwxNy40Yy01LjIsMS4zLTkuMSw1LjYtOS45LDEwLjhsLTcuMSw0MlxcXG5cdFx0XHRjLTAuMiwxLjMtMS4zLDIuMi0yLjYsMi4yaC00Mi4xYy0xLjMsMC0yLjQtMC45LTIuNi0yLjJsLTctNDJjLTAuOS01LjMtNC44LTkuNS05LjktMTAuOGMtMTQuMy0zLjctMjguMS05LjQtNDEtMTYuOFxcXG5cdFx0XHRjLTIuMS0xLjItNC41LTEuOC02LjgtMS44Yy0yLjcsMC01LjUsMC44LTcuOCwyLjVsLTM1LDI0LjljLTAuNSwwLjMtMSwwLjUtMS41LDAuNWMtMC40LDAtMS4yLTAuMS0xLjktMC44bC0yOS44LTI5LjhcXFxuXHRcdFx0Yy0wLjktMC45LTEtMi4zLTAuMy0zLjRsMjQuNi0zNC41YzMuMS00LjQsMy4zLTEwLjIsMC42LTE0LjhjLTcuOC0xMy0xMy44LTI3LjEtMTcuNi00MS44Yy0xLjQtNS4xLTUuNi05LTEwLjgtOS45bC00Mi4zLTcuMlxcXG5cdFx0XHRjLTEuMy0wLjItMi4yLTEuMy0yLjItMi42di00Mi4xYzAtMS4zLDAuOS0yLjQsMi4yLTIuNmw0MS43LTdjNS4zLTAuOSw5LjYtNC44LDEwLjktMTBjMy43LTE0LjcsOS40LTI4LjksMTcuMS00MlxcXG5cdFx0XHRjMi43LTQuNiwyLjQtMTAuMy0wLjctMTQuNmwtMjQuOS0zNWMtMC43LTEtMC42LTIuNSwwLjMtMy40bDI5LjgtMjkuOGMwLjctMC43LDEuNC0wLjgsMS45LTAuOGMwLjYsMCwxLjEsMC4yLDEuNSwwLjVsMzQuNSwyNC42XFxcblx0XHRcdGM0LjQsMy4xLDEwLjIsMy4zLDE0LjgsMC42YzEzLTcuOCwyNy4xLTEzLjgsNDEuOC0xNy42YzUuMS0xLjQsOS01LjYsOS45LTEwLjhsNy4yLTQyLjNjMC4yLTEuMywxLjMtMi4yLDIuNi0yLjJoNDIuMVxcXG5cdFx0XHRjMS4zLDAsMi40LDAuOSwyLjYsMi4ybDcsNDEuN2MwLjksNS4zLDQuOCw5LjYsMTAsMTAuOWMxNS4xLDMuOCwyOS41LDkuNyw0Mi45LDE3LjZjNC42LDIuNywxMC4zLDIuNSwxNC43LTAuNmwzNC41LTI0LjhcXFxuXHRcdFx0YzAuNS0wLjMsMS0wLjUsMS41LTAuNWMwLjQsMCwxLjIsMC4xLDEuOSwwLjhsMjkuOCwyOS44YzAuOSwwLjksMSwyLjMsMC4zLDMuNGwtMjQuNywzNC43Yy0zLjEsNC4zLTMuMywxMC4xLTAuNiwxNC43XFxcblx0XHRcdGM3LjgsMTMuMSwxMy42LDI3LjIsMTcuNCw0MS45YzEuMyw1LjIsNS42LDkuMSwxMC44LDkuOWw0Miw3LjFjMS4zLDAuMiwyLjIsMS4zLDIuMiwyLjZ2NDIuMUg0NTEuOXonKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGgyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdwYXRoJyk7XG4gICAgICAgICAgICBwYXRoMi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsICdNMjM5LjQsMTM2LjAwMWMtNTcsMC0xMDMuMyw0Ni4zLTEwMy4zLDEwMy4zczQ2LjMsMTAzLjMsMTAzLjMsMTAzLjNzMTAzLjMtNDYuMywxMDMuMy0xMDMuM1MyOTYuNCwxMzYuMDAxLDIzOS40LDEzNi4wMDF6IE0yMzkuNCwzMTUuNjAxYy00Mi4xLDAtNzYuMy0zNC4yLTc2LjMtNzYuM3MzNC4yLTc2LjMsNzYuMy03Ni4zczc2LjMsMzQuMiw3Ni4zLDc2LjNTMjgxLjUsMzE1LjYwMSwyMzkuNCwzMTUuNjAxeicpO1xuICAgICAgICAgICAgc3ZnR3JvdXAuYXBwZW5kQ2hpbGQocGF0aDEpO1xuICAgICAgICAgICAgc3ZnR3JvdXAuYXBwZW5kQ2hpbGQocGF0aDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5nc0ljb247XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2V0dGluZ3NJY29uLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIEEgVUkgY29tcG9uZW50IGNvbnRhaW5pbmcgYWxsIHRoZSBzZXR0aW5ncyBmb3IgdGhlIGFwcGxpY2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgU2V0dGluZ3NQYW5lbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgUmV0dXJuIG9yIGNyZWF0ZXMgYSBIVE1MIGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIHRoaXMgc2V0dGluZyBpbiB0aGUgRE9NLlxuICAgICAqL1xuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmlkID0gJ3NldHRpbmdzLXBhbmVsJztcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3BhbmVsLXdyYXAnKTtcbiAgICAgICAgICAgIGNvbnN0IHBhbmVsRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgcGFuZWxFbGVtLmNsYXNzTGlzdC5hZGQoJ3BhbmVsJyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5hcHBlbmRDaGlsZChwYW5lbEVsZW0pO1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NIZWFkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBzZXR0aW5nc0hlYWRpbmcuaWQgPSAnc2V0dGluZ3NIZWFkaW5nJztcbiAgICAgICAgICAgIHNldHRpbmdzSGVhZGluZy50ZXh0Q29udGVudCA9ICdTZXR0aW5ncyc7XG4gICAgICAgICAgICBwYW5lbEVsZW0uYXBwZW5kQ2hpbGQoc2V0dGluZ3NIZWFkaW5nKTtcbiAgICAgICAgICAgIHBhbmVsRWxlbS5hcHBlbmRDaGlsZCh0aGlzLnNldHRpbmdzQ2xvc2VCdXR0b24pO1xuICAgICAgICAgICAgcGFuZWxFbGVtLmFwcGVuZENoaWxkKHRoaXMuc2V0dGluZ3NDb250ZW50RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RFbGVtZW50O1xuICAgIH1cbiAgICBnZXQgc2V0dGluZ3NDb250ZW50RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zZXR0aW5nc0NvbnRlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5nc0NvbnRlbnRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5nc0NvbnRlbnRFbGVtZW50LmlkID0gJ3NldHRpbmdzQ29udGVudCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzQ29udGVudEVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBzZXR0aW5nc0Nsb3NlQnV0dG9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3NldHRpbmdzQ2xvc2VCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzQ2xvc2VCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzQ2xvc2VCdXR0b24uaWQgPSAnc2V0dGluZ3NDbG9zZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzQ2xvc2VCdXR0b247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgc2V0dGluZ3MgcGFuZWwuXG4gICAgICovXG4gICAgc2hvdygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvb3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygncGFuZWwtd3JhcC12aXNpYmxlJykpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgncGFuZWwtd3JhcC12aXNpYmxlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBzZXR0aW5ncyBwYW5lbC5cbiAgICAgKi9cbiAgICB0b2dnbGVWaXNpYmlsaXR5KCkge1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoJ3BhbmVsLXdyYXAtdmlzaWJsZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlIHNldHRpbmdzIHBhbmVsLlxuICAgICAqL1xuICAgIGhpZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygncGFuZWwtd3JhcC12aXNpYmxlJykpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgncGFuZWwtd3JhcC12aXNpYmxlJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXR0aW5nc1BhbmVsLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIFN0YXRzIGljb24gdGhhdCBjYW4gYmUgY2xpY2tlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXRzSWNvbiB7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0aGUgYnV0dG9uIGNvbnRhaW5pbmcgdGhlIHN0YXRzIGljb24uXG4gICAgICovXG4gICAgZ2V0IHJvb3RFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQudHlwZSA9ICdidXR0b24nO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnVWlUb29sJyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5pZCA9ICdzdGF0c0J0bic7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnN0YXRzSWNvbik7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnRvb2x0aXBUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCB0b29sdGlwVGV4dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b29sdGlwVGV4dCkge1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwVGV4dC5jbGFzc0xpc3QuYWRkKCd0b29sdGlwdGV4dCcpO1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFRleHQuaW5uZXJIVE1MID0gJ0luZm9ybWF0aW9uJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdG9vbHRpcFRleHQ7XG4gICAgfVxuICAgIGdldCBzdGF0c0ljb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3RhdHNJY29uKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0c0ljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3N2ZycpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdHNJY29uLnNldEF0dHJpYnV0ZU5TKG51bGwsICdpZCcsICdzdGF0c0ljb24nKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRzSWNvbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsICcwcHgnKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRzSWNvbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneScsICcwcHgnKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRzSWNvbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndmlld0JveCcsICcwIDAgMzMwIDMzMCcpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIHN2ZyBncm91cCBmb3IgdGhlIHBhdGhzXG4gICAgICAgICAgICBjb25zdCBzdmdHcm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnZycpO1xuICAgICAgICAgICAgc3ZnR3JvdXAuY2xhc3NMaXN0LmFkZCgnc3ZnSWNvbicpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdHNJY29uLmFwcGVuZENoaWxkKHN2Z0dyb3VwKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBwYXRocyBmb3IgdGhlIGljb24gaXRzZWxmLCB0aGUgaW5uZXIgYW5kIG91dCBwYXRoIG9mIGEgY29nXG4gICAgICAgICAgICBjb25zdCBwYXRoMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncGF0aCcpO1xuICAgICAgICAgICAgcGF0aDEuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCAnTTE2NSwwLjAwOEM3NC4wMTksMC4wMDgsMCw3NC4wMjQsMCwxNjQuOTk5YzAsOTAuOTc3LDc0LjAxOSwxNjQuOTkyLDE2NSwxNjQuOTkyczE2NS03NC4wMTUsMTY1LTE2NC45OTJDMzMwLDc0LjAyNCwyNTUuOTgxLDAuMDA4LDE2NSwwLjAwOHogTTE2NSwyOTkuOTkyYy03NC40MzksMC0xMzUtNjAuNTU3LTEzNS0xMzQuOTkyUzkwLjU2MSwzMC4wMDgsMTY1LDMwLjAwOHMxMzUsNjAuNTU3LDEzNSwxMzQuOTkxQzMwMCwyMzkuNDM2LDIzOS40MzksMjk5Ljk5MiwxNjUsMjk5Ljk5MnonKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGgyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdwYXRoJyk7XG4gICAgICAgICAgICBwYXRoMi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsICdNMTY1LDEzMC4wMDhjLTguMjg0LDAtMTUsNi43MTYtMTUsMTV2OTkuOTgzYzAsOC4yODQsNi43MTYsMTUsMTUsMTVzMTUtNi43MTYsMTUtMTV2LTk5Ljk4M0MxODAsMTM2LjcyNSwxNzMuMjg0LDEzMC4wMDgsMTY1LDEzMC4wMDh6Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXRoMyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncGF0aCcpO1xuICAgICAgICAgICAgcGF0aDMuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCAnTTE2NSw3MC4wMTFjLTMuOTUsMC03LjgxMSwxLjYtMTAuNjEsNC4zOWMtMi43OSwyLjc5LTQuMzksNi42Ni00LjM5LDEwLjYxczEuNiw3LjgxLDQuMzksMTAuNjFjMi43OSwyLjc5LDYuNjYsNC4zOSwxMC42MSw0LjM5czcuODEtMS42LDEwLjYwOS00LjM5YzIuNzktMi44LDQuMzkxLTYuNjYsNC4zOTEtMTAuNjFzLTEuNjAxLTcuODItNC4zOTEtMTAuNjFDMTcyLjgxLDcxLjYxLDE2OC45NSw3MC4wMTEsMTY1LDcwLjAxMXonKTtcbiAgICAgICAgICAgIHN2Z0dyb3VwLmFwcGVuZENoaWxkKHBhdGgxKTtcbiAgICAgICAgICAgIHN2Z0dyb3VwLmFwcGVuZENoaWxkKHBhdGgyKTtcbiAgICAgICAgICAgIHN2Z0dyb3VwLmFwcGVuZENoaWxkKHBhdGgzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHNJY29uO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YXRzSWNvbi5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTGF0ZW5jeVRlc3QgfSBmcm9tICcuL0xhdGVuY3lUZXN0JztcbmltcG9ydCB7IExvZ2dlciwgRmxhZ3MgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2Zyb250ZW5kLXVlNS42JztcbmltcG9ydCB7IE1hdGhVdGlscyB9IGZyb20gJy4uL1V0aWwvTWF0aFV0aWxzJztcbmltcG9ydCB7IERhdGFDaGFubmVsTGF0ZW5jeVRlc3QgfSBmcm9tICcuL0RhdGFDaGFubmVsTGF0ZW5jeVRlc3QnO1xuaW1wb3J0IHsgU2Vzc2lvblRlc3QgfSBmcm9tICcuL1Nlc3Npb25UZXN0JztcbmltcG9ydCB7IGlzU2VjdGlvbkVuYWJsZWQsIFN0YXRzU2VjdGlvbnMgfSBmcm9tICcuL1VJQ29uZmlndXJhdGlvblR5cGVzJztcbi8qKlxuICogQSBzdGF0IHN0cnVjdHVyZSwgYW4gaWQsIHRoZSBzdGF0IHN0cmluZywgYW5kIHRoZSBlbGVtZW50IHdoZXJlIGl0IGlzIHJlbmRlcmVkLlxuICovXG5leHBvcnQgY2xhc3MgU3RhdCB7XG59XG4vKipcbiAqIEEgVUkgY29tcG9uZW50IGNvbnRhaW5pbmcgYWxsIHRoZSBzdGF0cyBmb3IgdGhlIGFwcGxpY2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgU3RhdHNQYW5lbCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzdHJlYW1Db25maWcpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uVGVzdCA9IG51bGw7XG4gICAgICAgIC8qIEEgbWFwIHN0YXRzIHdlIGFyZSBzdG9yaW5nL3JlbmRlcmluZyAqL1xuICAgICAgICB0aGlzLnN0YXRzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIHRoZSBzZXNzaW9uIHRlc3QgY2xhc3MvdWktZWxlbWVudHMgaWYgdGhlID9MYXRlbmN5Q1NWIGZsYWcgaXMgZW5hYmxlZC5cbiAgICAgICAgdGhpcy5zZXNzaW9uVGVzdCA9IHN0cmVhbUNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkxhdGVuY3lDU1YpID8gbmV3IFNlc3Npb25UZXN0KCkgOiBudWxsO1xuICAgICAgICB0aGlzLmxhdGVuY3lUZXN0ID0gbmV3IExhdGVuY3lUZXN0KCk7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWxMYXRlbmN5VGVzdCA9IG5ldyBEYXRhQ2hhbm5lbExhdGVuY3lUZXN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFJldHVybiBvciBjcmVhdGVzIGEgSFRNTCBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyB0aGlzIHNldHRpbmcgaW4gdGhlIERPTS5cbiAgICAgKi9cbiAgICBnZXQgcm9vdEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5pZCA9ICdzdGF0cy1wYW5lbCc7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdwYW5lbC13cmFwJyk7XG4gICAgICAgICAgICBjb25zdCBwYW5lbEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHBhbmVsRWxlbS5jbGFzc0xpc3QuYWRkKCdwYW5lbCcpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQocGFuZWxFbGVtKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRzSGVhZGluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgc3RhdHNIZWFkaW5nLmlkID0gJ3N0YXRzSGVhZGluZyc7XG4gICAgICAgICAgICBzdGF0c0hlYWRpbmcudGV4dENvbnRlbnQgPSAnSW5mb3JtYXRpb24nO1xuICAgICAgICAgICAgcGFuZWxFbGVtLmFwcGVuZENoaWxkKHN0YXRzSGVhZGluZyk7XG4gICAgICAgICAgICBwYW5lbEVsZW0uYXBwZW5kQ2hpbGQodGhpcy5zdGF0c0Nsb3NlQnV0dG9uKTtcbiAgICAgICAgICAgIHBhbmVsRWxlbS5hcHBlbmRDaGlsZCh0aGlzLnN0YXRzQ29udGVudEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290RWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IHN0YXRzQ29udGVudEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3RhdHNDb250ZW50RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdHNDb250ZW50RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdHNDb250ZW50RWxlbWVudC5pZCA9ICdzdGF0c0NvbnRlbnQnO1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtVG9vbFN0YXRzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBzdHJlYW1Ub29sU3RhdHMuaWQgPSAnc3RyZWFtVG9vbHNTdGF0cyc7XG4gICAgICAgICAgICBzdHJlYW1Ub29sU3RhdHMuY2xhc3NMaXN0LmFkZCgnY29udGFpbmVyJyk7XG4gICAgICAgICAgICBjb25zdCBjb250cm9sU3RhdHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGNvbnRyb2xTdGF0cy5pZCA9ICdDb250cm9sU3RhdHMnO1xuICAgICAgICAgICAgY29udHJvbFN0YXRzLmNsYXNzTGlzdC5hZGQoJ3JvdycpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGlzdGljcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlY3Rpb24nKTtcbiAgICAgICAgICAgIHN0YXRpc3RpY3MuaWQgPSAnc3RhdGlzdGljcyc7XG4gICAgICAgICAgICBzdGF0aXN0aWNzLmNsYXNzTGlzdC5hZGQoJ3NldHRpbmdzQ29udGFpbmVyJyk7XG4gICAgICAgICAgICBjb25zdCBsYXRlbmN5U3RhdHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWN0aW9uJyk7XG4gICAgICAgICAgICBsYXRlbmN5U3RhdHMuaWQgPSAnbGF0ZW5jeVN0YXRzJztcbiAgICAgICAgICAgIGxhdGVuY3lTdGF0cy5jbGFzc0xpc3QuYWRkKCdzZXR0aW5nc0NvbnRhaW5lcicpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGlzdGljc0hlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgc3RhdGlzdGljc0hlYWRlci5pZCA9ICdzdGF0aXN0aWNzSGVhZGVyJztcbiAgICAgICAgICAgIHN0YXRpc3RpY3NIZWFkZXIuY2xhc3NMaXN0LmFkZCgnc2V0dGluZ3MtdGV4dCcpO1xuICAgICAgICAgICAgc3RhdGlzdGljc0hlYWRlci5jbGFzc0xpc3QuYWRkKCdzZXR0aW5nc0hlYWRlcicpO1xuICAgICAgICAgICAgY29uc3QgbGF0ZW5jeVN0YXRzSGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBsYXRlbmN5U3RhdHNIZWFkZXIuaWQgPSAnbGF0ZW5jeVN0YXRzSGVhZGVyJztcbiAgICAgICAgICAgIGxhdGVuY3lTdGF0c0hlYWRlci5jbGFzc0xpc3QuYWRkKCdzZXR0aW5ncy10ZXh0Jyk7XG4gICAgICAgICAgICBsYXRlbmN5U3RhdHNIZWFkZXIuY2xhc3NMaXN0LmFkZCgnc2V0dGluZ3NIZWFkZXInKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRzQ29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc3RyZWFtVG9vbFN0YXRzKTtcbiAgICAgICAgICAgIHN0cmVhbVRvb2xTdGF0cy5hcHBlbmRDaGlsZChjb250cm9sU3RhdHMpO1xuICAgICAgICAgICAgLy8gQWRkIHNlc3NzaW9uIHRlc3QgdG8gdGhlIFVJIGlmID9MYXRlbmN5Q1NWIGZsYWcgaXMgZW5hYmxlZCBhbmQgY29uZmlnIGFsbG93cyBpdC5cbiAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb25UZXN0ICYmIGlzU2VjdGlvbkVuYWJsZWQodGhpcy5fY29uZmlnLCBTdGF0c1NlY3Rpb25zLlNlc3Npb25UZXN0KSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xTdGF0cy5hcHBlbmRDaGlsZCh0aGlzLnNlc3Npb25UZXN0LnJvb3RFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xTdGF0cy5hcHBlbmRDaGlsZChzdGF0aXN0aWNzKTtcbiAgICAgICAgICAgIGNvbnRyb2xTdGF0cy5hcHBlbmRDaGlsZChsYXRlbmN5U3RhdHMpO1xuICAgICAgICAgICAgc3RhdGlzdGljcy5hcHBlbmRDaGlsZChzdGF0aXN0aWNzSGVhZGVyKTtcbiAgICAgICAgICAgIGxhdGVuY3lTdGF0cy5hcHBlbmRDaGlsZChsYXRlbmN5U3RhdHNIZWFkZXIpO1xuICAgICAgICAgICAgaWYgKGlzU2VjdGlvbkVuYWJsZWQodGhpcy5fY29uZmlnLCBTdGF0c1NlY3Rpb25zLlNlc3Npb25TdGF0cykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uU3RhdHNUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvblN0YXRzVGV4dC5pbm5lckhUTUwgPSBTdGF0c1NlY3Rpb25zLlNlc3Npb25TdGF0cztcbiAgICAgICAgICAgICAgICBzdGF0aXN0aWNzSGVhZGVyLmFwcGVuZENoaWxkKHNlc3Npb25TdGF0c1RleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGlzdGljcy5hcHBlbmRDaGlsZCh0aGlzLnN0YXRpc3RpY3NDb250YWluZXIpO1xuICAgICAgICAgICAgaWYgKGlzU2VjdGlvbkVuYWJsZWQodGhpcy5fY29uZmlnLCBTdGF0c1NlY3Rpb25zLkxhdGVuY3lTdGF0cykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXRlbmN5U3RhdHNUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgbGF0ZW5jeVN0YXRzVGV4dC5pbm5lckhUTUwgPSBTdGF0c1NlY3Rpb25zLkxhdGVuY3lTdGF0cztcbiAgICAgICAgICAgICAgICBsYXRlbmN5U3RhdHNIZWFkZXIuYXBwZW5kQ2hpbGQobGF0ZW5jeVN0YXRzVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXRlbmN5U3RhdHMuYXBwZW5kQ2hpbGQodGhpcy5sYXRlbmN5U3RhdHNDb250YWluZXIpO1xuICAgICAgICAgICAgaWYgKGlzU2VjdGlvbkVuYWJsZWQodGhpcy5fY29uZmlnLCBTdGF0c1NlY3Rpb25zLkxhdGVuY3lUZXN0KSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xTdGF0cy5hcHBlbmRDaGlsZCh0aGlzLmxhdGVuY3lUZXN0LnJvb3RFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1NlY3Rpb25FbmFibGVkKHRoaXMuX2NvbmZpZywgU3RhdHNTZWN0aW9ucy5EYXRhQ2hhbm5lbExhdGVuY3lUZXN0KSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xTdGF0cy5hcHBlbmRDaGlsZCh0aGlzLmRhdGFDaGFubmVsTGF0ZW5jeVRlc3Qucm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0c0NvbnRlbnRFbGVtZW50O1xuICAgIH1cbiAgICBnZXQgc3RhdGlzdGljc0NvbnRhaW5lcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0aXN0aWNzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0aXN0aWNzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0aXN0aWNzQ29udGFpbmVyLmlkID0gJ3N0YXRpc3RpY3NDb250YWluZXInO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGlzdGljc0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdkLW5vbmUnKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRpc3RpY3NDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zdGF0c1Jlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRpc3RpY3NDb250YWluZXI7XG4gICAgfVxuICAgIGdldCBsYXRlbmN5U3RhdHNDb250YWluZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbGF0ZW5jeVN0YXRzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5U3RhdHNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lTdGF0c0NvbnRhaW5lci5pZCA9ICdsYXRlbmN5U3RhdHNDb250YWluZXInO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVN0YXRzQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2Qtbm9uZScpO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVN0YXRzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubGF0ZW5jeVJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhdGVuY3lTdGF0c0NvbnRhaW5lcjtcbiAgICB9XG4gICAgZ2V0IHN0YXRzUmVzdWx0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXRzUmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0c1Jlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdHNSZXN1bHQuaWQgPSAnc3RhdGlzdGljc1Jlc3VsdCc7XG4gICAgICAgICAgICB0aGlzLl9zdGF0c1Jlc3VsdC5jbGFzc0xpc3QuYWRkKCdTdGF0c1Jlc3VsdCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0c1Jlc3VsdDtcbiAgICB9XG4gICAgZ2V0IGxhdGVuY3lSZXN1bHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbGF0ZW5jeVJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVJlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVJlc3VsdC5pZCA9ICdsYXRlbmN5UmVzdWx0JztcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lSZXN1bHQuY2xhc3NMaXN0LmFkZCgnU3RhdHNSZXN1bHQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbGF0ZW5jeVJlc3VsdDtcbiAgICB9XG4gICAgZ2V0IHN0YXRzQ2xvc2VCdXR0b24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3RhdHNDbG9zZUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5fc3RhdHNDbG9zZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdHNDbG9zZUJ1dHRvbi5pZCA9ICdzdGF0c0Nsb3NlJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHNDbG9zZUJ1dHRvbjtcbiAgICB9XG4gICAgb25EaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmxhdGVuY3lUZXN0LmxhdGVuY3lUZXN0QnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWxMYXRlbmN5VGVzdC5sYXRlbmN5VGVzdEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgLy9kbyBub3RoaW5nXG4gICAgICAgIH07XG4gICAgfVxuICAgIG9uVmlkZW9Jbml0aWFsaXplZChzdHJlYW0pIHtcbiAgICAgICAgLy8gc3RhcnRpbmcgYSBsYXRlbmN5IGNoZWNrXG4gICAgICAgIHRoaXMubGF0ZW5jeVRlc3QubGF0ZW5jeVRlc3RCdXR0b24ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIHN0cmVhbS5yZXF1ZXN0TGF0ZW5jeVRlc3QoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbExhdGVuY3lUZXN0LmxhdGVuY3lUZXN0QnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGFydGVkID0gc3RyZWFtLnJlcXVlc3REYXRhQ2hhbm5lbExhdGVuY3lUZXN0KHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTAwMCxcbiAgICAgICAgICAgICAgICBycHM6IDEwLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RTaXplOiAyMDAsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VTaXplOiAyMDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDaGFubmVsTGF0ZW5jeVRlc3QuaGFuZGxlVGVzdFN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbmZpZ3VyZShzZXR0aW5ncykge1xuICAgICAgICBpZiAoc2V0dGluZ3MuRGlzYWJsZUxhdGVuY3lUZXN0KSB7XG4gICAgICAgICAgICB0aGlzLmxhdGVuY3lUZXN0LmxhdGVuY3lUZXN0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubGF0ZW5jeVRlc3QubGF0ZW5jeVRlc3RCdXR0b24udGl0bGUgPSAnRGlzYWJsZWQgYnkgLVBpeGVsU3RyZWFtaW5nRGlzYWJsZUxhdGVuY3lUZXN0ZXI9dHJ1ZSc7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFubmVsTGF0ZW5jeVRlc3QubGF0ZW5jeVRlc3RCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbExhdGVuY3lUZXN0LmxhdGVuY3lUZXN0QnV0dG9uLnRpdGxlID1cbiAgICAgICAgICAgICAgICAnRGlzYWJsZWQgYnkgLVBpeGVsU3RyZWFtaW5nRGlzYWJsZUxhdGVuY3lUZXN0ZXI9dHJ1ZSc7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLVBpeGVsU3RyZWFtaW5nRGlzYWJsZUxhdGVuY3lUZXN0ZXI9dHJ1ZSwgcmVxdWVzdGluZyBsYXRlbmN5IHJlcG9ydCBmcm9tIHRoZSB0aGUgYnJvd3NlciB0byBVRSBpcyBkaXNhYmxlZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHN0YXRzIHBhbmVsLlxuICAgICAqL1xuICAgIHNob3coKSB7XG4gICAgICAgIGlmICghdGhpcy5yb290RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3BhbmVsLXdyYXAtdmlzaWJsZScpKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3BhbmVsLXdyYXAtdmlzaWJsZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgc3RhdHMgcGFuZWwuXG4gICAgICovXG4gICAgdG9nZ2xlVmlzaWJpbGl0eSgpIHtcbiAgICAgICAgdGhpcy5yb290RWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCdwYW5lbC13cmFwLXZpc2libGUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgc3RhdHMgcGFuZWwuXG4gICAgICovXG4gICAgaGlkZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYW5lbC13cmFwLXZpc2libGUnKSkge1xuICAgICAgICAgICAgdGhpcy5yb290RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdwYW5lbC13cmFwLXZpc2libGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVQbGF5ZXJDb3VudChwbGF5ZXJDb3VudCkge1xuICAgICAgICB0aGlzLmFkZE9yVXBkYXRlU2Vzc2lvblN0YXQoJ1BsYXllckNvdW50U3RhdCcsICdQbGF5ZXJzJywgcGxheWVyQ291bnQudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBzdGF0cyBjb21pbmcgaW4gZnJvbSBicm93c2VyL1VFXG4gICAgICogQHBhcmFtIHN0YXRzIC0gdGhlIHN0YXRzIHN0cnVjdHVyZVxuICAgICAqL1xuICAgIGhhbmRsZVN0YXRzKHN0YXRzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgLy8gZm9ybWF0IG51bWJlcmluZyBiYXNlZCBvbiB0aGUgYnJvd3NlciBsYW5ndWFnZVxuICAgICAgICBjb25zdCBudW1iZXJGb3JtYXQgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQod2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZSwge1xuICAgICAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uVGVzdCkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uVGVzdC5oYW5kbGVTdGF0cyhzdGF0cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5ib3VuZCBkYXRhXG4gICAgICAgIGNvbnN0IGluYm91bmREYXRhID0gTWF0aFV0aWxzLmZvcm1hdEJ5dGVzKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmJ5dGVzUmVjZWl2ZWQsIDIpO1xuICAgICAgICB0aGlzLmFkZE9yVXBkYXRlU2Vzc2lvblN0YXQoJ0luYm91bmREYXRhU3RhdCcsICdSZWNlaXZlZCcsIGluYm91bmREYXRhKTtcbiAgICAgICAgLy8gUGFja2V0cyBsb3N0XG4gICAgICAgIGNvbnN0IHBhY2tldHNMb3N0U3RhdCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cywgJ3BhY2tldHNMb3N0JylcbiAgICAgICAgICAgID8gbnVtYmVyRm9ybWF0LmZvcm1hdChzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5wYWNrZXRzTG9zdClcbiAgICAgICAgICAgIDogJ0Nocm9tZSBvbmx5JztcbiAgICAgICAgdGhpcy5hZGRPclVwZGF0ZVNlc3Npb25TdGF0KCdQYWNrZXRzTG9zdFN0YXQnLCAnUGFja2V0cyBMb3N0JywgcGFja2V0c0xvc3RTdGF0KTtcbiAgICAgICAgLy8gQml0cmF0ZVxuICAgICAgICBpZiAoc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuYml0cmF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRPclVwZGF0ZVNlc3Npb25TdGF0KCdWaWRlb0JpdHJhdGVTdGF0JywgJ1ZpZGVvIEJpdHJhdGUgKGticHMpJywgc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuYml0cmF0ZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHMuaW5ib3VuZEF1ZGlvU3RhdHMuYml0cmF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRPclVwZGF0ZVNlc3Npb25TdGF0KCdBdWRpb0JpdHJhdGVTdGF0JywgJ0F1ZGlvIEJpdHJhdGUgKGticHMpJywgc3RhdHMuaW5ib3VuZEF1ZGlvU3RhdHMuYml0cmF0ZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWaWRlbyByZXNvbHV0aW9uXG4gICAgICAgIGNvbnN0IHJlc1N0YXQgPSBzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZVdpZHRoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lV2lkdGggPiAwICYmXG4gICAgICAgICAgICBzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZUhlaWdodCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZUhlaWdodCA+IDBcbiAgICAgICAgICAgID8gc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuZnJhbWVXaWR0aCArICd4JyArIHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lSGVpZ2h0XG4gICAgICAgICAgICA6ICdDaHJvbWUgb25seSc7XG4gICAgICAgIHRoaXMuYWRkT3JVcGRhdGVTZXNzaW9uU3RhdCgnVmlkZW9SZXNTdGF0JywgJ1ZpZGVvIHJlc29sdXRpb24nLCByZXNTdGF0KTtcbiAgICAgICAgLy8gRnJhbWVzIGRlY29kZWRcbiAgICAgICAgaWYgKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lc0RlY29kZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZnJhbWVzRGVjb2RlZCA9IG51bWJlckZvcm1hdC5mb3JtYXQoc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuZnJhbWVzRGVjb2RlZCk7XG4gICAgICAgICAgICB0aGlzLmFkZE9yVXBkYXRlU2Vzc2lvblN0YXQoJ0ZyYW1lc0RlY29kZWRTdGF0JywgJ0ZyYW1lcyBEZWNvZGVkJywgZnJhbWVzRGVjb2RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRnJhbWVyYXRlXG4gICAgICAgIGlmIChzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZXNQZXJTZWNvbmQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JVcGRhdGVTZXNzaW9uU3RhdCgnRnJhbWVyYXRlU3RhdCcsICdGcmFtZXJhdGUnLCBzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZXNQZXJTZWNvbmQudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRnJhbWVzIGRyb3BwZWRcbiAgICAgICAgaWYgKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lc0Ryb3BwZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hZGRPclVwZGF0ZVNlc3Npb25TdGF0KCdGcmFtZXNEcm9wcGVkU3RhdCcsICdGcmFtZXMgZHJvcHBlZCcsIHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lc0Ryb3BwZWQudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmNvZGVjSWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JVcGRhdGVTZXNzaW9uU3RhdCgnVmlkZW9Db2RlY1N0YXQnLCAnVmlkZW8gY29kZWMnLCBcbiAgICAgICAgICAgIC8vIFNwbGl0IHRoZSBjb2RlYyB0byByZW1vdmUgdGhlIEZtdHAgbGluZVxuICAgICAgICAgICAgKF9iID0gKF9hID0gc3RhdHMuY29kZWNzLmdldChzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5jb2RlY0lkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1pbWVUeXBlLnJlcGxhY2UoJ3ZpZGVvLycsICcnKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0cy5pbmJvdW5kQXVkaW9TdGF0cy5jb2RlY0lkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yVXBkYXRlU2Vzc2lvblN0YXQoJ0F1ZGlvQ29kZWNTdGF0JywgJ0F1ZGlvIGNvZGVjJywgXG4gICAgICAgICAgICAvLyBTcGxpdCB0aGUgY29kZWMgdG8gcmVtb3ZlIHRoZSBGbXRwIGxpbmVcbiAgICAgICAgICAgIChfZCA9IChfYyA9IHN0YXRzLmNvZGVjcy5nZXQoc3RhdHMuaW5ib3VuZEF1ZGlvU3RhdHMuY29kZWNJZCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5taW1lVHlwZS5yZXBsYWNlKCdhdWRpby8nLCAnJykpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9yZSB0aGUgYWN0aXZlIGNhbmRpZGF0ZSBwYWlyIHJldHVybiBhIG5ldyBDYW5kaWRhdGUgcGFpciBzdGF0IGlmIGdldEFjdGl2ZUNhbmRpZGF0ZSBpcyBudWxsXG4gICAgICAgIGNvbnN0IGFjdGl2ZUNhbmRpZGF0ZVBhaXIgPSBzdGF0cy5nZXRBY3RpdmVDYW5kaWRhdGVQYWlyKCk7XG4gICAgICAgIGlmIChhY3RpdmVDYW5kaWRhdGVQYWlyKSB7XG4gICAgICAgICAgICAvLyBSVFRcbiAgICAgICAgICAgIGNvbnN0IG5ldFJUVCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhY3RpdmVDYW5kaWRhdGVQYWlyLCAnY3VycmVudFJvdW5kVHJpcFRpbWUnKSAmJlxuICAgICAgICAgICAgICAgIHN0YXRzLmlzTnVtYmVyKGFjdGl2ZUNhbmRpZGF0ZVBhaXIuY3VycmVudFJvdW5kVHJpcFRpbWUpXG4gICAgICAgICAgICAgICAgPyBNYXRoLmNlaWwoYWN0aXZlQ2FuZGlkYXRlUGFpci5jdXJyZW50Um91bmRUcmlwVGltZSAqIDEwMDApLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICA6IFwiQ2FuJ3QgY2FsY3VsYXRlXCI7XG4gICAgICAgICAgICB0aGlzLmFkZE9yVXBkYXRlU2Vzc2lvblN0YXQoJ1JUVFN0YXQnLCAnTmV0IFJUVCAobXMpJywgbmV0UlRUKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZE9yVXBkYXRlU2Vzc2lvblN0YXQoJ0R1cmF0aW9uU3RhdCcsICdEdXJhdGlvbicsIHN0YXRzLnNlc3Npb25TdGF0cy5ydW5UaW1lKTtcbiAgICAgICAgdGhpcy5hZGRPclVwZGF0ZVNlc3Npb25TdGF0KCdDb250cm9sc0lucHV0U3RhdCcsICdDb250cm9scyBzdHJlYW0gaW5wdXQnLCBzdGF0cy5zZXNzaW9uU3RhdHMuY29udHJvbHNTdHJlYW1JbnB1dCk7XG4gICAgICAgIC8vIFFQXG4gICAgICAgIGlmIChzdGF0cy5zZXNzaW9uU3RhdHMudmlkZW9FbmNvZGVyQXZnUVAgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgIU51bWJlci5pc05hTihzdGF0cy5zZXNzaW9uU3RhdHMudmlkZW9FbmNvZGVyQXZnUVApKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yVXBkYXRlU2Vzc2lvblN0YXQoJ1FQU3RhdCcsICdWaWRlbyBxdWFudGl6YXRpb24gcGFyYW1ldGVyJywgc3RhdHMuc2Vzc2lvblN0YXRzLnZpZGVvRW5jb2RlckF2Z1FQLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIExvZ2dlci5JbmZvKGAtLS0tLS0tLS0gU3RhdHMgLS0tLS0tLS0tXFxuICR7SlNPTi5zdHJpbmdpZnkoc3RhdHMpfVxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLWApO1xuICAgIH1cbiAgICBoYW5kbGVMYXRlbmN5SW5mbyhsYXRlbmN5SW5mbykge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uVGVzdCkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uVGVzdC5oYW5kbGVMYXRlbmN5SW5mbyhsYXRlbmN5SW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhdGVuY3lJbmZvLmZyYW1lVGltaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEVuY29kZXIgbGF0ZW5jeVxuICAgICAgICAgICAgaWYgKGxhdGVuY3lJbmZvLmZyYW1lVGltaW5nLmVuY29kZXJMYXRlbmN5TXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkT3JVcGRhdGVMYXRlbmN5U3RhdCgnRW5jb2RlTGF0ZW5jeScsICdFbmNvZGUgbGF0ZW5jeSAobXMpJywgTWF0aC5jZWlsKGxhdGVuY3lJbmZvLmZyYW1lVGltaW5nLmVuY29kZXJMYXRlbmN5TXMpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFja2V0aXplciBsYXRlbmN5XG4gICAgICAgICAgICBpZiAobGF0ZW5jeUluZm8uZnJhbWVUaW1pbmcucGFja2V0aXplTGF0ZW5jeU1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE9yVXBkYXRlTGF0ZW5jeVN0YXQoJ1BhY2tldGl6ZXJMYXRlbmN5JywgJ1BhY2tldGl6ZXIgbGF0ZW5jeSAobXMpJywgTWF0aC5jZWlsKGxhdGVuY3lJbmZvLmZyYW1lVGltaW5nLnBhY2tldGl6ZUxhdGVuY3lNcykudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYWNlciBsYXRlbmN5XG4gICAgICAgICAgICBpZiAobGF0ZW5jeUluZm8uZnJhbWVUaW1pbmcucGFjZXJMYXRlbmN5TXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkT3JVcGRhdGVMYXRlbmN5U3RhdCgnUGFjZXJMYXRlbmN5JywgJ1BhY2VyIGxhdGVuY3kgKG1zKScsIE1hdGguY2VpbChsYXRlbmN5SW5mby5mcmFtZVRpbWluZy5wYWNlckxhdGVuY3lNcykudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZW5kZXIgbGF0ZW5jeSBjYWxjdWxhdGVkIHVzaW5nIHRpbWluZyBzdGF0c1xuICAgICAgICAgICAgaWYgKGxhdGVuY3lJbmZvLmZyYW1lVGltaW5nLmNhcHR1cmVUb1NlbmRMYXRlbmN5TXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkT3JVcGRhdGVMYXRlbmN5U3RhdCgnVmlkZW9UaW1pbmdDYXB0dXJlVG9TZW5kJywgJ1Bvc3QtY2FwdHVyZSB0byBzZW5kIGxhdGVuY3kgKG1zKScsIE1hdGguY2VpbChsYXRlbmN5SW5mby5mcmFtZVRpbWluZy5jYXB0dXJlVG9TZW5kTGF0ZW5jeU1zKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGF0ZW5jeUluZm8uc2VuZGVyTGF0ZW5jeU1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JVcGRhdGVMYXRlbmN5U3RhdCgnQWJzQ2FwdHVyZVRpbWVUb1NlbmRMYXRlbmN5JywgJ1Bvc3QtY2FwdHVyZSAoYWJzLWN0KSB0byBzZW5kIGxhdGVuY3kgKG1zKScsIE1hdGguY2VpbChsYXRlbmN5SW5mby5zZW5kZXJMYXRlbmN5TXMpLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXRlbmN5SW5mby5hdmVyYWdlQXNzZW1ibHlEZWxheU1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JVcGRhdGVMYXRlbmN5U3RhdCgnQXZnQXNzZW1ibHlEZWxheScsICdBc3NlbWJseSBkZWxheSAobXMpJywgTWF0aC5jZWlsKGxhdGVuY3lJbmZvLmF2ZXJhZ2VBc3NlbWJseURlbGF5TXMpLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXRlbmN5SW5mby5hdmVyYWdlRGVjb2RlTGF0ZW5jeU1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JVcGRhdGVMYXRlbmN5U3RhdCgnQXZnRGVjb2RlRGVsYXknLCAnRGVjb2RlIHRpbWUgKG1zKScsIE1hdGguY2VpbChsYXRlbmN5SW5mby5hdmVyYWdlRGVjb2RlTGF0ZW5jeU1zKS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF0ZW5jeUluZm8uYXZlcmFnZUppdHRlckJ1ZmZlckRlbGF5TXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hZGRPclVwZGF0ZUxhdGVuY3lTdGF0KCdBdmdKaXR0ZXJCdWZmZXJEZWxheScsICdKaXR0ZXIgYnVmZmVyIChtcyknLCBNYXRoLmNlaWwobGF0ZW5jeUluZm8uYXZlcmFnZUppdHRlckJ1ZmZlckRlbGF5TXMpLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXRlbmN5SW5mby5hdmVyYWdlUHJvY2Vzc2luZ0RlbGF5TXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hZGRPclVwZGF0ZUxhdGVuY3lTdGF0KCdBdmdQcm9jZXNzaW5nRGVsYXknLCAnUHJvY2Vzc2luZyBkZWxheSAobXMpJywgTWF0aC5jZWlsKGxhdGVuY3lJbmZvLmF2ZXJhZ2VQcm9jZXNzaW5nRGVsYXlNcykudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhdGVuY3lJbmZvLmF2ZXJhZ2VFMkVMYXRlbmN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JVcGRhdGVMYXRlbmN5U3RhdCgnQXZnRTJFTGF0ZW5jeScsICdUb3RhbCBsYXRlbmN5IChtcyknLCBNYXRoLmNlaWwobGF0ZW5jeUluZm8uYXZlcmFnZUUyRUxhdGVuY3kpLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgc3RhdCB0byB0aGUgc3RhdHMgcmVzdWx0cyBpbiB0aGUgRE9NIG9yIHVwZGF0ZXMgYW4gZXhpdGluZyBzdGF0LlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgc3RhdCB0byBhZGQvdXBkYXRlLlxuICAgICAqIEBwYXJhbSBzdGF0IC0gVGhlIGNvbnRlbnRzIG9mIHRoZSBzdGF0LlxuICAgICAqL1xuICAgIGFkZE9yVXBkYXRlU2Vzc2lvblN0YXQoaWQsIHN0YXRMYWJlbCwgc3RhdCkge1xuICAgICAgICB0aGlzLmFkZE9yVXBkYXRlU3RhdChTdGF0c1NlY3Rpb25zLlNlc3Npb25TdGF0cywgaWQsIHN0YXRMYWJlbCwgc3RhdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgc3RhdCB0byB0aGUgbGF0ZW5jeSByZXN1bHRzIGluIHRoZSBET00gb3IgdXBkYXRlcyBhbiBleGl0aW5nIHN0YXQuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBzdGF0IHRvIGFkZC91cGRhdGUuXG4gICAgICogQHBhcmFtIHN0YXQgLSBUaGUgY29udGVudHMgb2YgdGhlIHN0YXQuXG4gICAgICovXG4gICAgYWRkT3JVcGRhdGVMYXRlbmN5U3RhdChpZCwgc3RhdExhYmVsLCBzdGF0KSB7XG4gICAgICAgIHRoaXMuYWRkT3JVcGRhdGVTdGF0KFN0YXRzU2VjdGlvbnMuTGF0ZW5jeVN0YXRzLCBpZCwgc3RhdExhYmVsLCBzdGF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBzdGF0IHRvIHRoZSBzdGF0cyByZXN1bHRzIGluIHRoZSBET00gb3IgdXBkYXRlcyBhbiBleGl0aW5nIHN0YXQuXG4gICAgICogQHBhcmFtIHNlY3Rpb25JZCAtIFRoZSBzZWN0aW9uIHRvIGFkZCB0aGlzIHN0YXQgdG9vLlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgc3RhdCB0byBhZGQvdXBkYXRlLlxuICAgICAqIEBwYXJhbSBzdGF0IC0gVGhlIGNvbnRlbnRzIG9mIHRoZSBzdGF0LlxuICAgICAqL1xuICAgIGFkZE9yVXBkYXRlU3RhdChzZWN0aW9uSWQsIGlkLCBzdGF0TGFiZWwsIHN0YXQpIHtcbiAgICAgICAgaWYgKHNlY3Rpb25JZCA9PT0gU3RhdHNTZWN0aW9ucy5TZXNzaW9uU3RhdHMgJiZcbiAgICAgICAgICAgICFpc1NlY3Rpb25FbmFibGVkKHRoaXMuX2NvbmZpZywgU3RhdHNTZWN0aW9ucy5TZXNzaW9uU3RhdHMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb25JZCA9PT0gU3RhdHNTZWN0aW9ucy5MYXRlbmN5U3RhdHMgJiZcbiAgICAgICAgICAgICFpc1NlY3Rpb25FbmFibGVkKHRoaXMuX2NvbmZpZywgU3RhdHNTZWN0aW9ucy5MYXRlbmN5U3RhdHMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBzdXBwb3J0IHNlc3Npb24gb3IgbGF0ZW5jeSBzdGF0cyBiZWluZyB1cGRhdGVkIGluIHRoaXMgZnVuY3Rpb24gY3VycmVudGx5XG4gICAgICAgIGlmIChzZWN0aW9uSWQgIT09IFN0YXRzU2VjdGlvbnMuU2Vzc2lvblN0YXRzICYmIHNlY3Rpb25JZCAhPT0gU3RhdHNTZWN0aW9ucy5MYXRlbmN5U3RhdHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRFbGVtID0gc2VjdGlvbklkID09PSBTdGF0c1NlY3Rpb25zLlNlc3Npb25TdGF0cyA/IHRoaXMuc3RhdHNSZXN1bHQgOiB0aGlzLmxhdGVuY3lSZXN1bHQ7XG4gICAgICAgIGNvbnN0IHN0YXRIVE1MID0gYCR7c3RhdExhYmVsfTogJHtzdGF0fWA7XG4gICAgICAgIGlmICghdGhpcy5zdGF0c01hcC5oYXMoaWQpKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHN0YXRcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXQgPSBuZXcgU3RhdCgpO1xuICAgICAgICAgICAgbmV3U3RhdC5pZCA9IGlkO1xuICAgICAgICAgICAgbmV3U3RhdC5zdGF0ID0gc3RhdDtcbiAgICAgICAgICAgIG5ld1N0YXQudGl0bGUgPSBzdGF0TGFiZWw7XG4gICAgICAgICAgICBuZXdTdGF0LmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIG5ld1N0YXQuZWxlbWVudC5pbm5lckhUTUwgPSBzdGF0SFRNTDtcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgc3RhdCB0byB0aGUgZG9tXG4gICAgICAgICAgICBwYXJlbnRFbGVtLmFwcGVuZENoaWxkKG5ld1N0YXQuZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRzTWFwLnNldChpZCwgbmV3U3RhdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBleGlzdGluZyBzdGF0XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnN0YXRzTWFwLmdldChpZCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlLmVsZW1lbnQuaW5uZXJIVE1MID0gc3RhdEhUTUw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGF0c1BhbmVsLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5leHBvcnQgY2xhc3MgRXh0cmFGbGFncyB7XG59XG5FeHRyYUZsYWdzLkxpZ2h0TW9kZSA9ICdMaWdodE1vZGUnO1xuLyoqXG4gKiBBbGwgdGhlIFVJIHNlY3Rpb25zIGFjcm9zcyBhbGwgdGhlIHBhbmVscy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNldHRpbmdzU2VjdGlvbnMge1xufVxuU2V0dGluZ3NTZWN0aW9ucy5QaXhlbFN0cmVhbWluZyA9ICdQaXhlbCBTdHJlYW1pbmcnO1xuU2V0dGluZ3NTZWN0aW9ucy5VSSA9ICdVSSc7XG5TZXR0aW5nc1NlY3Rpb25zLklucHV0ID0gJ0lucHV0JztcblNldHRpbmdzU2VjdGlvbnMuRW5jb2RlciA9ICdFbmNvZGVyJztcblNldHRpbmdzU2VjdGlvbnMuV2ViUlRDID0gJ1dlYlJUQyc7XG5TZXR0aW5nc1NlY3Rpb25zLkNvbW1hbmRzID0gJ0NvbW1hbmRzJztcbmV4cG9ydCBjbGFzcyBTdGF0c1NlY3Rpb25zIHtcbn1cblN0YXRzU2VjdGlvbnMuU2Vzc2lvblN0YXRzID0gJ1Nlc3Npb24gU3RhdHMnO1xuU3RhdHNTZWN0aW9ucy5MYXRlbmN5U3RhdHMgPSAnTGF0ZW5jeSBTdGF0cyc7XG5TdGF0c1NlY3Rpb25zLkxhdGVuY3lUZXN0ID0gJ0xhdGVuY3kgVGVzdCc7XG5TdGF0c1NlY3Rpb25zLkRhdGFDaGFubmVsTGF0ZW5jeVRlc3QgPSAnRGF0YSBDaGFubmVsIExhdGVuY3kgVGVzdCc7XG5TdGF0c1NlY3Rpb25zLlNlc3Npb25UZXN0ID0gJ1Nlc3Npb24gVGVzdCc7XG4vKiogV2hldGhlciBhIHN0cmVhbSBVSSBlbGVtZW50IGlzIGludGVybmFsbHkgbWFkZSwgZXh0ZXJuYWxseSBwcm92aWRlZCwgb3IgZGlzYWJsZWQuICovXG5leHBvcnQgdmFyIFVJRWxlbWVudENyZWF0aW9uTW9kZTtcbihmdW5jdGlvbiAoVUlFbGVtZW50Q3JlYXRpb25Nb2RlKSB7XG4gICAgVUlFbGVtZW50Q3JlYXRpb25Nb2RlW1VJRWxlbWVudENyZWF0aW9uTW9kZVtcIkNyZWF0ZURlZmF1bHRFbGVtZW50XCJdID0gMF0gPSBcIkNyZWF0ZURlZmF1bHRFbGVtZW50XCI7XG4gICAgVUlFbGVtZW50Q3JlYXRpb25Nb2RlW1VJRWxlbWVudENyZWF0aW9uTW9kZVtcIlVzZUN1c3RvbUVsZW1lbnRcIl0gPSAxXSA9IFwiVXNlQ3VzdG9tRWxlbWVudFwiO1xuICAgIFVJRWxlbWVudENyZWF0aW9uTW9kZVtVSUVsZW1lbnRDcmVhdGlvbk1vZGVbXCJEaXNhYmxlXCJdID0gMl0gPSBcIkRpc2FibGVcIjtcbn0pKFVJRWxlbWVudENyZWF0aW9uTW9kZSB8fCAoVUlFbGVtZW50Q3JlYXRpb25Nb2RlID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBpc1BhbmVsRW5hYmxlZChjb25maWcpIHtcbiAgICByZXR1cm4gIWNvbmZpZyB8fCAoISFjb25maWcgJiYgY29uZmlnLmlzRW5hYmxlZCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTZWN0aW9uRW5hYmxlZChjb25maWcsIHNlY3Rpb24pIHtcbiAgICByZXR1cm4gKCFjb25maWcgfHxcbiAgICAgICAgKCEhY29uZmlnICYmXG4gICAgICAgICAgICAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcuc2VjdGlvblZpc2liaWxpdHksIHNlY3Rpb24pIHx8XG4gICAgICAgICAgICAgICAgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcuc2VjdGlvblZpc2liaWxpdHksIHNlY3Rpb24pICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zZWN0aW9uVmlzaWJpbGl0eVtzZWN0aW9uXSkpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTZXR0aW5nRW5hYmxlZChjb25maWcsIHNldHRpbmcpIHtcbiAgICByZXR1cm4gKCFjb25maWcgfHxcbiAgICAgICAgKCEhY29uZmlnICYmXG4gICAgICAgICAgICAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcuc2V0dGluZ1Zpc2liaWxpdHksIHNldHRpbmcpIHx8XG4gICAgICAgICAgICAgICAgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcuc2V0dGluZ1Zpc2liaWxpdHksIHNldHRpbmcpICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zZXR0aW5nVmlzaWJpbGl0eVtzZXR0aW5nXSkpKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VSUNvbmZpZ3VyYXRpb25UeXBlcy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBBIFVJIGVsZW1lbnQgc2hvd2luZyB0aGUgUVAgKHF1YW50aXphdGlvbiBwYXJhbWV0ZXIpIG9mIHRoZSB2aWRlbyBzdHJlYW0gYXQgdGhlIGxhc3QgZW5jb2RlZCBmcmFtZSAod2VsbCwgbGFzdCB0cmFuc21pdHRlZCBRUCByZWFsbHkpLlxuICogQSBibG9ja2llciBlbmNvZGluZyB3aWxsIGhhdmUgYSBoaWdoZXIgUVAgYW5kIHRoaXMgd2lsbCBtYWtlIHRoZSBpbmRpY2F0b3IgdHVybiBtb3JlIHJlZC5cbiAqIEEgbm9uLWJsb2NreSBzdHJlYW0gd2lsbCBoYXZlIGEgbG93ZXIgUVAgYW5kIHRoaXMgd2lsbCBtYWtlIHRoZSBpbmRpY2F0b3IgdHVybiBtb3JlIGdyZWVuLlxuICogVGhlIFFQIGluZGljYXRvciBpcyByZXByZXNlbnRlZCB2aXN1YWxseSB1c2luZyBhIFdpRmkgaWNvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFZpZGVvUXBJbmRpY2F0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLnZpZGVvRW5jb2RlckF2Z1FQID0gLTE7XG4gICAgICAgIC8vIG5vbiBodG1sIGVsZW1lbnRzXG4gICAgICAgIHRoaXMuc3RhdHNUZXh0ID0gJyc7XG4gICAgICAgIHRoaXMuY29sb3IgPSAnJztcbiAgICAgICAgLy8gcXAgY29sb3JzXG4gICAgICAgIHRoaXMub3JhbmdlUVAgPSAyNjtcbiAgICAgICAgdGhpcy5yZWRRUCA9IDM1O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByb290IGVsZW1lbnQgb2YgdGhlIFFQIGluZGljYXRvci5cbiAgICAgKi9cbiAgICBnZXQgcm9vdEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJvb3QgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBzdmcgZm9yIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuaWQgPSAnY29ubmVjdGlvbic7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdVaVRvb2wnKTtcbiAgICAgICAgICAgIC8vIGFkZCBzdmcgaWNvbiBmb3IgdGhlIGNvbm5lY3Rpb24gc3RyZW5ndGhcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMucXVhbGl0eVN0YXR1cyk7XG4gICAgICAgICAgICAvLyBhZGQgdGhlIHRleHQgdW5kZXJuZWF0aCB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5xdWFsaXR5VGV4dCk7XG4gICAgICAgICAgICAvLyBzZXQgY29sb3JzIHRvIG5vdCBjb25uZWN0ZWQgaW5pdGlhbGx5XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVFwVG9vbHRpcCgtMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RFbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRleHQgdGhhdCBkaXNwbGF5cyB1bmRlciB0aGUgaWNvbi5cbiAgICAgKi9cbiAgICBnZXQgcXVhbGl0eVRleHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcXVhbGl0eVRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3F1YWxpdHlUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgdGhpcy5fcXVhbGl0eVRleHQuaWQgPSAncXVhbGl0eVRleHQnO1xuICAgICAgICAgICAgdGhpcy5fcXVhbGl0eVRleHQuY2xhc3NMaXN0LmFkZCgndG9vbHRpcHRleHQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcXVhbGl0eVRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaWNvbi5cbiAgICAgKi9cbiAgICBnZXQgcXVhbGl0eVN0YXR1cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9xdWFsaXR5U3RhdHVzKSB7XG4gICAgICAgICAgICB0aGlzLl9xdWFsaXR5U3RhdHVzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgICAgICAgICAgIHRoaXMuX3F1YWxpdHlTdGF0dXMuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2lkJywgJ2Nvbm5lY3Rpb25TdHJlbmd0aCcpO1xuICAgICAgICAgICAgdGhpcy5fcXVhbGl0eVN0YXR1cy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsICcwcHgnKTtcbiAgICAgICAgICAgIHRoaXMuX3F1YWxpdHlTdGF0dXMuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLCAnMHB4Jyk7XG4gICAgICAgICAgICB0aGlzLl9xdWFsaXR5U3RhdHVzLnNldEF0dHJpYnV0ZU5TKG51bGwsICd2aWV3Qm94JywgJzAgMCA0OTQuNDUgNDk0LjQ1Jyk7XG4gICAgICAgICAgICAvLyBidWlsZCB3aWZpIGljb25cbiAgICAgICAgICAgIHRoaXMucXVhbGl0eVN0YXR1cy5hcHBlbmRDaGlsZCh0aGlzLmRvdCk7XG4gICAgICAgICAgICB0aGlzLnF1YWxpdHlTdGF0dXMuYXBwZW5kQ2hpbGQodGhpcy5taWRkbGUpO1xuICAgICAgICAgICAgdGhpcy5xdWFsaXR5U3RhdHVzLmFwcGVuZENoaWxkKHRoaXMub3V0ZXIpO1xuICAgICAgICAgICAgdGhpcy5xdWFsaXR5U3RhdHVzLmFwcGVuZENoaWxkKHRoaXMuaW5uZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9xdWFsaXR5U3RhdHVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRvdCBhdCB0aGUgYm90dG9tIG9mIHRoZSB3aWZpIGljb24uXG4gICAgICovXG4gICAgZ2V0IGRvdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2RvdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnY2lyY2xlJyk7XG4gICAgICAgICAgICB0aGlzLl9kb3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ2lkJywgJ2RvdCcpO1xuICAgICAgICAgICAgdGhpcy5fZG90LnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeCcsICcyNDcuMTI1Jyk7XG4gICAgICAgICAgICB0aGlzLl9kb3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N5JywgJzM5OC45MjUnKTtcbiAgICAgICAgICAgIHRoaXMuX2RvdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAncicsICczNS4zJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvdXRlciBhcmMgb2YgdGhlIHdpZmkgaWNvbi5cbiAgICAgKi9cbiAgICBnZXQgb3V0ZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fb3V0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX291dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdwYXRoJyk7XG4gICAgICAgICAgICB0aGlzLl9vdXRlci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaWQnLCAnb3V0ZXInKTtcbiAgICAgICAgICAgIHRoaXMuX291dGVyLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ000NjcuOTI1LDIwNC42MjVjLTYuOCwwLTEzLjUtMi42LTE4LjctNy44Yy0xMTEuNS0xMTEuNC0yOTIuNy0xMTEuNC00MDQuMSwwYy0xMC4zLDEwLjMtMjcuMSwxMC4zLTM3LjQsMHMtMTAuMy0yNy4xLDAtMzcuNGM2NC02NCwxNDktOTkuMiwyMzkuNS05OS4yczE3NS41LDM1LjIsMjM5LjUsOTkuMmMxMC4zLDEwLjMsMTAuMywyNy4xLDAsMzcuNEM0ODEuNDI1LDIwMi4wMjUsNDc0LjYyNSwyMDQuNjI1LDQ2Ny45MjUsMjA0LjYyNXonKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fb3V0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbWlkZGxlIGFyYyBvZiB0aGUgd2lmaSBpY29uLlxuICAgICAqL1xuICAgIGdldCBtaWRkbGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWlkZGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9taWRkbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3BhdGgnKTtcbiAgICAgICAgICAgIHRoaXMuX21pZGRsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaWQnLCAnbWlkZGxlJyk7XG4gICAgICAgICAgICB0aGlzLl9taWRkbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCAnTTM5NS4yMjUsMjc3LjMyNWMtNi44LDAtMTMuNS0yLjYtMTguNy03LjhjLTcxLjQtNzEuMy0xODcuNC03MS4zLTI1OC44LDBjLTEwLjMsMTAuMy0yNy4xLDEwLjMtMzcuNCwwcy0xMC4zLTI3LjEsMC0zNy40YzkyLTkyLDI0MS42LTkyLDMzMy42LDBjMTAuMywxMC4zLDEwLjMsMjcuMSwwLDM3LjRDNDA4LjcyNSwyNzQuNzI1LDQwMS45MjUsMjc3LjMyNSwzOTUuMjI1LDI3Ny4zMjV6Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21pZGRsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbm5lciBhcmMgb2YgdGhlIHdpZmkgaWNvbi5cbiAgICAgKi9cbiAgICBnZXQgaW5uZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5faW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2lubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdwYXRoJyk7XG4gICAgICAgICAgICB0aGlzLl9pbm5lci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaWQnLCAnaW5uZXInKTtcbiAgICAgICAgICAgIHRoaXMuX2lubmVyLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ00zMjMuNjI1LDM0OC44MjVjLTYuOCwwLTEzLjUtMi42LTE4LjctNy44Yy0xNS40LTE1LjQtMzYtMjMuOS01Ny44LTIzLjlzLTQyLjQsOC41LTU3LjgsMjMuOWMtMTAuMywxMC4zLTI3LjEsMTAuMy0zNy40LDBjLTEwLjMtMTAuMy0xMC4zLTI3LjEsMC0zNy40YzI1LjQtMjUuNCw1OS4yLTM5LjQsOTUuMi0zOS40czY5LjgsMTQsOTUuMiwzOS41YzEwLjMsMTAuMywxMC4zLDI3LjEsMCwzNy40QzMzNy4yMjUsMzQ2LjIyNSwzMzAuNDI1LDM0OC44MjUsMzIzLjYyNSwzNDguODI1eicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBzZXQgdGhlIHNwZWVkIG9mIHRoZSBzdGF0dXMgbGlnaHQuXG4gICAgICogQHBhcmFtIHNwZWVkIC0gU2V0IHRoZSBzcGVlZCBvZiB0aGUgYmxpbmssIGhpZ2hlciBudW1iZXJzIG1ha2UgdGhlIHN0YXR1cyBsaWdodCBibGluayBmYXN0ZXIuXG4gICAgICovXG4gICAgYmxpbmtWaWRlb1F1YWxpdHlTdGF0dXMoc3BlZWQpIHtcbiAgICAgICAgbGV0IGl0ZXJhdGlvbiA9IHNwZWVkO1xuICAgICAgICBsZXQgb3BhY2l0eSA9IDE7XG4gICAgICAgIGNvbnN0IHRpY2tJRCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIG9wYWNpdHkgLT0gMC4xO1xuICAgICAgICAgICAgdGhpcy5xdWFsaXR5VGV4dC5zdHlsZS5vcGFjaXR5ID0gU3RyaW5nKE1hdGguYWJzKChvcGFjaXR5IC0gMC41KSAqIDIpKTtcbiAgICAgICAgICAgIGlmIChvcGFjaXR5IDw9IDAuMSkge1xuICAgICAgICAgICAgICAgIGlmICgtLWl0ZXJhdGlvbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGlja0lEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwIC8gc3BlZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB1cGRhdGVzIHRoZSBRUCB0b29sdGlwIGJ5IGNvbnZlcnRpbmcgdGhlIFZpZGVvIEVuY29kZXIgUVAgdG8gYSBjb2xvciBsaWdodFxuICAgICAqIEBwYXJhbSBRUCAtIFRoZSB2aWRlbyBlbmNvZGVyIFFQIG51bWJlciBuZWVkZWQgdG8gZmluZCB0aGUgYXZlcmFnZVxuICAgICAqL1xuICAgIHVwZGF0ZVFwVG9vbHRpcChRUCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMudmlkZW9FbmNvZGVyQXZnUVAgPSBRUDtcbiAgICAgICAgaWYgKFFQID4gdGhpcy5yZWRRUCkge1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9ICdyZWQnO1xuICAgICAgICAgICAgdGhpcy5ibGlua1ZpZGVvUXVhbGl0eVN0YXR1cygyKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHNUZXh0ID0gYDxkaXYgc3R5bGU9XCJjb2xvcjogJHt0aGlzLmNvbG9yfVwiPlBvb3IgZW5jb2RpbmcgcXVhbGl0eTwvZGl2PmA7XG4gICAgICAgICAgICB0aGlzLm91dGVyLnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJyMzYzNiNDAnKTtcbiAgICAgICAgICAgIHRoaXMubWlkZGxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJyMzYzNiNDAnKTtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCB0aGlzLmNvbG9yKTtcbiAgICAgICAgICAgIHRoaXMuZG90LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgdGhpcy5jb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUVAgPiB0aGlzLm9yYW5nZVFQKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gJ29yYW5nZSc7XG4gICAgICAgICAgICB0aGlzLmJsaW5rVmlkZW9RdWFsaXR5U3RhdHVzKDEpO1xuICAgICAgICAgICAgdGhpcy5zdGF0c1RleHQgPSBgPGRpdiBzdHlsZT1cImNvbG9yOiAke3RoaXMuY29sb3J9XCI+QmxvY2t5IGVuY29kaW5nIHF1YWxpdHk8L2Rpdj5gO1xuICAgICAgICAgICAgdGhpcy5vdXRlci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICcjM2MzYjQwJyk7XG4gICAgICAgICAgICB0aGlzLm1pZGRsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsIHRoaXMuY29sb3IpO1xuICAgICAgICAgICAgdGhpcy5pbm5lci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsIHRoaXMuY29sb3IpO1xuICAgICAgICAgICAgdGhpcy5kb3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCB0aGlzLmNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChRUCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gJyNiMGIwYjAnO1xuICAgICAgICAgICAgdGhpcy5vdXRlci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICcjM2MzYjQwJyk7XG4gICAgICAgICAgICB0aGlzLm1pZGRsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICcjM2MzYjQwJyk7XG4gICAgICAgICAgICB0aGlzLmlubmVyLnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJyMzYzNiNDAnKTtcbiAgICAgICAgICAgIHRoaXMuZG90LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJyMzYzNiNDAnKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHNUZXh0ID0gYDxkaXYgc3R5bGU9XCJjb2xvcjogJHt0aGlzLmNvbG9yfVwiPk5vdCBjb25uZWN0ZWQ8L2Rpdj5gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9ICdsaW1lJztcbiAgICAgICAgICAgIHRoaXMucXVhbGl0eVN0YXR1cy5zdHlsZS5vcGFjaXR5ID0gKChfYSA9IHRoaXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGlkZVdoZW5Hb29kKSA9PSB0cnVlID8gJzAnIDogJzEnO1xuICAgICAgICAgICAgdGhpcy5zdGF0c1RleHQgPSBgPGRpdiBzdHlsZT1cImNvbG9yOiAke3RoaXMuY29sb3J9XCI+Q2xlYXIgZW5jb2RpbmcgcXVhbGl0eTwvZGl2PmA7XG4gICAgICAgICAgICB0aGlzLm91dGVyLnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgdGhpcy5jb2xvcik7XG4gICAgICAgICAgICB0aGlzLm1pZGRsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsIHRoaXMuY29sb3IpO1xuICAgICAgICAgICAgdGhpcy5pbm5lci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsIHRoaXMuY29sb3IpO1xuICAgICAgICAgICAgdGhpcy5kb3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCB0aGlzLmNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnF1YWxpdHlUZXh0LmlubmVySFRNTCA9IHRoaXMuc3RhdHNUZXh0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpZGVvUXBJbmRpY2F0b3IuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogWFIgaWNvbiB0aGF0IGNhbiBiZSBjbGlja2VkLlxuICovXG5leHBvcnQgY2xhc3MgWFJJY29uIHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRoZSBidXR0b24gY29udGFpbmluZyB0aGUgWFIgaWNvbi5cbiAgICAgKi9cbiAgICBnZXQgcm9vdEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC50eXBlID0gJ2J1dHRvbic7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdVaVRvb2wnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmlkID0gJ3hyQnRuJztcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMueHJJY29uKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudG9vbHRpcFRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290RWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IHRvb2x0aXBUZXh0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rvb2x0aXBUZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBUZXh0LmNsYXNzTGlzdC5hZGQoJ3Rvb2x0aXB0ZXh0Jyk7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwVGV4dC5pbm5lckhUTUwgPSAnWFInO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90b29sdGlwVGV4dDtcbiAgICB9XG4gICAgZ2V0IHhySWNvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl94ckljb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3hySWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG4gICAgICAgICAgICB0aGlzLl94ckljb24uc2V0QXR0cmlidXRlTlMobnVsbCwgJ2lkJywgJ3hySWNvbicpO1xuICAgICAgICAgICAgdGhpcy5feHJJY29uLnNldEF0dHJpYnV0ZU5TKG51bGwsICd4JywgJzBweCcpO1xuICAgICAgICAgICAgdGhpcy5feHJJY29uLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5JywgJzBweCcpO1xuICAgICAgICAgICAgdGhpcy5feHJJY29uLnNldEF0dHJpYnV0ZU5TKG51bGwsICd2aWV3Qm94JywgJzAgMCAxMDAgMTAwJyk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgc3ZnIGdyb3VwIGZvciB0aGUgcGF0aHNcbiAgICAgICAgICAgIGNvbnN0IHN2Z0dyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdnJyk7XG4gICAgICAgICAgICBzdmdHcm91cC5jbGFzc0xpc3QuYWRkKCdzdmdJY29uJyk7XG4gICAgICAgICAgICB0aGlzLl94ckljb24uYXBwZW5kQ2hpbGQoc3ZnR3JvdXApO1xuICAgICAgICAgICAgLy8gY3JlYXRlIHBhdGhzIGZvciB0aGUgaWNvbiBpdHNlbGYsIHRoZSBwYXRoIG9mIHRoZSB4ciBoZWFkc2V0XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdwYXRoJyk7XG4gICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ00yOSA0MWMtNSAwLTkgNC05IDlzNCA5IDkgOSA5LTQgOS05LTQtOS05LTl6bTAgMTRjLTIuOCAwLTUtMi4yLTUtNXMyLjItNSA1LTUgNSAyLjIgNSA1LTIuMiA1LTUgNXptNDItMTRjLTUgMC05IDQtOSA5czQgOSA5IDkgOS00IDktOS00LTktOS05em0wIDE0Yy0yLjggMC01LTIuMi01LTVzMi4yLTUgNS01IDUgMi4yIDUgNS0yLjIgNS01IDV6bTEyLTMxSDE3Yy02LjYgMC0xMiA1LjQtMTIgMTJ2MjhjMCA2LjYgNS40IDEyIDEyIDEyaDE0LjVjMy41IDAgNi44LTEuNSA5LTQuMWwzLjUtNGMxLjUtMS43IDMuNy0yLjcgNi0yLjdzNC41IDEgNiAyLjdsMy41IDRjMi4zIDIuNiA1LjYgNC4xIDkgNC4xSDgzYzYuNiAwIDEyLTUuNCAxMi0xMlYzNmMwLTYuNi01LjQtMTItMTItMTJ6bTggNDBjMCA0LjQtMy42IDgtOCA4SDY4LjVjLTIuMyAwLTQuNS0xLTYtMi43bC0zLjUtNGMtMi4zLTIuNi01LjYtNC4xLTktNC4xLTMuNSAwLTYuOCAxLjUtOSA0LjFsLTMuNSA0QzM2IDcxIDMzLjggNzIgMzEuNSA3MkgxN2MtNC40IDAtOC0zLjYtOC04VjM2YzAtNC40IDMuNi04IDgtOGg2NmM0LjQgMCA4IDMuNiA4IDh2Mjh6Jyk7XG4gICAgICAgICAgICBzdmdHcm91cC5hcHBlbmRDaGlsZChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5feHJJY29uO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVhSSWNvbi5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuZXhwb3J0IGNsYXNzIE1hdGhVdGlscyB7XG4gICAgLyoqXG4gICAgICogZm9ybWF0cyBCeXRlcyBjb21pbmcgaW4gZm9yIHZpZGVvIHN0YXRzXG4gICAgICogQHBhcmFtIGJ5dGVzIC0gbnVtYmVyIHRvIGNvbnZlcnRcbiAgICAgKiBAcGFyYW0gZGVjaW1hbHMgLSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgZm9ybWF0Qnl0ZXMoYnl0ZXMsIGRlY2ltYWxzKSB7XG4gICAgICAgIGlmIChieXRlcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcwJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWN0b3IgPSAxMDI0O1xuICAgICAgICBjb25zdCBkbSA9IGRlY2ltYWxzIDwgMCA/IDAgOiBkZWNpbWFscztcbiAgICAgICAgY29uc3Qgc2l6ZXMgPSBbJ0J5dGVzJywgJ0tpQicsICdNaUInLCAnR2lCJywgJ1RpQicsICdQaUInLCAnRWlCJywgJ1ppQicsICdZaUInXTtcbiAgICAgICAgY29uc3QgaSA9IE1hdGguZmxvb3IoTWF0aC5sb2coYnl0ZXMpIC8gTWF0aC5sb2coZmFjdG9yKSk7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KChieXRlcyAvIE1hdGgucG93KGZhY3RvciwgaSkpLnRvRml4ZWQoZG0pKSArICcgJyArIHNpemVzW2ldO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hdGhVdGlscy5qcy5tYXAiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuaW1wb3J0IHsgQ29uZmlnLCBQaXhlbFN0cmVhbWluZyB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nZnJvbnRlbmQtdWU1LjYnO1xuaW1wb3J0IHsgQXBwbGljYXRpb24sIFBpeGVsU3RyZWFtaW5nQXBwbGljYXRpb25TdHlsZSB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nZnJvbnRlbmQtdWktdWU1LjYnO1xuZXhwb3J0IGNvbnN0IFBpeGVsU3RyZWFtaW5nQXBwbGljYXRpb25TdHlsZXMgPSBuZXcgUGl4ZWxTdHJlYW1pbmdBcHBsaWNhdGlvblN0eWxlKCk7XG5QaXhlbFN0cmVhbWluZ0FwcGxpY2F0aW9uU3R5bGVzLmFwcGx5U3R5bGVTaGVldCgpO1xuXG5cbmRvY3VtZW50LmJvZHkub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdC8vIENyZWF0ZSBhIGNvbmZpZyBvYmplY3Rcblx0Y29uc3QgY29uZmlnID0gbmV3IENvbmZpZyh7IHVzZVVybFBhcmFtczogdHJ1ZSB9KTtcblxuXHQvLyBDcmVhdGUgUGl4ZWwgU3RyZWFtaW5nIGFwcGxpY2F0aW9uXG5cdGNvbnN0IHN0cmVhbSA9IG5ldyBQaXhlbFN0cmVhbWluZyhjb25maWcpO1xuXHRjb25zdCBhcHBsaWNhdGlvbiA9IG5ldyBBcHBsaWNhdGlvbih7XG5cdFx0c3RyZWFtLFxuXHRcdG9uQ29sb3JNb2RlQ2hhbmdlZDogKGlzTGlnaHRNb2RlKSA9PiBQaXhlbFN0cmVhbWluZ0FwcGxpY2F0aW9uU3R5bGVzLnNldENvbG9yTW9kZShpc0xpZ2h0TW9kZSlcblx0fSk7XG5cdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGxheWVyY29udGFpbmVyXCIpLmFwcGVuZENoaWxkKGFwcGxpY2F0aW9uLnJvb3RFbGVtZW50KTtcblxuXHRjb25zdCBzaG93Y2FzZSA9IG5ldyBTaG93Y2FzZShzdHJlYW0pO1xuXG5cdC8vIEJpbmQgZXhhbXBsZSBzZWxlY3Rpb24gdG8gdGhlIG9uRXhhbXBsZUNoYW5nZWQgZnVuY3Rpb25cblx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJleGFtcGxlU2VsZWN0XCIpLm9uY2hhbmdlID0gKGV2ZW50IDogRXZlbnQpID0+IHsgc2hvd2Nhc2Uub25FeGFtcGxlQ2hhbmdlZChldmVudCk7IH07XG59XG5cbmNsYXNzIFNob3djYXNlIHtcblxuXHRwcml2YXRlIF9waXhlbFN0cmVhbWluZyA6IFBpeGVsU3RyZWFtaW5nO1xuXHRwcml2YXRlIF9pbmZvRWxlbSA6IEhUTUxFbGVtZW50O1xuXHRwcml2YXRlIF9leGFtcGxlU2V0dGluZ3NFbGVtIDogSFRNTEVsZW1lbnQ7XG5cblx0Y29uc3RydWN0b3IgKHBpeGVsU3RyZWFtaW5nIDogUGl4ZWxTdHJlYW1pbmcpIHtcblx0XHR0aGlzLl9waXhlbFN0cmVhbWluZyA9IHBpeGVsU3RyZWFtaW5nO1xuXHRcdHRoaXMuX2luZm9FbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvaW5zdHJ1Y3Rpb25zXCIpIGFzIEhUTUxFbGVtZW50O1xuXHRcdHRoaXMuX2V4YW1wbGVTZXR0aW5nc0VsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNpZGViYXJDb250ZW50XCIpIGFzIEhUTUxFbGVtZW50O1xuXHRcdHRoaXMuX2NyZWF0ZUdldHRpbmdTdGFydGVkRXhhbXBsZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV2ZW50IGZpcmVkIGZvciB3aGVuIHRoZSBzZWxlY3Rpb24gZHJvcCBkb3duIGNvbnRhaW5pbmcgb3VyIHNob3djYXNlIGV4YW1wbGVzIGNoYW5nZXMuXG5cdCAqIEBwYXJhbSBldmVudCBUaGUgY2hhbmdlIGV2ZW50LlxuXHQgKi9cblx0b25FeGFtcGxlQ2hhbmdlZChldmVudCA6IEV2ZW50KSA6IHZvaWQge1xuXG5cdFx0aWYoIWV2ZW50KSB7IHJldHVybjsgfVxuXG5cdFx0Y29uc3Qgc2VsZWN0RWxlbWVudCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MU2VsZWN0RWxlbWVudDtcblx0XHRjb25zdCBleGFtcGxlTmFtZSA9IHNlbGVjdEVsZW1lbnQudmFsdWU7XG5cdFx0dGhpcy5fY3JlYXRlRXhhbXBsZShleGFtcGxlTmFtZSk7XG5cdH1cblxuXHRwcml2YXRlIF9jcmVhdGVFeGFtcGxlKGV4YW1wbGVOYW1lIDogc3RyaW5nKSB7XG5cblx0XHQvLyBjbGVhciBleGFtcGxlIGVsZW1lbnRzXG5cdFx0d2hpbGUgKHRoaXMuX2V4YW1wbGVTZXR0aW5nc0VsZW0ubGFzdEVsZW1lbnRDaGlsZCkge1xuXHRcdFx0dGhpcy5fZXhhbXBsZVNldHRpbmdzRWxlbS5yZW1vdmVDaGlsZCh0aGlzLl9leGFtcGxlU2V0dGluZ3NFbGVtLmxhc3RFbGVtZW50Q2hpbGQpO1xuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSB0aGUgcmVsZXZhbnQgZXhhbXBsZSBiYXNlZCBvbiB0aGUgc3RyaW5nIHBhc3NlZCBpblxuXHRcdHN3aXRjaChleGFtcGxlTmFtZSkge1xuXHRcdFx0Y2FzZSBcIlNlbmQgRGF0YSB0byBVRVwiOlxuXHRcdFx0XHR0aGlzLl9jcmVhdGVTZW5kVUVEYXRhRXhhbXBsZSgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJHZXR0aW5nIFN0YXJ0ZWRcIjpcblx0XHRcdFx0dGhpcy5fY3JlYXRlR2V0dGluZ1N0YXJ0ZWRFeGFtcGxlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcIlNlbmQgQ29tbWFuZHMgdG8gVUVcIjpcblx0XHRcdFx0dGhpcy5fY3JlYXRlVUVDb21tYW5kRXhhbXBsZSgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgX29uQ2hhcmFjdGVyQ2xpY2tlZChjaGFyYWN0ZXJOYW1lIDogc3RyaW5nKSB7XG5cdFx0dGhpcy5fcGl4ZWxTdHJlYW1pbmcuZW1pdFVJSW50ZXJhY3Rpb24oeyBDaGFyYWN0ZXI6IGNoYXJhY3Rlck5hbWUgfSk7XG5cdH1cblxuXHRwcml2YXRlIF9vblNraW5DbGlja2VkKHNraW5JbmRleCA6IG51bWJlcikge1xuXHRcdHRoaXMuX3BpeGVsU3RyZWFtaW5nLmVtaXRVSUludGVyYWN0aW9uKHsgU2tpbjogc2tpbkluZGV4IH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBfb25SZXNDbGlja2VkKHdpZHRoIDogbnVtYmVyLCBoZWlnaHQgOiBudW1iZXIpIHtcblx0XHR0aGlzLl9waXhlbFN0cmVhbWluZy5lbWl0Q29tbWFuZCh7IFJlc29sdXRpb246IHsgV2lkdGg6IHdpZHRoLCBIZWlnaHQ6IGhlaWdodCB9IH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBfY3JlYXRlR2V0dGluZ1N0YXJ0ZWRFeGFtcGxlKCkge1xuXHRcdHRoaXMuX2luZm9FbGVtLmlubmVySFRNTCA9IFxuXHRcdGBcblx0XHQ8cD5XZWxjb21lIHRvIHRoZSBQaXhlbCBTdHJlYW1pbmcgZGVtbyBzaG93Y2FzZSE8L3A+XG5cdFx0PHA+IDx1PkdldHRpbmcgU3RhcnRlZDwvdT4gPC9wPlxuXHRcdDxvbD5cblx0XHRcdDxsaT5SdW4gdGhlIFVucmVhbCBFbmdpbmUgUGl4ZWwgU3RyZWFtaW5nIGRlbW8gcHJvamVjdCB3aXRoIGxhdW5jaCBhcmdzIGZvciB0aGlzIHNlcnZlciwgZXhhbXBsZTogLVBpeGVsU3RyZWFtaW5nVXJsPXdzOi8vbG9jYWxob3N0Ojg4ODguPC9saT5cblx0XHRcdDxsaT5DbGljayB0aGUgXCJjbGljayB0byBzdGFydFwiIHRleHQgb24gdGhpcyBwYWdlIHRvIHN0YXJ0IHN0cmVhbWluZy48L2xpPlxuXHRcdFx0PGxpPlVzZSB0aGUgZHJvcCBkb3duIHRvIHNlbGVjdCBhbiBleGFtcGxlLjwvbGk+XG5cdFx0XHQ8bGk+VXNlIGNvbnRyb2wgcGFuZWwgb24gdGhlIGxlZnQgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgZXhhbXBsZS48L2xpPlxuXHRcdDwvb2w+XG5cdFx0YDtcblx0fVxuXG5cdHByaXZhdGUgX2NyZWF0ZVNlbmRVRURhdGFFeGFtcGxlKCkge1xuXG5cdFx0dGhpcy5faW5mb0VsZW0uaW5uZXJIVE1MID0gXG5cdFx0YFxuXHRcdDxwPiA8dT5FeGFtcGxlOiBTZW5kaW5nIGRhdGEgdG8gVW5yZWFsIEVuZ2luZTwvdT4gPC9wPlxuXHRcdDxvbD5cblx0XHRcdDxsaT5DbGljayB0aGUgY2hhcmFjdGVyIHBvcnRyYWl0cyB0byBjaGFuZ2UgY2hhcmFjdGVyLjwvbGk+XG5cdFx0XHQ8bGk+Q2xpY2sgdGhlIHNraW5zIHRvIGNoYW5nZSBjaGFyYWN0ZXIgc2tpbnMuPC9saT5cblx0XHQ8L29sPlxuXHRcdDxwPlVuZGVyIHRoZSBob29kIHRoZXNlIGludGVyYWN0aW9ucyB1c2UgdGhlIFdlYlJUQyBkYXRhIGNoYW5uZWwgdG8gc2VuZCBhIGRhdGEgcGF5bG9hZCB0aGF0IHdlIGludGVycHJldCBvbiB0aGUgVUUgc2lkZSBhbmQgcmVzcG9uZCB0byBhcHByb3ByaWF0ZWx5LjwvcD5cblx0XHQ8cD5JbiBwYXJ0aWN1bGFyIHRoZSBmdW5jdGlvbiBjYWxsZWQgdG8gc2VuZCBjdXN0b20gZGF0YSB0byBVbnJlYWwgRW5naW5lIGZyb20gdGhlIGZyb250ZW5kIGlzOjwvcD5cblx0XHQ8Y29kZT5waXhlbHN0cmVhbWluZy5lbWl0VUlJbnRlcmFjdGlvbihkYXRhOiBvYmplY3QgfCBzdHJpbmcpPC9jb2RlPlxuXHRcdGA7XG5cblx0XHRjb25zdCBjaGFyYWN0ZXJTZWxlY3RFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHR0aGlzLl9leGFtcGxlU2V0dGluZ3NFbGVtLmFwcGVuZENoaWxkKGNoYXJhY3RlclNlbGVjdEVsZW0pO1xuXG5cdFx0Y29uc3Qgc2VuZERhdGFUaXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoMlwiKTtcblx0XHRzZW5kRGF0YVRpdGxlLmlubmVyVGV4dCA9IFwiU2VuZCBkYXRhOiBcIjtcblx0XHRjaGFyYWN0ZXJTZWxlY3RFbGVtLmFwcGVuZENoaWxkKHNlbmREYXRhVGl0bGUpO1xuXG5cdFx0Y29uc3QgY2hhcmFjdGVyU2VsZWN0VGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcblx0XHRjaGFyYWN0ZXJTZWxlY3RUaXRsZS5pbm5lclRleHQgPSBcIlNlbGVjdCBhIGNoYXJhY3RlcjogXCI7XG5cdFx0Y2hhcmFjdGVyU2VsZWN0RWxlbS5hcHBlbmRDaGlsZChjaGFyYWN0ZXJTZWxlY3RUaXRsZSk7XG5cblx0XHQvLyBNYWtlIEF1cm9yYSBjaGFyYWN0ZXJcblx0XHRjb25zdCBhdXJvcmFFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRjaGFyYWN0ZXJTZWxlY3RFbGVtLmFwcGVuZENoaWxkKGF1cm9yYUVsZW0pO1xuXHRcdGNvbnN0IGF1cm9yYUltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cdFx0YXVyb3JhSW1nLmNsYXNzTGlzdC5hZGQoXCJjaGFyYWN0ZXJCdG5cIik7XG5cdFx0YXVyb3JhSW1nLnNyYyA9IFwiLi9pbWFnZXMvQXVyb3JhLmpwZ1wiO1xuXHRcdGF1cm9yYUltZy5vbmNsaWNrID0gKCkgPT4geyB0aGlzLl9vbkNoYXJhY3RlckNsaWNrZWQoXCJBdXJvcmFcIik7IH1cblx0XHRhdXJvcmFFbGVtLmFwcGVuZENoaWxkKGF1cm9yYUltZyk7XG5cblx0XHQvLyBNYWtlIENydW5jaCBjaGFyYWN0ZXJcblx0XHRjb25zdCBjcnVuY2hFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRjaGFyYWN0ZXJTZWxlY3RFbGVtLmFwcGVuZENoaWxkKGNydW5jaEVsZW0pO1xuXHRcdGNvbnN0IGNydW5jaEltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cdFx0Y3J1bmNoSW1nLmNsYXNzTGlzdC5hZGQoXCJjaGFyYWN0ZXJCdG5cIik7XG5cdFx0Y3J1bmNoSW1nLnNyYyA9IFwiLi9pbWFnZXMvQ3J1bmNoLmpwZ1wiO1xuXHRcdGNydW5jaEltZy5vbmNsaWNrID0gKCkgPT4geyB0aGlzLl9vbkNoYXJhY3RlckNsaWNrZWQoXCJDcnVuY2hcIik7IH1cblx0XHRjcnVuY2hFbGVtLmFwcGVuZENoaWxkKGNydW5jaEltZyk7XG5cblx0XHQvLyBNYWtlIHNraW4gc2VsZWN0aW9uIHRpdGxlXG5cdFx0Y29uc3Qgc2tpblNlbGVjdFRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG5cdFx0c2tpblNlbGVjdFRpdGxlLmlubmVyVGV4dCA9IFwiU2VsZWN0IGEgc2tpbjogXCI7XG5cdFx0dGhpcy5fZXhhbXBsZVNldHRpbmdzRWxlbS5hcHBlbmRDaGlsZChza2luU2VsZWN0VGl0bGUpO1xuXG5cdFx0Ly8gTWFrZSBza2luIHNlbGVjdGlvblxuXHRcdGNvbnN0IHNraW5TZWxlY3RFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRza2luU2VsZWN0RWxlbS5jbGFzc0xpc3QuYWRkKFwic3BhY2VkLXJvd1wiKTtcblx0XHR0aGlzLl9leGFtcGxlU2V0dGluZ3NFbGVtLmFwcGVuZENoaWxkKHNraW5TZWxlY3RFbGVtKTtcblxuXHRcdC8vIE1ha2Ugc2tpbiBzZWxlY3Rpb24gYnV0dG9uc1xuXG5cdFx0Ly8gU2tpbjFcblx0XHRjb25zdCBza2luMUJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG5cdFx0c2tpbjFCdG4uY2xhc3NMaXN0LmFkZChcImJ0bi1mbGF0XCIpO1xuXHRcdHNraW4xQnRuLm9uY2xpY2sgPSAoKSA9PiB7IHRoaXMuX29uU2tpbkNsaWNrZWQoMCk7IH1cblx0XHRza2luMUJ0bi5pbm5lclRleHQgPSBcIlNraW4gMVwiO1xuXHRcdHNraW5TZWxlY3RFbGVtLmFwcGVuZENoaWxkKHNraW4xQnRuKTtcblxuXHRcdC8vIFNraW4yXG5cdFx0Y29uc3Qgc2tpbjJCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuXHRcdHNraW4yQnRuLmNsYXNzTGlzdC5hZGQoXCJidG4tZmxhdFwiKTtcblx0XHRza2luMkJ0bi5vbmNsaWNrID0gKCkgPT4geyB0aGlzLl9vblNraW5DbGlja2VkKDEpOyB9XG5cdFx0c2tpbjJCdG4uaW5uZXJUZXh0ID0gXCJTa2luIDJcIjtcblx0XHRza2luU2VsZWN0RWxlbS5hcHBlbmRDaGlsZChza2luMkJ0bik7XG5cblx0XHQvLyBTa2luM1xuXHRcdGNvbnN0IHNraW4zQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcblx0XHRza2luM0J0bi5jbGFzc0xpc3QuYWRkKFwiYnRuLWZsYXRcIik7XG5cdFx0c2tpbjNCdG4ub25jbGljayA9ICgpID0+IHsgdGhpcy5fb25Ta2luQ2xpY2tlZCgyKTsgfVxuXHRcdHNraW4zQnRuLmlubmVyVGV4dCA9IFwiU2tpbiAzXCI7XG5cdFx0c2tpblNlbGVjdEVsZW0uYXBwZW5kQ2hpbGQoc2tpbjNCdG4pO1xuXHR9XG5cblx0cHJpdmF0ZSBfY3JlYXRlVUVDb21tYW5kRXhhbXBsZSgpIHtcblxuXHRcdHRoaXMuX2luZm9FbGVtLmlubmVySFRNTCA9IFxuXHRcdGBcblx0XHQ8cD4gPHU+RXhhbXBsZTogVHJpZ2dlcmluZyBDb21tYW5kcyBpbiBVbnJlYWwgRW5naW5lPC91PiA8L3A+XG5cdFx0PHVsPlxuXHRcdFx0PGxpPkNsaWNrIG9uIHRoZSByZXNvbHV0aW9uIGJ1dHRvbnMgdG8gY2hhbmdlIHlvdXIgVW5yZWFsIEVuZ2luZSBhcHBsaWNhdGlvbidzIHJlc29sdXRpb24gKHJlcXVpcmVzIGEgPGNvZGU+LXdpbmRvd2VkPC9jb2RlPiBhcHBsaWNhdGlvbikuPC9saT5cblx0XHQ8L3VsPlxuXHRcdDxwPlVuZGVyIHRoZSBob29kIHRoZXNlIGludGVyYWN0aW9ucyB1c2UgdGhlIFdlYlJUQyBkYXRhIGNoYW5uZWwgdG8gc2VuZCBjb21tYW5kIG1lc3NhZ2VzIHRoYXQgd2UgaW50ZXJwcmV0IG9uIHRoZSBVRSBzaWRlIHRvIGNhbGwgc3BlY2lmaWMgVUUgZnVuY3Rpb25zLjwvcD5cblx0XHQ8cD5UaGVyZSBhcmUgYSB2ZXJ5IHNlbGVjdCBzZXQgb2YgYnVpbHQtaW4gY29tbWFuZHMgc3VjaCBhcyA8aT5jaGFuZ2luZyByZXNvbHV0aW9uPC9pPiBhbmQgPGk+Y2hhbmdlIGVuY29kZXIgUVA8L2k+LCB3aGljaCBjYW4gYmUgdHJpZ2dlcmVkIGxpa2Ugc286PC9wPlxuXHRcdDxjb2RlPnBpeGVsU3RyZWFtaW5nLmVtaXRDb21tYW5kKHtcIkVuY29kZXIuTWluUVBcIjogNTEsfSk8L2NvZGU+XG5cblx0XHQ8cD5Ib3dldmVyLCB5b3UgY2FuIGJpbmQgeW91ciBvd24gY3VzdG9tIGNvbW1hbmRzIGluIEMrKyB1c2luZzo8L3A+XG5cdFx0PGNvZGU+XG5cdFx0XHQvLyBDKysgc2lkZSBcblx0XHRcdDwvYnI+XG5cdFx0XHRJUGl4ZWxTdHJlYW1pbmdJbnB1dEhhbmRsZXI6OlNldENvbW1hbmRIYW5kbGVyKGNvbnN0IEZTdHJpbmcmIENvbW1hbmROYW1lLCBjb25zdCBURnVuY3Rpb248dm9pZChGU3RyaW5nLCBGU3RyaW5nKT4mIEhhbmRsZXIpXG5cdFx0XHQ8L2JyPlxuXHRcdFx0Ly8gSlMgc2lkZVxuXHRcdFx0PC9icj5cblx0XHRcdHBpeGVsc3RyZWFtaW5nLmVtaXRDb21tYW5kKHtcIk15Q3VzdG9tQ29tbWFuZFwiOiBcIk15Q3VzdG9tQ29tbWFuZFBhcmFtZXRlclwifSk7XG5cdFx0PC9jb2RlPlxuXG5cdFx0PHA+QWRkaXRpb25hbGx5IHlvdSBjYW4gYWxzbyB0cmlnZ2VyIFVucmVhbCBFbmdpbmUgY29uc29sZSBjb21tYW5kcyBsaWtlIDxjb2RlPnN0YXQgZ3B1PC9jb2RlPiBpZiB5b3UgbGF1bmNoIFBpeGVsIFN0cmVhbWluZyB3aXRoIDxjb2RlPi1BbGxvd1BpeGVsU3RyZWFtaW5nQ29tbWFuZHM8L2NvZGU+IHRoZW4gY2FsbGluZzo8L3A+XG5cdFx0PGNvZGU+cGl4ZWxzdHJlYW1pbmcuZW1pdENvbnNvbGVDb21tYW5kKGNvbW1hbmQ6IHN0cmluZyk8L2NvZGU+XG5cdFx0YDtcblxuXHRcdC8vIEFkZCBhIG5ldyBlbGVtZW50IGZvciBjb250YWluaW5nIGVsZW1lbnRzIGZvciByZXMgY2hhbmdpbmcgZmVhdHVyZVxuXHRcdGNvbnN0IGNoYW5nZVJlc0VsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdHRoaXMuX2V4YW1wbGVTZXR0aW5nc0VsZW0uYXBwZW5kQ2hpbGQoY2hhbmdlUmVzRWxlbSk7XG5cblx0XHQvLyBNYWtlIHJlcyBjaGFuZ2UgdGl0bGVcblx0XHRjb25zdCBjaGFuZ2VSZXNUaXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoMlwiKTtcblx0XHRjaGFuZ2VSZXNUaXRsZS5pbm5lclRleHQgPSBcIlNlbmQgYSBjdXN0b20gY29tbWFuZDogXCI7XG5cdFx0Y2hhbmdlUmVzRWxlbS5hcHBlbmRDaGlsZChjaGFuZ2VSZXNUaXRsZSk7XG5cblx0XHQvLyBNYWtlIGNoYW5nZSByZXNvbHV0aW9uIHRleHRcblx0XHRjb25zdCBjaGFuZ2VSZXNUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG5cdFx0Y2hhbmdlUmVzVGV4dC5pbm5lckhUTUwgPSBcIkNoYW5nZSByZXNvbHV0aW9uXCJcblx0XHRjaGFuZ2VSZXNFbGVtLmFwcGVuZENoaWxkKGNoYW5nZVJlc1RleHQpO1xuXG5cdFx0Ly8gTWFrZSByZXMgY2hhbmdlIGJ1dHRvbiBjb250YWluZXJcblx0XHRjb25zdCBjaGFuZ2VSZXNCdG5Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdGNoYW5nZVJlc0J0bkNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3BhY2VkLXJvd1wiKTtcblx0XHR0aGlzLl9leGFtcGxlU2V0dGluZ3NFbGVtLmFwcGVuZENoaWxkKGNoYW5nZVJlc0J0bkNvbnRhaW5lcik7XG5cblx0XHQvLyBNYWtlIHJlcyBjaGFuZ2UgYnV0dG9uc1xuXG5cdFx0Ly8gNzIwcFxuXHRcdGNvbnN0IHJlczcyMHBCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuXHRcdHJlczcyMHBCdG4uY2xhc3NMaXN0LmFkZChcImJ0bi1mbGF0XCIpO1xuXHRcdHJlczcyMHBCdG4ub25jbGljayA9ICgpID0+IHsgdGhpcy5fb25SZXNDbGlja2VkKDEyODAsIDcyMCk7IH1cblx0XHRyZXM3MjBwQnRuLmlubmVyVGV4dCA9IFwiNzIwcFwiO1xuXHRcdGNoYW5nZVJlc0J0bkNvbnRhaW5lci5hcHBlbmRDaGlsZChyZXM3MjBwQnRuKTtcblxuXHRcdC8vIDEwODBwXG5cdFx0Y29uc3QgcmVzMTA4MHBCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuXHRcdHJlczEwODBwQnRuLmNsYXNzTGlzdC5hZGQoXCJidG4tZmxhdFwiKTtcblx0XHRyZXMxMDgwcEJ0bi5vbmNsaWNrID0gKCkgPT4geyB0aGlzLl9vblJlc0NsaWNrZWQoMTkyMCwgMTA4MCk7IH1cblx0XHRyZXMxMDgwcEJ0bi5pbm5lclRleHQgPSBcIjEwODBwXCI7XG5cdFx0Y2hhbmdlUmVzQnRuQ29udGFpbmVyLmFwcGVuZENoaWxkKHJlczEwODBwQnRuKTtcblxuXHRcdC8vIDE0NDBwXG5cdFx0Y29uc3QgcmVzMTQ0MHBCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuXHRcdHJlczE0NDBwQnRuLmNsYXNzTGlzdC5hZGQoXCJidG4tZmxhdFwiKTtcblx0XHRyZXMxNDQwcEJ0bi5vbmNsaWNrID0gKCkgPT4geyB0aGlzLl9vblJlc0NsaWNrZWQoMjU2MCwgMTQ0MCk7IH1cblx0XHRyZXMxNDQwcEJ0bi5pbm5lclRleHQgPSBcIjE0NDBwXCI7XG5cdFx0Y2hhbmdlUmVzQnRuQ29udGFpbmVyLmFwcGVuZENoaWxkKHJlczE0NDBwQnRuKTtcblxuXHRcdC8vIDRrXG5cdFx0Y29uc3QgcmVzNGtCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuXHRcdHJlczRrQnRuLmNsYXNzTGlzdC5hZGQoXCJidG4tZmxhdFwiKTtcblx0XHRyZXM0a0J0bi5vbmNsaWNrID0gKCkgPT4geyB0aGlzLl9vblJlc0NsaWNrZWQoMzg0MCwgMjE2MCk7IH1cblx0XHRyZXM0a0J0bi5pbm5lclRleHQgPSBcIjRrXCI7XG5cdFx0Y2hhbmdlUmVzQnRuQ29udGFpbmVyLmFwcGVuZENoaWxkKHJlczRrQnRuKTtcblxuXHRcdC8vIEFkZCBhIG5ldyBlbGVtZW50IGZvciBjb250YWluaW5nIGVsZW1lbnRzIGZvciByZXMgY2hhbmdpbmcgZmVhdHVyZVxuXHRcdGNvbnN0IGNvbnNvbGVDb21tYW5kRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0dGhpcy5fZXhhbXBsZVNldHRpbmdzRWxlbS5hcHBlbmRDaGlsZChjb25zb2xlQ29tbWFuZEVsZW0pO1xuXG5cdFx0Ly8gTWFrZSBjb25zb2xlIGNvbW1hbmQgdGl0bGVcblx0XHRjb25zdCBjb25zb2xlQ29tbWFuZFRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgyXCIpO1xuXHRcdGNvbnNvbGVDb21tYW5kVGl0bGUuaW5uZXJUZXh0ID0gXCJTZW5kIGEgY29uc29sZSBjb21tYW5kOiBcIjtcblx0XHRjb25zb2xlQ29tbWFuZEVsZW0uYXBwZW5kQ2hpbGQoY29uc29sZUNvbW1hbmRUaXRsZSk7XG5cblx0XHQvLyBUZXh0IGluZm9ybWluZyB1c2luZyBhYm91dCAtQWxsb3dQaXhlbFN0cmVhbWluZ0NvbW1hbmRzXG5cdFx0Y29uc3QgaW5mb3JtUFNDb21tYW5kc1RleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcblx0XHRpbmZvcm1QU0NvbW1hbmRzVGV4dC5pbm5lckhUTUwgPSBcIihSZXF1aXJlcyBVRSBzaWRlIGxhdW5jaGVkIHdpdGggPGNvZGU+LUFsbG93UGl4ZWxTdHJlYW1pbmdDb21tYW5kczwvY29kZT4pXCJcblx0XHRjb25zb2xlQ29tbWFuZEVsZW0uYXBwZW5kQ2hpbGQoaW5mb3JtUFNDb21tYW5kc1RleHQpO1xuXG5cdFx0Ly8gTWFrZSBidXR0b25zIGZvciBzdGF0IGZwcy9zdGF0IGdwdVxuXHRcdGNvbnN0IGNvbnNvbGVDbWRCdG5zQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRjb25zb2xlQ21kQnRuc0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3BhY2VkLXJvd1wiKTtcblx0XHR0aGlzLl9leGFtcGxlU2V0dGluZ3NFbGVtLmFwcGVuZENoaWxkKGNvbnNvbGVDbWRCdG5zQ29udGFpbmVyKTtcblxuXHRcdC8vIHN0YXQgZnBzXG5cdFx0Y29uc3Qgc3RhdGZwc0J0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG5cdFx0c3RhdGZwc0J0bi5jbGFzc0xpc3QuYWRkKFwiYnRuLWZsYXRcIik7XG5cdFx0c3RhdGZwc0J0bi5vbmNsaWNrID0gKCkgPT4geyB0aGlzLl9waXhlbFN0cmVhbWluZy5lbWl0Q29uc29sZUNvbW1hbmQoXCJzdGF0IGZwc1wiKTsgfVxuXHRcdHN0YXRmcHNCdG4uaW5uZXJUZXh0ID0gXCJzdGF0IGZwc1wiO1xuXHRcdGNvbnNvbGVDbWRCdG5zQ29udGFpbmVyLmFwcGVuZENoaWxkKHN0YXRmcHNCdG4pO1xuXG5cdFx0Ly8gc3RhdCBwaXhlbHN0cmVhbWluZ1xuXHRcdGNvbnN0IHN0YXRncHVCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuXHRcdHN0YXRncHVCdG4uY2xhc3NMaXN0LmFkZChcImJ0bi1mbGF0XCIpO1xuXHRcdHN0YXRncHVCdG4ub25jbGljayA9ICgpID0+IHsgdGhpcy5fcGl4ZWxTdHJlYW1pbmcuZW1pdENvbnNvbGVDb21tYW5kKFwic3RhdCBwaXhlbHN0cmVhbWluZ1wiKTsgdGhpcy5fcGl4ZWxTdHJlYW1pbmcuZW1pdENvbnNvbGVDb21tYW5kKFwic3RhdCBwaXhlbHN0cmVhbWluZzJcIik7IH1cblx0XHRzdGF0Z3B1QnRuLmlubmVyVGV4dCA9IFwic3RhdCBwaXhlbHN0cmVhbWluZ1wiO1xuXHRcdGNvbnNvbGVDbWRCdG5zQ29udGFpbmVyLmFwcGVuZENoaWxkKHN0YXRncHVCdG4pO1xuXG5cdFx0Ly9zdGF0IHBpeGVsU3RyZWFtaW5nR3JhcGhzXG5cdFx0Y29uc3Qgc3RhdEdyYXBoQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcblx0XHRzdGF0R3JhcGhCdG4uY2xhc3NMaXN0LmFkZChcImJ0bi1mbGF0XCIpO1xuXHRcdHN0YXRHcmFwaEJ0bi5vbmNsaWNrID0gKCkgPT4geyB0aGlzLl9waXhlbFN0cmVhbWluZy5lbWl0Q29uc29sZUNvbW1hbmQoXCJzdGF0IHBpeGVsc3RyZWFtaW5nZ3JhcGhzXCIpOyB0aGlzLl9waXhlbFN0cmVhbWluZy5lbWl0Q29uc29sZUNvbW1hbmQoXCJzdGF0IHBpeGVsc3RyZWFtaW5nMmdyYXBoc1wiKTsgfVxuXHRcdHN0YXRHcmFwaEJ0bi5pbm5lclRleHQgPSBcInN0YXQgcGl4ZWxzdHJlYW1pbmdncmFwaHNcIjtcblx0XHRjb25zb2xlQ21kQnRuc0NvbnRhaW5lci5hcHBlbmRDaGlsZChzdGF0R3JhcGhCdG4pO1xuXG5cdH1cblxufVxuXG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==