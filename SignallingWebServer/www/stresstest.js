(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["epicgames-frontend"] = factory();
	else
		root["epicgames-frontend"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../../../Common/dist/esm/Event/EventEmitter.js":
/*!******************************************************!*\
  !*** ../../../Common/dist/esm/Event/EventEmitter.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
// To match NodeJS' EventEmitter syntax without downstream code changes we need to use `any`.
// This means we need to disable linting `any` checks on this file.
//
/* eslint-disable @typescript-eslint/no-unsafe-argument */
class PixelStreamingEventListener {
    constructor(callback) {
        this._args = [];
        this._callback = callback;
    }
    handleEvent(_evt) {
        this._callback(...this._args);
        // Reset storage of args.
        this._args = [];
    }
    setArgs(...args) {
        this._args = args;
    }
}
/**
 * A feature-limited, but _mostly_ drop-in replacement for Node's EventEmitter type that is implemented using EventTarget.
 *
 * For those unfamiliar with Node's EventEmitter, here is some info from the official docs:
 *
 * [In NodeJS] all objects that emit events are instances of the `EventEmitter` class. These
 * objects expose an `eventEmitter.on()` function that allows one or more
 * functions to be attached to named events emitted by the object. Typically,
 * event names are camel-cased strings but any valid JavaScript property key
 * can be used.
 *
 * When the `EventEmitter` object emits an event, all of the functions attached
 * to that specific event are called _synchronously_. Any values returned by the
 * called listeners are _ignored_ and discarded.
 *
 * The following example shows a simple `EventEmitter` instance with a single
 * listener. The `eventEmitter.on()` method is used to register listeners, while
 * the `eventEmitter.emit()` method is used to trigger the event.
 *
 * ```js
 * import { EventEmitter } from 'node:events';
 *
 * class MyEmitter extends EventEmitter {}
 *
 * const myEmitter = new MyEmitter();
 * myEmitter.on('event', () => {
 *   console.log('an event occurred!');
 * });
 * myEmitter.emit('event');
 * ```
 */
class EventEmitter extends EventTarget {
    constructor() {
        super();
        this._eventListeners = new Map();
    }
    removeListenerInternal(eventName, listener) {
        if (this._eventListeners.has(eventName)) {
            const listeners = this._eventListeners.get(eventName);
            if (listeners === undefined) {
                return this;
            }
            for (let i = 0; i < listeners.length; ++i) {
                const eventPair = listeners[i];
                if (eventPair.callback === listener) {
                    // Remove from event target
                    super.removeEventListener(eventName, eventPair.eventListenerWrapper);
                    // Remove from our internal map
                    listeners.splice(i, 1);
                    break;
                }
            }
        }
        return this;
    }
    /**
     * Alias for `emitter.on(eventName, listener)`.
     */
    addListener(eventName, listener) {
        return this.on(eventName, listener);
    }
    /**
     * Adds the `listener` function to the end of the listeners array for the event
     * named `eventName`.
     *
     * ```js
     * server.on('connection', (stream) => {
     *   console.log('someone connected!');
     * });
     * ```
     *
     * Returns a reference to the `EventEmitter`, so that calls can be chained.
     *
     * @param eventName - The name of the event.
     * @param listener - The callback function
     */
    on(eventName, listener) {
        var _a;
        // Wrap our normal JS function in a event listener interface
        // so we can use it with event target.
        const eventListenerWrapper = new PixelStreamingEventListener(listener);
        super.addEventListener(eventName, eventListenerWrapper);
        // Store the event listener/function pair for later removal.
        if (!this._eventListeners.has(eventName)) {
            this._eventListeners.set(eventName, new Array());
        }
        (_a = this._eventListeners
            .get(eventName)) === null || _a === void 0 ? void 0 : _a.push({ callback: listener, eventListenerWrapper: eventListenerWrapper });
        return this;
    }
    /**
     * Adds a **one-time** `listener` function for the event named `eventName`. The
     * next time `eventName` is triggered, this listener is removed and then invoked.
     *
     * ```js
     * server.once('connection', (stream) => {
     *   console.log('Ah, we have our first user!');
     * });
     * ```
     *
     * Returns a reference to the `EventEmitter`, so that calls can be chained.
     * @param eventName - The name of the event.
     * @param listener - The callback function
     */
    once(eventName, listener) {
        var _a;
        // Pass options so this event callback is only called once
        const eventListenerOpts = { once: true };
        // Wrap our normal JS function in a event listener interface
        // so we can use it with event target and remove it from event target when this function completes.
        const eventListenerWrapper = new PixelStreamingEventListener((...args) => {
            listener(args);
            this.removeListenerInternal(eventName, listener);
        });
        super.addEventListener(eventName, eventListenerWrapper, eventListenerOpts);
        // Store the event listener/function pair for later removal.
        if (!this._eventListeners.has(eventName)) {
            this._eventListeners.set(eventName, new Array());
        }
        (_a = this._eventListeners
            .get(eventName)) === null || _a === void 0 ? void 0 : _a.push({ callback: listener, eventListenerWrapper: eventListenerWrapper });
        return this;
    }
    /**
     * Removes the specified `listener` from this EventEmitter.
     *
     * ```js
     * const callback = (stream) => {
     *   console.log('someone connected!');
     * };
     * server.on('connection', callback);
     * // ...
     * server.removeListener('connection', callback);
     * ```
     * Returns a reference to the `EventEmitter`, so that calls can be chained.
     */
    removeListener(eventName, listener) {
        this.removeListenerInternal(eventName, listener);
        return this;
    }
    /**
     * Alias for `emitter.removeListener()`.
     */
    off(eventName, listener) {
        return this.removeListener(eventName, listener);
    }
    /**
     * Removes all listeners, or those of the specified `eventName`.
     * Returns a reference to the `EventEmitter`, so that calls can be chained.
     */
    removeAllListeners(eventName) {
        if (this._eventListeners.has(eventName)) {
            const listeners = this._eventListeners.get(eventName);
            if (listeners === undefined) {
                return this;
            }
            // Remove each event listener from the event target
            for (const listenerPair of listeners) {
                this.removeEventListener(eventName, listenerPair.eventListenerWrapper);
            }
            // Remove all event listeners mapped to this event from our internal map
            this._eventListeners.delete(eventName);
        }
        return this;
    }
    /**
     * Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments
     * to each.
     *
     * Returns `true` if the event had listeners, `false` otherwise.
     *
     * ```js
     * import { EventEmitter } from 'node:events';
     * const myEmitter = new EventEmitter();
     *
     * // First listener
     * myEmitter.on('event', function firstListener() {
     *   console.log('Helloooo! first listener');
     * });
     * // Second listener
     * myEmitter.on('event', function secondListener(arg1, arg2) {
     *   console.log(`event with parameters ${arg1}, ${arg2} in second listener`);
     * });
     * // Third listener
     * myEmitter.on('event', function thirdListener(...args) {
     *   const parameters = args.join(', ');
     *   console.log(`event with parameters ${parameters} in third listener`);
     * });
     *
     * console.log(myEmitter.listeners('event'));
     *
     * myEmitter.emit('event', 1, 2, 3, 4, 5);
     *
     * // Prints:
     * // [
     * //   [Function: firstListener],
     * //   [Function: secondListener],
     * //   [Function: thirdListener]
     * // ]
     * // Helloooo! first listener
     * // event with parameters 1, 2 in second listener
     * // event with parameters 1, 2, 3, 4, 5 in third listener
     * ```
     */
    emit(eventName, ...args) {
        if (this._eventListeners.has(eventName)) {
            const listeners = this._eventListeners.get(eventName);
            if (listeners === undefined) {
                return false;
            }
            // Ensure each of our listeners have the args the callback injected
            for (const listenerPair of listeners) {
                listenerPair.eventListenerWrapper.setArgs(...args);
            }
            // Fire off the actual event
            super.dispatchEvent(new Event(eventName));
            return true;
        }
        return false;
    }
}
//# sourceMappingURL=EventEmitter.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Logger/Logger.js":
/*!*************************************************!*\
  !*** ../../../Common/dist/esm/Logger/Logger.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LogLevel: () => (/* binding */ LogLevel),
/* harmony export */   Logger: () => (/* binding */ Logger),
/* harmony export */   LoggerContext: () => (/* binding */ LoggerContext),
/* harmony export */   LoggerType: () => (/* binding */ LoggerType),
/* harmony export */   overrideLogger: () => (/* binding */ overrideLogger)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Disabled"] = 0] = "Disabled";
    LogLevel[LogLevel["Error"] = 1] = "Error";
    LogLevel[LogLevel["Warning"] = 2] = "Warning";
    LogLevel[LogLevel["Info"] = 3] = "Info";
    LogLevel[LogLevel["Debug"] = 4] = "Debug";
})(LogLevel || (LogLevel = {}));
/**
 * The global context for the logger configuration.
 * This cannot be stored statically in the Logger class because we sometimes have multiple execution
 * contexts, such as stats reporting. Instead we store the logger config context on the window object
 * to be shared with any Logger instances.
 */
class LoggerContext {
    constructor() {
        this.logLevel = LogLevel.Debug;
        this.includeStack = true;
    }
}
function overrideLogger(logger) {
    Logger = logger;
}
/**
 * A basic console logger utilized by the Pixel Streaming frontend to allow
 * logging to the browser console.
 */
class LoggerType {
    /**
     * Set the log verbosity level
     */
    InitLogging(logLevel, includeStack) {
        this.ValidateContext();
        this.context.logLevel = logLevel;
        this.context.includeStack = includeStack;
    }
    /**
     * Logging output for debugging
     * @param message - the message to be logged
     */
    Debug(message) {
        this.ValidateContext();
        if (this.context.logLevel >= LogLevel.Debug) {
            this.CommonLog('Debug', message);
        }
    }
    /**
     * Basic logging output for standard messages
     * @param message - the message to be logged
     */
    Info(message) {
        this.ValidateContext();
        if (this.context.logLevel >= LogLevel.Info) {
            this.CommonLog('Info', message);
        }
    }
    /**
     * Logging for warnings
     * @param message - the message to be logged
     */
    Warning(message) {
        this.ValidateContext();
        if (this.context.logLevel >= LogLevel.Warning) {
            this.CommonLog('Warning', message);
        }
    }
    /**
     * Error logging
     * @param message - the message to be logged
     */
    Error(message) {
        this.ValidateContext();
        if (this.context.logLevel >= LogLevel.Error) {
            this.CommonLog('Error', message);
        }
    }
    /**
     * The common log function that all other log functions call to.
     * @param level - the level of this log message.
     * @param stack - an optional stack trace string from where the log message was called.
     * @param message - the message to be logged.
     */
    CommonLog(level, message) {
        let logMessage = `[${level}] - ${message}`;
        if (this.context.includeStack) {
            logMessage += `\nStack: ${this.GetStackTrace()}`;
        }
        if (level === 'Error') {
            console.error(logMessage);
        }
        else if (level === 'Warning') {
            console.warn(logMessage);
        }
        else {
            console.log(logMessage);
        }
    }
    /**
     * Captures the stack and returns it
     * @returns the current stack
     */
    GetStackTrace() {
        const error = new Error();
        let formattedStack = 'No Stack Available for this browser';
        // format the error
        if (error.stack) {
            formattedStack = error.stack.toString().replace(/Error/g, '');
        }
        return formattedStack;
    }
    /**
     * Since there can be multiple execution contexts, (stats reporting and some webxr logging comes from
     * different execution contexts we can end up with multiple static Logger instances. Here we try to
     * work around it by storing the context on the window object.
     */
    ValidateContext() {
        if (!this.context) {
            if (typeof window == 'undefined' || !window) {
                // no window object so we can only store a local context.
                this.context = new LoggerContext();
            }
            else if (!window.loggerContext) {
                this.context = new LoggerContext();
                window.loggerContext = this.context;
            }
            else {
                this.context = window.loggerContext;
            }
        }
    }
}
let Logger = new LoggerType();
//# sourceMappingURL=Logger.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Messages/message_helpers.js":
/*!************************************************************!*\
  !*** ../../../Common/dist/esm/Messages/message_helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createMessage: () => (/* binding */ createMessage),
/* harmony export */   validateMessage: () => (/* binding */ validateMessage)
/* harmony export */ });
/* harmony import */ var _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Logger/Logger */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _message_registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./message_registry */ "../../../Common/dist/esm/Messages/message_registry.js");


/**
 * A helper for creating signalling messages. Takes in optional given parameters and
 * includes them in a message object with the 'type' field set properly for the message
 * type supplied.
 * @param messageType - A message type from MessageRegistry that indicates the type of message to create.
 * @param params - An optional object whose fields are added to the newly created message.
 * @returns The resulting message object.
 */
function createMessage(messageType, params) {
    const message = messageType.create();
    message.type = messageType.typeName;
    if (params) {
        messageType.mergePartial(message, params);
    }
    return message;
}
/**
 * Tests that the supplied message is valid. That is contains all expected fields and
 * doesn't contain any unknown fields.
 * @param msg - The message object to test.
 * @returns The message type from MessageRegistry of the supplied message object if it's valid, or null if invalid.
 */
function validateMessage(msg) {
    let valid = true;
    if (!msg.type) {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Parsed message has no type. Rejected. ${JSON.stringify(msg)}`);
        return null;
    }
    const messageType = _message_registry__WEBPACK_IMPORTED_MODULE_1__.MessageRegistry[msg.type];
    if (!messageType) {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Message is of an unknown type: "${msg.type}". Rejected.`);
        return null;
    }
    if (messageType.fields) {
        for (const field of messageType.fields) {
            if (!field.opt) {
                if (!Object.prototype.hasOwnProperty.call(msg, field.name)) {
                    _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Message "${msg.type}"" is missing required field "${field.name}". Rejected.`);
                    valid = false;
                }
            }
        }
    }
    for (const fieldName in msg) {
        const found = messageType.fields.find((field) => field.name === fieldName);
        if (!found) {
            _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Message "${msg.type}" contains unknown field "${fieldName}". Rejected.`);
            valid = false;
        }
    }
    return valid ? messageType : null;
}
//# sourceMappingURL=message_helpers.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Messages/message_registry.js":
/*!*************************************************************!*\
  !*** ../../../Common/dist/esm/Messages/message_registry.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MessageRegistry: () => (/* binding */ MessageRegistry)
/* harmony export */ });
/* harmony import */ var _signalling_messages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signalling_messages */ "../../../Common/dist/esm/Messages/signalling_messages.js");

/**
 * A map of all the supported signalling messages in the Pixel Streaming
 * signalling protocol. This allows mapping of signalling message names
 * to actual message types.
 */
const MessageRegistry = {
    answer: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.answer,
    config: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.config,
    disconnectPlayer: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.disconnectPlayer,
    endpointId: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.endpointId,
    endpointIdConfirm: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.endpointIdConfirm,
    iceCandidate: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.iceCandidate,
    identify: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.identify,
    listStreamers: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.listStreamers,
    offer: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.offer,
    ping: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.ping,
    playerConnected: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.playerConnected,
    playerCount: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.playerCount,
    playerDisconnected: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.playerDisconnected,
    pong: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.pong,
    stats: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.stats,
    streamerDisconnected: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.streamerDisconnected,
    streamerList: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.streamerList,
    subscribe: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.subscribe,
    unsubscribe: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.unsubscribe,
    layerPreference: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.layerPreference,
    dataChannelRequest: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.dataChannelRequest,
    peerDataChannels: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.peerDataChannels,
    peerDataChannelsReady: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.peerDataChannelsReady,
    streamerDataChannels: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.streamerDataChannels,
    startStreaming: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.startStreaming,
    stopStreaming: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.stopStreaming
};
//# sourceMappingURL=message_registry.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Messages/signalling_messages.js":
/*!****************************************************************!*\
  !*** ../../../Common/dist/esm/Messages/signalling_messages.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   answer: () => (/* binding */ answer),
/* harmony export */   base_message: () => (/* binding */ base_message),
/* harmony export */   config: () => (/* binding */ config),
/* harmony export */   dataChannelRequest: () => (/* binding */ dataChannelRequest),
/* harmony export */   disconnectPlayer: () => (/* binding */ disconnectPlayer),
/* harmony export */   endpointId: () => (/* binding */ endpointId),
/* harmony export */   endpointIdConfirm: () => (/* binding */ endpointIdConfirm),
/* harmony export */   iceCandidate: () => (/* binding */ iceCandidate),
/* harmony export */   iceCandidateData: () => (/* binding */ iceCandidateData),
/* harmony export */   identify: () => (/* binding */ identify),
/* harmony export */   layerPreference: () => (/* binding */ layerPreference),
/* harmony export */   listStreamers: () => (/* binding */ listStreamers),
/* harmony export */   offer: () => (/* binding */ offer),
/* harmony export */   peerConnectionOptions: () => (/* binding */ peerConnectionOptions),
/* harmony export */   peerDataChannels: () => (/* binding */ peerDataChannels),
/* harmony export */   peerDataChannelsReady: () => (/* binding */ peerDataChannelsReady),
/* harmony export */   ping: () => (/* binding */ ping),
/* harmony export */   playerConnected: () => (/* binding */ playerConnected),
/* harmony export */   playerCount: () => (/* binding */ playerCount),
/* harmony export */   playerDisconnected: () => (/* binding */ playerDisconnected),
/* harmony export */   pong: () => (/* binding */ pong),
/* harmony export */   startStreaming: () => (/* binding */ startStreaming),
/* harmony export */   stats: () => (/* binding */ stats),
/* harmony export */   stopStreaming: () => (/* binding */ stopStreaming),
/* harmony export */   streamerDataChannels: () => (/* binding */ streamerDataChannels),
/* harmony export */   streamerDisconnected: () => (/* binding */ streamerDisconnected),
/* harmony export */   streamerIdChanged: () => (/* binding */ streamerIdChanged),
/* harmony export */   streamerList: () => (/* binding */ streamerList),
/* harmony export */   subscribe: () => (/* binding */ subscribe),
/* harmony export */   subscribeFailed: () => (/* binding */ subscribeFailed),
/* harmony export */   unsubscribe: () => (/* binding */ unsubscribe)
/* harmony export */ });
/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @protobuf-ts/runtime */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js");
/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @protobuf-ts/runtime */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js");
/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @protobuf-ts/runtime */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type.js");




// @generated message type with reflection information, may provide speed optimized methods
class base_message$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("base_message", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base_message
 */
const base_message = new base_message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class peerConnectionOptions$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("peerConnectionOptions", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message peerConnectionOptions
 */
const peerConnectionOptions = new peerConnectionOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class config$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("config", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "peerConnectionOptions", kind: "message", T: () => peerConnectionOptions },
            { no: 3, name: "protocolVersion", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* peerConnectionOptions peerConnectionOptions */ 2:
                    message.peerConnectionOptions = peerConnectionOptions.internalBinaryRead(reader, reader.uint32(), options, message.peerConnectionOptions);
                    break;
                case /* optional string protocolVersion */ 3:
                    message.protocolVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* peerConnectionOptions peerConnectionOptions = 2; */
        if (message.peerConnectionOptions)
            peerConnectionOptions.internalBinaryWrite(message.peerConnectionOptions, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).fork(), options).join();
        /* optional string protocolVersion = 3; */
        if (message.protocolVersion !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.protocolVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message config
 */
const config = new config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class identify$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("identify", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message identify
 */
const identify = new identify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class endpointId$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("endpointId", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "protocolVersion", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.id = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* optional string protocolVersion */ 3:
                    message.protocolVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.id);
        /* optional string protocolVersion = 3; */
        if (message.protocolVersion !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.protocolVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message endpointId
 */
const endpointId = new endpointId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class endpointIdConfirm$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("endpointIdConfirm", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "committedId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.committedId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string committedId */ 2:
                    message.committedId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string committedId = 2; */
        if (message.committedId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.committedId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message endpointIdConfirm
 */
const endpointIdConfirm = new endpointIdConfirm$Type();
// @generated message type with reflection information, may provide speed optimized methods
class streamerIdChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("streamerIdChanged", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "newID", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.newID = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string newID */ 2:
                    message.newID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string newID = 2; */
        if (message.newID !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.newID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message streamerIdChanged
 */
const streamerIdChanged = new streamerIdChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class listStreamers$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("listStreamers", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message listStreamers
 */
const listStreamers = new listStreamers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class streamerList$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("streamerList", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.ids = [];
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* repeated string ids */ 2:
                    message.ids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* repeated string ids = 2; */
        for (let i = 0; i < message.ids.length; i++)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message streamerList
 */
const streamerList = new streamerList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class subscribe$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("subscribe", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "streamerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.streamerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string streamerId */ 2:
                    message.streamerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string streamerId = 2; */
        if (message.streamerId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.streamerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message subscribe
 */
const subscribe = new subscribe$Type();
// @generated message type with reflection information, may provide speed optimized methods
class unsubscribe$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("unsubscribe", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message unsubscribe
 */
const unsubscribe = new unsubscribe$Type();
// @generated message type with reflection information, may provide speed optimized methods
class subscribeFailed$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("subscribeFailed", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.message = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message subscribeFailed
 */
const subscribeFailed = new subscribeFailed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class playerConnected$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("playerConnected", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dataChannel", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "sfu", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.dataChannel = false;
        message.sfu = false;
        message.playerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* bool dataChannel */ 2:
                    message.dataChannel = reader.bool();
                    break;
                case /* bool sfu */ 3:
                    message.sfu = reader.bool();
                    break;
                case /* string playerId */ 5:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* bool dataChannel = 2; */
        if (message.dataChannel !== false)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).bool(message.dataChannel);
        /* bool sfu = 3; */
        if (message.sfu !== false)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).bool(message.sfu);
        /* string playerId = 5; */
        if (message.playerId !== "")
            writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message playerConnected
 */
const playerConnected = new playerConnected$Type();
// @generated message type with reflection information, may provide speed optimized methods
class playerDisconnected$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("playerDisconnected", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.playerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string playerId */ 2:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string playerId = 2; */
        if (message.playerId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message playerDisconnected
 */
const playerDisconnected = new playerDisconnected$Type();
// @generated message type with reflection information, may provide speed optimized methods
class offer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("offer", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sdp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "playerId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "sfu", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "multiplex", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "scalabilityMode", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.sdp = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string sdp */ 2:
                    message.sdp = reader.string();
                    break;
                case /* optional string playerId */ 3:
                    message.playerId = reader.string();
                    break;
                case /* optional bool sfu */ 4:
                    message.sfu = reader.bool();
                    break;
                case /* optional bool multiplex */ 5:
                    message.multiplex = reader.bool();
                    break;
                case /* optional string scalabilityMode */ 6:
                    message.scalabilityMode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string sdp = 2; */
        if (message.sdp !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.sdp);
        /* optional string playerId = 3; */
        if (message.playerId !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        /* optional bool sfu = 4; */
        if (message.sfu !== undefined)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).bool(message.sfu);
        /* optional bool multiplex = 5; */
        if (message.multiplex !== undefined)
            writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).bool(message.multiplex);
        /* optional string scalabilityMode = 6; */
        if (message.scalabilityMode !== undefined)
            writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.scalabilityMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offer
 */
const offer = new offer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class answer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("answer", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sdp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "playerId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "minBitrateBps", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "maxBitrateBps", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.sdp = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string sdp */ 2:
                    message.sdp = reader.string();
                    break;
                case /* optional string playerId */ 3:
                    message.playerId = reader.string();
                    break;
                case /* optional int32 minBitrateBps */ 4:
                    message.minBitrateBps = reader.int32();
                    break;
                case /* optional int32 maxBitrateBps */ 5:
                    message.maxBitrateBps = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string sdp = 2; */
        if (message.sdp !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.sdp);
        /* optional string playerId = 3; */
        if (message.playerId !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        /* optional int32 minBitrateBps = 4; */
        if (message.minBitrateBps !== undefined)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.minBitrateBps);
        /* optional int32 maxBitrateBps = 5; */
        if (message.maxBitrateBps !== undefined)
            writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.maxBitrateBps);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message answer
 */
const answer = new answer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class iceCandidateData$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("iceCandidateData", [
            { no: 1, name: "candidate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sdpMid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sdpMLineIndex", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "usernameFragment", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.candidate = "";
        message.sdpMid = "";
        message.sdpMLineIndex = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string candidate */ 1:
                    message.candidate = reader.string();
                    break;
                case /* string sdpMid */ 2:
                    message.sdpMid = reader.string();
                    break;
                case /* int32 sdpMLineIndex */ 3:
                    message.sdpMLineIndex = reader.int32();
                    break;
                case /* optional string usernameFragment */ 4:
                    message.usernameFragment = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string candidate = 1; */
        if (message.candidate !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.candidate);
        /* string sdpMid = 2; */
        if (message.sdpMid !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.sdpMid);
        /* int32 sdpMLineIndex = 3; */
        if (message.sdpMLineIndex !== 0)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.sdpMLineIndex);
        /* optional string usernameFragment = 4; */
        if (message.usernameFragment !== undefined)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.usernameFragment);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message iceCandidateData
 */
const iceCandidateData = new iceCandidateData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class iceCandidate$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("iceCandidate", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "candidate", kind: "message", T: () => iceCandidateData },
            { no: 3, name: "playerId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* iceCandidateData candidate */ 2:
                    message.candidate = iceCandidateData.internalBinaryRead(reader, reader.uint32(), options, message.candidate);
                    break;
                case /* optional string playerId */ 3:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* iceCandidateData candidate = 2; */
        if (message.candidate)
            iceCandidateData.internalBinaryWrite(message.candidate, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).fork(), options).join();
        /* optional string playerId = 3; */
        if (message.playerId !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message iceCandidate
 */
const iceCandidate = new iceCandidate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class disconnectPlayer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("disconnectPlayer", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reason", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.playerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string playerId */ 2:
                    message.playerId = reader.string();
                    break;
                case /* optional string reason */ 3:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string playerId = 2; */
        if (message.playerId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        /* optional string reason = 3; */
        if (message.reason !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message disconnectPlayer
 */
const disconnectPlayer = new disconnectPlayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ping$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("ping", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "time", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.time = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 time */ 2:
                    message.time = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* int32 time = 2; */
        if (message.time !== 0)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.time);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ping
 */
const ping = new ping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class pong$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("pong", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "time", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.time = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 time */ 2:
                    message.time = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* int32 time = 2; */
        if (message.time !== 0)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.time);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pong
 */
const pong = new pong$Type();
// @generated message type with reflection information, may provide speed optimized methods
class streamerDisconnected$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("streamerDisconnected", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message streamerDisconnected
 */
const streamerDisconnected = new streamerDisconnected$Type();
// @generated message type with reflection information, may provide speed optimized methods
class layerPreference$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("layerPreference", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "spatialLayer", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "temporalLayer", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.spatialLayer = 0;
        message.temporalLayer = 0;
        message.playerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 spatialLayer */ 2:
                    message.spatialLayer = reader.int32();
                    break;
                case /* int32 temporalLayer */ 3:
                    message.temporalLayer = reader.int32();
                    break;
                case /* string playerId */ 4:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* int32 spatialLayer = 2; */
        if (message.spatialLayer !== 0)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.spatialLayer);
        /* int32 temporalLayer = 3; */
        if (message.temporalLayer !== 0)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.temporalLayer);
        /* string playerId = 4; */
        if (message.playerId !== "")
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message layerPreference
 */
const layerPreference = new layerPreference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class dataChannelRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("dataChannelRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message dataChannelRequest
 */
const dataChannelRequest = new dataChannelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class peerDataChannels$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("peerDataChannels", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sendStreamId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "recvStreamId", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.playerId = "";
        message.sendStreamId = 0;
        message.recvStreamId = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string playerId */ 2:
                    message.playerId = reader.string();
                    break;
                case /* int32 sendStreamId */ 3:
                    message.sendStreamId = reader.int32();
                    break;
                case /* int32 recvStreamId */ 4:
                    message.recvStreamId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string playerId = 2; */
        if (message.playerId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        /* int32 sendStreamId = 3; */
        if (message.sendStreamId !== 0)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.sendStreamId);
        /* int32 recvStreamId = 4; */
        if (message.recvStreamId !== 0)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.recvStreamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message peerDataChannels
 */
const peerDataChannels = new peerDataChannels$Type();
// @generated message type with reflection information, may provide speed optimized methods
class peerDataChannelsReady$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("peerDataChannelsReady", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message peerDataChannelsReady
 */
const peerDataChannelsReady = new peerDataChannelsReady$Type();
// @generated message type with reflection information, may provide speed optimized methods
class streamerDataChannels$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("streamerDataChannels", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sfuId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sendStreamId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "recvStreamId", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.sfuId = "";
        message.sendStreamId = 0;
        message.recvStreamId = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string sfuId */ 2:
                    message.sfuId = reader.string();
                    break;
                case /* int32 sendStreamId */ 3:
                    message.sendStreamId = reader.int32();
                    break;
                case /* int32 recvStreamId */ 4:
                    message.recvStreamId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string sfuId = 2; */
        if (message.sfuId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.sfuId);
        /* int32 sendStreamId = 3; */
        if (message.sendStreamId !== 0)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.sendStreamId);
        /* int32 recvStreamId = 4; */
        if (message.recvStreamId !== 0)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.recvStreamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message streamerDataChannels
 */
const streamerDataChannels = new streamerDataChannels$Type();
// @generated message type with reflection information, may provide speed optimized methods
class startStreaming$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("startStreaming", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message startStreaming
 */
const startStreaming = new startStreaming$Type();
// @generated message type with reflection information, may provide speed optimized methods
class stopStreaming$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("stopStreaming", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stopStreaming
 */
const stopStreaming = new stopStreaming$Type();
// @generated message type with reflection information, may provide speed optimized methods
class playerCount$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("playerCount", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.count = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 count */ 2:
                    message.count = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* int32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message playerCount
 */
const playerCount = new playerCount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class stats$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("stats", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.data = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string data */ 2:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string data = 2; */
        if (message.data !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stats
 */
const stats = new stats$Type();
//# sourceMappingURL=signalling_messages.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Protocol/KeepaliveMonitor.js":
/*!*************************************************************!*\
  !*** ../../../Common/dist/esm/Protocol/KeepaliveMonitor.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeepaliveMonitor: () => (/* binding */ KeepaliveMonitor)
/* harmony export */ });
/* harmony import */ var _Messages_signalling_messages__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Messages/signalling_messages */ "../../../Common/dist/esm/Messages/signalling_messages.js");
/* harmony import */ var _Messages_message_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Messages/message_helpers */ "../../../Common/dist/esm/Messages/message_helpers.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * Used to regularly ping a protocol connection to make sure the connection is still good and open.
 * When the pong doesn't come in response to a ping in time a callback is fired that can be handed
 * by the owner.
 */
class KeepaliveMonitor {
    /**
     * Gets the Round Trip Time of the current connection in milliseconds.
     */
    get RTT() {
        return this.rtt;
    }
    /**
     * Creates a new monitor and starts the ping timer. If a pong does not come back by the time we want
     * to send a second ping then the connection is considered dead and the onTimeout callback is fired.
     * @param protocol - The connection that we want to monitor.
     * @param timeout - The time in milliseconds between ping messages.
     */
    constructor(protocol, timeout) {
        this.alive = false;
        this.rtt = 0;
        this.protocol = protocol;
        this.timeout = timeout;
        this.onResponse = this.onHeartbeatResponse.bind(this);
        this.protocol.transport.on('close', this.stop.bind(this));
        this.start();
    }
    start() {
        this.alive = true;
        this.protocol.on('pong', this.onResponse);
        this.keepalive = setInterval(this.sendHeartbeat.bind(this), this.timeout);
    }
    stop() {
        clearInterval(this.keepalive);
        this.protocol.off('pong', this.onResponse);
    }
    sendHeartbeat() {
        var _a;
        // if we never got a response from the last heartbeat, assume the connection is dead and timeout
        if (this.alive === false) {
            (_a = this.onTimeout) === null || _a === void 0 ? void 0 : _a.call(this);
            return;
        }
        // mark the connection as temporarily dead until we get a response from the ping
        this.alive = false;
        this.protocol.sendMessage(_Messages_message_helpers__WEBPACK_IMPORTED_MODULE_0__.createMessage(_Messages_signalling_messages__WEBPACK_IMPORTED_MODULE_1__.ping, { time: new Date().getTime() }));
    }
    onHeartbeatResponse(pongMsg) {
        // we got a pong response from the other side, the connection is good.
        // we also store the round trip time if anyone is curious
        this.rtt = new Date().getTime() - pongMsg.time;
        this.alive = true;
    }
}
//# sourceMappingURL=KeepaliveMonitor.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Protocol/SignallingProtocol.js":
/*!***************************************************************!*\
  !*** ../../../Common/dist/esm/Protocol/SignallingProtocol.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SignallingProtocol: () => (/* binding */ SignallingProtocol)
/* harmony export */ });
/* harmony import */ var _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Event/EventEmitter */ "../../../Common/dist/esm/Event/EventEmitter.js");
/* harmony import */ var _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Logger/Logger */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * Signalling protocol for handling messages from the signalling server.
 *
 * Listen on this emitter for messages. Message type is the name of the event to listen for.
 * Example:
 *      signallingProtocol.on('config', (message: Messages.config) =\> console.log(`Got a config message: ${message}`)));
 *
 * The transport in this class will also emit on message events.
 *
 * Events emitted on transport:
 *   message:
 *      Emitted any time a message is received by the transport. Listen on this if
 *      you wish to capture all messages, rather than specific messages on
 *      'messageHandlers'.
 *
 *   out:
 *      Emitted when sending a message out on the transport. Similar to 'message' but
 *      only for when messages are sent from this endpoint. Useful for debugging.
 */
class SignallingProtocol extends _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    static get SIGNALLING_VERSION() {
        return '1.3.0';
    }
    constructor(transport) {
        super();
        this.transport = transport;
        transport.onMessage = (msg) => {
            let parsedMessage;
            try {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                const parsedData = JSON.parse(msg);
                _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Debug('Protocol received => \n' + JSON.stringify(parsedData, undefined, 4));
                parsedMessage = parsedData;
            }
            catch (e) {
                if (e instanceof Error) {
                    _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`Error parsing message string ${msg}.\n${e.message}`);
                }
                else {
                    _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`Unknown error while parsing message data in handleOnMessage`);
                }
                return;
            }
            // call the handlers
            transport.emit('message', parsedMessage); // emit this for listeners listening to any message
            if (!this.emit(parsedMessage.type, parsedMessage)) {
                // emit this for listeners listening for specific messages
                // no listeners
                this.emit('unhandled', parsedMessage);
            }
        };
    }
    /**
     * Asks the transport to connect to the given URL.
     * @param url - The url to connect to.
     * @returns True if the connection call succeeded.
     */
    connect(url) {
        return this.transport.connect(url);
    }
    /**
     * Asks the transport to disconnect from any connection it might have.
     * @param code - An optional disconnection code.
     * @param reason - An optional descriptive string for the disconnect reason.
     */
    disconnect(code, reason) {
        this.transport.disconnect(code, reason);
    }
    /**
     * Returns true if the transport is connected and ready to send/receive messages.
     * @returns True if the protocol is connected.
     */
    isConnected() {
        return this.transport.isConnected();
    }
    /**
     * Passes a message to the transport to send to the other end.
     * @param msg - The message to send.
     */
    sendMessage(msg) {
        this.transport.sendMessage(JSON.stringify(msg));
        this.transport.emit('out', msg); // emit this for listeners listening to outgoing messages
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Debug('Protocol sent => \n' + JSON.stringify(msg, undefined, 4));
    }
}
//# sourceMappingURL=SignallingProtocol.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Transport/WebSocketTransport.js":
/*!****************************************************************!*\
  !*** ../../../Common/dist/esm/Transport/WebSocketTransport.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebSocketTransport: () => (/* binding */ WebSocketTransport)
/* harmony export */ });
/* harmony import */ var _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Logger/Logger */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Event/EventEmitter */ "../../../Common/dist/esm/Event/EventEmitter.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * The controller for the WebSocket and all associated methods
 */
class WebSocketTransport extends _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    /**
     * Constructs a new WebSocketTransport for browser contexts.
     * @param protocols - An optional string or list of strings to pass to the new websocket protocols param
     */
    constructor(protocols) {
        super();
        this.WS_OPEN_STATE = 1;
        this.protocols = protocols;
    }
    /**
     * Sends a message over the websocket.
     * @param msg - The message to send.
     */
    sendMessage(msg) {
        if (this.webSocket) {
            this.webSocket.send(msg);
        }
    }
    /**
     * Connect to the signaling server
     * @param connectionURL - The Address of the signaling server
     * @returns If there is a connection
     */
    connect(connectionURL) {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(connectionURL);
        try {
            this.webSocket = new WebSocket(connectionURL, this.protocols);
            this.webSocket.onopen = (_) => this.handleOnOpen();
            this.webSocket.onerror = (_) => this.handleOnError();
            this.webSocket.onclose = (event) => this.handleOnClose(event);
            this.webSocket.onmessage = (event) => this.handleOnMessage(event);
            this.webSocket.onmessagebinary = (event) => this.handleOnMessageBinary(event);
            return true;
        }
        catch (error) {
            _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(error);
            return false;
        }
    }
    /**
     * Disconnect this transport.
     * @param code - An optional disconnect code.
     * @param reason - A descriptive string for the disconnect reason.
     */
    disconnect(code, reason) {
        if (this.webSocket) {
            this.webSocket.close(code, reason);
        }
    }
    /**
     * Should return true when the transport is connected and ready to send/receive messages.
     * @returns True if the transport is connected.
     */
    isConnected() {
        return !!this.webSocket && this.webSocket.readyState != WebSocket.CLOSED;
    }
    /**
     * Handles what happens when a message is received in binary form
     * @param event - Message Received
     */
    handleOnMessageBinary(event) {
        // if the event is empty return
        if (!event || !event.data) {
            return;
        }
        // handle the binary and then handle the message
        event.data
            .text()
            .then((messageString) => {
            // build a new message
            const constructedMessage = new MessageEvent('messageFromBinary', {
                data: messageString
            });
            // send the new stringified event back into `onmessage`
            this.handleOnMessage(constructedMessage);
        })
            .catch((error) => {
            _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`Failed to parse binary blob from websocket, reason: ${error.message}`);
        });
    }
    /**
     * Handles what happens when a message is received
     * @param event - Message Received
     */
    handleOnMessage(event) {
        // Check if websocket message is binary, if so, stringify it.
        if (event.data && event.data instanceof Blob) {
            this.handleOnMessageBinary(event);
            return;
        }
        if (this.onMessage) {
            this.onMessage(event.data);
        }
    }
    /**
     * Handles when the Websocket is opened
     */
    handleOnOpen() {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Connected to the signalling server via WebSocket');
        this.emit('open');
    }
    /**
     * Handles when there is an error on the websocket
     */
    handleOnError() {
        //Logger.Error(Logger.GetStackTrace(), 'WebSocket error');
        this.emit('error');
    }
    /**
     * Handles when the Websocket is closed
     * @param event - Close Event
     */
    handleOnClose(event) {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Disconnected to the signalling server via WebSocket: ' +
            JSON.stringify(event.code) +
            ' - ' +
            event.reason);
        this.emit('close', event);
    }
}
//# sourceMappingURL=WebSocketTransport.js.map

/***/ }),

/***/ "../../../Common/dist/esm/Util/SdpUtils.js":
/*!*************************************************!*\
  !*** ../../../Common/dist/esm/Util/SdpUtils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SDPUtils: () => (/* binding */ SDPUtils)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class SDPUtils {
    static addVideoHeaderExtensionToSdp(sdp, uri) {
        // Find the highest used header extension id by sorting the extension ids used,
        // eliminating duplicates and adding one.
        // Todo: Update this when WebRTC in Chrome supports the header extension API.
        const usedIds = sdp
            .split('\n')
            .filter((line) => line.startsWith('a=extmap:'))
            .map((line) => parseInt(line.split(' ')[0].substring(9), 10))
            .sort((a, b) => a - b)
            .filter((item, index, array) => array.indexOf(item) === index);
        const nextId = usedIds[usedIds.length - 1] + 1;
        const extmapLine = 'a=extmap:' + nextId + ' ' + uri + '\r\n';
        const sections = sdp.split('\nm=').map((part, index) => {
            return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
        });
        const sessionPart = sections.shift();
        // Only add extension to m=video media section
        return (sessionPart +
            sections
                .map((mediaSection) => mediaSection.startsWith('m=video') ? mediaSection + extmapLine : mediaSection)
                .join(''));
    }
}
//# sourceMappingURL=SdpUtils.js.map

/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!*********************************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _assertThisInitialized)
/* harmony export */ });
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}


/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!***********************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _createClass)
/* harmony export */ });
/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ "../../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js");

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}


/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/extends.js":
/*!*******************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _extends)
/* harmony export */ });
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}


/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _inheritsLoose)
/* harmony export */ });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ "../../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(t, o);
}


/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!****************************************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _objectWithoutPropertiesLoose)
/* harmony export */ });
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}


/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _setPrototypeOf)
/* harmony export */ });
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}


/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js":
/*!***********************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toPrimitive)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "../../../node_modules/@babel/runtime/helpers/esm/typeof.js");

function toPrimitive(t, r) {
  if ("object" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}


/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toPropertyKey)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "../../../node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPrimitive.js */ "../../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js");


function toPropertyKey(t) {
  var i = (0,_toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__["default"])(t, "string");
  return "symbol" == (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(i) ? i : i + "";
}


/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _typeof)
/* harmony export */ });
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assert: () => (/* binding */ assert),
/* harmony export */   assertFloat32: () => (/* binding */ assertFloat32),
/* harmony export */   assertInt32: () => (/* binding */ assertInt32),
/* harmony export */   assertNever: () => (/* binding */ assertNever),
/* harmony export */   assertUInt32: () => (/* binding */ assertUInt32)
/* harmony export */ });
/**
 * assert that condition is true or throw error (with message)
 */
function assert(condition, msg) {
    if (!condition) {
        throw new Error(msg);
    }
}
/**
 * assert that value cannot exist = type `never`. throw runtime error if it does.
 */
function assertNever(value, msg) {
    throw new Error(msg !== null && msg !== void 0 ? msg : 'Unexpected object: ' + value);
}
const FLOAT32_MAX = 3.4028234663852886e+38, FLOAT32_MIN = -3.4028234663852886e+38, UINT32_MAX = 0xFFFFFFFF, INT32_MAX = 0X7FFFFFFF, INT32_MIN = -0X80000000;
function assertInt32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid int 32: ' + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
        throw new Error('invalid int 32: ' + arg);
}
function assertUInt32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid uint 32: ' + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
        throw new Error('invalid uint 32: ' + arg);
}
function assertFloat32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid float 32: ' + typeof arg);
    if (!Number.isFinite(arg))
        return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
        throw new Error('invalid float 32: ' + arg);
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/base64.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/base64.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base64decode: () => (/* binding */ base64decode),
/* harmony export */   base64encode: () => (/* binding */ base64encode)
/* harmony export */ });
// lookup table from base64 character to byte
let encTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
// lookup table from base64 character *code* to byte because lookup by number is fast
let decTable = [];
for (let i = 0; i < encTable.length; i++)
    decTable[encTable[i].charCodeAt(0)] = i;
// support base64url variants
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
/**
 * Decodes a base64 string to a byte array.
 *
 * - ignores white-space, including line breaks and tabs
 * - allows inner padding (can decode concatenated base64 strings)
 * - does not require padding
 * - understands base64url encoding:
 *   "-" instead of "+",
 *   "_" instead of "/",
 *   no padding
 */
function base64decode(base64Str) {
    // estimate byte size, not accounting for inner padding and whitespace
    let es = base64Str.length * 3 / 4;
    // if (es % 3 !== 0)
    // throw new Error('invalid base64 string');
    if (base64Str[base64Str.length - 2] == '=')
        es -= 2;
    else if (base64Str[base64Str.length - 1] == '=')
        es -= 1;
    let bytes = new Uint8Array(es), bytePos = 0, // position in byte array
    groupPos = 0, // position in base64 group
    b, // current byte
    p = 0 // previous byte
    ;
    for (let i = 0; i < base64Str.length; i++) {
        b = decTable[base64Str.charCodeAt(i)];
        if (b === undefined) {
            // noinspection FallThroughInSwitchStatementJS
            switch (base64Str[i]) {
                case '=':
                    groupPos = 0; // reset state when padding found
                case '\n':
                case '\r':
                case '\t':
                case ' ':
                    continue; // skip white-space, and padding
                default:
                    throw Error(`invalid base64 string.`);
            }
        }
        switch (groupPos) {
            case 0:
                p = b;
                groupPos = 1;
                break;
            case 1:
                bytes[bytePos++] = p << 2 | (b & 48) >> 4;
                p = b;
                groupPos = 2;
                break;
            case 2:
                bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
                p = b;
                groupPos = 3;
                break;
            case 3:
                bytes[bytePos++] = (p & 3) << 6 | b;
                groupPos = 0;
                break;
        }
    }
    if (groupPos == 1)
        throw Error(`invalid base64 string.`);
    return bytes.subarray(0, bytePos);
}
/**
 * Encodes a byte array to a base64 string.
 * Adds padding at the end.
 * Does not insert newlines.
 */
function base64encode(bytes) {
    let base64 = '', groupPos = 0, // position in base64 group
    b, // current byte
    p = 0; // carry over from previous byte
    for (let i = 0; i < bytes.length; i++) {
        b = bytes[i];
        switch (groupPos) {
            case 0:
                base64 += encTable[b >> 2];
                p = (b & 3) << 4;
                groupPos = 1;
                break;
            case 1:
                base64 += encTable[p | b >> 4];
                p = (b & 15) << 2;
                groupPos = 2;
                break;
            case 2:
                base64 += encTable[p | b >> 6];
                base64 += encTable[b & 63];
                groupPos = 0;
                break;
        }
    }
    // padding required?
    if (groupPos) {
        base64 += encTable[p];
        base64 += '=';
        if (groupPos == 1)
            base64 += '=';
    }
    return base64;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnknownFieldHandler: () => (/* binding */ UnknownFieldHandler),
/* harmony export */   WireType: () => (/* binding */ WireType),
/* harmony export */   mergeBinaryOptions: () => (/* binding */ mergeBinaryOptions)
/* harmony export */ });
/**
 * This handler implements the default behaviour for unknown fields.
 * When reading data, unknown fields are stored on the message, in a
 * symbol property.
 * When writing data, the symbol property is queried and unknown fields
 * are serialized into the output again.
 */
var UnknownFieldHandler;
(function (UnknownFieldHandler) {
    /**
     * The symbol used to store unknown fields for a message.
     * The property must conform to `UnknownFieldContainer`.
     */
    UnknownFieldHandler.symbol = Symbol.for("protobuf-ts/unknown");
    /**
     * Store an unknown field during binary read directly on the message.
     * This method is compatible with `BinaryReadOptions.readUnknownField`.
     */
    UnknownFieldHandler.onRead = (typeName, message, fieldNo, wireType, data) => {
        let container = is(message) ? message[UnknownFieldHandler.symbol] : message[UnknownFieldHandler.symbol] = [];
        container.push({ no: fieldNo, wireType, data });
    };
    /**
     * Write unknown fields stored for the message to the writer.
     * This method is compatible with `BinaryWriteOptions.writeUnknownFields`.
     */
    UnknownFieldHandler.onWrite = (typeName, message, writer) => {
        for (let { no, wireType, data } of UnknownFieldHandler.list(message))
            writer.tag(no, wireType).raw(data);
    };
    /**
     * List unknown fields stored for the message.
     * Note that there may be multiples fields with the same number.
     */
    UnknownFieldHandler.list = (message, fieldNo) => {
        if (is(message)) {
            let all = message[UnknownFieldHandler.symbol];
            return fieldNo ? all.filter(uf => uf.no == fieldNo) : all;
        }
        return [];
    };
    /**
     * Returns the last unknown field by field number.
     */
    UnknownFieldHandler.last = (message, fieldNo) => UnknownFieldHandler.list(message, fieldNo).slice(-1)[0];
    const is = (message) => message && Array.isArray(message[UnknownFieldHandler.symbol]);
})(UnknownFieldHandler || (UnknownFieldHandler = {}));
/**
 * Merges binary write or read options. Later values override earlier values.
 */
function mergeBinaryOptions(a, b) {
    return Object.assign(Object.assign({}, a), b);
}
/**
 * Protobuf binary format wire types.
 *
 * A wire type provides just enough information to find the length of the
 * following value.
 *
 * See https://developers.google.com/protocol-buffers/docs/encoding#structure
 */
var WireType;
(function (WireType) {
    /**
     * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum
     */
    WireType[WireType["Varint"] = 0] = "Varint";
    /**
     * Used for fixed64, sfixed64, double.
     * Always 8 bytes with little-endian byte order.
     */
    WireType[WireType["Bit64"] = 1] = "Bit64";
    /**
     * Used for string, bytes, embedded messages, packed repeated fields
     *
     * Only repeated numeric types (types which use the varint, 32-bit,
     * or 64-bit wire types) can be packed. In proto3, such fields are
     * packed by default.
     */
    WireType[WireType["LengthDelimited"] = 2] = "LengthDelimited";
    /**
     * Used for groups
     * @deprecated
     */
    WireType[WireType["StartGroup"] = 3] = "StartGroup";
    /**
     * Used for groups
     * @deprecated
     */
    WireType[WireType["EndGroup"] = 4] = "EndGroup";
    /**
     * Used for fixed32, sfixed32, float.
     * Always 4 bytes with little-endian byte order.
     */
    WireType[WireType["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js":
/*!********************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BinaryReader: () => (/* binding */ BinaryReader),
/* harmony export */   binaryReadOptions: () => (/* binding */ binaryReadOptions)
/* harmony export */ });
/* harmony import */ var _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binary-format-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js");
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");
/* harmony import */ var _goog_varint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./goog-varint */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js");



const defaultsRead = {
    readUnknownField: true,
    readerFactory: bytes => new BinaryReader(bytes),
};
/**
 * Make options for reading binary data form partial options.
 */
function binaryReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
class BinaryReader {
    constructor(buf, textDecoder) {
        this.varint64 = _goog_varint__WEBPACK_IMPORTED_MODULE_0__.varint64read; // dirty cast for `this`
        /**
         * Read a `uint32` field, an unsigned 32 bit varint.
         */
        this.uint32 = _goog_varint__WEBPACK_IMPORTED_MODULE_0__.varint32read; // dirty cast for `this` and access to protected `buf`
        this.buf = buf;
        this.len = buf.length;
        this.pos = 0;
        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
            fatal: true,
            ignoreBOM: true,
        });
    }
    /**
     * Reads a tag - field number and wire type.
     */
    tag() {
        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5)
            throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [fieldNo, wireType];
    }
    /**
     * Skip one element on the wire and return the skipped data.
     * Supports WireType.StartGroup since v2.0.0-alpha.23.
     */
    skip(wireType) {
        let start = this.pos;
        // noinspection FallThroughInSwitchStatementJS
        switch (wireType) {
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.Varint:
                while (this.buf[this.pos++] & 0x80) {
                    // ignore
                }
                break;
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.Bit64:
                this.pos += 4;
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.Bit32:
                this.pos += 4;
                break;
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.LengthDelimited:
                let len = this.uint32();
                this.pos += len;
                break;
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.StartGroup:
                // From descriptor.proto: Group type is deprecated, not supported in proto3.
                // But we must still be able to parse and treat as unknown.
                let t;
                while ((t = this.tag()[1]) !== _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.EndGroup) {
                    this.skip(t);
                }
                break;
            default:
                throw new Error("cant skip wire type " + wireType);
        }
        this.assertBounds();
        return this.buf.subarray(start, this.pos);
    }
    /**
     * Throws error if position in byte array is out of range.
     */
    assertBounds() {
        if (this.pos > this.len)
            throw new RangeError("premature EOF");
    }
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */
    int32() {
        return this.uint32() | 0;
    }
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
    sint32() {
        let zze = this.uint32();
        // decode zigzag
        return (zze >>> 1) ^ -(zze & 1);
    }
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */
    int64() {
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong(...this.varint64());
    }
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */
    uint64() {
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong(...this.varint64());
    }
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64() {
        let [lo, hi] = this.varint64();
        // decode zig zag
        let s = -(lo & 1);
        lo = ((lo >>> 1 | (hi & 1) << 31) ^ s);
        hi = (hi >>> 1 ^ s);
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong(lo, hi);
    }
    /**
     * Read a `bool` field, a variant.
     */
    bool() {
        let [lo, hi] = this.varint64();
        return lo !== 0 || hi !== 0;
    }
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */
    fixed32() {
        return this.view.getUint32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */
    sfixed32() {
        return this.view.getInt32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */
    fixed64() {
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */
    sfixed64() {
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `float` field, 32-bit floating point number.
     */
    float() {
        return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `double` field, a 64-bit floating point number.
     */
    double() {
        return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */
    bytes() {
        let len = this.uint32();
        let start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
    }
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */
    string() {
        return this.textDecoder.decode(this.bytes());
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js":
/*!********************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BinaryWriter: () => (/* binding */ BinaryWriter),
/* harmony export */   binaryWriteOptions: () => (/* binding */ binaryWriteOptions)
/* harmony export */ });
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");
/* harmony import */ var _goog_varint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./goog-varint */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js");



const defaultsWrite = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter(),
};
/**
 * Make options for writing binary data form partial options.
 */
function binaryWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
class BinaryWriter {
    constructor(textEncoder) {
        /**
         * Previous fork states.
         */
        this.stack = [];
        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
        this.chunks = [];
        this.buf = [];
    }
    /**
     * Return all bytes written and reset this writer.
     */
    finish() {
        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer
        let len = 0;
        for (let i = 0; i < this.chunks.length; i++)
            len += this.chunks[i].length;
        let bytes = new Uint8Array(len);
        let offset = 0;
        for (let i = 0; i < this.chunks.length; i++) {
            bytes.set(this.chunks[i], offset);
            offset += this.chunks[i].length;
        }
        this.chunks = [];
        return bytes;
    }
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */
    fork() {
        this.stack.push({ chunks: this.chunks, buf: this.buf });
        this.chunks = [];
        this.buf = [];
        return this;
    }
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */
    join() {
        // get chunk of fork
        let chunk = this.finish();
        // restore previous state
        let prev = this.stack.pop();
        if (!prev)
            throw new Error('invalid state, fork stack empty');
        this.chunks = prev.chunks;
        this.buf = prev.buf;
        // write length of chunk as varint
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
    }
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */
    tag(fieldNo, type) {
        return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    /**
     * Write a chunk of raw bytes.
     */
    raw(chunk) {
        if (this.buf.length) {
            this.chunks.push(new Uint8Array(this.buf));
            this.buf = [];
        }
        this.chunks.push(chunk);
        return this;
    }
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */
    uint32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertUInt32)(value);
        // write value as varint 32, inlined for speed
        while (value > 0x7f) {
            this.buf.push((value & 0x7f) | 0x80);
            value = value >>> 7;
        }
        this.buf.push(value);
        return this;
    }
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */
    int32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertInt32)(value);
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint32write)(value, this.buf);
        return this;
    }
    /**
     * Write a `bool` value, a variant.
     */
    bool(value) {
        this.buf.push(value ? 1 : 0);
        return this;
    }
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */
    bytes(value) {
        this.uint32(value.byteLength); // write length of chunk as varint
        return this.raw(value);
    }
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */
    string(value) {
        let chunk = this.textEncoder.encode(value);
        this.uint32(chunk.byteLength); // write length of chunk as varint
        return this.raw(chunk);
    }
    /**
     * Write a `float` value, 32-bit floating point number.
     */
    float(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertFloat32)(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setFloat32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `double` value, a 64-bit floating point number.
     */
    double(value) {
        let chunk = new Uint8Array(8);
        new DataView(chunk.buffer).setFloat64(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */
    fixed32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertUInt32)(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setUint32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */
    sfixed32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertInt32)(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setInt32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */
    sint32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertInt32)(value);
        // zigzag encode
        value = ((value << 1) ^ (value >> 31)) >>> 0;
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint32write)(value, this.buf);
        return this;
    }
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */
    sfixed64(value) {
        let chunk = new Uint8Array(8);
        let view = new DataView(chunk.buffer);
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk);
    }
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */
    fixed64(value) {
        let chunk = new Uint8Array(8);
        let view = new DataView(chunk.buffer);
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong.from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk);
    }
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */
    int64(value) {
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.from(value);
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint64write)(long.lo, long.hi, this.buf);
        return this;
    }
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64(value) {
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.from(value), 
        // zigzag encode
        sign = long.hi >> 31, lo = (long.lo << 1) ^ sign, hi = ((long.hi << 1) | (long.lo >>> 31)) ^ sign;
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint64write)(lo, hi, this.buf);
        return this;
    }
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */
    uint64(value) {
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong.from(value);
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint64write)(long.lo, long.hi, this.buf);
        return this;
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   int64fromString: () => (/* binding */ int64fromString),
/* harmony export */   int64toString: () => (/* binding */ int64toString),
/* harmony export */   varint32read: () => (/* binding */ varint32read),
/* harmony export */   varint32write: () => (/* binding */ varint32write),
/* harmony export */   varint64read: () => (/* binding */ varint64read),
/* harmony export */   varint64write: () => (/* binding */ varint64write)
/* harmony export */ });
// Copyright 2008 Google Inc.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Code generated by the Protocol Buffer compiler is owned by the owner
// of the input file used when generating it.  This code is not
// standalone and requires a support library to be linked with it.  This
// support library is itself covered by the above license.
/**
 * Read a 64 bit varint as two JS numbers.
 *
 * Returns tuple:
 * [0]: low bits
 * [0]: high bits
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175
 */
function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
        let b = this.buf[this.pos++];
        lowBits |= (b & 0x7F) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [lowBits, highBits];
        }
    }
    let middleByte = this.buf[this.pos++];
    // last four bits of the first 32 bit number
    lowBits |= (middleByte & 0x0F) << 28;
    // 3 upper bits are part of the next 32 bit number
    highBits = (middleByte & 0x70) >> 4;
    if ((middleByte & 0x80) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
        let b = this.buf[this.pos++];
        highBits |= (b & 0x7F) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [lowBits, highBits];
        }
    }
    throw new Error('invalid varint');
}
/**
 * Write a 64 bit varint, given as two JS numbers, to the given bytes array.
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344
 */
function varint64write(lo, hi, bytes) {
    for (let i = 0; i < 28; i = i + 7) {
        const shift = lo >>> i;
        const hasNext = !((shift >>> 7) == 0 && hi == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    const splitBits = ((lo >>> 28) & 0x0F) | ((hi & 0x07) << 4);
    const hasMoreBits = !((hi >> 3) == 0);
    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xFF);
    if (!hasMoreBits) {
        return;
    }
    for (let i = 3; i < 31; i = i + 7) {
        const shift = hi >>> i;
        const hasNext = !((shift >>> 7) == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    bytes.push((hi >>> 31) & 0x01);
}
// constants for binary math
const TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
/**
 * Parse decimal string of 64 bit integer value as two JS numbers.
 *
 * Returns tuple:
 * [0]: minus sign?
 * [1]: low bits
 * [2]: high bits
 *
 * Copyright 2008 Google Inc.
 */
function int64fromString(dec) {
    // Check for minus sign.
    let minus = dec[0] == '-';
    if (minus)
        dec = dec.slice(1);
    // Work 6 decimal digits at a time, acting like we're converting base 1e6
    // digits to binary. This is safe to do with floating point math because
    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
        // Note: Number('') is 0.
        const digit1e6 = Number(dec.slice(begin, end));
        highBits *= base;
        lowBits = lowBits * base + digit1e6;
        // Carry bits from lowBits to highBits
        if (lowBits >= TWO_PWR_32_DBL) {
            highBits = highBits + ((lowBits / TWO_PWR_32_DBL) | 0);
            lowBits = lowBits % TWO_PWR_32_DBL;
        }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return [minus, lowBits, highBits];
}
/**
 * Format 64 bit integer value (as two JS numbers) to decimal string.
 *
 * Copyright 2008 Google Inc.
 */
function int64toString(bitsLow, bitsHigh) {
    // Skip the expensive conversion if the number is small enough to use the
    // built-in conversions.
    if ((bitsHigh >>> 0) <= 0x1FFFFF) {
        return '' + (TWO_PWR_32_DBL * bitsHigh + (bitsLow >>> 0));
    }
    // What this code is doing is essentially converting the input number from
    // base-2 to base-1e7, which allows us to represent the 64-bit range with
    // only 3 (very large) digits. Those digits are then trivial to convert to
    // a base-10 string.
    // The magic numbers used here are -
    // 2^24 = 16777216 = (1,6777216) in base-1e7.
    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.
    // Split 32:32 representation into 16:24:24 representation so our
    // intermediate digits don't overflow.
    let low = bitsLow & 0xFFFFFF;
    let mid = (((bitsLow >>> 24) | (bitsHigh << 8)) >>> 0) & 0xFFFFFF;
    let high = (bitsHigh >> 16) & 0xFFFF;
    // Assemble our three base-1e7 digits, ignoring carries. The maximum
    // value in a digit at this step is representable as a 48-bit integer, which
    // can be stored in a 64-bit floating point number.
    let digitA = low + (mid * 6777216) + (high * 6710656);
    let digitB = mid + (high * 8147497);
    let digitC = (high * 2);
    // Apply carries from A to B and from B to C.
    let base = 10000000;
    if (digitA >= base) {
        digitB += Math.floor(digitA / base);
        digitA %= base;
    }
    if (digitB >= base) {
        digitC += Math.floor(digitB / base);
        digitB %= base;
    }
    // Convert base-1e7 digits to base-10, with optional leading zeroes.
    function decimalFrom1e7(digit1e7, needLeadingZeros) {
        let partial = digit1e7 ? String(digit1e7) : '';
        if (needLeadingZeros) {
            return '0000000'.slice(partial.length) + partial;
        }
        return partial;
    }
    return decimalFrom1e7(digitC, /*needLeadingZeros=*/ 0) +
        decimalFrom1e7(digitB, /*needLeadingZeros=*/ digitC) +
        // If the final 1e7 digit didn't need leading zeros, we would have
        // returned via the trivial code path at the top.
        decimalFrom1e7(digitA, /*needLeadingZeros=*/ 1);
}
/**
 * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144
 */
function varint32write(value, bytes) {
    if (value >= 0) {
        // write value as varint 32
        while (value > 0x7f) {
            bytes.push((value & 0x7f) | 0x80);
            value = value >>> 7;
        }
        bytes.push(value);
    }
    else {
        for (let i = 0; i < 9; i++) {
            bytes.push(value & 127 | 128);
            value = value >> 7;
        }
        bytes.push(1);
    }
}
/**
 * Read an unsigned 32 bit varint.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220
 */
function varint32read() {
    let b = this.buf[this.pos++];
    let result = b & 0x7F;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 7;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 14;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 21;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    // Extract only last 4 bits
    b = this.buf[this.pos++];
    result |= (b & 0x0F) << 28;
    for (let readBytes = 5; ((b & 0x80) !== 0) && readBytes < 10; readBytes++)
        b = this.buf[this.pos++];
    if ((b & 0x80) != 0)
        throw new Error('invalid varint');
    this.assertBounds();
    // Result can have 32 bits, convert it to unsigned
    return result >>> 0;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js":
/*!***************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   jsonReadOptions: () => (/* binding */ jsonReadOptions),
/* harmony export */   jsonWriteOptions: () => (/* binding */ jsonWriteOptions),
/* harmony export */   mergeJsonOptions: () => (/* binding */ mergeJsonOptions)
/* harmony export */ });
const defaultsWrite = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0,
}, defaultsRead = {
    ignoreUnknownFields: false,
};
/**
 * Make options for reading JSON data from partial options.
 */
function jsonReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
/**
 * Make options for writing JSON data from partial options.
 */
function jsonWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
/**
 * Merges JSON write or read options. Later values override earlier values. Type registries are merged.
 */
function mergeJsonOptions(a, b) {
    var _a, _b;
    let c = Object.assign(Object.assign({}, a), b);
    c.typeRegistry = [...((_a = a === null || a === void 0 ? void 0 : a.typeRegistry) !== null && _a !== void 0 ? _a : []), ...((_b = b === null || b === void 0 ? void 0 : b.typeRegistry) !== null && _b !== void 0 ? _b : [])];
    return c;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js":
/*!*******************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),
/* harmony export */   typeofJsonValue: () => (/* binding */ typeofJsonValue)
/* harmony export */ });
/**
 * Get the type of a JSON value.
 * Distinguishes between array, null and object.
 */
function typeofJsonValue(value) {
    let t = typeof value;
    if (t == "object") {
        if (Array.isArray(value))
            return "array";
        if (value === null)
            return "null";
    }
    return t;
}
/**
 * Is this a JSON object (instead of an array or null)?
 */
function isJsonObject(value) {
    return value !== null && typeof value == "object" && !Array.isArray(value);
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lowerCamelCase: () => (/* binding */ lowerCamelCase)
/* harmony export */ });
/**
 * Converts snake_case to lowerCamelCase.
 *
 * Should behave like protoc:
 * https://github.com/protocolbuffers/protobuf/blob/e8ae137c96444ea313485ed1118c5e43b2099cf1/src/google/protobuf/compiler/java/java_helpers.cc#L118
 */
function lowerCamelCase(snakeCase) {
    let capNext = false;
    const sb = [];
    for (let i = 0; i < snakeCase.length; i++) {
        let next = snakeCase.charAt(i);
        if (next == '_') {
            capNext = true;
        }
        else if (/\d/.test(next)) {
            sb.push(next);
            capNext = true;
        }
        else if (capNext) {
            sb.push(next.toUpperCase());
            capNext = false;
        }
        else if (i == 0) {
            sb.push(next.toLowerCase());
        }
        else {
            sb.push(next);
        }
    }
    return sb.join('');
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js":
/*!****************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MESSAGE_TYPE: () => (/* binding */ MESSAGE_TYPE)
/* harmony export */ });
/**
 * The symbol used as a key on message objects to store the message type.
 *
 * Note that this is an experimental feature - it is here to stay, but
 * implementation details may change without notice.
 */
const MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type.js":
/*!*******************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MessageType: () => (/* binding */ MessageType)
/* harmony export */ });
/* harmony import */ var _message_type_contract__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./message-type-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js");
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _reflection_type_check__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reflection-type-check */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js");
/* harmony import */ var _reflection_json_reader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reflection-json-reader */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js");
/* harmony import */ var _reflection_json_writer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reflection-json-writer */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js");
/* harmony import */ var _reflection_binary_reader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./reflection-binary-reader */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js");
/* harmony import */ var _reflection_binary_writer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./reflection-binary-writer */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js");
/* harmony import */ var _reflection_create__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./reflection-create */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js");
/* harmony import */ var _reflection_merge_partial__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./reflection-merge-partial */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js");
/* harmony import */ var _json_typings__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./json-typings */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js");
/* harmony import */ var _json_format_contract__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./json-format-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js");
/* harmony import */ var _reflection_equals__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./reflection-equals */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js");
/* harmony import */ var _binary_writer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./binary-writer */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js");
/* harmony import */ var _binary_reader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./binary-reader */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js");














const baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
/**
 * This standard message type provides reflection-based
 * operations to work with a message.
 */
class MessageType {
    constructor(name, fields, options) {
        this.defaultCheckDepth = 16;
        this.typeName = name;
        this.fields = fields.map(_reflection_info__WEBPACK_IMPORTED_MODULE_0__.normalizeFieldInfo);
        this.options = options !== null && options !== void 0 ? options : {};
        this.messagePrototype = Object.create(null, Object.assign(Object.assign({}, baseDescriptors), { [_message_type_contract__WEBPACK_IMPORTED_MODULE_1__.MESSAGE_TYPE]: { value: this } }));
        this.refTypeCheck = new _reflection_type_check__WEBPACK_IMPORTED_MODULE_2__.ReflectionTypeCheck(this);
        this.refJsonReader = new _reflection_json_reader__WEBPACK_IMPORTED_MODULE_3__.ReflectionJsonReader(this);
        this.refJsonWriter = new _reflection_json_writer__WEBPACK_IMPORTED_MODULE_4__.ReflectionJsonWriter(this);
        this.refBinReader = new _reflection_binary_reader__WEBPACK_IMPORTED_MODULE_5__.ReflectionBinaryReader(this);
        this.refBinWriter = new _reflection_binary_writer__WEBPACK_IMPORTED_MODULE_6__.ReflectionBinaryWriter(this);
    }
    create(value) {
        let message = (0,_reflection_create__WEBPACK_IMPORTED_MODULE_7__.reflectionCreate)(this);
        if (value !== undefined) {
            (0,_reflection_merge_partial__WEBPACK_IMPORTED_MODULE_8__.reflectionMergePartial)(this, message, value);
        }
        return message;
    }
    /**
     * Clone the message.
     *
     * Unknown fields are discarded.
     */
    clone(message) {
        let copy = this.create();
        (0,_reflection_merge_partial__WEBPACK_IMPORTED_MODULE_8__.reflectionMergePartial)(this, copy, message);
        return copy;
    }
    /**
     * Determines whether two message of the same type have the same field values.
     * Checks for deep equality, traversing repeated fields, oneof groups, maps
     * and messages recursively.
     * Will also return true if both messages are `undefined`.
     */
    equals(a, b) {
        return (0,_reflection_equals__WEBPACK_IMPORTED_MODULE_9__.reflectionEquals)(this, a, b);
    }
    /**
     * Is the given value assignable to our message type
     * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */
    is(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, false);
    }
    /**
     * Is the given value assignable to our message type,
     * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */
    isAssignable(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, true);
    }
    /**
     * Copy partial data into the target message.
     */
    mergePartial(target, source) {
        (0,_reflection_merge_partial__WEBPACK_IMPORTED_MODULE_8__.reflectionMergePartial)(this, target, source);
    }
    /**
     * Create a new message from binary format.
     */
    fromBinary(data, options) {
        let opt = (0,_binary_reader__WEBPACK_IMPORTED_MODULE_10__.binaryReadOptions)(options);
        return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
    }
    /**
     * Read a new message from a JSON value.
     */
    fromJson(json, options) {
        return this.internalJsonRead(json, (0,_json_format_contract__WEBPACK_IMPORTED_MODULE_11__.jsonReadOptions)(options));
    }
    /**
     * Read a new message from a JSON string.
     * This is equivalent to `T.fromJson(JSON.parse(json))`.
     */
    fromJsonString(json, options) {
        let value = JSON.parse(json);
        return this.fromJson(value, options);
    }
    /**
     * Write the message to canonical JSON value.
     */
    toJson(message, options) {
        return this.internalJsonWrite(message, (0,_json_format_contract__WEBPACK_IMPORTED_MODULE_11__.jsonWriteOptions)(options));
    }
    /**
     * Convert the message to canonical JSON string.
     * This is equivalent to `JSON.stringify(T.toJson(t))`
     */
    toJsonString(message, options) {
        var _a;
        let value = this.toJson(message, options);
        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
    }
    /**
     * Write the message to binary format.
     */
    toBinary(message, options) {
        let opt = (0,_binary_writer__WEBPACK_IMPORTED_MODULE_12__.binaryWriteOptions)(options);
        return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
    }
    /**
     * This is an internal method. If you just want to read a message from
     * JSON, use `fromJson()` or `fromJsonString()`.
     *
     * Reads JSON value and merges the fields into the target
     * according to protobuf rules. If the target is omitted,
     * a new instance is created first.
     */
    internalJsonRead(json, options, target) {
        if (json !== null && typeof json == "object" && !Array.isArray(json)) {
            let message = target !== null && target !== void 0 ? target : this.create();
            this.refJsonReader.read(json, message, options);
            return message;
        }
        throw new Error(`Unable to parse message ${this.typeName} from JSON ${(0,_json_typings__WEBPACK_IMPORTED_MODULE_13__.typeofJsonValue)(json)}.`);
    }
    /**
     * This is an internal method. If you just want to write a message
     * to JSON, use `toJson()` or `toJsonString().
     *
     * Writes JSON value and returns it.
     */
    internalJsonWrite(message, options) {
        return this.refJsonWriter.write(message, options);
    }
    /**
     * This is an internal method. If you just want to write a message
     * in binary format, use `toBinary()`.
     *
     * Serializes the message in binary format and appends it to the given
     * writer. Returns passed writer.
     */
    internalBinaryWrite(message, writer, options) {
        this.refBinWriter.write(message, writer, options);
        return writer;
    }
    /**
     * This is an internal method. If you just want to read a message from
     * binary data, use `fromBinary()`.
     *
     * Reads data from binary format and merges the fields into
     * the target according to protobuf rules. If the target is
     * omitted, a new instance is created first.
     */
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create();
        this.refBinReader.read(reader, message, options, length);
        return message;
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/oneof.js":
/*!************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/oneof.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clearOneofValue: () => (/* binding */ clearOneofValue),
/* harmony export */   getOneofValue: () => (/* binding */ getOneofValue),
/* harmony export */   getSelectedOneofValue: () => (/* binding */ getSelectedOneofValue),
/* harmony export */   isOneofGroup: () => (/* binding */ isOneofGroup),
/* harmony export */   setOneofValue: () => (/* binding */ setOneofValue),
/* harmony export */   setUnknownOneofValue: () => (/* binding */ setUnknownOneofValue)
/* harmony export */ });
/**
 * Is the given value a valid oneof group?
 *
 * We represent protobuf `oneof` as algebraic data types (ADT) in generated
 * code. But when working with messages of unknown type, the ADT does not
 * help us.
 *
 * This type guard checks if the given object adheres to the ADT rules, which
 * are as follows:
 *
 * 1) Must be an object.
 *
 * 2) Must have a "oneofKind" discriminator property.
 *
 * 3) If "oneofKind" is `undefined`, no member field is selected. The object
 * must not have any other properties.
 *
 * 4) If "oneofKind" is a `string`, the member field with this name is
 * selected.
 *
 * 5) If a member field is selected, the object must have a second property
 * with this name. The property must not be `undefined`.
 *
 * 6) No extra properties are allowed. The object has either one property
 * (no selection) or two properties (selection).
 *
 */
function isOneofGroup(any) {
    if (typeof any != 'object' || any === null || !any.hasOwnProperty('oneofKind')) {
        return false;
    }
    switch (typeof any.oneofKind) {
        case "string":
            if (any[any.oneofKind] === undefined)
                return false;
            return Object.keys(any).length == 2;
        case "undefined":
            return Object.keys(any).length == 1;
        default:
            return false;
    }
}
/**
 * Returns the value of the given field in a oneof group.
 */
function getOneofValue(oneof, kind) {
    return oneof[kind];
}
function setOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== undefined) {
        delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = kind;
    if (value !== undefined) {
        oneof[kind] = value;
    }
}
function setUnknownOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== undefined) {
        delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = kind;
    if (value !== undefined && kind !== undefined) {
        oneof[kind] = value;
    }
}
/**
 * Removes the selected field in a oneof group.
 *
 * Note that the recommended way to modify a oneof group is to set
 * a new object:
 *
 * ```ts
 * message.result = { oneofKind: undefined };
 * ```
 */
function clearOneofValue(oneof) {
    if (oneof.oneofKind !== undefined) {
        delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = undefined;
}
/**
 * Returns the selected value of the given oneof group.
 *
 * Not that the recommended way to access a oneof group is to check
 * the "oneofKind" property and let TypeScript narrow down the union
 * type for you:
 *
 * ```ts
 * if (message.result.oneofKind === "error") {
 *   message.result.error; // string
 * }
 * ```
 *
 * In the rare case you just need the value, and do not care about
 * which protobuf field is selected, you can use this function
 * for convenience.
 */
function getSelectedOneofValue(oneof) {
    if (oneof.oneofKind === undefined) {
        return undefined;
    }
    return oneof[oneof.oneofKind];
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PbLong: () => (/* binding */ PbLong),
/* harmony export */   PbULong: () => (/* binding */ PbULong),
/* harmony export */   detectBi: () => (/* binding */ detectBi)
/* harmony export */ });
/* harmony import */ var _goog_varint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./goog-varint */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js");

let BI;
function detectBi() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = globalThis.BigInt !== undefined
        && typeof dv.getBigInt64 === "function"
        && typeof dv.getBigUint64 === "function"
        && typeof dv.setBigInt64 === "function"
        && typeof dv.setBigUint64 === "function";
    BI = ok ? {
        MIN: BigInt("-9223372036854775808"),
        MAX: BigInt("9223372036854775807"),
        UMIN: BigInt("0"),
        UMAX: BigInt("18446744073709551615"),
        C: BigInt,
        V: dv,
    } : undefined;
}
detectBi();
function assertBi(bi) {
    if (!bi)
        throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
// used to validate from(string) input (when bigint is unavailable)
const RE_DECIMAL_STR = /^-?[0-9]+$/;
// constants for binary math
const TWO_PWR_32_DBL = 0x100000000;
const HALF_2_PWR_32 = 0x080000000;
// base class for PbLong and PbULong provides shared code
class SharedPbLong {
    /**
     * Create a new instance with the given bits.
     */
    constructor(lo, hi) {
        this.lo = lo | 0;
        this.hi = hi | 0;
    }
    /**
     * Is this instance equal to 0?
     */
    isZero() {
        return this.lo == 0 && this.hi == 0;
    }
    /**
     * Convert to a native number.
     */
    toNumber() {
        let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);
        if (!Number.isSafeInteger(result))
            throw new Error("cannot convert to safe number");
        return result;
    }
}
/**
 * 64-bit unsigned integer as two 32-bit values.
 * Converts between `string`, `number` and `bigint` representations.
 */
class PbULong extends SharedPbLong {
    /**
     * Create instance from a `string`, `number` or `bigint`.
     */
    static from(value) {
        if (BI)
            // noinspection FallThroughInSwitchStatementJS
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    if (value == "")
                        throw new Error('string is no integer');
                    value = BI.C(value);
                case "number":
                    if (value === 0)
                        return this.ZERO;
                    value = BI.C(value);
                case "bigint":
                    if (!value)
                        return this.ZERO;
                    if (value < BI.UMIN)
                        throw new Error('signed value for ulong');
                    if (value > BI.UMAX)
                        throw new Error('ulong too large');
                    BI.V.setBigUint64(0, value, true);
                    return new PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
            }
        else
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    value = value.trim();
                    if (!RE_DECIMAL_STR.test(value))
                        throw new Error('string is no integer');
                    let [minus, lo, hi] = (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64fromString)(value);
                    if (minus)
                        throw new Error('signed value for ulong');
                    return new PbULong(lo, hi);
                case "number":
                    if (value == 0)
                        return this.ZERO;
                    if (!Number.isSafeInteger(value))
                        throw new Error('number is no integer');
                    if (value < 0)
                        throw new Error('signed value for ulong');
                    return new PbULong(value, value / TWO_PWR_32_DBL);
            }
        throw new Error('unknown value ' + typeof value);
    }
    /**
     * Convert to decimal string.
     */
    toString() {
        return BI ? this.toBigInt().toString() : (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64toString)(this.lo, this.hi);
    }
    /**
     * Convert to native bigint.
     */
    toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigUint64(0, true);
    }
}
/**
 * ulong 0 singleton.
 */
PbULong.ZERO = new PbULong(0, 0);
/**
 * 64-bit signed integer as two 32-bit values.
 * Converts between `string`, `number` and `bigint` representations.
 */
class PbLong extends SharedPbLong {
    /**
     * Create instance from a `string`, `number` or `bigint`.
     */
    static from(value) {
        if (BI)
            // noinspection FallThroughInSwitchStatementJS
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    if (value == "")
                        throw new Error('string is no integer');
                    value = BI.C(value);
                case "number":
                    if (value === 0)
                        return this.ZERO;
                    value = BI.C(value);
                case "bigint":
                    if (!value)
                        return this.ZERO;
                    if (value < BI.MIN)
                        throw new Error('signed long too small');
                    if (value > BI.MAX)
                        throw new Error('signed long too large');
                    BI.V.setBigInt64(0, value, true);
                    return new PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
            }
        else
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    value = value.trim();
                    if (!RE_DECIMAL_STR.test(value))
                        throw new Error('string is no integer');
                    let [minus, lo, hi] = (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64fromString)(value);
                    if (minus) {
                        if (hi > HALF_2_PWR_32 || (hi == HALF_2_PWR_32 && lo != 0))
                            throw new Error('signed long too small');
                    }
                    else if (hi >= HALF_2_PWR_32)
                        throw new Error('signed long too large');
                    let pbl = new PbLong(lo, hi);
                    return minus ? pbl.negate() : pbl;
                case "number":
                    if (value == 0)
                        return this.ZERO;
                    if (!Number.isSafeInteger(value))
                        throw new Error('number is no integer');
                    return value > 0
                        ? new PbLong(value, value / TWO_PWR_32_DBL)
                        : new PbLong(-value, -value / TWO_PWR_32_DBL).negate();
            }
        throw new Error('unknown value ' + typeof value);
    }
    /**
     * Do we have a minus sign?
     */
    isNegative() {
        return (this.hi & HALF_2_PWR_32) !== 0;
    }
    /**
     * Negate two's complement.
     * Invert all the bits and add one to the result.
     */
    negate() {
        let hi = ~this.hi, lo = this.lo;
        if (lo)
            lo = ~lo + 1;
        else
            hi += 1;
        return new PbLong(lo, hi);
    }
    /**
     * Convert to decimal string.
     */
    toString() {
        if (BI)
            return this.toBigInt().toString();
        if (this.isNegative()) {
            let n = this.negate();
            return '-' + (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64toString)(n.lo, n.hi);
        }
        return (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64toString)(this.lo, this.hi);
    }
    /**
     * Convert to native bigint.
     */
    toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigInt64(0, true);
    }
}
/**
 * long 0 singleton.
 */
PbLong.ZERO = new PbLong(0, 0);


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReflectionBinaryReader: () => (/* binding */ ReflectionBinaryReader)
/* harmony export */ });
/* harmony import */ var _binary_format_contract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binary-format-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js");
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reflection-long-convert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js");
/* harmony import */ var _reflection_scalar_default__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reflection-scalar-default */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js");




/**
 * Reads proto3 messages in binary format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/encoding
 */
class ReflectionBinaryReader {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        var _a;
        if (!this.fieldNoToField) {
            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
            this.fieldNoToField = new Map(fieldsInput.map(field => [field.no, field]));
        }
    }
    /**
     * Reads a message from binary format into the target message.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    read(reader, message, options, length) {
        this.prepare();
        const end = length === undefined ? reader.len : reader.pos + length;
        while (reader.pos < end) {
            // read the tag and find the field
            const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
            if (!field) {
                let u = options.readUnknownField;
                if (u == "throw")
                    throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
                let d = reader.skip(wireType);
                if (u !== false)
                    (u === true ? _binary_format_contract__WEBPACK_IMPORTED_MODULE_0__.UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);
                continue;
            }
            // target object for the field we are reading
            let target = message, repeated = field.repeat, localName = field.localName;
            // if field is member of oneof ADT, use ADT as target
            if (field.oneof) {
                target = target[field.oneof];
                // if other oneof member selected, set new ADT
                if (target.oneofKind !== localName)
                    target = message[field.oneof] = {
                        oneofKind: localName
                    };
            }
            // we have handled oneof above, we just have read the value into `target[localName]`
            switch (field.kind) {
                case "scalar":
                case "enum":
                    let T = field.kind == "enum" ? _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32 : field.T;
                    let L = field.kind == "scalar" ? field.L : undefined;
                    if (repeated) {
                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                        if (wireType == _binary_format_contract__WEBPACK_IMPORTED_MODULE_0__.WireType.LengthDelimited && T != _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING && T != _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES) {
                            let e = reader.uint32() + reader.pos;
                            while (reader.pos < e)
                                arr.push(this.scalar(reader, T, L));
                        }
                        else
                            arr.push(this.scalar(reader, T, L));
                    }
                    else
                        target[localName] = this.scalar(reader, T, L);
                    break;
                case "message":
                    if (repeated) {
                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                        let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
                        arr.push(msg);
                    }
                    else
                        target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
                    break;
                case "map":
                    let [mapKey, mapVal] = this.mapEntry(field, reader, options);
                    // safe to assume presence of map object, oneof cannot contain repeated values
                    target[localName][mapKey] = mapVal;
                    break;
            }
        }
    }
    /**
     * Read a map field, expecting key field = 1, value field = 2
     */
    mapEntry(field, reader, options) {
        let length = reader.uint32();
        let end = reader.pos + length;
        let key = undefined; // javascript only allows number or string for object properties
        let val = undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    if (field.K == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL)
                        key = reader.bool().toString();
                    else
                        // long types are read as string, number types are okay as number
                        key = this.scalar(reader, field.K, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.STRING);
                    break;
                case 2:
                    switch (field.V.kind) {
                        case "scalar":
                            val = this.scalar(reader, field.V.T, field.V.L);
                            break;
                        case "enum":
                            val = reader.int32();
                            break;
                        case "message":
                            val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
                            break;
                    }
                    break;
                default:
                    throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
            }
        }
        if (key === undefined) {
            let keyRaw = (0,_reflection_scalar_default__WEBPACK_IMPORTED_MODULE_2__.reflectionScalarDefault)(field.K);
            key = field.K == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL ? keyRaw.toString() : keyRaw;
        }
        if (val === undefined)
            switch (field.V.kind) {
                case "scalar":
                    val = (0,_reflection_scalar_default__WEBPACK_IMPORTED_MODULE_2__.reflectionScalarDefault)(field.V.T, field.V.L);
                    break;
                case "enum":
                    val = 0;
                    break;
                case "message":
                    val = field.V.T().create();
                    break;
            }
        return [key, val];
    }
    scalar(reader, type, longType) {
        switch (type) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32:
                return reader.int32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING:
                return reader.string();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                return reader.bool();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.DOUBLE:
                return reader.double();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT:
                return reader.float();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.int64(), longType);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.uint64(), longType);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.fixed64(), longType);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED32:
                return reader.fixed32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES:
                return reader.bytes();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32:
                return reader.uint32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED32:
                return reader.sfixed32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.sfixed64(), longType);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT32:
                return reader.sint32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.sint64(), longType);
        }
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReflectionBinaryWriter: () => (/* binding */ ReflectionBinaryWriter)
/* harmony export */ });
/* harmony import */ var _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./binary-format-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js");
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js");
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");




/**
 * Writes proto3 messages in binary format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/encoding
 */
class ReflectionBinaryWriter {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        if (!this.fields) {
            const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
            this.fields = fieldsInput.sort((a, b) => a.no - b.no);
        }
    }
    /**
     * Writes the message to binary format.
     */
    write(message, writer, options) {
        this.prepare();
        for (const field of this.fields) {
            let value, // this will be our field value, whether it is member of a oneof or not
            emitDefault, // whether we emit the default value (only true for oneof members)
            repeated = field.repeat, localName = field.localName;
            // handle oneof ADT
            if (field.oneof) {
                const group = message[field.oneof];
                if (group.oneofKind !== localName)
                    continue; // if field is not selected, skip
                value = group[localName];
                emitDefault = true;
            }
            else {
                value = message[localName];
                emitDefault = false;
            }
            // we have handled oneof above. we just have to honor `emitDefault`.
            switch (field.kind) {
                case "scalar":
                case "enum":
                    let T = field.kind == "enum" ? _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32 : field.T;
                    if (repeated) {
                        (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(Array.isArray(value));
                        if (repeated == _reflection_info__WEBPACK_IMPORTED_MODULE_0__.RepeatType.PACKED)
                            this.packed(writer, T, field.no, value);
                        else
                            for (const item of value)
                                this.scalar(writer, T, field.no, item, true);
                    }
                    else if (value === undefined)
                        (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(field.opt);
                    else
                        this.scalar(writer, T, field.no, value, emitDefault || field.opt);
                    break;
                case "message":
                    if (repeated) {
                        (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(Array.isArray(value));
                        for (const item of value)
                            this.message(writer, options, field.T(), field.no, item);
                    }
                    else {
                        this.message(writer, options, field.T(), field.no, value);
                    }
                    break;
                case "map":
                    (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof value == 'object' && value !== null);
                    for (const [key, val] of Object.entries(value))
                        this.mapEntry(writer, options, field, key, val);
                    break;
            }
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);
    }
    mapEntry(writer, options, field, key, value) {
        writer.tag(field.no, _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited);
        writer.fork();
        // javascript only allows number or string for object properties
        // we convert from our representation to the protobuf type
        let keyValue = key;
        switch (field.K) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.UINT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SFIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SINT32:
                keyValue = Number.parseInt(key);
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BOOL:
                (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(key == 'true' || key == 'false');
                keyValue = key == 'true';
                break;
        }
        // write key, expecting key field number = 1
        this.scalar(writer, field.K, 1, keyValue, true);
        // write value, expecting value field number = 2
        switch (field.V.kind) {
            case 'scalar':
                this.scalar(writer, field.V.T, 2, value, true);
                break;
            case 'enum':
                this.scalar(writer, _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32, 2, value, true);
                break;
            case 'message':
                this.message(writer, options, field.V.T(), 2, value);
                break;
        }
        writer.join();
    }
    message(writer, options, handler, fieldNo, value) {
        if (value === undefined)
            return;
        handler.internalBinaryWrite(value, writer.tag(fieldNo, _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).fork(), options);
        writer.join();
    }
    /**
     * Write a single scalar value.
     */
    scalar(writer, type, fieldNo, value, emitDefault) {
        let [wireType, method, isDefault] = this.scalarInfo(type, value);
        if (!isDefault || emitDefault) {
            writer.tag(fieldNo, wireType);
            writer[method](value);
        }
    }
    /**
     * Write an array of scalar values in packed format.
     */
    packed(writer, type, fieldNo, value) {
        if (!value.length)
            return;
        (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(type !== _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BYTES && type !== _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.STRING);
        // write tag
        writer.tag(fieldNo, _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited);
        // begin length-delimited
        writer.fork();
        // write values without tags
        let [, method,] = this.scalarInfo(type);
        for (let i = 0; i < value.length; i++)
            writer[method](value[i]);
        // end length delimited
        writer.join();
    }
    /**
     * Get information for writing a scalar value.
     *
     * Returns tuple:
     * [0]: appropriate WireType
     * [1]: name of the appropriate method of IBinaryWriter
     * [2]: whether the given value is a default value
     *
     * If argument `value` is omitted, [2] is always false.
     */
    scalarInfo(type, value) {
        let t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint;
        let m;
        let i = value === undefined;
        let d = value === 0;
        switch (type) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32:
                m = "int32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.STRING:
                d = i || !value.length;
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited;
                m = "string";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BOOL:
                d = value === false;
                m = "bool";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.UINT32:
                m = "uint32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.DOUBLE:
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit64;
                m = "double";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FLOAT:
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit32;
                m = "float";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbLong.from(value).isZero();
                m = "int64";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.UINT64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbULong.from(value).isZero();
                m = "uint64";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FIXED64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbULong.from(value).isZero();
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit64;
                m = "fixed64";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BYTES:
                d = i || !value.byteLength;
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited;
                m = "bytes";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FIXED32:
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit32;
                m = "fixed32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SFIXED32:
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit32;
                m = "sfixed32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SFIXED64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbLong.from(value).isZero();
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit64;
                m = "sfixed64";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SINT32:
                m = "sint32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SINT64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbLong.from(value).isZero();
                m = "sint64";
                break;
        }
        return [t, m, i || d];
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reflectionCreate: () => (/* binding */ reflectionCreate)
/* harmony export */ });
/* harmony import */ var _reflection_scalar_default__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-scalar-default */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js");
/* harmony import */ var _message_type_contract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./message-type-contract */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js");


/**
 * Creates an instance of the generic message, using the field
 * information.
 */
function reflectionCreate(type) {
    /**
     * This ternary can be removed in the next major version.
     * The `Object.create()` code path utilizes a new `messagePrototype`
     * property on the `IMessageType` which has this same `MESSAGE_TYPE`
     * non-enumerable property on it. Doing it this way means that we only
     * pay the cost of `Object.defineProperty()` once per `IMessageType`
     * class of once per "instance". The falsy code path is only provided
     * for backwards compatibility in cases where the runtime library is
     * updated without also updating the generated code.
     */
    const msg = type.messagePrototype
        ? Object.create(type.messagePrototype)
        : Object.defineProperty({}, _message_type_contract__WEBPACK_IMPORTED_MODULE_0__.MESSAGE_TYPE, { value: type });
    for (let field of type.fields) {
        let name = field.localName;
        if (field.opt)
            continue;
        if (field.oneof)
            msg[field.oneof] = { oneofKind: undefined };
        else if (field.repeat)
            msg[name] = [];
        else
            switch (field.kind) {
                case "scalar":
                    msg[name] = (0,_reflection_scalar_default__WEBPACK_IMPORTED_MODULE_1__.reflectionScalarDefault)(field.T, field.L);
                    break;
                case "enum":
                    // we require 0 to be default value for all enums
                    msg[name] = 0;
                    break;
                case "map":
                    msg[name] = {};
                    break;
            }
    }
    return msg;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reflectionEquals: () => (/* binding */ reflectionEquals)
/* harmony export */ });
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");

/**
 * Determines whether two message of the same type have the same field values.
 * Checks for deep equality, traversing repeated fields, oneof groups, maps
 * and messages recursively.
 * Will also return true if both messages are `undefined`.
 */
function reflectionEquals(info, a, b) {
    if (a === b)
        return true;
    if (!a || !b)
        return false;
    for (let field of info.fields) {
        let localName = field.localName;
        let val_a = field.oneof ? a[field.oneof][localName] : a[localName];
        let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
        switch (field.kind) {
            case "enum":
            case "scalar":
                let t = field.kind == "enum" ? _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32 : field.T;
                if (!(field.repeat
                    ? repeatedPrimitiveEq(t, val_a, val_b)
                    : primitiveEq(t, val_a, val_b)))
                    return false;
                break;
            case "map":
                if (!(field.V.kind == "message"
                    ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b))
                    : repeatedPrimitiveEq(field.V.kind == "enum" ? _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
                    return false;
                break;
            case "message":
                let T = field.T();
                if (!(field.repeat
                    ? repeatedMsgEq(T, val_a, val_b)
                    : T.equals(val_a, val_b)))
                    return false;
                break;
        }
    }
    return true;
}
const objectValues = Object.values;
function primitiveEq(type, a, b) {
    if (a === b)
        return true;
    if (type !== _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BYTES)
        return false;
    let ba = a;
    let bb = b;
    if (ba.length !== bb.length)
        return false;
    for (let i = 0; i < ba.length; i++)
        if (ba[i] != bb[i])
            return false;
    return true;
}
function repeatedPrimitiveEq(type, a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!primitiveEq(type, a[i], b[i]))
            return false;
    return true;
}
function repeatedMsgEq(type, a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!type.equals(a[i], b[i]))
            return false;
    return true;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LongType: () => (/* binding */ LongType),
/* harmony export */   RepeatType: () => (/* binding */ RepeatType),
/* harmony export */   ScalarType: () => (/* binding */ ScalarType),
/* harmony export */   normalizeFieldInfo: () => (/* binding */ normalizeFieldInfo),
/* harmony export */   readFieldOption: () => (/* binding */ readFieldOption),
/* harmony export */   readFieldOptions: () => (/* binding */ readFieldOptions),
/* harmony export */   readMessageOption: () => (/* binding */ readMessageOption)
/* harmony export */ });
/* harmony import */ var _lower_camel_case__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lower-camel-case */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js");

/**
 * Scalar value types. This is a subset of field types declared by protobuf
 * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE
 * are omitted, but the numerical values are identical.
 */
var ScalarType;
(function (ScalarType) {
    // 0 is reserved for errors.
    // Order is weird for historical reasons.
    ScalarType[ScalarType["DOUBLE"] = 1] = "DOUBLE";
    ScalarType[ScalarType["FLOAT"] = 2] = "FLOAT";
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
    // negative values are likely.
    ScalarType[ScalarType["INT64"] = 3] = "INT64";
    ScalarType[ScalarType["UINT64"] = 4] = "UINT64";
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
    // negative values are likely.
    ScalarType[ScalarType["INT32"] = 5] = "INT32";
    ScalarType[ScalarType["FIXED64"] = 6] = "FIXED64";
    ScalarType[ScalarType["FIXED32"] = 7] = "FIXED32";
    ScalarType[ScalarType["BOOL"] = 8] = "BOOL";
    ScalarType[ScalarType["STRING"] = 9] = "STRING";
    // Tag-delimited aggregate.
    // Group type is deprecated and not supported in proto3. However, Proto3
    // implementations should still be able to parse the group wire format and
    // treat group fields as unknown fields.
    // TYPE_GROUP = 10,
    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.
    // New in version 2.
    ScalarType[ScalarType["BYTES"] = 12] = "BYTES";
    ScalarType[ScalarType["UINT32"] = 13] = "UINT32";
    // TYPE_ENUM = 14,
    ScalarType[ScalarType["SFIXED32"] = 15] = "SFIXED32";
    ScalarType[ScalarType["SFIXED64"] = 16] = "SFIXED64";
    ScalarType[ScalarType["SINT32"] = 17] = "SINT32";
    ScalarType[ScalarType["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
/**
 * JavaScript representation of 64 bit integral types. Equivalent to the
 * field option "jstype".
 *
 * By default, protobuf-ts represents 64 bit types as `bigint`.
 *
 * You can change the default behaviour by enabling the plugin parameter
 * `long_type_string`, which will represent 64 bit types as `string`.
 *
 * Alternatively, you can change the behaviour for individual fields
 * with the field option "jstype":
 *
 * ```protobuf
 * uint64 my_field = 1 [jstype = JS_STRING];
 * uint64 other_field = 2 [jstype = JS_NUMBER];
 * ```
 */
var LongType;
(function (LongType) {
    /**
     * Use JavaScript `bigint`.
     *
     * Field option `[jstype = JS_NORMAL]`.
     */
    LongType[LongType["BIGINT"] = 0] = "BIGINT";
    /**
     * Use JavaScript `string`.
     *
     * Field option `[jstype = JS_STRING]`.
     */
    LongType[LongType["STRING"] = 1] = "STRING";
    /**
     * Use JavaScript `number`.
     *
     * Large values will loose precision.
     *
     * Field option `[jstype = JS_NUMBER]`.
     */
    LongType[LongType["NUMBER"] = 2] = "NUMBER";
})(LongType || (LongType = {}));
/**
 * Protobuf 2.1.0 introduced packed repeated fields.
 * Setting the field option `[packed = true]` enables packing.
 *
 * In proto3, all repeated fields are packed by default.
 * Setting the field option `[packed = false]` disables packing.
 *
 * Packed repeated fields are encoded with a single tag,
 * then a length-delimiter, then the element values.
 *
 * Unpacked repeated fields are encoded with a tag and
 * value for each element.
 *
 * `bytes` and `string` cannot be packed.
 */
var RepeatType;
(function (RepeatType) {
    /**
     * The field is not repeated.
     */
    RepeatType[RepeatType["NO"] = 0] = "NO";
    /**
     * The field is repeated and should be packed.
     * Invalid for `bytes` and `string`, they cannot be packed.
     */
    RepeatType[RepeatType["PACKED"] = 1] = "PACKED";
    /**
     * The field is repeated but should not be packed.
     * The only valid repeat type for repeated `bytes` and `string`.
     */
    RepeatType[RepeatType["UNPACKED"] = 2] = "UNPACKED";
})(RepeatType || (RepeatType = {}));
/**
 * Turns PartialFieldInfo into FieldInfo.
 */
function normalizeFieldInfo(field) {
    var _a, _b, _c, _d;
    field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : (0,_lower_camel_case__WEBPACK_IMPORTED_MODULE_0__.lowerCamelCase)(field.name);
    field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : (0,_lower_camel_case__WEBPACK_IMPORTED_MODULE_0__.lowerCamelCase)(field.name);
    field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;
    field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : (field.repeat ? false : field.oneof ? false : field.kind == "message");
    return field;
}
/**
 * Read custom field options from a generated message type.
 *
 * @deprecated use readFieldOption()
 */
function readFieldOptions(messageType, fieldName, extensionName, extensionType) {
    var _a;
    const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
    return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : undefined;
}
function readFieldOption(messageType, fieldName, extensionName, extensionType) {
    var _a;
    const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
    if (!options) {
        return undefined;
    }
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
        return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
function readMessageOption(messageType, extensionName, extensionType) {
    const options = messageType.options;
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
        return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReflectionJsonReader: () => (/* binding */ ReflectionJsonReader)
/* harmony export */ });
/* harmony import */ var _json_typings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./json-typings */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js");
/* harmony import */ var _base64__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base64 */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/base64.js");
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js");
/* harmony import */ var _reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reflection-long-convert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js");






/**
 * Reads proto3 messages in canonical JSON format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/proto3#json
 */
class ReflectionJsonReader {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        var _a;
        if (this.fMap === undefined) {
            this.fMap = {};
            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
            for (const field of fieldsInput) {
                this.fMap[field.name] = field;
                this.fMap[field.jsonName] = field;
                this.fMap[field.localName] = field;
            }
        }
    }
    // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
    assert(condition, fieldName, jsonValue) {
        if (!condition) {
            let what = (0,_json_typings__WEBPACK_IMPORTED_MODULE_0__.typeofJsonValue)(jsonValue);
            if (what == "number" || what == "boolean")
                what = jsonValue.toString();
            throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
        }
    }
    /**
     * Reads a message from canonical JSON format into the target message.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    read(input, message, options) {
        this.prepare();
        const oneofsHandled = [];
        for (const [jsonKey, jsonValue] of Object.entries(input)) {
            const field = this.fMap[jsonKey];
            if (!field) {
                if (!options.ignoreUnknownFields)
                    throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
                continue;
            }
            const localName = field.localName;
            // handle oneof ADT
            let target; // this will be the target for the field value, whether it is member of a oneof or not
            if (field.oneof) {
                if (jsonValue === null && (field.kind !== 'enum' || field.T()[0] !== 'google.protobuf.NullValue')) {
                    continue;
                }
                // since json objects are unordered by specification, it is not possible to take the last of multiple oneofs
                if (oneofsHandled.includes(field.oneof))
                    throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
                oneofsHandled.push(field.oneof);
                target = message[field.oneof] = {
                    oneofKind: localName
                };
            }
            else {
                target = message;
            }
            // we have handled oneof above. we just have read the value into `target`.
            if (field.kind == 'map') {
                if (jsonValue === null) {
                    continue;
                }
                // check input
                this.assert((0,_json_typings__WEBPACK_IMPORTED_MODULE_0__.isJsonObject)(jsonValue), field.name, jsonValue);
                // our target to put map entries into
                const fieldObj = target[localName];
                // read entries
                for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
                    this.assert(jsonObjValue !== null, field.name + " map value", null);
                    // read value
                    let val;
                    switch (field.V.kind) {
                        case "message":
                            val = field.V.T().internalJsonRead(jsonObjValue, options);
                            break;
                        case "enum":
                            val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
                            if (val === false)
                                continue;
                            break;
                        case "scalar":
                            val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
                            break;
                    }
                    this.assert(val !== undefined, field.name + " map value", jsonObjValue);
                    // read key
                    let key = jsonObjKey;
                    if (field.K == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL)
                        key = key == "true" ? true : key == "false" ? false : key;
                    key = this.scalar(key, field.K, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.STRING, field.name).toString();
                    fieldObj[key] = val;
                }
            }
            else if (field.repeat) {
                if (jsonValue === null)
                    continue;
                // check input
                this.assert(Array.isArray(jsonValue), field.name, jsonValue);
                // our target to put array entries into
                const fieldArr = target[localName];
                // read array entries
                for (const jsonItem of jsonValue) {
                    this.assert(jsonItem !== null, field.name, null);
                    let val;
                    switch (field.kind) {
                        case "message":
                            val = field.T().internalJsonRead(jsonItem, options);
                            break;
                        case "enum":
                            val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
                            if (val === false)
                                continue;
                            break;
                        case "scalar":
                            val = this.scalar(jsonItem, field.T, field.L, field.name);
                            break;
                    }
                    this.assert(val !== undefined, field.name, jsonValue);
                    fieldArr.push(val);
                }
            }
            else {
                switch (field.kind) {
                    case "message":
                        if (jsonValue === null && field.T().typeName != 'google.protobuf.Value') {
                            this.assert(field.oneof === undefined, field.name + " (oneof member)", null);
                            continue;
                        }
                        target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
                        break;
                    case "enum":
                        if (jsonValue === null)
                            continue;
                        let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
                        if (val === false)
                            continue;
                        target[localName] = val;
                        break;
                    case "scalar":
                        if (jsonValue === null)
                            continue;
                        target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
                        break;
                }
            }
        }
    }
    /**
     * Returns `false` for unrecognized string representations.
     *
     * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
     */
    enum(type, json, fieldName, ignoreUnknownFields) {
        if (type[0] == 'google.protobuf.NullValue')
            (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assert)(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
        if (json === null)
            // we require 0 to be default value for all enums
            return 0;
        switch (typeof json) {
            case "number":
                (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assert)(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
                return json;
            case "string":
                let localEnumName = json;
                if (type[2] && json.substring(0, type[2].length) === type[2])
                    // lookup without the shared prefix
                    localEnumName = json.substring(type[2].length);
                let enumNumber = type[1][localEnumName];
                if (typeof enumNumber === 'undefined' && ignoreUnknownFields) {
                    return false;
                }
                (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
                return enumNumber;
        }
        (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assert)(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
    }
    scalar(json, type, longType, fieldName) {
        let e;
        try {
            switch (type) {
                // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
                // Either numbers or strings are accepted. Exponent notation is also accepted.
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.DOUBLE:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT:
                    if (json === null)
                        return .0;
                    if (json === "NaN")
                        return Number.NaN;
                    if (json === "Infinity")
                        return Number.POSITIVE_INFINITY;
                    if (json === "-Infinity")
                        return Number.NEGATIVE_INFINITY;
                    if (json === "") {
                        e = "empty string";
                        break;
                    }
                    if (typeof json == "string" && json.trim().length !== json.length) {
                        e = "extra whitespace";
                        break;
                    }
                    if (typeof json != "string" && typeof json != "number") {
                        break;
                    }
                    let float = Number(json);
                    if (Number.isNaN(float)) {
                        e = "not a number";
                        break;
                    }
                    if (!Number.isFinite(float)) {
                        // infinity and -infinity are handled by string representation above, so this is an error
                        e = "too large or small";
                        break;
                    }
                    if (type == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT)
                        (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assertFloat32)(float);
                    return float;
                // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED32:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED32:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT32:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32:
                    if (json === null)
                        return 0;
                    let int32;
                    if (typeof json == "number")
                        int32 = json;
                    else if (json === "")
                        e = "empty string";
                    else if (typeof json == "string") {
                        if (json.trim().length !== json.length)
                            e = "extra whitespace";
                        else
                            int32 = Number(json);
                    }
                    if (int32 === undefined)
                        break;
                    if (type == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32)
                        (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assertUInt32)(int32);
                    else
                        (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assertInt32)(int32);
                    return int32;
                // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT64:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED64:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT64:
                    if (json === null)
                        return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_4__.PbLong.ZERO, longType);
                    if (typeof json != "number" && typeof json != "string")
                        break;
                    return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_4__.PbLong.from(json), longType);
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED64:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT64:
                    if (json === null)
                        return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_4__.PbULong.ZERO, longType);
                    if (typeof json != "number" && typeof json != "string")
                        break;
                    return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_4__.PbULong.from(json), longType);
                // bool:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                    if (json === null)
                        return false;
                    if (typeof json !== "boolean")
                        break;
                    return json;
                // string:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING:
                    if (json === null)
                        return "";
                    if (typeof json !== "string") {
                        e = "extra whitespace";
                        break;
                    }
                    try {
                        encodeURIComponent(json);
                    }
                    catch (e) {
                        e = "invalid UTF8";
                        break;
                    }
                    return json;
                // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
                // Either standard or URL-safe base64 encoding with/without paddings are accepted.
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES:
                    if (json === null || json === "")
                        return new Uint8Array(0);
                    if (typeof json !== 'string')
                        break;
                    return (0,_base64__WEBPACK_IMPORTED_MODULE_5__.base64decode)(json);
            }
        }
        catch (error) {
            e = error.message;
        }
        this.assert(false, fieldName + (e ? " - " + e : ""), json);
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReflectionJsonWriter: () => (/* binding */ ReflectionJsonWriter)
/* harmony export */ });
/* harmony import */ var _base64__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base64 */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/base64.js");
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js");




/**
 * Writes proto3 messages in canonical JSON format using reflection
 * information.
 *
 * https://developers.google.com/protocol-buffers/docs/proto3#json
 */
class ReflectionJsonWriter {
    constructor(info) {
        var _a;
        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
    }
    /**
     * Converts the message to a JSON object, based on the field descriptors.
     */
    write(message, options) {
        const json = {}, source = message;
        for (const field of this.fields) {
            // field is not part of a oneof, simply write as is
            if (!field.oneof) {
                let jsonValue = this.field(field, source[field.localName], options);
                if (jsonValue !== undefined)
                    json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
                continue;
            }
            // field is part of a oneof
            const group = source[field.oneof];
            if (group.oneofKind !== field.localName)
                continue; // not selected, skip
            const opt = field.kind == 'scalar' || field.kind == 'enum'
                ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
            let jsonValue = this.field(field, group[field.localName], opt);
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(jsonValue !== undefined);
            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
        }
        return json;
    }
    field(field, value, options) {
        let jsonValue = undefined;
        if (field.kind == 'map') {
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == "object" && value !== null);
            const jsonObj = {};
            switch (field.V.kind) {
                case "scalar":
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        const val = this.scalar(field.V.T, entryValue, field.name, false, true);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
                case "message":
                    const messageType = field.V.T();
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        const val = this.message(messageType, entryValue, field.name, options);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
                case "enum":
                    const enumInfo = field.V.T();
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(entryValue === undefined || typeof entryValue == 'number');
                        const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
            }
            if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
                jsonValue = jsonObj;
        }
        else if (field.repeat) {
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(Array.isArray(value));
            const jsonArr = [];
            switch (field.kind) {
                case "scalar":
                    for (let i = 0; i < value.length; i++) {
                        const val = this.scalar(field.T, value[i], field.name, field.opt, true);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
                case "enum":
                    const enumInfo = field.T();
                    for (let i = 0; i < value.length; i++) {
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(value[i] === undefined || typeof value[i] == 'number');
                        const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
                case "message":
                    const messageType = field.T();
                    for (let i = 0; i < value.length; i++) {
                        const val = this.message(messageType, value[i], field.name, options);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
            }
            // add converted array to json output
            if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
                jsonValue = jsonArr;
        }
        else {
            switch (field.kind) {
                case "scalar":
                    jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
                    break;
                case "enum":
                    jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
                    break;
                case "message":
                    jsonValue = this.message(field.T(), value, field.name, options);
                    break;
            }
        }
        return jsonValue;
    }
    /**
     * Returns `null` as the default for google.protobuf.NullValue.
     */
    enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
        if (type[0] == 'google.protobuf.NullValue')
            return !emitDefaultValues && !optional ? undefined : null;
        if (value === undefined) {
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(optional);
            return undefined;
        }
        if (value === 0 && !emitDefaultValues && !optional)
            // we require 0 to be default value for all enums
            return undefined;
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'number');
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(Number.isInteger(value));
        if (enumAsInteger || !type[1].hasOwnProperty(value))
            // if we don't now the enum value, just return the number
            return value;
        if (type[2])
            // restore the dropped prefix
            return type[2] + type[1][value];
        return type[1][value];
    }
    message(type, value, fieldName, options) {
        if (value === undefined)
            return options.emitDefaultValues ? null : undefined;
        return type.internalJsonWrite(value, options);
    }
    scalar(type, value, fieldName, optional, emitDefaultValues) {
        if (value === undefined) {
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(optional);
            return undefined;
        }
        const ed = emitDefaultValues || optional;
        // noinspection FallThroughInSwitchStatementJS
        switch (type) {
            // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT32:
                if (value === 0)
                    return ed ? 0 : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertInt32)(value);
                return value;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32:
                if (value === 0)
                    return ed ? 0 : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertUInt32)(value);
                return value;
            // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
            // Either numbers or strings are accepted. Exponent notation is also accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT:
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertFloat32)(value);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.DOUBLE:
                if (value === 0)
                    return ed ? 0 : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'number');
                if (Number.isNaN(value))
                    return 'NaN';
                if (value === Number.POSITIVE_INFINITY)
                    return 'Infinity';
                if (value === Number.NEGATIVE_INFINITY)
                    return '-Infinity';
                return value;
            // string:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING:
                if (value === "")
                    return ed ? '' : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'string');
                return value;
            // bool:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                if (value === false)
                    return ed ? false : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'boolean');
                return value;
            // JSON value will be a decimal string. Either numbers or strings are accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED64:
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                let ulong = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong.from(value);
                if (ulong.isZero() && !ed)
                    return undefined;
                return ulong.toString();
            // JSON value will be a decimal string. Either numbers or strings are accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT64:
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.from(value);
                if (long.isZero() && !ed)
                    return undefined;
                return long.toString();
            // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
            // Either standard or URL-safe base64 encoding with/without paddings are accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES:
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(value instanceof Uint8Array);
                if (!value.byteLength)
                    return ed ? "" : undefined;
                return (0,_base64__WEBPACK_IMPORTED_MODULE_3__.base64encode)(value);
        }
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reflectionLongConvert: () => (/* binding */ reflectionLongConvert)
/* harmony export */ });
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");

/**
 * Utility method to convert a PbLong or PbUlong to a JavaScript
 * representation during runtime.
 *
 * Works with generated field information, `undefined` is equivalent
 * to `STRING`.
 */
function reflectionLongConvert(long, type) {
    switch (type) {
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.LongType.BIGINT:
            return long.toBigInt();
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.LongType.NUMBER:
            return long.toNumber();
        default:
            // case undefined:
            // case LongType.STRING:
            return long.toString();
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reflectionMergePartial: () => (/* binding */ reflectionMergePartial)
/* harmony export */ });
/**
 * Copy partial data into the target message.
 *
 * If a singular scalar or enum field is present in the source, it
 * replaces the field in the target.
 *
 * If a singular message field is present in the source, it is merged
 * with the target field by calling mergePartial() of the responsible
 * message type.
 *
 * If a repeated field is present in the source, its values replace
 * all values in the target array, removing extraneous values.
 * Repeated message fields are copied, not merged.
 *
 * If a map field is present in the source, entries are added to the
 * target map, replacing entries with the same key. Entries that only
 * exist in the target remain. Entries with message values are copied,
 * not merged.
 *
 * Note that this function differs from protobuf merge semantics,
 * which appends repeated fields.
 */
function reflectionMergePartial(info, target, source) {
    let fieldValue, // the field value we are working with
    input = source, output; // where we want our field value to go
    for (let field of info.fields) {
        let name = field.localName;
        if (field.oneof) {
            const group = input[field.oneof]; // this is the oneof`s group in the source
            if ((group === null || group === void 0 ? void 0 : group.oneofKind) == undefined) { // the user is free to omit
                continue; // we skip this field, and all other members too
            }
            fieldValue = group[name]; // our value comes from the the oneof group of the source
            output = target[field.oneof]; // and our output is the oneof group of the target
            output.oneofKind = group.oneofKind; // always update discriminator
            if (fieldValue == undefined) {
                delete output[name]; // remove any existing value
                continue; // skip further work on field
            }
        }
        else {
            fieldValue = input[name]; // we are using the source directly
            output = target; // we want our field value to go directly into the target
            if (fieldValue == undefined) {
                continue; // skip further work on field, existing value is used as is
            }
        }
        if (field.repeat)
            output[name].length = fieldValue.length; // resize target array to match source array
        // now we just work with `fieldValue` and `output` to merge the value
        switch (field.kind) {
            case "scalar":
            case "enum":
                if (field.repeat)
                    for (let i = 0; i < fieldValue.length; i++)
                        output[name][i] = fieldValue[i]; // not a reference type
                else
                    output[name] = fieldValue; // not a reference type
                break;
            case "message":
                let T = field.T();
                if (field.repeat)
                    for (let i = 0; i < fieldValue.length; i++)
                        output[name][i] = T.create(fieldValue[i]);
                else if (output[name] === undefined)
                    output[name] = T.create(fieldValue); // nothing to merge with
                else
                    T.mergePartial(output[name], fieldValue);
                break;
            case "map":
                // Map and repeated fields are simply overwritten, not appended or merged
                switch (field.V.kind) {
                    case "scalar":
                    case "enum":
                        Object.assign(output[name], fieldValue); // elements are not reference types
                        break;
                    case "message":
                        let T = field.V.T();
                        for (let k of Object.keys(fieldValue))
                            output[name][k] = T.create(fieldValue[k]);
                        break;
                }
                break;
        }
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js":
/*!********************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reflectionScalarDefault: () => (/* binding */ reflectionScalarDefault)
/* harmony export */ });
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _reflection_long_convert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-long-convert */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js");
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pb-long */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js");



/**
 * Creates the default value for a scalar type.
 */
function reflectionScalarDefault(type, longType = _reflection_info__WEBPACK_IMPORTED_MODULE_0__.LongType.STRING) {
    switch (type) {
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BOOL:
            return false;
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.UINT64:
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FIXED64:
            return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_1__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong.ZERO, longType);
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT64:
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SFIXED64:
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SINT64:
            return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_1__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.ZERO, longType);
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.DOUBLE:
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FLOAT:
            return 0.0;
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BYTES:
            return new Uint8Array(0);
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.STRING:
            return "";
        default:
            // case ScalarType.INT32:
            // case ScalarType.UINT32:
            // case ScalarType.SINT32:
            // case ScalarType.FIXED32:
            // case ScalarType.SFIXED32:
            return 0;
    }
}


/***/ }),

/***/ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js":
/*!****************************************************************************************!*\
  !*** ../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReflectionTypeCheck: () => (/* binding */ ReflectionTypeCheck)
/* harmony export */ });
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection-info */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js");
/* harmony import */ var _oneof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./oneof */ "../../../node_modules/@protobuf-ts/runtime/build/es2015/oneof.js");


// noinspection JSMethodCanBeStatic
class ReflectionTypeCheck {
    constructor(info) {
        var _a;
        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
    }
    prepare() {
        if (this.data)
            return;
        const req = [], known = [], oneofs = [];
        for (let field of this.fields) {
            if (field.oneof) {
                if (!oneofs.includes(field.oneof)) {
                    oneofs.push(field.oneof);
                    req.push(field.oneof);
                    known.push(field.oneof);
                }
            }
            else {
                known.push(field.localName);
                switch (field.kind) {
                    case "scalar":
                    case "enum":
                        if (!field.opt || field.repeat)
                            req.push(field.localName);
                        break;
                    case "message":
                        if (field.repeat)
                            req.push(field.localName);
                        break;
                    case "map":
                        req.push(field.localName);
                        break;
                }
            }
        }
        this.data = { req, known, oneofs: Object.values(oneofs) };
    }
    /**
     * Is the argument a valid message as specified by the
     * reflection information?
     *
     * Checks all field types recursively. The `depth`
     * specifies how deep into the structure the check will be.
     *
     * With a depth of 0, only the presence of fields
     * is checked.
     *
     * With a depth of 1 or more, the field types are checked.
     *
     * With a depth of 2 or more, the members of map, repeated
     * and message fields are checked.
     *
     * Message fields will be checked recursively with depth - 1.
     *
     * The number of map entries / repeated values being checked
     * is < depth.
     */
    is(message, depth, allowExcessProperties = false) {
        if (depth < 0)
            return true;
        if (message === null || message === undefined || typeof message != 'object')
            return false;
        this.prepare();
        let keys = Object.keys(message), data = this.data;
        // if a required field is missing in arg, this cannot be a T
        if (keys.length < data.req.length || data.req.some(n => !keys.includes(n)))
            return false;
        if (!allowExcessProperties) {
            // if the arg contains a key we dont know, this is not a literal T
            if (keys.some(k => !data.known.includes(k)))
                return false;
        }
        // "With a depth of 0, only the presence and absence of fields is checked."
        // "With a depth of 1 or more, the field types are checked."
        if (depth < 1) {
            return true;
        }
        // check oneof group
        for (const name of data.oneofs) {
            const group = message[name];
            if (!(0,_oneof__WEBPACK_IMPORTED_MODULE_0__.isOneofGroup)(group))
                return false;
            if (group.oneofKind === undefined)
                continue;
            const field = this.fields.find(f => f.localName === group.oneofKind);
            if (!field)
                return false; // we found no field, but have a kind, something is wrong
            if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
                return false;
        }
        // check types
        for (const field of this.fields) {
            if (field.oneof !== undefined)
                continue;
            if (!this.field(message[field.localName], field, allowExcessProperties, depth))
                return false;
        }
        return true;
    }
    field(arg, field, allowExcessProperties, depth) {
        let repeated = field.repeat;
        switch (field.kind) {
            case "scalar":
                if (arg === undefined)
                    return field.opt;
                if (repeated)
                    return this.scalars(arg, field.T, depth, field.L);
                return this.scalar(arg, field.T, field.L);
            case "enum":
                if (arg === undefined)
                    return field.opt;
                if (repeated)
                    return this.scalars(arg, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32, depth);
                return this.scalar(arg, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32);
            case "message":
                if (arg === undefined)
                    return true;
                if (repeated)
                    return this.messages(arg, field.T(), allowExcessProperties, depth);
                return this.message(arg, field.T(), allowExcessProperties, depth);
            case "map":
                if (typeof arg != 'object' || arg === null)
                    return false;
                if (depth < 2)
                    return true;
                if (!this.mapKeys(arg, field.K, depth))
                    return false;
                switch (field.V.kind) {
                    case "scalar":
                        return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
                    case "enum":
                        return this.scalars(Object.values(arg), _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32, depth);
                    case "message":
                        return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
                }
                break;
        }
        return true;
    }
    message(arg, type, allowExcessProperties, depth) {
        if (allowExcessProperties) {
            return type.isAssignable(arg, depth);
        }
        return type.is(arg, depth);
    }
    messages(arg, type, allowExcessProperties, depth) {
        if (!Array.isArray(arg))
            return false;
        if (depth < 2)
            return true;
        if (allowExcessProperties) {
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!type.isAssignable(arg[i], depth - 1))
                    return false;
        }
        else {
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!type.is(arg[i], depth - 1))
                    return false;
        }
        return true;
    }
    scalar(arg, type, longType) {
        let argType = typeof arg;
        switch (type) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT64:
                switch (longType) {
                    case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.BIGINT:
                        return argType == "bigint";
                    case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.NUMBER:
                        return argType == "number" && !isNaN(arg);
                    default:
                        return argType == "string";
                }
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                return argType == 'boolean';
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING:
                return argType == 'string';
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES:
                return arg instanceof Uint8Array;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.DOUBLE:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT:
                return argType == 'number' && !isNaN(arg);
            default:
                // case ScalarType.UINT32:
                // case ScalarType.FIXED32:
                // case ScalarType.INT32:
                // case ScalarType.SINT32:
                // case ScalarType.SFIXED32:
                return argType == 'number' && Number.isInteger(arg);
        }
    }
    scalars(arg, type, depth, longType) {
        if (!Array.isArray(arg))
            return false;
        if (depth < 2)
            return true;
        if (Array.isArray(arg))
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!this.scalar(arg[i], type, longType))
                    return false;
        return true;
    }
    mapKeys(map, type, depth) {
        let keys = Object.keys(map);
        switch (type) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32:
                return this.scalars(keys.slice(0, depth).map(k => parseInt(k)), type, depth);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                return this.scalars(keys.slice(0, depth).map(k => k == 'true' ? true : k == 'false' ? false : k), type, depth);
            default:
                return this.scalars(keys, type, depth, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.STRING);
        }
    }
}


/***/ }),

/***/ "../../../node_modules/hyphenate-style-name/index.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/hyphenate-style-name/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* eslint-disable no-var, prefer-template */
var uppercasePattern = /[A-Z]/g
var msPattern = /^ms-/
var cache = {}

function toHyphenLower(match) {
  return '-' + match.toLowerCase()
}

function hyphenateStyleName(name) {
  if (cache.hasOwnProperty(name)) {
    return cache[name]
  }

  var hName = name.replace(uppercasePattern, toHyphenLower)
  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hyphenateStyleName);


/***/ }),

/***/ "../../../node_modules/is-in-browser/dist/module.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/is-in-browser/dist/module.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   isBrowser: () => (/* binding */ isBrowser)
/* harmony export */ });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isBrowser);


/***/ }),

/***/ "../../../node_modules/jss-plugin-camel-case/dist/jss-plugin-camel-case.esm.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/jss-plugin-camel-case/dist/jss-plugin-camel-case.esm.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var hyphenate_style_name__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hyphenate-style-name */ "../../../node_modules/hyphenate-style-name/index.js");


/**
 * Convert camel cased property names to dash separated.
 */

function convertCase(style) {
  var converted = {};

  for (var prop in style) {
    var key = prop.indexOf('--') === 0 ? prop : (0,hyphenate_style_name__WEBPACK_IMPORTED_MODULE_0__["default"])(prop);
    converted[key] = style[prop];
  }

  if (style.fallbacks) {
    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
  }

  return converted;
}
/**
 * Allow camel cased property names by converting them back to dasherized.
 */


function camelCase() {
  function onProcessStyle(style) {
    if (Array.isArray(style)) {
      // Handle rules like @font-face, which can have multiple styles in an array
      for (var index = 0; index < style.length; index++) {
        style[index] = convertCase(style[index]);
      }

      return style;
    }

    return convertCase(style);
  }

  function onChangeValue(value, prop, rule) {
    if (prop.indexOf('--') === 0) {
      return value;
    }

    var hyphenatedProp = (0,hyphenate_style_name__WEBPACK_IMPORTED_MODULE_0__["default"])(prop); // There was no camel case in place

    if (prop === hyphenatedProp) return value;
    rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.

    return null;
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (camelCase);


/***/ }),

/***/ "../../../node_modules/jss-plugin-global/dist/jss-plugin-global.esm.js":
/*!*****************************************************************************!*\
  !*** ../../../node_modules/jss-plugin-global/dist/jss-plugin-global.esm.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "../../../node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jss */ "../../../node_modules/jss/dist/jss.esm.js");



var at = '@global';
var atPrefix = '@global ';

var GlobalContainerRule =
/*#__PURE__*/
function () {
  function GlobalContainerRule(key, styles, options) {
    this.type = 'global';
    this.at = at;
    this.isProcessed = false;
    this.key = key;
    this.options = options;
    this.rules = new jss__WEBPACK_IMPORTED_MODULE_1__.RuleList((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      parent: this
    }));

    for (var selector in styles) {
      this.rules.add(selector, styles[selector]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = GlobalContainerRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (rule) this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Replace rule, run plugins.
   */
  ;

  _proto.replaceRule = function replaceRule(name, style, options) {
    var newRule = this.rules.replace(name, style, options);
    if (newRule) this.options.jss.plugins.onProcessRule(newRule);
    return newRule;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    return this.rules.toString(options);
  };

  return GlobalContainerRule;
}();

var GlobalPrefixedRule =
/*#__PURE__*/
function () {
  function GlobalPrefixedRule(key, style, options) {
    this.type = 'global';
    this.at = at;
    this.isProcessed = false;
    this.key = key;
    this.options = options;
    var selector = key.substr(atPrefix.length);
    this.rule = options.jss.createRule(selector, style, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      parent: this
    }));
  }

  var _proto2 = GlobalPrefixedRule.prototype;

  _proto2.toString = function toString(options) {
    return this.rule ? this.rule.toString(options) : '';
  };

  return GlobalPrefixedRule;
}();

var separatorRegExp = /\s*,\s*/g;

function addScope(selector, scope) {
  var parts = selector.split(separatorRegExp);
  var scoped = '';

  for (var i = 0; i < parts.length; i++) {
    scoped += scope + " " + parts[i].trim();
    if (parts[i + 1]) scoped += ', ';
  }

  return scoped;
}

function handleNestedGlobalContainerRule(rule, sheet) {
  var options = rule.options,
      style = rule.style;
  var rules = style ? style[at] : null;
  if (!rules) return;

  for (var name in rules) {
    sheet.addRule(name, rules[name], (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      selector: addScope(name, rule.selector)
    }));
  }

  delete style[at];
}

function handlePrefixedGlobalRule(rule, sheet) {
  var options = rule.options,
      style = rule.style;

  for (var prop in style) {
    if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;
    var selector = addScope(prop.substr(at.length), rule.selector);
    sheet.addRule(selector, style[prop], (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      selector: selector
    }));
    delete style[prop];
  }
}
/**
 * Convert nested rules to separate, remove them from original styles.
 */


function jssGlobal() {
  function onCreateRule(name, styles, options) {
    if (!name) return null;

    if (name === at) {
      return new GlobalContainerRule(name, styles, options);
    }

    if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {
      return new GlobalPrefixedRule(name, styles, options);
    }

    var parent = options.parent;

    if (parent) {
      if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {
        options.scoped = false;
      }
    }

    if (!options.selector && options.scoped === false) {
      options.selector = name;
    }

    return null;
  }

  function onProcessRule(rule, sheet) {
    if (rule.type !== 'style' || !sheet) return;
    handleNestedGlobalContainerRule(rule, sheet);
    handlePrefixedGlobalRule(rule, sheet);
  }

  return {
    onCreateRule: onCreateRule,
    onProcessRule: onProcessRule
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (jssGlobal);


/***/ }),

/***/ "../../../node_modules/jss/dist/jss.esm.js":
/*!*************************************************!*\
  !*** ../../../node_modules/jss/dist/jss.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RuleList: () => (/* binding */ RuleList),
/* harmony export */   SheetsManager: () => (/* binding */ SheetsManager),
/* harmony export */   SheetsRegistry: () => (/* binding */ SheetsRegistry),
/* harmony export */   create: () => (/* binding */ createJss),
/* harmony export */   createGenerateId: () => (/* binding */ createGenerateId),
/* harmony export */   createRule: () => (/* binding */ createRule),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getDynamicStyles: () => (/* binding */ getDynamicStyles),
/* harmony export */   hasCSSTOMSupport: () => (/* binding */ hasCSSTOMSupport),
/* harmony export */   sheets: () => (/* binding */ sheets),
/* harmony export */   toCssValue: () => (/* binding */ toCssValue)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "../../../node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var is_in_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-in-browser */ "../../../node_modules/is-in-browser/dist/module.js");
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tiny-warning */ "../../../node_modules/tiny-warning/dist/tiny-warning.esm.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ "../../../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");








var plainObjectConstrurctor = {}.constructor;
function cloneStyle(style) {
  if (style == null || typeof style !== 'object') return style;
  if (Array.isArray(style)) return style.map(cloneStyle);
  if (style.constructor !== plainObjectConstrurctor) return style;
  var newStyle = {};

  for (var name in style) {
    newStyle[name] = cloneStyle(style[name]);
  }

  return newStyle;
}

/**
 * Create a rule instance.
 */

function createRule(name, decl, options) {
  if (name === void 0) {
    name = 'unnamed';
  }

  var jss = options.jss;
  var declCopy = cloneStyle(decl);
  var rule = jss.plugins.onCreateRule(name, declCopy, options);
  if (rule) return rule; // It is an at-rule and it has no instance.

  if (name[0] === '@') {
     true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] Unknown rule " + name) : 0;
  }

  return null;
}

var join = function join(value, by) {
  var result = '';

  for (var i = 0; i < value.length; i++) {
    // Remove !important from the value, it will be readded later.
    if (value[i] === '!important') break;
    if (result) result += by;
    result += value[i];
  }

  return result;
};
/**
 * Converts JSS array value to a CSS string.
 *
 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
 * `border: ['1px', '2px']` > `border: 1px, 2px;`
 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
 * `color: ['red', !important]` > `color: red !important;`
 */


var toCssValue = function toCssValue(value) {
  if (!Array.isArray(value)) return value;
  var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.

  if (Array.isArray(value[0])) {
    for (var i = 0; i < value.length; i++) {
      if (value[i] === '!important') break;
      if (cssValue) cssValue += ', ';
      cssValue += join(value[i], ' ');
    }
  } else cssValue = join(value, ', '); // Add !important, because it was ignored.


  if (value[value.length - 1] === '!important') {
    cssValue += ' !important';
  }

  return cssValue;
};

function getWhitespaceSymbols(options) {
  if (options && options.format === false) {
    return {
      linebreak: '',
      space: ''
    };
  }

  return {
    linebreak: '\n',
    space: ' '
  };
}

/**
 * Indent a string.
 * http://jsperf.com/array-join-vs-for
 */

function indentStr(str, indent) {
  var result = '';

  for (var index = 0; index < indent; index++) {
    result += '  ';
  }

  return result + str;
}
/**
 * Converts a Rule to CSS string.
 */


function toCss(selector, style, options) {
  if (options === void 0) {
    options = {};
  }

  var result = '';
  if (!style) return result;
  var _options = options,
      _options$indent = _options.indent,
      indent = _options$indent === void 0 ? 0 : _options$indent;
  var fallbacks = style.fallbacks;

  if (options.format === false) {
    indent = -Infinity;
  }

  var _getWhitespaceSymbols = getWhitespaceSymbols(options),
      linebreak = _getWhitespaceSymbols.linebreak,
      space = _getWhitespaceSymbols.space;

  if (selector) indent++; // Apply fallbacks first.

  if (fallbacks) {
    // Array syntax {fallbacks: [{prop: value}]}
    if (Array.isArray(fallbacks)) {
      for (var index = 0; index < fallbacks.length; index++) {
        var fallback = fallbacks[index];

        for (var prop in fallback) {
          var value = fallback[prop];

          if (value != null) {
            if (result) result += linebreak;
            result += indentStr(prop + ":" + space + toCssValue(value) + ";", indent);
          }
        }
      }
    } else {
      // Object syntax {fallbacks: {prop: value}}
      for (var _prop in fallbacks) {
        var _value = fallbacks[_prop];

        if (_value != null) {
          if (result) result += linebreak;
          result += indentStr(_prop + ":" + space + toCssValue(_value) + ";", indent);
        }
      }
    }
  }

  for (var _prop2 in style) {
    var _value2 = style[_prop2];

    if (_value2 != null && _prop2 !== 'fallbacks') {
      if (result) result += linebreak;
      result += indentStr(_prop2 + ":" + space + toCssValue(_value2) + ";", indent);
    }
  } // Allow empty style in this case, because properties will be added dynamically.


  if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.

  if (!selector) return result;
  indent--;
  if (result) result = "" + linebreak + result + linebreak;
  return indentStr("" + selector + space + "{" + result, indent) + indentStr('}', indent);
}

var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
var nativeEscape = typeof CSS !== 'undefined' && CSS.escape;
var escape = (function (str) {
  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\$1');
});

var BaseStyleRule =
/*#__PURE__*/
function () {
  function BaseStyleRule(key, style, options) {
    this.type = 'style';
    this.isProcessed = false;
    var sheet = options.sheet,
        Renderer = options.Renderer;
    this.key = key;
    this.options = options;
    this.style = style;
    if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();
  }
  /**
   * Get or set a style property.
   */


  var _proto = BaseStyleRule.prototype;

  _proto.prop = function prop(name, value, options) {
    // It's a getter.
    if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.

    var force = options ? options.force : false;
    if (!force && this.style[name] === value) return this;
    var newValue = value;

    if (!options || options.process !== false) {
      newValue = this.options.jss.plugins.onChangeValue(value, name, this);
    }

    var isEmpty = newValue == null || newValue === false;
    var isDefined = name in this.style; // Value is empty and wasn't defined before.

    if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.

    var remove = isEmpty && isDefined;
    if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.

    if (this.renderable && this.renderer) {
      if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);
      return this;
    }

    var sheet = this.options.sheet;

    if (sheet && sheet.attached) {
       true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, '[JSS] Rule is not linked. Missing sheet option "link: true".') : 0;
    }

    return this;
  };

  return BaseStyleRule;
}();
var StyleRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__["default"])(StyleRule, _BaseStyleRule);

  function StyleRule(key, style, options) {
    var _this;

    _this = _BaseStyleRule.call(this, key, style, options) || this;
    var selector = options.selector,
        scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;

    if (selector) {
      _this.selectorText = selector;
    } else if (scoped !== false) {
      _this.id = generateId((0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__["default"])((0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__["default"])(_this)), sheet);
      _this.selectorText = "." + escape(_this.id);
    }

    return _this;
  }
  /**
   * Set selector string.
   * Attention: use this with caution. Most browsers didn't implement
   * selectorText setter, so this may result in rerendering of entire Style Sheet.
   */


  var _proto2 = StyleRule.prototype;

  /**
   * Apply rule to an element inline.
   */
  _proto2.applyTo = function applyTo(renderable) {
    var renderer = this.renderer;

    if (renderer) {
      var json = this.toJSON();

      for (var prop in json) {
        renderer.setProperty(renderable, prop, json[prop]);
      }
    }

    return this;
  }
  /**
   * Returns JSON representation of the rule.
   * Fallbacks are not supported.
   * Useful for inline styles.
   */
  ;

  _proto2.toJSON = function toJSON() {
    var json = {};

    for (var prop in this.style) {
      var value = this.style[prop];
      if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);
    }

    return json;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto2.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.selectorText, this.style, opts);
  };

  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(StyleRule, [{
    key: "selector",
    set: function set(selector) {
      if (selector === this.selectorText) return;
      this.selectorText = selector;
      var renderer = this.renderer,
          renderable = this.renderable;
      if (!renderable || !renderer) return;
      var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.

      if (!hasChanged) {
        renderer.replaceRule(renderable, this);
      }
    }
    /**
     * Get selector string.
     */
    ,
    get: function get() {
      return this.selectorText;
    }
  }]);

  return StyleRule;
}(BaseStyleRule);
var pluginStyleRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    if (key[0] === '@' || options.parent && options.parent.type === 'keyframes') {
      return null;
    }

    return new StyleRule(key, style, options);
  }
};

var defaultToStringOptions = {
  indent: 1,
  children: true
};
var atRegExp = /@([\w-]+)/;
/**
 * Conditional rule for @media, @supports
 */

var ConditionalRule =
/*#__PURE__*/
function () {
  function ConditionalRule(key, styles, options) {
    this.type = 'conditional';
    this.isProcessed = false;
    this.key = key;
    var atMatch = key.match(atRegExp);
    this.at = atMatch ? atMatch[1] : 'unknown'; // Key might contain a unique suffix in case the `name` passed by user was duplicate.

    this.query = options.name || "@" + this.at;
    this.options = options;
    this.rules = new RuleList((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      parent: this
    }));

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = ConditionalRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Replace rule, run plugins.
   */
  ;

  _proto.replaceRule = function replaceRule(name, style, options) {
    var newRule = this.rules.replace(name, style, options);
    if (newRule) this.options.jss.plugins.onProcessRule(newRule);
    return newRule;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions;
    }

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (options.indent == null) options.indent = defaultToStringOptions.indent;
    if (options.children == null) options.children = defaultToStringOptions.children;

    if (options.children === false) {
      return this.query + " {}";
    }

    var children = this.rules.toString(options);
    return children ? this.query + " {" + linebreak + children + linebreak + "}" : '';
  };

  return ConditionalRule;
}();
var keyRegExp = /@container|@media|@supports\s+/;
var pluginConditionalRule = {
  onCreateRule: function onCreateRule(key, styles, options) {
    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;
  }
};

var defaultToStringOptions$1 = {
  indent: 1,
  children: true
};
var nameRegExp = /@keyframes\s+([\w-]+)/;
/**
 * Rule for @keyframes
 */

var KeyframesRule =
/*#__PURE__*/
function () {
  function KeyframesRule(key, frames, options) {
    this.type = 'keyframes';
    this.at = '@keyframes';
    this.isProcessed = false;
    var nameMatch = key.match(nameRegExp);

    if (nameMatch && nameMatch[1]) {
      this.name = nameMatch[1];
    } else {
      this.name = 'noname';
       true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] Bad keyframes name " + key) : 0;
    }

    this.key = this.type + "-" + this.name;
    this.options = options;
    var scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;
    this.id = scoped === false ? this.name : escape(generateId(this, sheet));
    this.rules = new RuleList((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      parent: this
    }));

    for (var name in frames) {
      this.rules.add(name, frames[name], (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
        parent: this
      }));
    }

    this.rules.process();
  }
  /**
   * Generates a CSS string.
   */


  var _proto = KeyframesRule.prototype;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions$1;
    }

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (options.indent == null) options.indent = defaultToStringOptions$1.indent;
    if (options.children == null) options.children = defaultToStringOptions$1.children;

    if (options.children === false) {
      return this.at + " " + this.id + " {}";
    }

    var children = this.rules.toString(options);
    if (children) children = "" + linebreak + children + linebreak;
    return this.at + " " + this.id + " {" + children + "}";
  };

  return KeyframesRule;
}();
var keyRegExp$1 = /@keyframes\s+/;
var refRegExp = /\$([\w-]+)/g;

var findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {
  if (typeof val === 'string') {
    return val.replace(refRegExp, function (match, name) {
      if (name in keyframes) {
        return keyframes[name];
      }

       true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] Referenced keyframes rule \"" + name + "\" is not defined.") : 0;
      return match;
    });
  }

  return val;
};
/**
 * Replace the reference for a animation name.
 */


var replaceRef = function replaceRef(style, prop, keyframes) {
  var value = style[prop];
  var refKeyframe = findReferencedKeyframe(value, keyframes);

  if (refKeyframe !== value) {
    style[prop] = refKeyframe;
  }
};

var pluginKeyframesRule = {
  onCreateRule: function onCreateRule(key, frames, options) {
    return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;
  },
  // Animation name ref replacer.
  onProcessStyle: function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style' || !sheet) return style;
    if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);
    if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);
    return style;
  },
  onChangeValue: function onChangeValue(val, prop, rule) {
    var sheet = rule.options.sheet;

    if (!sheet) {
      return val;
    }

    switch (prop) {
      case 'animation':
        return findReferencedKeyframe(val, sheet.keyframes);

      case 'animation-name':
        return findReferencedKeyframe(val, sheet.keyframes);

      default:
        return val;
    }
  }
};

var KeyframeRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__["default"])(KeyframeRule, _BaseStyleRule);

  function KeyframeRule() {
    return _BaseStyleRule.apply(this, arguments) || this;
  }

  var _proto = KeyframeRule.prototype;

  /**
   * Generates a CSS string.
   */
  _proto.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.key, this.style, opts);
  };

  return KeyframeRule;
}(BaseStyleRule);
var pluginKeyframeRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    if (options.parent && options.parent.type === 'keyframes') {
      return new KeyframeRule(key, style, options);
    }

    return null;
  }
};

var FontFaceRule =
/*#__PURE__*/
function () {
  function FontFaceRule(key, style, options) {
    this.type = 'font-face';
    this.at = '@font-face';
    this.isProcessed = false;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = FontFaceRule.prototype;

  _proto.toString = function toString(options) {
    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (Array.isArray(this.style)) {
      var str = '';

      for (var index = 0; index < this.style.length; index++) {
        str += toCss(this.at, this.style[index]);
        if (this.style[index + 1]) str += linebreak;
      }

      return str;
    }

    return toCss(this.at, this.style, options);
  };

  return FontFaceRule;
}();
var keyRegExp$2 = /@font-face/;
var pluginFontFaceRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;
  }
};

var ViewportRule =
/*#__PURE__*/
function () {
  function ViewportRule(key, style, options) {
    this.type = 'viewport';
    this.at = '@viewport';
    this.isProcessed = false;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = ViewportRule.prototype;

  _proto.toString = function toString(options) {
    return toCss(this.key, this.style, options);
  };

  return ViewportRule;
}();
var pluginViewportRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;
  }
};

var SimpleRule =
/*#__PURE__*/
function () {
  function SimpleRule(key, value, options) {
    this.type = 'simple';
    this.isProcessed = false;
    this.key = key;
    this.value = value;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */
  // eslint-disable-next-line no-unused-vars


  var _proto = SimpleRule.prototype;

  _proto.toString = function toString(options) {
    if (Array.isArray(this.value)) {
      var str = '';

      for (var index = 0; index < this.value.length; index++) {
        str += this.key + " " + this.value[index] + ";";
        if (this.value[index + 1]) str += '\n';
      }

      return str;
    }

    return this.key + " " + this.value + ";";
  };

  return SimpleRule;
}();
var keysMap = {
  '@charset': true,
  '@import': true,
  '@namespace': true
};
var pluginSimpleRule = {
  onCreateRule: function onCreateRule(key, value, options) {
    return key in keysMap ? new SimpleRule(key, value, options) : null;
  }
};

var plugins = [pluginStyleRule, pluginConditionalRule, pluginKeyframesRule, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];

var defaultUpdateOptions = {
  process: true
};
var forceUpdateOptions = {
  force: true,
  process: true
  /**
   * Contains rules objects and allows adding/removing etc.
   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
   */

};

var RuleList =
/*#__PURE__*/
function () {
  // Rules registry for access by .get() method.
  // It contains the same rule registered by name and by selector.
  // Original styles object.
  // Used to ensure correct rules order.
  function RuleList(options) {
    this.map = {};
    this.raw = {};
    this.index = [];
    this.counter = 0;
    this.options = options;
    this.classes = options.classes;
    this.keyframes = options.keyframes;
  }
  /**
   * Create and register rule.
   *
   * Will not render after Style Sheet was rendered the first time.
   */


  var _proto = RuleList.prototype;

  _proto.add = function add(name, decl, ruleOptions) {
    var _this$options = this.options,
        parent = _this$options.parent,
        sheet = _this$options.sheet,
        jss = _this$options.jss,
        Renderer = _this$options.Renderer,
        generateId = _this$options.generateId,
        scoped = _this$options.scoped;

    var options = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
      classes: this.classes,
      parent: parent,
      sheet: sheet,
      jss: jss,
      Renderer: Renderer,
      generateId: generateId,
      scoped: scoped,
      name: name,
      keyframes: this.keyframes,
      selector: undefined
    }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
    // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
    // we need to make the key unique within this RuleList instance scope.


    var key = name;

    if (name in this.raw) {
      key = name + "-d" + this.counter++;
    } // We need to save the original decl before creating the rule
    // because cache plugin needs to use it as a key to return a cached rule.


    this.raw[key] = decl;

    if (key in this.classes) {
      // E.g. rules inside of @media container
      options.selector = "." + escape(this.classes[key]);
    }

    var rule = createRule(key, decl, options);
    if (!rule) return null;
    this.register(rule);
    var index = options.index === undefined ? this.index.length : options.index;
    this.index.splice(index, 0, rule);
    return rule;
  }
  /**
   * Replace rule.
   * Create a new rule and remove old one instead of overwriting
   * because we want to invoke onCreateRule hook to make plugins work.
   */
  ;

  _proto.replace = function replace(name, decl, ruleOptions) {
    var oldRule = this.get(name);
    var oldIndex = this.index.indexOf(oldRule);

    if (oldRule) {
      this.remove(oldRule);
    }

    var options = ruleOptions;
    if (oldIndex !== -1) options = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, ruleOptions, {
      index: oldIndex
    });
    return this.add(name, decl, options);
  }
  /**
   * Get a rule by name or selector.
   */
  ;

  _proto.get = function get(nameOrSelector) {
    return this.map[nameOrSelector];
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.remove = function remove(rule) {
    this.unregister(rule);
    delete this.raw[rule.key];
    this.index.splice(this.index.indexOf(rule), 1);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.index.indexOf(rule);
  }
  /**
   * Run `onProcessRule()` plugins on every rule.
   */
  ;

  _proto.process = function process() {
    var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
    // we end up with very hard-to-track-down side effects.

    this.index.slice(0).forEach(plugins.onProcessRule, plugins);
  }
  /**
   * Register a rule in `.map`, `.classes` and `.keyframes` maps.
   */
  ;

  _proto.register = function register(rule) {
    this.map[rule.key] = rule;

    if (rule instanceof StyleRule) {
      this.map[rule.selector] = rule;
      if (rule.id) this.classes[rule.key] = rule.id;
    } else if (rule instanceof KeyframesRule && this.keyframes) {
      this.keyframes[rule.name] = rule.id;
    }
  }
  /**
   * Unregister a rule.
   */
  ;

  _proto.unregister = function unregister(rule) {
    delete this.map[rule.key];

    if (rule instanceof StyleRule) {
      delete this.map[rule.selector];
      delete this.classes[rule.key];
    } else if (rule instanceof KeyframesRule) {
      delete this.keyframes[rule.name];
    }
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var name;
    var data;
    var options;

    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
      name = arguments.length <= 0 ? undefined : arguments[0];
      data = arguments.length <= 1 ? undefined : arguments[1];
      options = arguments.length <= 2 ? undefined : arguments[2];
    } else {
      data = arguments.length <= 0 ? undefined : arguments[0];
      options = arguments.length <= 1 ? undefined : arguments[1];
      name = null;
    }

    if (name) {
      this.updateOne(this.get(name), data, options);
    } else {
      for (var index = 0; index < this.index.length; index++) {
        this.updateOne(this.index[index], data, options);
      }
    }
  }
  /**
   * Execute plugins, update rule props.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    if (options === void 0) {
      options = defaultUpdateOptions;
    }

    var _this$options2 = this.options,
        plugins = _this$options2.jss.plugins,
        sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.

    if (rule.rules instanceof RuleList) {
      rule.rules.update(data, options);
      return;
    }

    var style = rule.style;
    plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.

    if (options.process && style && style !== rule.style) {
      // We need to run the plugins in case new `style` relies on syntax plugins.
      plugins.onProcessStyle(rule.style, rule, sheet); // Update and add props.

      for (var prop in rule.style) {
        var nextValue = rule.style[prop];
        var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (nextValue !== prevValue) {
          rule.prop(prop, nextValue, forceUpdateOptions);
        }
      } // Remove props.


      for (var _prop in style) {
        var _nextValue = rule.style[_prop];
        var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (_nextValue == null && _nextValue !== _prevValue) {
          rule.prop(_prop, null, forceUpdateOptions);
        }
      }
    }
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    var str = '';
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    for (var index = 0; index < this.index.length; index++) {
      var rule = this.index[index];
      var css = rule.toString(options); // No need to render an empty rule.

      if (!css && !link) continue;
      if (str) str += linebreak;
      str += css;
    }

    return str;
  };

  return RuleList;
}();

var StyleSheet =
/*#__PURE__*/
function () {
  function StyleSheet(styles, options) {
    this.attached = false;
    this.deployed = false;
    this.classes = {};
    this.keyframes = {};
    this.options = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    });

    if (options.Renderer) {
      this.renderer = new options.Renderer(this);
    }

    this.rules = new RuleList(this.options);

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Attach renderable to the render tree.
   */


  var _proto = StyleSheet.prototype;

  _proto.attach = function attach() {
    if (this.attached) return this;
    if (this.renderer) this.renderer.attach();
    this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.

    if (!this.deployed) this.deploy();
    return this;
  }
  /**
   * Remove renderable from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.attached) return this;
    if (this.renderer) this.renderer.detach();
    this.attached = false;
    return this;
  }
  /**
   * Add a rule to the current stylesheet.
   * Will insert a rule also after the stylesheet has been rendered first time.
   */
  ;

  _proto.addRule = function addRule(name, decl, options) {
    var queue = this.queue; // Plugins can create rules.
    // In order to preserve the right order, we need to queue all `.addRule` calls,
    // which happen after the first `rules.add()` call.

    if (this.attached && !queue) this.queue = [];
    var rule = this.rules.add(name, decl, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);

    if (this.attached) {
      if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
      // It will be inserted all together when .attach is called.

      if (queue) queue.push(rule);else {
        this.insertRule(rule);

        if (this.queue) {
          this.queue.forEach(this.insertRule, this);
          this.queue = undefined;
        }
      }
      return rule;
    } // We can't add rules to a detached style node.
    // We will redeploy the sheet once user will attach it.


    this.deployed = false;
    return rule;
  }
  /**
   * Replace a rule in the current stylesheet.
   */
  ;

  _proto.replaceRule = function replaceRule(nameOrSelector, decl, options) {
    var oldRule = this.rules.get(nameOrSelector);
    if (!oldRule) return this.addRule(nameOrSelector, decl, options);
    var newRule = this.rules.replace(nameOrSelector, decl, options);

    if (newRule) {
      this.options.jss.plugins.onProcessRule(newRule);
    }

    if (this.attached) {
      if (!this.deployed) return newRule; // Don't replace / delete rule directly if there is no stringified version yet.
      // It will be inserted all together when .attach is called.

      if (this.renderer) {
        if (!newRule) {
          this.renderer.deleteRule(oldRule);
        } else if (oldRule.renderable) {
          this.renderer.replaceRule(oldRule.renderable, newRule);
        }
      }

      return newRule;
    } // We can't replace rules to a detached style node.
    // We will redeploy the sheet once user will attach it.


    this.deployed = false;
    return newRule;
  }
  /**
   * Insert rule into the StyleSheet
   */
  ;

  _proto.insertRule = function insertRule(rule) {
    if (this.renderer) {
      this.renderer.insertRule(rule);
    }
  }
  /**
   * Create and add rules.
   * Will render also after Style Sheet was rendered the first time.
   */
  ;

  _proto.addRules = function addRules(styles, options) {
    var added = [];

    for (var name in styles) {
      var rule = this.addRule(name, styles[name], options);
      if (rule) added.push(rule);
    }

    return added;
  }
  /**
   * Get a rule by name or selector.
   */
  ;

  _proto.getRule = function getRule(nameOrSelector) {
    return this.rules.get(nameOrSelector);
  }
  /**
   * Delete a rule by name.
   * Returns `true`: if rule has been deleted from the DOM.
   */
  ;

  _proto.deleteRule = function deleteRule(name) {
    var rule = typeof name === 'object' ? name : this.rules.get(name);

    if (!rule || // Style sheet was created without link: true and attached, in this case we
    // won't be able to remove the CSS rule from the DOM.
    this.attached && !rule.renderable) {
      return false;
    }

    this.rules.remove(rule);

    if (this.attached && rule.renderable && this.renderer) {
      return this.renderer.deleteRule(rule.renderable);
    }

    return true;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Deploy pure CSS string to a renderable.
   */
  ;

  _proto.deploy = function deploy() {
    if (this.renderer) this.renderer.deploy();
    this.deployed = true;
    return this;
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var _this$rules;

    (_this$rules = this.rules).update.apply(_this$rules, arguments);

    return this;
  }
  /**
   * Updates a single rule.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    this.rules.updateOne(rule, data, options);
    return this;
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    return this.rules.toString(options);
  };

  return StyleSheet;
}();

var PluginsRegistry =
/*#__PURE__*/
function () {
  function PluginsRegistry() {
    this.plugins = {
      internal: [],
      external: []
    };
    this.registry = {};
  }

  var _proto = PluginsRegistry.prototype;

  /**
   * Call `onCreateRule` hooks and return an object if returned by a hook.
   */
  _proto.onCreateRule = function onCreateRule(name, decl, options) {
    for (var i = 0; i < this.registry.onCreateRule.length; i++) {
      var rule = this.registry.onCreateRule[i](name, decl, options);
      if (rule) return rule;
    }

    return null;
  }
  /**
   * Call `onProcessRule` hooks.
   */
  ;

  _proto.onProcessRule = function onProcessRule(rule) {
    if (rule.isProcessed) return;
    var sheet = rule.options.sheet;

    for (var i = 0; i < this.registry.onProcessRule.length; i++) {
      this.registry.onProcessRule[i](rule, sheet);
    }

    if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
    rule.isProcessed = true;
  }
  /**
   * Call `onProcessStyle` hooks.
   */
  ;

  _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
    for (var i = 0; i < this.registry.onProcessStyle.length; i++) {
      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
    }
  }
  /**
   * Call `onProcessSheet` hooks.
   */
  ;

  _proto.onProcessSheet = function onProcessSheet(sheet) {
    for (var i = 0; i < this.registry.onProcessSheet.length; i++) {
      this.registry.onProcessSheet[i](sheet);
    }
  }
  /**
   * Call `onUpdate` hooks.
   */
  ;

  _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
    for (var i = 0; i < this.registry.onUpdate.length; i++) {
      this.registry.onUpdate[i](data, rule, sheet, options);
    }
  }
  /**
   * Call `onChangeValue` hooks.
   */
  ;

  _proto.onChangeValue = function onChangeValue(value, prop, rule) {
    var processedValue = value;

    for (var i = 0; i < this.registry.onChangeValue.length; i++) {
      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
    }

    return processedValue;
  }
  /**
   * Register a plugin.
   */
  ;

  _proto.use = function use(newPlugin, options) {
    if (options === void 0) {
      options = {
        queue: 'external'
      };
    }

    var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.

    if (plugins.indexOf(newPlugin) !== -1) {
      return;
    }

    plugins.push(newPlugin);
    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {
      for (var name in plugin) {
        if (name in registry) {
          registry[name].push(plugin[name]);
        } else {
           true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] Unknown hook \"" + name + "\".") : 0;
        }
      }

      return registry;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    });
  };

  return PluginsRegistry;
}();

/**
 * Sheets registry to access all instances in one place.
 */

var SheetsRegistry =
/*#__PURE__*/
function () {
  function SheetsRegistry() {
    this.registry = [];
  }

  var _proto = SheetsRegistry.prototype;

  /**
   * Register a Style Sheet.
   */
  _proto.add = function add(sheet) {
    var registry = this.registry;
    var index = sheet.options.index;
    if (registry.indexOf(sheet) !== -1) return;

    if (registry.length === 0 || index >= this.index) {
      registry.push(sheet);
      return;
    } // Find a position.


    for (var i = 0; i < registry.length; i++) {
      if (registry[i].options.index > index) {
        registry.splice(i, 0, sheet);
        return;
      }
    }
  }
  /**
   * Reset the registry.
   */
  ;

  _proto.reset = function reset() {
    this.registry = [];
  }
  /**
   * Remove a Style Sheet.
   */
  ;

  _proto.remove = function remove(sheet) {
    var index = this.registry.indexOf(sheet);
    this.registry.splice(index, 1);
  }
  /**
   * Convert all attached sheets to a CSS string.
   */
  ;

  _proto.toString = function toString(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        attached = _ref.attached,
        options = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_5__["default"])(_ref, ["attached"]);

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    var css = '';

    for (var i = 0; i < this.registry.length; i++) {
      var sheet = this.registry[i];

      if (attached != null && sheet.attached !== attached) {
        continue;
      }

      if (css) css += linebreak;
      css += sheet.toString(options);
    }

    return css;
  };

  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(SheetsRegistry, [{
    key: "index",

    /**
     * Current highest index number.
     */
    get: function get() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]);

  return SheetsRegistry;
}();

/**
 * This is a global sheets registry. Only DomRenderer will add sheets to it.
 * On the server one should use an own SheetsRegistry instance and add the
 * sheets to it, because you need to make sure to create a new registry for
 * each request in order to not leak sheets across requests.
 */

var sheets = new SheetsRegistry();

/* eslint-disable */

/**
 * Now that `globalThis` is available on most platforms
 * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)
 * we check for `globalThis` first. `globalThis` is necessary for jss
 * to run in Agoric's secure version of JavaScript (SES). Under SES,
 * `globalThis` exists, but `window`, `self`, and `Function('return
 * this')()` are all undefined for security reasons.
 *
 * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
 */
var globalThis$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();

var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
if (globalThis$1[ns] == null) globalThis$1[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
// the current version with just one short number and use it for classes generation
// we use a counter. Also it is more accurate, because user can manually reevaluate
// the module.

var moduleId = globalThis$1[ns]++;

var maxRules = 1e10;
/**
 * Returns a function which generates unique class names based on counters.
 * When new generator function is created, rule counter is reseted.
 * We need to reset the rule counter for SSR for each request.
 */

var createGenerateId = function createGenerateId(options) {
  if (options === void 0) {
    options = {};
  }

  var ruleCounter = 0;

  var generateId = function generateId(rule, sheet) {
    ruleCounter += 1;

    if (ruleCounter > maxRules) {
       true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] You might have a memory leak. Rule counter is at " + ruleCounter + ".") : 0;
    }

    var jssId = '';
    var prefix = '';

    if (sheet) {
      if (sheet.options.classNamePrefix) {
        prefix = sheet.options.classNamePrefix;
      }

      if (sheet.options.jss.id != null) {
        jssId = String(sheet.options.jss.id);
      }
    }

    if (options.minify) {
      // Using "c" because a number can't be the first char in a class name.
      return "" + (prefix || 'c') + moduleId + jssId + ruleCounter;
    }

    return prefix + rule.key + "-" + moduleId + (jssId ? "-" + jssId : '') + "-" + ruleCounter;
  };

  return generateId;
};

/**
 * Cache the value from the first time a function is called.
 */

var memoize = function memoize(fn) {
  var value;
  return function () {
    if (!value) value = fn();
    return value;
  };
};
/**
 * Get a style property value.
 */


var getPropertyValue = function getPropertyValue(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      return cssRule.attributeStyleMap.get(prop);
    }

    return cssRule.style.getPropertyValue(prop);
  } catch (err) {
    // IE may throw if property is unknown.
    return '';
  }
};
/**
 * Set a style property.
 */


var setProperty = function setProperty(cssRule, prop, value) {
  try {
    var cssValue = value;

    if (Array.isArray(value)) {
      cssValue = toCssValue(value);
    } // Support CSSTOM.


    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.set(prop, cssValue);
    } else {
      var indexOfImportantFlag = cssValue ? cssValue.indexOf('!important') : -1;
      var cssValueWithoutImportantFlag = indexOfImportantFlag > -1 ? cssValue.substr(0, indexOfImportantFlag - 1) : cssValue;
      cssRule.style.setProperty(prop, cssValueWithoutImportantFlag, indexOfImportantFlag > -1 ? 'important' : '');
    }
  } catch (err) {
    // IE may throw if property is unknown.
    return false;
  }

  return true;
};
/**
 * Remove a style property.
 */


var removeProperty = function removeProperty(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.delete(prop);
    } else {
      cssRule.style.removeProperty(prop);
    }
  } catch (err) {
     true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] DOMException \"" + err.message + "\" was thrown. Tried to remove property \"" + prop + "\".") : 0;
  }
};
/**
 * Set the selector.
 */


var setSelector = function setSelector(cssRule, selectorText) {
  cssRule.selectorText = selectorText; // Return false if setter was not successful.
  // Currently works in chrome only.

  return cssRule.selectorText === selectorText;
};
/**
 * Gets the `head` element upon the first call and caches it.
 * We assume it can't be null.
 */


var getHead = memoize(function () {
  return document.querySelector('head');
});
/**
 * Find attached sheet with an index higher than the passed one.
 */

function findHigherSheet(registry, options) {
  for (var i = 0; i < registry.length; i++) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find attached sheet with the highest index.
 */


function findHighestSheet(registry, options) {
  for (var i = registry.length - 1; i >= 0; i--) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find a comment with "jss" inside.
 */


function findCommentNode(text) {
  var head = getHead();

  for (var i = 0; i < head.childNodes.length; i++) {
    var node = head.childNodes[i];

    if (node.nodeType === 8 && node.nodeValue.trim() === text) {
      return node;
    }
  }

  return null;
}
/**
 * Find a node before which we can insert the sheet.
 */


function findPrevNode(options) {
  var registry = sheets.registry;

  if (registry.length > 0) {
    // Try to insert before the next higher sheet.
    var sheet = findHigherSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element
      };
    } // Otherwise insert after the last attached.


    sheet = findHighestSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element.nextSibling
      };
    }
  } // Try to find a comment placeholder if registry is empty.


  var insertionPoint = options.insertionPoint;

  if (insertionPoint && typeof insertionPoint === 'string') {
    var comment = findCommentNode(insertionPoint);

    if (comment) {
      return {
        parent: comment.parentNode,
        node: comment.nextSibling
      };
    } // If user specifies an insertion point and it can't be found in the document -
    // bad specificity issues may appear.


     true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] Insertion point \"" + insertionPoint + "\" not found.") : 0;
  }

  return false;
}
/**
 * Insert style element into the DOM.
 */


function insertStyle(style, options) {
  var insertionPoint = options.insertionPoint;
  var nextNode = findPrevNode(options);

  if (nextNode !== false && nextNode.parent) {
    nextNode.parent.insertBefore(style, nextNode.node);
    return;
  } // Works with iframes and any node types.


  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
    var insertionPointElement = insertionPoint;
    var parentNode = insertionPointElement.parentNode;
    if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);else  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, '[JSS] Insertion point is not in the DOM.') : 0;
    return;
  }

  getHead().appendChild(style);
}
/**
 * Read jss nonce setting from the page if the user has set it.
 */


var getNonce = memoize(function () {
  var node = document.querySelector('meta[property="csp-nonce"]');
  return node ? node.getAttribute('content') : null;
});

var _insertRule = function insertRule(container, rule, index) {
  try {
    if ('insertRule' in container) {
      container.insertRule(rule, index);
    } // Keyframes rule.
    else if ('appendRule' in container) {
        container.appendRule(rule);
      }
  } catch (err) {
     true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] " + err.message) : 0;
    return false;
  }

  return container.cssRules[index];
};

var getValidRuleInsertionIndex = function getValidRuleInsertionIndex(container, index) {
  var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong

  if (index === undefined || index > maxIndex) {
    // eslint-disable-next-line no-param-reassign
    return maxIndex;
  }

  return index;
};

var createStyle = function createStyle() {
  var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we
  // insert rules after we insert the style tag.
  // It seems to kick-off the source order specificity algorithm.

  el.textContent = '\n';
  return el;
};

var DomRenderer =
/*#__PURE__*/
function () {
  // Will be empty if link: true option is not set, because
  // it is only for use together with insertRule API.
  function DomRenderer(sheet) {
    this.getPropertyValue = getPropertyValue;
    this.setProperty = setProperty;
    this.removeProperty = removeProperty;
    this.setSelector = setSelector;
    this.hasInsertedRules = false;
    this.cssRules = [];
    // There is no sheet when the renderer is used from a standalone StyleRule.
    if (sheet) sheets.add(sheet);
    this.sheet = sheet;

    var _ref = this.sheet ? this.sheet.options : {},
        media = _ref.media,
        meta = _ref.meta,
        element = _ref.element;

    this.element = element || createStyle();
    this.element.setAttribute('data-jss', '');
    if (media) this.element.setAttribute('media', media);
    if (meta) this.element.setAttribute('data-meta', meta);
    var nonce = getNonce();
    if (nonce) this.element.setAttribute('nonce', nonce);
  }
  /**
   * Insert style element into render tree.
   */


  var _proto = DomRenderer.prototype;

  _proto.attach = function attach() {
    // In the case the element node is external and it is already in the DOM.
    if (this.element.parentNode || !this.sheet) return;
    insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
    // most browsers create a new CSSStyleSheet, except of all IEs.

    var deployed = Boolean(this.sheet && this.sheet.deployed);

    if (this.hasInsertedRules && deployed) {
      this.hasInsertedRules = false;
      this.deploy();
    }
  }
  /**
   * Remove style element from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.sheet) return;
    var parentNode = this.element.parentNode;
    if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.
    // Though IE will keep them and we need a consistent behavior.

    if (this.sheet.options.link) {
      this.cssRules = [];
      this.element.textContent = '\n';
    }
  }
  /**
   * Inject CSS string into element.
   */
  ;

  _proto.deploy = function deploy() {
    var sheet = this.sheet;
    if (!sheet) return;

    if (sheet.options.link) {
      this.insertRules(sheet.rules);
      return;
    }

    this.element.textContent = "\n" + sheet.toString() + "\n";
  }
  /**
   * Insert RuleList into an element.
   */
  ;

  _proto.insertRules = function insertRules(rules, nativeParent) {
    for (var i = 0; i < rules.index.length; i++) {
      this.insertRule(rules.index[i], i, nativeParent);
    }
  }
  /**
   * Insert a rule into element.
   */
  ;

  _proto.insertRule = function insertRule(rule, index, nativeParent) {
    if (nativeParent === void 0) {
      nativeParent = this.element.sheet;
    }

    if (rule.rules) {
      var parent = rule;
      var latestNativeParent = nativeParent;

      if (rule.type === 'conditional' || rule.type === 'keyframes') {
        var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.


        latestNativeParent = _insertRule(nativeParent, parent.toString({
          children: false
        }), _insertionIndex);

        if (latestNativeParent === false) {
          return false;
        }

        this.refCssRule(rule, _insertionIndex, latestNativeParent);
      }

      this.insertRules(parent.rules, latestNativeParent);
      return latestNativeParent;
    }

    var ruleStr = rule.toString();
    if (!ruleStr) return false;
    var insertionIndex = getValidRuleInsertionIndex(nativeParent, index);

    var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);

    if (nativeRule === false) {
      return false;
    }

    this.hasInsertedRules = true;
    this.refCssRule(rule, insertionIndex, nativeRule);
    return nativeRule;
  };

  _proto.refCssRule = function refCssRule(rule, index, cssRule) {
    rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules
    // like rules inside media queries or keyframes

    if (rule.options.parent instanceof StyleSheet) {
      this.cssRules.splice(index, 0, cssRule);
    }
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.deleteRule = function deleteRule(cssRule) {
    var sheet = this.element.sheet;
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    sheet.deleteRule(index);
    this.cssRules.splice(index, 1);
    return true;
  }
  /**
   * Get index of a CSS Rule.
   */
  ;

  _proto.indexOf = function indexOf(cssRule) {
    return this.cssRules.indexOf(cssRule);
  }
  /**
   * Generate a new CSS rule and replace the existing one.
   */
  ;

  _proto.replaceRule = function replaceRule(cssRule, rule) {
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    this.element.sheet.deleteRule(index);
    this.cssRules.splice(index, 1);
    return this.insertRule(rule, index);
  }
  /**
   * Get all rules elements.
   */
  ;

  _proto.getRules = function getRules() {
    return this.element.sheet.cssRules;
  };

  return DomRenderer;
}();

var instanceCounter = 0;

var Jss =
/*#__PURE__*/
function () {
  function Jss(options) {
    this.id = instanceCounter++;
    this.version = "10.10.0";
    this.plugins = new PluginsRegistry();
    this.options = {
      id: {
        minify: false
      },
      createGenerateId: createGenerateId,
      Renderer: is_in_browser__WEBPACK_IMPORTED_MODULE_1__["default"] ? DomRenderer : null,
      plugins: []
    };
    this.generateId = createGenerateId({
      minify: false
    });

    for (var i = 0; i < plugins.length; i++) {
      this.plugins.use(plugins[i], {
        queue: 'internal'
      });
    }

    this.setup(options);
  }
  /**
   * Prepares various options, applies plugins.
   * Should not be used twice on the same instance, because there is no plugins
   * deduplication logic.
   */


  var _proto = Jss.prototype;

  _proto.setup = function setup(options) {
    if (options === void 0) {
      options = {};
    }

    if (options.createGenerateId) {
      this.options.createGenerateId = options.createGenerateId;
    }

    if (options.id) {
      this.options.id = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, this.options.id, options.id);
    }

    if (options.createGenerateId || options.id) {
      this.generateId = this.options.createGenerateId(this.options.id);
    }

    if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;

    if ('Renderer' in options) {
      this.options.Renderer = options.Renderer;
    } // eslint-disable-next-line prefer-spread


    if (options.plugins) this.use.apply(this, options.plugins);
    return this;
  }
  /**
   * Create a Style Sheet.
   */
  ;

  _proto.createStyleSheet = function createStyleSheet(styles, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        index = _options.index;

    if (typeof index !== 'number') {
      index = sheets.index === 0 ? 0 : sheets.index + 1;
    }

    var sheet = new StyleSheet(styles, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      jss: this,
      generateId: options.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: index
    }));
    this.plugins.onProcessSheet(sheet);
    return sheet;
  }
  /**
   * Detach the Style Sheet and remove it from the registry.
   */
  ;

  _proto.removeStyleSheet = function removeStyleSheet(sheet) {
    sheet.detach();
    sheets.remove(sheet);
    return this;
  }
  /**
   * Create a rule without a Style Sheet.
   * [Deprecated] will be removed in the next major version.
   */
  ;

  _proto.createRule = function createRule$1(name, style, options) {
    if (style === void 0) {
      style = {};
    }

    if (options === void 0) {
      options = {};
    }

    // Enable rule without name for inline styles.
    if (typeof name === 'object') {
      return this.createRule(undefined, name, style);
    }

    var ruleOptions = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      name: name,
      jss: this,
      Renderer: this.options.Renderer
    });

    if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
    if (!ruleOptions.classes) ruleOptions.classes = {};
    if (!ruleOptions.keyframes) ruleOptions.keyframes = {};

    var rule = createRule(name, style, ruleOptions);

    if (rule) this.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Register plugin. Passed function will be invoked with a rule instance.
   */
  ;

  _proto.use = function use() {
    var _this = this;

    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }

    plugins.forEach(function (plugin) {
      _this.plugins.use(plugin);
    });
    return this;
  };

  return Jss;
}();

var createJss = function createJss(options) {
  return new Jss(options);
};

/**
 * SheetsManager is like a WeakMap which is designed to count StyleSheet
 * instances and attach/detach automatically.
 * Used in react-jss.
 */

var SheetsManager =
/*#__PURE__*/
function () {
  function SheetsManager() {
    this.length = 0;
    this.sheets = new WeakMap();
  }

  var _proto = SheetsManager.prototype;

  _proto.get = function get(key) {
    var entry = this.sheets.get(key);
    return entry && entry.sheet;
  };

  _proto.add = function add(key, sheet) {
    if (this.sheets.has(key)) return;
    this.length++;
    this.sheets.set(key, {
      sheet: sheet,
      refs: 0
    });
  };

  _proto.manage = function manage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs === 0) {
        entry.sheet.attach();
      }

      entry.refs++;
      return entry.sheet;
    }

    (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] SheetsManager: can't find sheet to manage");
    return undefined;
  };

  _proto.unmanage = function unmanage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs > 0) {
        entry.refs--;
        if (entry.refs === 0) entry.sheet.detach();
      }
    } else {
      (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "SheetsManager: can't find sheet to unmanage");
    }
  };

  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(SheetsManager, [{
    key: "size",
    get: function get() {
      return this.length;
    }
  }]);

  return SheetsManager;
}();

/**
* Export a constant indicating if this browser has CSSTOM support.
* https://developers.google.com/web/updates/2018/03/cssom
*/
var hasCSSTOMSupport = typeof CSS === 'object' && CSS != null && 'number' in CSS;

/**
 * Extracts a styles object with only props that contain function values.
 */
function getDynamicStyles(styles) {
  var to = null;

  for (var key in styles) {
    var value = styles[key];
    var type = typeof value;

    if (type === 'function') {
      if (!to) to = {};
      to[key] = value;
    } else if (type === 'object' && value !== null && !Array.isArray(value)) {
      var extracted = getDynamicStyles(value);

      if (extracted) {
        if (!to) to = {};
        to[key] = extracted;
      }
    }
  }

  return to;
}

/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */
var index = createJss();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);



/***/ }),

/***/ "../../../node_modules/sdp/sdp.js":
/*!****************************************!*\
  !*** ../../../node_modules/sdp/sdp.js ***!
  \****************************************/
/***/ ((module) => {

/* eslint-env node */


// SDP helpers.
const SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substring(2, 12);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(line => line.trim());
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  const parts = blob.split('\nm=');
  return parts.map((part, index) => (index > 0 ?
    'm=' + part : part).trim() + '\r\n');
};

// Returns the session description.
SDPUtils.getDescription = function(blob) {
  const sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// Returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  const sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
// Input can be prefixed with a=.
SDPUtils.parseCandidate = function(line) {
  let parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  const candidate = {
    foundation: parts[0],
    component: {1: 'rtp', 2: 'rtcp'}[parts[1]] || parts[1],
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    address: parts[4], // address is an alias for ip.
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7],
  };

  for (let i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compatibility.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag. Don't overwrite.
        if (candidate[parts[i]] === undefined) {
          candidate[parts[i]] = parts[i + 1];
        }
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
// This does not include the a= prefix!
SDPUtils.writeCandidate = function(candidate) {
  const sdp = [];
  sdp.push(candidate.foundation);

  const component = candidate.component;
  if (component === 'rtp') {
    sdp.push(1);
  } else if (component === 'rtcp') {
    sdp.push(2);
  } else {
    sdp.push(component);
  }
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.address || candidate.ip);
  sdp.push(candidate.port);

  const type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress);
    sdp.push('rport');
    sdp.push(candidate.relatedPort);
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// Sample input:
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substring(14).split(' ');
};

// Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  let parts = line.substring(9).split(' ');
  const parsed = {
    payloadType: parseInt(parts.shift(), 10), // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  // legacy alias, got renamed back to channels in ORTC.
  parsed.numChannels = parsed.channels;
  return parsed;
};

// Generates a rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  const channels = codec.channels || codec.numChannels || 1;
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (channels !== 1 ? '/' + channels : '') + '\r\n';
};

// Parses a extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  const parts = line.substring(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1],
    attributes: parts.slice(2).join(' '),
  };
};

// Generates an extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
        ? '/' + headerExtension.direction
        : '') +
      ' ' + headerExtension.uri +
      (headerExtension.attributes ? ' ' + headerExtension.attributes : '') +
      '\r\n';
};

// Parses a fmtp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  const parsed = {};
  let kv;
  const parts = line.substring(line.indexOf(' ') + 1).split(';');
  for (let j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  let line = '';
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    const params = [];
    Object.keys(codec.parameters).forEach(param => {
      if (codec.parameters[param] !== undefined) {
        params.push(param + '=' + codec.parameters[param]);
      } else {
        params.push(param);
      }
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  const parts = line.substring(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' '),
  };
};

// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  let lines = '';
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(fb => {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses a RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  const sp = line.indexOf(' ');
  const parts = {
    ssrc: parseInt(line.substring(7, sp), 10),
  };
  const colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substring(sp + 1, colon);
    parts.value = line.substring(colon + 1);
  } else {
    parts.attribute = line.substring(sp + 1);
  }
  return parts;
};

// Parse a ssrc-group line (see RFC 5576). Sample input:
// a=ssrc-group:semantics 12 34
SDPUtils.parseSsrcGroup = function(line) {
  const parts = line.substring(13).split(' ');
  return {
    semantics: parts.shift(),
    ssrcs: parts.map(ssrc => parseInt(ssrc, 10)),
  };
};

// Extracts the MID (RFC 5888) from a media section.
// Returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substring(6);
  }
};

// Parses a fingerprint line for DTLS-SRTP.
SDPUtils.parseFingerprint = function(line) {
  const parts = line.substring(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1].toUpperCase(), // the definition is upper-case in RFC 4572.
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint),
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  let sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(fp => {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};

// Parses a=crypto lines into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members
SDPUtils.parseCryptoLine = function(line) {
  const parts = line.substring(9).split(' ');
  return {
    tag: parseInt(parts[0], 10),
    cryptoSuite: parts[1],
    keyParams: parts[2],
    sessionParams: parts.slice(3),
  };
};

SDPUtils.writeCryptoLine = function(parameters) {
  return 'a=crypto:' + parameters.tag + ' ' +
    parameters.cryptoSuite + ' ' +
    (typeof parameters.keyParams === 'object'
      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)
      : parameters.keyParams) +
    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +
    '\r\n';
};

// Parses the crypto key parameters into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*
SDPUtils.parseCryptoKeyParams = function(keyParams) {
  if (keyParams.indexOf('inline:') !== 0) {
    return null;
  }
  const parts = keyParams.substring(7).split('|');
  return {
    keyMethod: 'inline',
    keySalt: parts[0],
    lifeTime: parts[1],
    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,
    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,
  };
};

SDPUtils.writeCryptoKeyParams = function(keyParams) {
  return keyParams.keyMethod + ':'
    + keyParams.keySalt +
    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +
    (keyParams.mkiValue && keyParams.mkiLength
      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength
      : '');
};

// Extracts all SDES parameters.
SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {
  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=crypto:');
  return lines.map(SDPUtils.parseCryptoLine);
};

// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=ice-ufrag:')[0];
  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=ice-pwd:')[0];
  if (!(ufrag && pwd)) {
    return null;
  }
  return {
    usernameFragment: ufrag.substring(12),
    password: pwd.substring(10),
  };
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
  if (params.iceLite) {
    sdp += 'a=ice-lite\r\n';
  }
  return sdp;
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  const description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: [],
  };
  const lines = SDPUtils.splitLines(mediaSection);
  const mline = lines[0].split(' ');
  description.profile = mline[2];
  for (let i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    const pt = mline[i];
    const rtpmapline = SDPUtils.matchPrefix(
      mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      const codec = SDPUtils.parseRtpMap(rtpmapline);
      const fmtps = SDPUtils.matchPrefix(
        mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
        mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:* ')
    .map(SDPUtils.parseRtcpFb);
  description.codecs.forEach(codec => {
    wildcardRtcpFb.forEach(fb=> {
      const duplicate = codec.rtcpFeedback.find(existingFeedback => {
        return existingFeedback.type === fb.type &&
          existingFeedback.parameter === fb.parameter;
      });
      if (!duplicate) {
        codec.rtcpFeedback.push(fb);
      }
    });
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  let sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' ' + (caps.profile || 'UDP/TLS/RTP/SAVPF') + ' ';
  sdp += caps.codecs.map(codec => {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(codec => {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  let maxptime = 0;
  caps.codecs.forEach(codec => {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }

  if (caps.headerExtensions) {
    caps.headerExtensions.forEach(extension => {
      sdp += SDPUtils.writeExtmap(extension);
    });
  }
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  const encodingParameters = [];
  const description = SDPUtils.parseRtpParameters(mediaSection);
  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(parts => parts.attribute === 'cname');
  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  let secondarySsrc;

  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
    .map(line => {
      const parts = line.substring(17).split(' ');
      return parts.map(part => parseInt(part, 10));
    });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(codec => {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      let encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10),
      };
      if (primarySsrc && secondarySsrc) {
        encParam.rtx = {ssrc: secondarySsrc};
      }
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: primarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red',
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc,
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substring(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(params => {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  const rtcpParameters = {};

  // Gets the first SSRC. Note that with RTX there might be multiple
  // SSRCs.
  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(obj => obj.attribute === 'cname')[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrbute.
  // Note that Edge does not support unmuxed RTCP.
  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

SDPUtils.writeRtcpParameters = function(rtcpParameters) {
  let sdp = '';
  if (rtcpParameters.reducedSize) {
    sdp += 'a=rtcp-rsize\r\n';
  }
  if (rtcpParameters.mux) {
    sdp += 'a=rtcp-mux\r\n';
  }
  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {
    sdp += 'a=ssrc:' + rtcpParameters.ssrc +
      ' cname:' + rtcpParameters.cname + '\r\n';
  }
  return sdp;
};


// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  let parts;
  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substring(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(msidParts => msidParts.attribute === 'msid');
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// SCTP
// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
// to draft-ietf-mmusic-sctp-sdp-05
SDPUtils.parseSctpDescription = function(mediaSection) {
  const mline = SDPUtils.parseMLine(mediaSection);
  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
  let maxMessageSize;
  if (maxSizeLine.length > 0) {
    maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);
  }
  if (isNaN(maxMessageSize)) {
    maxMessageSize = 65536;
  }
  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
  if (sctpPort.length > 0) {
    return {
      port: parseInt(sctpPort[0].substring(12), 10),
      protocol: mline.fmt,
      maxMessageSize,
    };
  }
  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');
  if (sctpMapLines.length > 0) {
    const parts = sctpMapLines[0]
      .substring(10)
      .split(' ');
    return {
      port: parseInt(parts[0], 10),
      protocol: parts[1],
      maxMessageSize,
    };
  }
};

// SCTP
// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
// support by now receiving in this format, unless we originally parsed
// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
// protocol of DTLS/SCTP -- without UDP/ or TCP/)
SDPUtils.writeSctpDescription = function(media, sctp) {
  let output = [];
  if (media.protocol !== 'DTLS/SCTP') {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctp-port:' + sctp.port + '\r\n',
    ];
  } else {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n',
    ];
  }
  if (sctp.maxMessageSize !== undefined) {
    output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
  }
  return output.join('');
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 22);
};

// Write boiler plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
// sessUser is optional and defaults to 'thisisadapterortc'
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
  let sessionId;
  const version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  const user = sessUser || 'thisisadapterortc';
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=' + user + ' ' + sessionId + ' ' + version +
        ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  const lines = SDPUtils.splitLines(mediaSection);
  for (let i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substring(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  const lines = SDPUtils.splitLines(mediaSection);
  const mline = lines[0].split(' ');
  return mline[0].substring(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  const lines = SDPUtils.splitLines(mediaSection);
  const parts = lines[0].substring(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' '),
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  const parts = line.substring(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5],
  };
};

// a very naive interpretation of a valid SDP.
SDPUtils.isValidSDP = function(blob) {
  if (typeof blob !== 'string' || blob.length === 0) {
    return false;
  }
  const lines = SDPUtils.splitLines(blob);
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
      return false;
    }
    // TODO: check the modifier a bit more.
  }
  return true;
};

// Expose public methods.
if (true) {
  module.exports = SDPUtils;
}


/***/ }),

/***/ "../../../node_modules/tiny-warning/dist/tiny-warning.esm.js":
/*!*******************************************************************!*\
  !*** ../../../node_modules/tiny-warning/dist/tiny-warning.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var isProduction = "development" === 'production';
function warning(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }

    var text = "Warning: " + message;

    if (typeof console !== 'undefined') {
      console.warn(text);
    }

    try {
      throw Error(text);
    } catch (x) {}
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (warning);


/***/ }),

/***/ "../../library/dist/esm/AFK/AFKController.js":
/*!***************************************************!*\
  !*** ../../library/dist/esm/AFK/AFKController.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AFKController: () => (/* binding */ AFKController)
/* harmony export */ });
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Util/EventEmitter */ "../../library/dist/esm/Util/EventEmitter.js");
// Copyright Epic Games, Inc. All Rights Reserved.



class AFKController {
    constructor(config, pixelStreaming, onDismissAfk) {
        // time out logic details
        this.active = false;
        this.countdownActive = false;
        this.warnTimer = undefined;
        this.countDown = 0;
        this.countDownTimer = undefined;
        this.config = config;
        this.pixelStreaming = pixelStreaming;
        this.onDismissAfk = onDismissAfk;
        this.onAFKTimedOutCallback = () => {
            console.log('AFK timed out, did you want to override this callback?');
        };
    }
    /**
     * The methods that occur when an afk event listener is clicked
     */
    onAfkClick() {
        clearInterval(this.countDownTimer);
        if (this.active || this.countdownActive) {
            this.startAfkWarningTimer();
            this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkWarningDeactivateEvent());
        }
    }
    /**
     * Start the warning timer if a timeout is set greater that 0 seconds
     */
    startAfkWarningTimer() {
        if (this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.NumericParameters.AFKTimeoutSecs) > 0 &&
            this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.AFKDetection)) {
            this.active = true;
        }
        else {
            this.active = false;
        }
        this.resetAfkWarningTimer();
    }
    /**
     * Stop the afk warning timer
     */
    stopAfkWarningTimer() {
        this.active = false;
        this.countdownActive = false;
        clearTimeout(this.warnTimer);
        clearInterval(this.countDownTimer);
    }
    /**
     * Pause the timer which when elapsed will warn the user they are inactive.
     */
    pauseAfkWarningTimer() {
        this.active = false;
    }
    /**
     * If the user interacts then reset the warning timer.
     */
    resetAfkWarningTimer() {
        if (this.active && this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.AFKDetection)) {
            clearTimeout(this.warnTimer);
            this.warnTimer = setTimeout(() => this.activateAfkEvent(), this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.NumericParameters.AFKTimeoutSecs) * 1000);
        }
    }
    /**
     * Show the AFK overlay and begin the countDown
     */
    activateAfkEvent() {
        // Pause the timer while the user is looking at the inactivity warning overlay
        this.pauseAfkWarningTimer();
        // instantiate a new overlay
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkWarningActivateEvent({
            countDown: this.countDown,
            dismissAfk: this.onDismissAfk
        }));
        // update our countDown timer and overlay contents
        this.countDown = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.NumericParameters.AFKCountdownSecs);
        this.countdownActive = true;
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkWarningUpdateEvent({ countDown: this.countDown }));
        // if we are in locked mouse exit pointerlock
        if (!this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.HoveringMouseMode)) {
            // minor hack to alleviate ios not supporting pointerlock
            if (document.exitPointerLock) {
                document.exitPointerLock();
            }
        }
        // reset our countDown interval accordingly
        this.countDownTimer = setInterval(() => {
            this.countDown--;
            if (this.countDown == 0) {
                // The user failed to click so hide the overlay and disconnect them.
                this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkTimedOutEvent());
                this.onAFKTimedOutCallback();
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_2__.Logger.Info('You have been disconnected due to inactivity');
                // switch off the afk feature as stream has closed
                this.stopAfkWarningTimer();
            }
            else {
                this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkWarningUpdateEvent({ countDown: this.countDown }));
            }
        }, 1000);
    }
}
//# sourceMappingURL=AFKController.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/Config.js":
/*!***********************************************!*\
  !*** ../../library/dist/esm/Config/Config.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Config: () => (/* binding */ Config),
/* harmony export */   ControlSchemeType: () => (/* binding */ ControlSchemeType),
/* harmony export */   Flags: () => (/* binding */ Flags),
/* harmony export */   NumericParameters: () => (/* binding */ NumericParameters),
/* harmony export */   OptionParameters: () => (/* binding */ OptionParameters),
/* harmony export */   TextParameters: () => (/* binding */ TextParameters),
/* harmony export */   isFlagId: () => (/* binding */ isFlagId),
/* harmony export */   isNumericId: () => (/* binding */ isNumericId),
/* harmony export */   isOptionId: () => (/* binding */ isOptionId),
/* harmony export */   isTextId: () => (/* binding */ isTextId)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _SettingFlag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SettingFlag */ "../../library/dist/esm/Config/SettingFlag.js");
/* harmony import */ var _SettingNumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SettingNumber */ "../../library/dist/esm/Config/SettingNumber.js");
/* harmony import */ var _SettingText__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingText */ "../../library/dist/esm/Config/SettingText.js");
/* harmony import */ var _SettingOption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SettingOption */ "../../library/dist/esm/Config/SettingOption.js");
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Util/EventEmitter */ "../../library/dist/esm/Util/EventEmitter.js");
/* harmony import */ var _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util/BrowserUtils */ "../../library/dist/esm/Util/BrowserUtils.js");
// Copyright Epic Games, Inc. All Rights Reserved.







/**
 * A collection of flags that can be toggled and are core to all Pixel Streaming experiences.
 * These are used in the `Config.Flags` map.
 */
class Flags {
}
Flags.AutoConnect = 'AutoConnect';
Flags.AutoPlayVideo = 'AutoPlayVideo';
Flags.AFKDetection = 'TimeoutIfIdle';
Flags.HoveringMouseMode = 'HoveringMouse';
Flags.ForceMonoAudio = 'ForceMonoAudio';
Flags.ForceTURN = 'ForceTURN';
Flags.FakeMouseWithTouches = 'FakeMouseWithTouches';
Flags.IsQualityController = 'ControlsQuality';
Flags.MatchViewportResolution = 'MatchViewportRes';
Flags.StartVideoMuted = 'StartVideoMuted';
Flags.SuppressBrowserKeys = 'SuppressBrowserKeys';
Flags.UseMic = 'UseMic';
Flags.UseModalForTextInput = 'UseModalForTextInput';
Flags.UseCamera = 'UseCamera';
Flags.KeyboardInput = 'KeyboardInput';
Flags.MouseInput = 'MouseInput';
Flags.TouchInput = 'TouchInput';
Flags.GamepadInput = 'GamepadInput';
Flags.XRControllerInput = 'XRControllerInput';
Flags.WaitForStreamer = 'WaitForStreamer';
Flags.HideUI = 'HideUI';
Flags.EnableCaptureTimeExt = 'EnableCaptureTimeExt';
Flags.BrowserSendOffer = 'BrowserSendOffer';
Flags.LatencyCSV = 'LatencyCSV';
const isFlagId = (id) => Object.getOwnPropertyNames(Flags).some((name) => Flags[name] === id);
/**
 * A collection of numeric parameters that are core to all Pixel Streaming experiences.
 *
 */
class NumericParameters {
}
NumericParameters.AFKTimeoutSecs = 'AFKTimeout';
NumericParameters.AFKCountdownSecs = 'AFKCountdown';
NumericParameters.MinQP = 'MinQP';
NumericParameters.MaxQP = 'MaxQP';
NumericParameters.MinQuality = 'MinQuality';
NumericParameters.MaxQuality = 'MaxQuality';
NumericParameters.CompatQualityMin = 'CompatQualityMin';
NumericParameters.CompatQualityMax = 'CompatQualityMax';
NumericParameters.WebRTCFPS = 'WebRTCFPS';
NumericParameters.WebRTCMinBitrate = 'WebRTCMinBitrate';
NumericParameters.WebRTCMaxBitrate = 'WebRTCMaxBitrate';
NumericParameters.MaxReconnectAttempts = 'MaxReconnectAttempts';
NumericParameters.StreamerAutoJoinInterval = 'StreamerAutoJoinInterval';
NumericParameters.KeepaliveDelay = 'KeepaliveDelay';
const isNumericId = (id) => Object.getOwnPropertyNames(NumericParameters).some((name) => NumericParameters[name] === id);
/**
 * A collection of textual parameters that are core to all Pixel Streaming experiences.
 *
 */
class TextParameters {
}
TextParameters.SignallingServerUrl = 'ss';
const isTextId = (id) => Object.getOwnPropertyNames(TextParameters).some((name) => TextParameters[name] === id);
/**
 * A collection of enum based parameters that are core to all Pixel Streaming experiences.
 *
 */
class OptionParameters {
}
OptionParameters.PreferredCodec = 'PreferredCodec';
OptionParameters.StreamerId = 'StreamerId';
OptionParameters.PreferredQuality = 'PreferredQuality';
const isOptionId = (id) => Object.getOwnPropertyNames(OptionParameters).some((name) => OptionParameters[name] === id);
class Config {
    // ------------ Settings -----------------
    constructor(config = {}) {
        /* A map of flags that can be toggled - options that can be set in the application - e.g. Use Mic? */
        this.flags = new Map();
        /* A map of numerical settings - options that can be in the application - e.g. MinBitrate */
        this.numericParameters = new Map();
        /* A map of text settings - e.g. signalling server url */
        this.textParameters = new Map();
        /* A map of enum based settings - e.g. preferred codec */
        this.optionParameters = new Map();
        const { initialSettings, useUrlParams, webSocketProtocols } = config;
        this._useUrlParams = !!useUrlParams;
        this._webSocketProtocols = webSocketProtocols;
        this.populateDefaultSettings(this._useUrlParams, initialSettings);
    }
    /**
     * True if reading configuration initial values from URL parameters, and
     * persisting changes in URL when changed.
     */
    get useUrlParams() {
        return this._useUrlParams;
    }
    /**
     * Gets a protocol or list of protocols to pass to the websocket if set.
     */
    get webSocketProtocols() {
        return this._webSocketProtocols;
    }
    /**
     * Populate the default settings for a Pixel Streaming application
     */
    populateDefaultSettings(useUrlParams, settings) {
        /**
         * Text Parameters
         */
        this.textParameters.set(TextParameters.SignallingServerUrl, new _SettingText__WEBPACK_IMPORTED_MODULE_0__.SettingText(TextParameters.SignallingServerUrl, 'Signalling url', 'Url of the signalling server', settings && Object.prototype.hasOwnProperty.call(settings, TextParameters.SignallingServerUrl)
            ? settings[TextParameters.SignallingServerUrl]
            : (location.protocol === 'https:' ? 'wss://' : 'ws://') +
                window.location.hostname +
                // for readability, we omit the port if it's 80
                (window.location.port === '80' || window.location.port === ''
                    ? ''
                    : `:${window.location.port}`), useUrlParams));
        this.optionParameters.set(OptionParameters.StreamerId, new _SettingOption__WEBPACK_IMPORTED_MODULE_1__.SettingOption(OptionParameters.StreamerId, 'Streamer ID', 'The ID of the streamer to stream.', settings && Object.prototype.hasOwnProperty.call(settings, OptionParameters.StreamerId)
            ? settings[OptionParameters.StreamerId]
            : '', settings && Object.prototype.hasOwnProperty.call(settings, OptionParameters.StreamerId)
            ? [settings[OptionParameters.StreamerId]]
            : undefined, useUrlParams));
        const getDefaultVideoCodec = function () {
            const videoCodecs = _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_2__.BrowserUtils.getSupportedVideoCodecs();
            // If only one option, then select that.
            if (videoCodecs.length == 1) {
                return videoCodecs[0];
            }
            else if (videoCodecs.length > 0) {
                const defaultCodec = videoCodecs[0];
                for (const codec of videoCodecs) {
                    if (codec.startsWith('H264')) {
                        return codec;
                    }
                }
                return defaultCodec;
            }
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error('Could not find any reasonable video codec to assign as a default.');
            return '';
        };
        const matchSpecifiedCodecToClosestSupported = function (specifiedCodec) {
            const browserSupportedCodecs = _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_2__.BrowserUtils.getSupportedVideoCodecs();
            // Codec supplied in url param is an exact match for the browser codec.
            // (e.g. H264 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f)
            if (browserSupportedCodecs.includes(specifiedCodec)) {
                return specifiedCodec;
            }
            // Try to match the start of whatever is passed into the url parameter with what the browser supports
            for (const browserCodec of browserSupportedCodecs) {
                if (browserCodec.startsWith(specifiedCodec)) {
                    return browserCodec;
                }
            }
            // If we weren't able to match, just return the codec as from the URL as-is.
            return specifiedCodec;
        };
        /**
         * Enum Parameters
         */
        this.optionParameters.set(OptionParameters.PreferredCodec, new _SettingOption__WEBPACK_IMPORTED_MODULE_1__.SettingOption(OptionParameters.PreferredCodec, 'Preferred Codec', 'The preferred codec to be used during codec negotiation', settings && Object.prototype.hasOwnProperty.call(settings, OptionParameters.PreferredCodec)
            ? matchSpecifiedCodecToClosestSupported(settings[OptionParameters.PreferredCodec])
            : getDefaultVideoCodec(), _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_2__.BrowserUtils.getSupportedVideoCodecs(), useUrlParams, matchSpecifiedCodecToClosestSupported));
        this.optionParameters.set(OptionParameters.PreferredQuality, new _SettingOption__WEBPACK_IMPORTED_MODULE_1__.SettingOption(OptionParameters.PreferredQuality, 'Preferred Quality', 'The preferred quality of the stream (only applicable when using the SFU)', settings && Object.prototype.hasOwnProperty.call(settings, OptionParameters.PreferredQuality)
            ? settings[OptionParameters.PreferredQuality]
            : 'Default', ['Default'], useUrlParams));
        /**
         * Boolean parameters
         */
        this.flags.set(Flags.AutoConnect, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.AutoConnect, 'Auto connect to stream', 'Whether we should attempt to auto connect to the signalling server or show a click to start prompt.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.AutoConnect)
            ? settings[Flags.AutoConnect]
            : false, useUrlParams));
        this.flags.set(Flags.AutoPlayVideo, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.AutoPlayVideo, 'Auto play video', 'When video is ready automatically start playing it as opposed to showing a play button.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.AutoPlayVideo)
            ? settings[Flags.AutoPlayVideo]
            : true, useUrlParams));
        this.flags.set(Flags.UseMic, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.UseMic, 'Use microphone', 'Make browser request microphone access and open an input audio track.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.UseMic)
            ? settings[Flags.UseMic]
            : false, useUrlParams));
        this.flags.set(Flags.UseModalForTextInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.UseModalForTextInput, 'Use modal for text input', 'When entering input into a streamed UE text widget, use an input modal.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.UseModalForTextInput)
            ? settings[Flags.UseModalForTextInput]
            : true, useUrlParams));
        this.flags.set(Flags.UseCamera, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.UseCamera, 'Use webcam', 'Make browser request webcam access and open a input video track.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.UseCamera)
            ? settings[Flags.UseCamera]
            : false, useUrlParams));
        this.flags.set(Flags.StartVideoMuted, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.StartVideoMuted, 'Start video muted', 'Video will start muted if true.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.StartVideoMuted)
            ? settings[Flags.StartVideoMuted]
            : false, useUrlParams));
        this.flags.set(Flags.SuppressBrowserKeys, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.SuppressBrowserKeys, 'Suppress browser keys', 'Suppress certain browser keys that we use in UE, for example F5 to show shader complexity instead of refresh the page.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.SuppressBrowserKeys)
            ? settings[Flags.SuppressBrowserKeys]
            : true, useUrlParams));
        this.flags.set(Flags.IsQualityController, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.IsQualityController, 'Is quality controller?', 'True if this peer controls stream quality', settings && Object.prototype.hasOwnProperty.call(settings, Flags.IsQualityController)
            ? settings[Flags.IsQualityController]
            : true, useUrlParams));
        this.flags.set(Flags.ForceMonoAudio, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.ForceMonoAudio, 'Force mono audio', 'Force browser to request mono audio in the SDP', settings && Object.prototype.hasOwnProperty.call(settings, Flags.ForceMonoAudio)
            ? settings[Flags.ForceMonoAudio]
            : false, useUrlParams));
        this.flags.set(Flags.ForceTURN, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.ForceTURN, 'Force TURN', 'Only generate TURN/Relayed ICE candidates.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.ForceTURN)
            ? settings[Flags.ForceTURN]
            : false, useUrlParams));
        this.flags.set(Flags.AFKDetection, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.AFKDetection, 'AFK if idle', 'Timeout the experience if user is AFK for a period.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.AFKDetection)
            ? settings[Flags.AFKDetection]
            : false, useUrlParams));
        this.flags.set(Flags.MatchViewportResolution, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.MatchViewportResolution, 'Match viewport resolution', 'Pixel Streaming will be instructed to dynamically resize the video stream to match the size of the video element.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.MatchViewportResolution)
            ? settings[Flags.MatchViewportResolution]
            : false, useUrlParams));
        this.flags.set(Flags.HoveringMouseMode, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.HoveringMouseMode, 'Control Scheme: Locked Mouse', 'Either locked mouse, where the pointer is consumed by the video and locked to it, or hovering mouse, where the mouse is not consumed.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.HoveringMouseMode)
            ? settings[Flags.HoveringMouseMode]
            : false, useUrlParams, (isHoveringMouse, setting) => {
            setting.label = `Control Scheme: ${isHoveringMouse ? 'Hovering' : 'Locked'} Mouse`;
        }));
        this.flags.set(Flags.FakeMouseWithTouches, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.FakeMouseWithTouches, 'Fake mouse with touches', 'A single finger touch is converted into a mouse event. This allows a non-touch application to be controlled partially via a touch device.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.FakeMouseWithTouches)
            ? settings[Flags.FakeMouseWithTouches]
            : false, useUrlParams));
        this.flags.set(Flags.KeyboardInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.KeyboardInput, 'Keyboard input', 'If enabled, send keyboard events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.KeyboardInput)
            ? settings[Flags.KeyboardInput]
            : true, useUrlParams));
        this.flags.set(Flags.MouseInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.MouseInput, 'Mouse input', 'If enabled, send mouse events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.MouseInput)
            ? settings[Flags.MouseInput]
            : true, useUrlParams));
        this.flags.set(Flags.TouchInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.TouchInput, 'Touch input', 'If enabled, send touch events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.TouchInput)
            ? settings[Flags.TouchInput]
            : true, useUrlParams));
        this.flags.set(Flags.GamepadInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.GamepadInput, 'Gamepad input', 'If enabled, send gamepad events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.GamepadInput)
            ? settings[Flags.GamepadInput]
            : true, useUrlParams));
        this.flags.set(Flags.XRControllerInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.XRControllerInput, 'XR controller input', 'If enabled, send XR controller events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.XRControllerInput)
            ? settings[Flags.XRControllerInput]
            : true, useUrlParams));
        this.flags.set(Flags.WaitForStreamer, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.WaitForStreamer, 'Wait for streamer', 'Will continue trying to connect to the first streamer available.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.WaitForStreamer)
            ? settings[Flags.WaitForStreamer]
            : true, useUrlParams));
        this.flags.set(Flags.HideUI, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.HideUI, 'Hide the UI overlay', 'Will hide all UI overlay details', settings && Object.prototype.hasOwnProperty.call(settings, Flags.HideUI)
            ? settings[Flags.HideUI]
            : false, useUrlParams));
        this.flags.set(Flags.EnableCaptureTimeExt, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.EnableCaptureTimeExt, 'Enable abs-capture-time', 'Enables the abs-capture-time RTP header extension', settings && Object.prototype.hasOwnProperty.call(settings, Flags.EnableCaptureTimeExt)
            ? settings[Flags.EnableCaptureTimeExt]
            : false, useUrlParams));
        this.flags.set(Flags.BrowserSendOffer, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.BrowserSendOffer, 'Browser send offer (4.27 ONLY)', 'Browser will initiate the WebRTC handshake by sending the offer to the streamer (4.27 ONLY)', settings && Object.prototype.hasOwnProperty.call(settings, Flags.BrowserSendOffer)
            ? settings[Flags.BrowserSendOffer]
            : false, useUrlParams));
        this.flags.set(Flags.LatencyCSV, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.LatencyCSV, 'Export Latency CSV', 'Shows a button in the stats panel that allows to run a latency test and export the results to a CSV file.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.LatencyCSV)
            ? settings[Flags.LatencyCSV]
            : false, useUrlParams));
        /**
         * Numeric parameters
         */
        this.numericParameters.set(NumericParameters.AFKTimeoutSecs, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.AFKTimeoutSecs, 'AFK timeout', 'The time (in seconds) it takes for the application to time out if AFK timeout is enabled.', 0 /*min*/, null /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.AFKTimeoutSecs)
            ? settings[NumericParameters.AFKTimeoutSecs]
            : 120 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.AFKCountdownSecs, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.AFKCountdownSecs, 'AFK countdown', 'The time (in seconds) for a user to respond before the stream is ended after an AFK timeout.', 10 /*min*/, null /*max*/, 10 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MaxReconnectAttempts, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MaxReconnectAttempts, 'Max Reconnects', 'Maximum number of reconnects the application will attempt when a streamer disconnects.', 0 /*min*/, 999 /*max*/, settings &&
            Object.prototype.hasOwnProperty.call(settings, NumericParameters.MaxReconnectAttempts)
            ? settings[NumericParameters.MaxReconnectAttempts]
            : 3 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MinQP, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MinQP, 'Min QP', 'The lower bound for the quantization parameter (QP) of the encoder. 0 = Best quality, 51 = worst quality.', 0 /*min*/, 51 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.MinQP)
            ? settings[NumericParameters.MinQP]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MaxQP, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MaxQP, 'Max QP', 'The upper bound for the quantization parameter (QP) of the encoder. 0 = Best quality, 51 = worst quality.', 0 /*min*/, 51 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.MaxQP)
            ? settings[NumericParameters.MaxQP]
            : 51 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MinQuality, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MinQuality, 'Min Quality', 'The lower bound for the quality factor of the encoder. 0 = Worst quality, 100 = Best quality.', 0 /*min*/, 100 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.MinQuality)
            ? settings[NumericParameters.MinQuality]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MaxQuality, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MaxQuality, 'Max Quality', 'The upper bound for the quality factor of the encoder. 0 = Worst quality, 100 = Best quality.', 0 /*min*/, 100 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.MaxQuality)
            ? settings[NumericParameters.MaxQuality]
            : 100 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.CompatQualityMin, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.CompatQualityMin, 'Min Quality', 'The lower bound for encoding quality. 0 = Worst, 100 = Best.', 0 /*min*/, 100 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.CompatQualityMin)
            ? settings[NumericParameters.CompatQualityMin]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.CompatQualityMax, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.CompatQualityMax, 'Max Quality', 'The upper bound for encoding quality. 0 = Worst, 100 = Best.', 0 /*min*/, 100 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.CompatQualityMax)
            ? settings[NumericParameters.CompatQualityMax]
            : 100 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.WebRTCFPS, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.WebRTCFPS, 'Max FPS', 'The maximum FPS that WebRTC will try to transmit frames at.', 1 /*min*/, 999 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.WebRTCFPS)
            ? settings[NumericParameters.WebRTCFPS]
            : 60 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.WebRTCMinBitrate, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.WebRTCMinBitrate, 'Min Bitrate (kbps)', 'The minimum bitrate that WebRTC should use.', 0 /*min*/, 500000 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.WebRTCMinBitrate)
            ? settings[NumericParameters.WebRTCMinBitrate]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.WebRTCMaxBitrate, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.WebRTCMaxBitrate, 'Max Bitrate (kbps)', 'The maximum bitrate that WebRTC should use.', 0 /*min*/, 500000 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.WebRTCMaxBitrate)
            ? settings[NumericParameters.WebRTCMaxBitrate]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.StreamerAutoJoinInterval, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.StreamerAutoJoinInterval, 'Streamer Auto Join Interval (ms)', 'Delay between retries when waiting for an available streamer.', 500 /*min*/, 900000 /*max*/, settings &&
            Object.prototype.hasOwnProperty.call(settings, NumericParameters.StreamerAutoJoinInterval)
            ? settings[NumericParameters.StreamerAutoJoinInterval]
            : 3000 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.KeepaliveDelay, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.KeepaliveDelay, 'Connection Keepalive delay', 'Delay between keepalive pings to the signalling server.', 0 /*min*/, 900000 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.KeepaliveDelay)
            ? settings[NumericParameters.KeepaliveDelay]
            : 30000 /*value*/, useUrlParams));
    }
    /**
     * Add a callback to fire when the numeric setting is toggled.
     * @param id The id of the flag.
     * @param onChangedListener The callback to fire when the numeric value changes.
     */
    _addOnNumericSettingChangedListener(id, onChangedListener) {
        if (this.numericParameters.has(id)) {
            this.numericParameters.get(id).addOnChangedListener(onChangedListener);
        }
    }
    _addOnOptionSettingChangedListener(id, onChangedListener) {
        if (this.optionParameters.has(id)) {
            this.optionParameters.get(id).addOnChangedListener(onChangedListener);
        }
    }
    /**
     * @param id The id of the numeric setting we are interested in getting a value for.
     * @returns The numeric value stored in the parameter with the passed id.
     */
    getNumericSettingValue(id) {
        if (this.numericParameters.has(id)) {
            return this.numericParameters.get(id).number;
        }
        else {
            throw new Error(`There is no numeric setting with the id of ${id}`);
        }
    }
    /**
     * @param id The id of the text setting we are interested in getting a value for.
     * @returns The text value stored in the parameter with the passed id.
     */
    getTextSettingValue(id) {
        if (this.textParameters.has(id)) {
            return this.textParameters.get(id).value;
        }
        else {
            throw new Error(`There is no numeric setting with the id of ${id}`);
        }
    }
    /**
     * Set number in the setting.
     * @param id The id of the numeric setting we are interested in.
     * @param value The numeric value to set.
     */
    setNumericSetting(id, value) {
        if (this.numericParameters.has(id)) {
            this.numericParameters.get(id).number = value;
        }
        else {
            throw new Error(`There is no numeric setting with the id of ${id}`);
        }
    }
    /**
     * Add a callback to fire when the flag is toggled.
     * @param id The id of the flag.
     * @param onChangeListener The callback to fire when the value changes.
     */
    _addOnSettingChangedListener(id, onChangeListener) {
        if (this.flags.has(id)) {
            this.flags.get(id).onChange = onChangeListener;
        }
    }
    /**
     * Add a callback to fire when the text is changed.
     * @param id The id of the flag.
     * @param onChangeListener The callback to fire when the value changes.
     */
    _addOnTextSettingChangedListener(id, onChangeListener) {
        if (this.textParameters.has(id)) {
            this.textParameters.get(id).onChange = onChangeListener;
        }
    }
    /**
     * Get the option which has the given id.
     * @param id The id of the option.
     * @returns The SettingOption object matching id
     */
    getSettingOption(id) {
        return this.optionParameters.get(id);
    }
    /**
     * Get the value of the configuration flag which has the given id.
     * @param id The unique id for the flag.
     * @returns True if the flag is enabled.
     */
    isFlagEnabled(id) {
        return this.flags.get(id).flag;
    }
    /**
     * Set flag to be enabled/disabled.
     * @param id The id of the flag to toggle.
     * @param flagEnabled True if the flag should be enabled.
     */
    setFlagEnabled(id, flagEnabled) {
        if (!this.flags.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot toggle flag called ${id} - it does not exist in the Config.flags map.`);
        }
        else {
            this.flags.get(id).flag = flagEnabled;
        }
    }
    /**
     * Set the text setting.
     * @param id The id of the setting
     * @param settingValue The value to set in the setting.
     */
    setTextSetting(id, settingValue) {
        if (!this.textParameters.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot set text setting called ${id} - it does not exist in the Config.textParameters map.`);
        }
        else {
            this.textParameters.get(id).text = settingValue;
        }
    }
    /**
     * Set the option setting list of options.
     * @param id The id of the setting
     * @param settingOptions The values the setting could take
     */
    setOptionSettingOptions(id, settingOptions) {
        if (!this.optionParameters.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot set text setting called ${id} - it does not exist in the Config.optionParameters map.`);
        }
        else {
            this.optionParameters.get(id).options = settingOptions;
        }
    }
    /**
     * Set option enum settings selected option.
     * @param id The id of the setting
     * @param settingOptions The value to select out of all the options
     */
    setOptionSettingValue(id, settingValue) {
        if (!this.optionParameters.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot set text setting called ${id} - it does not exist in the Config.enumParameters map.`);
        }
        else {
            const optionSetting = this.optionParameters.get(id);
            const existingOptions = optionSetting.options;
            if (!existingOptions.includes(settingValue)) {
                existingOptions.push(settingValue);
                optionSetting.options = existingOptions;
            }
            optionSetting.selected = settingValue;
        }
    }
    /**
     * Set the label for the flag.
     * @param id The id of the flag.
     * @param label The new label to use for the flag.
     */
    setFlagLabel(id, label) {
        if (!this.flags.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot set label for flag called ${id} - it does not exist in the Config.flags map.`);
        }
        else {
            this.flags.get(id).label = label;
        }
    }
    /**
     * Set a subset of all settings in one function call.
     *
     * @param settings A (partial) list of settings to set
     */
    setSettings(settings) {
        for (const key of Object.keys(settings)) {
            if (isFlagId(key)) {
                this.setFlagEnabled(key, settings[key]);
            }
            else if (isNumericId(key)) {
                this.setNumericSetting(key, settings[key]);
            }
            else if (isTextId(key)) {
                this.setTextSetting(key, settings[key]);
            }
            else if (isOptionId(key)) {
                this.setOptionSettingValue(key, settings[key]);
            }
        }
    }
    /**
     * Get all settings
     * @returns All setting values as an object with setting ids as keys
     */
    getSettings() {
        const settings = {};
        for (const [key, value] of this.flags.entries()) {
            settings[key] = value.flag;
        }
        for (const [key, value] of this.numericParameters.entries()) {
            settings[key] = value.number;
        }
        for (const [key, value] of this.textParameters.entries()) {
            settings[key] = value.text;
        }
        for (const [key, value] of this.optionParameters.entries()) {
            settings[key] = value.selected;
        }
        return settings;
    }
    /**
     * Get all Flag settings as an array.
     * @returns All SettingFlag objects
     */
    getFlags() {
        return Array.from(this.flags.values());
    }
    /**
     * Get all Text settings as an array.
     * @returns All SettingText objects
     */
    getTextSettings() {
        return Array.from(this.textParameters.values());
    }
    /**
     * Get all Number settings as an array.
     * @returns All SettingNumber objects
     */
    getNumericSettings() {
        return Array.from(this.numericParameters.values());
    }
    /**
     * Get all Option settings as an array.
     * @returns All SettingOption objects
     */
    getOptionSettings() {
        return Array.from(this.optionParameters.values());
    }
    /**
     * Emit events when settings change.
     * @param eventEmitter
     */
    _registerOnChangeEvents(eventEmitter) {
        for (const key of this.flags.keys()) {
            const flag = this.flags.get(key);
            if (flag) {
                flag.onChangeEmit = (newValue) => eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__.SettingsChangedEvent({
                    id: flag.id,
                    type: 'flag',
                    value: newValue,
                    target: flag
                }));
            }
        }
        for (const key of this.numericParameters.keys()) {
            const number = this.numericParameters.get(key);
            if (number) {
                number.onChangeEmit = (newValue) => eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__.SettingsChangedEvent({
                    id: number.id,
                    type: 'number',
                    value: newValue,
                    target: number
                }));
            }
        }
        for (const key of this.textParameters.keys()) {
            const text = this.textParameters.get(key);
            if (text) {
                text.onChangeEmit = (newValue) => eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__.SettingsChangedEvent({
                    id: text.id,
                    type: 'text',
                    value: newValue,
                    target: text
                }));
            }
        }
        for (const key of this.optionParameters.keys()) {
            const option = this.optionParameters.get(key);
            if (option) {
                option.onChangeEmit = (newValue) => eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__.SettingsChangedEvent({
                    id: option.id,
                    type: 'option',
                    value: newValue,
                    target: option
                }));
            }
        }
    }
}
/**
 * The enum associated with the mouse being locked or hovering
 */
var ControlSchemeType;
(function (ControlSchemeType) {
    ControlSchemeType[ControlSchemeType["LockedMouse"] = 0] = "LockedMouse";
    ControlSchemeType[ControlSchemeType["HoveringMouse"] = 1] = "HoveringMouse";
})(ControlSchemeType || (ControlSchemeType = {}));
//# sourceMappingURL=Config.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/SettingBase.js":
/*!****************************************************!*\
  !*** ../../library/dist/esm/Config/SettingBase.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingBase: () => (/* binding */ SettingBase)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Base class for a setting that has a text label and an arbitrary setting value it stores.
 */
class SettingBase {
    constructor(id, label, description, defaultSettingValue, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        this.parseURLParams();
        this.onChange = defaultOnChangeListener;
        this.onChangeEmit = () => {
            /* Do nothing, to be overridden. */
        };
        this.id = id;
        this.description = description;
        this.label = label;
        this.value = defaultSettingValue;
    }
    /**
     * Set the label text for the setting.
     * @param label setting label.
     */
    set label(inLabel) {
        this._label = inLabel;
        this.onChangeEmit(this._value);
    }
    /**
     * @returns The label text for the setting.
     */
    get label() {
        return this._label;
    }
    /**
     * @return The setting's value.
     */
    get value() {
        return this._value;
    }
    /**
     * Update the setting's stored value.
     * @param inValue The new value for the setting.
     */
    set value(inValue) {
        this._value = inValue;
        this.onChange(this._value, this);
        this.onChangeEmit(this._value);
    }
    /**
     * Persist the setting value in URL.
     */
    updateURLParams() {
        if (this.useUrlParams) {
            // set url params
            const urlParams = new URLSearchParams(window.location.search);
            const valueString = this.getValueAsString();
            let set = false;
            for (const [name, _value] of urlParams) {
                if (name.toLowerCase() == this.id.toLowerCase()) {
                    urlParams.set(name, valueString);
                    set = true;
                    break;
                }
            }
            if (!set) {
                urlParams.set(this.id, valueString);
            }
            window.history.replaceState({}, '', urlParams.toString() !== '' ? `${location.pathname}?${urlParams}` : `${location.pathname}`);
        }
    }
    /**
     * Allows sub types to provide their value for the url search params.
     */
    getValueAsString() {
        return '';
    }
    parseURLParams() {
        this._urlParams = {};
        const params = new URLSearchParams(window.location.search);
        for (const [name, value] of params) {
            this._urlParams[name.toLowerCase()] = value;
        }
    }
    hasURLParam(name) {
        return name.toLowerCase() in this._urlParams;
    }
    getURLParam(name) {
        if (this.hasURLParam(name)) {
            return this._urlParams[name.toLowerCase()];
        }
        return '';
    }
}
//# sourceMappingURL=SettingBase.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/SettingFlag.js":
/*!****************************************************!*\
  !*** ../../library/dist/esm/Config/SettingFlag.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingFlag: () => (/* binding */ SettingFlag)
/* harmony export */ });
/* harmony import */ var _SettingBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingBase */ "../../library/dist/esm/Config/SettingBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * A boolean flag setting object with a text label.
 */
class SettingFlag extends _SettingBase__WEBPACK_IMPORTED_MODULE_0__.SettingBase {
    constructor(id, label, description, defaultFlagValue, useUrlParams, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        super(id, label, description, defaultFlagValue, defaultOnChangeListener);
        if (!useUrlParams || !this.hasURLParam(this.id)) {
            this.flag = defaultFlagValue;
        }
        else {
            // parse flag from url parameters
            const urlParamFlag = this.getURLParam(this.id);
            this.flag = urlParamFlag.toLowerCase() != 'false';
        }
        this.useUrlParams = useUrlParams;
    }
    getValueAsString() {
        return this.flag ? 'true' : 'false';
    }
    /**
     * Enables this flag.
     */
    enable() {
        this.flag = true;
    }
    /**
     * @return The setting's value.
     */
    get flag() {
        return !!this.value;
    }
    /**
     * Update the setting's stored value.
     * @param inValue The new value for the setting.
     */
    set flag(inValue) {
        this.value = inValue;
    }
}
//# sourceMappingURL=SettingFlag.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/SettingNumber.js":
/*!******************************************************!*\
  !*** ../../library/dist/esm/Config/SettingNumber.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingNumber: () => (/* binding */ SettingNumber)
/* harmony export */ });
/* harmony import */ var _SettingBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingBase */ "../../library/dist/esm/Config/SettingBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * A number setting object with a text label. Min and max limit the range of allowed values.
 */
class SettingNumber extends _SettingBase__WEBPACK_IMPORTED_MODULE_0__.SettingBase {
    constructor(id, label, description, min, max, defaultNumber, useUrlParams, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        super(id, label, description, defaultNumber, defaultOnChangeListener);
        this._min = min;
        this._max = max;
        // attempt to read the number from the url params
        if (!useUrlParams || !this.hasURLParam(this.id)) {
            this.number = defaultNumber;
        }
        else {
            const parsedValue = Number.parseFloat(this.getURLParam(this.id));
            this.number = Number.isNaN(parsedValue) ? defaultNumber : parsedValue;
        }
        this.useUrlParams = useUrlParams;
    }
    getValueAsString() {
        return this.number.toString();
    }
    /**
     * Set the number value (will be clamped within range).
     */
    set number(newNumber) {
        this.value = this.clamp(newNumber);
    }
    /**
     * @returns The number stored.
     */
    get number() {
        return this.value;
    }
    /**
     * Clamps a number between the min and max values (inclusive).
     * @param inNumber The number to clamp.
     * @returns The clamped number.
     */
    clamp(inNumber) {
        if (this._min == null && this._max == null) {
            return inNumber;
        }
        else if (this._min == null) {
            return Math.min(this._max, inNumber);
        }
        else if (this._max == null) {
            return Math.max(this._min, inNumber);
        }
        else {
            return Math.max(Math.min(this._max, inNumber), this._min);
        }
    }
    /**
     * Returns the minimum value
     * @returns The minimum value
     */
    get min() {
        return this._min;
    }
    /**
     * Returns the maximum value
     * @returns The maximum value
     */
    get max() {
        return this._max;
    }
    /**
     * Add a change listener to the number object.
     */
    addOnChangedListener(onChangedFunc) {
        this.onChange = onChangedFunc;
    }
}
//# sourceMappingURL=SettingNumber.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/SettingOption.js":
/*!******************************************************!*\
  !*** ../../library/dist/esm/Config/SettingOption.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingOption: () => (/* binding */ SettingOption)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _SettingBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingBase */ "../../library/dist/esm/Config/SettingBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * An Option setting object with a text label. Allows you to specify an array of options and select one of them.
 */
class SettingOption extends _SettingBase__WEBPACK_IMPORTED_MODULE_0__.SettingBase {
    constructor(id, label, description, defaultTextValue, options, useUrlParams, defaultUrlParamResolver = function (value) {
        /* Return the string as-is by default */
        return value;
    }, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        super(id, label, description, defaultTextValue, defaultOnChangeListener);
        this._urlParamResolver = defaultUrlParamResolver;
        const stringToMatch = this.hasURLParam(this.id)
            ? this._urlParamResolver(this.getURLParam(this.id))
            : defaultTextValue;
        this.options = options !== null && options !== void 0 ? options : [stringToMatch];
        this.selected = stringToMatch;
        this.useUrlParams = useUrlParams;
    }
    getValueAsString() {
        return this.selected;
    }
    /**
     * Add a change listener to the select element.
     */
    addOnChangedListener(onChangedFunc) {
        this.onChange = onChangedFunc;
    }
    /**
     * @returns All available options as an array
     */
    get options() {
        return this._options;
    }
    /**
     * Set options
     * @param values Array of options
     */
    set options(values) {
        this._options = values;
        this.onChangeEmit(this.selected);
    }
    /**
     * @returns Selected option as a string
     */
    get selected() {
        return this.value;
    }
    /**
     * Set selected option if it matches one of the available options
     * @param value Selected option
     */
    set selected(value) {
        if (value === undefined) {
            return;
        }
        // If options contains the value, then set that as selected
        if (this.options.includes(value)) {
            this.value = value;
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`Could not set "${value}" as the selected option for ${this.id} because it wasn't one of the options.`);
        }
    }
    /**
     * Set the url parameter resolver to do some transformation to the string value
     * that is extracted from the url parameters.
     * @param urlParam A function that transforms the extracted url parameter string for this setting to something else.
     */
    set urlParamResolver(value) {
        this._urlParamResolver = value;
    }
}
//# sourceMappingURL=SettingOption.js.map

/***/ }),

/***/ "../../library/dist/esm/Config/SettingText.js":
/*!****************************************************!*\
  !*** ../../library/dist/esm/Config/SettingText.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingText: () => (/* binding */ SettingText)
/* harmony export */ });
/* harmony import */ var _SettingBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingBase */ "../../library/dist/esm/Config/SettingBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * A text setting object with a text label.
 */
class SettingText extends _SettingBase__WEBPACK_IMPORTED_MODULE_0__.SettingBase {
    constructor(id, label, description, defaultTextValue, useUrlParams, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        super(id, label, description, defaultTextValue, defaultOnChangeListener);
        if (!useUrlParams || !this.hasURLParam(this.id)) {
            this.text = defaultTextValue;
        }
        else {
            // parse flag from url parameters
            this.text = this.getURLParam(this.id);
        }
        this.useUrlParams = useUrlParams;
    }
    getValueAsString() {
        return this.text;
    }
    /**
     * @return The setting's value.
     */
    get text() {
        return this.value;
    }
    /**
     * Update the setting's stored value.
     * @param inValue The new value for the setting.
     */
    set text(inValue) {
        this.value = inValue;
    }
}
//# sourceMappingURL=SettingText.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/DataChannelController.js":
/*!*******************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/DataChannelController.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataChannelController: () => (/* binding */ DataChannelController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Handles the Sending and Receiving of messages to the UE Instance via the Data Channel
 */
class DataChannelController {
    constructor() {
        this.isReceivingFreezeFrame = false;
    }
    /**
     * return the current state of a datachannel controller instance
     * @returns the current DataChannelController instance
     */
    getDataChannelInstance() {
        return this;
    }
    /**
     * To Create and Set up a Data Channel
     * @param peerConnection - The RTC Peer Connection
     * @param label - Label of the Data Channel
     * @param datachannelOptions - Optional RTC DataChannel options
     */
    createDataChannel(peerConnection, label, datachannelOptions) {
        this.peerConnection = peerConnection;
        this.label = label;
        this.datachannelOptions = datachannelOptions;
        if (datachannelOptions == null) {
            this.datachannelOptions = {};
            this.datachannelOptions.ordered = true;
        }
        this.dataChannel = this.peerConnection.createDataChannel(this.label, this.datachannelOptions);
        this.setupDataChannel();
    }
    setupDataChannel() {
        //We Want an Array Buffer not a blob
        this.dataChannel.binaryType = 'arraybuffer';
        this.dataChannel.onopen = (ev) => this.handleOnOpen(ev);
        this.dataChannel.onclose = (ev) => this.handleOnClose(ev);
        this.dataChannel.onmessage = (ev) => this.handleOnMessage(ev);
        this.dataChannel.onerror = (ev) => this.handleOnError(ev);
    }
    /**
     * Handles when the Data Channel is opened
     */
    handleOnOpen(ev) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data Channel (${this.label}) opened.`);
        this.onOpen((_a = this.dataChannel) === null || _a === void 0 ? void 0 : _a.label, ev);
    }
    /**
     * Handles when the Data Channel is closed
     */
    handleOnClose(ev) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data Channel (${this.label}) closed.`);
        this.onClose((_a = this.dataChannel) === null || _a === void 0 ? void 0 : _a.label, ev);
    }
    /**
     * Handles when a message is received
     * @param event - Message Event
     */
    handleOnMessage(event) {
        // Higher log level to prevent log spam with messages received
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data Channel (${this.label}) message: ${event}`);
    }
    /**
     * Handles when an error is thrown
     * @param event - Error Event
     */
    handleOnError(event) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data Channel (${this.label}) error: ${event}`);
        this.onError((_a = this.dataChannel) === null || _a === void 0 ? void 0 : _a.label, event);
    }
    /**
     * Override to register onOpen handler
     * @param label Data channel label ("datachannel", "send-datachannel", "recv-datachannel")
     * @param ev event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onOpen(label, ev) {
        // empty default implementation
    }
    /**
     * Override to register onClose handler
     * @param label Data channel label ("datachannel", "send-datachannel", "recv-datachannel")
     * @param ev event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onClose(label, ev) {
        // empty default implementation
    }
    /**
     * Override to register onError handler
     * @param label Data channel label ("datachannel", "send-datachannel", "recv-datachannel")
     * @param ev event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onError(label, ev) {
        // empty default implementation
    }
}
//# sourceMappingURL=DataChannelController.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/DataChannelLatencyTestController.js":
/*!******************************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/DataChannelLatencyTestController.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataChannelLatencyTestController: () => (/* binding */ DataChannelLatencyTestController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _DataChannelLatencyTestResults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DataChannelLatencyTestResults */ "../../library/dist/esm/DataChannel/DataChannelLatencyTestResults.js");
// Copyright Epic Games, Inc. All Rights Reserved.


class DataChannelLatencyTestController {
    constructor(sink, callback) {
        this.intervalHandle = undefined;
        this.sink = sink;
        this.callback = callback;
        this.records = new Map();
        this.seq = 0;
    }
    start(config) {
        if (this.isRunning()) {
            return false;
        }
        this.startTime = Date.now();
        this.records.clear();
        this.intervalHandle = window.setInterval((() => {
            if (Date.now() - this.startTime >= config.duration) {
                this.stop();
            }
            else {
                this.sendRequest(config.requestSize, config.responseSize);
            }
        }).bind(this), Math.floor(1000 / config.rps));
        return true;
    }
    stop() {
        if (this.intervalHandle) {
            window.clearInterval(this.intervalHandle);
            this.intervalHandle = undefined;
            this.callback(this.produceResult());
        }
    }
    produceResult() {
        const resultRecords = new Map(this.records);
        return {
            records: resultRecords,
            dataChannelRtt: Math.ceil(Array.from(this.records.values()).reduce((acc, next) => {
                return acc + (next.playerReceivedTimestamp - next.playerSentTimestamp);
            }, 0) / this.records.size),
            playerToStreamerTime: Math.ceil(Array.from(this.records.values()).reduce((acc, next) => {
                return acc + (next.streamerReceivedTimestamp - next.playerSentTimestamp);
            }, 0) / this.records.size),
            streamerToPlayerTime: Math.ceil(Array.from(this.records.values()).reduce((acc, next) => {
                return acc + (next.playerReceivedTimestamp - next.streamerSentTimestamp);
            }, 0) / this.records.size),
            exportLatencyAsCSV: () => {
                let csv = 'Timestamp;RTT;PlayerToStreamer;StreamerToPlayer;\n';
                resultRecords.forEach((record) => {
                    csv += record.playerSentTimestamp + ';';
                    csv += record.playerReceivedTimestamp - record.playerSentTimestamp + ';';
                    csv += record.streamerReceivedTimestamp - record.playerSentTimestamp + ';';
                    csv += record.playerReceivedTimestamp - record.streamerSentTimestamp + ';';
                    csv += '\n';
                });
                return csv;
            }
        };
    }
    isRunning() {
        return !!this.intervalHandle;
    }
    receive(response) {
        if (!this.isRunning()) {
            return;
        }
        if (!response) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Error('Undefined response from server');
            return;
        }
        const record = this.records.get(response.Seq);
        if (record) {
            record.update(response);
        }
    }
    sendRequest(requestSize, responseSize) {
        const request = this.createRequest(requestSize, responseSize);
        const record = new _DataChannelLatencyTestResults__WEBPACK_IMPORTED_MODULE_1__.DataChannelLatencyTestRecord(request);
        this.records.set(record.seq, record);
        this.sink(request);
    }
    createRequest(requestSize, responseSize) {
        return {
            Seq: this.seq++,
            FillResponseSize: responseSize,
            Filler: requestSize ? 'A'.repeat(requestSize) : ''
        };
    }
}
//# sourceMappingURL=DataChannelLatencyTestController.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/DataChannelLatencyTestResults.js":
/*!***************************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/DataChannelLatencyTestResults.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataChannelLatencyTestRecord: () => (/* binding */ DataChannelLatencyTestRecord)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class DataChannelLatencyTestRecord {
    constructor(request) {
        this.seq = request.Seq;
        this.playerSentTimestamp = Date.now();
        this.requestFillerSize = request.Filler ? request.Filler.length : 0;
    }
    update(response) {
        this.playerReceivedTimestamp = Date.now();
        this.streamerReceivedTimestamp = response.ReceivedTimestamp;
        this.streamerSentTimestamp = response.SentTimestamp;
        this.responseFillerSize = response.Filler ? response.Filler.length : 0;
    }
}
//# sourceMappingURL=DataChannelLatencyTestResults.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/DataChannelSender.js":
/*!***************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/DataChannelSender.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataChannelSender: () => (/* binding */ DataChannelSender)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * A class for sending data channel messages
 */
class DataChannelSender {
    /**
     * @param dataChannelProvider - Data channel object type
     */
    constructor(dataChannelProvider) {
        this.dataChannelProvider = dataChannelProvider;
    }
    canSend() {
        return (this.dataChannelProvider.getDataChannelInstance().dataChannel !== undefined &&
            this.dataChannelProvider.getDataChannelInstance().dataChannel.readyState == 'open');
    }
    /**
     * Send Data over the Data channel to the UE Instance
     * @param data - Message Data Array Buffer
     */
    sendData(data) {
        // reset the afk inactivity
        const dataChannelInstance = this.dataChannelProvider.getDataChannelInstance();
        if (dataChannelInstance.dataChannel.readyState == 'open') {
            dataChannelInstance.dataChannel.send(data);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Message Sent: ${new Uint8Array(data)}`);
            this.resetAfkWarningTimerOnDataSend();
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Message Failed: ${new Uint8Array(data)}`);
        }
    }
    /**
     * An override method for resetting the Afk warning timer when data is sent over the data channel
     */
    resetAfkWarningTimerOnDataSend() {
        // Base Functionality: Do Nothing
    }
}
//# sourceMappingURL=DataChannelSender.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/InitialSettings.js":
/*!*************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/InitialSettings.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EncoderSettings: () => (/* binding */ EncoderSettings),
/* harmony export */   InitialSettings: () => (/* binding */ InitialSettings),
/* harmony export */   PixelStreamingSettings: () => (/* binding */ PixelStreamingSettings),
/* harmony export */   WebRTCSettings: () => (/* binding */ WebRTCSettings)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Latency Test Results Data
 */
class InitialSettings {
    constructor() {
        this.PixelStreamingSettings = new PixelStreamingSettings();
        this.EncoderSettings = new EncoderSettings();
        this.WebRTCSettings = new WebRTCSettings();
    }
    /**
     * Checks for compatibility with the FPS and MaxFPS stats between 4.27 and 5
     */
    ueCompatible() {
        if (this.WebRTCSettings.MaxFPS != null) {
            this.WebRTCSettings.FPS = this.WebRTCSettings.MaxFPS;
        }
    }
}
/**
 * A class for handling Pixel Streaming details
 */
class PixelStreamingSettings {
}
/**
 * A class for handling encoder stats
 */
class EncoderSettings {
}
/**
 * A class for handling web rtc stats
 */
class WebRTCSettings {
}
//# sourceMappingURL=InitialSettings.js.map

/***/ }),

/***/ "../../library/dist/esm/DataChannel/LatencyTestResults.js":
/*!****************************************************************!*\
  !*** ../../library/dist/esm/DataChannel/LatencyTestResults.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LatencyTestResults: () => (/* binding */ LatencyTestResults)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Latency Test Results Data
 */
class LatencyTestResults {
    constructor() {
        //Fields Set from the latency payload regardless of version
        this.ReceiptTimeMs = null;
        this.TransmissionTimeMs = null;
        //Fields Set from the latency payload from 4.27.2
        this.PreCaptureTimeMs = null;
        this.PostCaptureTimeMs = null;
        this.PreEncodeTimeMs = null;
        this.PostEncodeTimeMs = null;
        //Fields Set from the latency payload from 5.0
        this.EncodeMs = null;
        this.CaptureToSendMs = null;
        //Fields Set when processed
        this.testStartTimeMs = 0;
        this.browserReceiptTimeMs = 0;
        //Fields set from calculations
        this.latencyExcludingDecode = 0;
        this.testDuration = 0;
        //ueLatency: number = 0;
        this.networkLatency = 0;
        this.browserSendLatency = 0;
        this.frameDisplayDeltaTimeMs = 0;
        this.endToEndLatency = 0;
        //uePixelStreamLatency: number = 0;
        this.encodeLatency = 0;
    }
    /**
     * Sets the Delta Time Milliseconds
     * @param DeltaTimeMs - Delta Time Milliseconds
     */
    setFrameDisplayDeltaTime(DeltaTimeMs) {
        if (this.frameDisplayDeltaTimeMs == 0) {
            this.frameDisplayDeltaTimeMs = Math.round(DeltaTimeMs);
        }
    }
    /**
     * Process the encoder times and set them
     */
    processFields() {
        if (this.EncodeMs == null && (this.PreEncodeTimeMs != null || this.PostEncodeTimeMs != null)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Setting Encode Ms \n ${this.PostEncodeTimeMs} \n ${this.PreEncodeTimeMs}`);
            this.EncodeMs = this.PostEncodeTimeMs - this.PreEncodeTimeMs;
        }
        if (this.CaptureToSendMs == null &&
            (this.PreCaptureTimeMs != null || this.PostCaptureTimeMs != null)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Setting CaptureToSendMs Ms \n ${this.PostCaptureTimeMs} \n ${this.PreCaptureTimeMs}`);
            this.CaptureToSendMs = this.PostCaptureTimeMs - this.PreCaptureTimeMs;
        }
    }
}
//# sourceMappingURL=LatencyTestResults.js.map

/***/ }),

/***/ "../../library/dist/esm/FreezeFrame/FreezeFrame.js":
/*!*********************************************************!*\
  !*** ../../library/dist/esm/FreezeFrame/FreezeFrame.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FreezeFrame: () => (/* binding */ FreezeFrame)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * A class for managing the freeze frame object
 */
class FreezeFrame {
    /**
     * Construct a freeze frame
     * @param rootDiv the div that a freeze frame element will be injected into
     */
    constructor(rootDiv) {
        this.freezeFrameHeight = 0;
        this.freezeFrameWidth = 0;
        this.rootDiv = rootDiv;
        // create the overlay
        this.rootElement = document.createElement('div');
        this.rootElement.id = 'freezeFrame';
        this.rootElement.style.display = 'none';
        this.rootElement.style.pointerEvents = 'none';
        this.rootElement.style.position = 'absolute';
        this.rootElement.style.zIndex = '20';
        // create the image place holder
        this.imageElement = document.createElement('img');
        this.imageElement.style.position = 'absolute';
        // append the image into the root element and append the element to the root div
        this.rootElement.appendChild(this.imageElement);
        this.rootDiv.appendChild(this.rootElement);
    }
    /**
     * Set the freeze frame element for showing
     */
    setElementForShow() {
        this.rootElement.style.display = 'block';
    }
    /**
     * Set the freeze frame element for hiding
     */
    setElementForHide() {
        this.rootElement.style.display = 'none';
    }
    /**
     * Update the freeze frames image source
     * @param jpeg - the freeze frame image as a byte array data
     */
    updateImageElementSource(jpeg) {
        const base64 = btoa(jpeg.reduce((data, byte) => data + String.fromCharCode(byte), ''));
        this.imageElement.src = 'data:image/jpeg;base64,' + base64;
    }
    /**
     * Set the dimensions for the freeze frame from the element and resize it
     */
    setDimensionsFromElementAndResize() {
        this.freezeFrameHeight = this.imageElement.naturalHeight;
        this.freezeFrameWidth = this.imageElement.naturalWidth;
        this.resize();
    }
    /**
     * Resize a freeze frame element
     */
    resize() {
        if (this.freezeFrameWidth !== 0 && this.freezeFrameHeight !== 0) {
            let displayWidth = 0;
            let displayHeight = 0;
            let displayTop = 0;
            let displayLeft = 0;
            const parentAspectRatio = this.rootDiv.clientWidth / this.rootDiv.clientHeight;
            const videoAspectRatio = this.freezeFrameWidth / this.freezeFrameHeight;
            if (parentAspectRatio < videoAspectRatio) {
                displayWidth = this.rootDiv.clientWidth;
                displayHeight = Math.floor(this.rootDiv.clientWidth / videoAspectRatio);
                displayTop = Math.floor((this.rootDiv.clientHeight - displayHeight) * 0.5);
                displayLeft = 0;
            }
            else {
                displayWidth = Math.floor(this.rootDiv.clientHeight * videoAspectRatio);
                displayHeight = this.rootDiv.clientHeight;
                displayTop = 0;
                displayLeft = Math.floor((this.rootDiv.clientWidth - displayWidth) * 0.5);
            }
            this.rootElement.style.width = this.rootDiv.offsetWidth + 'px';
            this.rootElement.style.height = this.rootDiv.offsetHeight + 'px';
            this.rootElement.style.left = 0 + 'px';
            this.rootElement.style.top = 0 + 'px';
            this.imageElement.style.width = displayWidth + 'px';
            this.imageElement.style.height = displayHeight + 'px';
            this.imageElement.style.left = displayLeft + 'px';
            this.imageElement.style.top = displayTop + 'px';
        }
    }
}
//# sourceMappingURL=FreezeFrame.js.map

/***/ }),

/***/ "../../library/dist/esm/FreezeFrame/FreezeFrameController.js":
/*!*******************************************************************!*\
  !*** ../../library/dist/esm/FreezeFrame/FreezeFrameController.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FreezeFrameController: () => (/* binding */ FreezeFrameController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _FreezeFrame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FreezeFrame */ "../../library/dist/esm/FreezeFrame/FreezeFrame.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * A class for controlling freeze frame functionality
 */
class FreezeFrameController {
    /**
     * Construct a freeze frame controller
     * @param rootDiv - the div that a freeze frame element will be injected into
     */
    constructor(rootDiv) {
        this.receiving = false;
        this.size = 0;
        this.jpeg = undefined;
        this.valid = false;
        this.freezeFrameDelay = 50;
        this.freezeFrame = new _FreezeFrame__WEBPACK_IMPORTED_MODULE_0__.FreezeFrame(rootDiv);
    }
    /**
     * Show the freeze frame if it is valid
     */
    showFreezeFrame() {
        if (this.valid) {
            this.freezeFrame.setElementForShow();
        }
    }
    /**
     * Hide the freeze frame and set the validity to false
     */
    hideFreezeFrame() {
        this.valid = false;
        this.freezeFrame.setElementForHide();
    }
    /**
     * Update the freeze frames image source and load it
     * @param jpeg - the freeze frame image as a byte array data
     * @param onLoadCallBack - a call back for managing if the play overlay needs to be shown or not
     */
    updateFreezeFrameAndShow(jpeg, onLoadCallBack) {
        this.freezeFrame.updateImageElementSource(jpeg);
        this.freezeFrame.imageElement.onload = () => {
            this.freezeFrame.setDimensionsFromElementAndResize();
            onLoadCallBack();
        };
    }
    /**
     * Process the new freeze frame image and update it
     * @param view - the freeze frame image as a byte array data
     * @param onLoadCallBack - a call back for managing if the play overlay needs to be shown or not
     */
    processFreezeFrameMessage(view, onLoadCallBack) {
        // Reset freeze frame if we got a freeze frame message and we are not "receiving" yet.
        if (!this.receiving) {
            this.receiving = true;
            this.valid = false;
            this.size = 0;
            this.jpeg = undefined;
        }
        // Extract total size of freeze frame (across all chunks)
        this.size = new DataView(view.slice(1, 5).buffer).getInt32(0, true);
        // Get the jpeg part of the payload
        const jpegBytes = view.slice(1 + 4);
        // Append to existing jpeg that holds the freeze frame
        if (this.jpeg) {
            const jpeg = new Uint8Array(this.jpeg.length + jpegBytes.length);
            jpeg.set(this.jpeg, 0);
            jpeg.set(jpegBytes, this.jpeg.length);
            this.jpeg = jpeg;
        }
        // No existing freeze frame jpeg, make one
        else {
            this.jpeg = jpegBytes;
            this.receiving = true;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(`received first chunk of freeze frame: ${this.jpeg.length}/${this.size}`);
        }
        // Finished receiving freeze frame, we can show it now
        if (this.jpeg.length === this.size) {
            this.receiving = false;
            this.valid = true;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(`received complete freeze frame ${this.size}`);
            this.updateFreezeFrameAndShow(this.jpeg, onLoadCallBack);
        }
        // We received more data than the freeze frame payload message indicate (this is an error)
        else if (this.jpeg.length > this.size) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`received bigger freeze frame than advertised: ${this.jpeg.length}/${this.size}`);
            this.jpeg = undefined;
            this.receiving = false;
        }
    }
}
//# sourceMappingURL=FreezeFrameController.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/GamepadController.js":
/*!**********************************************************!*\
  !*** ../../library/dist/esm/Inputs/GamepadController.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GamepadController: () => (/* binding */ GamepadController),
/* harmony export */   GamepadLayout: () => (/* binding */ GamepadLayout)
/* harmony export */ });
/* harmony import */ var _GamepadTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GamepadTypes */ "../../library/dist/esm/Inputs/GamepadTypes.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Gamepad layout codes enum
 */
var GamepadLayout;
(function (GamepadLayout) {
    GamepadLayout[GamepadLayout["RightClusterBottomButton"] = 0] = "RightClusterBottomButton";
    GamepadLayout[GamepadLayout["RightClusterRightButton"] = 1] = "RightClusterRightButton";
    GamepadLayout[GamepadLayout["RightClusterLeftButton"] = 2] = "RightClusterLeftButton";
    GamepadLayout[GamepadLayout["RightClusterTopButton"] = 3] = "RightClusterTopButton";
    GamepadLayout[GamepadLayout["LeftShoulder"] = 4] = "LeftShoulder";
    GamepadLayout[GamepadLayout["RightShoulder"] = 5] = "RightShoulder";
    GamepadLayout[GamepadLayout["LeftTrigger"] = 6] = "LeftTrigger";
    GamepadLayout[GamepadLayout["RightTrigger"] = 7] = "RightTrigger";
    GamepadLayout[GamepadLayout["SelectOrBack"] = 8] = "SelectOrBack";
    GamepadLayout[GamepadLayout["StartOrForward"] = 9] = "StartOrForward";
    GamepadLayout[GamepadLayout["LeftAnalogPress"] = 10] = "LeftAnalogPress";
    GamepadLayout[GamepadLayout["RightAnalogPress"] = 11] = "RightAnalogPress";
    GamepadLayout[GamepadLayout["LeftClusterTopButton"] = 12] = "LeftClusterTopButton";
    GamepadLayout[GamepadLayout["LeftClusterBottomButton"] = 13] = "LeftClusterBottomButton";
    GamepadLayout[GamepadLayout["LeftClusterLeftButton"] = 14] = "LeftClusterLeftButton";
    GamepadLayout[GamepadLayout["LeftClusterRightButton"] = 15] = "LeftClusterRightButton";
    GamepadLayout[GamepadLayout["CentreButton"] = 16] = "CentreButton";
    // Axes
    GamepadLayout[GamepadLayout["LeftStickHorizontal"] = 0] = "LeftStickHorizontal";
    GamepadLayout[GamepadLayout["LeftStickVertical"] = 1] = "LeftStickVertical";
    GamepadLayout[GamepadLayout["RightStickHorizontal"] = 2] = "RightStickHorizontal";
    GamepadLayout[GamepadLayout["RightStickVertical"] = 3] = "RightStickVertical";
})(GamepadLayout || (GamepadLayout = {}));
/**
 * Handles gamepad events from the document to send to the streamer.
 */
class GamepadController {
    constructor(streamMessageController) {
        this.streamMessageController = streamMessageController;
        this.onGamepadConnectedListener = this.onGamepadConnected.bind(this);
        this.onGamepadDisconnectedListener = this.onGamepadDisconnected.bind(this);
        this.beforeUnloadListener = this.onBeforeUnload.bind(this);
        this.requestAnimationFrame = (window.mozRequestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.requestAnimationFrame).bind(window);
    }
    register() {
        window.addEventListener('beforeunload', this.beforeUnloadListener);
        const browserWindow = window;
        if ('GamepadEvent' in browserWindow) {
            window.addEventListener('gamepadconnected', this.onGamepadConnectedListener);
            window.addEventListener('gamepaddisconnected', this.onGamepadDisconnectedListener);
        }
        else if ('WebKitGamepadEvent' in browserWindow) {
            window.addEventListener('webkitgamepadconnected', this.onGamepadConnectedListener);
            window.addEventListener('webkitgamepaddisconnected', this.onGamepadDisconnectedListener);
        }
        this.controllers = [];
        if (navigator.getGamepads) {
            for (const gamepad of navigator.getGamepads()) {
                if (gamepad) {
                    this.onGamepadConnected(new GamepadEvent('gamepadconnected', { gamepad }));
                }
            }
        }
    }
    unregister() {
        window.removeEventListener('gamepadconnected', this.onGamepadConnectedListener);
        window.removeEventListener('gamepaddisconnected', this.onGamepadDisconnectedListener);
        window.removeEventListener('webkitgamepadconnected', this.onGamepadConnectedListener);
        window.removeEventListener('webkitgamepaddisconnected', this.onGamepadDisconnectedListener);
        for (const controller of this.controllers) {
            if (controller && controller.id !== undefined) {
                this.streamMessageController.toStreamerHandlers.get('GamepadDisconnected')([controller.id]);
            }
        }
        this.controllers = [];
    }
    onGamepadResponseReceived(gamepadId) {
        for (const controller of this.controllers) {
            if (controller && controller.id === undefined) {
                controller.id = gamepadId;
                break;
            }
        }
    }
    onGamepadConnected(event) {
        const gamepad = event.gamepad;
        const newController = {
            currentState: (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(gamepad),
            prevState: (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(gamepad),
            id: undefined
        };
        this.controllers[gamepad.index] = newController;
        window.requestAnimationFrame(() => this.updateStatus());
        this.streamMessageController.toStreamerHandlers.get('GamepadConnected')();
    }
    onGamepadDisconnected(event) {
        const gamepad = event.gamepad;
        const deletedController = this.controllers[gamepad.index];
        delete this.controllers[gamepad.index];
        this.controllers = this.controllers.filter((controller) => controller !== undefined);
        if (deletedController.id !== undefined) {
            this.streamMessageController.toStreamerHandlers.get('GamepadDisconnected')([
                deletedController.id
            ]);
        }
    }
    scanGamepads() {
        const gamepads = navigator.getGamepads
            ? navigator.getGamepads()
            : navigator.webkitGetGamepads
                ? navigator.webkitGetGamepads()
                : [];
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i] && this.controllers[gamepads[i].index] !== undefined) {
                this.controllers[gamepads[i].index].currentState = gamepads[i];
            }
        }
    }
    updateStatus() {
        this.scanGamepads();
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        // Iterate over multiple controllers in the case the multiple gamepads are connected
        for (const controller of this.controllers) {
            if (!controller) {
                continue;
            }
            // If we haven't received an id (possible if using an older version of UE), return to original functionality
            const controllerId = controller.id === undefined ? this.controllers.indexOf(controller) : controller.id;
            const currentState = controller.currentState;
            for (let i = 0; i < controller.currentState.buttons.length; i++) {
                const currentButton = controller.currentState.buttons[i];
                const previousButton = controller.prevState.buttons[i];
                if (currentButton.pressed) {
                    // press
                    if (i == GamepadLayout.LeftTrigger) {
                        // UEs left analog has a button index of 5
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 5, currentButton.value]);
                    }
                    else if (i == GamepadLayout.RightTrigger) {
                        // UEs right analog has a button index of 6
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 6, currentButton.value]);
                    }
                    else {
                        toStreamerHandlers.get('GamepadButtonPressed')([
                            controllerId,
                            i,
                            previousButton.pressed ? 1 : 0
                        ]);
                    }
                }
                else if (!currentButton.pressed && previousButton.pressed) {
                    // release
                    if (i == GamepadLayout.LeftTrigger) {
                        // UEs left analog has a button index of 5
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 5, 0]);
                    }
                    else if (i == GamepadLayout.RightTrigger) {
                        // UEs right analog has a button index of 6
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 6, 0]);
                    }
                    else {
                        toStreamerHandlers.get('GamepadButtonReleased')([controllerId, i, 0]);
                    }
                }
            }
            // Iterate over gamepad axes (we will increment in lots of 2 as there is 2 axes per stick)
            for (let i = 0; i < currentState.axes.length; i += 2) {
                // Horizontal axes are even numbered
                const x = parseFloat(currentState.axes[i].toFixed(4));
                // Vertical axes are odd numbered
                // https://w3c.github.io/gamepad/#remapping Gamepad browser side standard mapping has positive down, negative up. This is downright disgusting. So we fix it.
                const y = -parseFloat(currentState.axes[i + 1].toFixed(4));
                // UE's analog axes follow the same order as the browsers, but start at index 1 so we will offset as such
                toStreamerHandlers.get('GamepadAnalog')([controllerId, i + 1, x]); // Horizontal axes, only offset by 1
                toStreamerHandlers.get('GamepadAnalog')([controllerId, i + 2, y]); // Vertical axes, offset by two (1 to match UEs axes convention and then another 1 for the vertical axes)
            }
            const controllerIndex = this.controllers.indexOf(controller);
            this.controllers[controllerIndex].prevState = (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(currentState);
        }
        if (this.controllers.length > 0) {
            this.requestAnimationFrame(() => this.updateStatus());
        }
    }
    onBeforeUnload(_) {
        // When a user navigates away from the page, we need to inform UE of all the disconnecting
        // controllers
        for (const controller of this.controllers) {
            if (!controller || controller.id === undefined) {
                continue;
            }
            this.streamMessageController.toStreamerHandlers.get('GamepadDisconnected')([controller.id]);
        }
    }
}
//# sourceMappingURL=GamepadController.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/GamepadTypes.js":
/*!*****************************************************!*\
  !*** ../../library/dist/esm/Inputs/GamepadTypes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deepCopyGamepad: () => (/* binding */ deepCopyGamepad)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Deep copies the values from a gamepad by first converting it to a JSON object and then back to a gamepad
 *
 * @param gamepad the original gamepad
 * @returns a new gamepad object, populated with the original gamepads values
 */
function deepCopyGamepad(gamepad) {
    return JSON.parse(JSON.stringify({
        buttons: gamepad.buttons.map((b) => JSON.parse(JSON.stringify({
            pressed: b.pressed,
            touched: b.touched,
            value: b.value
        }))),
        axes: gamepad.axes
    }));
}
//# sourceMappingURL=GamepadTypes.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/InputClassesFactory.js":
/*!************************************************************!*\
  !*** ../../library/dist/esm/Inputs/InputClassesFactory.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActiveKeys: () => (/* binding */ ActiveKeys),
/* harmony export */   InputClassesFactory: () => (/* binding */ InputClassesFactory)
/* harmony export */ });
/* harmony import */ var _KeyboardController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KeyboardController */ "../../library/dist/esm/Inputs/KeyboardController.js");
/* harmony import */ var _MouseControllerLocked__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MouseControllerLocked */ "../../library/dist/esm/Inputs/MouseControllerLocked.js");
/* harmony import */ var _MouseControllerHovering__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MouseControllerHovering */ "../../library/dist/esm/Inputs/MouseControllerHovering.js");
/* harmony import */ var _TouchController__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TouchController */ "../../library/dist/esm/Inputs/TouchController.js");
/* harmony import */ var _TouchControllerFake__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TouchControllerFake */ "../../library/dist/esm/Inputs/TouchControllerFake.js");
/* harmony import */ var _GamepadController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GamepadController */ "../../library/dist/esm/Inputs/GamepadController.js");
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.








/**
 * Class for making and setting up input class types
 */
class InputClassesFactory {
    /**
     * @param toStreamerMessagesProvider - Stream message instance
     * @param videoElementProvider - Video Player instance
     * @param coordinateConverter - A coordinateConverter instance
     */
    constructor(toStreamerMessagesProvider, videoElementProvider, coordinateConverter) {
        this.activeKeys = new ActiveKeys();
        this.toStreamerMessagesProvider = toStreamerMessagesProvider;
        this.videoElementProvider = videoElementProvider;
        this.coordinateConverter = coordinateConverter;
    }
    /**
     * Registers browser key events.
     */
    registerKeyBoard(config) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Register Keyboard Events');
        const keyboardController = new _KeyboardController__WEBPACK_IMPORTED_MODULE_1__.KeyboardController(this.toStreamerMessagesProvider, config, this.activeKeys);
        keyboardController.register();
        return keyboardController;
    }
    /**
     * register mouse events based on a control type
     * @param controlScheme - if the mouse is either hovering or locked
     */
    registerMouse(controlScheme) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Register Mouse Events');
        let mouseController;
        if (controlScheme == _Config_Config__WEBPACK_IMPORTED_MODULE_2__.ControlSchemeType.HoveringMouse) {
            mouseController = new _MouseControllerHovering__WEBPACK_IMPORTED_MODULE_3__.MouseControllerHovering(this.toStreamerMessagesProvider, this.videoElementProvider, this.coordinateConverter, this.activeKeys);
        }
        else {
            mouseController = new _MouseControllerLocked__WEBPACK_IMPORTED_MODULE_4__.MouseControllerLocked(this.toStreamerMessagesProvider, this.videoElementProvider, this.coordinateConverter, this.activeKeys);
        }
        mouseController.register();
        return mouseController;
    }
    /**
     * register touch events
     * @param fakeMouseTouch - the faked mouse touch event
     */
    registerTouch(fakeMouseTouch) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Registering Touch');
        let touchController;
        if (fakeMouseTouch) {
            touchController = new _TouchControllerFake__WEBPACK_IMPORTED_MODULE_5__.TouchControllerFake(this.toStreamerMessagesProvider, this.videoElementProvider, this.coordinateConverter);
        }
        else {
            touchController = new _TouchController__WEBPACK_IMPORTED_MODULE_6__.TouchController(this.toStreamerMessagesProvider, this.videoElementProvider, this.coordinateConverter);
        }
        touchController.register();
        return touchController;
    }
    /**
     * registers a gamepad
     */
    registerGamePad() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Register Game Pad');
        const gamepadController = new _GamepadController__WEBPACK_IMPORTED_MODULE_7__.GamepadController(this.toStreamerMessagesProvider);
        gamepadController.register();
        return gamepadController;
    }
}
/**
 * A class that keeps track of current active keys
 */
class ActiveKeys {
    constructor() {
        this.activeKeys = [];
        this.activeKeys = [];
    }
    /**
     * Get the current array of active keys
     * @returns - an array of active keys
     */
    getActiveKeys() {
        return this.activeKeys;
    }
}
//# sourceMappingURL=InputClassesFactory.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/KeyCodes.js":
/*!*************************************************!*\
  !*** ../../library/dist/esm/Inputs/KeyCodes.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CodeToKeyCode: () => (/* binding */ CodeToKeyCode)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/*
 * New browser APIs have moved away from KeyboardEvent.keyCode to KeyboardEvent.Code.
 * For details see: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#constants_for_keycode_value
 * We still use old KeyboardEvent.keyCode integers in the UE C++ side, so we need a way to map the new
 * string-based KeyboardEvent.Code to the old integers.
 */
const CodeToKeyCode = Object.freeze({
    Escape: 27,
    Digit0: 48,
    Digit1: 49,
    Digit2: 50,
    Digit3: 51,
    Digit4: 52,
    Digit5: 53,
    Digit6: 54,
    Digit7: 55,
    Digit8: 56,
    Digit9: 57,
    Minus: 173,
    Equal: 187,
    Backspace: 8,
    Tab: 9,
    KeyQ: 81,
    KeyW: 87,
    KeyE: 69,
    KeyR: 82,
    KeyT: 84,
    KeyY: 89,
    KeyU: 85,
    KeyI: 73,
    KeyO: 79,
    KeyP: 80,
    BracketLeft: 219,
    BracketRight: 221,
    Enter: 13,
    ControlLeft: 17,
    KeyA: 65,
    KeyS: 83,
    KeyD: 68,
    KeyF: 70,
    KeyG: 71,
    KeyH: 72,
    KeyJ: 74,
    KeyK: 75,
    KeyL: 76,
    Semicolon: 186,
    Quote: 222,
    Backquote: 192,
    ShiftLeft: 16,
    Backslash: 220,
    KeyZ: 90,
    KeyX: 88,
    KeyC: 67,
    KeyV: 86,
    KeyB: 66,
    KeyN: 78,
    KeyM: 77,
    Comma: 188,
    Period: 190,
    Slash: 191,
    ShiftRight: 253,
    AltLeft: 18,
    Space: 32,
    CapsLock: 20,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    Pause: 19,
    ScrollLock: 145,
    NumpadDivide: 111,
    NumpadMultiply: 106,
    NumpadSubtract: 109,
    NumpadAdd: 107,
    NumpadDecimal: 110,
    Numpad9: 105,
    Numpad8: 104,
    Numpad7: 103,
    Numpad6: 102,
    Numpad5: 101,
    Numpad4: 100,
    Numpad3: 99,
    Numpad2: 98,
    Numpad1: 97,
    Numpad0: 96,
    NumLock: 144,
    ControlRight: 254,
    AltRight: 255,
    Home: 36,
    End: 35,
    ArrowUp: 38,
    ArrowLeft: 37,
    ArrowRight: 39,
    ArrowDown: 40,
    PageUp: 33,
    PageDown: 34,
    Insert: 45,
    Delete: 46,
    ContextMenu: 93
});
//# sourceMappingURL=KeyCodes.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/KeyboardController.js":
/*!***********************************************************!*\
  !*** ../../library/dist/esm/Inputs/KeyboardController.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeyboardController: () => (/* binding */ KeyboardController)
/* harmony export */ });
/* harmony import */ var _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SpecialKeyCodes */ "../../library/dist/esm/Inputs/SpecialKeyCodes.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _KeyCodes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./KeyCodes */ "../../library/dist/esm/Inputs/KeyCodes.js");
// Copyright Epic Games, Inc. All Rights Reserved.




/**
 * Handles the Keyboard Inputs for the document
 */
class KeyboardController {
    constructor(streamMessageController, config, activeKeys) {
        this.streamMessageController = streamMessageController;
        this.config = config;
        this.activeKeys = activeKeys;
        this.onKeyDownListener = this.handleOnKeyDown.bind(this);
        this.onKeyUpListener = this.handleOnKeyUp.bind(this);
        this.onKeyPressListener = this.handleOnKeyPress.bind(this);
    }
    register() {
        document.addEventListener('keydown', this.onKeyDownListener);
        document.addEventListener('keyup', this.onKeyUpListener);
        //This has been deprecated as at Jun 13 2021
        document.addEventListener('keypress', this.onKeyPressListener);
    }
    unregister() {
        document.removeEventListener('keydown', this.onKeyDownListener);
        document.removeEventListener('keyup', this.onKeyUpListener);
        document.removeEventListener('keypress', this.onKeyPressListener);
    }
    handleOnKeyDown(keyboardEvent) {
        var _a;
        const keyCode = this.getKeycode(keyboardEvent);
        if (!keyCode || keyCode === 229) {
            return;
        }
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        (_a = toStreamerHandlers.get('KeyDown')) === null || _a === void 0 ? void 0 : _a([this.getKeycode(keyboardEvent), keyboardEvent.repeat ? 1 : 0]);
        const activeKeys = this.activeKeys.getActiveKeys();
        activeKeys.push(keyCode);
        // Backspace is not considered a keypress in JavaScript but we need it
        // to be so characters may be deleted in a UE text entry field.
        // since keypress is deprecated we really should be sending all keys to keypress
        // or we change everything to handle the deprecation of these parts
        if (keyCode === _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.backSpace) {
            this.handleOnKeyPress(new KeyboardEvent('keypress', {
                charCode: _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.backSpace,
                keyCode: _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.backSpace
            }));
        }
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.SuppressBrowserKeys) && this.isKeyCodeBrowserKey(keyCode)) {
            keyboardEvent.preventDefault();
        }
    }
    handleOnKeyUp(keyboardEvent) {
        var _a;
        const keyCode = this.getKeycode(keyboardEvent);
        if (!keyCode) {
            return;
        }
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        (_a = toStreamerHandlers.get('KeyUp')) === null || _a === void 0 ? void 0 : _a([keyCode]);
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.SuppressBrowserKeys) && this.isKeyCodeBrowserKey(keyCode)) {
            keyboardEvent.preventDefault();
        }
    }
    handleOnKeyPress(keyboardEvent) {
        var _a;
        const keyCode = this.getKeycode(keyboardEvent);
        if (!keyCode) {
            return;
        }
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        (_a = toStreamerHandlers.get('KeyPress')) === null || _a === void 0 ? void 0 : _a([keyCode]);
    }
    /**
     * Gets the Keycode of the Key pressed
     * @param keyboardEvent - Key board Event
     * @returns - the key code of the Key
     */
    getKeycode(keyboardEvent) {
        // If we don't have keyCode property because browser API is deprecated then use KeyboardEvent.code instead.
        // See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#constants_for_keycode_value
        if (!('keyCode' in keyboardEvent)) {
            // this type assertion here is required because if 'keyCode' doesnt exist in keyboardEvent then
            // it cannot be a KeyboardEvent and so it gets narrowed to 'never'
            const event = keyboardEvent;
            // Convert KeyboardEvent.code string into integer-based key code for backwards compatibility reasons.
            if (event.code in _KeyCodes__WEBPACK_IMPORTED_MODULE_2__.CodeToKeyCode) {
                return _KeyCodes__WEBPACK_IMPORTED_MODULE_2__.CodeToKeyCode[event.code];
            }
            else {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Keyboard code of ${event.code} is not supported in our mapping, ignoring this key.`);
                return null;
            }
        }
        // If we made it here KeyboardEvent.keyCode is still supported so we can safely use it.
        if (keyboardEvent.keyCode === _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.shift && keyboardEvent.code === 'ShiftRight') {
            return _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.rightShift;
        }
        else if (keyboardEvent.keyCode === _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.control &&
            keyboardEvent.code === 'ControlRight') {
            return _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.rightControl;
        }
        else if (keyboardEvent.keyCode === _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.alt && keyboardEvent.code === 'AltRight') {
            return _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.rightAlt;
        }
        else {
            return keyboardEvent.keyCode;
        }
    }
    /**
     * Browser keys do not have a charCode so we only need to test keyCode.
     * @param keyCode - the browser keycode number
     */
    isKeyCodeBrowserKey(keyCode) {
        // Function keys or tab key are considered "browser keys" that we may wish to suppress by preventing them being process by browser.
        return (keyCode >= 112 && keyCode <= 123) || keyCode === 9;
    }
}
//# sourceMappingURL=KeyboardController.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/MouseButtons.js":
/*!*****************************************************!*\
  !*** ../../library/dist/esm/Inputs/MouseButtons.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MouseButton: () => (/* binding */ MouseButton),
/* harmony export */   MouseButtonsMask: () => (/* binding */ MouseButtonsMask)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Mouse Button Data
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button}
 */
class MouseButton {
}
MouseButton.mainButton = 0; // Left button.
MouseButton.auxiliaryButton = 1; // Wheel button.
MouseButton.secondaryButton = 2; // Right button.
MouseButton.fourthButton = 3; // Browser Back button.
MouseButton.fifthButton = 4; // Browser Forward button.
/**
 * Mouse Button Mask Data
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons}
 */
class MouseButtonsMask {
}
MouseButtonsMask.primaryButton = 1; // Left button.
MouseButtonsMask.secondaryButton = 2; // Right button.
MouseButtonsMask.auxiliaryButton = 4; // Wheel button.
MouseButtonsMask.fourthButton = 8; // Browser Back button.
MouseButtonsMask.fifthButton = 16; // Browser Forward button.
//# sourceMappingURL=MouseButtons.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/MouseController.js":
/*!********************************************************!*\
  !*** ../../library/dist/esm/Inputs/MouseController.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MouseController: () => (/* binding */ MouseController)
/* harmony export */ });
/* harmony import */ var _MouseButtons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MouseButtons */ "../../library/dist/esm/Inputs/MouseButtons.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * The base class for mouse controllers. Since there is a bunch of shared behaviour between locked and
 * hover mouse controllers this is where that shared behaviour lives.
 */
class MouseController {
    constructor(streamMessageController, videoPlayer, coordinateConverter, activeKeys) {
        this.streamMessageController = streamMessageController;
        this.coordinateConverter = coordinateConverter;
        this.videoPlayer = videoPlayer;
        this.activeKeys = activeKeys;
        this.onEnterListener = this.onMouseEnter.bind(this);
        this.onLeaveListener = this.onMouseLeave.bind(this);
    }
    register() {
        this.registerMouseEnterAndLeaveEvents();
    }
    unregister() {
        this.unregisterMouseEnterAndLeaveEvents();
    }
    registerMouseEnterAndLeaveEvents() {
        const videoElementParent = this.videoPlayer.getVideoParentElement();
        videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.addEventListener('mouseenter', this.onEnterListener);
        videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.addEventListener('mouseleave', this.onLeaveListener);
    }
    unregisterMouseEnterAndLeaveEvents() {
        const videoElementParent = this.videoPlayer.getVideoParentElement();
        videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.removeEventListener('mouseenter', this.onEnterListener);
        videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.removeEventListener('mouseleave', this.onLeaveListener);
    }
    onMouseEnter(event) {
        var _a;
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        (_a = this.streamMessageController.toStreamerHandlers.get('MouseEnter')) === null || _a === void 0 ? void 0 : _a();
        this.pressMouseButtons(event.buttons, event.x, event.y);
    }
    onMouseLeave(event) {
        var _a;
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        (_a = this.streamMessageController.toStreamerHandlers.get('MouseLeave')) === null || _a === void 0 ? void 0 : _a();
        this.releaseMouseButtons(event.buttons, event.x, event.y);
    }
    releaseMouseButtons(buttons, X, Y) {
        const coord = this.coordinateConverter.translateUnsigned(X, Y);
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.primaryButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.mainButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.secondaryButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.secondaryButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.auxiliaryButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.auxiliaryButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.fourthButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.fourthButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.fifthButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.fifthButton, coord.x, coord.y);
        }
    }
    pressMouseButtons(buttons, X, Y) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(X, Y);
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.primaryButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.mainButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.secondaryButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.secondaryButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.auxiliaryButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.auxiliaryButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.fourthButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.fourthButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.fifthButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.fifthButton, coord.x, coord.y);
        }
    }
    sendMouseDown(button, X, Y) {
        var _a;
        (_a = this.streamMessageController.toStreamerHandlers.get('MouseDown')) === null || _a === void 0 ? void 0 : _a([button, X, Y]);
    }
    sendMouseUp(button, X, Y) {
        var _a;
        const coord = this.coordinateConverter.translateUnsigned(X, Y);
        (_a = this.streamMessageController.toStreamerHandlers.get('MouseUp')) === null || _a === void 0 ? void 0 : _a([button, coord.x, coord.y]);
    }
}
//# sourceMappingURL=MouseController.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/MouseControllerHovering.js":
/*!****************************************************************!*\
  !*** ../../library/dist/esm/Inputs/MouseControllerHovering.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MouseControllerHovering: () => (/* binding */ MouseControllerHovering)
/* harmony export */ });
/* harmony import */ var _MouseController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MouseController */ "../../library/dist/esm/Inputs/MouseController.js");

/**
 * A mouse controller that allows the mouse to freely float over the video document.
 */
class MouseControllerHovering extends _MouseController__WEBPACK_IMPORTED_MODULE_0__.MouseController {
    constructor(streamMessageController, videoPlayer, coordinateConverter, activeKeys) {
        super(streamMessageController, videoPlayer, coordinateConverter, activeKeys);
        this.videoElementParent = videoPlayer.getVideoParentElement();
        this.onMouseUpListener = this.onMouseUp.bind(this);
        this.onMouseDownListener = this.onMouseDown.bind(this);
        this.onMouseDblClickListener = this.onMouseDblClick.bind(this);
        this.onMouseWheelListener = this.onMouseWheel.bind(this);
        this.onMouseMoveListener = this.onMouseMove.bind(this);
        this.onContextMenuListener = this.onContextMenu.bind(this);
    }
    register() {
        super.register();
        this.videoElementParent.addEventListener('mousemove', this.onMouseMoveListener);
        this.videoElementParent.addEventListener('mousedown', this.onMouseDownListener);
        this.videoElementParent.addEventListener('mouseup', this.onMouseUpListener);
        this.videoElementParent.addEventListener('contextmenu', this.onContextMenuListener);
        this.videoElementParent.addEventListener('wheel', this.onMouseWheelListener);
        this.videoElementParent.addEventListener('dblclick', this.onMouseDblClickListener);
    }
    unregister() {
        this.videoElementParent.removeEventListener('mousemove', this.onMouseMoveListener);
        this.videoElementParent.removeEventListener('mousedown', this.onMouseDownListener);
        this.videoElementParent.removeEventListener('mouseup', this.onMouseUpListener);
        this.videoElementParent.removeEventListener('contextmenu', this.onContextMenuListener);
        this.videoElementParent.removeEventListener('wheel', this.onMouseWheelListener);
        this.videoElementParent.removeEventListener('dblclick', this.onMouseDblClickListener);
        super.unregister();
    }
    onMouseDown(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        this.streamMessageController.toStreamerHandlers.get('MouseDown')([event.button, coord.x, coord.y]);
        event.preventDefault();
    }
    onMouseUp(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        this.streamMessageController.toStreamerHandlers.get('MouseUp')([event.button, coord.x, coord.y]);
        event.preventDefault();
    }
    onContextMenu(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        event.preventDefault();
    }
    onMouseMove(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        const delta = this.coordinateConverter.translateSigned(event.movementX, event.movementY);
        this.streamMessageController.toStreamerHandlers.get('MouseMove')([
            coord.x,
            coord.y,
            delta.x,
            delta.y
        ]);
        event.preventDefault();
    }
    onMouseWheel(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        this.streamMessageController.toStreamerHandlers.get('MouseWheel')([
            event.wheelDelta,
            coord.x,
            coord.y
        ]);
        event.preventDefault();
    }
    onMouseDblClick(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        this.streamMessageController.toStreamerHandlers.get('MouseDouble')([event.button, coord.x, coord.y]);
    }
}
//# sourceMappingURL=MouseControllerHovering.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/MouseControllerLocked.js":
/*!**************************************************************!*\
  !*** ../../library/dist/esm/Inputs/MouseControllerLocked.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MouseControllerLocked: () => (/* binding */ MouseControllerLocked)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _MouseController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MouseController */ "../../library/dist/esm/Inputs/MouseController.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * A mouse controller that locks the mouse to the video document and prevents it from leaving the window
 */
class MouseControllerLocked extends _MouseController__WEBPACK_IMPORTED_MODULE_0__.MouseController {
    constructor(streamMessageController, videoPlayer, coordinateConverter, activeKeys) {
        super(streamMessageController, videoPlayer, coordinateConverter, activeKeys);
        this.videoElementParent = videoPlayer.getVideoParentElement();
        this.x = this.videoElementParent.getBoundingClientRect().width / 2;
        this.y = this.videoElementParent.getBoundingClientRect().height / 2;
        this.normalizedCoord = this.coordinateConverter.translateUnsigned(this.x, this.y);
        this.onRequestLockListener = this.onRequestLock.bind(this);
        this.onLockStateChangeListener = this.onLockStateChange.bind(this);
        this.onMouseUpListener = this.onMouseUp.bind(this);
        this.onMouseDownListener = this.onMouseDown.bind(this);
        this.onMouseDblClickListener = this.onMouseDblClick.bind(this);
        this.onMouseWheelListener = this.onMouseWheel.bind(this);
        this.onMouseMoveListener = this.onMouseMove.bind(this);
    }
    register() {
        super.register();
        this.videoElementParent.requestPointerLock =
            this.videoElementParent.requestPointerLock || this.videoElementParent.mozRequestPointerLock;
        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
        if (this.videoElementParent.requestPointerLock) {
            this.videoElementParent.addEventListener('click', this.onRequestLockListener);
        }
        document.addEventListener('pointerlockchange', this.onLockStateChangeListener);
        document.addEventListener('mozpointerlockchange', this.onLockStateChangeListener);
        this.videoElementParent.addEventListener('mousedown', this.onMouseDownListener);
        this.videoElementParent.addEventListener('mouseup', this.onMouseUpListener);
        this.videoElementParent.addEventListener('wheel', this.onMouseWheelListener);
        this.videoElementParent.addEventListener('dblclick', this.onMouseDblClickListener);
    }
    unregister() {
        const pointerLockElement = document.pointerLockElement || document.mozPointerLockElement;
        if (document.exitPointerLock && pointerLockElement === this.videoElementParent) {
            document.exitPointerLock();
        }
        this.videoElementParent.removeEventListener('click', this.onRequestLockListener);
        document.removeEventListener('pointerlockchange', this.onLockStateChangeListener);
        document.removeEventListener('mozpointerlockchange', this.onLockStateChangeListener);
        document.removeEventListener('mousemove', this.onMouseMoveListener);
        this.videoElementParent.removeEventListener('mousedown', this.onMouseDownListener);
        this.videoElementParent.removeEventListener('mouseup', this.onMouseUpListener);
        this.videoElementParent.removeEventListener('wheel', this.onMouseWheelListener);
        this.videoElementParent.removeEventListener('dblclick', this.onMouseDblClickListener);
        super.unregister();
    }
    onRequestLock() {
        this.videoElementParent.requestPointerLock();
    }
    onLockStateChange() {
        const pointerLockElement = document.pointerLockElement || document.mozPointerLockElement;
        if (pointerLockElement === this.videoElementParent) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Pointer locked');
            document.addEventListener('mousemove', this.onMouseMoveListener);
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('The pointer lock status is now unlocked');
            document.removeEventListener('mousemove', this.onMouseMoveListener);
            // If mouse loses focus, send a key up for all of the currently held-down keys
            // This is necessary as when the mouse loses focus, the windows stops listening for events and as such
            // the keyup listener won't get fired
            const activeKeys = this.activeKeys.getActiveKeys();
            activeKeys.forEach((key) => {
                this.streamMessageController.toStreamerHandlers.get('KeyUp')([key]);
            });
        }
    }
    onMouseDown(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.streamMessageController.toStreamerHandlers.get('MouseDown')([
            event.button,
            // We use the store value of this.coord as opposed to the mouseEvent.x/y as the mouseEvent location
            // uses the system cursor location which hasn't moved
            this.normalizedCoord.x,
            this.normalizedCoord.y
        ]);
    }
    onMouseUp(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.streamMessageController.toStreamerHandlers.get('MouseUp')([
            event.button,
            // We use the store value of this.coord as opposed to the mouseEvent.x/y as the mouseEvent location
            // uses the system cursor location which hasn't moved
            this.normalizedCoord.x,
            this.normalizedCoord.y
        ]);
    }
    onMouseMove(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const styleWidth = this.videoPlayer.getVideoParentElement().clientWidth;
        const styleHeight = this.videoPlayer.getVideoParentElement().clientHeight;
        this.x += event.movementX;
        this.y += event.movementY;
        while (this.x > styleWidth) {
            this.x -= styleWidth;
        }
        while (this.y > styleHeight) {
            this.y -= styleHeight;
        }
        while (this.x < 0) {
            this.x += styleWidth;
        }
        while (this.y < 0) {
            this.y += styleHeight;
        }
        this.normalizedCoord = this.coordinateConverter.translateUnsigned(this.x, this.y);
        const delta = this.coordinateConverter.translateSigned(event.movementX, event.movementY);
        this.streamMessageController.toStreamerHandlers.get('MouseMove')([
            this.normalizedCoord.x,
            this.normalizedCoord.y,
            delta.x,
            delta.y
        ]);
    }
    onMouseWheel(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.streamMessageController.toStreamerHandlers.get('MouseWheel')([
            event.wheelDelta,
            // We use the store value of this.coord as opposed to the mouseEvent.x/y as the mouseEvent location
            // uses the system cursor location which hasn't moved
            this.normalizedCoord.x,
            this.normalizedCoord.y
        ]);
    }
    onMouseDblClick(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.streamMessageController.toStreamerHandlers.get('MouseDouble')([
            event.button,
            // We use the store value of this.coord as opposed to the mouseEvent.x/y as the mouseEvent location
            // uses the system cursor location which hasn't moved
            this.normalizedCoord.x,
            this.normalizedCoord.y
        ]);
    }
}
//# sourceMappingURL=MouseControllerLocked.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/SpecialKeyCodes.js":
/*!********************************************************!*\
  !*** ../../library/dist/esm/Inputs/SpecialKeyCodes.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpecialKeyCodes: () => (/* binding */ SpecialKeyCodes)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Registers the Special Key codes
 *  Must be kept in sync with JavaScriptKeyCodeToFKey C++ array.
 * The index of the entry in the array is the special key code given below.
 */
class SpecialKeyCodes {
}
SpecialKeyCodes.backSpace = 8;
SpecialKeyCodes.shift = 16;
SpecialKeyCodes.control = 17;
SpecialKeyCodes.alt = 18;
SpecialKeyCodes.rightShift = 253;
SpecialKeyCodes.rightControl = 254;
SpecialKeyCodes.rightAlt = 255;
//# sourceMappingURL=SpecialKeyCodes.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/TouchController.js":
/*!********************************************************!*\
  !*** ../../library/dist/esm/Inputs/TouchController.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TouchController: () => (/* binding */ TouchController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * The basic touch controller that handles the touch events on the document.
 */
class TouchController {
    constructor(streamMessageController, videoPlayer, coordinateConverter) {
        this.fingers = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0];
        this.fingerIds = new Map();
        this.maxByteValue = 255;
        this.streamMessageController = streamMessageController;
        this.videoPlayer = videoPlayer;
        this.coordinateConverter = coordinateConverter;
        this.videoElementParent = videoPlayer.getVideoElement();
        this.onTouchStartListener = this.onTouchStart.bind(this);
        this.onTouchEndListener = this.onTouchEnd.bind(this);
        this.onTouchMoveListener = this.onTouchMove.bind(this);
    }
    register() {
        this.videoElementParent.addEventListener('touchstart', this.onTouchStartListener);
        this.videoElementParent.addEventListener('touchend', this.onTouchEndListener);
        this.videoElementParent.addEventListener('touchmove', this.onTouchMoveListener);
    }
    unregister() {
        this.videoElementParent.removeEventListener('touchstart', this.onTouchStartListener);
        this.videoElementParent.removeEventListener('touchend', this.onTouchEndListener);
        this.videoElementParent.removeEventListener('touchmove', this.onTouchMoveListener);
    }
    rememberTouch(touch) {
        const finger = this.fingers.pop();
        if (finger === undefined) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('exhausted touch identifiers');
        }
        this.fingerIds.set(touch.identifier, finger);
    }
    forgetTouch(touch) {
        this.fingers.push(this.fingerIds.get(touch.identifier));
        // Sort array back into descending order. This means if finger '1' were to lift after finger '0', we would ensure that 0 will be the first index to pop
        this.fingers.sort(function (a, b) {
            return b - a;
        });
        this.fingerIds.delete(touch.identifier);
    }
    onTouchStart(touchEvent) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        for (let t = 0; t < touchEvent.changedTouches.length; t++) {
            this.rememberTouch(touchEvent.changedTouches[t]);
        }
        this.emitTouchData('TouchStart', touchEvent.changedTouches);
        touchEvent.preventDefault();
    }
    onTouchEnd(touchEvent) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.emitTouchData('TouchEnd', touchEvent.changedTouches);
        // Re-cycle unique identifiers previously assigned to each touch.
        for (let t = 0; t < touchEvent.changedTouches.length; t++) {
            this.forgetTouch(touchEvent.changedTouches[t]);
        }
        touchEvent.preventDefault();
    }
    onTouchMove(touchEvent) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.emitTouchData('TouchMove', touchEvent.touches);
        touchEvent.preventDefault();
    }
    emitTouchData(type, touches) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const offset = this.videoPlayer.getVideoParentElement().getBoundingClientRect();
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        for (let t = 0; t < touches.length; t++) {
            const numTouches = 1; // the number of touches to be sent this message
            const touch = touches[t];
            const x = touch.clientX - offset.left;
            const y = touch.clientY - offset.top;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`F${this.fingerIds.get(touch.identifier)}=(${x}, ${y})`);
            const coord = this.coordinateConverter.translateUnsigned(x, y);
            switch (type) {
                case 'TouchStart':
                    toStreamerHandlers.get('TouchStart')([
                        numTouches,
                        coord.x,
                        coord.y,
                        this.fingerIds.get(touch.identifier),
                        this.maxByteValue * (touch.force > 0 ? touch.force : 1),
                        coord.inRange ? 1 : 0
                    ]);
                    break;
                case 'TouchEnd':
                    toStreamerHandlers.get('TouchEnd')([
                        numTouches,
                        coord.x,
                        coord.y,
                        this.fingerIds.get(touch.identifier),
                        this.maxByteValue * touch.force,
                        coord.inRange ? 1 : 0
                    ]);
                    break;
                case 'TouchMove':
                    toStreamerHandlers.get('TouchMove')([
                        numTouches,
                        coord.x,
                        coord.y,
                        this.fingerIds.get(touch.identifier),
                        this.maxByteValue * (touch.force > 0 ? touch.force : 1),
                        coord.inRange ? 1 : 0
                    ]);
                    break;
            }
        }
    }
}
//# sourceMappingURL=TouchController.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/TouchControllerFake.js":
/*!************************************************************!*\
  !*** ../../library/dist/esm/Inputs/TouchControllerFake.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TouchControllerFake: () => (/* binding */ TouchControllerFake)
/* harmony export */ });
/* harmony import */ var _MouseButtons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MouseButtons */ "../../library/dist/esm/Inputs/MouseButtons.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Allows for the usage of fake touch events
 */
class TouchControllerFake {
    constructor(streamMessageController, videoPlayer, coordinateConverter) {
        this.streamMessageController = streamMessageController;
        this.videoPlayer = videoPlayer;
        this.coordinateConverter = coordinateConverter;
        this.onTouchStartListener = this.onTouchStart.bind(this);
        this.onTouchEndListener = this.onTouchEnd.bind(this);
        this.onTouchMoveListener = this.onTouchMove.bind(this);
        this.videoElementParentClientRect = this.videoPlayer.getVideoParentElement().getBoundingClientRect();
    }
    register() {
        document.addEventListener('touchstart', this.onTouchStartListener);
        document.addEventListener('touchend', this.onTouchEndListener);
        document.addEventListener('touchmove', this.onTouchMoveListener);
    }
    unregister() {
        document.removeEventListener('touchstart', this.onTouchStartListener);
        document.removeEventListener('touchend', this.onTouchEndListener);
        document.removeEventListener('touchmove', this.onTouchMoveListener);
    }
    onTouchStart(touch) {
        if (!this.videoPlayer.isVideoReady() || touch.target !== this.videoPlayer.getVideoElement()) {
            return;
        }
        if (this.fakeTouchFinger == null) {
            const first_touch = touch.changedTouches[0];
            this.fakeTouchFinger = {
                id: first_touch.identifier,
                x: first_touch.clientX - this.videoElementParentClientRect.left,
                y: first_touch.clientY - this.videoElementParentClientRect.top
            };
            const videoElementParent = this.videoPlayer.getVideoParentElement();
            const mouseEvent = new MouseEvent('mouseenter', first_touch);
            videoElementParent.dispatchEvent(mouseEvent);
            const coord = this.coordinateConverter.translateUnsigned(this.fakeTouchFinger.x, this.fakeTouchFinger.y);
            const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
            toStreamerHandlers.get('MouseDown')([_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.mainButton, coord.x, coord.y]);
        }
        touch.preventDefault();
    }
    onTouchEnd(touchEvent) {
        if (!this.videoPlayer.isVideoReady() || this.fakeTouchFinger == null) {
            return;
        }
        const videoElementParent = this.videoPlayer.getVideoParentElement();
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        for (let t = 0; t < touchEvent.changedTouches.length; t++) {
            const touch = touchEvent.changedTouches[t];
            if (touch.identifier === this.fakeTouchFinger.id) {
                const x = touch.clientX - this.videoElementParentClientRect.left;
                const y = touch.clientY - this.videoElementParentClientRect.top;
                const coord = this.coordinateConverter.translateUnsigned(x, y);
                toStreamerHandlers.get('MouseUp')([_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.mainButton, coord.x, coord.y]);
                const mouseEvent = new MouseEvent('mouseleave', touch);
                videoElementParent.dispatchEvent(mouseEvent);
                this.fakeTouchFinger = null;
                break;
            }
        }
        touchEvent.preventDefault();
    }
    onTouchMove(touchEvent) {
        if (!this.videoPlayer.isVideoReady() || this.fakeTouchFinger == null) {
            return;
        }
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        for (let t = 0; t < touchEvent.touches.length; t++) {
            const touch = touchEvent.touches[t];
            if (touch.identifier === this.fakeTouchFinger.id) {
                const x = touch.clientX - this.videoElementParentClientRect.left;
                const y = touch.clientY - this.videoElementParentClientRect.top;
                const coord = this.coordinateConverter.translateUnsigned(x, y);
                const delta = this.coordinateConverter.translateSigned(x - this.fakeTouchFinger.x, y - this.fakeTouchFinger.y);
                toStreamerHandlers.get('MouseMove')([coord.x, coord.y, delta.x, delta.y]);
                this.fakeTouchFinger.x = x;
                this.fakeTouchFinger.y = y;
                break;
            }
        }
        touchEvent.preventDefault();
    }
}
//# sourceMappingURL=TouchControllerFake.js.map

/***/ }),

/***/ "../../library/dist/esm/Inputs/XRGamepadController.js":
/*!************************************************************!*\
  !*** ../../library/dist/esm/Inputs/XRGamepadController.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   XRGamepadController: () => (/* binding */ XRGamepadController)
/* harmony export */ });
/* harmony import */ var _GamepadTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GamepadTypes */ "../../library/dist/esm/Inputs/GamepadTypes.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * The class that handles the functionality of XR gamepads and controllers.
 */
class XRGamepadController {
    /**
     * @param toStreamerMessagesProvider - Stream message instance
     */
    constructor(toStreamerMessagesProvider) {
        this.toStreamerMessagesProvider = toStreamerMessagesProvider;
        this.controllers = [];
    }
    updateStatus(source, frame, refSpace) {
        if (source.gamepad) {
            const gamepadPose = frame.getPose(source.gripSpace, refSpace);
            if (!gamepadPose) {
                return;
            }
            let system = 0;
            if (source.profiles.includes('htc-vive')) {
                system = 1;
            }
            else if (source.profiles.includes('oculus-touch')) {
                system = 2;
            }
            // TODO (william.belcher): Add other profiles (Quest, Microsoft Mixed Reality, etc)
            this.toStreamerMessagesProvider.toStreamerHandlers.get('XRSystem')([system]);
            // Default: AnyHand (2)
            let handedness = 2;
            switch (source.handedness) {
                case 'left':
                    handedness = 0;
                    break;
                case 'right':
                    handedness = 1;
                    break;
            }
            // Send controller transform
            const matrix = gamepadPose.transform.matrix;
            const mat = [];
            for (let i = 0; i < 16; i++) {
                mat[i] = new Float32Array([matrix[i]])[0];
            }
            // prettier-ignore
            this.toStreamerMessagesProvider.toStreamerHandlers.get('XRControllerTransform')([
                mat[0], mat[4], mat[8], mat[12],
                mat[1], mat[5], mat[9], mat[13],
                mat[2], mat[6], mat[10], mat[14],
                mat[3], mat[7], mat[11], mat[15],
                handedness
            ]);
            // Handle controller buttons and axes
            if (this.controllers[handedness] === undefined) {
                this.controllers[handedness] = {
                    prevState: undefined,
                    currentState: undefined,
                    id: undefined
                };
                this.controllers[handedness].prevState = (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(source.gamepad);
            }
            this.controllers[handedness].currentState = (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(source.gamepad);
            const controller = this.controllers[handedness];
            const currState = controller.currentState;
            const prevState = controller.prevState;
            // Iterate over buttons
            for (let i = 0; i < currState.buttons.length; i++) {
                const currButton = currState.buttons[i];
                const prevButton = prevState.buttons[i];
                if (currButton.pressed) {
                    // press
                    const isRepeat = prevButton.pressed ? 1 : 0;
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRButtonPressed')([
                        handedness,
                        i,
                        isRepeat,
                        currButton.value
                    ]);
                }
                else if (prevButton.pressed) {
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRButtonReleased')([
                        handedness,
                        i,
                        0
                    ]);
                }
                if (currButton.touched) {
                    // touched
                    const isRepeat = prevButton.touched ? 1 : 0;
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRButtonTouched')([
                        handedness,
                        i,
                        isRepeat
                    ]);
                }
                else if (prevButton.touched) {
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRButtonTouchReleased')([
                        handedness,
                        i,
                        0
                    ]);
                }
            }
            // Iterate over gamepad axes
            for (let i = 0; i < currState.axes.length; i++) {
                const curAxisValue = currState.axes[i];
                const prevAxisValue = prevState.axes[i];
                // Only send axis update if there is a change
                if (curAxisValue != prevAxisValue) {
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRAnalog')([
                        handedness,
                        i,
                        curAxisValue
                    ]);
                }
            }
            this.controllers[handedness].prevState = currState;
        }
    }
}
//# sourceMappingURL=XRGamepadController.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/AggregatedStats.js":
/*!**************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/AggregatedStats.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AggregatedStats: () => (/* binding */ AggregatedStats)
/* harmony export */ });
/* harmony import */ var _InboundRTPStats__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InboundRTPStats */ "../../library/dist/esm/PeerConnectionController/InboundRTPStats.js");
/* harmony import */ var _DataChannelStats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DataChannelStats */ "../../library/dist/esm/PeerConnectionController/DataChannelStats.js");
/* harmony import */ var _CandidateStat__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CandidateStat */ "../../library/dist/esm/PeerConnectionController/CandidateStat.js");
/* harmony import */ var _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OutBoundRTPStats */ "../../library/dist/esm/PeerConnectionController/OutBoundRTPStats.js");
/* harmony import */ var _SessionStats__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SessionStats */ "../../library/dist/esm/PeerConnectionController/SessionStats.js");
/* harmony import */ var _StreamStats__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./StreamStats */ "../../library/dist/esm/PeerConnectionController/StreamStats.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.







/**
 * The Aggregated Stats that is generated from the RTC Stats Report
 */
class AggregatedStats {
    constructor() {
        this.inboundVideoStats = new _InboundRTPStats__WEBPACK_IMPORTED_MODULE_0__.InboundVideoStats();
        this.inboundAudioStats = new _InboundRTPStats__WEBPACK_IMPORTED_MODULE_0__.InboundAudioStats();
        this.candidatePairs = new Array();
        this.datachannelStats = new _DataChannelStats__WEBPACK_IMPORTED_MODULE_1__.DataChannelStats();
        this.localCandidates = new Array();
        this.remoteCandidates = new Array();
        this.outboundVideoStats = new _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__.OutboundRTPStats();
        this.outboundAudioStats = new _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__.OutboundRTPStats();
        this.remoteOutboundAudioStats = new _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__.RemoteOutboundRTPStats();
        this.remoteOutboundVideoStats = new _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__.RemoteOutboundRTPStats();
        this.sessionStats = new _SessionStats__WEBPACK_IMPORTED_MODULE_3__.SessionStats();
        this.streamStats = new _StreamStats__WEBPACK_IMPORTED_MODULE_4__.StreamStats();
        this.codecs = new Map();
    }
    /**
     * Gather all the information from the RTC Peer Connection Report
     * @param rtcStatsReport - RTC Stats Report
     */
    processStats(rtcStatsReport) {
        this.localCandidates = new Array();
        this.remoteCandidates = new Array();
        this.candidatePairs = new Array();
        rtcStatsReport.forEach((stat) => {
            const type = stat.type;
            switch (type) {
                case 'candidate-pair':
                    this.handleCandidatePair(stat);
                    break;
                case 'certificate':
                    break;
                case 'codec':
                    this.handleCodec(stat);
                    break;
                case 'data-channel':
                    this.handleDataChannel(stat);
                    break;
                case 'inbound-rtp':
                    this.handleInboundRTP(stat);
                    break;
                case 'local-candidate':
                    this.handleLocalCandidate(stat);
                    break;
                case 'media-source':
                    break;
                case 'media-playout':
                    break;
                case 'outbound-rtp':
                    this.handleLocalOutbound(stat);
                    break;
                case 'peer-connection':
                    break;
                case 'remote-candidate':
                    this.handleRemoteCandidate(stat);
                    break;
                case 'remote-inbound-rtp':
                    break;
                case 'remote-outbound-rtp':
                    this.handleRemoteOutbound(stat);
                    break;
                case 'track':
                    this.handleTrack(stat);
                    break;
                case 'transport':
                    this.handleTransport(stat);
                    break;
                case 'stream':
                    this.handleStream(stat);
                    break;
                default:
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Logger.Error('unhandled Stat Type');
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Logger.Info(stat);
                    break;
            }
        });
    }
    /**
     * Process stream stats data from webrtc
     *
     * @param stat - the stats coming in from webrtc
     */
    handleStream(stat) {
        this.streamStats = stat;
    }
    /**
     * Process the Ice Candidate Pair Data
     * @param stat - the stats coming in from ice candidates
     */
    handleCandidatePair(stat) {
        // Add the candidate pair to the candidate pair array
        this.candidatePairs.push(stat);
    }
    /**
     * Process the Data Channel Data
     * @param stat - the stats coming in from the data channel
     */
    handleDataChannel(stat) {
        this.datachannelStats.bytesReceived = stat.bytesReceived;
        this.datachannelStats.bytesSent = stat.bytesSent;
        this.datachannelStats.dataChannelIdentifier = stat.dataChannelIdentifier;
        this.datachannelStats.id = stat.id;
        this.datachannelStats.label = stat.label;
        this.datachannelStats.messagesReceived = stat.messagesReceived;
        this.datachannelStats.messagesSent = stat.messagesSent;
        this.datachannelStats.protocol = stat.protocol;
        this.datachannelStats.state = stat.state;
        this.datachannelStats.timestamp = stat.timestamp;
    }
    /**
     * Process the Local Ice Candidate Data
     * @param stat - local stats
     */
    handleLocalCandidate(stat) {
        const localCandidate = new _CandidateStat__WEBPACK_IMPORTED_MODULE_6__.CandidateStat();
        localCandidate.label = 'local-candidate';
        localCandidate.address = stat.address;
        localCandidate.port = stat.port;
        localCandidate.protocol = stat.protocol;
        localCandidate.candidateType = stat.candidateType;
        localCandidate.id = stat.id;
        localCandidate.relayProtocol = stat.relayProtocol;
        localCandidate.transportId = stat.transportId;
        this.localCandidates.push(localCandidate);
    }
    /**
     * Process the Remote Ice Candidate Data
     * @param stat - ice candidate stats
     */
    handleRemoteCandidate(stat) {
        const remoteCandidate = new _CandidateStat__WEBPACK_IMPORTED_MODULE_6__.CandidateStat();
        remoteCandidate.label = 'remote-candidate';
        remoteCandidate.address = stat.address;
        remoteCandidate.port = stat.port;
        remoteCandidate.protocol = stat.protocol;
        remoteCandidate.id = stat.id;
        remoteCandidate.candidateType = stat.candidateType;
        remoteCandidate.relayProtocol = stat.relayProtocol;
        remoteCandidate.transportId = stat.transportId;
        this.remoteCandidates.push(remoteCandidate);
    }
    /**
     * Process the Inbound RTP Audio and Video Data
     * @param stat - inbound rtp stats
     */
    handleInboundRTP(stat) {
        switch (stat.kind) {
            case 'video':
                // Calculate bitrate between stat updates
                if (stat.bytesReceived > this.inboundVideoStats.bytesReceived &&
                    stat.timestamp > this.inboundVideoStats.timestamp) {
                    this.inboundVideoStats.bitrate =
                        (8 * (stat.bytesReceived - this.inboundVideoStats.bytesReceived)) /
                            (stat.timestamp - this.inboundVideoStats.timestamp);
                    this.inboundVideoStats.bitrate = Math.floor(this.inboundVideoStats.bitrate);
                }
                // Copy members from stat into `this.inboundVideoStats`
                for (const key in stat) {
                    this.inboundVideoStats[key] = stat[key];
                }
                break;
            case 'audio':
                if (stat.bytesReceived > this.inboundAudioStats.bytesReceived &&
                    stat.timestamp > this.inboundAudioStats.timestamp) {
                    this.inboundAudioStats.bitrate =
                        (8 * (stat.bytesReceived - this.inboundAudioStats.bytesReceived)) /
                            (stat.timestamp - this.inboundAudioStats.timestamp);
                    this.inboundAudioStats.bitrate = Math.floor(this.inboundAudioStats.bitrate);
                }
                // Copy members from stat into `this.inboundAudioStats`
                for (const key in stat) {
                    this.inboundAudioStats[key] = stat[key];
                }
                break;
            default:
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Logger.Error(`Kind should be audio or video, we got ${stat.kind} - that's unsupported.`);
                break;
        }
    }
    /**
     * Process the "local" outbound RTP Audio and Video stats.
     * @param stat - local outbound rtp stats
     */
    handleLocalOutbound(stat) {
        const localOutboundStats = stat.kind === 'audio' ? this.outboundAudioStats : this.outboundVideoStats;
        localOutboundStats.active = stat.active;
        localOutboundStats.codecId = stat.codecId;
        localOutboundStats.bytesSent = stat.bytesSent;
        localOutboundStats.frameHeight = stat.frameHeight;
        localOutboundStats.frameWidth = stat.frameWidth;
        localOutboundStats.framesEncoded = stat.framesEncoded;
        localOutboundStats.framesPerSecond = stat.framesPerSecond;
        localOutboundStats.headerBytesSent = stat.headerBytesSent;
        localOutboundStats.id = stat.id;
        localOutboundStats.keyFramesEncoded = stat.keyFramesEncoded;
        localOutboundStats.kind = stat.kind;
        localOutboundStats.mediaSourceId = stat.mediaSourceId;
        localOutboundStats.mid = stat.mid;
        localOutboundStats.nackCount = stat.nackCount;
        localOutboundStats.packetsSent = stat.packetsSent;
        localOutboundStats.qpSum = stat.qpSum;
        localOutboundStats.qualityLimitationDurations = stat.qualityLimitationDurations;
        localOutboundStats.qualityLimitationReason = stat.qualityLimitationReason;
        localOutboundStats.remoteId = stat.remoteId;
        localOutboundStats.retransmittedBytesSent = stat.retransmittedBytesSent;
        localOutboundStats.rid = stat.rid;
        localOutboundStats.scalabilityMode = stat.scalabilityMode;
        localOutboundStats.ssrc = stat.ssrc;
        localOutboundStats.targetBitrate = stat.targetBitrate;
        localOutboundStats.timestamp = stat.timestamp;
        localOutboundStats.totalEncodeTime = stat.totalEncodeTime;
        localOutboundStats.totalEncodeBytesTarget = stat.totalEncodeBytesTarget;
        localOutboundStats.totalPacketSendDelay = stat.totalPacketSendDelay;
        localOutboundStats.transportId = stat.transportId;
    }
    /**
     * Process the "remote" outbound RTP Audio and Video stats.
     * @param stat - remote outbound rtp stats
     */
    handleRemoteOutbound(stat) {
        const remoteOutboundStats = stat.kind === 'audio' ? this.remoteOutboundAudioStats : this.remoteOutboundVideoStats;
        remoteOutboundStats.bytesSent = stat.bytesSent;
        remoteOutboundStats.codecId = stat.codecId;
        remoteOutboundStats.id = stat.id;
        remoteOutboundStats.kind = stat.kind;
        remoteOutboundStats.localId = stat.localId;
        remoteOutboundStats.packetsSent = stat.packetsSent;
        remoteOutboundStats.remoteTimestamp = stat.remoteTimestamp;
        remoteOutboundStats.reportsSent = stat.reportsSent;
        remoteOutboundStats.roundTripTimeMeasurements = stat.roundTripTimeMeasurements;
        remoteOutboundStats.ssrc = stat.ssrc;
        remoteOutboundStats.timestamp = stat.timestamp;
        remoteOutboundStats.totalRoundTripTime = stat.totalRoundTripTime;
        remoteOutboundStats.transportId = stat.transportId;
    }
    /**
     * Process the Inbound Video Track Data
     * @param stat - video track stats
     */
    handleTrack(stat) {
        // we only want to extract stats from the video track
        if (stat.type === 'track' && (stat.trackIdentifier === 'video_label' || stat.kind === 'video')) {
            this.inboundVideoStats.framesDropped = stat.framesDropped;
            this.inboundVideoStats.framesReceived = stat.framesReceived;
            this.inboundVideoStats.frameHeight = stat.frameHeight;
            this.inboundVideoStats.frameWidth = stat.frameWidth;
        }
    }
    handleTransport(stat) {
        this.transportStats = stat;
    }
    handleCodec(stat) {
        const codecId = stat.id;
        this.codecs.set(codecId, stat);
    }
    handleSessionStatistics(videoStartTime, inputController, videoEncoderAvgQP) {
        const deltaTime = Date.now() - videoStartTime;
        this.sessionStats.runTime = new Date(deltaTime).toISOString().substr(11, 8).toString();
        const controlsStreamInput = inputController === null ? 'Not sent yet' : inputController ? 'true' : 'false';
        this.sessionStats.controlsStreamInput = controlsStreamInput;
        this.sessionStats.videoEncoderAvgQP = videoEncoderAvgQP;
    }
    /**
     * Check if a value coming in from our stats is actually a number
     * @param value - the number to be checked
     */
    isNumber(value) {
        return typeof value === 'number' && isFinite(value);
    }
    /**
     * Helper function to return the active candidate pair
     * @returns The candidate pair that is currently receiving data
     */
    getActiveCandidatePair() {
        if (this.candidatePairs === undefined) {
            return null;
        }
        // Check if the RTCTransport stat is not undefined
        if (this.transportStats) {
            // Return the candidate pair that matches the transport candidate pair id
            const selectedPair = this.candidatePairs.find((candidatePair) => candidatePair.id === this.transportStats.selectedCandidatePairId);
            if (selectedPair === undefined) {
                return null;
            }
            else {
                return selectedPair;
            }
        }
        // Fall back to the `.selected` member of the candidate pair
        const selectedPair = this.candidatePairs.find((candidatePair) => candidatePair.selected);
        if (selectedPair === undefined) {
            return null;
        }
        else {
            return selectedPair;
        }
    }
}
//# sourceMappingURL=AggregatedStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/CandidateStat.js":
/*!************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/CandidateStat.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CandidateStat: () => (/* binding */ CandidateStat)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * ICE Candidate Stat collected from the RTC Stats Report
 */
class CandidateStat {
}
//# sourceMappingURL=CandidateStat.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/DataChannelStats.js":
/*!***************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/DataChannelStats.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataChannelStats: () => (/* binding */ DataChannelStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Data Channel Stats collected from the RTC Stats Report
 */
class DataChannelStats {
}
//# sourceMappingURL=DataChannelStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/InboundRTPStats.js":
/*!**************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/InboundRTPStats.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InboundAudioStats: () => (/* binding */ InboundAudioStats),
/* harmony export */   InboundRTPStats: () => (/* binding */ InboundRTPStats),
/* harmony export */   InboundVideoStats: () => (/* binding */ InboundVideoStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Inbound Audio Stats collected from the RTC Stats Report
 */
class InboundAudioStats {
}
/**
 * Inbound Video Stats collected from the RTC Stats Report
 */
class InboundVideoStats {
}
/**
 * Inbound Stats collected from the RTC Stats Report
 */
class InboundRTPStats {
}
//# sourceMappingURL=InboundRTPStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/LatencyCalculator.js":
/*!****************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/LatencyCalculator.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FrameTimingInfo: () => (/* binding */ FrameTimingInfo),
/* harmony export */   LatencyCalculator: () => (/* binding */ LatencyCalculator),
/* harmony export */   LatencyInfo: () => (/* binding */ LatencyInfo)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Represents either a:
 * - synchronization source: https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpReceiver/getSynchronizationSources
 * - contributing source: https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpReceiver/getContributingSources
 * Which also (if browser supports it) may optionall contain fields for captureTimestamp + senderCaptureTimeOffset
 * if the abs-capture-time RTP header extension is enabled (currently this only works in Chromium based browsers).
 */
class RTCRtpCaptureSource {
}
/**
 * FrameTimingInfo is a Chromium-specific set of WebRTC stats useful for latency calculation. It is stored in WebRTC stats as `googTimingFrameInfo`.
 * It is defined as an RTP header extension here: https://webrtc.googlesource.com/src/+/refs/heads/main/docs/native-code/rtp-hdrext/video-timing/README.md
 * It is defined in source code here: https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/api/video/video_timing.cc;l=82;drc=8d399817282e3c12ed54eb23ec42a5e418298ec6
 * It is discussed by its author here: https://github.com/w3c/webrtc-provisional-stats/issues/40#issuecomment-1272916692
 * In summary it a comma-delimited string that contains the following (in this order):
 * 1)  RTP timestamp: the RTP timestamp of the frame
 * 2)  Capture time: timestamp when this frame was captured
 * 3)  Encode start: timestamp when this frame started to be encoded
 * 4)  Encode finish: timestamp when this frame finished encoding
 * 5)  Packetization finish: timestamp when this frame was split into packets and was ready to be sent over the network
 * 6)  Pacer exit: timestamp when last packet of this frame was sent over the network by the sender at this timestamp
 * 7)  Network timestamp1: place for the SFU to mark when the frame started being forwarded. Application specific.
 * 8)  Network timestamp2: place for the SFU to mark when the frame finished being forwarded. Application specific.
 * 9)  Receive start: timestamp when the first packet of this frame was received
 * 10) Receive finish: timestamp when the last packet of this frame was received
 * 11) Decode start:  timestamp when the frame was passed to decoder
 * 12) Decode finish:  timestamp when the frame was decoded
 * 13) Render time:  timestamp of the projected render time for this frame
 * 14) "is outlier": a flag for if this frame is bigger in encoded size than the average frame by at least 5x.
 * 15) "triggered by timer": a flag for if this report was triggered by the timer (The report is sent every 200ms)
 */
class FrameTimingInfo {
}
/**
 * Calculates a combination of latency statistics using purely WebRTC API.
 */
class LatencyCalculator {
    constructor() {
        /* Clock offset between peer clocks cannot always be calculated as it relies of latest sender reports.
         * so we store the last time we had a valid clock offset in the assumption that clocks haven't drifted too much since then.
         */
        this.latestSenderRecvClockOffset = null;
    }
    calculate(stats, receivers) {
        const latencyInfo = new LatencyInfo();
        const rttMS = this.getRTTMs(stats);
        if (rttMS != null) {
            latencyInfo.rttMs = rttMS;
            // Calculate sender latency using the first valid video ssrc/csrc
            const captureSource = this.getCaptureSource(receivers);
            if (captureSource != null) {
                const senderLatencyMs = this.calculateSenderLatency(stats, captureSource);
                if (senderLatencyMs !== null) {
                    latencyInfo.senderLatencyMs = senderLatencyMs;
                }
            }
        }
        // https://w3c.github.io/webrtc-stats/#dom-rtcinboundrtpstreamstats-totalprocessingdelay
        if (stats.inboundVideoStats.totalProcessingDelay !== undefined &&
            stats.inboundVideoStats.framesDecoded !== undefined) {
            latencyInfo.averageProcessingDelayMs =
                (stats.inboundVideoStats.totalProcessingDelay / stats.inboundVideoStats.framesDecoded) * 1000;
        }
        // https://w3c.github.io/webrtc-stats/#dom-rtcinboundrtpstreamstats-jitterbufferminimumdelay
        if (stats.inboundVideoStats.jitterBufferDelay !== undefined &&
            stats.inboundVideoStats.jitterBufferEmittedCount !== undefined) {
            latencyInfo.averageJitterBufferDelayMs =
                (stats.inboundVideoStats.jitterBufferDelay /
                    stats.inboundVideoStats.jitterBufferEmittedCount) *
                    1000;
        }
        // https://w3c.github.io/webrtc-stats/#dom-rtcinboundrtpstreamstats-totaldecodetime
        if (stats.inboundVideoStats.framesDecoded !== undefined &&
            stats.inboundVideoStats.totalDecodeTime !== undefined) {
            latencyInfo.averageDecodeLatencyMs =
                (stats.inboundVideoStats.totalDecodeTime / stats.inboundVideoStats.framesDecoded) * 1000;
        }
        // https://w3c.github.io/webrtc-stats/#dom-rtcinboundrtpstreamstats-framesassembledfrommultiplepackets
        if (stats.inboundVideoStats.totalAssemblyTime !== undefined &&
            stats.inboundVideoStats.framesAssembledFromMultiplePackets !== undefined) {
            latencyInfo.averageAssemblyDelayMs =
                (stats.inboundVideoStats.totalAssemblyTime /
                    stats.inboundVideoStats.framesAssembledFromMultiplePackets) *
                    1000;
        }
        // Extract extra Chrome-specific stats like encoding latency
        if (stats.inboundVideoStats.googTimingFrameInfo !== undefined &&
            stats.inboundVideoStats.googTimingFrameInfo.length > 0) {
            latencyInfo.frameTiming = this.extractFrameTimingInfo(stats.inboundVideoStats.googTimingFrameInfo);
        }
        // Calculate E2E latency using video-timing capture to send time + one way network latency + receiver-side latency
        if (latencyInfo.frameTiming !== undefined &&
            latencyInfo.frameTiming.captureToSendLatencyMs !== undefined &&
            latencyInfo.averageProcessingDelayMs !== undefined &&
            latencyInfo.rttMs !== undefined) {
            latencyInfo.averageE2ELatency =
                latencyInfo.frameTiming.captureToSendLatencyMs +
                    latencyInfo.rttMs * 0.5 +
                    latencyInfo.averageProcessingDelayMs;
        }
        // Calculate E2E latency as abs-capture-time capture to send latency + one way network latency + receiver-side latency
        if (latencyInfo.senderLatencyMs != undefined &&
            latencyInfo.averageProcessingDelayMs !== undefined &&
            latencyInfo.rttMs !== undefined) {
            latencyInfo.averageE2ELatency =
                latencyInfo.senderLatencyMs + latencyInfo.rttMs * 0.5 + latencyInfo.averageProcessingDelayMs;
        }
        return latencyInfo;
    }
    extractFrameTimingInfo(googTimingFrameInfo) {
        const timingInfo = new FrameTimingInfo();
        const timingInfoArr = googTimingFrameInfo.split(',');
        // Should have exactly 15 elements according to:
        // https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/api/video/video_timing.cc;l=82;drc=8d399817282e3c12ed54eb23ec42a5e418298ec6
        if (timingInfoArr.length === 15) {
            timingInfo.rtpTimestamp = Number.parseInt(timingInfoArr[0]);
            timingInfo.captureTimestamp = Number.parseInt(timingInfoArr[1]);
            timingInfo.encodeStartTimestamp = Number.parseInt(timingInfoArr[2]);
            timingInfo.encodeFinishTimestamp = Number.parseInt(timingInfoArr[3]);
            timingInfo.packetizerFinishTimestamp = Number.parseInt(timingInfoArr[4]);
            timingInfo.pacerExitTimestamp = Number.parseInt(timingInfoArr[5]);
            timingInfo.networkTimestamp1 = Number.parseInt(timingInfoArr[6]);
            timingInfo.networkTimestamp2 = Number.parseInt(timingInfoArr[7]);
            timingInfo.receiveStart = Number.parseInt(timingInfoArr[8]);
            timingInfo.receiveFinish = Number.parseInt(timingInfoArr[9]);
            timingInfo.decodeStart = Number.parseInt(timingInfoArr[10]);
            timingInfo.decodeFinish = Number.parseInt(timingInfoArr[11]);
            timingInfo.renderTime = Number.parseInt(timingInfoArr[12]);
            timingInfo.isOutlier = Number.parseInt(timingInfoArr[13]) > 0;
            timingInfo.isTriggeredByTimer = Number.parseInt(timingInfoArr[14]) > 0;
            // Calculate some latency stats
            timingInfo.encoderLatencyMs = timingInfo.encodeFinishTimestamp - timingInfo.encodeStartTimestamp;
            timingInfo.packetizeLatencyMs =
                timingInfo.packetizerFinishTimestamp - timingInfo.encodeFinishTimestamp;
            timingInfo.pacerLatencyMs = timingInfo.pacerExitTimestamp - timingInfo.packetizerFinishTimestamp;
            timingInfo.captureToSendLatencyMs = timingInfo.pacerExitTimestamp - timingInfo.captureTimestamp;
        }
        return timingInfo;
    }
    calculateSenderLatency(stats, captureSource) {
        // The calculation performed in this function is as per the procedure defined here:
        // https://w3c.github.io/webrtc-extensions/#dom-rtcrtpcontributingsource-sendercapturetimeoffset
        // Get the sender capture in the sender's clock
        const senderCaptureTimestamp = captureSource.captureTimestamp + captureSource.senderCaptureTimeOffset;
        let sendRecvClockOffset = this.calculateSenderReceiverClockOffset(stats);
        // Use latest clock offset if we couldn't calculate one now
        if (sendRecvClockOffset == null) {
            if (this.latestSenderRecvClockOffset != null) {
                sendRecvClockOffset = this.latestSenderRecvClockOffset;
            }
            else {
                return null;
            }
        }
        else {
            this.latestSenderRecvClockOffset = sendRecvClockOffset;
        }
        // This brings sender clock roughly inline with recv clock
        const recvCaptureTimestampNTP = senderCaptureTimestamp + sendRecvClockOffset;
        // As defined in Chrome source: https://chromium.googlesource.com/external/webrtc/+/master/system_wrappers/include/clock.h#26
        const ntp1970 = 2208988800000;
        const recvCaptureTimestamp = recvCaptureTimestampNTP - ntp1970;
        const senderLatency = captureSource.timestamp - recvCaptureTimestamp;
        return senderLatency;
    }
    /**
     * Find the first valid ssrc or csrc that has capture time fields present from abs-capture-time header extension.
     * @param receivers The RTP receviers this peer connection has.
     * @returns A single valid ssrc or csrc that has capture time fields or null if there is none (e.g. in non-chromium browsers it will be null).
     */
    getCaptureSource(receivers) {
        // We only want video receivers
        receivers = receivers.filter((receiver) => receiver.track.kind === 'video');
        for (const receiver of receivers) {
            // Go through all ssrc and csrc to check for capture timestamp
            // Note: Conversion to `any` here is because TS does not have captureTimestamp etc defined in the types
            // these fields only exist in Chromium currently.
            const sources = receiver
                .getSynchronizationSources()
                .concat(receiver.getContributingSources());
            for (const src of sources) {
                if (src.captureTimestamp !== undefined &&
                    src.senderCaptureTimeOffset !== undefined &&
                    src.timestamp !== undefined) {
                    const captureSrc = new RTCRtpCaptureSource();
                    captureSrc.timestamp = src.timestamp;
                    captureSrc.captureTimestamp = src.captureTimestamp;
                    captureSrc.senderCaptureTimeOffset = src.senderCaptureTimeOffset;
                    return captureSrc;
                }
            }
        }
        return null;
    }
    calculateSenderReceiverClockOffset(stats) {
        // The calculation performed in this function is as per the procedure defined here:
        // https://w3c.github.io/webrtc-extensions/#dom-rtcrtpcontributingsource-sendercapturetimeoffset
        const hasRemoteOutboundVideoStats = stats.remoteOutboundVideoStats !== undefined &&
            stats.remoteOutboundVideoStats.timestamp !== undefined &&
            stats.remoteOutboundVideoStats.remoteTimestamp !== undefined;
        // Note: As of Chrome 132, remote-outbound-rtp stats for video are not yet implemented (audio works).
        // This codepath should activate once they do begin to work.
        if (!hasRemoteOutboundVideoStats) {
            return null;
        }
        const remoteStatsArrivedTimestamp = stats.remoteOutboundVideoStats.timestamp;
        const remoteStatsSentTimestamp = stats.remoteOutboundVideoStats.remoteTimestamp;
        const rttMs = this.getRTTMs(stats);
        if (remoteStatsArrivedTimestamp !== undefined &&
            remoteStatsSentTimestamp !== undefined &&
            rttMs !== null) {
            const onewayDelay = rttMs * 0.5;
            return remoteStatsArrivedTimestamp - (remoteStatsSentTimestamp + onewayDelay);
        }
        // Could not get stats to calculate sender/receiver clock offset
        else {
            return null;
        }
    }
    getRTTMs(stats) {
        // Try to get it from the active candidate pair
        const activeCandidatePair = stats.getActiveCandidatePair();
        if (!!activeCandidatePair && activeCandidatePair.currentRoundTripTime !== undefined) {
            const curRTTSeconds = activeCandidatePair.currentRoundTripTime;
            return curRTTSeconds * 1000;
        }
        // Next try to get it from remote-outbound-rtp video stats
        if (!!stats.remoteOutboundVideoStats &&
            stats.remoteOutboundVideoStats.totalRoundTripTime !== undefined &&
            stats.remoteOutboundVideoStats.roundTripTimeMeasurements !== undefined &&
            stats.remoteOutboundVideoStats.roundTripTimeMeasurements > 0) {
            const avgRttSeconds = stats.remoteOutboundVideoStats.totalRoundTripTime /
                stats.remoteOutboundVideoStats.roundTripTimeMeasurements;
            return avgRttSeconds * 1000;
        }
        // Next try to get it from remote-outbound-rtp audio stats
        if (!!stats.remoteOutboundAudioStats &&
            stats.remoteOutboundAudioStats.totalRoundTripTime !== undefined &&
            stats.remoteOutboundAudioStats.roundTripTimeMeasurements !== undefined &&
            stats.remoteOutboundAudioStats.roundTripTimeMeasurements > 0) {
            const avgRttSeconds = stats.remoteOutboundAudioStats.totalRoundTripTime /
                stats.remoteOutboundAudioStats.roundTripTimeMeasurements;
            return avgRttSeconds * 1000;
        }
        return null;
    }
}
/**
 * A collection of latency information calculated using the WebRTC API.
 * Most stats are calculated following the spec:
 * https://w3c.github.io/webrtc-stats/#dictionary-rtcinboundrtpstreamstats-members
 */
class LatencyInfo {
    constructor() {
        /**
         * The time taken from the moment a frame is done capturing to the moment it is sent over the network.
         * Note: This can only be calculated if both offer and answer contain the
         * the RTP header extension for `video-timing` (Chrome only for now)
         */
        this.senderLatencyMs = undefined;
        /**
         * The time taken from the moment a frame is done capturing to the moment it is sent over the network.
         * Note: This can only be calculated if both offer and answer contain the
         * the RTP header extension for `abs-capture-time` (Chrome only for now)
         */
        this.senderLatencyAbsCaptureTimeMs = undefined;
        /* The round trip time (milliseconds) between each sender->receiver->sender */
        this.rttMs = undefined;
        /* Average time taken (milliseconds) from video packet receipt to post-decode. */
        this.averageProcessingDelayMs = undefined;
        /* Average time taken (milliseconds) inside the jitter buffer (which is post-receipt but pre-decode). */
        this.averageJitterBufferDelayMs = undefined;
        /* Average time taken (milliseconds) to decode a video frame. */
        this.averageDecodeLatencyMs = undefined;
        /* Average time taken (milliseconds) to between receipt of the first and last video packet of a. */
        this.averageAssemblyDelayMs = undefined;
        /* The sender latency + RTT/2 + processing delay */
        this.averageE2ELatency = undefined;
        /* Timing information about the worst performing frame since the last getStats call (only works on Chrome) */
        this.frameTiming = undefined;
    }
}
//# sourceMappingURL=LatencyCalculator.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/OutBoundRTPStats.js":
/*!***************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/OutBoundRTPStats.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OutboundRTPStats: () => (/* binding */ OutboundRTPStats),
/* harmony export */   RemoteOutboundRTPStats: () => (/* binding */ RemoteOutboundRTPStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Outbound RTP stats collected from the RTC Stats Report under `outbound-rtp`.
 * Wrapper around: https://developer.mozilla.org/en-US/docs/Web/API/RTCOutboundRtpStreamStats
 * These are stats for video we are sending to a remote peer.
 */
class OutboundRTPStats {
}
/**
 * Remote outbound stats collected from the RTC Stats Report under `remote-outbound-rtp`.
 * Wrapper around: https://developer.mozilla.org/en-US/docs/Web/API/RTCRemoteOutboundRtpStreamStats
 * These are stats for media we are receiving from a remote peer.
 */
class RemoteOutboundRTPStats {
}
//# sourceMappingURL=OutBoundRTPStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/PeerConnectionController.js":
/*!***********************************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/PeerConnectionController.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PeerConnectionController: () => (/* binding */ PeerConnectionController),
/* harmony export */   kAbsCaptureTime: () => (/* binding */ kAbsCaptureTime)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _AggregatedStats__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AggregatedStats */ "../../library/dist/esm/PeerConnectionController/AggregatedStats.js");
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sdp */ "../../../node_modules/sdp/sdp.js");
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sdp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Util_RTCUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Util/RTCUtils */ "../../library/dist/esm/Util/RTCUtils.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Util/SdpUtils.js");
/* harmony import */ var _LatencyCalculator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LatencyCalculator */ "../../library/dist/esm/PeerConnectionController/LatencyCalculator.js");
// Copyright Epic Games, Inc. All Rights Reserved.
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







const kAbsCaptureTime = 'http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time';
/**
 * Handles the Peer Connection
 */
class PeerConnectionController {
    /**
     * Create a new RTC Peer Connection client
     * @param options - Peer connection Options
     * @param config - The config for our PS experience.
     */
    constructor(options, config, preferredCodec) {
        this.config = config;
        this.createPeerConnection(options, preferredCodec);
        this.latencyCalculator = new _LatencyCalculator__WEBPACK_IMPORTED_MODULE_1__.LatencyCalculator();
    }
    createPeerConnection(options, preferredCodec) {
        // Set the ICE transport to relay if TURN enabled
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.ForceTURN)) {
            options.iceTransportPolicy = 'relay';
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('Forcing TURN usage by setting ICE Transport Policy in peer connection config.');
        }
        // build a new peer connection with the options
        this.peerConnection = new RTCPeerConnection(options);
        this.peerConnection.onsignalingstatechange = (ev) => this.handleSignalStateChange(ev);
        this.peerConnection.oniceconnectionstatechange = (ev) => this.handleIceConnectionStateChange(ev);
        this.peerConnection.onicegatheringstatechange = (ev) => this.handleIceGatheringStateChange(ev);
        this.peerConnection.ontrack = (ev) => this.handleOnTrack(ev);
        this.peerConnection.onicecandidate = (ev) => this.handleIceCandidate(ev);
        this.peerConnection.ondatachannel = (ev) => this.handleDataChannel(ev);
        this.aggregatedStats = new _AggregatedStats__WEBPACK_IMPORTED_MODULE_4__.AggregatedStats();
        this.preferredCodec = preferredCodec;
        this.updateCodecSelection = true;
    }
    /**
     * Create an offer for the Web RTC handshake and send the offer to the signaling server via websocket
     * @param offerOptions - RTC Offer Options
     */
    createOffer(offerOptions, config) {
        return __awaiter(this, void 0, void 0, function* () {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('Create Offer');
            const isLocalhostConnection = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
            const isHttpsConnection = location.protocol === 'https:';
            let useMic = config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.UseMic);
            let useCamera = config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.UseCamera);
            if ((useMic || useCamera) && !(isLocalhostConnection || isHttpsConnection)) {
                useMic = false;
                useCamera = false;
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error('Microphone and Webcam access in the browser will not work if you are not on HTTPS or localhost. Disabling mic and webcam access.');
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error("For testing you can enable HTTP microphone access Chrome by visiting chrome://flags/ and enabling 'unsafely-treat-insecure-origin-as-secure'");
            }
            this.setupTransceiversAsync(useMic, useCamera).finally(() => {
                var _a;
                (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.createOffer(offerOptions).then((offer) => {
                    var _a;
                    this.showTextOverlayConnecting();
                    offer.sdp = this.mungeSDP(offer.sdp, useMic);
                    (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setLocalDescription(offer);
                    this.onSendWebRTCOffer(offer);
                }).catch(() => {
                    this.showTextOverlaySetupFailure();
                });
            });
        });
    }
    /**
     * Receive offer from UE side and process it as the remote description of this peer connection
     */
    receiveOffer(offer, config) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('Receive Offer');
            // If UE or JSStreamer did send abs-capture-time RTP header extension to a non-Chrome browser
            // then remove it from the SDP because if Firefox detects it in offer or answer it will fail to connect
            // due having 15 or more header extensions: https://mailarchive.ietf.org/arch/msg/rtcweb/QRnWNuWzGuLRovWdHkodNP6VOgg/
            if (this.isFirefox()) {
                // example: a=extmap:15 http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time
                offer.sdp = offer.sdp.replace(/^a=extmap:\d+ http:\/\/www\.webrtc\.org\/experiments\/rtp-hdrext\/abs-capture-time\r\n/gm, '');
            }
            (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setRemoteDescription(offer).then(() => {
                // Fire event for when remote offer description is set
                this.onSetRemoteDescription(offer);
                const isLocalhostConnection = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
                const isHttpsConnection = location.protocol === 'https:';
                let useMic = config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.UseMic);
                let useCamera = config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.UseCamera);
                if ((useMic || useCamera) && !(isLocalhostConnection || isHttpsConnection)) {
                    useMic = false;
                    useCamera = false;
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error('Microphone and Webcam access in the browser will not work if you are not on HTTPS or localhost. Disabling mic and webcam access.');
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error("For testing you can enable HTTP microphone access Chrome by visiting chrome://flags/ and enabling 'unsafely-treat-insecure-origin-as-secure'");
                }
                // Add our list of preferred codecs, in order of preference
                this.config.setOptionSettingOptions(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec, this.fuzzyIntersectUEAndBrowserCodecs(offer));
                this.setupTransceiversAsync(useMic, useCamera).finally(() => {
                    var _a;
                    (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.createAnswer().then((Answer) => {
                        var _a;
                        Answer.sdp = this.mungeSDP(Answer.sdp, useMic);
                        return (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setLocalDescription(Answer);
                    }).then(() => {
                        var _a;
                        this.onSetLocalDescription((_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.localDescription);
                    }).catch((err) => {
                        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Error(`createAnswer() failed - ${err}`);
                    });
                });
            });
        });
    }
    /**
     * Set the Remote Descriptor from the signaling server to the RTC Peer Connection
     * @param answer - RTC Session Descriptor from the Signaling Server
     */
    receiveAnswer(answer) {
        var _a;
        (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setRemoteDescription(answer);
        // Add our list of preferred codecs, in order of preference
        this.config.setOptionSettingOptions(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec, this.fuzzyIntersectUEAndBrowserCodecs(answer));
    }
    /**
     * Generate Aggregated Stats and then fire a onVideo Stats event
     */
    generateStats() {
        this.peerConnection.getStats().then((statsData) => {
            this.aggregatedStats.processStats(statsData);
            this.onVideoStats(this.aggregatedStats);
            // Calculate latency using stats and video receivers and then call the handling function
            const latencyInfo = this.latencyCalculator.calculate(this.aggregatedStats, this.peerConnection.getReceivers());
            this.onLatencyCalculated(latencyInfo);
            // Update the preferred codec selection based on what was actually negotiated
            if (this.updateCodecSelection && !!this.aggregatedStats.inboundVideoStats.codecId) {
                // Construct the qualified codec name from the mimetype and fmtp
                const codecStats = this.aggregatedStats.codecs.get(this.aggregatedStats.inboundVideoStats.codecId);
                if (codecStats === undefined) {
                    return;
                }
                const codecShortname = codecStats.mimeType.replace('video/', '');
                let fullCodecName = codecShortname;
                if (codecStats.sdpFmtpLine && codecStats.sdpFmtpLine.trim() !== '') {
                    fullCodecName = `${codecShortname} ${codecStats.sdpFmtpLine.trim()}`;
                }
                const allBrowserCodecs = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec).options;
                // The list of codecs directly contains the one that was negotiated, select that
                if (allBrowserCodecs.includes(fullCodecName)) {
                    this.config.setOptionSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec, fullCodecName);
                    return;
                }
                // If we couldn't match on the full name, try to match on just the codec shortname
                const filteredList = allBrowserCodecs.filter((option) => option.indexOf(codecShortname) !== -1);
                if (filteredList.length > 0) {
                    this.config.setOptionSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec, filteredList[0]);
                    return;
                }
            }
        });
    }
    /**
     * Close The Peer Connection
     */
    close() {
        if (this.peerConnection) {
            this.peerConnection.close();
            this.peerConnection = null;
        }
    }
    /**
     * Modify the Session Descriptor
     * @param sdp - Session Descriptor as a string
     * @param useMic - Is the microphone in use
     * @returns A modified Session Descriptor
     */
    mungeSDP(sdp, useMic) {
        let mungedSDP = sdp.replace(/(a=fmtp:\d+ .*level-asymmetry-allowed=.*)\r\n/gm, '$1;x-google-start-bitrate=10000;x-google-max-bitrate=100000\r\n');
        // set max bitrate to highest bitrate Opus supports
        let audioSDP = 'maxaveragebitrate=510000;';
        if (useMic) {
            // set the max capture rate to 48khz (so we can send high quality audio from mic)
            audioSDP += 'sprop-maxcapturerate=48000;';
        }
        // Force mono or stereo based on whether ?forceMono was passed or not
        audioSDP += this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.ForceMonoAudio) ? 'stereo=0;' : 'stereo=1;';
        // enable in-band forward error correction for opus audio
        audioSDP += 'useinbandfec=1';
        // We use the line 'useinbandfec=1' (which Opus uses) to set our Opus specific audio parameters.
        mungedSDP = mungedSDP.replace('useinbandfec=1', audioSDP);
        // Add abs-capture-time RTP header extension if we have enabled the setting.
        // Note: As at Feb 2025, Chromium based browsers are the only ones that support this and
        // munging it into the answer in Firefox will cause the connection to fail.
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.EnableCaptureTimeExt) && !this.isFirefox()) {
            mungedSDP = _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_5__.SDPUtils.addVideoHeaderExtensionToSdp(mungedSDP, kAbsCaptureTime);
        }
        return mungedSDP;
    }
    isFirefox() {
        return navigator.userAgent.indexOf('Firefox') > 0;
    }
    /**
     * When a Ice Candidate is received add to the RTC Peer Connection
     * @param iceCandidate - RTC Ice Candidate from the Signaling Server
     */
    handleOnIce(iceCandidate) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('peerconnection handleOnIce');
        // // if forcing TURN, reject any candidates not relay
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.ForceTURN)) {
            // check if no relay address is found, if so, we are assuming it means no TURN server
            if (iceCandidate.candidate.indexOf('relay') < 0) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info(`Dropping candidate because it was not TURN relay. | Type= ${iceCandidate.type} | Protocol= ${iceCandidate.protocol} | Address=${iceCandidate.address} | Port=${iceCandidate.port} |`);
                return;
            }
        }
        (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.addIceCandidate(iceCandidate);
    }
    /**
     * When the RTC Peer Connection Signaling server state Changes
     * @param state - Signaling Server State Change Event
     */
    handleSignalStateChange(state) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('signaling state change: ' + state);
    }
    /**
     * Handle when the Ice Connection State Changes
     * @param state - Ice Connection State
     */
    handleIceConnectionStateChange(state) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('ice connection state change: ' + state);
        this.onIceConnectionStateChange(state);
    }
    /**
     * Handle when the Ice Gathering State Changes
     * @param state - Ice Gathering State Change
     */
    handleIceGatheringStateChange(state) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('ice gathering state change: ' + JSON.stringify(state));
    }
    /**
     * Activates the onTrack method
     * @param event - The webRtc track event
     */
    handleOnTrack(event) {
        if (event.streams.length < 1 || event.streams[0].id == 'probator') {
            return;
        }
        if (event.track.kind == 'video') {
            this.videoTrack = event.track;
        }
        if (event.track.kind == 'audio') {
            this.audioTrack = event.track;
        }
        this.onTrack(event);
    }
    /**
     * Activates the onPeerIceCandidate
     * @param event - The peer ice candidate
     */
    handleIceCandidate(event) {
        this.onPeerIceCandidate(event);
    }
    /**
     * Activates the onDataChannel
     * @param event - The peer's data channel
     */
    handleDataChannel(event) {
        this.onDataChannel(event);
    }
    /**
     * An override method for onTrack for use outside of the PeerConnectionController
     * @param trackEvent - The webRtc track event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onTrack(trackEvent) {
        // Default Functionality: Do Nothing
    }
    /**
     * An override method for onIceConnectionStateChange for use outside of the PeerConnectionController
     * @param event - The webRtc iceconnectionstatechange event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onIceConnectionStateChange(event) {
        // Default Functionality: Do Nothing
    }
    /**
     * An override method for onPeerIceCandidate for use outside of the PeerConnectionController
     * @param peerConnectionIceEvent - The peer ice candidate
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onPeerIceCandidate(peerConnectionIceEvent) {
        // Default Functionality: Do Nothing
    }
    /**
     * An override method for onDataChannel for use outside of the PeerConnectionController
     * @param datachannelEvent - The peer's data channel
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onDataChannel(datachannelEvent) {
        // Default Functionality: Do Nothing
    }
    /**
     * Find the intersection between UE and browser codecs, with fuzzy matching if some parameters are mismatched.
     * @param sdp The remote sdp
     * @returns The intersection between browser supported codecs and ue supported codecs.
     */
    fuzzyIntersectUEAndBrowserCodecs(sdp) {
        // We want to build an array of all supported codecs on both sides
        const allSupportedCodecs = new Array();
        const allUECodecs = this.parseAvailableCodecs(sdp);
        const allBrowserCodecs = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec).options;
        for (const ueCodec of allUECodecs) {
            // Check if browser codecs directly matches UE codec (with parameters and everything)
            if (allBrowserCodecs.includes(ueCodec)) {
                allSupportedCodecs.push(ueCodec);
                continue;
            }
            // Otherwise check if browser codec at least contains a match for the UE codec name (without parameters).
            else {
                const ueCodecNameAndParams = ueCodec.split(' ');
                const ueCodecName = ueCodecNameAndParams[0];
                for (const browserCodec of allBrowserCodecs) {
                    if (browserCodec.includes(ueCodecName)) {
                        // We pass browser codec here as they option contain extra parameters.
                        allSupportedCodecs.push(browserCodec);
                        break;
                    }
                }
            }
        }
        return allSupportedCodecs;
    }
    /**
     * Setup tracks on the RTC Peer Connection
     * @param useMic - is mic in use
     * @param useCamera - is webcam in use
     */
    setupTransceiversAsync(useMic, useCamera) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            let hasVideoReceiver = false;
            for (const transceiver of (_b = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : []) {
                if (transceiver &&
                    transceiver.receiver &&
                    transceiver.receiver.track &&
                    transceiver.receiver.track.kind === 'video') {
                    hasVideoReceiver = true;
                    break;
                }
            }
            // Setup a transceiver for sending webcam video to UE and receiving video from UE
            if (!useCamera) {
                if (!hasVideoReceiver) {
                    (_c = this.peerConnection) === null || _c === void 0 ? void 0 : _c.addTransceiver('video', { direction: 'recvonly' });
                }
            }
            else {
                yield this.setupVideoSender(hasVideoReceiver);
            }
            if (RTCRtpReceiver.getCapabilities && this.preferredCodec != '') {
                for (const transceiver of (_e = (_d = this.peerConnection) === null || _d === void 0 ? void 0 : _d.getTransceivers()) !== null && _e !== void 0 ? _e : []) {
                    if (transceiver &&
                        transceiver.receiver &&
                        transceiver.receiver.track &&
                        transceiver.receiver.track.kind === 'video' &&
                        transceiver.setCodecPreferences) {
                        // Get our preferred codec from the codecs options drop down
                        const preferredRTPCodec = this.preferredCodec.split(' ');
                        const preferredRTCRtpCodecCapability = {
                            mimeType: 'video/' + preferredRTPCodec[0] /* Name */,
                            clockRate: 90000 /* All current video formats in browsers have 90khz clock rate */,
                            sdpFmtpLine: preferredRTPCodec[1] ? preferredRTPCodec[1] : ''
                        };
                        // Populate a list of codecs we will support with our preferred one in the first position
                        const ourSupportedCodecs = [preferredRTCRtpCodecCapability];
                        // Go through all codecs the browser supports and add them to the list (in any order)
                        RTCRtpReceiver.getCapabilities('video').codecs.forEach((browserSupportedCodec) => {
                            // Don't add our preferred codec again, but add everything else
                            if (browserSupportedCodec.mimeType != preferredRTCRtpCodecCapability.mimeType) {
                                ourSupportedCodecs.push(browserSupportedCodec);
                            }
                            else if ((browserSupportedCodec === null || browserSupportedCodec === void 0 ? void 0 : browserSupportedCodec.sdpFmtpLine) !=
                                (preferredRTCRtpCodecCapability === null || preferredRTCRtpCodecCapability === void 0 ? void 0 : preferredRTCRtpCodecCapability.sdpFmtpLine)) {
                                ourSupportedCodecs.push(browserSupportedCodec);
                            }
                        });
                        for (const codec of ourSupportedCodecs) {
                            if ((codec === null || codec === void 0 ? void 0 : codec.sdpFmtpLine) === undefined || codec.sdpFmtpLine === '') {
                                // We can't dynamically add members to the codec, so instead remove the field if it's empty
                                delete codec.sdpFmtpLine;
                            }
                        }
                        transceiver.setCodecPreferences(ourSupportedCodecs);
                    }
                }
            }
            let hasAudioReceiver = false;
            for (const transceiver of (_g = (_f = this.peerConnection) === null || _f === void 0 ? void 0 : _f.getTransceivers()) !== null && _g !== void 0 ? _g : []) {
                if (transceiver &&
                    transceiver.receiver &&
                    transceiver.receiver.track &&
                    transceiver.receiver.track.kind === 'audio') {
                    hasAudioReceiver = true;
                    break;
                }
            }
            // Setup a transceiver for sending mic audio to UE and receiving audio from UE
            if (!useMic) {
                if (!hasAudioReceiver) {
                    (_h = this.peerConnection) === null || _h === void 0 ? void 0 : _h.addTransceiver('audio', {
                        direction: 'recvonly'
                    });
                }
            }
            else {
                yield this.setupAudioSender(hasAudioReceiver);
            }
        });
    }
    setupVideoSender(hasVideoReceiver) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            // set the media send options
            const mediaSendOptions = {
                video: true
            };
            // Note using webcam on android chrome requires SSL or chrome://flags/ "unsafely-treat-insecure-origin-as-secure"
            const stream = yield navigator.mediaDevices.getUserMedia(mediaSendOptions);
            if (stream) {
                if (hasVideoReceiver) {
                    for (const transceiver of (_b = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : []) {
                        if (_Util_RTCUtils__WEBPACK_IMPORTED_MODULE_6__.RTCUtils.canTransceiverReceiveVideo(transceiver)) {
                            for (const track of stream.getTracks()) {
                                if (track.kind && track.kind == 'video') {
                                    transceiver.sender.replaceTrack(track);
                                    transceiver.direction = 'sendrecv';
                                }
                            }
                        }
                    }
                }
                else {
                    for (const track of stream.getTracks()) {
                        if (track.kind && track.kind == 'video') {
                            (_c = this.peerConnection) === null || _c === void 0 ? void 0 : _c.addTransceiver(track, {
                                direction: 'sendrecv'
                            });
                        }
                    }
                }
            }
            else {
                if (!hasVideoReceiver) {
                    (_d = this.peerConnection) === null || _d === void 0 ? void 0 : _d.addTransceiver('video', { direction: 'recvonly' });
                }
            }
        });
    }
    setupAudioSender(hasAudioReceiver) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            // set the audio options based on mic usage
            const audioOptions = {
                autoGainControl: false,
                channelCount: 1,
                echoCancellation: false,
                latency: 0,
                noiseSuppression: false,
                sampleRate: 48000,
                sampleSize: 16,
                volume: 1.0
            };
            // set the media send options
            const mediaSendOptions = {
                video: false,
                audio: audioOptions
            };
            // Note using mic on android chrome requires SSL or chrome://flags/ "unsafely-treat-insecure-origin-as-secure"
            const stream = yield navigator.mediaDevices.getUserMedia(mediaSendOptions);
            if (stream) {
                if (hasAudioReceiver) {
                    for (const transceiver of (_b = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : []) {
                        if (_Util_RTCUtils__WEBPACK_IMPORTED_MODULE_6__.RTCUtils.canTransceiverReceiveAudio(transceiver)) {
                            for (const track of stream.getTracks()) {
                                if (track.kind && track.kind == 'audio') {
                                    transceiver.sender.replaceTrack(track);
                                    transceiver.direction = 'sendrecv';
                                }
                            }
                        }
                    }
                }
                else {
                    for (const track of stream.getTracks()) {
                        if (track.kind && track.kind == 'audio') {
                            (_c = this.peerConnection) === null || _c === void 0 ? void 0 : _c.addTransceiver(track, {
                                direction: 'sendrecv'
                            });
                        }
                    }
                }
            }
            else {
                if (!hasAudioReceiver) {
                    (_d = this.peerConnection) === null || _d === void 0 ? void 0 : _d.addTransceiver('audio', {
                        direction: 'recvonly'
                    });
                }
            }
        });
    }
    /**
     * And override event for when the video stats are fired
     * @param event - Aggregated Stats
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVideoStats(event) {
        // Default Functionality: Do Nothing
    }
    /**
     * And override event for when latency info is calculated
     * @param latencyInfo - Calculated latency information.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onLatencyCalculated(latencyInfo) {
        // Default Functionality: Do Nothing
    }
    /**
     * Event to send the RTC offer to the Signaling server
     * @param offer - RTC Offer
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onSendWebRTCOffer(offer) {
        // Default Functionality: Do Nothing
    }
    /**
     * Event fired when remote offer description is set.
     * @param offer - RTC Offer
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onSetRemoteDescription(offer) {
        // Default Functionality: Do Nothing
    }
    /**
     * Event fire when local description answer is set.
     * @param answer - RTC Answer
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onSetLocalDescription(answer) {
        // Default Functionality: Do Nothing
    }
    /**
     * An override for showing the Peer connection connecting Overlay
     */
    showTextOverlayConnecting() {
        // Default Functionality: Do Nothing
    }
    /**
     * An override for showing the Peer connection Failed overlay
     */
    showTextOverlaySetupFailure() {
        // Default Functionality: Do Nothing
    }
    parseAvailableCodecs(rtcSessionDescription) {
        // No point in updating the available codecs if on FF
        if (!RTCRtpReceiver.getCapabilities)
            return ['Only available on Chrome'];
        const ueSupportedCodecs = [];
        const sections = (0,sdp__WEBPACK_IMPORTED_MODULE_0__.splitSections)(rtcSessionDescription.sdp);
        // discard the session information as we only want media related info
        sections.shift();
        sections.forEach((mediaSection) => {
            const { codecs } = (0,sdp__WEBPACK_IMPORTED_MODULE_0__.parseRtpParameters)(mediaSection);
            // Filter only for VPX / H26X / AV1
            const matcher = /(VP\d|H26\d|AV1).*/;
            codecs.forEach((c) => {
                const str = c.name +
                    ' ' +
                    Object.keys(c.parameters || {})
                        .map((p) => p + '=' + c.parameters[p])
                        .join(';');
                const match = matcher.exec(str);
                if (match !== null) {
                    if (c.name == 'VP9') {
                        // UE answers don't specify profile but we know we want profile 0
                        c.parameters = {
                            'profile-id': '0'
                        };
                    }
                    const codecStr = c.name +
                        ' ' +
                        Object.keys(c.parameters || {})
                            .map((p) => p + '=' + c.parameters[p])
                            .join(';');
                    ueSupportedCodecs.push(codecStr);
                }
            });
        });
        return ueSupportedCodecs;
    }
}
//# sourceMappingURL=PeerConnectionController.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/SessionStats.js":
/*!***********************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/SessionStats.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SessionStats: () => (/* binding */ SessionStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Session statistics
 */
class SessionStats {
}
//# sourceMappingURL=SessionStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PeerConnectionController/StreamStats.js":
/*!**********************************************************************!*\
  !*** ../../library/dist/esm/PeerConnectionController/StreamStats.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StreamStats: () => (/* binding */ StreamStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Class to hold the stream stats data coming in from webRtc
 */
class StreamStats {
}
//# sourceMappingURL=StreamStats.js.map

/***/ }),

/***/ "../../library/dist/esm/PixelStreaming/PixelStreaming.js":
/*!***************************************************************!*\
  !*** ../../library/dist/esm/PixelStreaming/PixelStreaming.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PixelStreaming: () => (/* binding */ PixelStreaming)
/* harmony export */ });
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _WebRtcPlayer_WebRtcPlayerController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../WebRtcPlayer/WebRtcPlayerController */ "../../library/dist/esm/WebRtcPlayer/WebRtcPlayerController.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Util/EventEmitter */ "../../library/dist/esm/Util/EventEmitter.js");
/* harmony import */ var _WebXR_WebXRController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../WebXR/WebXRController */ "../../library/dist/esm/WebXR/WebXRController.js");
/* harmony import */ var _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../UeInstanceMessage/StreamMessageController */ "../../library/dist/esm/UeInstanceMessage/StreamMessageController.js");
/* harmony import */ var _DataChannel_DataChannelLatencyTestController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../DataChannel/DataChannelLatencyTestController */ "../../library/dist/esm/DataChannel/DataChannelLatencyTestController.js");
/* harmony import */ var _Util_RTCUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Util/RTCUtils */ "../../library/dist/esm/Util/RTCUtils.js");
/* harmony import */ var _Util_IURLSearchParams__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Util/IURLSearchParams */ "../../library/dist/esm/Util/IURLSearchParams.js");
// Copyright Epic Games, Inc. All Rights Reserved.










/**
 * The key class for the browser side of a Pixel Streaming application, it includes:
 * WebRTC handling, XR support, input handling, and emitters for lifetime and state change events.
 * Users are encouraged to use this class as is, through composition, or extend it. In any case,
 * this will likely be the core of your Pixel Streaming experience in terms of functionality.
 */
class PixelStreaming {
    /**
     * @param config - A newly instantiated config object
     * @param overrides - Parameters to override default behaviour
     * returns the base Pixel streaming object
     */
    constructor(config, overrides) {
        this.allowConsoleCommands = false;
        this.config = config;
        if (overrides === null || overrides === void 0 ? void 0 : overrides.videoElementParent) {
            this._videoElementParent = overrides.videoElementParent;
        }
        this._eventEmitter = new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.PixelStreamingEventEmitter();
        this.configureSettings();
        // setup WebRTC
        this.setWebRtcPlayerController(new _WebRtcPlayer_WebRtcPlayerController__WEBPACK_IMPORTED_MODULE_1__.WebRtcPlayerController(this.config, this));
        this._webXrController = new _WebXR_WebXRController__WEBPACK_IMPORTED_MODULE_2__.WebXRController(this._webRtcController);
        this._setupWebRtcTCPRelayDetection = this._setupWebRtcTCPRelayDetection.bind(this);
        // Add event listener for the webRtcConnected event
        this._eventEmitter.addEventListener('webRtcConnected', (_) => {
            // Bind to the stats received event
            this._eventEmitter.addEventListener('statsReceived', this._setupWebRtcTCPRelayDetection);
        });
    }
    /**
     * Gets the element that contains the video stream element.
     */
    get videoElementParent() {
        if (!this._videoElementParent) {
            this._videoElementParent = document.createElement('div');
            this._videoElementParent.id = 'videoElementParent';
        }
        return this._videoElementParent;
    }
    /**
     * Configure the settings with on change listeners and any additional per experience settings.
     */
    configureSettings() {
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.IsQualityController, (wantsQualityController) => {
            // If the setting has been set to true (either programmatically or the user has flicked the toggle)
            // and we aren't currently quality controller, send the request
            if (wantsQualityController === true && !this._webRtcController.isQualityController) {
                this._webRtcController.sendRequestQualityControlOwnership();
            }
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.AFKDetection, (isAFKEnabled) => {
            this._webRtcController.setAfkEnabled(isAFKEnabled);
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.MatchViewportResolution, () => {
            this._webRtcController.videoPlayer.updateVideoStreamSize();
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.HoveringMouseMode, (isHoveringMouse) => {
            this.config.setFlagLabel(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.HoveringMouseMode, `Control Scheme: ${isHoveringMouse ? 'Hovering' : 'Locked'} Mouse`);
            this._webRtcController.setMouseInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.MouseInput));
        });
        // user input
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.KeyboardInput, (isEnabled) => {
            this._webRtcController.setKeyboardInputEnabled(isEnabled);
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.MouseInput, (isEnabled) => {
            this._webRtcController.setMouseInputEnabled(isEnabled);
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.FakeMouseWithTouches, (_isFakeMouseEnabled) => {
            this._webRtcController.setTouchInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.TouchInput));
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.TouchInput, (isEnabled) => {
            this._webRtcController.setTouchInputEnabled(isEnabled);
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.GamepadInput, (isEnabled) => {
            this._webRtcController.setGamePadInputEnabled(isEnabled);
        });
        // direct qp settings
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQP, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MinQP  --------');
            this._webRtcController.sendEncoderMinQP(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
            const quality = Math.trunc(100 * (1 - newValue / 51));
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax, quality);
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQP, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MaxQP  --------');
            this._webRtcController.sendEncoderMaxQP(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
            const quality = Math.trunc(100 * (1 - newValue / 51));
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin, quality);
        });
        // direct quality factor settings
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQuality, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MinQuality  --------');
            this._webRtcController.sendEncoderMinQuality(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin, newValue);
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQuality, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MaxQuality  --------');
            this._webRtcController.sendEncoderMaxQuality(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax, newValue);
        });
        // new quality value that gets scaled to qp for legacy reasons
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin, (newValue) => {
            newValue = 51 - (newValue / 100) * 51;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MinQP from quality value  --------');
            this._webRtcController.sendEncoderMaxQP(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax, (newValue) => {
            newValue = 51 - (newValue / 100) * 51;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MaxQP from quality value  --------');
            this._webRtcController.sendEncoderMinQP(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        // WebRTC settings
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMinBitrate, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending web rtc settings  --------');
            this._webRtcController.sendWebRTCMinBitrate(newValue * 1000 /* kbps to bps */);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMaxBitrate, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending web rtc settings  --------');
            this._webRtcController.sendWebRTCMaxBitrate(newValue * 1000 /* kbps to bps */);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCFPS, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending web rtc settings  --------');
            this._webRtcController.sendWebRTCFps(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        this.config._addOnOptionSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.OptionParameters.PreferredCodec, (newValue) => {
            if (this._webRtcController) {
                this._webRtcController.setPreferredCodec(newValue);
            }
        });
        this.config._registerOnChangeEvents(this._eventEmitter);
    }
    /**
     * Set the input control ownership
     * @param inputControlOwnership - does the user have input control ownership
     */
    _onInputControlOwnership(inputControlOwnership) {
        this._inputController = inputControlOwnership;
    }
    /**
     * Instantiate the WebRTCPlayerController interface to provide WebRTCPlayerController functionality within this class and set up anything that requires it
     * @param webRtcPlayerController - a WebRtcPlayerController controller instance
     */
    setWebRtcPlayerController(webRtcPlayerController) {
        this._webRtcController = webRtcPlayerController;
        this._webRtcController.setPreferredCodec(this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.OptionParameters.PreferredCodec).selected);
        this._webRtcController.resizePlayerStyle();
        // connect if auto connect flag is enabled
        this.checkForAutoConnect();
    }
    /**
     * Connect to signaling server.
     */
    connect() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StreamPreConnectEvent());
        this._webRtcController.connectToSignallingServer();
    }
    /**
     * Reconnects to the signaling server. If connection is up, disconnects first
     * before establishing a new connection
     */
    reconnect() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StreamReconnectEvent());
        this._webRtcController.tryReconnect('Reconnecting...');
    }
    /**
     * Disconnect from the signaling server and close open peer connections.
     */
    disconnect() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StreamPreDisconnectEvent());
        this._webRtcController.close();
    }
    /**
     * Play the stream. Can be called only after a peer connection has been established.
     */
    play() {
        this._onStreamLoading();
        this._webRtcController.playStream();
    }
    /**
     * Auto connect if AutoConnect flag is enabled
     */
    checkForAutoConnect() {
        // set up if the auto play will be used or regular click to start
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.AutoConnect)) {
            // if autoplaying show an info overlay while while waiting for the connection to begin
            this._onWebRtcAutoConnect();
            this._webRtcController.connectToSignallingServer();
        }
    }
    /**
     * Will unmute the microphone track which is sent to Unreal Engine.
     * By default, will only unmute an existing mic track.
     *
     * @param forceEnable Can be used for cases when this object wasn't initialized with a mic track.
     * If this parameter is true, the connection will be restarted with a microphone.
     * Warning: this takes some time, as a full renegotiation and reconnection will happen.
     */
    unmuteMicrophone(forceEnable = false) {
        // If there's an existing mic track, we just set muted state
        if (this.config.isFlagEnabled('UseMic')) {
            this.setMicrophoneMuted(false);
            return;
        }
        // If there's no pre-existing mic track, and caller is ok with full reset, we enable and reset
        if (forceEnable) {
            this.config.setFlagEnabled('UseMic', true);
            this.reconnect();
            return;
        }
        // If we prefer not to force a reconnection, just warn the user that this operation didn't happen
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Warning('Trying to unmute mic, but PixelStreaming was initialized with no microphone track. Call with forceEnable == true to re-connect with a mic track.');
    }
    muteMicrophone() {
        if (this.config.isFlagEnabled('UseMic')) {
            this.setMicrophoneMuted(true);
            return;
        }
        // If there wasn't a mic track, just let user know there's nothing to mute
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('Trying to mute mic, but PixelStreaming has no microphone track, so sending sound is already disabled.');
    }
    setMicrophoneMuted(mute) {
        var _a, _b, _c, _d;
        for (const transceiver of (_d = (_c = (_b = (_a = this._webRtcController) === null || _a === void 0 ? void 0 : _a.peerConnectionController) === null || _b === void 0 ? void 0 : _b.peerConnection) === null || _c === void 0 ? void 0 : _c.getTransceivers()) !== null && _d !== void 0 ? _d : []) {
            if (_Util_RTCUtils__WEBPACK_IMPORTED_MODULE_5__.RTCUtils.canTransceiverSendAudio(transceiver)) {
                transceiver.sender.track.enabled = !mute;
            }
        }
    }
    /**
     * Will unmute the video track which is sent to Unreal Engine.
     * By default, will only unmute an existing video track.
     *
     * @param forceEnable Can be used for cases when this object wasn't initialized with a video track.
     * If this parameter is true, the connection will be restarted with a camera.
     * Warning: this takes some time, as a full renegotiation and reconnection will happen.
     */
    unmuteCamera(forceEnable = false) {
        // If there's an existing video track, we just set muted state
        if (this.config.isFlagEnabled('UseCamera')) {
            this.setCameraMuted(false);
            return;
        }
        // If there's no pre-existing video track, and caller is ok with full reset, we enable and reset
        if (forceEnable) {
            this.config.setFlagEnabled('UseCamera', true);
            this.reconnect();
            return;
        }
        // If we prefer not to force a reconnection, just warn the user that this operation didn't happen
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Warning('Trying to unmute video, but PixelStreaming was initialized with no video track. Call with forceEnable == true to re-connect with a video track.');
    }
    muteCamera() {
        if (this.config.isFlagEnabled('UseCamera')) {
            this.setCameraMuted(true);
            return;
        }
        // If there wasn't a mic track, just let user know there's nothing to mute
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('Trying to mute camera, but PixelStreaming has no video track, so sending video is already disabled.');
    }
    setCameraMuted(mute) {
        var _a, _b, _c, _d;
        for (const transceiver of (_d = (_c = (_b = (_a = this._webRtcController) === null || _a === void 0 ? void 0 : _a.peerConnectionController) === null || _b === void 0 ? void 0 : _b.peerConnection) === null || _c === void 0 ? void 0 : _c.getTransceivers()) !== null && _d !== void 0 ? _d : []) {
            if (_Util_RTCUtils__WEBPACK_IMPORTED_MODULE_5__.RTCUtils.canTransceiverSendVideo(transceiver)) {
                transceiver.sender.track.enabled = !mute;
            }
        }
    }
    /**
     * Internal function to emit an event when auto connecting occurs
     */
    _onWebRtcAutoConnect() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcAutoConnectEvent());
    }
    /**
     * Internal function to emit an event for when SDP negotiation is fully finished.
     */
    _onWebRtcSdp() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcSdpEvent());
    }
    /**
     * Internal function to emit an SDP offer after it has been set.
     */
    _onWebRtcSdpOffer(offer) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcSdpOfferEvent({ sdp: offer }));
    }
    /**
     * Internal function to emit an SDP answer after it has been set.
     */
    _onWebRtcSdpAnswer(answer) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcSdpAnswerEvent({ sdp: answer }));
    }
    /**
     * Internal function call to emit a `latencyCalculated` event.
     */
    _onLatencyCalculated(latencyInfo) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.LatencyCalculatedEvent({ latencyInfo }));
    }
    /**
     * Internal function to emits a StreamLoading event
     */
    _onStreamLoading() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StreamLoadingEvent());
    }
    /**
     * Event fired when the video is disconnected - emits given eventString or an override
     * message from webRtcController if one has been set
     * @param eventString - a string describing why the connection closed
     * @param allowClickToReconnect - true if we want to allow the user to retry the connection with a click
     */
    _onDisconnect(eventString, allowClickToReconnect) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcDisconnectedEvent({
            eventString: eventString,
            allowClickToReconnect: allowClickToReconnect
        }));
    }
    /**
     * Handles when Web Rtc is connecting
     */
    _onWebRtcConnecting() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcConnectingEvent());
    }
    /**
     * Handles when Web Rtc has connected
     */
    _onWebRtcConnected() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcConnectedEvent());
    }
    /**
     * Handles when Web Rtc fails to connect
     */
    _onWebRtcFailed() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcFailedEvent());
    }
    /**
     * Handle when the Video has been Initialized
     */
    _onVideoInitialized() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.VideoInitializedEvent());
        this._videoStartTime = Date.now();
    }
    /**
     * Set up functionality to happen when receiving latency test results
     * @param latency - latency test results object
     */
    _onLatencyTestResult(latencyTimings) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.LatencyTestResultEvent({ latencyTimings }));
    }
    _onDataChannelLatencyTestResponse(response) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.DataChannelLatencyTestResponseEvent({ response }));
    }
    /**
     * Set up functionality to happen when receiving video statistics
     * @param videoStats - video statistics as a aggregate stats object
     */
    _onVideoStats(videoStats) {
        // Duration
        if (!this._videoStartTime || this._videoStartTime === undefined) {
            this._videoStartTime = Date.now();
        }
        videoStats.handleSessionStatistics(this._videoStartTime, this._inputController, this._webRtcController.videoAvgQp);
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StatsReceivedEvent({ aggregatedStats: videoStats }));
    }
    /**
     * Set up functionality to happen when calculating the average video encoder qp
     * @param QP - the quality number of the stream
     */
    _onVideoEncoderAvgQP(QP) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.VideoEncoderAvgQPEvent({ avgQP: QP }));
    }
    /**
     * Set up functionality to happen when receiving and handling initial settings for the UE app
     * @param settings - initial UE app settings
     */
    _onInitialSettings(settings) {
        var _a;
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.InitialSettingsEvent({ settings }));
        if (settings.PixelStreamingSettings) {
            this.allowConsoleCommands = (_a = settings.PixelStreamingSettings.AllowPixelStreamingCommands) !== null && _a !== void 0 ? _a : false;
            if (this.allowConsoleCommands === false) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-AllowPixelStreamingCommands=false, sending arbitrary console commands from browser to UE is disabled.');
            }
        }
        const useUrlParams = this.config.useUrlParams;
        const urlParams = new _Util_IURLSearchParams__WEBPACK_IMPORTED_MODULE_6__.IURLSearchParams(window.location.search);
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Info(`using URL parameters ${useUrlParams}`);
        if (settings.EncoderSettings) {
            // here we should either get Min/MaxQP from PS1
            // or Min/MaxQuality from PS2
            // we only want to set one set or the other as they converge in CompatQualityMin/Max and
            // we dont want to have them conflict with default values.
            if (settings.EncoderSettings.MinQP) {
                this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQP, 
                // If a setting is set in the URL, make sure we respect that value as opposed to what the application sends us
                useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQP)
                    ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQP))
                    : settings.EncoderSettings.MinQP || 0);
                this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQP, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQP)
                    ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQP))
                    : settings.EncoderSettings.MaxQP || 51);
            }
            if (settings.EncoderSettings.MinQuality) {
                this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQuality, 
                // If a setting is set in the URL, make sure we respect that value as opposed to what the application sends us
                useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQuality)
                    ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQuality))
                    : settings.EncoderSettings.MinQuality || 0);
                this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQuality, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQuality)
                    ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQuality))
                    : settings.EncoderSettings.MaxQuality || 100);
            }
            // these two are just used to converge quality and qp and behave slightly differently since they
            // shouldnt exist in EncoderSettings
            if (useUrlParams) {
                if (urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin)) {
                    this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin, Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin)));
                }
                if (urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax)) {
                    this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax, Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax)));
                }
            }
        }
        if (settings.WebRTCSettings) {
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMinBitrate, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMinBitrate)
                ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMinBitrate))
                : settings.WebRTCSettings.MinBitrate / 1000 /* bps to kbps */);
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMaxBitrate, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMaxBitrate)
                ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMaxBitrate))
                : settings.WebRTCSettings.MaxBitrate / 1000 /* bps to kbps */);
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCFPS, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCFPS)
                ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCFPS))
                : settings.WebRTCSettings.FPS);
        }
    }
    /**
     * Set up functionality to happen when setting quality control ownership of a stream
     * @param hasQualityOwnership - does this user have quality ownership of the stream true / false
     */
    _onQualityControlOwnership(hasQualityOwnership) {
        this.config.setFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.IsQualityController, hasQualityOwnership);
    }
    _onPlayerCount(playerCount) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.PlayerCountEvent({ count: playerCount }));
    }
    _onSubscribeFailed(message) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.SubscribeFailedEvent({ message: message }));
    }
    // Sets up to emit the webrtc tcp relay detect event
    _setupWebRtcTCPRelayDetection(statsReceivedEvent) {
        // Get the active candidate pair
        const activeCandidatePair = statsReceivedEvent.data.aggregatedStats.getActiveCandidatePair();
        // Check if the active candidate pair is not null
        if (activeCandidatePair != null) {
            // Get the local candidate assigned to the active candidate pair
            const localCandidate = statsReceivedEvent.data.aggregatedStats.localCandidates.find((candidate) => candidate.id == activeCandidatePair.localCandidateId, null);
            // Check if the local candidate is not null, candidate type is relay and the relay protocol is tcp
            if (localCandidate != null &&
                localCandidate.candidateType == 'relay' &&
                localCandidate.relayProtocol == 'tcp') {
                // Send the web rtc tcp relay detected event
                this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcTCPRelayDetectedEvent());
            }
            // The check is completed and the stats listen event can be removed
            this._eventEmitter.removeEventListener('statsReceived', this._setupWebRtcTCPRelayDetection);
        }
    }
    /**
     * Request a connection latency test.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     * @returns
     */
    requestLatencyTest() {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendLatencyTest();
        return true;
    }
    /**
     * Request a data channel latency test.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     */
    requestDataChannelLatencyTest(config) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        if (!this._dataChannelLatencyTestController) {
            this._dataChannelLatencyTestController = new _DataChannel_DataChannelLatencyTestController__WEBPACK_IMPORTED_MODULE_7__.DataChannelLatencyTestController(this._webRtcController.sendDataChannelLatencyTest.bind(this._webRtcController), (result) => {
                this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.DataChannelLatencyTestResultEvent({ result }));
            });
            this.addEventListener('dataChannelLatencyTestResponse', ({ data: { response } }) => {
                this._dataChannelLatencyTestController.receive(response);
            });
        }
        return this._dataChannelLatencyTestController.start(config);
    }
    /**
     * Request for the UE application to show FPS counter.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     * @returns
     */
    requestShowFps() {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendShowFps();
        return true;
    }
    /**
     * Request for a new IFrame from the UE application.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     * @returns
     */
    requestIframe() {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendIframeRequest();
        return true;
    }
    /**
     * Send data to UE application. The data will be run through JSON.stringify() so e.g. strings
     * and any serializable plain JSON objects with no recurrence can be sent.
     * @returns true if succeeded, false if rejected
     */
    emitUIInteraction(descriptor) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.emitUIInteraction(descriptor);
        return true;
    }
    /**
     * Send a command to UE application. Blocks ConsoleCommand descriptors unless UE
     * has signaled that it allows console commands.
     * @returns true if succeeded, false if rejected
     */
    emitCommand(descriptor) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        if (!this.allowConsoleCommands && 'ConsoleCommand' in descriptor) {
            return false;
        }
        this._webRtcController.emitCommand(descriptor);
        return true;
    }
    /**
     * Send a console command to UE application. Only allowed if UE has signaled that it allows
     * console commands.
     * @returns true if succeeded, false if rejected
     */
    emitConsoleCommand(command) {
        if (!this.allowConsoleCommands || !this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.emitConsoleCommand(command);
        return true;
    }
    /**
     * Sets the text contents of the currently focused UE text box widget.
     * @param contents The new contents of the UE text box.
     * @returns True if the message could be sent.
     */
    sendTextboxEntry(contents) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendTextboxEntry(contents);
        return true;
    }
    /**
     * Add a UE -> browser response event listener
     * @param name - The name of the response handler
     * @param listener - The method to be activated when a message is received
     */
    addResponseEventListener(name, listener) {
        this._webRtcController.responseController.addResponseEventListener(name, listener);
    }
    /**
     * Remove a UE -> browser response event listener
     * @param name - The name of the response handler
     */
    removeResponseEventListener(name) {
        this._webRtcController.responseController.removeResponseEventListener(name);
    }
    /**
     * Dispatch a new event.
     * @param e event
     * @returns
     */
    dispatchEvent(e) {
        return this._eventEmitter.dispatchEvent(e);
    }
    /**
     * Register an event handler.
     * @param type event name
     * @param listener event handler function
     */
    addEventListener(type, listener) {
        this._eventEmitter.addEventListener(type, listener);
    }
    /**
     * Remove an event handler.
     * @param type event name
     * @param listener event handler function
     */
    removeEventListener(type, listener) {
        this._eventEmitter.removeEventListener(type, listener);
    }
    /**
     * Enable/disable XR mode.
     */
    toggleXR() {
        this.webXrController.xrClicked();
    }
    /**
     * Pass in a function to generate a signalling server URL.
     * This function is useful if you need to programmatically construct your signalling server URL.
     * @param signallingUrlBuilderFunc A function that generates a signalling server url.
     */
    setSignallingUrlBuilder(signallingUrlBuilderFunc) {
        this._webRtcController.signallingUrlBuilder = signallingUrlBuilderFunc;
    }
    get webRtcController() {
        return this._webRtcController;
    }
    /**
     * Public getter for the websocket controller. Access to this property allows you to send
     * custom websocket messages.
     */
    get signallingProtocol() {
        return this._webRtcController.protocol;
    }
    /**
     * Public getter for the webXrController controller. Used for all XR features.
     */
    get webXrController() {
        return this._webXrController;
    }
    registerMessageHandler(name, direction, handler) {
        if (direction === _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_8__.MessageDirection.FromStreamer && typeof handler === 'undefined') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Logger.Warning(`Unable to register an undefined handler for ${name}`);
            return;
        }
        if (direction === _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_8__.MessageDirection.ToStreamer && typeof handler === 'undefined') {
            this._webRtcController.streamMessageController.registerMessageHandler(direction, name, (data) => this._webRtcController.sendMessageController.sendMessageToStreamer(name, data));
        }
        else {
            this._webRtcController.streamMessageController.registerMessageHandler(direction, name, (data) => handler(data));
        }
    }
    get toStreamerHandlers() {
        return this._webRtcController.streamMessageController.toStreamerHandlers;
    }
    isReconnecting() {
        return this._webRtcController.isReconnecting;
    }
}
//# sourceMappingURL=PixelStreaming.js.map

/***/ }),

/***/ "../../library/dist/esm/UeInstanceMessage/ResponseController.js":
/*!**********************************************************************!*\
  !*** ../../library/dist/esm/UeInstanceMessage/ResponseController.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ResponseController: () => (/* binding */ ResponseController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class ResponseController {
    constructor() {
        this.responseEventListeners = new Map();
    }
    /**
     * Add a response event listener to the response map
     * @param name - The name of the response
     * @param listener - The method to be activated when the response is selected
     */
    addResponseEventListener(name, listener) {
        this.responseEventListeners.set(name, listener);
    }
    /**
     * Remove a response event listener to the response map
     * @param name - The name of the response
     */
    removeResponseEventListener(name) {
        this.responseEventListeners.delete(name);
    }
    /**
     * Handle a response when receiving one form the streamer
     * @param message - Data received from the data channel with the command in question
     */
    onResponse(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('DataChannelReceiveMessageType.Response');
        const responses = new TextDecoder('utf-16').decode(message.slice(1));
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(responses);
        this.responseEventListeners.forEach((listener) => {
            listener(responses);
        });
    }
}
//# sourceMappingURL=ResponseController.js.map

/***/ }),

/***/ "../../library/dist/esm/UeInstanceMessage/SendMessageController.js":
/*!*************************************************************************!*\
  !*** ../../library/dist/esm/UeInstanceMessage/SendMessageController.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SendMessageController: () => (/* binding */ SendMessageController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class SendMessageController {
    /**
     * @param dataChannelSender - Data channel instance
     * @param toStreamerMessagesMapProvider - Stream Messages instance
     */
    constructor(dataChannelSender, toStreamerMessagesMapProvider) {
        this.dataChannelSender = dataChannelSender;
        this.toStreamerMessagesMapProvider = toStreamerMessagesMapProvider;
    }
    /**
     * Send a message to the streamer through the data channel
     * @param messageType - the type of message we are sending
     * @param messageData - the message data we are sending over the data channel
     * @returns - nil
     */
    sendMessageToStreamer(messageType, messageData) {
        if (messageData === undefined) {
            messageData = [];
        }
        const toStreamerMessages = this.toStreamerMessagesMapProvider.toStreamerMessages;
        const messageFormat = toStreamerMessages.get(messageType);
        if (messageFormat === undefined) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Attempted to send a message to the streamer with message type: ${messageType}, but the frontend hasn't been configured to send such a message. Check you've added the message type in your cpp`);
            return;
        }
        if (messageFormat.structure && messageData && messageFormat.structure.length !== messageData.length) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Provided message data doesn't match expected layout. Expected [ ${messageFormat.structure
                .map((element) => {
                switch (element) {
                    case 'uint8':
                    case 'uint16':
                    case 'int16':
                    case 'float':
                    case 'double':
                    default:
                        return 'number';
                    case 'string':
                        return 'string';
                }
            })
                .toString()} ] but received [ ${messageData.map((element) => typeof element).toString()} ]`);
            return;
        }
        let byteLength = 0;
        const textEncoder = new TextEncoder();
        // One loop to calculate the length in bytes of all of the provided data
        messageData.forEach((element, idx) => {
            const type = messageFormat.structure[idx];
            switch (type) {
                case 'uint8':
                    byteLength += 1;
                    break;
                case 'uint16':
                    byteLength += 2;
                    break;
                case 'int16':
                    byteLength += 2;
                    break;
                case 'float':
                    byteLength += 4;
                    break;
                case 'double':
                    byteLength += 8;
                    break;
                case 'string':
                    // 2 bytes for string length
                    byteLength += 2;
                    // 2 bytes per characters
                    byteLength += 2 * textEncoder.encode(element).length;
                    break;
            }
        });
        const data = new DataView(new ArrayBuffer(byteLength + 1));
        data.setUint8(0, messageFormat.id);
        let byteOffset = 1;
        messageData.forEach((element, idx) => {
            const type = messageFormat.structure[idx];
            switch (type) {
                case 'uint8':
                    data.setUint8(byteOffset, element);
                    byteOffset += 1;
                    break;
                case 'uint16':
                    data.setUint16(byteOffset, element, true);
                    byteOffset += 2;
                    break;
                case 'int16':
                    data.setInt16(byteOffset, element, true);
                    byteOffset += 2;
                    break;
                case 'float':
                    data.setFloat32(byteOffset, element, true);
                    byteOffset += 4;
                    break;
                case 'double':
                    data.setFloat64(byteOffset, element, true);
                    byteOffset += 8;
                    break;
                case 'string':
                    data.setUint16(byteOffset, element.length, true);
                    byteOffset += 2;
                    for (let i = 0; i < element.length; i++) {
                        data.setUint16(byteOffset, element.charCodeAt(i), true);
                        byteOffset += 2;
                    }
                    break;
            }
        });
        if (!this.dataChannelSender.canSend()) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data channel cannot send yet, skipping sending message: ${messageType} - ${new Uint8Array(data.buffer)}`);
            return;
        }
        this.dataChannelSender.sendData(data.buffer);
    }
}
//# sourceMappingURL=SendMessageController.js.map

/***/ }),

/***/ "../../library/dist/esm/UeInstanceMessage/StreamMessageController.js":
/*!***************************************************************************!*\
  !*** ../../library/dist/esm/UeInstanceMessage/StreamMessageController.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MessageDirection: () => (/* binding */ MessageDirection),
/* harmony export */   StreamMessageController: () => (/* binding */ StreamMessageController),
/* harmony export */   ToStreamerMessage: () => (/* binding */ ToStreamerMessage)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class ToStreamerMessage {
}
class StreamMessageController {
    constructor() {
        this.toStreamerHandlers = new Map();
        this.fromStreamerHandlers = new Map();
        this.toStreamerMessages = new Map();
        this.fromStreamerMessages = new Map();
    }
    /**
     * Populate the Default message protocol
     */
    populateDefaultProtocol() {
        /*
         * Control Messages. Range = 0..49.
         */
        this.toStreamerMessages.set('IFrameRequest', {
            id: 0,
            structure: []
        });
        this.toStreamerMessages.set('RequestQualityControl', {
            id: 1,
            structure: []
        });
        this.toStreamerMessages.set('FpsRequest', {
            id: 2,
            structure: []
        });
        this.toStreamerMessages.set('AverageBitrateRequest', {
            id: 3,
            structure: []
        });
        this.toStreamerMessages.set('StartStreaming', {
            id: 4,
            structure: []
        });
        this.toStreamerMessages.set('StopStreaming', {
            id: 5,
            structure: []
        });
        this.toStreamerMessages.set('LatencyTest', {
            id: 6,
            structure: ['string']
        });
        this.toStreamerMessages.set('RequestInitialSettings', {
            id: 7,
            structure: []
        });
        this.toStreamerMessages.set('TestEcho', {
            id: 8,
            structure: []
        });
        this.toStreamerMessages.set('DataChannelLatencyTest', {
            id: 9,
            structure: []
        });
        /*
         * Input Messages. Range = 50..89.
         */
        // Generic Input Messages. Range = 50..59.
        this.toStreamerMessages.set('UIInteraction', {
            id: 50,
            structure: ['string']
        });
        this.toStreamerMessages.set('Command', {
            id: 51,
            structure: ['string']
        });
        this.toStreamerMessages.set('TextboxEntry', {
            id: 52,
            structure: ['string']
        });
        // Keyboard Input Message. Range = 60..69.
        this.toStreamerMessages.set('KeyDown', {
            id: 60,
            //            keyCode  isRepeat
            structure: ['uint8', 'uint8']
        });
        this.toStreamerMessages.set('KeyUp', {
            id: 61,
            //            keyCode
            structure: ['uint8']
        });
        this.toStreamerMessages.set('KeyPress', {
            id: 62,
            //            charcode
            structure: ['uint16']
        });
        // Mouse Input Messages. Range = 70..79.
        this.toStreamerMessages.set('MouseEnter', {
            id: 70,
            structure: []
        });
        this.toStreamerMessages.set('MouseLeave', {
            id: 71,
            structure: []
        });
        this.toStreamerMessages.set('MouseDown', {
            id: 72,
            //              button     x         y
            structure: ['uint8', 'uint16', 'uint16']
        });
        this.toStreamerMessages.set('MouseUp', {
            id: 73,
            //              button     x         y
            structure: ['uint8', 'uint16', 'uint16']
        });
        this.toStreamerMessages.set('MouseMove', {
            id: 74,
            //              x           y      deltaX    deltaY
            structure: ['uint16', 'uint16', 'int16', 'int16']
        });
        this.toStreamerMessages.set('MouseWheel', {
            id: 75,
            //              delta       x        y
            structure: ['int16', 'uint16', 'uint16']
        });
        this.toStreamerMessages.set('MouseDouble', {
            id: 76,
            //              button     x         y
            structure: ['uint8', 'uint16', 'uint16']
        });
        // Touch Input Messages. Range = 80..89.
        this.toStreamerMessages.set('TouchStart', {
            id: 80,
            //          numtouches(1)   x       y        idx     force     valid
            structure: ['uint8', 'uint16', 'uint16', 'uint8', 'uint8', 'uint8']
        });
        this.toStreamerMessages.set('TouchEnd', {
            id: 81,
            //          numtouches(1)   x       y        idx     force     valid
            structure: ['uint8', 'uint16', 'uint16', 'uint8', 'uint8', 'uint8']
        });
        this.toStreamerMessages.set('TouchMove', {
            id: 82,
            //          numtouches(1)   x       y       idx      force     valid
            structure: ['uint8', 'uint16', 'uint16', 'uint8', 'uint8', 'uint8']
        });
        // Gamepad Input Messages. Range = 90..99
        this.toStreamerMessages.set('GamepadConnected', {
            id: 93,
            structure: []
        });
        this.toStreamerMessages.set('GamepadButtonPressed', {
            id: 90,
            //         ctrlerId   button  isRepeat
            structure: ['uint8', 'uint8', 'uint8']
        });
        this.toStreamerMessages.set('GamepadButtonReleased', {
            id: 91,
            //         ctrlerId   button  isRepeat(0)
            structure: ['uint8', 'uint8', 'uint8']
        });
        this.toStreamerMessages.set('GamepadAnalog', {
            id: 92,
            //         ctrlerId   button  analogValue
            structure: ['uint8', 'uint8', 'double']
        });
        this.toStreamerMessages.set('GamepadDisconnected', {
            id: 94,
            //          ctrlerId
            structure: ['uint8']
        });
        this.fromStreamerMessages.set(0, 'QualityControlOwnership');
        this.fromStreamerMessages.set(1, 'Response');
        this.fromStreamerMessages.set(2, 'Command');
        this.fromStreamerMessages.set(3, 'FreezeFrame');
        this.fromStreamerMessages.set(4, 'UnfreezeFrame');
        this.fromStreamerMessages.set(5, 'VideoEncoderAvgQP');
        this.fromStreamerMessages.set(6, 'LatencyTest');
        this.fromStreamerMessages.set(7, 'InitialSettings');
        this.fromStreamerMessages.set(8, 'FileExtension');
        this.fromStreamerMessages.set(9, 'FileMimeType');
        this.fromStreamerMessages.set(10, 'FileContents');
        this.fromStreamerMessages.set(11, 'TestEcho');
        this.fromStreamerMessages.set(12, 'InputControlOwnership');
        this.fromStreamerMessages.set(13, 'GamepadResponse');
        this.fromStreamerMessages.set(14, 'DataChannelLatencyTest');
        this.fromStreamerMessages.set(255, 'Protocol');
    }
    /**
     * Register a message handler
     * @param messageDirection - the direction of the message; toStreamer or fromStreamer
     * @param messageType - the type of the message
     * @param messageHandler - the function or method to be executed when this handler is called
     */
    registerMessageHandler(messageDirection, messageType, messageHandler) {
        switch (messageDirection) {
            case MessageDirection.ToStreamer:
                this.toStreamerHandlers.set(messageType, messageHandler);
                break;
            case MessageDirection.FromStreamer:
                this.fromStreamerHandlers.set(messageType, messageHandler);
                break;
            default:
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Unknown message direction ${messageDirection}`);
        }
    }
}
/**
 * The enum for message directions
 */
var MessageDirection;
(function (MessageDirection) {
    MessageDirection[MessageDirection["ToStreamer"] = 0] = "ToStreamer";
    MessageDirection[MessageDirection["FromStreamer"] = 1] = "FromStreamer";
})(MessageDirection || (MessageDirection = {}));
//# sourceMappingURL=StreamMessageController.js.map

/***/ }),

/***/ "../../library/dist/esm/UeInstanceMessage/ToStreamerMessagesController.js":
/*!********************************************************************************!*\
  !*** ../../library/dist/esm/UeInstanceMessage/ToStreamerMessagesController.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ToStreamerMessagesController: () => (/* binding */ ToStreamerMessagesController)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class ToStreamerMessagesController {
    /**
     * @param sendMessageController - Stream message controller instance
     */
    constructor(sendMessageController) {
        this.sendMessageController = sendMessageController;
    }
    /**
     * Send Request to Take Quality Control to the UE Instance
     */
    SendRequestQualityControl() {
        this.sendMessageController.sendMessageToStreamer('RequestQualityControl');
    }
    /**
     * Send Max FPS Request to the UE Instance
     */
    SendMaxFpsRequest() {
        this.sendMessageController.sendMessageToStreamer('FpsRequest');
    }
    /**
     * Send Average Bitrate Request to the UE Instance
     */
    SendAverageBitrateRequest() {
        this.sendMessageController.sendMessageToStreamer('AverageBitrateRequest');
    }
    /**
     * Send a Start Streaming Message to the UE Instance
     */
    SendStartStreaming() {
        this.sendMessageController.sendMessageToStreamer('StartStreaming');
    }
    /**
     * Send a Stop Streaming Message to the UE Instance
     */
    SendStopStreaming() {
        this.sendMessageController.sendMessageToStreamer('StopStreaming');
    }
    /**
     * Send a Request Initial Settings to the UE Instance
     */
    SendRequestInitialSettings() {
        this.sendMessageController.sendMessageToStreamer('RequestInitialSettings');
    }
}
//# sourceMappingURL=ToStreamerMessagesController.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/BrowserUtils.js":
/*!***************************************************!*\
  !*** ../../library/dist/esm/Util/BrowserUtils.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BrowserUtils: () => (/* binding */ BrowserUtils)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class BrowserUtils {
    static getSupportedVideoCodecs() {
        const browserSupportedCodecs = [];
        // Try get the info needed from the RTCRtpReceiver. This is only available on chrome
        if (!RTCRtpReceiver.getCapabilities) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Warning('RTCRtpReceiver.getCapabilities API is not available in your browser, defaulting to guess that we support H.264.');
            browserSupportedCodecs.push('H264 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f');
            return browserSupportedCodecs;
        }
        const matcher = /(VP\d|H26\d|AV1).*/;
        const capabilities = RTCRtpReceiver.getCapabilities('video');
        if (!capabilities) {
            browserSupportedCodecs.push('H264 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f');
            return browserSupportedCodecs;
        }
        capabilities.codecs.forEach((codec) => {
            const str = codec.mimeType.split('/')[1] + ' ' + (codec.sdpFmtpLine || '');
            const match = matcher.exec(str);
            if (match !== null) {
                browserSupportedCodecs.push(str);
            }
        });
        return browserSupportedCodecs;
    }
}
//# sourceMappingURL=BrowserUtils.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/EventEmitter.js":
/*!***************************************************!*\
  !*** ../../library/dist/esm/Util/EventEmitter.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AfkTimedOutEvent: () => (/* binding */ AfkTimedOutEvent),
/* harmony export */   AfkWarningActivateEvent: () => (/* binding */ AfkWarningActivateEvent),
/* harmony export */   AfkWarningDeactivateEvent: () => (/* binding */ AfkWarningDeactivateEvent),
/* harmony export */   AfkWarningUpdateEvent: () => (/* binding */ AfkWarningUpdateEvent),
/* harmony export */   DataChannelCloseEvent: () => (/* binding */ DataChannelCloseEvent),
/* harmony export */   DataChannelErrorEvent: () => (/* binding */ DataChannelErrorEvent),
/* harmony export */   DataChannelLatencyTestResponseEvent: () => (/* binding */ DataChannelLatencyTestResponseEvent),
/* harmony export */   DataChannelLatencyTestResultEvent: () => (/* binding */ DataChannelLatencyTestResultEvent),
/* harmony export */   DataChannelOpenEvent: () => (/* binding */ DataChannelOpenEvent),
/* harmony export */   HideFreezeFrameEvent: () => (/* binding */ HideFreezeFrameEvent),
/* harmony export */   InitialSettingsEvent: () => (/* binding */ InitialSettingsEvent),
/* harmony export */   LatencyCalculatedEvent: () => (/* binding */ LatencyCalculatedEvent),
/* harmony export */   LatencyTestResultEvent: () => (/* binding */ LatencyTestResultEvent),
/* harmony export */   LoadFreezeFrameEvent: () => (/* binding */ LoadFreezeFrameEvent),
/* harmony export */   PixelStreamingEventEmitter: () => (/* binding */ PixelStreamingEventEmitter),
/* harmony export */   PlayStreamErrorEvent: () => (/* binding */ PlayStreamErrorEvent),
/* harmony export */   PlayStreamEvent: () => (/* binding */ PlayStreamEvent),
/* harmony export */   PlayStreamRejectedEvent: () => (/* binding */ PlayStreamRejectedEvent),
/* harmony export */   PlayerCountEvent: () => (/* binding */ PlayerCountEvent),
/* harmony export */   SettingsChangedEvent: () => (/* binding */ SettingsChangedEvent),
/* harmony export */   ShowOnScreenKeyboardEvent: () => (/* binding */ ShowOnScreenKeyboardEvent),
/* harmony export */   StatsReceivedEvent: () => (/* binding */ StatsReceivedEvent),
/* harmony export */   StreamLoadingEvent: () => (/* binding */ StreamLoadingEvent),
/* harmony export */   StreamPreConnectEvent: () => (/* binding */ StreamPreConnectEvent),
/* harmony export */   StreamPreDisconnectEvent: () => (/* binding */ StreamPreDisconnectEvent),
/* harmony export */   StreamReconnectEvent: () => (/* binding */ StreamReconnectEvent),
/* harmony export */   StreamerIDChangedMessageEvent: () => (/* binding */ StreamerIDChangedMessageEvent),
/* harmony export */   StreamerListMessageEvent: () => (/* binding */ StreamerListMessageEvent),
/* harmony export */   SubscribeFailedEvent: () => (/* binding */ SubscribeFailedEvent),
/* harmony export */   VideoEncoderAvgQPEvent: () => (/* binding */ VideoEncoderAvgQPEvent),
/* harmony export */   VideoInitializedEvent: () => (/* binding */ VideoInitializedEvent),
/* harmony export */   WebRtcAutoConnectEvent: () => (/* binding */ WebRtcAutoConnectEvent),
/* harmony export */   WebRtcConnectedEvent: () => (/* binding */ WebRtcConnectedEvent),
/* harmony export */   WebRtcConnectingEvent: () => (/* binding */ WebRtcConnectingEvent),
/* harmony export */   WebRtcDisconnectedEvent: () => (/* binding */ WebRtcDisconnectedEvent),
/* harmony export */   WebRtcFailedEvent: () => (/* binding */ WebRtcFailedEvent),
/* harmony export */   WebRtcSdpAnswerEvent: () => (/* binding */ WebRtcSdpAnswerEvent),
/* harmony export */   WebRtcSdpEvent: () => (/* binding */ WebRtcSdpEvent),
/* harmony export */   WebRtcSdpOfferEvent: () => (/* binding */ WebRtcSdpOfferEvent),
/* harmony export */   WebRtcTCPRelayDetectedEvent: () => (/* binding */ WebRtcTCPRelayDetectedEvent),
/* harmony export */   XrFrameEvent: () => (/* binding */ XrFrameEvent),
/* harmony export */   XrSessionEndedEvent: () => (/* binding */ XrSessionEndedEvent),
/* harmony export */   XrSessionStartedEvent: () => (/* binding */ XrSessionStartedEvent)
/* harmony export */ });
/**
 * An event that is emitted when AFK disconnect is about to happen.
 * Can be cancelled by calling the callback function provided as part of the event.
 */
class AfkWarningActivateEvent extends Event {
    constructor(data) {
        super('afkWarningActivate');
        this.data = data;
    }
}
/**
 * An event that is emitted when the AFK disconnect countdown is updated.
 */
class AfkWarningUpdateEvent extends Event {
    constructor(data) {
        super('afkWarningUpdate');
        this.data = data;
    }
}
/**
 * An event that is emitted when AFK warning is deactivated.
 */
class AfkWarningDeactivateEvent extends Event {
    constructor() {
        super('afkWarningDeactivate');
    }
}
/**
 * An event that is emitted when AFK countdown reaches 0 and the user is disconnected.
 */
class AfkTimedOutEvent extends Event {
    constructor() {
        super('afkTimedOut');
    }
}
/**
 * An event that is emitted when we receive new video quality value.
 */
class VideoEncoderAvgQPEvent extends Event {
    constructor(data) {
        super('videoEncoderAvgQP');
        this.data = data;
    }
}
/**
 * An event that is emitted after a WebRtc connection has been negotiated.
 */
class WebRtcSdpEvent extends Event {
    constructor() {
        super('webRtcSdp');
    }
}
/**
 * An event that is emitted after the SDP answer is set.
 */
class WebRtcSdpAnswerEvent extends Event {
    constructor(data) {
        super('webRtcSdpAnswer');
        this.data = data;
    }
}
/**
 * An event that is emitted after the SDP offer is set.
 */
class WebRtcSdpOfferEvent extends Event {
    constructor(data) {
        super('webRtcSdpOffer');
        this.data = data;
    }
}
/**
 * An event that is emitted when auto connecting.
 */
class WebRtcAutoConnectEvent extends Event {
    constructor() {
        super('webRtcAutoConnect');
    }
}
/**
 * An event that is emitted when sending a WebRtc offer.
 */
class WebRtcConnectingEvent extends Event {
    constructor() {
        super('webRtcConnecting');
    }
}
/**
 * An event that is emitted when WebRtc connection has been established.
 */
class WebRtcConnectedEvent extends Event {
    constructor() {
        super('webRtcConnected');
    }
}
/**
 * An event that is emitted if WebRtc connection has failed.
 */
class WebRtcFailedEvent extends Event {
    constructor() {
        super('webRtcFailed');
    }
}
/**
 * An event that is emitted if WebRtc connection is disconnected.
 */
class WebRtcDisconnectedEvent extends Event {
    constructor(data) {
        super('webRtcDisconnected');
        this.data = data;
    }
}
/**
 * An event that is emitted when RTCDataChannel is opened.
 */
class DataChannelOpenEvent extends Event {
    constructor(data) {
        super('dataChannelOpen');
        this.data = data;
    }
}
/**
 * An event that is emitted when RTCDataChannel is closed.
 */
class DataChannelCloseEvent extends Event {
    constructor(data) {
        super('dataChannelClose');
        this.data = data;
    }
}
/**
 * An event that is emitted on RTCDataChannel errors.
 */
class DataChannelErrorEvent extends Event {
    constructor(data) {
        super('dataChannelError');
        this.data = data;
    }
}
/**
 * An event that is emitted when the video stream has been initialized.
 */
class VideoInitializedEvent extends Event {
    constructor() {
        super('videoInitialized');
    }
}
/**
 * An event that is emitted when video stream loading starts.
 */
class StreamLoadingEvent extends Event {
    constructor() {
        super('streamLoading');
    }
}
/**
 * An event that is emitted when video stream loading has finished.
 */
class StreamPreConnectEvent extends Event {
    constructor() {
        super('streamConnect');
    }
}
/**
 * An event that is emitted when video stream has stopped.
 */
class StreamPreDisconnectEvent extends Event {
    constructor() {
        super('streamDisconnect');
    }
}
/**
 * An event that is emitted when video stream is reconnecting.
 */
class StreamReconnectEvent extends Event {
    constructor() {
        super('streamReconnect');
    }
}
/**
 * An event that is emitted if there are errors loading the video stream.
 */
class PlayStreamErrorEvent extends Event {
    constructor(data) {
        super('playStreamError');
        this.data = data;
    }
}
/**
 * An event that is emitted before trying to start video playback.
 */
class PlayStreamEvent extends Event {
    constructor() {
        super('playStream');
    }
}
/**
 * An event that is emitted if the browser rejects video playback. Can happen for example if
 * video auto-play without user interaction is refused by the browser.
 */
class PlayStreamRejectedEvent extends Event {
    constructor(data) {
        super('playStreamRejected');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving a full FreezeFrame image from UE.
 */
class LoadFreezeFrameEvent extends Event {
    constructor(data) {
        super('loadFreezeFrame');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving UnfreezeFrame message from UE and video playback is about to be resumed.
 */
class HideFreezeFrameEvent extends Event {
    constructor() {
        super('hideFreezeFrame');
    }
}
/**
 * An event that is emitted when receiving WebRTC statistics.
 */
class StatsReceivedEvent extends Event {
    constructor(data) {
        super('statsReceived');
        this.data = data;
    }
}
/**
 * An event that is emitted when streamer list changes.
 */
class StreamerListMessageEvent extends Event {
    constructor(data) {
        super('streamerListMessage');
        this.data = data;
    }
}
/**
 * An event that is emitted when a subscribed to streamer's id changes.
 */
class StreamerIDChangedMessageEvent extends Event {
    constructor(data) {
        super('StreamerIDChangedMessage');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving latency test results.
 */
class LatencyTestResultEvent extends Event {
    constructor(data) {
        super('latencyTestResult');
        this.data = data;
    }
}
/**
 * An event that is emitted everytime latency is calculated using the WebRTC stats API.
 */
class LatencyCalculatedEvent extends Event {
    constructor(data) {
        super('latencyCalculated');
        this.data = data;
    }
}
/**
 * An event that is emitted when we receive the "onScreenKeyboard" command from UE.
 */
class ShowOnScreenKeyboardEvent extends Event {
    constructor(data) {
        super('showOnScreenKeyboard');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving data channel latency test response from server.
 * This event is handled by DataChannelLatencyTestController
 */
class DataChannelLatencyTestResponseEvent extends Event {
    constructor(data) {
        super('dataChannelLatencyTestResponse');
        this.data = data;
    }
}
/**
 * An event that is emitted when data channel latency test results are ready.
 */
class DataChannelLatencyTestResultEvent extends Event {
    constructor(data) {
        super('dataChannelLatencyTestResult');
        this.data = data;
    }
}
class SubscribeFailedEvent extends Event {
    constructor(data) {
        super('subscribeFailed');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving initial settings from UE.
 */
class InitialSettingsEvent extends Event {
    constructor(data) {
        super('initialSettings');
        this.data = data;
    }
}
/**
 * An event that is emitted when PixelStreaming settings change.
 */
class SettingsChangedEvent extends Event {
    constructor(data) {
        super('settingsChanged');
        this.data = data;
    }
}
/**
 * Event emitted when an XR Session starts
 */
class XrSessionStartedEvent extends Event {
    constructor() {
        super('xrSessionStarted');
    }
}
/**
 * Event emitted when an XR Session ends
 */
class XrSessionEndedEvent extends Event {
    constructor() {
        super('xrSessionEnded');
    }
}
/**
 * Event emitted when an XR Frame is complete
 */
class XrFrameEvent extends Event {
    constructor(data) {
        super('xrFrame');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving a player count from the signalling server
 */
class PlayerCountEvent extends Event {
    constructor(data) {
        super('playerCount');
        this.data = data;
    }
}
/**
 * An event that is emitted when the webRTC connections is relayed over TCP.
 */
class WebRtcTCPRelayDetectedEvent extends Event {
    constructor() {
        super('webRtcTCPRelayDetected');
    }
}
class PixelStreamingEventEmitter extends EventTarget {
    /**
     * Dispatch a new event.
     * @param e event
     * @returns
     */
    dispatchEvent(e) {
        return super.dispatchEvent(e);
    }
    /**
     * Register an event handler.
     * @param type event name
     * @param listener event handler function
     */
    addEventListener(type, listener) {
        super.addEventListener(type, listener);
    }
    /**
     * Remove an event handler.
     * @param type event name
     * @param listener event handler function
     */
    removeEventListener(type, listener) {
        super.removeEventListener(type, listener);
    }
}
//# sourceMappingURL=EventEmitter.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/FileUtil.js":
/*!***********************************************!*\
  !*** ../../library/dist/esm/Util/FileUtil.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FileTemplate: () => (/* binding */ FileTemplate),
/* harmony export */   FileUtil: () => (/* binding */ FileUtil)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Utility function for populate file information from byte buffers.
 */
class FileUtil {
    /**
     * Processes a files extension when received over data channel
     * @param view - the file extension data
     */
    static setExtensionFromBytes(view, file) {
        // Reset file if we got a file message and we are not "receiving" it yet
        if (!file.receiving) {
            file.mimetype = '';
            file.extension = '';
            file.receiving = true;
            file.valid = false;
            file.chunks = 0;
            file.data = [];
            file.timestampStart = new Date().getTime();
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Received first chunk of file');
        }
        const extensionAsString = new TextDecoder('utf-16').decode(view.slice(1));
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(extensionAsString);
        file.extension = extensionAsString;
    }
    /**
     * Processes a files mime type when received over data channel
     * @param view - the file mime type data
     */
    static setMimeTypeFromBytes(view, file) {
        // Reset file if we got a file message and we are not "receiving" it yet
        if (!file.receiving) {
            file.mimetype = '';
            file.extension = '';
            file.receiving = true;
            file.valid = false;
            file.chunks = 0;
            file.data = [];
            file.timestampStart = new Date().getTime();
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Received first chunk of file');
        }
        const mimeAsString = new TextDecoder('utf-16').decode(view.slice(1));
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(mimeAsString);
        file.mimetype = mimeAsString;
    }
    /**
     * Processes a files contents when received over data channel
     * @param view - the file contents data
     */
    static setContentsFromBytes(view, file) {
        // If we haven't received the initial setup instructions, return
        if (!file.receiving)
            return;
        const typeSize = 1;
        const intSize = 4;
        const maxMessageSize = 16 * 1024;
        const headerSize = typeSize + intSize;
        const maxPayloadSize = maxMessageSize - headerSize;
        // Calculate total number of chunks from the total file size
        file.chunks = Math.ceil(new DataView(view.slice(typeSize, headerSize).buffer).getInt32(0, true) / maxPayloadSize);
        // Get the file part of the payload
        const fileBytes = view.slice(headerSize);
        // Append to existing data that holds the file
        file.data.push(fileBytes);
        // Uncomment for debug
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Received file chunk: ${file.data.length}/${file.chunks}`);
        if (file.data.length === file.chunks) {
            file.receiving = false;
            file.valid = true;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Received complete file');
            const transferDuration = new Date().getTime() - file.timestampStart;
            const transferBitrate = Math.round((file.chunks * maxMessageSize) / transferDuration);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Average transfer bitrate: ${transferBitrate}kb/s over ${transferDuration / 1000} seconds`);
            // File reconstruction
            /**
             * Example code to reconstruct the file
             *
             * This code reconstructs the received data into the original file based on the mime type and extension provided and then downloads the reconstructed file
             */
            const received = new Blob(file.data, { type: file.mimetype });
            const a = document.createElement('a');
            a.setAttribute('href', URL.createObjectURL(received));
            a.setAttribute('download', `transfer.${file.extension}`);
            document.body.append(a);
            // if you are so inclined to make it auto-download, do something like: a.click();
            a.remove();
        }
        else if (file.data.length > file.chunks) {
            file.receiving = false;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Received bigger file than advertised: ${file.data.length}/${file.chunks}`);
        }
    }
}
/**
 * A class that represents a template for a downloaded file
 */
class FileTemplate {
    constructor() {
        this.mimetype = '';
        this.extension = '';
        this.receiving = false;
        this.chunks = 0;
        this.data = [];
        this.valid = false;
    }
}
//# sourceMappingURL=FileUtil.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/IURLSearchParams.js":
/*!*******************************************************!*\
  !*** ../../library/dist/esm/Util/IURLSearchParams.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IURLSearchParams: () => (/* binding */ IURLSearchParams)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * A case insensitive, partial implementation of URLSearchParams
 */
class IURLSearchParams {
    constructor(search) {
        this._urlParams = {};
        const urlParams = new URLSearchParams(search);
        for (const [name, value] of urlParams) {
            this._urlParams[name.toLowerCase()] = value;
        }
    }
    has(name) {
        return name.toLowerCase() in this._urlParams;
    }
    get(name) {
        if (this.has(name)) {
            return this._urlParams[name.toLowerCase()];
        }
        return null;
    }
}
//# sourceMappingURL=IURLSearchParams.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/InputCoordTranslator.js":
/*!***********************************************************!*\
  !*** ../../library/dist/esm/Util/InputCoordTranslator.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InputCoordTranslator: () => (/* binding */ InputCoordTranslator)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Converts coordinates from element relative coordinates to values normalized within the value range of a short (and back again)
 */
class InputCoordTranslator {
    // we dont use a constructor here because the object is created and passed around to various locations
    // possibly before this method is called.
    reconfigure(playerSize, videoSize) {
        const playerAspectRatio = playerSize.height / playerSize.width;
        const videoAspectRatio = videoSize.height / videoSize.width;
        this.playerIsLarger = playerAspectRatio > videoAspectRatio;
        this.playerSize = playerSize;
        this.ratio = this.playerIsLarger
            ? playerAspectRatio / videoAspectRatio
            : videoAspectRatio / playerAspectRatio;
    }
    translateUnsigned(x, y) {
        const normalizedX = this.playerIsLarger
            ? x / this.playerSize.width
            : this.ratio * (x / this.playerSize.width - 0.5) + 0.5;
        const normalizedY = this.playerIsLarger
            ? this.ratio * (y / this.playerSize.height - 0.5) + 0.5
            : y / this.playerSize.height;
        if (normalizedX < 0.0 || normalizedX > 1.0 || normalizedY < 0.0 || normalizedY > 1.0) {
            return { inRange: false, x: 65535, y: 65535 };
        }
        else {
            return { inRange: true, x: normalizedX * 65536, y: normalizedY * 65536 };
        }
    }
    translateSigned(x, y) {
        const normalizedX = this.playerIsLarger
            ? x / (0.5 * this.playerSize.width)
            : (this.ratio * x) / (0.5 * this.playerSize.width);
        const normalizedY = this.playerIsLarger
            ? (this.ratio * y) / (0.5 * this.playerSize.height)
            : y / (0.5 * this.playerSize.height);
        return { x: normalizedX * 32767, y: normalizedY * 32767 };
    }
    untranslateUnsigned(x, y) {
        const normalizedX = this.playerIsLarger ? x / 65536 : (x / 65536 - 0.5) / this.ratio + 0.5;
        const normalizedY = this.playerIsLarger ? (y / 65536 - 0.5) / this.ratio + 0.5 : y / 65536;
        return { x: normalizedX * this.playerSize.width, y: normalizedY * this.playerSize.height };
    }
}
//# sourceMappingURL=InputCoordTranslator.js.map

/***/ }),

/***/ "../../library/dist/esm/Util/RTCUtils.js":
/*!***********************************************!*\
  !*** ../../library/dist/esm/Util/RTCUtils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RTCUtils: () => (/* binding */ RTCUtils)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class RTCUtils {
    static isVideoTransceiver(transceiver) {
        return this.canTransceiverReceiveVideo(transceiver) || this.canTransceiverSendVideo(transceiver);
    }
    static canTransceiverReceiveVideo(transceiver) {
        return (!!transceiver &&
            (transceiver.direction === 'sendrecv' || transceiver.direction === 'recvonly') &&
            transceiver.receiver &&
            transceiver.receiver.track &&
            transceiver.receiver.track.kind === 'video');
    }
    static canTransceiverSendVideo(transceiver) {
        return (!!transceiver &&
            (transceiver.direction === 'sendrecv' || transceiver.direction === 'sendonly') &&
            transceiver.sender &&
            transceiver.sender.track &&
            transceiver.sender.track.kind === 'video');
    }
    static isAudioTransceiver(transceiver) {
        return this.canTransceiverReceiveAudio(transceiver) || this.canTransceiverSendAudio(transceiver);
    }
    static canTransceiverReceiveAudio(transceiver) {
        return (!!transceiver &&
            (transceiver.direction === 'sendrecv' || transceiver.direction === 'recvonly') &&
            transceiver.receiver &&
            transceiver.receiver.track &&
            transceiver.receiver.track.kind === 'audio');
    }
    static canTransceiverSendAudio(transceiver) {
        return (!!transceiver &&
            (transceiver.direction === 'sendrecv' || transceiver.direction === 'sendonly') &&
            transceiver.sender &&
            transceiver.sender.track &&
            transceiver.sender.track.kind === 'audio');
    }
}
//# sourceMappingURL=RTCUtils.js.map

/***/ }),

/***/ "../../library/dist/esm/VideoPlayer/StreamController.js":
/*!**************************************************************!*\
  !*** ../../library/dist/esm/VideoPlayer/StreamController.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StreamController: () => (/* binding */ StreamController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Video Player Controller handles the creation of the video HTML element and all handlers
 */
class StreamController {
    /**
     * @param videoElementProvider Video Player instance
     */
    constructor(videoElementProvider) {
        this.videoElementProvider = videoElementProvider;
        this.audioElement = document.createElement('Audio');
        this.videoElementProvider.setAudioElement(this.audioElement);
    }
    /**
     * Handles when the Peer connection has a track event
     * @param rtcTrackEvent - RTC Track Event
     */
    handleOnTrack(rtcTrackEvent) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('handleOnTrack ' + JSON.stringify(rtcTrackEvent.streams));
        // Do not add the track if the ID is `probator` as this is special track created by mediasoup for bitrate probing.
        // Refer to https://github.com/EpicGamesExt/PixelStreamingInfrastructure/pull/86 for more details.
        if (rtcTrackEvent.streams.length < 1 || rtcTrackEvent.streams[0].id == 'probator') {
            return;
        }
        const videoElement = this.videoElementProvider.getVideoElement();
        if (rtcTrackEvent.track) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Got track - ' +
                rtcTrackEvent.track.kind +
                ' id=' +
                rtcTrackEvent.track.id +
                ' readyState=' +
                rtcTrackEvent.track.readyState);
        }
        if (rtcTrackEvent.track.kind == 'audio') {
            this.CreateAudioTrack(rtcTrackEvent.streams[0]);
            return;
        }
        else if (rtcTrackEvent.track.kind == 'video' &&
            videoElement.srcObject !== rtcTrackEvent.streams[0]) {
            videoElement.srcObject = rtcTrackEvent.streams[0];
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Set video source from video track ontrack.');
            return;
        }
    }
    /**
     * Creates the audio device when receiving an RTCTrackEvent with the kind of "audio"
     * @param audioMediaStream - Audio Media stream track
     */
    CreateAudioTrack(audioMediaStream) {
        const videoElement = this.videoElementProvider.getVideoElement();
        // do nothing the video has the same media stream as the audio track we have here (they are linked)
        if (videoElement.srcObject == audioMediaStream) {
            return;
        }
        // video element has some other media stream that is not associated with this audio track
        else if (videoElement.srcObject && videoElement.srcObject !== audioMediaStream) {
            // create a new audio element
            this.audioElement.srcObject = audioMediaStream;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Created new audio element to play separate audio stream.');
        }
    }
}
//# sourceMappingURL=StreamController.js.map

/***/ }),

/***/ "../../library/dist/esm/VideoPlayer/VideoPlayer.js":
/*!*********************************************************!*\
  !*** ../../library/dist/esm/VideoPlayer/VideoPlayer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VideoPlayer: () => (/* binding */ VideoPlayer)
/* harmony export */ });
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * The video player html element
 */
class VideoPlayer {
    /**
     * @param videoElementParent the html div the the video player will be injected into
     * @param config the applications configuration. We're interested in the startVideoMuted flag
     */
    constructor(videoElementParent, config) {
        this.lastTimeResized = new Date().getTime();
        this.videoElement = document.createElement('video');
        this.config = config;
        this.videoElement.id = 'streamingVideo';
        this.videoElement.disablePictureInPicture = true;
        this.videoElement.playsInline = true;
        this.videoElement.style.width = '100%';
        this.videoElement.style.height = '100%';
        this.videoElement.style.position = 'absolute';
        this.videoElement.style.pointerEvents = 'all';
        videoElementParent.appendChild(this.videoElement);
        this.onResizePlayerCallback = () => {
            console.log('Resolution changed, restyling player, did you forget to override this function?');
        };
        this.onMatchViewportResolutionCallback = () => {
            console.log('Resolution changed and match viewport resolution is turned on, did you forget to override this function?');
        };
        // set play for video (and audio)
        this.videoElement.onclick = () => {
            if (this.audioElement != undefined && this.audioElement.paused) {
                this.audioElement.play();
            }
            if (this.videoElement.paused) {
                this.videoElement.play();
            }
        };
        this.videoElement.onloadedmetadata = () => {
            this.onVideoInitialized();
        };
        // set resize events to the windows if it is resized or its orientation is changed
        window.addEventListener('resize', () => this.resizePlayerStyle(), true);
        window.addEventListener('orientationchange', () => this.onOrientationChange());
    }
    destroy() {
        this.videoElement.src = '';
        this.videoElement.srcObject = null;
        this.videoElement.remove();
        if (this.audioElement) {
            this.audioElement.src = '';
            this.audioElement.srcObject = null;
            this.audioElement.remove();
        }
    }
    setAudioElement(audioElement) {
        this.audioElement = audioElement;
    }
    /**
     * Sets up the video element with any application config and plays the video element.
     * @returns A promise for if playing the video was successful or not.
     */
    play() {
        this.videoElement.muted = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_0__.Flags.StartVideoMuted);
        this.videoElement.autoplay = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_0__.Flags.AutoPlayVideo);
        return this.videoElement.play();
    }
    /**
     * @returns True if the video element is paused.
     */
    isPaused() {
        return this.videoElement.paused;
    }
    /**
     * @returns - whether the video element is playing.
     */
    isVideoReady() {
        return this.videoElement.readyState !== undefined && this.videoElement.readyState > 0;
    }
    /**
     * @returns True if the video element has a valid video source (srcObject).
     */
    hasVideoSource() {
        return this.videoElement.srcObject !== undefined && this.videoElement.srcObject !== null;
    }
    /**
     * Get the current context of the html video element
     * @returns - the current context of the video element
     */
    getVideoElement() {
        return this.videoElement;
    }
    /**
     * Get the current context of the html video elements parent
     * @returns - the current context of the video elements parent
     */
    getVideoParentElement() {
        var _a;
        return (_a = this.videoElement.parentElement) !== null && _a !== void 0 ? _a : undefined;
    }
    /**
     * Set the Video Elements src object tracks to enable
     * @param enabled - Enable Tracks on the Src Object
     */
    setVideoEnabled(enabled) {
        // this is a temporary hack until type scripts video element is updated to reflect the need for tracks on a html video element
        const videoElement = this.videoElement;
        videoElement.srcObject
            .getTracks()
            .forEach((track) => (track.enabled = enabled));
    }
    /**
     * An override for when the video has been initialized with a srcObject
     */
    onVideoInitialized() {
        // Default Functionality: Do Nothing
    }
    /**
     * On the orientation change of a window clear the timeout
     */
    onOrientationChange() {
        clearTimeout(this.orientationChangeTimeout);
        this.orientationChangeTimeout = window.setTimeout(() => {
            this.resizePlayerStyle();
        }, 500);
    }
    /**
     * Resizes the player style based on the window height and width
     * @returns - nil if requirements are satisfied
     */
    resizePlayerStyle() {
        const videoElementParent = this.getVideoParentElement();
        if (!videoElementParent) {
            return;
        }
        this.updateVideoStreamSize();
        if (videoElementParent.classList.contains('fixed-size')) {
            this.onResizePlayerCallback();
            return;
        }
        // controls for resizing the player
        this.resizePlayerStyleToFillParentElement();
        this.onResizePlayerCallback();
    }
    /**
     * Resizes the player element to fill the parent element
     */
    resizePlayerStyleToFillParentElement() {
        const videoElementParent = this.getVideoParentElement();
        //Video is not initialized yet so set videoElementParent to size of parent element
        const styleWidth = '100%';
        const styleHeight = '100%';
        const styleTop = 0;
        const styleLeft = 0;
        videoElementParent.setAttribute('style', 'top: ' +
            styleTop +
            'px; left: ' +
            styleLeft +
            'px; width: ' +
            styleWidth +
            '; height: ' +
            styleHeight +
            '; cursor: default;');
    }
    updateVideoStreamSize() {
        if (!this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_0__.Flags.MatchViewportResolution)) {
            return;
        }
        const now = new Date().getTime();
        if (now - this.lastTimeResized > 300) {
            const videoElementParent = this.getVideoParentElement();
            if (!videoElementParent) {
                return;
            }
            this.onMatchViewportResolutionCallback(videoElementParent.clientWidth, videoElementParent.clientHeight);
            this.lastTimeResized = new Date().getTime();
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Resizing too often - skipping');
            clearTimeout(this.resizeTimeoutHandle);
            this.resizeTimeoutHandle = window.setTimeout(() => this.updateVideoStreamSize(), 100);
        }
    }
}
//# sourceMappingURL=VideoPlayer.js.map

/***/ }),

/***/ "../../library/dist/esm/WebRtcPlayer/WebRtcPlayerController.js":
/*!*********************************************************************!*\
  !*** ../../library/dist/esm/WebRtcPlayer/WebRtcPlayerController.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebRtcPlayerController: () => (/* binding */ WebRtcPlayerController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Transport/WebSocketTransport.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Protocol/SignallingProtocol.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Messages/signalling_messages.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Messages/message_helpers.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Protocol/KeepaliveMonitor.js");
/* harmony import */ var _VideoPlayer_StreamController__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../VideoPlayer/StreamController */ "../../library/dist/esm/VideoPlayer/StreamController.js");
/* harmony import */ var _FreezeFrame_FreezeFrameController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../FreezeFrame/FreezeFrameController */ "../../library/dist/esm/FreezeFrame/FreezeFrameController.js");
/* harmony import */ var _AFK_AFKController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../AFK/AFKController */ "../../library/dist/esm/AFK/AFKController.js");
/* harmony import */ var _DataChannel_DataChannelController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../DataChannel/DataChannelController */ "../../library/dist/esm/DataChannel/DataChannelController.js");
/* harmony import */ var _PeerConnectionController_PeerConnectionController__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../PeerConnectionController/PeerConnectionController */ "../../library/dist/esm/PeerConnectionController/PeerConnectionController.js");
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _DataChannel_InitialSettings__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../DataChannel/InitialSettings */ "../../library/dist/esm/DataChannel/InitialSettings.js");
/* harmony import */ var _DataChannel_LatencyTestResults__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../DataChannel/LatencyTestResults */ "../../library/dist/esm/DataChannel/LatencyTestResults.js");
/* harmony import */ var _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util/FileUtil */ "../../library/dist/esm/Util/FileUtil.js");
/* harmony import */ var _Inputs_InputClassesFactory__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../Inputs/InputClassesFactory */ "../../library/dist/esm/Inputs/InputClassesFactory.js");
/* harmony import */ var _VideoPlayer_VideoPlayer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../VideoPlayer/VideoPlayer */ "../../library/dist/esm/VideoPlayer/VideoPlayer.js");
/* harmony import */ var _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../UeInstanceMessage/StreamMessageController */ "../../library/dist/esm/UeInstanceMessage/StreamMessageController.js");
/* harmony import */ var _UeInstanceMessage_ResponseController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../UeInstanceMessage/ResponseController */ "../../library/dist/esm/UeInstanceMessage/ResponseController.js");
/* harmony import */ var _UeInstanceMessage_SendMessageController__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../UeInstanceMessage/SendMessageController */ "../../library/dist/esm/UeInstanceMessage/SendMessageController.js");
/* harmony import */ var _UeInstanceMessage_ToStreamerMessagesController__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../UeInstanceMessage/ToStreamerMessagesController */ "../../library/dist/esm/UeInstanceMessage/ToStreamerMessagesController.js");
/* harmony import */ var _DataChannel_DataChannelSender__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../DataChannel/DataChannelSender */ "../../library/dist/esm/DataChannel/DataChannelSender.js");
/* harmony import */ var _Util_InputCoordTranslator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Util/InputCoordTranslator */ "../../library/dist/esm/Util/InputCoordTranslator.js");
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../Util/EventEmitter */ "../../library/dist/esm/Util/EventEmitter.js");
/* harmony import */ var _Util_IURLSearchParams__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../Util/IURLSearchParams */ "../../library/dist/esm/Util/IURLSearchParams.js");
/* harmony import */ var _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../Util/BrowserUtils */ "../../library/dist/esm/Util/BrowserUtils.js");
// Copyright Epic Games, Inc. All Rights Reserved.





















/**
 * Entry point for the WebRTC Player
 */
class WebRtcPlayerController {
    /**
     *
     * @param config - the frontend config object
     * @param pixelStreaming - the PixelStreaming object
     */
    constructor(config, pixelStreaming) {
        this.shouldShowPlayOverlay = true;
        this.autoJoinTimer = undefined;
        this.config = config;
        this.pixelStreaming = pixelStreaming;
        this.responseController = new _UeInstanceMessage_ResponseController__WEBPACK_IMPORTED_MODULE_0__.ResponseController();
        this.file = new _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__.FileTemplate();
        this.sdpConstraints = {
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
        };
        // set up the afk logic class and connect up its method for closing the signaling server
        this.afkController = new _AFK_AFKController__WEBPACK_IMPORTED_MODULE_2__.AFKController(this.config, this.pixelStreaming, this.onAfkTriggered.bind(this));
        this.afkController.onAFKTimedOutCallback = () => {
            this.closeSignalingServer('You have been disconnected due to inactivity.', false);
        };
        this.freezeFrameController = new _FreezeFrame_FreezeFrameController__WEBPACK_IMPORTED_MODULE_3__.FreezeFrameController(this.pixelStreaming.videoElementParent);
        this.videoPlayer = new _VideoPlayer_VideoPlayer__WEBPACK_IMPORTED_MODULE_4__.VideoPlayer(this.pixelStreaming.videoElementParent, this.config);
        this.videoPlayer.onVideoInitialized = () => this.handleVideoInitialized();
        // When in match viewport resolution mode, when the browser viewport is resized we send a resize command back to UE.
        this.videoPlayer.onMatchViewportResolutionCallback = (width, height) => {
            const descriptor = {
                'Resolution.Width': width,
                'Resolution.Height': height
            };
            this.streamMessageController.toStreamerHandlers.get('Command')([JSON.stringify(descriptor)]);
        };
        // Every time video player is resized in browser we need to reinitialize the mouse coordinate conversion and freeze frame sizing logic.
        this.videoPlayer.onResizePlayerCallback = () => {
            this.setUpMouseAndFreezeFrame();
        };
        this.streamController = new _VideoPlayer_StreamController__WEBPACK_IMPORTED_MODULE_5__.StreamController(this.videoPlayer);
        this.coordinateConverter = new _Util_InputCoordTranslator__WEBPACK_IMPORTED_MODULE_6__.InputCoordTranslator();
        this.sendrecvDataChannelController = new _DataChannel_DataChannelController__WEBPACK_IMPORTED_MODULE_7__.DataChannelController();
        this.recvDataChannelController = new _DataChannel_DataChannelController__WEBPACK_IMPORTED_MODULE_7__.DataChannelController();
        this.registerDataChannelEventEmitters(this.sendrecvDataChannelController);
        this.registerDataChannelEventEmitters(this.recvDataChannelController);
        this.dataChannelSender = new _DataChannel_DataChannelSender__WEBPACK_IMPORTED_MODULE_8__.DataChannelSender(this.sendrecvDataChannelController);
        this.dataChannelSender.resetAfkWarningTimerOnDataSend = () => this.afkController.resetAfkWarningTimer();
        this.streamMessageController = new _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.StreamMessageController();
        // set up websocket methods
        this.transport = new _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_10__.WebSocketTransport(config.webSocketProtocols);
        this.protocol = new _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_11__.SignallingProtocol(this.transport);
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.config.typeName, (msg) => this.handleOnConfigMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.ping.typeName, (msg) => this.handlePingMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.streamerList.typeName, (msg) => this.handleStreamerListMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.subscribeFailed.typeName, (msg) => this.handleSubscribeFailedMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.streamerIdChanged.typeName, (msg) => this.handleStreamerIDChangedMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.playerCount.typeName, (msg) => {
            const playerCountMessage = msg;
            this.pixelStreaming._onPlayerCount(playerCountMessage.count);
        });
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.answer.typeName, (msg) => this.handleWebRtcAnswer(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.offer.typeName, (msg) => this.handleWebRtcOffer(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.peerDataChannels.typeName, (msg) => this.handleWebRtcSFUPeerDatachannels(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.iceCandidate.typeName, (msg) => {
            const iceCandidateMessage = msg;
            this.handleIceCandidate(iceCandidateMessage.candidate);
        });
        this.protocol.transport.addListener('open', () => {
            const BrowserSendOffer = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.BrowserSendOffer);
            if (!BrowserSendOffer) {
                const message = _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.listStreamers);
                this.protocol.sendMessage(message);
            }
            this.reconnectAttempt = 0;
            this.isReconnecting = false;
        });
        this.protocol.transport.addListener('error', () => {
            // dont really need to do anything here since the close event should follow.
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`Got a transport error.`);
        });
        this.protocol.transport.addListener('close', (event) => {
            // when we refresh the page during a stream we get the going away code.
            // in that case we don't want to reconnect since we're navigating away.
            // https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code
            // lists all the codes.
            const CODE_GOING_AWAY = 1001;
            const maxReconnectAttempts = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.MaxReconnectAttempts);
            const attemptsLeft = this.reconnectAttempt < maxReconnectAttempts;
            const reconnectEnabled = this.forceReconnect || (this.enableAutoReconnect && maxReconnectAttempts > 0 && attemptsLeft);
            const willTryReconnect = reconnectEnabled && event.code != CODE_GOING_AWAY;
            const allowClickToReconnect = !willTryReconnect;
            const disconnectMessage = this.disconnectMessage ? this.disconnectMessage : event.reason;
            this.forceReconnect = false;
            // Reset the list of all possible codecs on disconnect so that if the next connection has "NegotiateCodecs" on
            // then all codecs can be negotiated
            this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.PreferredCodec).options =
                _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_16__.BrowserUtils.getSupportedVideoCodecs();
            this.pixelStreaming._onDisconnect(disconnectMessage, allowClickToReconnect);
            this.afkController.stopAfkWarningTimer();
            // stop sending stats on interval if we have closed our connection
            if (this.statsTimerHandle && this.statsTimerHandle !== undefined) {
                window.clearInterval(this.statsTimerHandle);
            }
            // reset the stream quality icon.
            this.setVideoEncoderAvgQP(0);
            // unregister all input device event handlers on disconnect
            this.setTouchInputEnabled(false);
            this.setMouseInputEnabled(false);
            this.setKeyboardInputEnabled(false);
            this.setGamePadInputEnabled(false);
            if (willTryReconnect) {
                // need a small delay here to prevent reconnect spamming
                setTimeout(() => {
                    this.reconnectAttempt++;
                    this.doReconnect(event.reason);
                }, 2000);
            }
        });
        // set up the final webRtc player controller methods from within our application so a connection can be activated
        this.sendMessageController = new _UeInstanceMessage_SendMessageController__WEBPACK_IMPORTED_MODULE_17__.SendMessageController(this.dataChannelSender, this.streamMessageController);
        this.toStreamerMessagesController = new _UeInstanceMessage_ToStreamerMessagesController__WEBPACK_IMPORTED_MODULE_18__.ToStreamerMessagesController(this.sendMessageController);
        this.registerMessageHandlers();
        this.streamMessageController.populateDefaultProtocol();
        this.inputClassesFactory = new _Inputs_InputClassesFactory__WEBPACK_IMPORTED_MODULE_19__.InputClassesFactory(this.streamMessageController, this.videoPlayer, this.coordinateConverter);
        this.isUsingSFU = false;
        this.isUsingSVC = false;
        this.isQualityController = false;
        this.preferredCodec = '';
        this.enableAutoReconnect = true;
        this.forceReconnect = false;
        this.reconnectAttempt = 0;
        this.isReconnecting = false;
        this.config._addOnOptionSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId, (streamerid) => {
            if (streamerid === undefined || streamerid === '') {
                return;
            }
            // close the current peer connection and create a new one
            this.peerConnectionController.peerConnection.close();
            this.peerConnectionController.createPeerConnection(this.peerConfig, this.preferredCodec);
            this.subscribedStream = streamerid;
            const message = _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.subscribe, { streamerId: streamerid });
            this.protocol.sendMessage(message);
        });
        this.config._addOnOptionSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.PreferredQuality, (preferredQuality) => {
            if (preferredQuality === undefined || preferredQuality === '') {
                return;
            }
            let message;
            if (this.isUsingSVC) {
                // User is using SVC so selected quality will be of the form SxTy(h). Just extract the x and y numbers
                message = _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.layerPreference, {
                    spatialLayer: +preferredQuality[1] - 1,
                    temporalLayer: +preferredQuality[3] - 1
                });
            }
            else {
                // User is not using SVC so the selected quality will be either Low, Medium or High so we extract the appropriate spatial layer index
                const allQualities = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.PreferredQuality).options;
                const qualityIndex = allQualities.indexOf(preferredQuality);
                message = _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.layerPreference, {
                    spatialLayer: qualityIndex,
                    temporalLayer: 0
                });
            }
            this.protocol.sendMessage(message);
        });
        this.setVideoEncoderAvgQP(-1);
        this.signallingUrlBuilder = () => {
            const signallingServerUrl = this.config.getTextSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.TextParameters.SignallingServerUrl);
            return signallingServerUrl;
        };
    }
    /**
     * Destroys the video player and makes sure resources are freed. This helps to prevent the issue in chrome
     * where it refuses to make new video players.
     */
    destroyVideoPlayer() {
        this.videoPlayer.destroy();
    }
    /**
     * Handles when a message is received
     * @param event - Message Event
     */
    handleOnMessage(event) {
        const message = new Uint8Array(event.data);
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Message incoming:' + message);
        //try {
        const messageType = this.streamMessageController.fromStreamerMessages.get(message[0]);
        this.streamMessageController.fromStreamerHandlers.get(messageType)(event.data);
        //} catch (e) {
        //Logger.Error(Logger.GetStackTrace(), `Custom data channel message with message type that is unknown to the Pixel Streaming protocol. Does your PixelStreamingProtocol need updating? The message type was: ${message[0]}`);
        //}
    }
    /**
     * Register message all handlers
     */
    registerMessageHandlers() {
        // From Streamer
        // Message events from the streamer have a data type of ArrayBuffer as we force this type in the DatachannelController
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'QualityControlOwnership', (data) => this.onQualityControlOwnership(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'Response', (data) => this.responseController.onResponse(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'Command', (data) => {
            this.onCommand(data);
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'FreezeFrame', (data) => this.onFreezeFrameMessage(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'UnfreezeFrame', () => this.invalidateFreezeFrameAndEnableVideo());
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'VideoEncoderAvgQP', (data) => this.handleVideoEncoderAvgQP(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'LatencyTest', (data) => this.handleLatencyTestResult(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'DataChannelLatencyTest', (data) => this.handleDataChannelLatencyTestResponse(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'InitialSettings', (data) => this.handleInitialSettings(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'FileExtension', (data) => this.onFileExtension(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'FileMimeType', (data) => this.onFileMimeType(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'FileContents', (data) => this.onFileContents(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'TestEcho', () => {
            /* Do nothing */
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'InputControlOwnership', (data) => this.onInputControlOwnership(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'GamepadResponse', (data) => this.onGamepadResponse(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'Multiplexed', () => {
            /* Do nothing as this message type is used only by the SFU */
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'Protocol', (data) => this.onProtocolMessage(data));
        // To Streamer
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'IFrameRequest', () => this.sendMessageController.sendMessageToStreamer('IFrameRequest'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'RequestQualityControl', () => this.sendMessageController.sendMessageToStreamer('RequestQualityControl'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'FpsRequest', () => this.sendMessageController.sendMessageToStreamer('FpsRequest'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'AverageBitrateRequest', () => this.sendMessageController.sendMessageToStreamer('AverageBitrateRequest'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'StartStreaming', () => this.sendMessageController.sendMessageToStreamer('StartStreaming'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'StopStreaming', () => this.sendMessageController.sendMessageToStreamer('StopStreaming'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'LatencyTest', (data) => this.sendMessageController.sendMessageToStreamer('LatencyTest', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'RequestInitialSettings', () => this.sendMessageController.sendMessageToStreamer('RequestInitialSettings'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TestEcho', () => {
            /* Do nothing */
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'UIInteraction', (data) => this.sendMessageController.sendMessageToStreamer('UIInteraction', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'Command', (data) => this.sendMessageController.sendMessageToStreamer('Command', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TextboxEntry', (data) => this.sendMessageController.sendMessageToStreamer('TextboxEntry', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'KeyDown', (data) => this.sendMessageController.sendMessageToStreamer('KeyDown', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'KeyUp', (data) => this.sendMessageController.sendMessageToStreamer('KeyUp', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'KeyPress', (data) => this.sendMessageController.sendMessageToStreamer('KeyPress', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseEnter', (data) => this.sendMessageController.sendMessageToStreamer('MouseEnter', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseLeave', (data) => this.sendMessageController.sendMessageToStreamer('MouseLeave', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseDown', (data) => this.sendMessageController.sendMessageToStreamer('MouseDown', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseUp', (data) => this.sendMessageController.sendMessageToStreamer('MouseUp', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseMove', (data) => this.sendMessageController.sendMessageToStreamer('MouseMove', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseWheel', (data) => this.sendMessageController.sendMessageToStreamer('MouseWheel', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseDouble', (data) => this.sendMessageController.sendMessageToStreamer('MouseDouble', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TouchStart', (data) => this.sendMessageController.sendMessageToStreamer('TouchStart', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TouchEnd', (data) => this.sendMessageController.sendMessageToStreamer('TouchEnd', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TouchMove', (data) => this.sendMessageController.sendMessageToStreamer('TouchMove', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadConnected', () => this.sendMessageController.sendMessageToStreamer('GamepadConnected'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadButtonPressed', (data) => this.sendMessageController.sendMessageToStreamer('GamepadButtonPressed', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadButtonReleased', (data) => this.sendMessageController.sendMessageToStreamer('GamepadButtonReleased', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadAnalog', (data) => this.sendMessageController.sendMessageToStreamer('GamepadAnalog', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadDisconnected', (data) => this.sendMessageController.sendMessageToStreamer('GamepadDisconnected', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XREyeViews', (data) => this.sendMessageController.sendMessageToStreamer('XREyeViews', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRHMDTransform', (data) => this.sendMessageController.sendMessageToStreamer('XRHMDTransform', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRControllerTransform', (data) => this.sendMessageController.sendMessageToStreamer('XRControllerTransform', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRSystem', (data) => this.sendMessageController.sendMessageToStreamer('XRSystem', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRButtonTouched', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonTouched', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRButtonTouchReleased', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonTouchReleased', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRButtonPressed', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonPressed', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRButtonReleased', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonReleased', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRAnalog', (data) => this.sendMessageController.sendMessageToStreamer('XRAnalog', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'ChannelRelayStatus', () => {
            /* Do nothing as this message type is used only by the SFU */
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'Multiplexed', () => {
            /* Do nothing as this message type is used only by the SFU */
        });
    }
    /**
     * Activate the logic associated with a command from UE
     * @param message
     */
    onCommand(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.Command');
        const commandAsString = new TextDecoder('utf-16').decode(message.slice(1));
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Data Channel Command: ' + commandAsString);
        const command = JSON.parse(commandAsString);
        // Handle "onScreenKeyboard" event
        if (command.command === 'onScreenKeyboard') {
            this.handleOnScreenKeyboardCommand(command);
        }
    }
    handleOnScreenKeyboardCommand(command) {
        var _a, _b, _c, _d;
        const data = {
            showOnScreenKeyboard: (_a = command.showOnScreenKeyboard) !== null && _a !== void 0 ? _a : true,
            x: (_b = command.x) !== null && _b !== void 0 ? _b : 0,
            y: (_c = command.y) !== null && _c !== void 0 ? _c : 0,
            contents: (_d = command.contents) !== null && _d !== void 0 ? _d : ''
        };
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.ShowOnScreenKeyboardEvent(data));
    }
    /**
     * Handles a protocol message received from the streamer
     * @param message the message data from the streamer
     */
    onProtocolMessage(message) {
        try {
            const protocolString = new TextDecoder('utf-16').decode(message.slice(1));
            const protocolJSON = JSON.parse(protocolString);
            if (!Object.prototype.hasOwnProperty.call(protocolJSON, 'Direction')) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error('Malformed protocol received. Ensure the protocol message contains a direction');
            }
            const direction = protocolJSON.Direction;
            delete protocolJSON.Direction;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Received new ${direction == _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer ? 'FromStreamer' : 'ToStreamer'} protocol. Updating existing protocol...`);
            Object.keys(protocolJSON).forEach((messageType) => {
                const message = protocolJSON[messageType];
                switch (direction) {
                    case _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer:
                        // Check that the message contains all the relevant params
                        if (!Object.prototype.hasOwnProperty.call(message, 'id')) {
                            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`ToStreamer->${messageType} protocol definition was malformed as it didn't contain at least an id\n
                                           Definition was: ${JSON.stringify(message, null, 2)}`);
                            // return in a forEach is equivalent to a continue in a normal for loop
                            return;
                        }
                        // UE5.1 and UE5.2 don't send a structure for these message types, but they actually do have a structure so ignore updating them
                        if (messageType === 'UIInteraction' ||
                            messageType === 'Command' ||
                            messageType === 'LatencyTest') {
                            return;
                        }
                        if (this.streamMessageController.toStreamerHandlers.get(messageType)) {
                            // If we've registered a handler for this message type we can add it to our supported messages. ie registerMessageHandler(...)
                            this.streamMessageController.toStreamerMessages.set(messageType, message);
                        }
                        else {
                            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`There was no registered handler for "${messageType}" - try adding one using registerMessageHandler(MessageDirection.ToStreamer, "${messageType}", myHandler)`);
                        }
                        break;
                    case _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer:
                        // Check that the message contains all the relevant params
                        if (!Object.prototype.hasOwnProperty.call(message, 'id')) {
                            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`FromStreamer->${messageType} protocol definition was malformed as it didn't contain at least an id\n
                            Definition was: ${JSON.stringify(message, null, 2)}`);
                            // return in a forEach is equivalent to a continue in a normal for loop
                            return;
                        }
                        if (this.streamMessageController.fromStreamerHandlers.get(messageType)) {
                            // If we've registered a handler for this message type. ie registerMessageHandler(...)
                            this.streamMessageController.fromStreamerMessages.set(message.id, messageType);
                        }
                        else {
                            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`There was no registered handler for "${message}" - try adding one using registerMessageHandler(MessageDirection.FromStreamer, "${messageType}", myHandler)`);
                        }
                        break;
                    default:
                        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`Unknown direction: ${direction}`);
                }
            });
            // Once the protocol has been received, we can send our control messages
            this.toStreamerMessagesController.SendRequestInitialSettings();
            this.toStreamerMessagesController.SendRequestQualityControl();
        }
        catch (e) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(e);
        }
    }
    /**
     * Handles an input control message when it is received from the streamer
     * @param message The input control message
     */
    onInputControlOwnership(message) {
        const view = new Uint8Array(message);
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.InputControlOwnership');
        const inputControlOwnership = new Boolean(view[1]).valueOf();
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Received input controller message - will your input control the stream: ${inputControlOwnership}`);
        this.pixelStreaming._onInputControlOwnership(inputControlOwnership);
    }
    /**
     *
     * @param message
     */
    onGamepadResponse(message) {
        const responseString = new TextDecoder('utf-16').decode(message.slice(1));
        const responseJSON = JSON.parse(responseString);
        this.gamePadController.onGamepadResponseReceived(responseJSON.controllerId);
    }
    onAfkTriggered() {
        this.afkController.onAfkClick();
        // if the stream is paused play it, if we can
        if (this.videoPlayer.isPaused() && this.videoPlayer.hasVideoSource()) {
            this.playStream();
        }
    }
    /**
     * Set whether we should timeout when afk.
     * @param afkEnabled If true we timeout when idle for some given amount of time.
     */
    setAfkEnabled(afkEnabled) {
        if (afkEnabled) {
            this.onAfkTriggered();
        }
        else {
            this.afkController.stopAfkWarningTimer();
        }
    }
    /**
     * Attempt a reconnection to the signalling server. Manual trigger
     */
    tryReconnect(message) {
        this.forceReconnect = true;
        this.doReconnect(message);
    }
    /**
     * Does the actual reconnect work. Used by the auto reconnect feature to skip the manual flag.
     */
    doReconnect(message) {
        // if there is no webSocketController return immediately or this will not work
        if (!this.protocol) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('This player has no protocol connection.');
            return;
        }
        this.isReconnecting = true;
        // if the connection is open, first close it and force a reconnect.
        if (this.protocol.isConnected()) {
            if (!this.forceReconnect) {
                this.disconnectMessage = `${message} Reconnecting.`;
            }
            this.closeSignalingServer(message, true);
        }
        else {
            this.pixelStreaming._onWebRtcAutoConnect();
            this.connectToSignallingServer();
        }
    }
    /**
     * Loads a freeze frame if it is required otherwise shows the play overlay
     */
    loadFreezeFrameOrShowPlayOverlay() {
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.LoadFreezeFrameEvent({
            shouldShowPlayOverlay: this.shouldShowPlayOverlay,
            isValid: this.freezeFrameController.valid,
            jpegData: this.freezeFrameController.jpeg
        }));
        if (this.shouldShowPlayOverlay === true) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('showing play overlay');
            this.resizePlayerStyle();
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('showing freeze frame');
            this.freezeFrameController.showFreezeFrame();
        }
        setTimeout(() => {
            this.videoPlayer.setVideoEnabled(false);
        }, this.freezeFrameController.freezeFrameDelay);
    }
    /**
     * Process the freeze frame and load it
     * @param message The freeze frame data in bytes
     */
    onFreezeFrameMessage(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.FreezeFrame');
        const view = new Uint8Array(message);
        this.freezeFrameController.processFreezeFrameMessage(view, () => this.loadFreezeFrameOrShowPlayOverlay());
    }
    /**
     * Enable the video after hiding a freeze frame
     */
    invalidateFreezeFrameAndEnableVideo() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.FreezeFrame');
        setTimeout(() => {
            this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.HideFreezeFrameEvent());
            this.freezeFrameController.hideFreezeFrame();
        }, this.freezeFrameController.freezeFrameDelay);
        if (this.videoPlayer.getVideoElement()) {
            this.videoPlayer.setVideoEnabled(true);
        }
    }
    /**
     * Prep datachannel data for processing file extension
     * @param data the file extension data
     */
    onFileExtension(data) {
        const view = new Uint8Array(data);
        _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__.FileUtil.setExtensionFromBytes(view, this.file);
    }
    /**
     * Prep datachannel data for processing the file mime type
     * @param data the file mime type data
     */
    onFileMimeType(data) {
        const view = new Uint8Array(data);
        _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__.FileUtil.setMimeTypeFromBytes(view, this.file);
    }
    /**
     * Prep datachannel data for processing the file contents
     * @param data the file contents data
     */
    onFileContents(data) {
        const view = new Uint8Array(data);
        _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__.FileUtil.setContentsFromBytes(view, this.file);
    }
    /**
     * Plays the stream audio and video source and sets up other pieces while the stream starts
     */
    playStream() {
        if (!this.videoPlayer.getVideoElement()) {
            const message = 'Could not play video stream because the video player was not initialized correctly.';
            this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.PlayStreamErrorEvent({ message }));
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(message);
            // close the connection
            this.closeSignalingServer('Stream not initialized correctly', false);
            return;
        }
        if (!this.videoPlayer.hasVideoSource()) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Warning('Cannot play stream, the video element has no srcObject to play.');
            return;
        }
        this.setTouchInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.TouchInput));
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.PlayStreamEvent());
        if (this.streamController.audioElement.srcObject) {
            const startMuted = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.StartVideoMuted);
            this.streamController.audioElement.muted = startMuted;
            if (startMuted) {
                this.playVideo();
            }
            else {
                this.streamController.audioElement
                    .play()
                    .then(() => {
                    this.playVideo();
                })
                    .catch((onRejectedReason) => {
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(onRejectedReason);
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Browser does not support autoplaying video without interaction - to resolve this we are going to show the play button overlay.');
                    this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.PlayStreamRejectedEvent({
                        reason: onRejectedReason
                    }));
                });
            }
        }
        else {
            this.playVideo();
        }
        this.shouldShowPlayOverlay = false;
        this.freezeFrameController.showFreezeFrame();
    }
    /**
     * Plays the video stream
     */
    playVideo() {
        // handle play() with promise as it is an asynchronous call
        this.videoPlayer.play().catch((onRejectedReason) => {
            if (this.streamController.audioElement.srcObject) {
                this.streamController.audioElement.pause();
            }
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(onRejectedReason);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Browser does not support autoplaying video without interaction - to resolve this we are going to show the play button overlay.');
            this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.PlayStreamRejectedEvent({ reason: onRejectedReason }));
        });
    }
    /**
     * Enable the video to play automatically if enableAutoplay is true
     */
    autoPlayVideoOrSetUpPlayOverlay() {
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.AutoPlayVideo)) {
            // attempt to play the video
            this.playStream();
        }
        this.resizePlayerStyle();
    }
    /**
     * Connect to the Signaling server
     */
    connectToSignallingServer() {
        this.locallyClosed = false;
        this.enableAutoReconnect = true;
        this.disconnectMessage = null;
        const signallingUrl = this.signallingUrlBuilder();
        this.protocol.connect(signallingUrl);
        const keepaliveDelay = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.KeepaliveDelay);
        if (keepaliveDelay > 0) {
            this.keepalive = new _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_21__.KeepaliveMonitor(this.protocol, keepaliveDelay);
            this.keepalive.onTimeout = () => {
                // if the ping fails just disconnect
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`Protocol timeout`);
                this.protocol.disconnect();
            };
        }
    }
    /**
     * This will start the handshake to the signalling server
     * @param peerConfig  - RTC Configuration Options from the Signaling server
     * @remark RTC Peer Connection on Ice Candidate event have it handled by handle Send Ice Candidate
     */
    startSession(peerConfig) {
        this.peerConfig = peerConfig;
        // check for forcing turn
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.ForceTURN)) {
            // check for a turn server
            const hasTurnServer = this.checkTurnServerAvailability(peerConfig);
            // close and error if turn is forced and there is no turn server
            if (!hasTurnServer) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('No turn server was found in the Peer Connection Options. TURN cannot be forced, closing connection. Please use STUN instead');
                this.closeSignalingServer('TURN cannot be forced, closing connection. Please use STUN instead.', false);
                return;
            }
        }
        // set up the peer connection controller
        this.peerConnectionController = new _PeerConnectionController_PeerConnectionController__WEBPACK_IMPORTED_MODULE_22__.PeerConnectionController(this.peerConfig, this.config, this.preferredCodec);
        // set up peer connection controller video stats
        this.peerConnectionController.onVideoStats = (event) => {
            this.handleVideoStats(event);
        };
        /* Set event handler for latency information is calculated, handle the event by propogating to the PixelStreaming API */
        this.peerConnectionController.onLatencyCalculated = (latencyInfo) => {
            this.pixelStreaming._onLatencyCalculated(latencyInfo);
        };
        /* When our PeerConnection wants to send an offer call our handler */
        this.peerConnectionController.onSendWebRTCOffer = (offer) => {
            this.handleSendWebRTCOffer(offer);
        };
        /* Set event handler for when local description is set */
        this.peerConnectionController.onSetLocalDescription = (sdp) => {
            if (sdp.type === 'offer') {
                this.handleSendWebRTCOffer(sdp);
            }
            else if (sdp.type === 'answer') {
                this.handleSendWebRTCAnswer(sdp);
            }
            else {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`PeerConnectionController onSetLocalDescription was called with unexpected type ${sdp.type}`);
            }
        };
        /* Event handler for when PeerConnection's remote description is set */
        this.peerConnectionController.onSetRemoteDescription = (sdp) => {
            if (sdp.type === 'offer') {
                this.pixelStreaming._onWebRtcSdpOffer(sdp);
            }
            else if (sdp.type === 'answer') {
                this.pixelStreaming._onWebRtcSdpAnswer(sdp);
            }
            else {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`PeerConnectionController onSetRemoteDescription was called with unexpected type ${sdp.type}`);
            }
        };
        /* When the Peer Connection ice candidate is added have it handled */
        this.peerConnectionController.onPeerIceCandidate = (peerConnectionIceEvent) => this.handleSendIceCandidate(peerConnectionIceEvent);
        /* When the Peer Connection has a data channel created for it by the browser, handle it */
        this.peerConnectionController.onDataChannel = (datachannelEvent) => this.handleDataChannel(datachannelEvent);
        // set up webRtc text overlays
        this.peerConnectionController.showTextOverlayConnecting = () => this.pixelStreaming._onWebRtcConnecting();
        this.peerConnectionController.showTextOverlaySetupFailure = () => this.pixelStreaming._onWebRtcFailed();
        let webRtcConnectedSent = false;
        this.peerConnectionController.onIceConnectionStateChange = () => {
            // Browsers emit "connected" when getting first connection and "completed" when finishing
            // candidate checking. However, sometimes browsers can skip "connected" and only emit "completed".
            // Therefore need to check both cases and emit onWebRtcConnected only once on the first hit.
            if (!webRtcConnectedSent &&
                ['connected', 'completed'].includes(this.peerConnectionController.peerConnection.iceConnectionState)) {
                this.pixelStreaming._onWebRtcConnected();
                webRtcConnectedSent = true;
            }
        };
        /* RTC Peer Connection on Track event -> handle on track */
        this.peerConnectionController.onTrack = (trackEvent) => this.streamController.handleOnTrack(trackEvent);
        const BrowserSendOffer = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.BrowserSendOffer);
        if (BrowserSendOffer) {
            // If browser is sending the offer, create an offer and send it to the streamer
            this.sendrecvDataChannelController.createDataChannel(this.peerConnectionController.peerConnection, 'cirrus', this.datachannelOptions);
            this.sendrecvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
            this.peerConnectionController.createOffer(this.sdpConstraints, this.config);
        }
    }
    /**
     * Checks the peer connection options for a turn server and returns true or false
     */
    checkTurnServerAvailability(options) {
        // if iceServers is empty return false this should not be the general use case but is here incase
        if (!options.iceServers) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('A turn sever was not found');
            return false;
        }
        // loop through the ice servers to check for a turn url
        for (const iceServer of options.iceServers) {
            for (const url of iceServer.urls) {
                if (url.includes('turn')) {
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`A turn sever was found at ${url}`);
                    return true;
                }
            }
        }
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('A turn sever was not found');
        return false;
    }
    /**
     * Handles when a Config Message is received contains the Peer Connection Options required (STUN and TURN Server Info)
     * @param messageConfig - Config Message received from the signaling server
     */
    handleOnConfigMessage(messageConfig) {
        this.resizePlayerStyle();
        // Tell the WebRtcController to start a session with the peer options sent from the signaling server
        this.startSession(messageConfig.peerConnectionOptions);
    }
    handlePingMessage(pingMessage) {
        this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.pong, { time: pingMessage.time }));
    }
    /**
     * Handles when the signalling server gives us the list of streamer ids.
     */
    handleStreamerListMessage(messageStreamerList) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Got streamer list ${messageStreamerList.ids}`);
        let wantedStreamerId = '';
        // get the current selected streamer id option
        const streamerIDOption = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId);
        const existingSelection = streamerIDOption.selected.toString().trim();
        if (existingSelection) {
            // default to selected option if it exists
            wantedStreamerId = streamerIDOption.selected;
        }
        // add the streamers to the UI
        const settingOptions = [...messageStreamerList.ids]; // copy the original messageStreamerList.ids
        settingOptions.unshift(''); // add an empty option at the top
        this.config.setOptionSettingOptions(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId, settingOptions);
        let autoSelectedStreamerId = '';
        const waitForStreamer = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.WaitForStreamer);
        const reconnectLimit = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.MaxReconnectAttempts);
        const reconnectDelay = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.StreamerAutoJoinInterval);
        // first we figure out a wanted streamer id through various means
        const useUrlParams = this.config.useUrlParams;
        const urlParams = new _Util_IURLSearchParams__WEBPACK_IMPORTED_MODULE_23__.IURLSearchParams(window.location.search);
        if (useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId)) {
            // if we've set the streamer id on the url we only want that streamer id
            wantedStreamerId = urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId);
        }
        else if (this.subscribedStream) {
            // we were previously subscribed to a streamer, we want that
            wantedStreamerId = this.subscribedStream;
        }
        // now lets see if we can pick it.
        if (wantedStreamerId && messageStreamerList.ids.includes(wantedStreamerId)) {
            // if the wanted stream is in the list. we pick that
            autoSelectedStreamerId = wantedStreamerId;
        }
        else if ((!wantedStreamerId || !waitForStreamer) && messageStreamerList.ids.length == 1) {
            // otherwise, if we're not waiting for the wanted streamer and there's only one streamer, connect to it
            autoSelectedStreamerId = messageStreamerList.ids[0];
        }
        // if we found a streamer id to auto select, select it
        if (autoSelectedStreamerId) {
            this.reconnectAttempt = 0;
            this.isReconnecting = false;
            this.config.setOptionSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId, autoSelectedStreamerId);
        }
        else {
            // no auto selected streamer.
            // if we're waiting for a streamer then try reconnecting
            if (waitForStreamer) {
                if (this.reconnectAttempt < reconnectLimit) {
                    // still reconnects available
                    this.reconnectAttempt++;
                    this.isReconnecting = true;
                    setTimeout(() => {
                        this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.listStreamers));
                    }, reconnectDelay);
                }
                else {
                    // We've exhausted our reconnect attempts, return to main screen
                    this.reconnectAttempt = 0;
                    this.isReconnecting = false;
                    this.enableAutoReconnect = false;
                }
            }
        }
        // dispatch this event finally
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.StreamerListMessageEvent({
            messageStreamerList,
            autoSelectedStreamerId,
            wantedStreamerId
        }));
    }
    handleSubscribeFailedMessage(subscribeFailedMessage) {
        this.reconnectAttempt = 0;
        this.isReconnecting = false;
        this.enableAutoReconnect = false;
        this.pixelStreaming._onSubscribeFailed(subscribeFailedMessage.message);
    }
    handleStreamerIDChangedMessage(streamerIDChangedMessage) {
        const newID = streamerIDChangedMessage.newID;
        // need to edit the selected streamer in the settings list
        const streamerListOptions = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.StreamerId);
        // temporarily prevent onChange from firing (it would try to subscribe to the streamer again)
        const oldOnChange = streamerListOptions.onChange;
        streamerListOptions.onChange = () => { };
        // change the selected entry.
        const streamerList = streamerListOptions.options;
        for (let i = 0; i < streamerList.length; ++i) {
            if (streamerList[i] == this.subscribedStream) {
                streamerList[i] = newID;
                break;
            }
        }
        // update the list
        streamerListOptions.options = streamerList;
        // update the selected entry
        streamerListOptions.selected = newID;
        // restore the old change notifier.
        streamerListOptions.onChange = oldOnChange;
        // remember which stream we're subscribe to
        this.subscribedStream = streamerIDChangedMessage.newID;
        // notify any listeners
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.StreamerIDChangedMessageEvent({
            newID
        }));
    }
    /**
     * Handle the RTC Answer from the signaling server
     * @param Answer - Answer SDP from the peer.
     */
    handleWebRtcAnswer(Answer) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Got answer sdp ${Answer.sdp}`);
        const sdpAnswer = {
            sdp: Answer.sdp,
            type: 'answer'
        };
        this.peerConnectionController.receiveAnswer(sdpAnswer);
        this.handlePostWebrtcNegotiation();
    }
    /**
     * Handle the RTC offer from a WebRTC peer (received through the signalling server).
     * @param Offer - Offer SDP from the peer.
     */
    handleWebRtcOffer(Offer) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Got offer sdp ${Offer.sdp}`);
        this.isUsingSFU = Offer.sfu ? Offer.sfu : false;
        this.isUsingSVC = Offer.scalabilityMode ? Offer.scalabilityMode != 'L1T1' : false;
        if (this.isUsingSFU || this.isUsingSVC) {
            // Disable negotiating with the sfu as the sfu only supports one codec at a time
            this.peerConnectionController.preferredCodec = '';
        }
        // NOTE: These two settings configurations are done outside of an if(this.isUsingSFU) so that users
        // can switch between a default and SFU stream and have the settings reconfigure appropriately
        const scalabilityMode = Offer.scalabilityMode ? Offer.scalabilityMode : 'L1T1';
        let availableQualities = ['Default'];
        if (this.isUsingSFU) {
            if (!this.isUsingSVC) {
                // User is using an SFU without any temporal scalability. Just offer easily readable names
                availableQualities = ['Low', 'Medium', 'High'];
            }
            else {
                // User is using SVC. Generate all available options.
                availableQualities = [];
                const maxSpatialLayers = +scalabilityMode[1];
                const maxTemporalLayers = +scalabilityMode[3];
                for (let s = 1; s <= maxSpatialLayers; s++) {
                    for (let t = 1; t <= maxTemporalLayers; t++) {
                        availableQualities.push(`S${s}T${t}`);
                    }
                }
            }
        }
        // Update the possible video quality options
        this.config.setOptionSettingOptions(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.PreferredQuality, availableQualities);
        // Update the selected video quality with the highest possible resolution
        this.config.setOptionSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.OptionParameters.PreferredQuality, availableQualities.slice(-1)[0]);
        const sdpOffer = {
            sdp: Offer.sdp,
            type: 'offer'
        };
        this.peerConnectionController.receiveOffer(sdpOffer, this.config);
        this.handlePostWebrtcNegotiation();
    }
    /**
     * Handle when the SFU provides the peer with its data channels
     * @param DataChannels - The message from the SFU containing the data channels ids
     */
    handleWebRtcSFUPeerDatachannels(DataChannels) {
        const SendOptions = {
            ordered: true,
            negotiated: true,
            id: DataChannels.sendStreamId
        };
        const unidirectional = DataChannels.sendStreamId != DataChannels.recvStreamId;
        this.sendrecvDataChannelController.createDataChannel(this.peerConnectionController.peerConnection, unidirectional ? 'send-datachannel' : 'datachannel', SendOptions);
        if (unidirectional) {
            const RecvOptions = {
                ordered: true,
                negotiated: true,
                id: DataChannels.recvStreamId
            };
            this.recvDataChannelController.createDataChannel(this.peerConnectionController.peerConnection, 'recv-datachannel', RecvOptions);
            this.recvDataChannelController.handleOnOpen = () => this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.peerDataChannelsReady));
            // If we're uni-directional, only the recv data channel should handle incoming messages
            this.recvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
        }
        else {
            // else our primary datachannel is send/recv so it can handle incoming messages
            this.sendrecvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
        }
    }
    handlePostWebrtcNegotiation() {
        // start the afk warning timer as PS is now running
        this.afkController.startAfkWarningTimer();
        // show the overlay that we have negotiated a connection
        this.pixelStreaming._onWebRtcSdp();
        if (this.statsTimerHandle && this.statsTimerHandle !== undefined) {
            window.clearInterval(this.statsTimerHandle);
        }
        this.statsTimerHandle = window.setInterval(() => this.getStats(), 1000);
        /*  */
        this.setMouseInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.MouseInput));
        this.setKeyboardInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.KeyboardInput));
        this.setGamePadInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.GamepadInput));
    }
    /**
     * Handler for when a remote ICE candidate is received.
     * @param iceCandidateInit - Initialization data used to make the actual ICE Candidate.
     */
    handleIceCandidate(iceCandidateInit) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Remote ICE candidate information received: ${JSON.stringify(iceCandidateInit)}`);
        // We are using "bundle" policy for media lines so we remove the sdpMid and sdpMLineIndex attributes
        // from ICE candidates as these are legacy attributes for when bundle is not used.
        // If we don't do this the browser may be unable to form a media connection
        // because some browsers are brittle if the bundle master (e.g. commonly mid=0) doesn't get a candidate first.
        const remoteIceCandidate = new RTCIceCandidate({
            candidate: iceCandidateInit.candidate,
            sdpMid: ''
        });
        this.peerConnectionController.handleOnIce(remoteIceCandidate);
    }
    /**
     * Send the ice Candidate to the signaling server via websocket
     * @param iceEvent - RTC Peer ConnectionIceEvent) {
     */
    handleSendIceCandidate(iceEvent) {
        if (iceEvent.candidate && iceEvent.candidate.candidate) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Local ICE candidate generated: ` + JSON.stringify(iceEvent.candidate));
            this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.iceCandidate, { candidate: iceEvent.candidate }));
        }
    }
    /**
     * Send the ice Candidate to the signaling server via websocket
     * @param iceEvent - RTC Peer ConnectionIceEvent) {
     */
    handleDataChannel(datachannelEvent) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Data channel created for us by browser as we are a receiving peer.');
        this.sendrecvDataChannelController.dataChannel = datachannelEvent.channel;
        // Data channel was created for us, so we just need to setup its callbacks and array type
        this.sendrecvDataChannelController.setupDataChannel();
        this.sendrecvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
    }
    /**
     * Send the RTC Offer Session to the Signaling server via websocket
     * @param offer - RTC Session Description
     */
    handleSendWebRTCOffer(offer) {
        if (offer.type !== 'offer') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`handleSendWebRTCOffer was called with type ${offer.type} - it only expects "offer"`);
            return;
        }
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Sending the offer to the Server');
        const extraParams = {
            sdp: offer.sdp,
            minBitrateBps: 1000 * this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.WebRTCMinBitrate),
            maxBitrateBps: 1000 * this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.WebRTCMaxBitrate)
        };
        this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.offer, extraParams));
        // Send offer back to Pixel Streaming main class for event dispatch
        this.pixelStreaming._onWebRtcSdpOffer(offer);
    }
    /**
     * Send the RTC Offer Session to the Signaling server via websocket
     * @param answer - RTC Session Description
     */
    handleSendWebRTCAnswer(answer) {
        if (answer.type !== 'answer') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Error(`handleSendWebRTCAnswer was called with type ${answer.type} - it only expects "answer"`);
            return;
        }
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('Sending the answer to the Server');
        const extraParams = {
            sdp: answer.sdp,
            minBitrateBps: 1000 * this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.WebRTCMinBitrate),
            maxBitrateBps: 1000 * this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.NumericParameters.WebRTCMaxBitrate)
        };
        this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.answer, extraParams));
        if (this.isUsingSFU) {
            this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_14__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_12__.dataChannelRequest));
        }
        // Send answer back to Pixel Streaming main class for event dispatch
        this.pixelStreaming._onWebRtcSdpAnswer(answer);
    }
    /**
     * Set the freeze frame overlay to the player div
     */
    setUpMouseAndFreezeFrame() {
        // Calculating and normalizing positions depends on the width and height of the player.
        const playerElement = this.videoPlayer.getVideoParentElement();
        const videoElement = this.videoPlayer.getVideoElement();
        this.coordinateConverter.reconfigure({ width: playerElement.clientWidth, height: playerElement.clientHeight }, { width: videoElement.videoWidth, height: videoElement.videoHeight });
        this.freezeFrameController.freezeFrame.resize();
    }
    /**
     * Close the Connection to the signaling server
     */
    closeSignalingServer(message, allowReconnect) {
        var _a;
        this.locallyClosed = true;
        this.enableAutoReconnect = allowReconnect;
        this.disconnectMessage = message;
        (_a = this.protocol) === null || _a === void 0 ? void 0 : _a.disconnect(1000, message);
    }
    /**
     * Close the peer connection
     */
    closePeerConnection() {
        var _a;
        (_a = this.peerConnectionController) === null || _a === void 0 ? void 0 : _a.close();
    }
    /**
     * Close all connections
     */
    close() {
        this.closeSignalingServer('', false);
        this.closePeerConnection();
    }
    /**
     * Fires a Video Stats Event in the RTC Peer Connection
     */
    getStats() {
        this.peerConnectionController.generateStats();
    }
    /**
     * Send a Latency Test Request to the UE Instance
     */
    sendLatencyTest() {
        this.latencyStartTime = Date.now();
        this.streamMessageController.toStreamerHandlers.get('LatencyTest')([
            JSON.stringify({
                StartTime: this.latencyStartTime
            })
        ]);
    }
    /**
     * Send a Data Channel Latency Test Request to the UE Instance
     */
    sendDataChannelLatencyTest(descriptor) {
        this.streamMessageController.toStreamerHandlers.get('DataChannelLatencyTest')([
            JSON.stringify(descriptor)
        ]);
    }
    /**
     * Send the MinQP encoder setting to the UE Instance.
     * @param minQP - The lower bound for QP when encoding
     * valid values are (1-51) where:
     * 1 = Best quality but highest bitrate.
     * 51 = Worst quality but lowest bitrate.
     * By default the minQP is 1 meaning the encoder is free
     * to aim for the best quality it can on the given network link.
     */
    sendEncoderMinQP(minQP) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`MinQP=${minQP}\n`);
        if (minQP != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MinQP': minQP
                })
            ]);
        }
    }
    /**
     * Send the MaxQP encoder setting to the UE Instance.
     * @param maxQP - The upper bound for QP when encoding
     * valid values are (1-51) where:
     * 1 = Best quality but highest bitrate.
     * 51 = Worst quality but lowest bitrate.
     * By default the maxQP is 51 meaning the encoder is free
     * to drop quality as low as needed on the given network link.
     */
    sendEncoderMaxQP(maxQP) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`MaxQP=${maxQP}\n`);
        if (maxQP != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MaxQP': maxQP
                })
            ]);
        }
    }
    /**
     * Send the MinQuality encoder setting to the UE Instance.
     * @param minQuality - The lower bound for quality when encoding
     * valid values are (0-100) where:
     * 0 = Worst quality.
     * 100 = Best quality.
     */
    sendEncoderMinQuality(minQuality) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`MinQuality=${minQuality}\n`);
        if (minQuality != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MinQuality': minQuality
                })
            ]);
        }
    }
    /**
     * Send the MaxQuality encoder setting to the UE Instance.
     * @param maxQuality - The upper bound for quality when encoding
     * valid values are (0-100) where:
     * 0 = Worst quality.
     * 100 = Best quality.
     */
    sendEncoderMaxQuality(maxQuality) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`MaxQuality=${maxQuality}\n`);
        if (maxQuality != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MaxQuality': maxQuality
                })
            ]);
        }
    }
    /**
     * Send the { WebRTC.MinBitrate: SomeNumber }} command to UE to set
     * the minimum bitrate that we allow WebRTC to use
     * (note setting this too high in poor networks can be problematic).
     * @param minBitrate - The minimum bitrate we would like WebRTC to not fall below.
     */
    sendWebRTCMinBitrate(minBitrate) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`WebRTC Min Bitrate=${minBitrate}`);
        if (minBitrate != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'WebRTC.MinBitrate': minBitrate
                })
            ]);
        }
    }
    /**
     * Send the { WebRTC.MaxBitrate: SomeNumber }} command to UE to set
     * the minimum bitrate that we allow WebRTC to use
     * (note setting this too low could result in blocky video).
     * @param minBitrate - The minimum bitrate we would like WebRTC to not fall below.
     */
    sendWebRTCMaxBitrate(maxBitrate) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`WebRTC Max Bitrate=${maxBitrate}`);
        if (maxBitrate != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'WebRTC.MaxBitrate': maxBitrate
                })
            ]);
        }
    }
    /**
     * Send the { WebRTC.Fps: SomeNumber }} UE 5.0+
     * and { WebRTC.MaxFps } UE 4.27 command to set
     * the maximum fps we would like WebRTC to stream at.
     * @param fps - The maximum stream fps.
     */
    sendWebRTCFps(fps) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`WebRTC FPS=${fps}`);
        if (fps != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({ 'WebRTC.Fps': fps })
            ]);
            /* TODO: Remove when UE 4.27 unsupported. */
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({ 'WebRTC.MaxFps': fps })
            ]);
        }
    }
    /**
     * Sends the UI Descriptor `stat fps` to the UE Instance
     */
    sendShowFps() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending show stat to UE   ----');
        this.streamMessageController.toStreamerHandlers.get('Command')([JSON.stringify({ 'stat.fps': '' })]);
    }
    /**
     * Send an Iframe request to the streamer
     */
    sendIframeRequest() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending Request for an IFrame  ----');
        this.streamMessageController.toStreamerHandlers.get('IFrameRequest')();
    }
    /**
     * Send a UIInteraction message
     */
    emitUIInteraction(descriptor) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending custom UIInteraction message   ----');
        this.streamMessageController.toStreamerHandlers.get('UIInteraction')([JSON.stringify(descriptor)]);
    }
    /**
     * Send a Command message
     */
    emitCommand(descriptor) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending custom Command message   ----');
        this.streamMessageController.toStreamerHandlers.get('Command')([JSON.stringify(descriptor)]);
    }
    /**
     * Send a console command message
     */
    emitConsoleCommand(command) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending custom Command:ConsoleCommand message   ----');
        this.streamMessageController.toStreamerHandlers.get('Command')([
            JSON.stringify({
                ConsoleCommand: command
            })
        ]);
    }
    /**
     * Sends a request to the UE Instance to have ownership of Quality
     */
    sendRequestQualityControlOwnership() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending Request to Control Quality  ----');
        this.toStreamerMessagesController.SendRequestQualityControl();
    }
    /**
     * Send a `TextBoxEntry` message back to UE.
     * @param contents The new contents of the UE side text box.
     */
    sendTextboxEntry(contents) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('----   Sending TextboxEntry message  ----');
        (_a = this.streamMessageController.toStreamerHandlers.get('TextboxEntry')) === null || _a === void 0 ? void 0 : _a([contents]);
    }
    /**
     * Handles when a Latency Test Result are received from the UE Instance
     * @param message - Latency Test Timings
     */
    handleLatencyTestResult(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.latencyTest');
        const latencyAsString = new TextDecoder('utf-16').decode(message.slice(1));
        const latencyTestResults = new _DataChannel_LatencyTestResults__WEBPACK_IMPORTED_MODULE_24__.LatencyTestResults();
        Object.assign(latencyTestResults, JSON.parse(latencyAsString));
        latencyTestResults.processFields();
        latencyTestResults.testStartTimeMs = this.latencyStartTime;
        latencyTestResults.browserReceiptTimeMs = Date.now();
        latencyTestResults.latencyExcludingDecode = ~~(latencyTestResults.browserReceiptTimeMs - latencyTestResults.testStartTimeMs);
        latencyTestResults.testDuration = ~~(latencyTestResults.TransmissionTimeMs - latencyTestResults.ReceiptTimeMs);
        latencyTestResults.networkLatency = ~~(latencyTestResults.latencyExcludingDecode - latencyTestResults.testDuration);
        if (latencyTestResults.frameDisplayDeltaTimeMs && latencyTestResults.browserReceiptTimeMs) {
            latencyTestResults.endToEndLatency = ~~(latencyTestResults.frameDisplayDeltaTimeMs +
                latencyTestResults.networkLatency,
                +latencyTestResults.CaptureToSendMs);
        }
        this.pixelStreaming._onLatencyTestResult(latencyTestResults);
    }
    /**
     * Handles when a Data Channel Latency Test Response is received from the UE Instance
     * @param message - Data Channel Latency Test Response
     */
    handleDataChannelLatencyTestResponse(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.dataChannelLatencyResponse');
        const responseAsString = new TextDecoder('utf-16').decode(message.slice(1));
        const latencyTestResponse = JSON.parse(responseAsString);
        this.pixelStreaming._onDataChannelLatencyTestResponse(latencyTestResponse);
    }
    /**
     * Handles when the Encoder and Web RTC Settings are received from the UE Instance
     * @param message - Initial Encoder and Web RTC Settings
     */
    handleInitialSettings(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.InitialSettings');
        const payloadAsString = new TextDecoder('utf-16').decode(message.slice(1));
        const parsedInitialSettings = JSON.parse(payloadAsString);
        const initialSettings = new _DataChannel_InitialSettings__WEBPACK_IMPORTED_MODULE_25__.InitialSettings();
        if (parsedInitialSettings.Encoder) {
            initialSettings.EncoderSettings = parsedInitialSettings.Encoder;
        }
        if (parsedInitialSettings.WebRTC) {
            initialSettings.WebRTCSettings = parsedInitialSettings.WebRTC;
        }
        if (parsedInitialSettings.PixelStreaming) {
            initialSettings.PixelStreamingSettings = parsedInitialSettings.PixelStreaming;
        }
        if (parsedInitialSettings.ConfigOptions &&
            parsedInitialSettings.ConfigOptions.DefaultToHover !== undefined) {
            this.config.setFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.HoveringMouseMode, !!parsedInitialSettings.ConfigOptions.DefaultToHover);
        }
        initialSettings.ueCompatible();
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(payloadAsString);
        this.pixelStreaming._onInitialSettings(initialSettings);
    }
    /**
     * Handles when the Quantization Parameter are received from the UE Instance
     * @param message - Encoders Quantization Parameter
     */
    handleVideoEncoderAvgQP(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.VideoEncoderAvgQP');
        const AvgQP = Number(new TextDecoder('utf-16').decode(message.slice(1)));
        this.setVideoEncoderAvgQP(AvgQP);
    }
    /**
     * Handles when the video element has been loaded with a srcObject
     */
    handleVideoInitialized() {
        this.pixelStreaming._onVideoInitialized();
        // either autoplay the video or set up the play overlay
        this.autoPlayVideoOrSetUpPlayOverlay();
        this.resizePlayerStyle();
        this.videoPlayer.updateVideoStreamSize();
    }
    /**
     * Flag set if the user has Quality Ownership
     * @param message - Does the current client have Quality Ownership
     */
    onQualityControlOwnership(message) {
        const view = new Uint8Array(message);
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('DataChannelReceiveMessageType.QualityControlOwnership');
        this.isQualityController = new Boolean(view[1]).valueOf();
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info(`Received quality controller message, will control quality: ${this.isQualityController}`);
        this.pixelStreaming._onQualityControlOwnership(this.isQualityController);
    }
    /**
     * Handles when the Aggregated stats are Collected
     * @param stats - Aggregated Stats
     */
    handleVideoStats(stats) {
        this.pixelStreaming._onVideoStats(stats);
    }
    /**
     * To Resize the Video Player element
     */
    resizePlayerStyle() {
        this.videoPlayer.resizePlayerStyle();
    }
    setPreferredCodec(codec) {
        this.preferredCodec = codec;
        if (this.peerConnectionController) {
            this.peerConnectionController.preferredCodec = codec;
            this.peerConnectionController.updateCodecSelection = false;
        }
    }
    setVideoEncoderAvgQP(avgQP) {
        this.videoAvgQp = avgQP;
        this.pixelStreaming._onVideoEncoderAvgQP(this.videoAvgQp);
    }
    /**
     * enables/disables keyboard event listeners
     */
    setKeyboardInputEnabled(isEnabled) {
        var _a;
        (_a = this.keyboardController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            this.keyboardController = this.inputClassesFactory.registerKeyBoard(this.config);
        }
    }
    /**
     * enables/disables mouse event listeners
     */
    setMouseInputEnabled(isEnabled) {
        var _a;
        (_a = this.mouseController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            const mouseMode = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.HoveringMouseMode)
                ? _Config_Config__WEBPACK_IMPORTED_MODULE_13__.ControlSchemeType.HoveringMouse
                : _Config_Config__WEBPACK_IMPORTED_MODULE_13__.ControlSchemeType.LockedMouse;
            this.mouseController = this.inputClassesFactory.registerMouse(mouseMode);
        }
    }
    /**
     * enables/disables touch event listeners
     */
    setTouchInputEnabled(isEnabled) {
        var _a;
        (_a = this.touchController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            this.touchController = this.inputClassesFactory.registerTouch(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_13__.Flags.FakeMouseWithTouches));
        }
    }
    /**
     * enables/disables game pad event listeners
     */
    setGamePadInputEnabled(isEnabled) {
        var _a;
        (_a = this.gamePadController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            this.gamePadController = this.inputClassesFactory.registerGamePad();
        }
    }
    registerDataChannelEventEmitters(dataChannel) {
        dataChannel.onOpen = (label, event) => this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.DataChannelOpenEvent({ label, event }));
        dataChannel.onClose = (label, event) => this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.DataChannelCloseEvent({ label, event }));
        dataChannel.onError = (label, event) => this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.DataChannelErrorEvent({ label, event }));
    }
    registerMessageHandler(name, direction, handler) {
        if (direction === _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer && typeof handler === 'undefined') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Warning(`Unable to register handler for ${name} as no handler was passed`);
        }
        this.streamMessageController.registerMessageHandler(direction, name, (data) => typeof handler === 'undefined' && direction === _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer
            ? this.sendMessageController.sendMessageToStreamer(name, data)
            : handler(data));
    }
}
//# sourceMappingURL=WebRtcPlayerController.js.map

/***/ }),

/***/ "../../library/dist/esm/WebXR/WebXRController.js":
/*!*******************************************************!*\
  !*** ../../library/dist/esm/WebXR/WebXRController.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebXRController: () => (/* binding */ WebXRController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingcommon-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Inputs_XRGamepadController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Inputs/XRGamepadController */ "../../library/dist/esm/Inputs/XRGamepadController.js");
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Util/EventEmitter */ "../../library/dist/esm/Util/EventEmitter.js");
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Config/Config */ "../../library/dist/esm/Config/Config.js");
// Copyright Epic Games, Inc. All Rights Reserved.




class WebXRController {
    constructor(webRtcPlayerController) {
        this.xrViewerPose = null;
        // Used for comparisons to ensure two numbers are close enough.
        this.EPSILON = 0.0000001;
        this.videoTexture = null;
        this.prevVideoWidth = 0;
        this.prevVideoHeight = 0;
        this.leftView = null;
        this.rightView = null;
        // Store the HMD data we have last sent (not all of it is needed every frame unless it changes)
        this.lastSentLeftEyeProj = null;
        this.lastSentRightEyeProj = null;
        this.lastSentRelativeLeftEyePos = null;
        this.lastSentRelativeRightEyePos = null;
        this.xrSession = null;
        this.webRtcController = webRtcPlayerController;
        this.xrGamepadController = new _Inputs_XRGamepadController__WEBPACK_IMPORTED_MODULE_0__.XRGamepadController(this.webRtcController.streamMessageController);
        this.onSessionEnded = new EventTarget();
        this.onSessionStarted = new EventTarget();
        this.onFrame = new EventTarget();
    }
    xrClicked() {
        if (!this.xrSession) {
            if (!navigator.xr) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Error('This browser does not support XR.');
                return;
            }
            navigator.xr
                /* Request immersive-vr session without any optional features. */
                .requestSession('immersive-vr', { optionalFeatures: [] })
                .then((session) => {
                this.onXrSessionStarted(session);
            });
        }
        else {
            this.xrSession.end();
        }
    }
    onXrSessionEnded() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('XR Session ended');
        this.xrSession = null;
        this.onSessionEnded.dispatchEvent(new Event('xrSessionEnded'));
    }
    initGL() {
        if (this.gl) {
            return;
        }
        const canvas = document.createElement('canvas');
        this.gl = canvas.getContext('webgl2', {
            xrCompatible: true
        });
        // Set our clear color
        this.gl.clearColor(0.0, 0.0, 0.0, 1);
    }
    initShaders() {
        // shader source code
        const vertexShaderSource = `
        attribute vec2 a_position;
        attribute vec2 a_texCoord;

        // varyings
        varying vec2 v_texCoord;

        void main() {
           gl_Position = vec4(a_position.x, a_position.y, 0, 1);
           // pass the texCoord to the fragment shader
           // The GPU will interpolate this value between points.
           v_texCoord = a_texCoord;
        }
        `;
        const fragmentShaderSource = `
        precision mediump float;

        // our texture
        uniform sampler2D u_image;

        // the texCoords passed in from the vertex shader.
        varying vec2 v_texCoord;

        void main() {
           gl_FragColor = texture2D(u_image, v_texCoord);
        }
        `;
        // setup vertex shader
        const vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
        this.gl.shaderSource(vertexShader, vertexShaderSource);
        this.gl.compileShader(vertexShader);
        // setup fragment shader
        const fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        this.gl.shaderSource(fragmentShader, fragmentShaderSource);
        this.gl.compileShader(fragmentShader);
        // setup GLSL program
        const shaderProgram = this.gl.createProgram();
        this.gl.attachShader(shaderProgram, vertexShader);
        this.gl.attachShader(shaderProgram, fragmentShader);
        this.gl.linkProgram(shaderProgram);
        this.gl.useProgram(shaderProgram);
        // look up where vertex data needs to go
        this.positionLocation = this.gl.getAttribLocation(shaderProgram, 'a_position');
        this.texcoordLocation = this.gl.getAttribLocation(shaderProgram, 'a_texCoord');
    }
    updateVideoTexture() {
        if (!this.videoTexture) {
            // Create our texture that we use in our shader
            // and bind it once because we never use any other texture.
            this.videoTexture = this.gl.createTexture();
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.videoTexture);
            // Set the parameters so we can render any size image.
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        }
        const videoHeight = this.webRtcController.videoPlayer.getVideoElement().videoHeight;
        const videoWidth = this.webRtcController.videoPlayer.getVideoElement().videoWidth;
        if (this.prevVideoHeight != videoHeight || this.prevVideoWidth != videoWidth) {
            // Do full update of texture if dimensions do not match
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, videoWidth, videoHeight, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.webRtcController.videoPlayer.getVideoElement());
        }
        else {
            // If dimensions match just update the sub region
            this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, 0, 0, videoWidth, videoHeight, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.webRtcController.videoPlayer.getVideoElement());
        }
        // Update prev video width/height
        this.prevVideoHeight = videoHeight;
        this.prevVideoWidth = videoWidth;
    }
    initBuffers() {
        // Create out position buffer and its vertex shader attribute
        {
            // Create a buffer to put the the vertices of the plane we will draw the video stream onto
            this.positionBuffer = this.gl.createBuffer();
            // Bind the position buffer
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
            // Enable `positionLocation` to be used as vertex shader attribute
            this.gl.enableVertexAttribArray(this.positionLocation);
            // Note: positions are passed in clip-space coordinates [-1..1] so no need to convert in-shader
            // prettier-ignore
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([
                -1.0, 1.0,
                1.0, 1.0,
                -1.0, -1.0,
                -1.0, -1.0,
                1.0, 1.0,
                1.0, -1.0
            ]), this.gl.STATIC_DRAW);
            // Tell position attribute of the vertex shader how to get data out of the bound buffer (the positionBuffer)
            this.gl.vertexAttribPointer(this.positionLocation, 2 /*size*/, this.gl.FLOAT /*type*/, false /*normalize*/, 0 /*stride*/, 0 /*offset*/);
        }
        // Create our texture coordinate buffers for accessing our texture
        {
            this.texcoordBuffer = this.gl.createBuffer();
            // Bind the texture coordinate buffer
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texcoordBuffer);
            // Enable `texcoordLocation` to be used as a vertex shader attribute
            this.gl.enableVertexAttribArray(this.texcoordLocation);
            // The texture coordinates to apply for rectangle we are drawing
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), this.gl.STATIC_DRAW);
            // Tell texture coordinate attribute of the vertex shader how to get data out of the bound buffer (the texcoordBuffer)
            this.gl.vertexAttribPointer(this.texcoordLocation, 2 /*size*/, this.gl.FLOAT /*type*/, false /*normalize*/, 0 /*stride*/, 0 /*offset*/);
        }
    }
    onXrSessionStarted(session) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('XR Session started');
        this.xrSession = session;
        this.xrSession.addEventListener('end', () => {
            this.onXrSessionEnded();
        });
        // Initialization
        this.initGL();
        this.initShaders();
        this.initBuffers();
        session.requestReferenceSpace('local').then((refSpace) => {
            this.xrRefSpace = refSpace;
            // Set up our base layer (i.e. a projection layer that fills the entire XR viewport).
            this.xrSession.updateRenderState({
                baseLayer: new XRWebGLLayer(this.xrSession, this.gl)
            });
            // Update target framerate to 90 fps if 90 fps is supported in this XR device
            if (this.xrSession.supportedFrameRates) {
                for (const frameRate of this.xrSession.supportedFrameRates) {
                    if (frameRate == 90) {
                        session.updateTargetFrameRate(90);
                    }
                }
            }
            // Binding to each new frame to get latest XR updates
            this.xrSession.requestAnimationFrame(this.onXrFrame.bind(this));
        });
        this.onSessionStarted.dispatchEvent(new Event('xrSessionStarted'));
    }
    areArraysEqual(a, b) {
        return (a.length === b.length && a.every((element, index) => Math.abs(element - b[index]) <= this.EPSILON));
    }
    arePointsEqual(a, b) {
        return (Math.abs(a.x - b.x) >= this.EPSILON &&
            Math.abs(a.y - b.y) >= this.EPSILON &&
            Math.abs(a.z - b.z) >= this.EPSILON);
    }
    sendXRDataToUE() {
        if (this.leftView == null || this.rightView == null) {
            return;
        }
        // We selectively send either the `XREyeViews` or `XRHMDTransform`
        // messages over the datachannel. The reason for this selective sending is that
        // the `XREyeViews` is a much larger message and changes infrequently (e.g. only when user changes headset IPD).
        // Therefore, we only need to send it once on startup and then any time it changes.
        // The rest of the time we can send the `XRHMDTransform` message.
        let shouldSendEyeViews = this.lastSentLeftEyeProj == null ||
            this.lastSentRightEyeProj == null ||
            this.lastSentRelativeLeftEyePos == null ||
            this.lastSentRelativeRightEyePos == null;
        const leftEyeTrans = this.leftView.transform.matrix;
        const leftEyeProj = this.leftView.projectionMatrix;
        const rightEyeTrans = this.rightView.transform.matrix;
        const rightEyeProj = this.rightView.projectionMatrix;
        const hmdTrans = this.xrViewerPose.transform.matrix;
        // Check if projection matrices have changed
        if (!shouldSendEyeViews && this.lastSentLeftEyeProj != null && this.lastSentRightEyeProj != null) {
            const leftEyeProjUnchanged = this.areArraysEqual(leftEyeProj, this.lastSentLeftEyeProj);
            const rightEyeProjUnchanged = this.areArraysEqual(rightEyeProj, this.lastSentRightEyeProj);
            shouldSendEyeViews = leftEyeProjUnchanged == false || rightEyeProjUnchanged == false;
        }
        const leftEyeRelativePos = new DOMPointReadOnly(this.leftView.transform.position.x - this.xrViewerPose.transform.position.x, this.leftView.transform.position.y - this.xrViewerPose.transform.position.y, this.leftView.transform.position.z - this.xrViewerPose.transform.position.z, 1.0);
        const rightEyeRelativePos = new DOMPointReadOnly(this.leftView.transform.position.x - this.xrViewerPose.transform.position.x, this.leftView.transform.position.y - this.xrViewerPose.transform.position.y, this.leftView.transform.position.z - this.xrViewerPose.transform.position.z, 1.0);
        // Check if relative eye pos has changed (e.g IPD changed)
        if (!shouldSendEyeViews &&
            this.lastSentRelativeLeftEyePos != null &&
            this.lastSentRelativeRightEyePos != null) {
            const leftEyePosUnchanged = this.arePointsEqual(leftEyeRelativePos, this.lastSentRelativeLeftEyePos);
            const rightEyePosUnchanged = this.arePointsEqual(rightEyeRelativePos, this.lastSentRelativeRightEyePos);
            shouldSendEyeViews = leftEyePosUnchanged == false || rightEyePosUnchanged == false;
            // Note: We are not checking if EyeView rotation changes (as far as I know no HMD supports changing this value at runtime).
        }
        if (shouldSendEyeViews) {
            // send transform (4x4) and projection matrix (4x4) data for each eye (left first, then right)
            // prettier-ignore
            this.webRtcController.streamMessageController.toStreamerHandlers.get('XREyeViews')([
                // Left eye 4x4 transform matrix
                leftEyeTrans[0], leftEyeTrans[4], leftEyeTrans[8], leftEyeTrans[12],
                leftEyeTrans[1], leftEyeTrans[5], leftEyeTrans[9], leftEyeTrans[13],
                leftEyeTrans[2], leftEyeTrans[6], leftEyeTrans[10], leftEyeTrans[14],
                leftEyeTrans[3], leftEyeTrans[7], leftEyeTrans[11], leftEyeTrans[15],
                // Left eye 4x4 projection matrix
                leftEyeProj[0], leftEyeProj[4], leftEyeProj[8], leftEyeProj[12],
                leftEyeProj[1], leftEyeProj[5], leftEyeProj[9], leftEyeProj[13],
                leftEyeProj[2], leftEyeProj[6], leftEyeProj[10], leftEyeProj[14],
                leftEyeProj[3], leftEyeProj[7], leftEyeProj[11], leftEyeProj[15],
                // Right eye 4x4 transform matrix
                rightEyeTrans[0], rightEyeTrans[4], rightEyeTrans[8], rightEyeTrans[12],
                rightEyeTrans[1], rightEyeTrans[5], rightEyeTrans[9], rightEyeTrans[13],
                rightEyeTrans[2], rightEyeTrans[6], rightEyeTrans[10], rightEyeTrans[14],
                rightEyeTrans[3], rightEyeTrans[7], rightEyeTrans[11], rightEyeTrans[15],
                // right eye 4x4 projection matrix
                rightEyeProj[0], rightEyeProj[4], rightEyeProj[8], rightEyeProj[12],
                rightEyeProj[1], rightEyeProj[5], rightEyeProj[9], rightEyeProj[13],
                rightEyeProj[2], rightEyeProj[6], rightEyeProj[10], rightEyeProj[14],
                rightEyeProj[3], rightEyeProj[7], rightEyeProj[11], rightEyeProj[15],
                // HMD 4x4 transform
                hmdTrans[0], hmdTrans[4], hmdTrans[8], hmdTrans[12],
                hmdTrans[1], hmdTrans[5], hmdTrans[9], hmdTrans[13],
                hmdTrans[2], hmdTrans[6], hmdTrans[10], hmdTrans[14],
                hmdTrans[3], hmdTrans[7], hmdTrans[11], hmdTrans[15],
            ]);
            this.lastSentLeftEyeProj = leftEyeProj;
            this.lastSentRightEyeProj = rightEyeProj;
            this.lastSentRelativeLeftEyePos = leftEyeRelativePos;
            this.lastSentRelativeRightEyePos = rightEyeRelativePos;
        }
        else {
            // If we don't need to the entire eye views being sent just send the HMD transform
            this.webRtcController.streamMessageController.toStreamerHandlers.get('XRHMDTransform')([
                // HMD 4x4 transform
                hmdTrans[0],
                hmdTrans[4],
                hmdTrans[8],
                hmdTrans[12],
                hmdTrans[1],
                hmdTrans[5],
                hmdTrans[9],
                hmdTrans[13],
                hmdTrans[2],
                hmdTrans[6],
                hmdTrans[10],
                hmdTrans[14],
                hmdTrans[3],
                hmdTrans[7],
                hmdTrans[11],
                hmdTrans[15]
            ]);
        }
    }
    onXrFrame(time, frame) {
        this.xrViewerPose = frame.getViewerPose(this.xrRefSpace);
        if (this.xrViewerPose) {
            this.updateViews();
            if (this.leftView == null || this.rightView == null) {
                return;
            }
            this.sendXRDataToUE();
            this.updateVideoTexture();
            this.render();
        }
        if (this.webRtcController.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.XRControllerInput)) {
            this.xrSession.inputSources.forEach((source, _index, _array) => {
                this.xrGamepadController.updateStatus(source, frame, this.xrRefSpace);
            }, this);
        }
        this.xrSession.requestAnimationFrame((time, frame) => this.onXrFrame(time, frame));
        this.onFrame.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_3__.XrFrameEvent({ time, frame }));
    }
    updateViews() {
        if (!this.xrViewerPose) {
            return;
        }
        for (const view of this.xrViewerPose.views) {
            if (view.eye === 'left') {
                this.leftView = view;
            }
            else if (view.eye === 'right') {
                this.rightView = view;
            }
        }
    }
    render() {
        if (!this.gl) {
            return;
        }
        // Bind the framebuffer to the base layer's framebuffer
        const glLayer = this.xrSession.renderState.baseLayer;
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, glLayer.framebuffer);
        // Set the relevant portion of clip space
        this.gl.viewport(0, 0, glLayer.framebufferWidth, glLayer.framebufferHeight);
        // Draw the rectangle we will show the video stream texture on
        this.gl.drawArrays(this.gl.TRIANGLES /*primitiveType*/, 0 /*offset*/, 6 /*count*/);
    }
    static isSessionSupported(mode) {
        if (location.protocol !== 'https:') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('WebXR requires https, if you want WebXR use https.');
        }
        if (navigator.xr) {
            return navigator.xr.isSessionSupported(mode);
        }
        else {
            return new Promise(() => {
                return false;
            });
        }
    }
}
//# sourceMappingURL=WebXRController.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Application/Application.js":
/*!************************************************************!*\
  !*** ../../ui-library/dist/esm/Application/Application.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Application: () => (/* binding */ Application)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Overlay_ConnectOverlay__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Overlay/ConnectOverlay */ "../../ui-library/dist/esm/Overlay/ConnectOverlay.js");
/* harmony import */ var _Overlay_DisconnectOverlay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Overlay/DisconnectOverlay */ "../../ui-library/dist/esm/Overlay/DisconnectOverlay.js");
/* harmony import */ var _Overlay_PlayOverlay__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Overlay/PlayOverlay */ "../../ui-library/dist/esm/Overlay/PlayOverlay.js");
/* harmony import */ var _Overlay_InfoOverlay__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Overlay/InfoOverlay */ "../../ui-library/dist/esm/Overlay/InfoOverlay.js");
/* harmony import */ var _Overlay_ErrorOverlay__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Overlay/ErrorOverlay */ "../../ui-library/dist/esm/Overlay/ErrorOverlay.js");
/* harmony import */ var _Overlay_AFKOverlay__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../Overlay/AFKOverlay */ "../../ui-library/dist/esm/Overlay/AFKOverlay.js");
/* harmony import */ var _UI_Controls__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../UI/Controls */ "../../ui-library/dist/esm/UI/Controls.js");
/* harmony import */ var _UI_LabelledButton__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../UI/LabelledButton */ "../../ui-library/dist/esm/UI/LabelledButton.js");
/* harmony import */ var _UI_SettingsPanel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../UI/SettingsPanel */ "../../ui-library/dist/esm/UI/SettingsPanel.js");
/* harmony import */ var _UI_StatsPanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../UI/StatsPanel */ "../../ui-library/dist/esm/UI/StatsPanel.js");
/* harmony import */ var _UI_VideoQpIndicator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../UI/VideoQpIndicator */ "../../ui-library/dist/esm/UI/VideoQpIndicator.js");
/* harmony import */ var _Config_ConfigUI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Config/ConfigUI */ "../../ui-library/dist/esm/Config/ConfigUI.js");
/* harmony import */ var _UI_EditTextModal__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../UI/EditTextModal */ "../../ui-library/dist/esm/UI/EditTextModal.js");
/* harmony import */ var _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UI/UIConfigurationTypes */ "../../ui-library/dist/esm/UI/UIConfigurationTypes.js");
/* harmony import */ var _UI_FullscreenIcon__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../UI/FullscreenIcon */ "../../ui-library/dist/esm/UI/FullscreenIcon.js");
// Copyright Epic Games, Inc. All Rights Reserved.
















/**
 * An Application is a combination of UI elements to display and manage a WebRTC Pixel Streaming
 * connection. It includes features for controlling a stream with mouse and keyboard,
 * managing connection endpoints, as well as displaying stats and other information about it.
 */
class Application {
    /**
     * @param options - Initialization options
     */
    constructor(options) {
        this.editTextModal = null;
        this._options = options;
        this.stream = options.stream;
        // Explicitly create ui features now so creation time is known
        this._uiFeatureElement = this.createUIFeaturesElement();
        // Explicitly create root element now so creation time is known
        this._rootElement = this.createRootElement(this.stream, this._uiFeatureElement);
        this.onColorModeChanged = options.onColorModeChanged;
        this.configUI = new _Config_ConfigUI__WEBPACK_IMPORTED_MODULE_0__.ConfigUI(this.stream.config);
        this.createOverlays();
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.isPanelEnabled)(options.statsPanelConfig)) {
            // Add stats panel
            this.statsPanel = new _UI_StatsPanel__WEBPACK_IMPORTED_MODULE_2__.StatsPanel(options.statsPanelConfig, this.stream.config);
            this.uiFeaturesElement.appendChild(this.statsPanel.rootElement);
        }
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.isPanelEnabled)(options.settingsPanelConfig)) {
            // Add settings panel
            this.settingsPanel = new _UI_SettingsPanel__WEBPACK_IMPORTED_MODULE_3__.SettingsPanel();
            this.uiFeaturesElement.appendChild(this.settingsPanel.rootElement);
            this.configureSettings();
        }
        if (!options.videoQpIndicatorConfig || !options.videoQpIndicatorConfig.disableIndicator) {
            // Add the video stream QP indicator
            this.videoQpIndicator = new _UI_VideoQpIndicator__WEBPACK_IMPORTED_MODULE_4__.VideoQpIndicator(options.videoQpIndicatorConfig);
            this.uiFeaturesElement.appendChild(this.videoQpIndicator.rootElement);
        }
        this.createButtons();
        this.registerCallbacks();
        this.showConnectOrAutoConnectOverlays();
        this.setColorMode(this.configUI.isCustomFlagEnabled(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.ExtraFlags.LightMode));
        this.stream.config._addOnSettingChangedListener(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Flags.HideUI, (isEnabled) => {
            this._uiFeatureElement.style.visibility = isEnabled ? 'hidden' : 'visible';
        });
        if (this.stream.config.isFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Flags.HideUI)) {
            this._uiFeatureElement.style.visibility = 'hidden';
        }
    }
    createOverlays() {
        // build all of the overlays
        this.disconnectOverlay = new _Overlay_DisconnectOverlay__WEBPACK_IMPORTED_MODULE_6__.DisconnectOverlay(this.stream.videoElementParent);
        this.connectOverlay = new _Overlay_ConnectOverlay__WEBPACK_IMPORTED_MODULE_7__.ConnectOverlay(this.stream.videoElementParent);
        this.playOverlay = new _Overlay_PlayOverlay__WEBPACK_IMPORTED_MODULE_8__.PlayOverlay(this.stream.videoElementParent);
        this.infoOverlay = new _Overlay_InfoOverlay__WEBPACK_IMPORTED_MODULE_9__.InfoOverlay(this.stream.videoElementParent);
        this.errorOverlay = new _Overlay_ErrorOverlay__WEBPACK_IMPORTED_MODULE_10__.ErrorOverlay(this.stream.videoElementParent);
        this.afkOverlay = new _Overlay_AFKOverlay__WEBPACK_IMPORTED_MODULE_11__.AFKOverlay(this.stream.videoElementParent);
        this.disconnectOverlay.onAction(() => this.stream.reconnect());
        // Build the webRtc connect overlay Event Listener and show the connect overlay
        this.connectOverlay.onAction(() => this.stream.connect());
        // set up the play overlays action
        this.playOverlay.onAction(() => this.stream.play());
    }
    /**
     * Set up button click functions and button functionality
     */
    createButtons() {
        const isIphone = /iPhone/.test(navigator.userAgent);
        const isIpad = /iPad/.test(navigator.userAgent) ||
            (/Macintosh/.test(navigator.userAgent) && 'ontouchend' in document);
        const isSafari = navigator.vendor &&
            navigator.vendor.indexOf('Apple') > -1 &&
            navigator.userAgent &&
            navigator.userAgent.indexOf('CriOS') == -1 &&
            navigator.userAgent.indexOf('FxiOS') == -1;
        // In some cases we want to disable fullscreen button if it is not explicitly requested:
        // IPhone does not support fullscreen API as at 28th July 2024 (see: https://caniuse.com/fullscreen) so if
        // we are on IPhone and user has not specified explicitly configured UI config for
        // fullscreen button then we should disable this button as it doesn't work.
        // Additionally iPad on non-Safari browsers doesn't really allow touch inputs and fullscreen video at the same time.
        // If you do this the video gets dragged off back to normal non-fullscreen video and then the video is paused.
        // See: https://github.com/EpicGamesExt/PixelStreamingInfrastructure/issues/219
        const disableFullscreenButton = isIphone || (!isSafari && isIpad);
        if (this._options.fullScreenControlsConfig === undefined && disableFullscreenButton) {
            this._options.fullScreenControlsConfig = { creationMode: _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.UIElementCreationMode.Disable };
        }
        const controlsUIConfig = {
            statsButtonType: this._options.statsPanelConfig
                ? this._options.statsPanelConfig.visibilityButtonConfig
                : undefined,
            settingsButtonType: this._options.settingsPanelConfig
                ? this._options.settingsPanelConfig.visibilityButtonConfig
                : undefined,
            fullscreenButtonType: this._options.fullScreenControlsConfig,
            xrIconType: this._options.xrControlsConfig,
            hideControlsInFullscreen: this._options.hideControlsInFullscreen
        };
        // Setup controls
        const controls = new _UI_Controls__WEBPACK_IMPORTED_MODULE_12__.Controls(controlsUIConfig);
        this.uiFeaturesElement.appendChild(controls.rootElement);
        // When we fullscreen we want this element to be the root
        const fullScreenButton = 
        // Depending on if we're creating an internal button, or using an external one
        !!this._options.fullScreenControlsConfig &&
            this._options.fullScreenControlsConfig.creationMode === _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.UIElementCreationMode.UseCustomElement
            ? // Either create a fullscreen class based on the external button
                new _UI_FullscreenIcon__WEBPACK_IMPORTED_MODULE_13__.FullScreenIconExternal(this._options.fullScreenControlsConfig.customElement)
            : // Or use the one created by the Controls initializer earlier
                controls.fullscreenIcon;
        if (fullScreenButton) {
            fullScreenButton.fullscreenElement = /iPad|iPhone|iPod/.test(navigator.userAgent)
                ? this.stream.videoElementParent.getElementsByTagName('video')[0]
                : this.rootElement;
        }
        // Add settings button to controls
        const settingsButton = controls.settingsIcon
            ? controls.settingsIcon.rootElement
            : this._options.settingsPanelConfig.visibilityButtonConfig.customElement;
        if (settingsButton)
            settingsButton.onclick = () => this.settingsClicked();
        if (this.settingsPanel)
            this.settingsPanel.settingsCloseButton.onclick = () => this.settingsClicked();
        // Add WebXR button to controls
        const xrButton = controls.xrIcon
            ? controls.xrIcon.rootElement
            : this._options.xrControlsConfig.creationMode === _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.UIElementCreationMode.UseCustomElement
                ? this._options.xrControlsConfig.customElement
                : undefined;
        if (xrButton)
            xrButton.onclick = () => this.stream.toggleXR();
        // setup the stats/info button
        const statsButton = controls.statsIcon
            ? controls.statsIcon.rootElement
            : this._options.statsPanelConfig.visibilityButtonConfig.customElement;
        if (statsButton)
            statsButton.onclick = () => this.statsClicked();
        if (this.statsPanel) {
            this.statsPanel.statsCloseButton.onclick = () => this.statsClicked();
        }
        // Add command buttons (if we have somewhere to add them to)
        if (this.settingsPanel) {
            // Add button for toggle fps
            const showFPSButton = new _UI_LabelledButton__WEBPACK_IMPORTED_MODULE_14__.LabelledButton('Show FPS', 'Toggle');
            showFPSButton.addOnClickListener(() => {
                this.stream.requestShowFps();
            });
            // Add button for restart stream
            const restartStreamButton = new _UI_LabelledButton__WEBPACK_IMPORTED_MODULE_14__.LabelledButton('Restart Stream', 'Restart');
            restartStreamButton.addOnClickListener(() => {
                this.stream.reconnect();
            });
            // Add button for request keyframe
            const requestKeyframeButton = new _UI_LabelledButton__WEBPACK_IMPORTED_MODULE_14__.LabelledButton('Request keyframe', 'Request');
            requestKeyframeButton.addOnClickListener(() => {
                this.stream.requestIframe();
            });
            const commandsSectionElem = this.configUI.buildSectionWithHeading(this.settingsPanel.settingsContentElement, 'Commands');
            commandsSectionElem.appendChild(showFPSButton.rootElement);
            commandsSectionElem.appendChild(requestKeyframeButton.rootElement);
            commandsSectionElem.appendChild(restartStreamButton.rootElement);
        }
    }
    /**
     * Configure the settings with on change listeners and any additional per experience settings.
     */
    configureSettings() {
        // This builds all the settings sections and flags under this `settingsContent` element.
        this.configUI.populateSettingsElement(this.settingsPanel.settingsContentElement, this._options.settingsPanelConfig);
        this.configUI.addCustomFlagOnSettingChangedListener(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.ExtraFlags.LightMode, (isLightMode) => {
            this.configUI.setCustomFlagLabel(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.ExtraFlags.LightMode, `Color Scheme: ${isLightMode ? 'Light' : 'Dark'} Mode`);
            this.setColorMode(isLightMode);
        });
    }
    registerCallbacks() {
        this.stream.addEventListener('afkWarningActivate', ({ data: { countDown, dismissAfk } }) => this.showAfkOverlay(countDown, dismissAfk));
        this.stream.addEventListener('afkWarningUpdate', ({ data: { countDown } }) => this.afkOverlay.updateCountdown(countDown));
        this.stream.addEventListener('afkWarningDeactivate', () => this.afkOverlay.hide());
        this.stream.addEventListener('afkTimedOut', () => this.afkOverlay.hide());
        this.stream.addEventListener('videoEncoderAvgQP', ({ data: { avgQP } }) => this.onVideoEncoderAvgQP(avgQP));
        this.stream.addEventListener('webRtcSdp', () => this.onWebRtcSdp());
        this.stream.addEventListener('webRtcAutoConnect', () => this.onWebRtcAutoConnect());
        this.stream.addEventListener('webRtcConnecting', () => this.onWebRtcConnecting());
        this.stream.addEventListener('webRtcConnected', () => this.onWebRtcConnected());
        this.stream.addEventListener('webRtcFailed', () => this.onWebRtcFailed());
        this.stream.addEventListener('webRtcDisconnected', ({ data: { eventString, allowClickToReconnect } }) => this.onDisconnect(eventString, allowClickToReconnect));
        this.stream.addEventListener('videoInitialized', () => this.onVideoInitialized());
        this.stream.addEventListener('streamLoading', () => this.onStreamLoading());
        this.stream.addEventListener('playStreamError', ({ data: { message } }) => this.onPlayStreamError(message));
        this.stream.addEventListener('playStream', () => this.onPlayStream());
        this.stream.addEventListener('playStreamRejected', ({ data: { reason } }) => this.onPlayStreamRejected(reason));
        this.stream.addEventListener('loadFreezeFrame', ({ data: { shouldShowPlayOverlay } }) => this.onLoadFreezeFrame(shouldShowPlayOverlay));
        this.stream.addEventListener('statsReceived', ({ data: { aggregatedStats } }) => this.onStatsReceived(aggregatedStats));
        this.stream.addEventListener('latencyCalculated', ({ data: { latencyInfo } }) => this.onLatencyUpdate(latencyInfo));
        this.stream.addEventListener('latencyTestResult', ({ data: { latencyTimings } }) => this.onLatencyTestResults(latencyTimings));
        this.stream.addEventListener('dataChannelLatencyTestResult', ({ data: { result } }) => this.onDataChannelLatencyTestResults(result));
        this.stream.addEventListener('streamerListMessage', ({ data: { messageStreamerList, autoSelectedStreamerId, wantedStreamerId } }) => this.handleStreamerListMessage(messageStreamerList, autoSelectedStreamerId, wantedStreamerId));
        this.stream.addEventListener('subscribeFailed', ({ data: { message } }) => this.handleSubscribeFailedMessage(message));
        this.stream.addEventListener('settingsChanged', (event) => this.onSettingsChanged(event));
        this.stream.addEventListener('playerCount', ({ data: { count } }) => this.onPlayerCount(count));
        this.stream.addEventListener('webRtcTCPRelayDetected', () => _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Warning(`Stream quailty degraded due to network enviroment, stream is relayed over TCP.`));
        this.stream.addEventListener('showOnScreenKeyboard', (event) => {
            // Only show the edit text modal if the flag is enabled
            if (!this.stream.config.isFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Flags.UseModalForTextInput)) {
                return;
            }
            const evtData = event.data;
            if (evtData.showOnScreenKeyboard) {
                this.showEditTextModal(evtData.contents);
            }
        });
    }
    /**
     * Gets the rootElement of the application, video stream and all UI are children of this element.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = this.createRootElement(this.stream, this.uiFeaturesElement);
        }
        return this._rootElement;
    }
    /**
     * Creates the root element for the Pixel Streaming UI.
     * Note: This should be called before the Pixel Streaming object is created.
     * @param pixelstreaming - The Pixel Streaming object.
     * @param uiFeaturesElem - The element holding all the custom UI features.
     * @returns A div with the id #playerUI populated with videoElementParent and uiFeatureElement.
     */
    createRootElement(pixelstreaming, uiFeaturesElem) {
        const elem = document.createElement('div');
        elem.id = 'playerUI';
        elem.classList.add('noselect');
        if (pixelstreaming === undefined) {
            throw new Error('Could not create root element properly - pixelstreaming object was undefined. Are you calling this too early?');
        }
        if (pixelstreaming.videoElementParent === undefined) {
            throw new Error('Could not create root element properly - videoElementParent object was undefined. Are you calling this too early?');
        }
        if (uiFeaturesElem === undefined) {
            throw new Error('Could not create root element properly - uiFeaturesElement object was undefined. Are you calling this too early?');
        }
        elem.appendChild(pixelstreaming.videoElementParent);
        elem.appendChild(uiFeaturesElem);
        return elem;
    }
    /**
     * Gets the element that contains all the UI features, like the stats and settings panels.
     */
    get uiFeaturesElement() {
        if (!this._uiFeatureElement) {
            this._uiFeatureElement = this.createUIFeaturesElement();
        }
        return this._uiFeatureElement;
    }
    /**
     * Creates the UI features element for holding all the custom UI features.
     * @returns A div with the id #uiFeatures.
     */
    createUIFeaturesElement() {
        const elem = document.createElement('div');
        elem.id = 'uiFeatures';
        return elem;
    }
    /**
     * Shows the disconnect overlay
     * @param updateText - the text that will be displayed in the overlay
     */
    showDisconnectOverlay(updateText) {
        this.hideCurrentOverlay();
        this.updateDisconnectOverlay(updateText);
        this.disconnectOverlay.show();
        this.currentOverlay = this.disconnectOverlay;
    }
    /**
     * Update the disconnect overlays span text
     * @param updateText - the new countdown number
     */
    updateDisconnectOverlay(updateText) {
        this.disconnectOverlay.update(updateText);
    }
    /**
     * Activates the disconnect overlays action
     */
    onDisconnectionAction() {
        this.disconnectOverlay.activate();
    }
    /**
     * Hides the current overlay
     */
    hideCurrentOverlay() {
        if (this.currentOverlay != null) {
            this.currentOverlay.hide();
            this.currentOverlay = null;
        }
    }
    /**
     * Shows the connect overlay
     */
    showConnectOverlay() {
        this.hideCurrentOverlay();
        this.connectOverlay.show();
        this.currentOverlay = this.connectOverlay;
    }
    /**
     * Shows the play overlay
     */
    showPlayOverlay() {
        this.hideCurrentOverlay();
        this.playOverlay.show();
        this.currentOverlay = this.playOverlay;
    }
    /**
     * Shows the text overlay
     * @param text - the text that will be shown in the overlay
     */
    showTextOverlay(text) {
        this.hideCurrentOverlay();
        this.infoOverlay.update(text);
        this.infoOverlay.show();
        this.currentOverlay = this.infoOverlay;
    }
    /**
     * Shows the error overlay
     * @param text - the text that will be shown in the overlay
     */
    showErrorOverlay(text) {
        this.hideCurrentOverlay();
        this.errorOverlay.update(text);
        this.errorOverlay.show();
        this.currentOverlay = this.errorOverlay;
    }
    /**
     * Shows or hides the settings panel if clicked
     */
    settingsClicked() {
        var _a;
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.hide();
        this.settingsPanel.toggleVisibility();
    }
    /**
     * Shows or hides the stats panel if clicked
     */
    statsClicked() {
        var _a;
        (_a = this.settingsPanel) === null || _a === void 0 ? void 0 : _a.hide();
        this.statsPanel.toggleVisibility();
    }
    /**
     * Activates the connect overlays action
     */
    onConnectAction() {
        this.connectOverlay.activate();
    }
    /**
     * Activates the play overlays action
     */
    onPlayAction() {
        this.playOverlay.activate();
    }
    /**
     * Shows the afk overlay
     * @param countDown - the countdown number for the afk countdown
     */
    showAfkOverlay(countDown, dismissAfk) {
        this.hideCurrentOverlay();
        this.afkOverlay.updateCountdown(countDown);
        this.afkOverlay.onAction(() => dismissAfk());
        this.afkOverlay.show();
        this.currentOverlay = this.afkOverlay;
    }
    /**
     * Show the Connect Overlay or auto connect
     */
    showConnectOrAutoConnectOverlays() {
        // set up if the auto play will be used or regular click to start
        if (!this.stream.config.isFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Flags.AutoConnect)) {
            this.showConnectOverlay();
        }
    }
    /**
     * Show the webRtcAutoConnect Overlay and connect
     */
    onWebRtcAutoConnect() {
        this.showTextOverlay('Auto Connecting Now');
    }
    /**
     * Set up functionality to happen when receiving a webRTC answer
     */
    onWebRtcSdp() {
        this.showTextOverlay('WebRTC Connection Negotiated');
    }
    /**
     * Shows a text overlay to alert the user the stream is currently loading
     */
    onStreamLoading() {
        // build the spinner span
        const spinnerSpan = document.createElement('span');
        spinnerSpan.className = 'visually-hidden';
        spinnerSpan.innerHTML = 'Loading...';
        // build the spinner div
        const spinnerDiv = document.createElement('div');
        spinnerDiv.id = 'loading-spinner';
        spinnerDiv.className = 'spinner-border ms-2';
        spinnerDiv.setAttribute('role', 'status');
        // append the spinner to the element
        spinnerDiv.appendChild(spinnerSpan);
        this.showTextOverlay('Loading Stream ' + spinnerDiv.outerHTML);
    }
    /**
     * Event fired when the video is disconnected - displays the error overlay and resets the buttons stream tools upon disconnect
     * @param eventString - the event text that will be shown in the overlay
     * @param allowClickToReconnect - true if we want to allow the user to click to reconnect. Otherwise it's just a message.
     */
    onDisconnect(eventString, allowClickToReconnect) {
        var _a;
        const overlayMessage = 'Disconnected' + (eventString ? `: ${eventString}` : '.');
        if (allowClickToReconnect) {
            this.showDisconnectOverlay(`${overlayMessage} Click To Restart.`);
        }
        else {
            this.showErrorOverlay(overlayMessage);
        }
        // disable starting a latency checks
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.onDisconnect();
    }
    /**
     * Handles when Web Rtc is connecting
     */
    onWebRtcConnecting() {
        this.showTextOverlay('Starting connection to server, please wait');
    }
    /**
     * Handles when Web Rtc has connected
     */
    onWebRtcConnected() {
        this.showTextOverlay('WebRTC connected, waiting for video');
    }
    /**
     * Handles when Web Rtc fails to connect
     */
    onWebRtcFailed() {
        this.showErrorOverlay('Unable to setup video');
    }
    onLoadFreezeFrame(shouldShowPlayOverlay) {
        if (shouldShowPlayOverlay === true) {
            _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('showing play overlay');
            this.showPlayOverlay();
        }
    }
    onPlayStream() {
        this.hideCurrentOverlay();
    }
    onPlayStreamError(message) {
        this.showErrorOverlay(message);
    }
    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
    onPlayStreamRejected(onRejectedReason) {
        this.showPlayOverlay();
    }
    onVideoInitialized() {
        var _a;
        if (!this.stream.config.isFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Flags.AutoPlayVideo)) {
            this.showPlayOverlay();
        }
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.onVideoInitialized(this.stream);
    }
    /**
     * Set up functionality to happen when calculating the average video encoder qp
     * @param QP - the quality number of the stream
     */
    onVideoEncoderAvgQP(QP) {
        // Update internal QP indicator if one is present
        if (this.videoQpIndicator) {
            this.videoQpIndicator.updateQpTooltip(QP);
        }
    }
    onInitialSettings(settings) {
        var _a;
        if (settings.PixelStreamingSettings) {
            (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.configure(settings.PixelStreamingSettings);
        }
    }
    onStatsReceived(aggregatedStats) {
        var _a;
        // Grab all stats we can off the aggregated stats
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.handleStats(aggregatedStats);
    }
    onLatencyUpdate(latencyInfo) {
        var _a;
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.handleLatencyInfo(latencyInfo);
    }
    onLatencyTestResults(latencyTimings) {
        var _a;
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.latencyTest.handleTestResult(latencyTimings);
    }
    onDataChannelLatencyTestResults(result) {
        var _a;
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.dataChannelLatencyTest.handleTestResult(result);
    }
    onPlayerCount(playerCount) {
        var _a;
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.handlePlayerCount(playerCount);
    }
    handleStreamerListMessage(messageStreamingList, autoSelectedStreamerId, wantedStreamerId) {
        const waitForStreamer = this.stream.config.isFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Flags.WaitForStreamer);
        const isReconnecting = this.stream.isReconnecting();
        let message = null;
        let allowRestart = true;
        if (!autoSelectedStreamerId) {
            if (waitForStreamer && wantedStreamerId) {
                if (isReconnecting) {
                    message = `Waiting for ${wantedStreamerId} to become available.`;
                    allowRestart = false;
                }
                else {
                    message = `Gave up waiting for ${wantedStreamerId} to become available. Click to try again`;
                    if (messageStreamingList.ids.length > 0) {
                        message += ` or select a streamer from the settings menu.`;
                    }
                    allowRestart = true;
                }
            }
            else if (messageStreamingList.ids.length == 0) {
                if (isReconnecting) {
                    message = `Waiting for a streamer to become available.`;
                    allowRestart = false;
                }
                else {
                    message = `No streamers available. Click to try again.`;
                    allowRestart = true;
                }
            }
            else {
                message = `Multiple streamers available. Select one from the settings menu.`;
                allowRestart = false;
            }
            if (allowRestart) {
                this.showDisconnectOverlay(message);
            }
            else {
                this.showTextOverlay(message);
            }
        }
    }
    handleSubscribeFailedMessage(message) {
        this.showDisconnectOverlay(`Subscribe failed: "${message}" Click to try again`);
    }
    /**
     * Set light/dark color mode
     * @param isLightMode - should we use a light or dark color scheme
     */
    setColorMode(isLightMode) {
        if (this.onColorModeChanged) {
            this.onColorModeChanged(isLightMode);
        }
    }
    showEditTextModal(ueTextboxContents) {
        var _a;
        // Remove any existing modal
        (_a = this.editTextModal) === null || _a === void 0 ? void 0 : _a.rootElement.remove();
        // Make a new modal for editing the UE textbox on the browser side
        this.editTextModal = new _UI_EditTextModal__WEBPACK_IMPORTED_MODULE_16__.EditTextModal();
        // Add it to the root of the Pixel Streaming application
        this.rootElement.append(this.editTextModal.rootElement);
        // Add the text content from UE side and summon on-screen keyboard
        this.editTextModal.showModal(ueTextboxContents);
        // Bind to the confirm event
        this.editTextModal.events.addEventListener('editConfirmed', (evt) => {
            const editTextEvent = evt;
            this.stream.sendTextboxEntry(editTextEvent.confirmedText);
        });
    }
    onSettingsChanged(event) {
        // Pass the event directly onto the configUI. This will do things like updating the possible values
        // as well as the selected value
        this.configUI.onSettingsChanged(event);
        const { 
        /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
        data: { id, target, type } } = event;
        // Explicitly handle specific setting behaviour
        if (id == _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.OptionParameters.PreferredQuality) {
            const preferredQualityOption = this.stream.config.getSettingOption(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.OptionParameters.PreferredQuality);
            if ([...preferredQualityOption.options].includes('Default')) {
                this.configUI.disableSetting(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.OptionParameters.PreferredQuality);
            }
            else {
                this.configUI.enableSetting(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.OptionParameters.PreferredQuality);
            }
        }
    }
}
//# sourceMappingURL=Application.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Config/ConfigUI.js":
/*!****************************************************!*\
  !*** ../../ui-library/dist/esm/Config/ConfigUI.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConfigUI: () => (/* binding */ ConfigUI)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/Config/SettingFlag.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _SettingUIFlag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SettingUIFlag */ "../../ui-library/dist/esm/Config/SettingUIFlag.js");
/* harmony import */ var _SettingUINumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SettingUINumber */ "../../ui-library/dist/esm/Config/SettingUINumber.js");
/* harmony import */ var _SettingUIText__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SettingUIText */ "../../ui-library/dist/esm/Config/SettingUIText.js");
/* harmony import */ var _SettingUIOption__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SettingUIOption */ "../../ui-library/dist/esm/Config/SettingUIOption.js");
/* harmony import */ var _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../UI/UIConfigurationTypes */ "../../ui-library/dist/esm/UI/UIConfigurationTypes.js");
// Copyright Epic Games, Inc. All Rights Reserved.






class ConfigUI {
    // ------------ Settings -----------------
    constructor(config) {
        this.customFlags = new Map();
        /* A map of flags that can be toggled - options that can be set in the application - e.g. Use Mic? */
        this.flagsUi = new Map();
        /* A map of numerical settings - options that can be in the application - e.g. MinBitrate */
        this.numericParametersUi = new Map();
        /* A map of text settings - e.g. signalling server url */
        this.textParametersUi = new Map();
        /* A map of enum based settings - e.g. preferred codec */
        this.optionParametersUi = new Map();
        this.createCustomUISettings(config.useUrlParams);
        this.registerSettingsUIComponents(config);
    }
    /**
     * Create custom UI settings that are not provided by the Pixel Streaming library.
     */
    createCustomUISettings(useUrlParams) {
        this.customFlags.set(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.ExtraFlags.LightMode, new _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__.SettingFlag(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.ExtraFlags.LightMode, 'Color Scheme: Dark Mode', 'Page styling will be either light or dark', false /*if want to use system pref: (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches)*/, useUrlParams, (isLightMode, setting) => {
            setting.label = `Color Scheme: ${isLightMode ? 'Light' : 'Dark'} Mode`;
        }));
    }
    /**
     * Creates UI wrapper components for each setting element in config.
     * @param config -
     */
    registerSettingsUIComponents(config) {
        for (const setting of config.getFlags()) {
            this.flagsUi.set(setting.id, new _SettingUIFlag__WEBPACK_IMPORTED_MODULE_2__.SettingUIFlag(setting));
        }
        for (const setting of Array.from(this.customFlags.values())) {
            this.flagsUi.set(setting.id, new _SettingUIFlag__WEBPACK_IMPORTED_MODULE_2__.SettingUIFlag(setting));
        }
        for (const setting of config.getTextSettings()) {
            this.textParametersUi.set(setting.id, new _SettingUIText__WEBPACK_IMPORTED_MODULE_3__.SettingUIText(setting));
        }
        for (const setting of config.getNumericSettings()) {
            this.numericParametersUi.set(setting.id, new _SettingUINumber__WEBPACK_IMPORTED_MODULE_4__.SettingUINumber(setting));
        }
        for (const setting of config.getOptionSettings()) {
            this.optionParametersUi.set(setting.id, new _SettingUIOption__WEBPACK_IMPORTED_MODULE_5__.SettingUIOption(setting));
        }
    }
    /**
     * Make DOM elements for a settings section with a heading.
     * @param settingsElem - The parent container for our DOM elements.
     * @param sectionHeading - The heading element to go into the section.
     * @returns The constructed DOM element for the section.
     */
    buildSectionWithHeading(settingsElem, sectionHeading) {
        // make section element
        const sectionElem = document.createElement('section');
        sectionElem.classList.add('settingsContainer');
        // make section heading
        const psSettingsHeader = document.createElement('div');
        psSettingsHeader.classList.add('settingsHeader');
        psSettingsHeader.classList.add('settings-text');
        psSettingsHeader.textContent = sectionHeading;
        // add section and heading to parent settings element
        sectionElem.appendChild(psSettingsHeader);
        settingsElem.appendChild(sectionElem);
        return sectionElem;
    }
    /**
     * Setup flags with their default values and add them to the `Config.flags` map.
     * @param settingsElem - - The element that contains all the individual settings sections, flags, and so on.
     */
    populateSettingsElement(settingsElem, settingsConfig) {
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSectionEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.PixelStreaming)) {
            /* Setup all Pixel Streaming specific settings */
            const psSettingsSection = this.buildSectionWithHeading(settingsElem, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.PixelStreaming);
            // make settings show up in DOM
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.TextParameters.SignallingServerUrl))
                this.addSettingText(psSettingsSection, this.textParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.TextParameters.SignallingServerUrl));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.BrowserSendOffer))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.BrowserSendOffer));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.StreamerId))
                this.addSettingOption(psSettingsSection, this.optionParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.StreamerId));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.AutoConnect))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.AutoConnect));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.AutoPlayVideo))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.AutoPlayVideo));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.UseMic))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.UseMic));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.UseCamera))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.UseCamera));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.StartVideoMuted))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.StartVideoMuted));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.IsQualityController))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.IsQualityController));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.ForceMonoAudio))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.ForceMonoAudio));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.ForceTURN))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.ForceTURN));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.SuppressBrowserKeys))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.SuppressBrowserKeys));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.AFKDetection))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.AFKDetection));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.WaitForStreamer))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.WaitForStreamer));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.AFKTimeoutSecs))
                this.addSettingNumeric(psSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.AFKTimeoutSecs));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.AFKCountdownSecs))
                this.addSettingNumeric(psSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.AFKCountdownSecs));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.MaxReconnectAttempts))
                this.addSettingNumeric(psSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.MaxReconnectAttempts));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.StreamerAutoJoinInterval))
                this.addSettingNumeric(psSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.StreamerAutoJoinInterval));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.KeepaliveDelay))
                this.addSettingNumeric(psSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.KeepaliveDelay));
        }
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSectionEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.UI)) {
            /* Setup all view/ui related settings under this section */
            const viewSettingsSection = this.buildSectionWithHeading(settingsElem, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.UI);
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.MatchViewportResolution))
                this.addSettingFlag(viewSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.MatchViewportResolution));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.HoveringMouseMode))
                this.addSettingFlag(viewSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.HoveringMouseMode));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.ExtraFlags.LightMode))
                this.addSettingFlag(viewSettingsSection, this.flagsUi.get(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.ExtraFlags.LightMode));
        }
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSectionEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.Input)) {
            /* Setup all encoder related settings under this section */
            const inputSettingsSection = this.buildSectionWithHeading(settingsElem, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.Input);
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.KeyboardInput))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.KeyboardInput));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.MouseInput))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.MouseInput));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.FakeMouseWithTouches))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.FakeMouseWithTouches));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.TouchInput))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.TouchInput));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.GamepadInput))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.GamepadInput));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.XRControllerInput))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.Flags.XRControllerInput));
        }
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSectionEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.Encoder)) {
            /* Setup all encoder related settings under this section */
            const encoderSettingsSection = this.buildSectionWithHeading(settingsElem, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.Encoder);
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.CompatQualityMin))
                this.addSettingNumeric(encoderSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.CompatQualityMin));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.CompatQualityMax))
                this.addSettingNumeric(encoderSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.CompatQualityMax));
            const preferredCodecOption = this.optionParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.PreferredCodec);
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.PreferredCodec))
                this.addSettingOption(encoderSettingsSection, this.optionParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.PreferredCodec));
            if (preferredCodecOption &&
                [...preferredCodecOption.selector.options]
                    .map((o) => o.value)
                    .includes('Only available on Chrome')) {
                preferredCodecOption.disable();
            }
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.PreferredQuality))
                this.addSettingOption(encoderSettingsSection, this.optionParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.PreferredQuality));
        }
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSectionEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.WebRTC)) {
            /* Setup all webrtc related settings under this section */
            const webrtcSettingsSection = this.buildSectionWithHeading(settingsElem, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.WebRTC);
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCFPS))
                this.addSettingNumeric(webrtcSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCFPS));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCMinBitrate))
                this.addSettingNumeric(webrtcSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCMinBitrate));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCMaxBitrate))
                this.addSettingNumeric(webrtcSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCMaxBitrate));
        }
    }
    /**
     * Add a SettingText element to a particular settings section in the DOM and registers that text in the text settings map.
     * @param settingsSection - The settings section HTML element.
     * @param settingText - The textual settings object.
     */
    addSettingText(settingsSection, settingText) {
        if (settingText) {
            settingsSection.appendChild(settingText.rootElement);
            this.textParametersUi.set(settingText.setting.id, settingText);
        }
    }
    /**
     * Add a SettingFlag element to a particular settings section in the DOM and registers that flag in the Config.flag map.
     * @param settingsSection - The settings section HTML element.
     * @param settingFlag - The settings flag object.
     */
    addSettingFlag(settingsSection, settingFlag) {
        if (settingFlag) {
            settingsSection.appendChild(settingFlag.rootElement);
            this.flagsUi.set(settingFlag.setting.id, settingFlag);
        }
    }
    /**
     * Add a numeric setting element to a particular settings section in the DOM and registers that flag in the Config.numericParameters map.
     * @param settingsSection - The settings section HTML element.
     * @param settingFlag - The settings flag object.
     */
    addSettingNumeric(settingsSection, setting) {
        if (setting) {
            settingsSection.appendChild(setting.rootElement);
            this.numericParametersUi.set(setting.setting.id, setting);
        }
    }
    /**
     * Add an enum based settings element to a particular settings section in the DOM and registers that flag in the Config.enumParameters map.
     * @param settingsSection - The settings section HTML element.
     * @param settingFlag - The settings flag object.
     */
    addSettingOption(settingsSection, setting) {
        if (setting) {
            settingsSection.appendChild(setting.rootElement);
            this.optionParametersUi.set(setting.setting.id, setting);
        }
    }
    onSettingsChanged({ data: { id, target, type } }) {
        if (type === 'flag') {
            const _id = id;
            const _target = target;
            const setting = this.flagsUi.get(_id);
            if (setting) {
                if (setting.flag !== _target.flag) {
                    setting.flag = _target.flag;
                }
                if (setting.label !== _target.label) {
                    setting.label = _target.label;
                }
            }
        }
        else if (type === 'number') {
            const _id = id;
            const _target = target;
            const setting = this.numericParametersUi.get(_id);
            if (setting) {
                if (setting.number !== _target.number) {
                    setting.number = _target.number;
                }
                if (setting.label !== _target.label) {
                    setting.label = _target.label;
                }
            }
        }
        else if (type === 'text') {
            const _id = id;
            const _target = target;
            const setting = this.textParametersUi.get(_id);
            if (setting) {
                if (setting.text !== _target.text) {
                    setting.text = _target.text;
                }
                if (setting.label !== _target.label) {
                    setting.label = _target.label;
                }
            }
        }
        else if (type === 'option') {
            const _id = id;
            const _target = target;
            const setting = this.optionParametersUi.get(_id);
            if (setting) {
                const uiOptions = setting.options;
                const targetOptions = _target.options;
                if (uiOptions.length !== targetOptions.length ||
                    !uiOptions.every((value) => targetOptions.includes(value))) {
                    setting.options = _target.options;
                }
                if (setting.selected !== _target.selected) {
                    setting.selected = _target.selected;
                }
                if (setting.label !== _target.label) {
                    setting.label = _target.label;
                }
            }
        }
    }
    /**
     * Add a callback to fire when the flag is toggled.
     * @param id - The id of the flag.
     * @param onChangeListener - The callback to fire when the value changes.
     */
    addCustomFlagOnSettingChangedListener(id, onChangeListener) {
        if (this.customFlags.has(id)) {
            this.customFlags.get(id).onChange = onChangeListener;
        }
    }
    /**
     * Set the label for the flag.
     * @param id - The id of the flag.
     * @param label - The new label to use for the flag.
     */
    setCustomFlagLabel(id, label) {
        if (!this.customFlags.has(id)) {
            _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_7__.Logger.Warning(`Cannot set label for flag called ${id} - it does not exist in the Config.flags map.`);
        }
        else {
            this.customFlags.get(id).label = label;
            this.flagsUi.get(id).label = label;
        }
    }
    /**
     * Get the value of the configuration flag which has the given id.
     * @param id - The unique id for the flag.
     * @returns True if the flag is enabled.
     */
    isCustomFlagEnabled(id) {
        return this.customFlags.get(id).flag;
    }
    disableSetting(id) {
        var _a, _b, _c, _d;
        if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.isFlagId)(id)) {
            (_a = this.flagsUi.get(id)) === null || _a === void 0 ? void 0 : _a.disable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.isNumericId)(id)) {
            (_b = this.numericParametersUi.get(id)) === null || _b === void 0 ? void 0 : _b.disable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.isTextId)(id)) {
            (_c = this.textParametersUi.get(id)) === null || _c === void 0 ? void 0 : _c.disable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.isOptionId)(id)) {
            (_d = this.optionParametersUi.get(id)) === null || _d === void 0 ? void 0 : _d.disable();
        }
    }
    enableSetting(id) {
        var _a, _b, _c, _d;
        if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.isFlagId)(id)) {
            (_a = this.flagsUi.get(id)) === null || _a === void 0 ? void 0 : _a.enable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.isNumericId)(id)) {
            (_b = this.numericParametersUi.get(id)) === null || _b === void 0 ? void 0 : _b.enable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.isTextId)(id)) {
            (_c = this.textParametersUi.get(id)) === null || _c === void 0 ? void 0 : _c.enable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_6__.isOptionId)(id)) {
            (_d = this.optionParametersUi.get(id)) === null || _d === void 0 ? void 0 : _d.enable();
        }
    }
}
//# sourceMappingURL=ConfigUI.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Config/SettingUIBase.js":
/*!*********************************************************!*\
  !*** ../../ui-library/dist/esm/Config/SettingUIBase.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingUIBase: () => (/* binding */ SettingUIBase)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Base class for a setting that has a text label, an arbitrary setting value it stores, an a HTML element that represents this setting.
 */
class SettingUIBase {
    constructor(setting) {
        this._setting = setting;
    }
    /**
     * @returns The setting component.
     */
    get setting() {
        return this._setting;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('div');
        }
        return this._rootElement;
    }
}
//# sourceMappingURL=SettingUIBase.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Config/SettingUIFlag.js":
/*!*********************************************************!*\
  !*** ../../ui-library/dist/esm/Config/SettingUIFlag.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingUIFlag: () => (/* binding */ SettingUIFlag)
/* harmony export */ });
/* harmony import */ var _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingUIBase */ "../../ui-library/dist/esm/Config/SettingUIBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class SettingUIFlag extends _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__.SettingUIBase {
    constructor(setting) {
        super(setting);
        this.label = setting.label;
        this.flag = setting.flag;
    }
    /**
     * @returns The setting component.
     */
    get setting() {
        return this._setting;
    }
    get settingsTextElem() {
        if (!this._settingsTextElem) {
            this._settingsTextElem = document.createElement('div');
            this._settingsTextElem.innerText = this.setting._label;
            this._settingsTextElem.title = this.setting.description;
        }
        return this._settingsTextElem;
    }
    get checkbox() {
        if (!this._checkbox) {
            this._checkbox = document.createElement('input');
            this._checkbox.type = 'checkbox';
            // Block keypress/up/down propogation from text field typing going to UE
            this._checkbox.addEventListener('keypress', (event) => {
                event.stopPropagation();
            });
            this._checkbox.addEventListener('keyup', (event) => {
                event.stopPropagation();
            });
            this._checkbox.addEventListener('keydown', (event) => {
                event.stopPropagation();
            });
        }
        return this._checkbox;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            // create root div with "setting" css class
            this._rootElement = document.createElement('div');
            this._rootElement.id = this.setting.id;
            this._rootElement.classList.add('setting');
            // create div element to contain our setting's text
            this._rootElement.appendChild(this.settingsTextElem);
            // create label element to wrap out input type
            const wrapperLabel = document.createElement('label');
            wrapperLabel.classList.add('tgl-switch');
            this._rootElement.appendChild(wrapperLabel);
            // create input type=checkbox
            this.checkbox.title = this.setting.description;
            this.checkbox.classList.add('tgl');
            this.checkbox.classList.add('tgl-flat');
            const slider = document.createElement('div');
            slider.classList.add('tgl-slider');
            wrapperLabel.appendChild(this.checkbox);
            wrapperLabel.appendChild(slider);
            // setup on change from checkbox
            this.checkbox.addEventListener('change', () => {
                if (this.setting.flag !== this.checkbox.checked) {
                    this.setting.flag = this.checkbox.checked;
                    this.setting.updateURLParams();
                }
            });
        }
        return this._rootElement;
    }
    /**
     * Update the setting's stored value.
     * @param inValue - The new value for the setting.
     */
    set flag(inValue) {
        this.checkbox.checked = inValue;
    }
    /**
     * Get value
     */
    get flag() {
        return this.checkbox.checked;
    }
    /**
     * Set the label text for the setting.
     * @param label - setting label.
     */
    set label(inLabel) {
        this.settingsTextElem.innerText = inLabel;
    }
    /**
     * Get label
     */
    get label() {
        return this.settingsTextElem.innerText;
    }
    disable() {
        this.checkbox.disabled = true;
    }
    enable() {
        this.checkbox.disabled = false;
    }
}
//# sourceMappingURL=SettingUIFlag.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Config/SettingUINumber.js":
/*!***********************************************************!*\
  !*** ../../ui-library/dist/esm/Config/SettingUINumber.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingUINumber: () => (/* binding */ SettingUINumber)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingUIBase */ "../../ui-library/dist/esm/Config/SettingUIBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * A number spinner with a text label beside it.
 */
class SettingUINumber extends _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__.SettingUIBase {
    constructor(setting) {
        super(setting);
        this.label = this.setting.label;
        this.number = this.setting.number;
    }
    /**
     * @returns The setting component.
     */
    get setting() {
        return this._setting;
    }
    get settingsTextElem() {
        if (!this._settingsTextElem) {
            this._settingsTextElem = document.createElement('label');
            this._settingsTextElem.innerText = this.setting.label;
            this._settingsTextElem.title = this.setting.description;
        }
        return this._settingsTextElem;
    }
    /**
     * Get the HTMLInputElement for the button.
     */
    get spinner() {
        if (!this._spinner) {
            this._spinner = document.createElement('input');
            this._spinner.type = 'number';
            if (this.setting.min != null) {
                this._spinner.min = this.setting.min.toString();
            }
            if (this.setting.max != null) {
                this._spinner.max = this.setting.max.toString();
            }
            this._spinner.value = this.setting.number.toString();
            this._spinner.title = this.setting.description;
            this._spinner.classList.add('form-control');
            // Block keypress/up/down propogation from text field typing going to UE
            this.spinner.addEventListener('keypress', (event) => {
                event.stopPropagation();
            });
            this.spinner.addEventListener('keyup', (event) => {
                event.stopPropagation();
            });
            this.spinner.addEventListener('keydown', (event) => {
                event.stopPropagation();
            });
        }
        return this._spinner;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            // create root div with "setting" css class
            this._rootElement = document.createElement('div');
            this._rootElement.classList.add('setting');
            this._rootElement.classList.add('form-group');
            // create div element to contain our setting's text
            this._rootElement.appendChild(this.settingsTextElem);
            // create label element to wrap out input type
            this._rootElement.appendChild(this.spinner);
            // setup onchange
            this.spinner.onchange = (event) => {
                const inputElem = event.target;
                const parsedValue = Number.parseFloat(inputElem.value);
                if (Number.isNaN(parsedValue)) {
                    _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Warning(`Could not parse value change into a valid number - value was ${inputElem.value}, resetting value to ${this.setting.min}`);
                    if (this.setting.number !== this.setting.min) {
                        this.setting.number = this.setting.min;
                    }
                }
                else {
                    if (this.setting.number !== parsedValue) {
                        this.setting.number = parsedValue;
                        this.setting.updateURLParams();
                    }
                }
            };
        }
        return this._rootElement;
    }
    /**
     * Set the number in the spinner (will be clamped within range).
     */
    set number(newNumber) {
        this.spinner.value = this.setting.clamp(newNumber).toString();
    }
    /**
     * Get value
     */
    get number() {
        return +this.spinner.value;
    }
    /**
     * Set the label text for the setting.
     * @param label - setting label.
     */
    set label(inLabel) {
        this.settingsTextElem.innerText = inLabel;
    }
    /**
     * Get label
     */
    get label() {
        return this.settingsTextElem.innerText;
    }
    disable() {
        this.spinner.disabled = true;
    }
    enable() {
        this.spinner.disabled = false;
    }
}
//# sourceMappingURL=SettingUINumber.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Config/SettingUIOption.js":
/*!***********************************************************!*\
  !*** ../../ui-library/dist/esm/Config/SettingUIOption.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingUIOption: () => (/* binding */ SettingUIOption)
/* harmony export */ });
/* harmony import */ var _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingUIBase */ "../../ui-library/dist/esm/Config/SettingUIBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class SettingUIOption extends _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__.SettingUIBase {
    constructor(setting) {
        super(setting);
        this.label = this.setting.label;
        this.options = this.setting.options;
        this.selected = this.setting.selected;
    }
    /**
     * @returns The setting component.
     */
    get setting() {
        return this._setting;
    }
    get selector() {
        if (!this._selector) {
            this._selector = document.createElement('select');
            this._selector.classList.add('form-control');
            this._selector.classList.add('settings-option');
        }
        return this._selector;
    }
    get settingsTextElem() {
        if (!this._settingsTextElem) {
            this._settingsTextElem = document.createElement('div');
            this._settingsTextElem.innerText = this.setting.label;
            this._settingsTextElem.title = this.setting.description;
        }
        return this._settingsTextElem;
    }
    /**
     * Set the label text for the setting.
     * @param label - setting label.
     */
    set label(inLabel) {
        this.settingsTextElem.innerText = inLabel;
    }
    /**
     * Get label
     */
    get label() {
        return this.settingsTextElem.innerText;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            // create root div with "setting" css class
            this._rootElement = document.createElement('div');
            this._rootElement.id = this.setting.id;
            this._rootElement.classList.add('setting');
            this._rootElement.classList.add('form-group');
            // create div element to contain our setting's text
            this._rootElement.appendChild(this.settingsTextElem);
            // create label element to wrap out input type
            const wrapperLabel = document.createElement('label');
            this._rootElement.appendChild(wrapperLabel);
            // create select element
            this.selector.title = this.setting.description;
            wrapperLabel.appendChild(this.selector);
            // setup on change from selector
            this.selector.onchange = () => {
                if (this.setting.selected !== this.selector.value) {
                    this.setting.selected = this.selector.value;
                    this.setting.updateURLParams();
                }
            };
            // Block keypress/up/down propogation from text field typing going to UE
            this.selector.addEventListener('keypress', (event) => {
                event.stopPropagation();
            });
            this.selector.addEventListener('keyup', (event) => {
                event.stopPropagation();
            });
            this.selector.addEventListener('keydown', (event) => {
                event.stopPropagation();
            });
        }
        return this._rootElement;
    }
    set options(values) {
        for (let i = this.selector.options.length - 1; i >= 0; i--) {
            this.selector.remove(i);
        }
        values.forEach((value) => {
            const opt = document.createElement('option');
            opt.value = value;
            opt.innerHTML = value;
            this.selector.appendChild(opt);
        });
    }
    get options() {
        return [...this.selector.options].map((o) => o.value);
    }
    set selected(value) {
        // A user may not specify the full possible value so we instead use the closest match.
        // eg ?xxx=H264 would select 'H264 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f'
        const filteredList = this.options.filter((option) => option.indexOf(value) !== -1);
        if (filteredList.length) {
            this.selector.value = filteredList[0];
        }
    }
    get selected() {
        return this.selector.value;
    }
    disable() {
        this.selector.disabled = true;
    }
    enable() {
        this.selector.disabled = false;
    }
}
//# sourceMappingURL=SettingUIOption.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Config/SettingUIText.js":
/*!*********************************************************!*\
  !*** ../../ui-library/dist/esm/Config/SettingUIText.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingUIText: () => (/* binding */ SettingUIText)
/* harmony export */ });
/* harmony import */ var _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingUIBase */ "../../ui-library/dist/esm/Config/SettingUIBase.js");
// Copyright Epic Games, Inc. All Rights Reserved.

class SettingUIText extends _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__.SettingUIBase {
    constructor(setting) {
        super(setting);
        this.label = this.setting.label;
        this.text = this.setting.text;
    }
    /**
     * @returns The setting component.
     */
    get setting() {
        return this._setting;
    }
    get settingsTextElem() {
        if (!this._settingsTextElem) {
            this._settingsTextElem = document.createElement('div');
            this._settingsTextElem.innerText = this.setting.label;
            this._settingsTextElem.title = this.setting.description;
        }
        return this._settingsTextElem;
    }
    get textbox() {
        if (!this._textbox) {
            this._textbox = document.createElement('input');
            this._textbox.classList.add('form-control');
            this._textbox.type = 'textbox';
        }
        return this._textbox;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            // create root div with "setting" css class
            this._rootElement = document.createElement('div');
            this._rootElement.id = this.setting.id;
            this._rootElement.classList.add('setting');
            // create div element to contain our setting's text
            this._rootElement.appendChild(this.settingsTextElem);
            // create label element to wrap out input type
            const wrapperLabel = document.createElement('label');
            this._rootElement.appendChild(wrapperLabel);
            // create input type=checkbox
            this.textbox.title = this.setting.description;
            wrapperLabel.appendChild(this.textbox);
            // setup on change from checkbox
            this.textbox.addEventListener('input', (event) => {
                if (this.setting.text !== this.textbox.value) {
                    this.setting.text = this.textbox.value;
                    this.setting.updateURLParams();
                }
                event.stopPropagation();
            });
            // Block keypress/up/down propogation from text field typing going to UE
            this.textbox.addEventListener('keypress', (event) => {
                event.stopPropagation();
            });
            this.textbox.addEventListener('keyup', (event) => {
                event.stopPropagation();
            });
            this.textbox.addEventListener('keydown', (event) => {
                event.stopPropagation();
            });
        }
        return this._rootElement;
    }
    /**
     * Update the setting's stored value.
     * @param inValue - The new value for the setting.
     */
    set text(inValue) {
        this.textbox.value = inValue;
    }
    /**
     * Get value
     */
    get text() {
        return this.textbox.value;
    }
    /**
     * Set the label text for the setting.
     * @param label - setting label.
     */
    set label(inLabel) {
        this.settingsTextElem.innerText = inLabel;
    }
    /**
     * Get label
     */
    get label() {
        return this.settingsTextElem.innerText;
    }
    disable() {
        this.textbox.disabled = true;
    }
    enable() {
        this.textbox.disabled = false;
    }
}
//# sourceMappingURL=SettingUIText.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/AFKOverlay.js":
/*!*******************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/AFKOverlay.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AFKOverlay: () => (/* binding */ AFKOverlay)
/* harmony export */ });
/* harmony import */ var _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ActionOverlay */ "../../ui-library/dist/esm/Overlay/ActionOverlay.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Show an overlay for when the session is unattended, it begins a countdown timer, which when elapsed will disconnect the stream.
 */
class AFKOverlay extends _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__.ActionOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const afkOverlayHtml = document.createElement('div');
        afkOverlayHtml.id = 'afkOverlay';
        afkOverlayHtml.className = 'clickableState';
        return afkOverlayHtml;
    }
    /**
     * @returns The created content element of this overlay, which contain some text for an afk count down.
     */
    static createContentElement() {
        const afkOverlayHtmlInner = document.createElement('div');
        afkOverlayHtmlInner.id = 'afkOverlayInner';
        afkOverlayHtmlInner.innerHTML =
            '<center>No activity detected<br>Disconnecting in <span id="afkCountDownNumber"></span> seconds<br>Click to continue<br></center>';
        return afkOverlayHtmlInner;
    }
    /**
     * Construct an Afk overlay
     * @param parentElement - the element this overlay will be inserted into
     */
    constructor(rootDiv) {
        super(rootDiv, AFKOverlay.createRootElement(), AFKOverlay.createContentElement());
        this.rootElement.addEventListener('click', () => {
            this.activate();
        });
    }
    /**
     * Update the count down spans number for the overlay
     * @param countdown - the count down number to be inserted into the span for updating
     */
    updateCountdown(countdown) {
        this.textElement.innerHTML = `<center>No activity detected<br>Disconnecting in <span id="afkCountDownNumber">${countdown}</span> seconds<br>Click to continue<br></center>`;
    }
}
//# sourceMappingURL=AFKOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/ActionOverlay.js":
/*!**********************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/ActionOverlay.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActionOverlay: () => (/* binding */ ActionOverlay)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _BaseOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseOverlay */ "../../ui-library/dist/esm/Overlay/BaseOverlay.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * Class for the base action overlay structure
 */
class ActionOverlay extends _BaseOverlay__WEBPACK_IMPORTED_MODULE_0__.OverlayBase {
    /**
     * Construct an action overlay
     * @param rootDiv - the root element this overlay will be inserted into
     * @param rootElement - the root element that is the overlay
     * @param contentElement - an element that contains text for the action overlay
     */
    constructor(rootDiv, rootElement, contentElement) {
        super(rootDiv, rootElement, contentElement);
        this.onActionCallback = () => {
            /* do nothing */ _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Did you forget to set the onAction callback in your overlay?');
        };
    }
    /**
     * Update the text overlays inner text
     * @param text - the update text to be inserted into the overlay
     */
    update(text) {
        if (text != null || text != undefined) {
            this.textElement.innerHTML = text;
        }
    }
    /**
     * Set a method as an event emitter callback
     * @param callBack - the method that is to be called when the event is emitted
     */
    onAction(callBack) {
        this.onActionCallback = callBack;
    }
    /**
     * Activate an event that is attached to the event emitter
     */
    activate() {
        this.onActionCallback();
    }
}
//# sourceMappingURL=ActionOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/BaseOverlay.js":
/*!********************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/BaseOverlay.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OverlayBase: () => (/* binding */ OverlayBase)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Class for the base overlay structure
 */
class OverlayBase {
    /**
     * Construct an overlay
     * @param rootDiv - the root element this overlay will be inserted into
     * @param rootElement - the root element that is the overlay
     */
    constructor(rootDiv, rootElement, textElement) {
        this.rootDiv = rootDiv;
        this.rootElement = rootElement;
        this.textElement = textElement;
        this.rootElement.appendChild(this.textElement);
        this.hide();
        this.rootDiv.appendChild(this.rootElement);
    }
    /**
     * Show the overlay
     */
    show() {
        this.rootElement.classList.remove('hiddenState');
    }
    /**
     * Hide the overlay
     */
    hide() {
        this.rootElement.classList.add('hiddenState');
    }
}
//# sourceMappingURL=BaseOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/ConnectOverlay.js":
/*!***********************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/ConnectOverlay.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConnectOverlay: () => (/* binding */ ConnectOverlay)
/* harmony export */ });
/* harmony import */ var _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ActionOverlay */ "../../ui-library/dist/esm/Overlay/ActionOverlay.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Overlay shown during connection, has a button that can be clicked to initiate a connection.
 */
class ConnectOverlay extends _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__.ActionOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const connectElem = document.createElement('div');
        connectElem.id = 'connectOverlay';
        connectElem.className = 'clickableState';
        return connectElem;
    }
    /**
     * @returns The created content element of this overlay, which contain whatever content this element contains, like text or a button.
     */
    static createContentElement() {
        const connectContentElem = document.createElement('div');
        connectContentElem.id = 'connectButton';
        connectContentElem.innerHTML = 'Click to start';
        return connectContentElem;
    }
    /**
     * Construct a connect overlay with a connection button.
     * @param parentElem - the parent element this overlay will be inserted into.
     */
    constructor(parentElem) {
        super(parentElem, ConnectOverlay.createRootElement(), ConnectOverlay.createContentElement());
        // add the new event listener
        this.rootElement.addEventListener('click', () => {
            this.activate();
        });
    }
}
//# sourceMappingURL=ConnectOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/DisconnectOverlay.js":
/*!**************************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/DisconnectOverlay.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DisconnectOverlay: () => (/* binding */ DisconnectOverlay)
/* harmony export */ });
/* harmony import */ var _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ActionOverlay */ "../../ui-library/dist/esm/Overlay/ActionOverlay.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Overlay shown during disconnection, has a reconnection element that can be clicked to reconnect.
 */
class DisconnectOverlay extends _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__.ActionOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const disconnectOverlayHtml = document.createElement('div');
        disconnectOverlayHtml.id = 'disconnectOverlay';
        disconnectOverlayHtml.className = 'clickableState';
        return disconnectOverlayHtml;
    }
    /**
     * @returns The created content element of this overlay, which contain whatever content this element contains, like text or a button.
     */
    static createContentElement() {
        // build the inner html container
        const disconnectOverlayHtmlContainer = document.createElement('div');
        disconnectOverlayHtmlContainer.id = 'disconnectButton';
        disconnectOverlayHtmlContainer.innerHTML = 'Click To Restart';
        return disconnectOverlayHtmlContainer;
    }
    /**
     * Construct a disconnect overlay with a retry connection icon.
     * @param parentElem - the parent element this overlay will be inserted into.
     */
    constructor(parentElem) {
        super(parentElem, DisconnectOverlay.createRootElement(), DisconnectOverlay.createContentElement());
        // add the new event listener
        this.rootElement.addEventListener('click', () => {
            this.activate();
        });
    }
}
//# sourceMappingURL=DisconnectOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/ErrorOverlay.js":
/*!*********************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/ErrorOverlay.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ErrorOverlay: () => (/* binding */ ErrorOverlay)
/* harmony export */ });
/* harmony import */ var _TextOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextOverlay */ "../../ui-library/dist/esm/Overlay/TextOverlay.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Generic overlay used to show textual error info to the user.
 */
class ErrorOverlay extends _TextOverlay__WEBPACK_IMPORTED_MODULE_0__.TextOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const errorOverlayHtml = document.createElement('div');
        errorOverlayHtml.id = 'errorOverlay';
        errorOverlayHtml.className = 'textDisplayState';
        return errorOverlayHtml;
    }
    /**
     * @returns The created content element of this overlay, which contain whatever content this element contains, like text or a button.
     */
    static createContentElement() {
        const errorOverlayHtmlInner = document.createElement('div');
        errorOverlayHtmlInner.id = 'errorOverlayInner';
        return errorOverlayHtmlInner;
    }
    /**
     * Construct a connect overlay with a connection button.
     * @param parentElem - the parent element this overlay will be inserted into.
     */
    constructor(parentElem) {
        super(parentElem, ErrorOverlay.createRootElement(), ErrorOverlay.createContentElement());
    }
}
//# sourceMappingURL=ErrorOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/InfoOverlay.js":
/*!********************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/InfoOverlay.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InfoOverlay: () => (/* binding */ InfoOverlay)
/* harmony export */ });
/* harmony import */ var _TextOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextOverlay */ "../../ui-library/dist/esm/Overlay/TextOverlay.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Generic overlay used to show textual info to the user.
 */
class InfoOverlay extends _TextOverlay__WEBPACK_IMPORTED_MODULE_0__.TextOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const infoOverlayHtml = document.createElement('div');
        infoOverlayHtml.id = 'infoOverlay';
        infoOverlayHtml.className = 'textDisplayState';
        return infoOverlayHtml;
    }
    /**
     * @returns The created content element of this overlay, which contain whatever content this element contains, like text or a button.
     */
    static createContentElement() {
        const infoOverlayHtmlInner = document.createElement('div');
        infoOverlayHtmlInner.id = 'messageOverlayInner';
        return infoOverlayHtmlInner;
    }
    /**
     * Construct a connect overlay with a connection button.
     * @param parentElem - the parent element this overlay will be inserted into.
     */
    constructor(parentElem) {
        super(parentElem, InfoOverlay.createRootElement(), InfoOverlay.createContentElement());
    }
}
//# sourceMappingURL=InfoOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/PlayOverlay.js":
/*!********************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/PlayOverlay.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PlayOverlay: () => (/* binding */ PlayOverlay)
/* harmony export */ });
/* harmony import */ var _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ActionOverlay */ "../../ui-library/dist/esm/Overlay/ActionOverlay.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Overlay shown when stream is ready to play.
 */
class PlayOverlay extends _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__.ActionOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const playElem = document.createElement('div');
        playElem.id = 'playOverlay';
        playElem.className = 'clickableState';
        return playElem;
    }
    /**
     * @returns The created content element of this overlay, which contain whatever content this element contains, like text or a button.
     */
    static createContentElement() {
        // todo: change this to an svg
        const playOverlayHtmlInner = document.createElement('img');
        playOverlayHtmlInner.id = 'playButton';
        playOverlayHtmlInner.src =
            'data:image/png;base64,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';
        playOverlayHtmlInner.alt = 'Start Streaming';
        return playOverlayHtmlInner;
    }
    /**
     * Construct a connect overlay with a connection button.
     * @param parentElem - the parent element this overlay will be inserted into.
     */
    constructor(parentElem) {
        super(parentElem, PlayOverlay.createRootElement(), PlayOverlay.createContentElement());
        // add the new event listener
        this.rootElement.addEventListener('click', () => {
            this.activate();
        });
    }
}
//# sourceMappingURL=PlayOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Overlay/TextOverlay.js":
/*!********************************************************!*\
  !*** ../../ui-library/dist/esm/Overlay/TextOverlay.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextOverlay: () => (/* binding */ TextOverlay)
/* harmony export */ });
/* harmony import */ var _BaseOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseOverlay */ "../../ui-library/dist/esm/Overlay/BaseOverlay.js");
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Class for the text overlay base
 */
class TextOverlay extends _BaseOverlay__WEBPACK_IMPORTED_MODULE_0__.OverlayBase {
    /**
     * Construct a text overlay
     * @param rootDiv - the root element this overlay will be inserted into
     * @param rootElement - the root element that is the overlay
     * @param textElement - an element that contains text for the action overlay
     */
    constructor(rootDiv, rootElement, textElement) {
        super(rootDiv, rootElement, textElement);
    }
    /**
     * Update the text overlays inner text
     * @param text - the update text to be inserted into the overlay
     */
    update(text) {
        if (text != null || text != undefined) {
            this.textElement.innerHTML = text;
        }
    }
}
//# sourceMappingURL=TextOverlay.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Styles/PixelStreamingApplicationStyles.js":
/*!***************************************************************************!*\
  !*** ../../ui-library/dist/esm/Styles/PixelStreamingApplicationStyles.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PixelStreamingApplicationStyle: () => (/* binding */ PixelStreamingApplicationStyle)
/* harmony export */ });
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jss */ "../../../node_modules/jss/dist/jss.esm.js");
/* harmony import */ var jss_plugin_global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jss-plugin-global */ "../../../node_modules/jss-plugin-global/dist/jss-plugin-global.esm.js");
/* harmony import */ var jss_plugin_camel_case__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jss-plugin-camel-case */ "../../../node_modules/jss-plugin-camel-case/dist/jss-plugin-camel-case.esm.js");
/* Copyright Epic Games, Inc. All Rights Reserved. */



class PixelStreamingApplicationStyle {
    constructor(options) {
        this.defaultLightModePalette = {
            '--color0': '#e2e0dd80',
            '--color1': '#FFFFFF',
            '--color2': '#000000',
            '--color3': '#0585fe',
            '--color4': '#35b350',
            '--color5': '#ffab00',
            '--color6': '#e1e2dd',
            '--color7': '#c3c4bf'
        };
        this.defaultDarkModePalette = {
            '--color0': '#1d1f22e0',
            '--color1': '#000000',
            '--color2': '#FFFFFF',
            '--color3': '#0585fe',
            '--color4': '#35b350',
            '--color5': '#ffab00',
            '--color6': '#1e1d22',
            '--color7': '#3c3b40'
        };
        this.defaultStyles = {
            ':root': {
                '--color0': '#1d1f22e0',
                '--color1': '#000000',
                '--color2': '#FFFFFF',
                '--color3': '#0585fe',
                '--color4': '#35b350',
                '--color5': '#ffab00',
                '--color6': '#1e1d22',
                '--color7': '#3c3b40',
                '--color8': '#41008c',
                '--color9': '#3e0070',
                '--color10': '#2e0052',
                '--color11': 'rgba(65,0,139,1)'
            },
            '.noselect': {
                userSelect: 'none'
            },
            '#playerUI': {
                width: '100%',
                height: '100%',
                position: 'relative'
            },
            '#videoElementParent': {
                width: '100%',
                height: '100%',
                position: 'absolute',
                backgroundColor: 'var(--color1)'
            },
            '#uiFeatures': {
                width: '100%',
                height: '100%',
                zIndex: '30',
                position: 'relative',
                color: 'var(--color2)',
                pointerEvents: 'none',
                overflow: 'hidden'
            },
            '.UiTool .tooltiptext': {
                visibility: 'hidden',
                width: 'auto',
                color: 'var(--color2)',
                textAlign: 'center',
                borderRadius: '15px',
                padding: '0px 10px',
                fontFamily: "'Montserrat', sans-serif",
                fontSize: '0.75rem',
                letterSpacing: '0.75px',
                position: 'absolute',
                top: '0',
                transform: 'translateY(25%)',
                left: '125%',
                zIndex: '20'
            },
            '.UiTool:hover .tooltiptext': {
                visibility: 'visible',
                backgroundColor: 'var(--color7)'
            },
            '#connection .tooltiptext': {
                top: '125%',
                transform: 'translateX(-25%)',
                left: '0',
                zIndex: '20',
                padding: '5px 10px'
            },
            '#connection': {
                position: 'absolute',
                bottom: '8%',
                left: '5%',
                fontFamily: "'Michroma', sans-serif",
                height: '3rem',
                width: '3rem',
                pointerEvents: 'all'
            },
            '#settings-panel .tooltiptext': {
                display: 'block',
                top: '125%',
                transform: 'translateX(-50%)',
                left: '0',
                zIndex: '20',
                padding: '5px 10px',
                border: '3px solid var(--color3)',
                width: 'max-content',
                fallbacks: [
                    {
                        width: 'max-content'
                    },
                    {
                        border: '3px solid var(--color3)'
                    },
                    {
                        padding: '5px 10px'
                    },
                    {
                        zIndex: '20'
                    },
                    {
                        left: '0'
                    },
                    {
                        transform: 'translateX(-50%)'
                    },
                    {
                        top: '125%'
                    },
                    {
                        display: 'block'
                    }
                ]
            },
            '#controls': {
                position: 'absolute',
                top: '3%',
                left: '2%',
                fontFamily: "'Michroma', sans-serif",
                pointerEvents: 'all',
                display: 'block'
            },
            '#controls>*': {
                marginBottom: '0.5rem',
                borderRadius: '50%',
                display: 'block',
                height: '2rem',
                lineHeight: '1.75rem',
                padding: '0.5rem'
            },
            '#controls #additionalinfo': {
                textAlign: 'center',
                fontFamily: "'Montserrat', sans-serif"
            },
            '#fullscreen-btn': {
                padding: '0.6rem !important'
            },
            '#minimizeIcon': {
                display: 'none'
            },
            '#settingsBtn, #statsBtn': {
                cursor: 'pointer'
            },
            '#uiFeatures button': {
                backgroundColor: 'var(--color7)',
                border: '1px solid var(--color7)',
                color: 'var(--color2)',
                position: 'relative',
                width: '3rem',
                height: '3rem',
                padding: '0.5rem',
                textAlign: 'center'
            },
            '#uiFeatures button:hover': {
                backgroundColor: 'var(--color3)',
                border: '3px solid var(--color3)',
                transition: '0.25s ease',
                paddingLeft: '0.55rem',
                paddingTop: '0.55rem'
            },
            '#uiFeatures button:active': {
                border: '3px solid var(--color3)',
                backgroundColor: 'var(--color7)',
                paddingLeft: '0.55rem',
                paddingTop: '0.55rem'
            },
            '.btn-flat': {
                backgroundColor: 'transparent',
                color: 'var(--color2)',
                fontFamily: "'Montserrat'",
                fontWeight: 'bold',
                border: '3px solid var(--color3)',
                borderRadius: '1rem',
                fontSize: '0.75rem',
                paddingLeft: '0.5rem',
                paddingRight: '0.5rem',
                cursor: 'pointer',
                textAlign: 'center'
            },
            '.btn-flat:hover': {
                backgroundColor: 'var(--color3)',
                transition: 'ease 0.3s'
            },
            '.btn-flat:disabled': {
                background: 'var(--color7)',
                borderColor: 'var(--color3)',
                color: 'var(--color3)',
                cursor: 'default'
            },
            '.btn-flat:active': {
                backgroundColor: 'transparent'
            },
            '.btn-flat:focus': {
                outline: 'none'
            },
            '#uiFeatures img': {
                width: '100%',
                height: '100%'
            },
            '.panel-wrap': {
                position: 'absolute',
                top: '0',
                bottom: '0',
                right: '0',
                height: '100%',
                minWidth: '20vw',
                maxWidth: '90vw',
                transform: 'translateX(100%)',
                transition: '.3s ease-out',
                pointerEvents: 'all',
                overflowY: 'auto',
                overflowX: 'hidden',
                backgroundColor: 'var(--color0)'
            },
            '.panel-wrap-visible': {
                transform: 'translateX(0%)'
            },
            '.panel': {
                overflowY: 'auto',
                padding: '1em'
            },
            '#settingsHeading, #statsHeading': {
                display: 'inline-block',
                fontSize: '2em',
                marginBlockStart: '0.67em',
                marginBlockEnd: '0.67em',
                marginInlineStart: '0px',
                marginInlineEnd: '0px',
                position: 'relative',
                padding: '0 0 0 2rem'
            },
            '#settingsClose, #statsClose': {
                margin: '0.5rem',
                paddingTop: '0.5rem',
                paddingBottom: '0.5rem',
                paddingRight: '0.5rem',
                fontSize: '2em',
                float: 'right'
            },
            '#settingsClose:after, #statsClose:after': {
                paddingLeft: '0.5rem',
                display: 'inline-block',
                content: '"\\00d7"'
            },
            '#settingsClose:hover, #statsClose:hover': {
                color: 'var(--color3)',
                transition: 'ease 0.3s'
            },
            '#settingsContent, #statsContent': {
                marginLeft: '2rem',
                marginRight: '2rem'
            },
            '.setting': {
                display: 'flex',
                flexDirection: 'row',
                justifyContent: 'space-between',
                padding: '0.15rem 10px 0.15rem 10px'
            },
            '.settings-text': {
                color: 'var(--color2)',
                verticalAlign: 'middle',
                fontWeight: 'normal'
            },
            '.settings-option': {
                width: '100%',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap'
            },
            '#connectOverlay, #playOverlay, #infoOverlay, #errorOverlay, #afkOverlay, #disconnectOverlay': {
                zIndex: '30',
                position: 'absolute',
                color: 'var(--color2)',
                fontSize: '1.8em',
                width: '100%',
                height: '100%',
                backgroundColor: 'var(--color1)',
                alignItems: 'center',
                justifyContent: 'center',
                textTransform: 'uppercase'
            },
            '.clickableState': {
                alignItems: 'center',
                justifyContent: 'center',
                display: 'flex',
                cursor: 'pointer'
            },
            '.textDisplayState': {
                display: 'flex'
            },
            '.hiddenState': {
                display: 'none'
            },
            '#playButton, #connectButton': {
                display: 'inline-block',
                height: 'auto',
                zIndex: '30'
            },
            'img#playButton': {
                maxWidth: '241px',
                width: '10%'
            },
            '#uiInteraction': {
                position: 'fixed'
            },
            '#UIInteractionButtonBoundary': {
                padding: '2px'
            },
            '#UIInteractionButton': {
                cursor: 'pointer'
            },
            '.btn-overlay': {
                verticalAlign: 'middle',
                display: 'inline-block'
            },
            '.tgl-switch': {
                verticalAlign: 'middle',
                display: 'inline-block'
            },
            '.tgl-switch .tgl': {
                display: 'none'
            },
            '.tgl, .tgl:after, .tgl:before, .tgl *, .tgl *:after, .tgl *:before, .tgl+.tgl-slider': {
                '-webkit-box-sizing': 'border-box',
                boxSizing: 'border-box'
            },
            '.tgl::-moz-selection, .tgl:after::-moz-selection, .tgl:before::-moz-selection, .tgl *::-moz-selection, .tgl *:after::-moz-selection, .tgl *:before::-moz-selection, .tgl+.tgl-slider::-moz-selection': {
                background: 'none'
            },
            '.tgl::selection, .tgl:after::selection, .tgl:before::selection, .tgl *::selection, .tgl *:after::selection, .tgl *:before::selection, .tgl+.tgl-slider::selection': {
                background: 'none'
            },
            '.tgl-slider': {},
            '.tgl+.tgl-slider': {
                outline: '0',
                display: 'block',
                width: '40px',
                height: '18px',
                position: 'relative',
                cursor: 'pointer',
                userSelect: 'none'
            },
            '.tgl+.tgl-slider:after, .tgl+.tgl-slider:before': {
                position: 'relative',
                display: 'block',
                content: '""',
                width: '50%',
                height: '100%'
            },
            '.tgl+.tgl-slider:after': {
                left: '0'
            },
            '.tgl+.tgl-slider:before': {
                display: 'none'
            },
            '.tgl-flat+.tgl-slider': {
                padding: '2px',
                '-webkit-transition': 'all .2s ease',
                transition: 'all .2s ease',
                background: 'var(--color6)',
                border: '3px solid var(--color7)',
                borderRadius: '2em'
            },
            '.tgl-flat+.tgl-slider:after': {
                '-webkit-transition': 'all .2s ease',
                transition: 'all .2s ease',
                background: 'var(--color7)',
                content: '""',
                borderRadius: '1em'
            },
            '.tgl-flat:checked+.tgl-slider': {
                border: '3px solid var(--color3)'
            },
            '.tgl-flat:checked+.tgl-slider:after': {
                left: '50%',
                background: 'var(--color3)'
            },
            '.btn-apply': {
                display: 'block !important',
                marginLeft: 'auto',
                marginRight: 'auto',
                width: '40%'
            },
            '.form-control': {
                backgroundColor: 'var(--color7)',
                border: '2px solid var(--color7)',
                borderRadius: '4px',
                color: 'var(--color2)',
                textAlign: 'right',
                fontFamily: 'inherit'
            },
            '.form-control:hover': {
                borderColor: 'var(--color7)'
            },
            '.form-group': {
                paddingTop: '4px',
                display: 'grid',
                gridTemplateColumns: '80% 20%',
                rowGap: '4px',
                paddingRight: '10px',
                paddingLeft: '10px'
            },
            '.form-group label': {
                verticalAlign: 'middle',
                fontWeight: 'normal'
            },
            '.settingsContainer': {
                display: 'flex',
                flexDirection: 'column',
                borderBottom: '1px solid var(--color7)',
                paddingTop: '10px',
                paddingBottom: '10px'
            },
            '.settingsContainer> :first-child': {
                marginTop: '4px',
                marginBottom: '4px',
                fontWeight: 'bold',
                justifyContent: 'space-between',
                display: 'flex',
                flexDirection: 'row',
                alignItems: 'baseline'
            },
            '.collapse': {
                paddingLeft: '5%'
            },
            '#streamTools': {
                borderBottomRightRadius: '5px',
                borderBottomLeftRadius: '5px',
                userSelect: 'none',
                position: 'absolute',
                top: '0',
                right: '2%',
                zIndex: '100',
                border: '4px solid var(--colour8)',
                borderTopWidth: '0px'
            },
            '.settingsHeader': {
                fontStyle: 'italic'
            },
            '#streamToolsHeader': {
                display: 'flex',
                flexDirection: 'row',
                justifyContent: 'space-between',
                borderBottom: '1px solid var(--colour8)',
                backgroundColor: 'var(--color7)'
            },
            '.streamTools': {
                backgroundColor: 'var(--color2)',
                fontFamily: 'var(--buttonFont)',
                fontWeight: 'lighter',
                color: 'var(--color7)'
            },
            '.streamTools-shown>#streamToolsSettings, .streamTools-shown>#streamToolsStats': {
                display: 'block'
            },
            '#streamToolsToggle': {
                width: '100%'
            },
            '#qualityStatus': {
                fontSize: '37px',
                paddingRight: '4px'
            },
            '.svgIcon': {
                fill: 'var(--color2)'
            },
            '.modal': {
                minWidth: '100vw',
                minHeight: '100vh',
                left: '0',
                top: '0',
                position: 'fixed',
                display: 'flex',
                flexDirection: 'column',
                justifyContent: 'center',
                alignItems: 'center',
                color: 'var(--color2)'
            },
            '.innerModal': {
                position: 'relative',
                width: '500px',
                height: '300px',
                backgroundColor: 'var(--color0)',
                display: 'flex',
                flexDirection: 'column',
                justifyContent: 'space-between',
                alignItems: 'center',
                borderRadius: '0.75em'
            },
            '.modalBtnContainer': {
                display: 'flex',
                flexDirection: 'row',
                justifyContent: 'space-around',
                width: '100%',
                paddingTop: '1em',
                paddingBottom: '1em'
            },
            '.modalTextArea': {
                textAlign: 'left',
                width: '95%',
                height: '100%',
                resize: 'none',
                fontSize: '1rem',
                border: '1px solid var(--color2)'
            },
            '.modalTextArea:focus-visible': {
                outline: 'none !important',
                border: '1px solid var(--color3)'
            },
            '.modal .btn-flat': {
                fontSize: '1.0rem'
            }
        };
        const { customStyles, lightModePalette, darkModePalette, jssInsertionPoint } = options !== null && options !== void 0 ? options : {};
        // One time setup with default plugins and settings.
        const jssOptions = {
            // JSS has many interesting plugins we may wish to turn on
            //plugins: [functions(), template(), global(), extend(), nested(), compose(), camelCase(), defaultUnit(options.defaultUnit), expand(), vendorPrefixer(), propsSort()]
            plugins: [(0,jss_plugin_global__WEBPACK_IMPORTED_MODULE_0__["default"])(), (0,jss_plugin_camel_case__WEBPACK_IMPORTED_MODULE_1__["default"])()],
            insertionPoint: jssInsertionPoint
        };
        jss__WEBPACK_IMPORTED_MODULE_2__["default"].setup(jssOptions);
        this.customStyles = customStyles;
        this.lightModePalette = lightModePalette !== null && lightModePalette !== void 0 ? lightModePalette : this.defaultLightModePalette;
        this.darkModePalette = darkModePalette !== null && darkModePalette !== void 0 ? darkModePalette : this.defaultDarkModePalette;
    }
    applyStyleSheet() {
        // Todo: refactor codebase to use jss at a component level, classes can be grabbed like so:
        //const {pixelStreamingClasses} = jss.createStyleSheet(styles).attach();
        // attach generated style sheet to page
        jss__WEBPACK_IMPORTED_MODULE_2__["default"].createStyleSheet({
            '@global': Object.assign(Object.assign({}, this.defaultStyles), this.customStyles)
        }).attach();
    }
    applyPalette(palette) {
        const rootElement = document.querySelector(':root');
        rootElement.style.setProperty('--color0', palette['--color0']);
        rootElement.style.setProperty('--color1', palette['--color1']);
        rootElement.style.setProperty('--color2', palette['--color2']);
        rootElement.style.setProperty('--color3', palette['--color3']);
        rootElement.style.setProperty('--color4', palette['--color4']);
        rootElement.style.setProperty('--color5', palette['--color5']);
        rootElement.style.setProperty('--color6', palette['--color6']);
        rootElement.style.setProperty('--color7', palette['--color7']);
    }
    /**
     * Update the players color variables
     * @param isLightMode - should we use a light or dark color scheme
     */
    setColorMode(isLightMode) {
        if (isLightMode) {
            this.applyPalette(this.lightModePalette);
        }
        else {
            this.applyPalette(this.darkModePalette);
        }
    }
}
//# sourceMappingURL=PixelStreamingApplicationStyles.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/Controls.js":
/*!************************************************!*\
  !*** ../../ui-library/dist/esm/UI/Controls.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Controls: () => (/* binding */ Controls)
/* harmony export */ });
/* harmony import */ var _FullscreenIcon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FullscreenIcon */ "../../ui-library/dist/esm/UI/FullscreenIcon.js");
/* harmony import */ var _SettingsIcon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SettingsIcon */ "../../ui-library/dist/esm/UI/SettingsIcon.js");
/* harmony import */ var _StatsIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StatsIcon */ "../../ui-library/dist/esm/UI/StatsIcon.js");
/* harmony import */ var _XRIcon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./XRIcon */ "../../ui-library/dist/esm/UI/XRIcon.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/WebXR/WebXRController.js");
/* harmony import */ var _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../UI/UIConfigurationTypes */ "../../ui-library/dist/esm/UI/UIConfigurationTypes.js");
// Copyright Epic Games, Inc. All Rights Reserved.






// If there isn't a type provided, default behaviour is to create the element.
function shouldCreateButton(type) {
    return type == undefined ? true : type.creationMode === _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.UIElementCreationMode.CreateDefaultElement;
}
/**
 * Element containing various controls like stats, settings, fullscreen.
 */
class Controls {
    /**
     * Construct the controls
     */
    constructor(config) {
        this.config = config;
        if (!config || shouldCreateButton(config.statsButtonType)) {
            this.statsIcon = new _StatsIcon__WEBPACK_IMPORTED_MODULE_1__.StatsIcon();
        }
        if (!config || shouldCreateButton(config.settingsButtonType)) {
            this.settingsIcon = new _SettingsIcon__WEBPACK_IMPORTED_MODULE_2__.SettingsIcon();
        }
        if (!config || shouldCreateButton(config.fullscreenButtonType)) {
            this.fullscreenIcon = new _FullscreenIcon__WEBPACK_IMPORTED_MODULE_3__.FullScreenIcon();
        }
        if (!config || shouldCreateButton(config.xrIconType)) {
            this.xrIcon = new _XRIcon__WEBPACK_IMPORTED_MODULE_4__.XRIcon();
        }
    }
    /**
     * Get the element containing the controls.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('div');
            this._rootElement.id = 'controls';
            if (this.fullscreenIcon) {
                this._rootElement.appendChild(this.fullscreenIcon.rootElement);
            }
            if (this.settingsIcon) {
                this._rootElement.appendChild(this.settingsIcon.rootElement);
            }
            if (this.statsIcon) {
                this._rootElement.appendChild(this.statsIcon.rootElement);
            }
            if (this.xrIcon) {
                void _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.WebXRController.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        this._rootElement.appendChild(this.xrIcon.rootElement);
                    }
                });
            }
            document.addEventListener('fullscreenchange', this.handleFullscreenChange.bind(this));
        }
        return this._rootElement;
    }
    handleFullscreenChange() {
        var _a;
        const isInFullscreen = !!document.fullscreenElement;
        if (isInFullscreen && ((_a = this.config) === null || _a === void 0 ? void 0 : _a.hideControlsInFullscreen)) {
            this._rootElement.style.visibility = 'hidden';
        }
        else {
            this._rootElement.style.visibility = 'visible';
        }
    }
}
//# sourceMappingURL=Controls.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/DataChannelLatencyTest.js":
/*!**************************************************************!*\
  !*** ../../ui-library/dist/esm/UI/DataChannelLatencyTest.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataChannelLatencyTest: () => (/* binding */ DataChannelLatencyTest)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UIConfigurationTypes */ "../../ui-library/dist/esm/UI/UIConfigurationTypes.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * DataChannel Latency test UI elements and results handling.
 */
class DataChannelLatencyTest {
    /**
     * Get the button containing the stats icon.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('section');
            this._rootElement.classList.add('settingsContainer');
            // make heading
            const heading = document.createElement('div');
            heading.id = 'dataChannelLatencyTestHeader';
            heading.classList.add('settings-text');
            heading.classList.add('settingsHeader');
            this._rootElement.appendChild(heading);
            const headingText = document.createElement('div');
            headingText.innerHTML = _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.StatsSections.DataChannelLatencyTest;
            heading.appendChild(headingText);
            heading.appendChild(this.latencyTestButton);
            // make test results element
            const resultsParentElem = document.createElement('div');
            resultsParentElem.id = 'dataChannelLatencyTestContainer';
            resultsParentElem.classList.add('d-none');
            this._rootElement.appendChild(resultsParentElem);
            resultsParentElem.appendChild(this.latencyTestResultsElement);
        }
        return this._rootElement;
    }
    get latencyTestResultsElement() {
        if (!this._latencyTestResultsElement) {
            this._latencyTestResultsElement = document.createElement('div');
            this._latencyTestResultsElement.id = 'dataChannelLatencyStatsResults';
            this._latencyTestResultsElement.classList.add('StatsResult');
        }
        return this._latencyTestResultsElement;
    }
    get latencyTestButton() {
        if (!this._latencyTestButton) {
            this._latencyTestButton = document.createElement('input');
            this._latencyTestButton.type = 'button';
            this._latencyTestButton.value = 'Run Test';
            this._latencyTestButton.id = 'btn-start-data-channel-latency-test';
            this._latencyTestButton.classList.add('streamTools-button');
            this._latencyTestButton.classList.add('btn-flat');
        }
        return this._latencyTestButton;
    }
    /**
     * Populate the UI based on the latency test's results.
     * @param result - The latency test results.
     */
    handleTestResult(result) {
        _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(JSON.stringify(result));
        /**
         * Check we have results, NaN would mean that UE version we talk to doesn't support our test
         */
        if (isNaN(result.dataChannelRtt)) {
            this.latencyTestResultsElement.innerHTML = '<div>Not supported</div>';
            return;
        }
        let latencyStatsInnerHTML = '';
        latencyStatsInnerHTML += '<div>Data channel RTT (ms): ' + result.dataChannelRtt + '</div>';
        /**
         * Separate path time discovery works only when UE and Player clocks have been synchronized.
         */
        if (result.playerToStreamerTime >= 0 && result.streamerToPlayerTime >= 0) {
            latencyStatsInnerHTML +=
                '<div>Player to Streamer path (ms): ' + result.playerToStreamerTime + '</div>';
            latencyStatsInnerHTML +=
                '<div>Streamer to Player path (ms): ' + result.streamerToPlayerTime + '</div>';
        }
        this.latencyTestResultsElement.innerHTML = latencyStatsInnerHTML;
        //setup button to download the detailed results
        const downloadButton = document.createElement('input');
        downloadButton.type = 'button';
        downloadButton.value = 'Download';
        downloadButton.classList.add('streamTools-button');
        downloadButton.classList.add('btn-flat');
        downloadButton.onclick = () => {
            const file = new Blob([result.exportLatencyAsCSV()], { type: 'text/plain' });
            const a = document.createElement('a');
            const url = URL.createObjectURL(file);
            a.href = url;
            a.download = 'data_channel_latency_test_results.csv';
            document.body.appendChild(a);
            a.click();
            setTimeout(function () {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 0);
        };
        this.latencyTestResultsElement.appendChild(downloadButton);
    }
    handleTestStart() {
        this.latencyTestResultsElement.innerHTML = '<div>Test in progress</div>';
    }
}
//# sourceMappingURL=DataChannelLatencyTest.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/EditTextModal.js":
/*!*****************************************************!*\
  !*** ../../ui-library/dist/esm/UI/EditTextModal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EditConfirmedEvent: () => (/* binding */ EditConfirmedEvent),
/* harmony export */   EditTextModal: () => (/* binding */ EditTextModal)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
// Event fired when "Confirm" button is clicked
class EditConfirmedEvent extends CustomEvent {
    constructor(confirmedText) {
        super('editConfirmed', {
            detail: confirmedText,
            bubbles: true,
            cancelable: true
        });
        this.confirmedText = confirmedText;
    }
}
/**
 * A modal that is shown when a UE widget is touched on mobile.
 * or
 * A hidden (offscreen) input field that is shown on non-touch devices (e.g. Desktop)
 * when a UE widget is clicked. The hidden text field is used so non-latin character
 * input can be composed using IME assistance (which requires an input field).
 *
 * The reason this modal is required is that on mobile typing uses
 * an on-screen keyboard, which requires a valid input text area/input
 * to be focused to summon it. Therefore we show this modal which has
 * the contents of the UE widget, populate its text area with the contents
 * of the UE widget, then focus the text area to finally summon the native
 * on-screen keyboard.
 *
 * The modal also contains:
 * 1) A cancel button - this closes the modal
 * 2) A confirm button - this submits the edit back to the UE side
 */
class EditTextModal {
    constructor() {
        this._rootElement = this.rootElement;
        this._events = new EventTarget();
    }
    // Bind to this if you want to handle edit confirmed
    get events() {
        return this._events;
    }
    showModal(existingTextAreaContents) {
        if (existingTextAreaContents) {
            // Remove any null terminators from the string
            existingTextAreaContents = existingTextAreaContents.replace(/\0/g, '');
            this.textArea.value = existingTextAreaContents;
        }
        // Bring focus to the text area.
        // This will make the on-screen keyboard show if we are
        // a device that has a native on-screen keyboard.
        // If we are on a non-touch device this will give IME a valid
        // input field to work with.
        this.textArea.focus();
        // Put cursor to the end of the textarea
        this.textArea.selectionStart = this.textArea.value.length;
    }
    /**
     * Get the root element that contains either the modal (mobile) or hidden text input (desktop)
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('div');
            this._rootElement.classList.add('modal');
            this._rootElement.appendChild(this.innerModal);
        }
        return this._rootElement;
    }
    get innerModal() {
        if (!this._innerModal) {
            this._innerModal = document.createElement('div');
            this._innerModal.classList.add('innerModal');
            this._innerModal.appendChild(this.editTextHeading);
            this._innerModal.appendChild(this.textArea);
            this._innerModal.appendChild(this.modalBtnContainer);
        }
        return this._innerModal;
    }
    get editTextHeading() {
        if (!this._editTextHeading) {
            this._editTextHeading = document.createElement('h2');
            this._editTextHeading.innerText = 'Edit Text';
        }
        return this._editTextHeading;
    }
    get textArea() {
        if (!this._textArea) {
            this._textArea = document.createElement('textarea');
            this._textArea.classList.add('form-control');
            this._textArea.classList.add('modalTextArea');
            this._textArea.title = 'Edit Text Area';
            this._textArea.placeholder = 'UE text widget value here...';
            // When keyboard is typed into we want to ensure keys are not sent back to UE until we confirm.
            this.textArea.addEventListener('keypress', (event) => {
                event.stopPropagation();
            });
            this.textArea.addEventListener('keyup', (event) => {
                event.stopPropagation();
            });
            this.textArea.addEventListener('keydown', (event) => {
                event.stopPropagation();
            });
            this.textArea.addEventListener('compositionend', (event) => {
                event.stopPropagation();
            });
        }
        return this._textArea;
    }
    get modalBtnContainer() {
        if (!this._modalBtnContainer) {
            this._modalBtnContainer = document.createElement('div');
            this._modalBtnContainer.classList.add('modalBtnContainer');
            this._modalBtnContainer.appendChild(this.cancelBtn);
            this._modalBtnContainer.appendChild(this.confirmBtn);
        }
        return this._modalBtnContainer;
    }
    get cancelBtn() {
        if (!this._cancelBtn) {
            this._cancelBtn = document.createElement('button');
            this._cancelBtn.classList.add('btn-flat');
            this._cancelBtn.innerText = 'Cancel';
            // When cancel is clicked, remove this modal from the DOM
            this._cancelBtn.addEventListener('click', (event) => {
                this.rootElement.remove();
                // Ensure the click/tap does not go back to UE
                event.stopPropagation();
            });
        }
        return this._cancelBtn;
    }
    get confirmBtn() {
        if (!this._confirmBtn) {
            this._confirmBtn = document.createElement('button');
            this._confirmBtn.classList.add('btn-flat');
            this._confirmBtn.innerText = 'Confirm';
            // When confirm is clicked, remove from DOM and send the contents of textarea to UE
            this._confirmBtn.addEventListener('click', (event) => {
                this.events.dispatchEvent(new EditConfirmedEvent(this.textArea.value));
                this.rootElement.remove();
                // Ensure the click/tap does not go back to UE
                event.stopPropagation();
            });
        }
        return this._confirmBtn;
    }
}
//# sourceMappingURL=EditTextModal.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/FullscreenIcon.js":
/*!******************************************************!*\
  !*** ../../ui-library/dist/esm/UI/FullscreenIcon.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FullScreenIcon: () => (/* binding */ FullScreenIcon),
/* harmony export */   FullScreenIconBase: () => (/* binding */ FullScreenIconBase),
/* harmony export */   FullScreenIconExternal: () => (/* binding */ FullScreenIconExternal)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Base class for an element (i.e. button) that, when clicked, will toggle fullscreen of a given element.
 * Can be initialized with any HTMLElement, if it is set as rootElement in the constructor.
 */
class FullScreenIconBase {
    get rootElement() {
        return this._rootElement;
    }
    set rootElement(element) {
        element.onclick = () => this.toggleFullscreen();
        this._rootElement = element;
    }
    constructor() {
        this.isFullscreen = false;
        // set up the full screen events
        document.addEventListener('webkitfullscreenchange', () => this.onFullscreenChange(), false);
        document.addEventListener('mozfullscreenchange', () => this.onFullscreenChange(), false);
        document.addEventListener('fullscreenchange', () => this.onFullscreenChange(), false);
        document.addEventListener('MSFullscreenChange', () => this.onFullscreenChange(), false);
    }
    /**
     * Makes the document or fullscreenElement fullscreen.
     */
    toggleFullscreen() {
        // if already full screen; exit
        // else go fullscreen
        if (document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement) {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
            else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            }
            else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            }
            else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }
        else {
            const element = this.fullscreenElement;
            if (!element) {
                return;
            }
            if (element.requestFullscreen) {
                element.requestFullscreen();
            }
            else if (element.mozRequestFullscreen) {
                element.mozRequestFullscreen();
            }
            else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen();
            }
            else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            }
            else if (element.webkitEnterFullscreen) {
                element.webkitEnterFullscreen(); //for iphone this code worked
            }
        }
        this.onFullscreenChange();
    }
    /**
     * Handles the fullscreen button on change
     */
    onFullscreenChange() {
        this.isFullscreen =
            document.webkitIsFullScreen ||
                document.mozFullScreen ||
                (document.msFullscreenElement && document.msFullscreenElement !== null) ||
                (document.fullscreenElement && document.fullscreenElement !== null);
    }
}
/**
 * An implementation of FullScreenIconBase that uses an externally
 * provided HTMLElement for toggling full screen.
 */
class FullScreenIconExternal extends FullScreenIconBase {
    constructor(externalButton) {
        super();
        this.rootElement = externalButton;
    }
}
/**
 * The default fullscreen icon that contains a button and svgs for each state.
 */
class FullScreenIcon extends FullScreenIconBase {
    constructor() {
        super();
        const createdButton = document.createElement('button');
        createdButton.type = 'button';
        createdButton.classList.add('UiTool');
        createdButton.id = 'fullscreen-btn';
        createdButton.appendChild(this.maximizeIcon);
        createdButton.appendChild(this.minimizeIcon);
        createdButton.appendChild(this.tooltipText);
        this.rootElement = createdButton;
    }
    get tooltipText() {
        if (!this._tooltipText) {
            this._tooltipText = document.createElement('span');
            this._tooltipText.classList.add('tooltiptext');
            this._tooltipText.innerHTML = 'Fullscreen';
        }
        return this._tooltipText;
    }
    get maximizeIcon() {
        if (!this._maximizeIcon) {
            this._maximizeIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._maximizeIcon.setAttributeNS(null, 'id', 'maximizeIcon');
            this._maximizeIcon.setAttributeNS(null, 'x', '0px');
            this._maximizeIcon.setAttributeNS(null, 'y', '0px');
            this._maximizeIcon.setAttributeNS(null, 'viewBox', '0 0 384.97 384.97');
            // create svg group for the paths
            const svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svgGroup.classList.add('svgIcon');
            this._maximizeIcon.appendChild(svgGroup);
            // create paths for the icon itself, one for each corner
            const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path1.setAttributeNS(null, 'd', 'M384.97,12.03c0-6.713-5.317-12.03-12.03-12.03H264.847c-6.833,0-11.922,5.39-11.934,12.223c0,6.821,5.101,11.838,11.934,11.838h96.062l-0.193,96.519c0,6.833,5.197,12.03,12.03,12.03c6.833-0.012,12.03-5.197,12.03-12.03l0.193-108.369c0-0.036-0.012-0.06-0.012-0.084C384.958,12.09,384.97,12.066,384.97,12.03z');
            const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path2.setAttributeNS(null, 'd', 'M120.496,0H12.403c-0.036,0-0.06,0.012-0.096,0.012C12.283,0.012,12.247,0,12.223,0C5.51,0,0.192,5.317,0.192,12.03L0,120.399c0,6.833,5.39,11.934,12.223,11.934c6.821,0,11.838-5.101,11.838-11.934l0.192-96.339h96.242c6.833,0,12.03-5.197,12.03-12.03C132.514,5.197,127.317,0,120.496,0z');
            const path3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path3.setAttributeNS(null, 'd', 'M120.123,360.909H24.061v-96.242c0-6.833-5.197-12.03-12.03-12.03S0,257.833,0,264.667v108.092c0,0.036,0.012,0.06,0.012,0.084c0,0.036-0.012,0.06-0.012,0.096c0,6.713,5.317,12.03,12.03,12.03h108.092c6.833,0,11.922-5.39,11.934-12.223C132.057,365.926,126.956,360.909,120.123,360.909z');
            const path4 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path4.setAttributeNS(null, 'd', 'M372.747,252.913c-6.833,0-11.85,5.101-11.838,11.934v96.062h-96.242c-6.833,0-12.03,5.197-12.03,12.03s5.197,12.03,12.03,12.03h108.092c0.036,0,0.06-0.012,0.084-0.012c0.036-0.012,0.06,0.012,0.096,0.012c6.713,0,12.03-5.317,12.03-12.03V264.847C384.97,258.014,379.58,252.913,372.747,252.913z');
            svgGroup.appendChild(path1);
            svgGroup.appendChild(path2);
            svgGroup.appendChild(path3);
            svgGroup.appendChild(path4);
        }
        return this._maximizeIcon;
    }
    get minimizeIcon() {
        if (!this._minimizeIcon) {
            this._minimizeIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._minimizeIcon.setAttributeNS(null, 'id', 'minimizeIcon');
            this._minimizeIcon.setAttributeNS(null, 'x', '0px');
            this._minimizeIcon.setAttributeNS(null, 'y', '0px');
            this._minimizeIcon.setAttributeNS(null, 'viewBox', '0 0 385.331 385.331');
            // create svg group for the paths
            const svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svgGroup.classList.add('svgIcon');
            this._minimizeIcon.appendChild(svgGroup);
            // create paths for the icon itself, one for each corner
            const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path1.setAttributeNS(null, 'd', 'M264.943,156.665h108.273c6.833,0,11.934-5.39,11.934-12.211c0-6.833-5.101-11.85-11.934-11.838h-96.242V36.181c0-6.833-5.197-12.03-12.03-12.03s-12.03,5.197-12.03,12.03v108.273c0,0.036,0.012,0.06,0.012,0.084c0,0.036-0.012,0.06-0.012,0.096C252.913,151.347,258.23,156.677,264.943,156.665z');
            const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path2.setAttributeNS(null, 'd', 'M120.291,24.247c-6.821,0-11.838,5.113-11.838,11.934v96.242H12.03c-6.833,0-12.03,5.197-12.03,12.03c0,6.833,5.197,12.03,12.03,12.03h108.273c0.036,0,0.06-0.012,0.084-0.012c0.036,0,0.06,0.012,0.096,0.012c6.713,0,12.03-5.317,12.03-12.03V36.181C132.514,29.36,127.124,24.259,120.291,24.247z');
            const path3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path3.setAttributeNS(null, 'd', 'M120.387,228.666H12.115c-6.833,0.012-11.934,5.39-11.934,12.223c0,6.833,5.101,11.85,11.934,11.838h96.242v96.423c0,6.833,5.197,12.03,12.03,12.03c6.833,0,12.03-5.197,12.03-12.03V240.877c0-0.036-0.012-0.06-0.012-0.084c0-0.036,0.012-0.06,0.012-0.096C132.418,233.983,127.1,228.666,120.387,228.666z');
            const path4 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path4.setAttributeNS(null, 'd', 'M373.3,228.666H265.028c-0.036,0-0.06,0.012-0.084,0.012c-0.036,0-0.06-0.012-0.096-0.012c-6.713,0-12.03,5.317-12.03,12.03v108.273c0,6.833,5.39,11.922,12.223,11.934c6.821,0.012,11.838-5.101,11.838-11.922v-96.242H373.3c6.833,0,12.03-5.197,12.03-12.03S380.134,228.678,373.3,228.666z');
            svgGroup.appendChild(path1);
            svgGroup.appendChild(path2);
            svgGroup.appendChild(path3);
            svgGroup.appendChild(path4);
        }
        return this._minimizeIcon;
    }
    onFullscreenChange() {
        super.onFullscreenChange();
        const minimize = this.minimizeIcon;
        const maximize = this.maximizeIcon;
        if (this.isFullscreen) {
            minimize.style.display = 'inline';
            //ios disappearing svg fix
            minimize.style.transform = 'translate(0, 0)';
            maximize.style.display = 'none';
        }
        else {
            minimize.style.display = 'none';
            maximize.style.display = 'inline';
            //ios disappearing svg fix
            maximize.style.transform = 'translate(0, 0)';
        }
    }
}
//# sourceMappingURL=FullscreenIcon.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/LabelledButton.js":
/*!******************************************************!*\
  !*** ../../ui-library/dist/esm/UI/LabelledButton.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LabelledButton: () => (/* binding */ LabelledButton)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * A button with a text label beside it.
 */
class LabelledButton {
    constructor(label, buttonText) {
        this._label = label;
        this._buttonText = buttonText;
    }
    /**
     * Add a click listener to the button element.
     */
    addOnClickListener(onClickFunc) {
        this.button.addEventListener('click', onClickFunc);
    }
    /**
     * Get the HTMLInputElement for the button.
     */
    get button() {
        if (!this._button) {
            this._button = document.createElement('input');
            this._button.type = 'button';
            this._button.value = this._buttonText;
            this._button.classList.add('overlay-button');
            this._button.classList.add('btn-flat');
        }
        return this._button;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            // create root div with "setting" css class
            this._rootElement = document.createElement('div');
            this._rootElement.classList.add('setting');
            // create div element to contain our setting's text
            const settingsTextElem = document.createElement('div');
            settingsTextElem.innerText = this._label;
            this._rootElement.appendChild(settingsTextElem);
            // create label element to wrap out input type
            const wrapperLabel = document.createElement('label');
            wrapperLabel.classList.add('btn-overlay');
            this._rootElement.appendChild(wrapperLabel);
            wrapperLabel.appendChild(this.button);
        }
        return this._rootElement;
    }
}
//# sourceMappingURL=LabelledButton.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/LatencyTest.js":
/*!***************************************************!*\
  !*** ../../ui-library/dist/esm/UI/LatencyTest.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LatencyTest: () => (/* binding */ LatencyTest)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UIConfigurationTypes */ "../../ui-library/dist/esm/UI/UIConfigurationTypes.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * Latency test UI elements and results handling.
 */
class LatencyTest {
    /**
     * Get the the button containing the stats icon.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('section');
            this._rootElement.classList.add('settingsContainer');
            // make heading
            const heading = document.createElement('div');
            heading.id = 'latencyTestHeader';
            heading.classList.add('settings-text');
            heading.classList.add('settingsHeader');
            this._rootElement.appendChild(heading);
            const headingText = document.createElement('div');
            headingText.innerHTML = _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.StatsSections.LatencyTest;
            heading.appendChild(headingText);
            heading.appendChild(this.latencyTestButton);
            // make test results element
            const resultsParentElem = document.createElement('div');
            resultsParentElem.id = 'latencyTestContainer';
            resultsParentElem.classList.add('d-none');
            this._rootElement.appendChild(resultsParentElem);
            resultsParentElem.appendChild(this.latencyTestResultsElement);
        }
        return this._rootElement;
    }
    get latencyTestResultsElement() {
        if (!this._latencyTestResultsElement) {
            this._latencyTestResultsElement = document.createElement('div');
            this._latencyTestResultsElement.id = 'latencyStatsResults';
            this._latencyTestResultsElement.classList.add('StatsResult');
        }
        return this._latencyTestResultsElement;
    }
    get latencyTestButton() {
        if (!this._latencyTestButton) {
            this._latencyTestButton = document.createElement('input');
            this._latencyTestButton.type = 'button';
            this._latencyTestButton.value = 'Run Test';
            this._latencyTestButton.id = 'btn-start-latency-test';
            this._latencyTestButton.classList.add('streamTools-button');
            this._latencyTestButton.classList.add('btn-flat');
        }
        return this._latencyTestButton;
    }
    /**
     * Populate the UI based on the latency test's results.
     * @param latencyTimings - The latency test results.
     */
    handleTestResult(latencyTimings) {
        _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(JSON.stringify(latencyTimings));
        let latencyStatsInnerHTML = '';
        if (latencyTimings.networkLatency !== undefined && latencyTimings.networkLatency > 0) {
            latencyStatsInnerHTML += '<div>Net latency RTT (ms): ' + latencyTimings.networkLatency + '</div>';
        }
        if (latencyTimings.EncodeMs !== undefined && latencyTimings.EncodeMs > 0) {
            latencyStatsInnerHTML += '<div>UE Encode (ms): ' + latencyTimings.EncodeMs + '</div>';
        }
        if (latencyTimings.CaptureToSendMs !== undefined && latencyTimings.CaptureToSendMs > 0) {
            latencyStatsInnerHTML += '<div>UE Capture (ms): ' + latencyTimings.CaptureToSendMs + '</div>';
        }
        if (latencyTimings.browserSendLatency !== undefined && latencyTimings.browserSendLatency > 0) {
            latencyStatsInnerHTML +=
                '<div>Browser send latency (ms): ' + latencyTimings.browserSendLatency + '</div>';
        }
        if (latencyTimings.frameDisplayDeltaTimeMs !== undefined &&
            latencyTimings.browserReceiptTimeMs !== undefined) {
            latencyStatsInnerHTML +=
                latencyTimings.frameDisplayDeltaTimeMs && latencyTimings.browserReceiptTimeMs
                    ? '<div>Browser receive latency (ms): ' +
                        latencyTimings.frameDisplayDeltaTimeMs +
                        '</div>'
                    : '';
        }
        if (latencyTimings.latencyExcludingDecode !== undefined) {
            latencyStatsInnerHTML +=
                '<div>Total latency (excluding browser) (ms): ' +
                    latencyTimings.latencyExcludingDecode +
                    '</div>';
        }
        if (latencyTimings.endToEndLatency !== undefined) {
            latencyStatsInnerHTML += latencyTimings.endToEndLatency
                ? '<div>Total latency (ms): ' + latencyTimings.endToEndLatency + '</div>'
                : '';
        }
        this.latencyTestResultsElement.innerHTML = latencyStatsInnerHTML;
    }
}
//# sourceMappingURL=LatencyTest.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/SessionTest.js":
/*!***************************************************!*\
  !*** ../../ui-library/dist/esm/UI/SessionTest.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SessionTest: () => (/* binding */ SessionTest)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/Config/SettingNumber.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Config_SettingUINumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Config/SettingUINumber */ "../../ui-library/dist/esm/Config/SettingUINumber.js");
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * Session test UI elements and results handling.
 * Creates a button to start the test and collects stats and latency info during the test.
 * After the test is finished, it generates CSV files for stats and latency info.
 * The test runs for a specified time frame, which can be set in the UI.
 */
class SessionTest {
    constructor() {
        this.isCollectingStats = false;
    }
    /**
     * Make the elements for the session test: e.g. button and test time input.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('section');
            this._rootElement.classList.add('settingsContainer');
            // make heading
            const heading = document.createElement('div');
            heading.id = 'latencyTestHeader';
            heading.classList.add('settings-text');
            heading.classList.add('settingsHeader');
            this._rootElement.appendChild(heading);
            const headingText = document.createElement('div');
            headingText.innerHTML = 'Session Test';
            heading.appendChild(headingText);
            // make test results element
            const resultsParentElem = document.createElement('div');
            resultsParentElem.id = 'latencyTestContainer';
            resultsParentElem.classList.add('d-none');
            this._rootElement.appendChild(resultsParentElem);
            this._testTimeFrameSetting = new _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_0__.SettingNumber('TestTimeFrame', 'Test Time Frame', 'How long the test runs for (seconds)', 0 /*min*/, 3600 /*max*/, 60 /*default*/, false);
            const testTimeFrameSetting = new _Config_SettingUINumber__WEBPACK_IMPORTED_MODULE_1__.SettingUINumber(this._testTimeFrameSetting);
            resultsParentElem.appendChild(testTimeFrameSetting.rootElement);
            resultsParentElem.appendChild(this.latencyTestButton);
        }
        return this._rootElement;
    }
    get latencyTestButton() {
        if (!this._latencyTestButton) {
            this._latencyTestButton = document.createElement('input');
            this._latencyTestButton.type = 'button';
            this._latencyTestButton.value = 'Run Test';
            this._latencyTestButton.id = 'btn-start-latency-test';
            this._latencyTestButton.classList.add('streamTools-button');
            this._latencyTestButton.classList.add('btn-flat');
            this._latencyTestButton.onclick = () => {
                this.records = [];
                this.latencyRecords = [];
                this.isCollectingStats = true;
                this._latencyTestButton.disabled = true;
                this._latencyTestButton.value = 'Running...';
                _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_2__.Logger.Info(`Starting session test. Duration: [${this._testTimeFrameSetting.number}]`);
                setTimeout(() => {
                    this.onCollectingFinished();
                    this._latencyTestButton.disabled = false;
                    this._latencyTestButton.value = 'Run Test';
                }, this._testTimeFrameSetting.number * 1000);
            };
        }
        return this._latencyTestButton;
    }
    handleStats(stats) {
        if (!this.isCollectingStats) {
            return;
        }
        const statsCopy = structuredClone(stats);
        this.records.push(statsCopy);
    }
    handleLatencyInfo(latencyInfo) {
        if (!this.isCollectingStats) {
            return;
        }
        const latencyInfoCopy = structuredClone(latencyInfo);
        this.latencyRecords.push(latencyInfoCopy);
    }
    onCollectingFinished() {
        this.isCollectingStats = false;
        _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_2__.Logger.Info(`Finished session test`);
        this.generateStatsCsv();
        this.generateLatencyCsv();
    }
    generateStatsCsv() {
        const csvHeader = [];
        this.records.forEach((record) => {
            for (const i in record) {
                const obj = record[i];
                if (Array.isArray(obj)) {
                    for (let j = 0; j < obj.length; j++) {
                        const arrayVal = obj[j];
                        for (const k in arrayVal) {
                            if (csvHeader.indexOf(`${i}.${j}.${k}`) === -1) {
                                csvHeader.push(`${i}.${j}.${k}`);
                            }
                        }
                    }
                }
                else if (obj instanceof Map) {
                    for (const j in obj.keys()) {
                        const mapVal = obj.get(j);
                        for (const k in mapVal) {
                            if (csvHeader.indexOf(`${i}.${j}.${k}`) === -1) {
                                csvHeader.push(`${i}.${j}.${k}`);
                            }
                        }
                    }
                }
                else {
                    for (const j in obj) {
                        if (csvHeader.indexOf(`${i}.${j}`) === -1) {
                            csvHeader.push(`${i}.${j}`);
                        }
                    }
                }
            }
        });
        let csvBody = '';
        this.records.forEach((record) => {
            csvHeader.forEach((field) => {
                try {
                    csvBody += `"${field.split('.').reduce((o, k) => o[k], record)}",`;
                }
                catch (_) {
                    csvBody += `"",`;
                }
            });
            csvBody += `\n`;
        });
        const file = new Blob([`${csvHeader.join(',')}\n${csvBody}`], { type: 'text/plain' });
        const a = document.createElement('a');
        const url = URL.createObjectURL(file);
        a.href = url;
        a.download = 'stats.csv';
        document.body.appendChild(a);
        a.click();
        setTimeout(function () {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 0);
    }
    generateLatencyCsv() {
        const csvHeader = [];
        this.latencyRecords.forEach((record) => {
            for (const i in record) {
                const obj = record[i];
                if (typeof obj === 'object') {
                    for (const j in obj) {
                        if (csvHeader.indexOf(`${i}.${j}`) === -1) {
                            csvHeader.push(`${i}.${j}`);
                        }
                    }
                }
                else if (csvHeader.indexOf(`${i}`) === -1) {
                    csvHeader.push(`${i}`);
                }
            }
        });
        let csvBody = '';
        this.latencyRecords.forEach((record) => {
            csvHeader.forEach((field) => {
                try {
                    csvBody += `"${field.split('.').reduce((o, k) => o[k], record)}",`;
                }
                catch (_) {
                    csvBody += `"",`;
                }
            });
            csvBody += `\n`;
        });
        const file = new Blob([`${csvHeader.join(',')}\n${csvBody}`], { type: 'text/plain' });
        const a = document.createElement('a');
        const url = URL.createObjectURL(file);
        a.href = url;
        a.download = 'latency.csv';
        document.body.appendChild(a);
        a.click();
        setTimeout(function () {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 0);
    }
}
//# sourceMappingURL=SessionTest.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/SettingsIcon.js":
/*!****************************************************!*\
  !*** ../../ui-library/dist/esm/UI/SettingsIcon.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingsIcon: () => (/* binding */ SettingsIcon)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Settings icon that can be clicked.
 */
class SettingsIcon {
    /**
     * Get the the button containing the settings icon.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('button');
            this._rootElement.type = 'button';
            this._rootElement.classList.add('UiTool');
            this._rootElement.id = 'settingsBtn';
            this._rootElement.appendChild(this.settingsIcon);
            this._rootElement.appendChild(this.tooltipText);
        }
        return this._rootElement;
    }
    get tooltipText() {
        if (!this._tooltipText) {
            this._tooltipText = document.createElement('span');
            this._tooltipText.classList.add('tooltiptext');
            this._tooltipText.innerHTML = 'Settings';
        }
        return this._tooltipText;
    }
    get settingsIcon() {
        if (!this._settingsIcon) {
            this._settingsIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._settingsIcon.setAttributeNS(null, 'id', 'settingsIcon');
            this._settingsIcon.setAttributeNS(null, 'x', '0px');
            this._settingsIcon.setAttributeNS(null, 'y', '0px');
            this._settingsIcon.setAttributeNS(null, 'viewBox', '0 0 478.703 478.703');
            // create svg group for the paths
            const svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svgGroup.classList.add('svgIcon');
            this._settingsIcon.appendChild(svgGroup);
            // create paths for the icon itself, the inner and out path of a cog
            const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path1.setAttributeNS(null, 'd', 'M454.2,189.101l-33.6-5.7c-3.5-11.3-8-22.2-13.5-32.6l19.8-27.7c8.4-11.8,7.1-27.9-3.2-38.1l-29.8-29.8\
			c-5.6-5.6-13-8.7-20.9-8.7c-6.2,0-12.1,1.9-17.1,5.5l-27.8,19.8c-10.8-5.7-22.1-10.4-33.8-13.9l-5.6-33.2\
			c-2.4-14.3-14.7-24.7-29.2-24.7h-42.1c-14.5,0-26.8,10.4-29.2,24.7l-5.8,34c-11.2,3.5-22.1,8.1-32.5,13.7l-27.5-19.8\
			c-5-3.6-11-5.5-17.2-5.5c-7.9,0-15.4,3.1-20.9,8.7l-29.9,29.8c-10.2,10.2-11.6,26.3-3.2,38.1l20,28.1\
			c-5.5,10.5-9.9,21.4-13.3,32.7l-33.2,5.6c-14.3,2.4-24.7,14.7-24.7,29.2v42.1c0,14.5,10.4,26.8,24.7,29.2l34,5.8\
			c3.5,11.2,8.1,22.1,13.7,32.5l-19.7,27.4c-8.4,11.8-7.1,27.9,3.2,38.1l29.8,29.8c5.6,5.6,13,8.7,20.9,8.7c6.2,0,12.1-1.9,17.1-5.5\
			l28.1-20c10.1,5.3,20.7,9.6,31.6,13l5.6,33.6c2.4,14.3,14.7,24.7,29.2,24.7h42.2c14.5,0,26.8-10.4,29.2-24.7l5.7-33.6\
			c11.3-3.5,22.2-8,32.6-13.5l27.7,19.8c5,3.6,11,5.5,17.2,5.5l0,0c7.9,0,15.3-3.1,20.9-8.7l29.8-29.8c10.2-10.2,11.6-26.3,3.2-38.1\
			l-19.8-27.8c5.5-10.5,10.1-21.4,13.5-32.6l33.6-5.6c14.3-2.4,24.7-14.7,24.7-29.2v-42.1\
			C478.9,203.801,468.5,191.501,454.2,189.101z M451.9,260.401c0,1.3-0.9,2.4-2.2,2.6l-42,7c-5.3,0.9-9.5,4.8-10.8,9.9\
			c-3.8,14.7-9.6,28.8-17.4,41.9c-2.7,4.6-2.5,10.3,0.6,14.7l24.7,34.8c0.7,1,0.6,2.5-0.3,3.4l-29.8,29.8c-0.7,0.7-1.4,0.8-1.9,0.8\
			c-0.6,0-1.1-0.2-1.5-0.5l-34.7-24.7c-4.3-3.1-10.1-3.3-14.7-0.6c-13.1,7.8-27.2,13.6-41.9,17.4c-5.2,1.3-9.1,5.6-9.9,10.8l-7.1,42\
			c-0.2,1.3-1.3,2.2-2.6,2.2h-42.1c-1.3,0-2.4-0.9-2.6-2.2l-7-42c-0.9-5.3-4.8-9.5-9.9-10.8c-14.3-3.7-28.1-9.4-41-16.8\
			c-2.1-1.2-4.5-1.8-6.8-1.8c-2.7,0-5.5,0.8-7.8,2.5l-35,24.9c-0.5,0.3-1,0.5-1.5,0.5c-0.4,0-1.2-0.1-1.9-0.8l-29.8-29.8\
			c-0.9-0.9-1-2.3-0.3-3.4l24.6-34.5c3.1-4.4,3.3-10.2,0.6-14.8c-7.8-13-13.8-27.1-17.6-41.8c-1.4-5.1-5.6-9-10.8-9.9l-42.3-7.2\
			c-1.3-0.2-2.2-1.3-2.2-2.6v-42.1c0-1.3,0.9-2.4,2.2-2.6l41.7-7c5.3-0.9,9.6-4.8,10.9-10c3.7-14.7,9.4-28.9,17.1-42\
			c2.7-4.6,2.4-10.3-0.7-14.6l-24.9-35c-0.7-1-0.6-2.5,0.3-3.4l29.8-29.8c0.7-0.7,1.4-0.8,1.9-0.8c0.6,0,1.1,0.2,1.5,0.5l34.5,24.6\
			c4.4,3.1,10.2,3.3,14.8,0.6c13-7.8,27.1-13.8,41.8-17.6c5.1-1.4,9-5.6,9.9-10.8l7.2-42.3c0.2-1.3,1.3-2.2,2.6-2.2h42.1\
			c1.3,0,2.4,0.9,2.6,2.2l7,41.7c0.9,5.3,4.8,9.6,10,10.9c15.1,3.8,29.5,9.7,42.9,17.6c4.6,2.7,10.3,2.5,14.7-0.6l34.5-24.8\
			c0.5-0.3,1-0.5,1.5-0.5c0.4,0,1.2,0.1,1.9,0.8l29.8,29.8c0.9,0.9,1,2.3,0.3,3.4l-24.7,34.7c-3.1,4.3-3.3,10.1-0.6,14.7\
			c7.8,13.1,13.6,27.2,17.4,41.9c1.3,5.2,5.6,9.1,10.8,9.9l42,7.1c1.3,0.2,2.2,1.3,2.2,2.6v42.1H451.9z');
            const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path2.setAttributeNS(null, 'd', 'M239.4,136.001c-57,0-103.3,46.3-103.3,103.3s46.3,103.3,103.3,103.3s103.3-46.3,103.3-103.3S296.4,136.001,239.4,136.001z M239.4,315.601c-42.1,0-76.3-34.2-76.3-76.3s34.2-76.3,76.3-76.3s76.3,34.2,76.3,76.3S281.5,315.601,239.4,315.601z');
            svgGroup.appendChild(path1);
            svgGroup.appendChild(path2);
        }
        return this._settingsIcon;
    }
}
//# sourceMappingURL=SettingsIcon.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/SettingsPanel.js":
/*!*****************************************************!*\
  !*** ../../ui-library/dist/esm/UI/SettingsPanel.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingsPanel: () => (/* binding */ SettingsPanel)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * A UI component containing all the settings for the application.
 */
class SettingsPanel {
    constructor() {
        this._rootElement = null;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('div');
            this._rootElement.id = 'settings-panel';
            this._rootElement.classList.add('panel-wrap');
            const panelElem = document.createElement('div');
            panelElem.classList.add('panel');
            this._rootElement.appendChild(panelElem);
            const settingsHeading = document.createElement('div');
            settingsHeading.id = 'settingsHeading';
            settingsHeading.textContent = 'Settings';
            panelElem.appendChild(settingsHeading);
            panelElem.appendChild(this.settingsCloseButton);
            panelElem.appendChild(this.settingsContentElement);
        }
        return this._rootElement;
    }
    get settingsContentElement() {
        if (!this._settingsContentElement) {
            this._settingsContentElement = document.createElement('div');
            this._settingsContentElement.id = 'settingsContent';
        }
        return this._settingsContentElement;
    }
    get settingsCloseButton() {
        if (!this._settingsCloseButton) {
            this._settingsCloseButton = document.createElement('div');
            this._settingsCloseButton.id = 'settingsClose';
        }
        return this._settingsCloseButton;
    }
    /**
     * Show settings panel.
     */
    show() {
        if (!this.rootElement.classList.contains('panel-wrap-visible')) {
            this.rootElement.classList.add('panel-wrap-visible');
        }
    }
    /**
     * Toggle the visibility of the settings panel.
     */
    toggleVisibility() {
        this.rootElement.classList.toggle('panel-wrap-visible');
    }
    /**
     * Hide settings panel.
     */
    hide() {
        if (this.rootElement.classList.contains('panel-wrap-visible')) {
            this.rootElement.classList.remove('panel-wrap-visible');
        }
    }
}
//# sourceMappingURL=SettingsPanel.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/StatsIcon.js":
/*!*************************************************!*\
  !*** ../../ui-library/dist/esm/UI/StatsIcon.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StatsIcon: () => (/* binding */ StatsIcon)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Stats icon that can be clicked.
 */
class StatsIcon {
    /**
     * Get the the button containing the stats icon.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('button');
            this._rootElement.type = 'button';
            this._rootElement.classList.add('UiTool');
            this._rootElement.id = 'statsBtn';
            this._rootElement.appendChild(this.statsIcon);
            this._rootElement.appendChild(this.tooltipText);
        }
        return this._rootElement;
    }
    get tooltipText() {
        if (!this._tooltipText) {
            this._tooltipText = document.createElement('span');
            this._tooltipText.classList.add('tooltiptext');
            this._tooltipText.innerHTML = 'Information';
        }
        return this._tooltipText;
    }
    get statsIcon() {
        if (!this._statsIcon) {
            this._statsIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._statsIcon.setAttributeNS(null, 'id', 'statsIcon');
            this._statsIcon.setAttributeNS(null, 'x', '0px');
            this._statsIcon.setAttributeNS(null, 'y', '0px');
            this._statsIcon.setAttributeNS(null, 'viewBox', '0 0 330 330');
            // create svg group for the paths
            const svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svgGroup.classList.add('svgIcon');
            this._statsIcon.appendChild(svgGroup);
            // create paths for the icon itself, the inner and out path of a cog
            const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path1.setAttributeNS(null, 'd', 'M165,0.008C74.019,0.008,0,74.024,0,164.999c0,90.977,74.019,164.992,165,164.992s165-74.015,165-164.992C330,74.024,255.981,0.008,165,0.008z M165,299.992c-74.439,0-135-60.557-135-134.992S90.561,30.008,165,30.008s135,60.557,135,134.991C300,239.436,239.439,299.992,165,299.992z');
            const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path2.setAttributeNS(null, 'd', 'M165,130.008c-8.284,0-15,6.716-15,15v99.983c0,8.284,6.716,15,15,15s15-6.716,15-15v-99.983C180,136.725,173.284,130.008,165,130.008z');
            const path3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path3.setAttributeNS(null, 'd', 'M165,70.011c-3.95,0-7.811,1.6-10.61,4.39c-2.79,2.79-4.39,6.66-4.39,10.61s1.6,7.81,4.39,10.61c2.79,2.79,6.66,4.39,10.61,4.39s7.81-1.6,10.609-4.39c2.79-2.8,4.391-6.66,4.391-10.61s-1.601-7.82-4.391-10.61C172.81,71.61,168.95,70.011,165,70.011z');
            svgGroup.appendChild(path1);
            svgGroup.appendChild(path2);
            svgGroup.appendChild(path3);
        }
        return this._statsIcon;
    }
}
//# sourceMappingURL=StatsIcon.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/StatsPanel.js":
/*!**************************************************!*\
  !*** ../../ui-library/dist/esm/UI/StatsPanel.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Stat: () => (/* binding */ Stat),
/* harmony export */   StatsPanel: () => (/* binding */ StatsPanel)
/* harmony export */ });
/* harmony import */ var _LatencyTest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LatencyTest */ "../../ui-library/dist/esm/UI/LatencyTest.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _Util_MathUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Util/MathUtils */ "../../ui-library/dist/esm/Util/MathUtils.js");
/* harmony import */ var _DataChannelLatencyTest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DataChannelLatencyTest */ "../../ui-library/dist/esm/UI/DataChannelLatencyTest.js");
/* harmony import */ var _SessionTest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SessionTest */ "../../ui-library/dist/esm/UI/SessionTest.js");
/* harmony import */ var _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UIConfigurationTypes */ "../../ui-library/dist/esm/UI/UIConfigurationTypes.js");
// Copyright Epic Games, Inc. All Rights Reserved.






/**
 * A stat structure, an id, the stat string, and the element where it is rendered.
 */
class Stat {
}
/**
 * A UI component containing all the stats for the application.
 */
class StatsPanel {
    constructor(config, streamConfig) {
        this.sessionTest = null;
        /* A map stats we are storing/rendering */
        this.statsMap = new Map();
        this._config = config;
        // Only create the session test class/ui-elements if the ?LatencyCSV flag is enabled.
        this.sessionTest = streamConfig.isFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_0__.Flags.LatencyCSV) ? new _SessionTest__WEBPACK_IMPORTED_MODULE_1__.SessionTest() : null;
        this.latencyTest = new _LatencyTest__WEBPACK_IMPORTED_MODULE_2__.LatencyTest();
        this.dataChannelLatencyTest = new _DataChannelLatencyTest__WEBPACK_IMPORTED_MODULE_3__.DataChannelLatencyTest();
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('div');
            this._rootElement.id = 'stats-panel';
            this._rootElement.classList.add('panel-wrap');
            const panelElem = document.createElement('div');
            panelElem.classList.add('panel');
            this._rootElement.appendChild(panelElem);
            const statsHeading = document.createElement('div');
            statsHeading.id = 'statsHeading';
            statsHeading.textContent = 'Information';
            panelElem.appendChild(statsHeading);
            panelElem.appendChild(this.statsCloseButton);
            panelElem.appendChild(this.statsContentElement);
        }
        return this._rootElement;
    }
    get statsContentElement() {
        if (!this._statsContentElement) {
            this._statsContentElement = document.createElement('div');
            this._statsContentElement.id = 'statsContent';
            const streamToolStats = document.createElement('div');
            streamToolStats.id = 'streamToolsStats';
            streamToolStats.classList.add('container');
            const controlStats = document.createElement('div');
            controlStats.id = 'ControlStats';
            controlStats.classList.add('row');
            const statistics = document.createElement('section');
            statistics.id = 'statistics';
            statistics.classList.add('settingsContainer');
            const latencyStats = document.createElement('section');
            latencyStats.id = 'latencyStats';
            latencyStats.classList.add('settingsContainer');
            const statisticsHeader = document.createElement('div');
            statisticsHeader.id = 'statisticsHeader';
            statisticsHeader.classList.add('settings-text');
            statisticsHeader.classList.add('settingsHeader');
            const latencyStatsHeader = document.createElement('div');
            latencyStatsHeader.id = 'latencyStatsHeader';
            latencyStatsHeader.classList.add('settings-text');
            latencyStatsHeader.classList.add('settingsHeader');
            this._statsContentElement.appendChild(streamToolStats);
            streamToolStats.appendChild(controlStats);
            // Add sesssion test to the UI if ?LatencyCSV flag is enabled and config allows it.
            if (this.sessionTest && (0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.SessionTest)) {
                controlStats.appendChild(this.sessionTest.rootElement);
            }
            controlStats.appendChild(statistics);
            controlStats.appendChild(latencyStats);
            statistics.appendChild(statisticsHeader);
            latencyStats.appendChild(latencyStatsHeader);
            if ((0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.SessionStats)) {
                const sessionStatsText = document.createElement('div');
                sessionStatsText.innerHTML = _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.SessionStats;
                statisticsHeader.appendChild(sessionStatsText);
            }
            statistics.appendChild(this.statisticsContainer);
            if ((0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.LatencyStats)) {
                const latencyStatsText = document.createElement('div');
                latencyStatsText.innerHTML = _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.LatencyStats;
                latencyStatsHeader.appendChild(latencyStatsText);
            }
            latencyStats.appendChild(this.latencyStatsContainer);
            if ((0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.LatencyTest)) {
                controlStats.appendChild(this.latencyTest.rootElement);
            }
            if ((0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.DataChannelLatencyTest)) {
                controlStats.appendChild(this.dataChannelLatencyTest.rootElement);
            }
        }
        return this._statsContentElement;
    }
    get statisticsContainer() {
        if (!this._statisticsContainer) {
            this._statisticsContainer = document.createElement('div');
            this._statisticsContainer.id = 'statisticsContainer';
            this._statisticsContainer.classList.add('d-none');
            this._statisticsContainer.appendChild(this.statsResult);
        }
        return this._statisticsContainer;
    }
    get latencyStatsContainer() {
        if (!this._latencyStatsContainer) {
            this._latencyStatsContainer = document.createElement('div');
            this._latencyStatsContainer.id = 'latencyStatsContainer';
            this._latencyStatsContainer.classList.add('d-none');
            this._latencyStatsContainer.appendChild(this.latencyResult);
        }
        return this._latencyStatsContainer;
    }
    get statsResult() {
        if (!this._statsResult) {
            this._statsResult = document.createElement('div');
            this._statsResult.id = 'statisticsResult';
            this._statsResult.classList.add('StatsResult');
        }
        return this._statsResult;
    }
    get latencyResult() {
        if (!this._latencyResult) {
            this._latencyResult = document.createElement('div');
            this._latencyResult.id = 'latencyResult';
            this._latencyResult.classList.add('StatsResult');
        }
        return this._latencyResult;
    }
    get statsCloseButton() {
        if (!this._statsCloseButton) {
            this._statsCloseButton = document.createElement('div');
            this._statsCloseButton.id = 'statsClose';
        }
        return this._statsCloseButton;
    }
    onDisconnect() {
        this.latencyTest.latencyTestButton.onclick = () => {
            // do nothing
        };
        this.dataChannelLatencyTest.latencyTestButton.onclick = () => {
            //do nothing
        };
    }
    onVideoInitialized(stream) {
        // starting a latency check
        this.latencyTest.latencyTestButton.onclick = () => {
            stream.requestLatencyTest();
        };
        this.dataChannelLatencyTest.latencyTestButton.onclick = () => {
            const started = stream.requestDataChannelLatencyTest({
                duration: 1000,
                rps: 10,
                requestSize: 200,
                responseSize: 200
            });
            if (started) {
                this.dataChannelLatencyTest.handleTestStart();
            }
        };
    }
    configure(settings) {
        if (settings.DisableLatencyTest) {
            this.latencyTest.latencyTestButton.disabled = true;
            this.latencyTest.latencyTestButton.title = 'Disabled by -PixelStreamingDisableLatencyTester=true';
            this.dataChannelLatencyTest.latencyTestButton.disabled = true;
            this.dataChannelLatencyTest.latencyTestButton.title =
                'Disabled by -PixelStreamingDisableLatencyTester=true';
            _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Logger.Info('-PixelStreamingDisableLatencyTester=true, requesting latency report from the the browser to UE is disabled.');
        }
    }
    /**
     * Show stats panel.
     */
    show() {
        if (!this.rootElement.classList.contains('panel-wrap-visible')) {
            this.rootElement.classList.add('panel-wrap-visible');
        }
    }
    /**
     * Toggle the visibility of the stats panel.
     */
    toggleVisibility() {
        this.rootElement.classList.toggle('panel-wrap-visible');
    }
    /**
     * Hide the stats panel.
     */
    hide() {
        if (this.rootElement.classList.contains('panel-wrap-visible')) {
            this.rootElement.classList.remove('panel-wrap-visible');
        }
    }
    handlePlayerCount(playerCount) {
        this.addOrUpdateSessionStat('PlayerCountStat', 'Players', playerCount.toString());
    }
    /**
     * Handle stats coming in from browser/UE
     * @param stats - the stats structure
     */
    handleStats(stats) {
        var _a, _b, _c, _d;
        // format numbering based on the browser language
        const numberFormat = new Intl.NumberFormat(window.navigator.language, {
            maximumFractionDigits: 0
        });
        if (this.sessionTest) {
            this.sessionTest.handleStats(stats);
        }
        // Inbound data
        const inboundData = _Util_MathUtils__WEBPACK_IMPORTED_MODULE_6__.MathUtils.formatBytes(stats.inboundVideoStats.bytesReceived, 2);
        this.addOrUpdateSessionStat('InboundDataStat', 'Received', inboundData);
        // Packets lost
        const packetsLostStat = Object.prototype.hasOwnProperty.call(stats.inboundVideoStats, 'packetsLost')
            ? numberFormat.format(stats.inboundVideoStats.packetsLost)
            : 'Chrome only';
        this.addOrUpdateSessionStat('PacketsLostStat', 'Packets Lost', packetsLostStat);
        // Bitrate
        if (stats.inboundVideoStats.bitrate) {
            this.addOrUpdateSessionStat('VideoBitrateStat', 'Video Bitrate (kbps)', stats.inboundVideoStats.bitrate.toString());
        }
        if (stats.inboundAudioStats.bitrate) {
            this.addOrUpdateSessionStat('AudioBitrateStat', 'Audio Bitrate (kbps)', stats.inboundAudioStats.bitrate.toString());
        }
        // Video resolution
        const resStat = stats.inboundVideoStats.frameWidth !== undefined &&
            stats.inboundVideoStats.frameWidth > 0 &&
            stats.inboundVideoStats.frameHeight !== undefined &&
            stats.inboundVideoStats.frameHeight > 0
            ? stats.inboundVideoStats.frameWidth + 'x' + stats.inboundVideoStats.frameHeight
            : 'Chrome only';
        this.addOrUpdateSessionStat('VideoResStat', 'Video resolution', resStat);
        // Frames decoded
        if (stats.inboundVideoStats.framesDecoded !== undefined) {
            const framesDecoded = numberFormat.format(stats.inboundVideoStats.framesDecoded);
            this.addOrUpdateSessionStat('FramesDecodedStat', 'Frames Decoded', framesDecoded);
        }
        // Framerate
        if (stats.inboundVideoStats.framesPerSecond) {
            this.addOrUpdateSessionStat('FramerateStat', 'Framerate', stats.inboundVideoStats.framesPerSecond.toString());
        }
        // Frames dropped
        if (stats.inboundVideoStats.framesDropped !== undefined) {
            this.addOrUpdateSessionStat('FramesDroppedStat', 'Frames dropped', stats.inboundVideoStats.framesDropped.toString());
        }
        if (stats.inboundVideoStats.codecId) {
            this.addOrUpdateSessionStat('VideoCodecStat', 'Video codec', 
            // Split the codec to remove the Fmtp line
            (_b = (_a = stats.codecs.get(stats.inboundVideoStats.codecId)) === null || _a === void 0 ? void 0 : _a.mimeType.replace('video/', '')) !== null && _b !== void 0 ? _b : '');
        }
        if (stats.inboundAudioStats.codecId) {
            this.addOrUpdateSessionStat('AudioCodecStat', 'Audio codec', 
            // Split the codec to remove the Fmtp line
            (_d = (_c = stats.codecs.get(stats.inboundAudioStats.codecId)) === null || _c === void 0 ? void 0 : _c.mimeType.replace('audio/', '')) !== null && _d !== void 0 ? _d : '');
        }
        // Store the active candidate pair return a new Candidate pair stat if getActiveCandidate is null
        const activeCandidatePair = stats.getActiveCandidatePair();
        if (activeCandidatePair) {
            // RTT
            const netRTT = Object.prototype.hasOwnProperty.call(activeCandidatePair, 'currentRoundTripTime') &&
                stats.isNumber(activeCandidatePair.currentRoundTripTime)
                ? Math.ceil(activeCandidatePair.currentRoundTripTime * 1000).toString()
                : "Can't calculate";
            this.addOrUpdateSessionStat('RTTStat', 'Net RTT (ms)', netRTT);
        }
        this.addOrUpdateSessionStat('DurationStat', 'Duration', stats.sessionStats.runTime);
        this.addOrUpdateSessionStat('ControlsInputStat', 'Controls stream input', stats.sessionStats.controlsStreamInput);
        // QP
        if (stats.sessionStats.videoEncoderAvgQP !== undefined &&
            !Number.isNaN(stats.sessionStats.videoEncoderAvgQP)) {
            this.addOrUpdateSessionStat('QPStat', 'Video quantization parameter', stats.sessionStats.videoEncoderAvgQP.toString());
        }
        _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_5__.Logger.Info(`--------- Stats ---------\n ${JSON.stringify(stats)}\n------------------------`);
    }
    handleLatencyInfo(latencyInfo) {
        if (this.sessionTest) {
            this.sessionTest.handleLatencyInfo(latencyInfo);
        }
        if (latencyInfo.frameTiming !== undefined) {
            // Encoder latency
            if (latencyInfo.frameTiming.encoderLatencyMs !== undefined) {
                this.addOrUpdateLatencyStat('EncodeLatency', 'Encode latency (ms)', Math.ceil(latencyInfo.frameTiming.encoderLatencyMs).toString());
            }
            // Packetizer latency
            if (latencyInfo.frameTiming.packetizeLatencyMs !== undefined) {
                this.addOrUpdateLatencyStat('PacketizerLatency', 'Packetizer latency (ms)', Math.ceil(latencyInfo.frameTiming.packetizeLatencyMs).toString());
            }
            // Pacer latency
            if (latencyInfo.frameTiming.pacerLatencyMs !== undefined) {
                this.addOrUpdateLatencyStat('PacerLatency', 'Pacer latency (ms)', Math.ceil(latencyInfo.frameTiming.pacerLatencyMs).toString());
            }
            // Sender latency calculated using timing stats
            if (latencyInfo.frameTiming.captureToSendLatencyMs !== undefined) {
                this.addOrUpdateLatencyStat('VideoTimingCaptureToSend', 'Post-capture to send latency (ms)', Math.ceil(latencyInfo.frameTiming.captureToSendLatencyMs).toString());
            }
        }
        if (latencyInfo.senderLatencyMs !== undefined) {
            this.addOrUpdateLatencyStat('AbsCaptureTimeToSendLatency', 'Post-capture (abs-ct) to send latency (ms)', Math.ceil(latencyInfo.senderLatencyMs).toString());
        }
        if (latencyInfo.averageAssemblyDelayMs !== undefined) {
            this.addOrUpdateLatencyStat('AvgAssemblyDelay', 'Assembly delay (ms)', Math.ceil(latencyInfo.averageAssemblyDelayMs).toString());
        }
        if (latencyInfo.averageDecodeLatencyMs !== undefined) {
            this.addOrUpdateLatencyStat('AvgDecodeDelay', 'Decode time (ms)', Math.ceil(latencyInfo.averageDecodeLatencyMs).toString());
        }
        if (latencyInfo.averageJitterBufferDelayMs !== undefined) {
            this.addOrUpdateLatencyStat('AvgJitterBufferDelay', 'Jitter buffer (ms)', Math.ceil(latencyInfo.averageJitterBufferDelayMs).toString());
        }
        if (latencyInfo.averageProcessingDelayMs !== undefined) {
            this.addOrUpdateLatencyStat('AvgProcessingDelay', 'Processing delay (ms)', Math.ceil(latencyInfo.averageProcessingDelayMs).toString());
        }
        if (latencyInfo.averageE2ELatency !== undefined) {
            this.addOrUpdateLatencyStat('AvgE2ELatency', 'Total latency (ms)', Math.ceil(latencyInfo.averageE2ELatency).toString());
        }
    }
    /**
     * Adds a new stat to the stats results in the DOM or updates an exiting stat.
     * @param id - The id of the stat to add/update.
     * @param stat - The contents of the stat.
     */
    addOrUpdateSessionStat(id, statLabel, stat) {
        this.addOrUpdateStat(_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.SessionStats, id, statLabel, stat);
    }
    /**
     * Adds a new stat to the latency results in the DOM or updates an exiting stat.
     * @param id - The id of the stat to add/update.
     * @param stat - The contents of the stat.
     */
    addOrUpdateLatencyStat(id, statLabel, stat) {
        this.addOrUpdateStat(_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.LatencyStats, id, statLabel, stat);
    }
    /**
     * Adds a new stat to the stats results in the DOM or updates an exiting stat.
     * @param sectionId - The section to add this stat too.
     * @param id - The id of the stat to add/update.
     * @param stat - The contents of the stat.
     */
    addOrUpdateStat(sectionId, id, statLabel, stat) {
        if (sectionId === _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.SessionStats &&
            !(0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.SessionStats)) {
            return;
        }
        if (sectionId === _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.LatencyStats &&
            !(0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.LatencyStats)) {
            return;
        }
        // Only support session or latency stats being updated in this function currently
        if (sectionId !== _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.SessionStats && sectionId !== _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.LatencyStats) {
            return;
        }
        const parentElem = sectionId === _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.StatsSections.SessionStats ? this.statsResult : this.latencyResult;
        const statHTML = `${statLabel}: ${stat}`;
        if (!this.statsMap.has(id)) {
            // create the stat
            const newStat = new Stat();
            newStat.id = id;
            newStat.stat = stat;
            newStat.title = statLabel;
            newStat.element = document.createElement('div');
            newStat.element.innerHTML = statHTML;
            // add the stat to the dom
            parentElem.appendChild(newStat.element);
            this.statsMap.set(id, newStat);
        }
        // update the existing stat
        else {
            const value = this.statsMap.get(id);
            if (value !== undefined) {
                value.element.innerHTML = statHTML;
            }
        }
    }
}
//# sourceMappingURL=StatsPanel.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/UIConfigurationTypes.js":
/*!************************************************************!*\
  !*** ../../ui-library/dist/esm/UI/UIConfigurationTypes.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExtraFlags: () => (/* binding */ ExtraFlags),
/* harmony export */   SettingsSections: () => (/* binding */ SettingsSections),
/* harmony export */   StatsSections: () => (/* binding */ StatsSections),
/* harmony export */   UIElementCreationMode: () => (/* binding */ UIElementCreationMode),
/* harmony export */   isPanelEnabled: () => (/* binding */ isPanelEnabled),
/* harmony export */   isSectionEnabled: () => (/* binding */ isSectionEnabled),
/* harmony export */   isSettingEnabled: () => (/* binding */ isSettingEnabled)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class ExtraFlags {
}
ExtraFlags.LightMode = 'LightMode';
/**
 * All the UI sections across all the panels.
 */
class SettingsSections {
}
SettingsSections.PixelStreaming = 'Pixel Streaming';
SettingsSections.UI = 'UI';
SettingsSections.Input = 'Input';
SettingsSections.Encoder = 'Encoder';
SettingsSections.WebRTC = 'WebRTC';
SettingsSections.Commands = 'Commands';
class StatsSections {
}
StatsSections.SessionStats = 'Session Stats';
StatsSections.LatencyStats = 'Latency Stats';
StatsSections.LatencyTest = 'Latency Test';
StatsSections.DataChannelLatencyTest = 'Data Channel Latency Test';
StatsSections.SessionTest = 'Session Test';
/** Whether a stream UI element is internally made, externally provided, or disabled. */
var UIElementCreationMode;
(function (UIElementCreationMode) {
    UIElementCreationMode[UIElementCreationMode["CreateDefaultElement"] = 0] = "CreateDefaultElement";
    UIElementCreationMode[UIElementCreationMode["UseCustomElement"] = 1] = "UseCustomElement";
    UIElementCreationMode[UIElementCreationMode["Disable"] = 2] = "Disable";
})(UIElementCreationMode || (UIElementCreationMode = {}));
function isPanelEnabled(config) {
    return !config || (!!config && config.isEnabled);
}
function isSectionEnabled(config, section) {
    return (!config ||
        (!!config &&
            (!Object.prototype.hasOwnProperty.call(config.sectionVisibility, section) ||
                (Object.prototype.hasOwnProperty.call(config.sectionVisibility, section) &&
                    config.sectionVisibility[section]))));
}
function isSettingEnabled(config, setting) {
    return (!config ||
        (!!config &&
            (!Object.prototype.hasOwnProperty.call(config.settingVisibility, setting) ||
                (Object.prototype.hasOwnProperty.call(config.settingVisibility, setting) &&
                    config.settingVisibility[setting]))));
}
//# sourceMappingURL=UIConfigurationTypes.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/VideoQpIndicator.js":
/*!********************************************************!*\
  !*** ../../ui-library/dist/esm/UI/VideoQpIndicator.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VideoQpIndicator: () => (/* binding */ VideoQpIndicator)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * A UI element showing the QP (quantization parameter) of the video stream at the last encoded frame (well, last transmitted QP really).
 * A blockier encoding will have a higher QP and this will make the indicator turn more red.
 * A non-blocky stream will have a lower QP and this will make the indicator turn more green.
 * The QP indicator is represented visually using a WiFi icon.
 */
class VideoQpIndicator {
    constructor(config) {
        this.videoEncoderAvgQP = -1;
        // non html elements
        this.statsText = '';
        this.color = '';
        // qp colors
        this.orangeQP = 26;
        this.redQP = 35;
        this.config = config;
    }
    /**
     * Get the root element of the QP indicator.
     */
    get rootElement() {
        if (!this._rootElement) {
            // make the root element that contains the svg for the connection
            this._rootElement = document.createElement('div');
            this._rootElement.id = 'connection';
            this._rootElement.classList.add('UiTool');
            // add svg icon for the connection strength
            this._rootElement.appendChild(this.qualityStatus);
            // add the text underneath the connection
            this._rootElement.appendChild(this.qualityText);
            // set colors to not connected initially
            this.updateQpTooltip(-1);
        }
        return this._rootElement;
    }
    /**
     * Get the text that displays under the icon.
     */
    get qualityText() {
        if (!this._qualityText) {
            this._qualityText = document.createElement('span');
            this._qualityText.id = 'qualityText';
            this._qualityText.classList.add('tooltiptext');
        }
        return this._qualityText;
    }
    /**
     * Get the icon.
     */
    get qualityStatus() {
        if (!this._qualityStatus) {
            this._qualityStatus = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._qualityStatus.setAttributeNS(null, 'id', 'connectionStrength');
            this._qualityStatus.setAttributeNS(null, 'x', '0px');
            this._qualityStatus.setAttributeNS(null, 'y', '0px');
            this._qualityStatus.setAttributeNS(null, 'viewBox', '0 0 494.45 494.45');
            // build wifi icon
            this.qualityStatus.appendChild(this.dot);
            this.qualityStatus.appendChild(this.middle);
            this.qualityStatus.appendChild(this.outer);
            this.qualityStatus.appendChild(this.inner);
        }
        return this._qualityStatus;
    }
    /**
     * Get the dot at the bottom of the wifi icon.
     */
    get dot() {
        if (!this._dot) {
            this._dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            this._dot.setAttributeNS(null, 'id', 'dot');
            this._dot.setAttributeNS(null, 'cx', '247.125');
            this._dot.setAttributeNS(null, 'cy', '398.925');
            this._dot.setAttributeNS(null, 'r', '35.3');
        }
        return this._dot;
    }
    /**
     * Get the outer arc of the wifi icon.
     */
    get outer() {
        if (!this._outer) {
            this._outer = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            this._outer.setAttributeNS(null, 'id', 'outer');
            this._outer.setAttributeNS(null, 'd', 'M467.925,204.625c-6.8,0-13.5-2.6-18.7-7.8c-111.5-111.4-292.7-111.4-404.1,0c-10.3,10.3-27.1,10.3-37.4,0s-10.3-27.1,0-37.4c64-64,149-99.2,239.5-99.2s175.5,35.2,239.5,99.2c10.3,10.3,10.3,27.1,0,37.4C481.425,202.025,474.625,204.625,467.925,204.625z');
        }
        return this._outer;
    }
    /**
     * Get the middle arc of the wifi icon.
     */
    get middle() {
        if (!this._middle) {
            this._middle = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            this._middle.setAttributeNS(null, 'id', 'middle');
            this._middle.setAttributeNS(null, 'd', 'M395.225,277.325c-6.8,0-13.5-2.6-18.7-7.8c-71.4-71.3-187.4-71.3-258.8,0c-10.3,10.3-27.1,10.3-37.4,0s-10.3-27.1,0-37.4c92-92,241.6-92,333.6,0c10.3,10.3,10.3,27.1,0,37.4C408.725,274.725,401.925,277.325,395.225,277.325z');
        }
        return this._middle;
    }
    /**
     * Get the inner arc of the wifi icon.
     */
    get inner() {
        if (!this._inner) {
            this._inner = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            this._inner.setAttributeNS(null, 'id', 'inner');
            this._inner.setAttributeNS(null, 'd', 'M323.625,348.825c-6.8,0-13.5-2.6-18.7-7.8c-15.4-15.4-36-23.9-57.8-23.9s-42.4,8.5-57.8,23.9c-10.3,10.3-27.1,10.3-37.4,0c-10.3-10.3-10.3-27.1,0-37.4c25.4-25.4,59.2-39.4,95.2-39.4s69.8,14,95.2,39.5c10.3,10.3,10.3,27.1,0,37.4C337.225,346.225,330.425,348.825,323.625,348.825z');
        }
        return this._inner;
    }
    /**
     * Used to set the speed of the status light.
     * @param speed - Set the speed of the blink, higher numbers make the status light blink faster.
     */
    blinkVideoQualityStatus(speed) {
        let iteration = speed;
        let opacity = 1;
        const tickID = setInterval(() => {
            opacity -= 0.1;
            this.qualityText.style.opacity = String(Math.abs((opacity - 0.5) * 2));
            if (opacity <= 0.1) {
                if (--iteration == 0) {
                    clearInterval(tickID);
                }
                else {
                    opacity = 1;
                }
            }
        }, 100 / speed);
    }
    /**
     * updates the QP tooltip by converting the Video Encoder QP to a color light
     * @param QP - The video encoder QP number needed to find the average
     */
    updateQpTooltip(QP) {
        var _a;
        this.videoEncoderAvgQP = QP;
        if (QP > this.redQP) {
            this.color = 'red';
            this.blinkVideoQualityStatus(2);
            this.statsText = `<div style="color: ${this.color}">Poor encoding quality</div>`;
            this.outer.setAttributeNS(null, 'fill', '#3c3b40');
            this.middle.setAttributeNS(null, 'fill', '#3c3b40');
            this.inner.setAttributeNS(null, 'fill', this.color);
            this.dot.setAttributeNS(null, 'fill', this.color);
        }
        else if (QP > this.orangeQP) {
            this.color = 'orange';
            this.blinkVideoQualityStatus(1);
            this.statsText = `<div style="color: ${this.color}">Blocky encoding quality</div>`;
            this.outer.setAttributeNS(null, 'fill', '#3c3b40');
            this.middle.setAttributeNS(null, 'fill', this.color);
            this.inner.setAttributeNS(null, 'fill', this.color);
            this.dot.setAttributeNS(null, 'fill', this.color);
        }
        else if (QP <= 0) {
            this.color = '#b0b0b0';
            this.outer.setAttributeNS(null, 'fill', '#3c3b40');
            this.middle.setAttributeNS(null, 'fill', '#3c3b40');
            this.inner.setAttributeNS(null, 'fill', '#3c3b40');
            this.dot.setAttributeNS(null, 'fill', '#3c3b40');
            this.statsText = `<div style="color: ${this.color}">Not connected</div>`;
        }
        else {
            this.color = 'lime';
            this.qualityStatus.style.opacity = ((_a = this.config) === null || _a === void 0 ? void 0 : _a.hideWhenGood) == true ? '0' : '1';
            this.statsText = `<div style="color: ${this.color}">Clear encoding quality</div>`;
            this.outer.setAttributeNS(null, 'fill', this.color);
            this.middle.setAttributeNS(null, 'fill', this.color);
            this.inner.setAttributeNS(null, 'fill', this.color);
            this.dot.setAttributeNS(null, 'fill', this.color);
        }
        this.qualityText.innerHTML = this.statsText;
    }
}
//# sourceMappingURL=VideoQpIndicator.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/UI/XRIcon.js":
/*!**********************************************!*\
  !*** ../../ui-library/dist/esm/UI/XRIcon.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   XRIcon: () => (/* binding */ XRIcon)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * XR icon that can be clicked.
 */
class XRIcon {
    /**
     * Get the the button containing the XR icon.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('button');
            this._rootElement.type = 'button';
            this._rootElement.classList.add('UiTool');
            this._rootElement.id = 'xrBtn';
            this._rootElement.appendChild(this.xrIcon);
            this._rootElement.appendChild(this.tooltipText);
        }
        return this._rootElement;
    }
    get tooltipText() {
        if (!this._tooltipText) {
            this._tooltipText = document.createElement('span');
            this._tooltipText.classList.add('tooltiptext');
            this._tooltipText.innerHTML = 'XR';
        }
        return this._tooltipText;
    }
    get xrIcon() {
        if (!this._xrIcon) {
            this._xrIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._xrIcon.setAttributeNS(null, 'id', 'xrIcon');
            this._xrIcon.setAttributeNS(null, 'x', '0px');
            this._xrIcon.setAttributeNS(null, 'y', '0px');
            this._xrIcon.setAttributeNS(null, 'viewBox', '0 0 100 100');
            // create svg group for the paths
            const svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svgGroup.classList.add('svgIcon');
            this._xrIcon.appendChild(svgGroup);
            // create paths for the icon itself, the path of the xr headset
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttributeNS(null, 'd', 'M29 41c-5 0-9 4-9 9s4 9 9 9 9-4 9-9-4-9-9-9zm0 14c-2.8 0-5-2.2-5-5s2.2-5 5-5 5 2.2 5 5-2.2 5-5 5zm42-14c-5 0-9 4-9 9s4 9 9 9 9-4 9-9-4-9-9-9zm0 14c-2.8 0-5-2.2-5-5s2.2-5 5-5 5 2.2 5 5-2.2 5-5 5zm12-31H17c-6.6 0-12 5.4-12 12v28c0 6.6 5.4 12 12 12h14.5c3.5 0 6.8-1.5 9-4.1l3.5-4c1.5-1.7 3.7-2.7 6-2.7s4.5 1 6 2.7l3.5 4c2.3 2.6 5.6 4.1 9 4.1H83c6.6 0 12-5.4 12-12V36c0-6.6-5.4-12-12-12zm8 40c0 4.4-3.6 8-8 8H68.5c-2.3 0-4.5-1-6-2.7l-3.5-4c-2.3-2.6-5.6-4.1-9-4.1-3.5 0-6.8 1.5-9 4.1l-3.5 4C36 71 33.8 72 31.5 72H17c-4.4 0-8-3.6-8-8V36c0-4.4 3.6-8 8-8h66c4.4 0 8 3.6 8 8v28z');
            svgGroup.appendChild(path);
        }
        return this._xrIcon;
    }
}
//# sourceMappingURL=XRIcon.js.map

/***/ }),

/***/ "../../ui-library/dist/esm/Util/MathUtils.js":
/*!***************************************************!*\
  !*** ../../ui-library/dist/esm/Util/MathUtils.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MathUtils: () => (/* binding */ MathUtils)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class MathUtils {
    /**
     * formats Bytes coming in for video stats
     * @param bytes - number to convert
     * @param decimals - number of decimal places
     */
    static formatBytes(bytes, decimals) {
        if (bytes === 0) {
            return '0';
        }
        const factor = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
        const i = Math.floor(Math.log(bytes) / Math.log(factor));
        return parseFloat((bytes / Math.pow(factor, i)).toFixed(dm)) + ' ' + sizes[i];
    }
}
//# sourceMappingURL=MathUtils.js.map

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!***************************!*\
  !*** ./src/stresstest.ts ***!
  \***************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PixelStreamingFrame: () => (/* binding */ PixelStreamingFrame),
/* harmony export */   StressTester: () => (/* binding */ StressTester)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../../Common/dist/esm/Logger/Logger.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/Config/Config.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ue5.6 */ "../../library/dist/esm/PixelStreaming/PixelStreaming.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ui_ue5_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ui-ue5.6 */ "../../ui-library/dist/esm/Styles/PixelStreamingApplicationStyles.js");
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ui_ue5_6__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @epicgames-ps/lib-pixelstreamingfrontend-ui-ue5.6 */ "../../ui-library/dist/esm/Application/Application.js");
// Copyright Epic Games, Inc. All Rights Reserved.


const PixelStreamingApplicationStyles = new _epicgames_ps_lib_pixelstreamingfrontend_ui_ue5_6__WEBPACK_IMPORTED_MODULE_0__.PixelStreamingApplicationStyle();
PixelStreamingApplicationStyles.applyStyleSheet();
class PixelStreamingFrame {
    constructor(element, pixelStreamingApp) {
        this.element = element;
        this.pixelStreamingApp = pixelStreamingApp;
    }
}
// This is the entrypoint to the stress test, all setup happens here
class StressTester {
    constructor() {
        this.play = false;
        this.maxPeers = 3;
        this.totalStreams = 0;
        this.streamCreationIntervalMs = 1000;
        this.streamDeletionIntervalMs = 4000;
        this.pixelStreamingFrames = [];
        this.creationIntervalHandle = null;
        this.deletionIntervalHandle = null;
        // Get a container to put the "Pixel Streaming" pages in.
        this.streamsContainer = document.getElementById('streamsContainer');
        _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__.Logger.InitLogging(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_1__.LogLevel.Warning, true);
    }
    startStressTest() {
        this.setupNumPeersSlider();
        this.startStreamCreation();
        this.startStreamDeletion();
        this.setupPlayPause();
        document.getElementById('creationIntervalInput').onchange = (event) => {
            const inputElem = document.getElementById('creationIntervalInput');
            const parsedValue = Number.parseInt(inputElem.value);
            if (!Number.isNaN(parsedValue)) {
                this.streamCreationIntervalMs = parsedValue * 1000.0;
                this.startStreamCreation();
            }
        };
        document.getElementById('deletionIntervalInput').onchange = (event) => {
            const inputElem = document.getElementById('deletionIntervalInput');
            const parsedValue = Number.parseInt(inputElem.value);
            if (!Number.isNaN(parsedValue)) {
                this.streamDeletionIntervalMs = parsedValue * 1000.0;
                this.startStreamDeletion();
            }
        };
        const creationIntervalInput = document.getElementById('creationIntervalInput');
        creationIntervalInput.value = (this.streamCreationIntervalMs / 1000.0).toString();
        const deletionIntervalInput = document.getElementById('deletionIntervalInput');
        deletionIntervalInput.value = (this.streamDeletionIntervalMs / 1000.0).toString();
    }
    setupNumPeersSlider() {
        const nPeersSlider = document.getElementById('nPeersSlider');
        nPeersSlider.value = this.maxPeers.toString();
        const nPeersLabel = document.getElementById('nPeerLabel');
        nPeersLabel.innerHTML = this.maxPeers.toString();
        nPeersSlider.onchange = (event) => {
            const inputElem = event.target;
            const parsedValue = Number.parseInt(inputElem.value);
            if (!Number.isNaN(parsedValue)) {
                this.maxPeers = parsedValue;
                const nPeersLabel = document.getElementById('nPeerLabel');
                nPeersLabel.innerHTML = this.maxPeers.toString();
            }
        };
    }
    startStreamCreation() {
        if (this.creationIntervalHandle) {
            clearInterval(this.creationIntervalHandle);
        }
        this.creationIntervalHandle = window.setInterval(() => {
            if (this.play) {
                const curNPeers = this.pixelStreamingFrames.length;
                if (curNPeers >= this.maxPeers)
                    return;
                const maxPeersToCreate = this.maxPeers - curNPeers;
                const nPeersToCreate = Math.ceil(Math.random() * maxPeersToCreate);
                for (let i = 0; i < nPeersToCreate; i++) {
                    const psFrame = this.createPixelStreamingFrame();
                    const n = this.pixelStreamingFrames.length;
                    psFrame.element.id = `PixelStreamingFrame_${n + 1}`;
                    this.streamsContainer.append(psFrame.element);
                    this.pixelStreamingFrames.push(psFrame);
                    this.totalStreams += 1;
                    this.updateTotalStreams();
                }
            }
        }, this.streamCreationIntervalMs);
    }
    startStreamDeletion() {
        if (this.deletionIntervalHandle) {
            clearInterval(this.deletionIntervalHandle);
        }
        this.deletionIntervalHandle = window.setInterval(() => {
            if (!this.play)
                return;
            const curNPeers = this.pixelStreamingFrames.length;
            if (curNPeers === 0)
                return;
            const nPeersToDelete = Math.ceil(Math.random() * curNPeers);
            for (let i = 0; i < nPeersToDelete; i++) {
                const psFrame = this.pixelStreamingFrames.shift();
                // Remove HTML element from DOM
                psFrame.element.parentNode.removeChild(psFrame.element);
                // Disconnect Pixel Streaming application so we don't have orphaned WebRTC/WebSocket/PeerConnections
                psFrame.pixelStreamingApp.stream.disconnect();
                psFrame === null || psFrame === void 0 ? void 0 : psFrame.pixelStreamingApp.stream.webRtcController.destroyVideoPlayer();
            }
        }, this.streamDeletionIntervalMs);
    }
    setupPlayPause() {
        const playPauseBtn = document.getElementById('playPause');
        playPauseBtn.innerHTML = this.play ? 'Pause' : 'Play';
        playPauseBtn.onclick = (event) => {
            this.play = !this.play;
            playPauseBtn.innerHTML = this.play ? 'Pause' : 'Play';
        };
    }
    createPixelStreamingFrame() {
        const streamFrame = document.createElement('div');
        const config = new _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_2__.Config();
        config.setFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_2__.Flags.AutoConnect, true);
        config.setFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_2__.Flags.AutoPlayVideo, true);
        config.setFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_2__.Flags.StartVideoMuted, true);
        // Create a Native DOM delegate instance that implements the Delegate interface class
        const stream = new _epicgames_ps_lib_pixelstreamingfrontend_ue5_6__WEBPACK_IMPORTED_MODULE_3__.PixelStreaming(config);
        const application = new _epicgames_ps_lib_pixelstreamingfrontend_ui_ue5_6__WEBPACK_IMPORTED_MODULE_4__.Application({
            stream,
            onColorModeChanged: (isLightMode) => PixelStreamingApplicationStyles.setColorMode(isLightMode)
        });
        streamFrame.appendChild(application.rootElement);
        return new PixelStreamingFrame(streamFrame, application);
    }
    updateTotalStreams() {
        const nStreamsLabel = document.getElementById('nStreamsLabel');
        nStreamsLabel.innerHTML = this.totalStreams.toString();
    }
}
const tester = new StressTester();
tester.startStressTest();

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyZXNzdGVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTzs7Ozs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxnRUFBZ0U7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxnRUFBZ0U7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsOENBQThDLEtBQUssSUFBSSxNQUFNO0FBQzdELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hQQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4RkE7QUFDMEM7QUFDVztBQUNyRDtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMsNkRBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFlBQVksa0RBQU0sOERBQThELGNBQWM7QUFDOUYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNDQUFzQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG1E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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEcrRDtBQUMvRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNkRBQWU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsb0ZBQWM7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOEVBQVEsR0FBRztBQUNqQztBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQiwyQkFBMkI7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQiwyQkFBMkI7QUFDckQsc0RBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiw4RUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0JBQWdCO0FBQ3JCO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsOEVBQVEsR0FBRztBQUM5QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBCQUEwQiwyQkFBMkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4RUFBUSxHQUFHO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix3Q0FBd0M7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQix5Q0FBeUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7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OztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxJQUEwQjtBQUM5QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNqeUJBLG1CQUFtQixhQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsaUVBQWUsT0FBTyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuQnZCO0FBQzREO0FBQ1U7QUFDNkQ7QUFDNUg7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QseUVBQXlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw2REFBaUI7QUFDaEUsc0NBQXNDLGlEQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaURBQUs7QUFDMUQ7QUFDQSwwR0FBMEcsNkRBQWlCO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1RUFBdUI7QUFDckU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDREQUE0RCw2REFBaUI7QUFDN0U7QUFDQSw4Q0FBOEMscUVBQXFCLEdBQUcsMkJBQTJCO0FBQ2pHO0FBQ0EsdUNBQXVDLGlEQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdFQUFnQjtBQUN0RTtBQUNBLGdCQUFnQixnRkFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxxRUFBcUIsR0FBRywyQkFBMkI7QUFDekc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6R0E7QUFDc0U7QUFDMUI7QUFDSTtBQUNKO0FBQ0k7QUFDWTtBQUNSO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9EQUFvRDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UscURBQVc7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQyxtRUFBbUUseURBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0REFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDREQUFZO0FBQ3ZEO0FBQ0Esb0RBQW9ELHFCQUFxQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUseURBQWE7QUFDcEY7QUFDQSxzQ0FBc0MsNERBQVk7QUFDbEQseUVBQXlFLHlEQUFhO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMscURBQVc7QUFDekQ7QUFDQTtBQUNBLGdEQUFnRCxxREFBVztBQUMzRDtBQUNBO0FBQ0EseUNBQXlDLHFEQUFXO0FBQ3BEO0FBQ0E7QUFDQSx1REFBdUQscURBQVc7QUFDbEU7QUFDQTtBQUNBLDRDQUE0QyxxREFBVztBQUN2RDtBQUNBO0FBQ0Esa0RBQWtELHFEQUFXO0FBQzdEO0FBQ0E7QUFDQSxzREFBc0QscURBQVc7QUFDakU7QUFDQTtBQUNBLHNEQUFzRCxxREFBVztBQUNqRTtBQUNBO0FBQ0EsaURBQWlELHFEQUFXO0FBQzVEO0FBQ0E7QUFDQSw0Q0FBNEMscURBQVc7QUFDdkQ7QUFDQTtBQUNBLCtDQUErQyxxREFBVztBQUMxRDtBQUNBO0FBQ0EsMERBQTBELHFEQUFXO0FBQ3JFO0FBQ0E7QUFDQSxvREFBb0QscURBQVc7QUFDL0Q7QUFDQTtBQUNBLCtDQUErQyx5Q0FBeUM7QUFDeEYsU0FBUztBQUNULHVEQUF1RCxxREFBVztBQUNsRTtBQUNBO0FBQ0EsZ0RBQWdELHFEQUFXO0FBQzNEO0FBQ0E7QUFDQSw2Q0FBNkMscURBQVc7QUFDeEQ7QUFDQTtBQUNBLDZDQUE2QyxxREFBVztBQUN4RDtBQUNBO0FBQ0EsK0NBQStDLHFEQUFXO0FBQzFEO0FBQ0E7QUFDQSxvREFBb0QscURBQVc7QUFDL0Q7QUFDQTtBQUNBLGtEQUFrRCxxREFBVztBQUM3RDtBQUNBO0FBQ0EseUNBQXlDLHFEQUFXO0FBQ3BEO0FBQ0E7QUFDQSx1REFBdUQscURBQVc7QUFDbEU7QUFDQTtBQUNBLG1EQUFtRCxxREFBVztBQUM5RDtBQUNBO0FBQ0EsNkNBQTZDLHFEQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUseURBQWE7QUFDdEY7QUFDQTtBQUNBLDJFQUEyRSx5REFBYTtBQUN4RiwrRUFBK0UseURBQWE7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHlEQUFhO0FBQzdFO0FBQ0E7QUFDQSxnRUFBZ0UseURBQWE7QUFDN0U7QUFDQTtBQUNBLHFFQUFxRSx5REFBYTtBQUNsRjtBQUNBO0FBQ0EscUVBQXFFLHlEQUFhO0FBQ2xGO0FBQ0E7QUFDQSwyRUFBMkUseURBQWE7QUFDeEY7QUFDQTtBQUNBLDJFQUEyRSx5REFBYTtBQUN4RjtBQUNBO0FBQ0Esb0VBQW9FLHlEQUFhO0FBQ2pGO0FBQ0E7QUFDQSwyRUFBMkUseURBQWE7QUFDeEY7QUFDQTtBQUNBLDJFQUEyRSx5REFBYTtBQUN4RjtBQUNBO0FBQ0EsbUZBQW1GLHlEQUFhO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSx5REFBYTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsR0FBRztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLEdBQUc7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLEdBQUc7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTSxzQ0FBc0MsSUFBSTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdGQUFNLDJDQUEyQyxJQUFJO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU0sMkNBQTJDLElBQUk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTSwyQ0FBMkMsSUFBSTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdGQUFNLDZDQUE2QyxJQUFJO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLG9FQUFvQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLG9FQUFvQjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLG9FQUFvQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLG9FQUFvQjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7Ozs7Ozs7Ozs7Ozs7O0FDcGtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1Q0FBdUMsa0JBQWtCLEdBQUcsVUFBVSxPQUFPLGtCQUFrQjtBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUM1RkE7QUFDNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ08sMEJBQTBCLHFEQUFXO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDM0NBO0FBQzRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNPLDRCQUE0QixxREFBVztBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzdFQTtBQUNzRTtBQUMxQjtBQUM1QztBQUNBO0FBQ0E7QUFDTyw0QkFBNEIscURBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdHQTtBQUNvRDtBQUNrQjtBQUM3QjtBQUNFO0FBQzNDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZEQUFlO0FBQ3ZDO0FBQ0EsMEJBQTBCLDZEQUFlO0FBQ3pDLHlC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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6RkE7QUFDc0U7QUFDbEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ08sb0NBQW9DLDZEQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdGQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDZkE7QUFDc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0NBQXNDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0NBQXNDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxZQUFZLGdGQUFNLFVBQVUscUNBQXFDLElBQUksRUFBRSxJQUFJLEVBQUU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNyVEE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNElBQTRJLEtBQUs7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUgsS0FBSztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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REFBOEQsNERBQWdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlIQUFpSCx1QkFBdUI7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvREFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlIQUFpSCx1QkFBdUI7QUFDeEk7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdGQUFnQjtBQUMxQyxZQUFZLGdGQUFNLHdEQUF3RCxLQUFLO0FBQy9FO0FBQ0E7QUFDQSwwQkFBMEIsd0ZBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3ZxQkE7QUFDc0U7QUFDL0Q7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRkFBTTtBQUNkO0FBQ0EsUUFBUSxnRkFBTTtBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDc0U7QUFDL0Q7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdGQUFNLHlFQUF5RSxZQUFZO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU0sMEVBQTBFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiw2QkFBNkIsbUJBQW1CLHlEQUF5RDtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFlBQVksZ0ZBQU0saUVBQWlFLGFBQWEsSUFBSSw0QkFBNEI7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JIQTtBQUNzRTtBQUMvRDtBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdGQUFNLG1DQUFtQyxpQkFBaUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3Qzs7Ozs7Ozs7Ozs7Ozs7QUNqTkE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzdDQTtBQUNzRTtBQUMvRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTTtBQUNsQix3RUFBd0UscUJBQXFCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UscUJBQXFCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbllBO0FBQ3NFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU07QUFDbEI7QUFDQTtBQUNBLFFBQVEsZ0ZBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU07QUFDbEI7QUFDQTtBQUNBLFFBQVEsZ0ZBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0ZBQU0sOEJBQThCLGlCQUFpQixHQUFHLFlBQVk7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTTtBQUNsQjtBQUNBO0FBQ0EsWUFBWSxnRkFBTSxtQ0FBbUMsZ0JBQWdCLFlBQVkseUJBQXlCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxxQkFBcUI7QUFDeEU7QUFDQTtBQUNBLG1EQUFtRCxlQUFlO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU0sZ0RBQWdELGlCQUFpQixHQUFHLFlBQVk7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM3Q0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDckNBO0FBQ3NFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdGQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdGQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQy9EQTtBQUN5QztBQUM2QjtBQUN0RTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaURBQUs7QUFDakUsK0RBQStELGlEQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlLGdCQUFnQjtB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LFFBQVEsZ0ZBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdGQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsaURBQUs7QUFDNUQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUNBQXVDLDREQUFZLEdBQUcsYUFBYTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0ZBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwV0E7QUFDaUc7QUFDdEM7QUFDTTtBQUNaO0FBQ0E7QUFDRTtBQUNKO0FBQ1Q7QUFDWTtBQUNGO0FBQ047QUFDWTtBQUNaO0FBQ007QUFDMkM7QUFDakM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNEQUFRO0FBQ3BDO0FBQ0EsWUFBWSx3RUFBYztBQUMxQjtBQUNBLGtDQUFrQyxzREFBVTtBQUM1QztBQUNBO0FBQ0EsWUFBWSx3RUFBYztBQUMxQjtBQUNBLHFDQUFxQyw0REFBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtFQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGdFQUFVO0FBQ3RFLHdEQUF3RCxpRkFBSztBQUM3RDtBQUNBLFNBQVM7QUFDVCw2Q0FBNkMsaUZBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx5RUFBaUI7QUFDdEQsa0NBQWtDLG1FQUFjO0FBQ2hELCtCQUErQiw2REFBVztBQUMxQywrQkFBK0IsNkRBQVc7QUFDMUMsZ0NBQWdDLGdFQUFZO0FBQzVDLDhCQUE4Qiw0REFBVTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYywyRUFBcUI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbURBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSwyRUFBcUI7QUFDekY7QUFDQSxvQkFBb0IsdUVBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwyRUFBcUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsK0RBQWM7QUFDcEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDRDQUE0QywrREFBYztBQUMxRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsOENBQThDLCtEQUFjO0FBQzVEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGdFQUFVO0FBQ3RFLDZDQUE2QyxnRUFBVSw2QkFBNkIsZ0NBQWdDO0FBQ3BIO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4REFBOEQsUUFBUSx5QkFBeUI7QUFDL0YsNERBQTRELFFBQVEsYUFBYTtBQUNqRjtBQUNBO0FBQ0EsNkRBQTZELFFBQVEsU0FBUztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFFBQVEsc0NBQXNDO0FBQzVHO0FBQ0E7QUFDQSwyREFBMkQsUUFBUSxXQUFXO0FBQzlFO0FBQ0EsOERBQThELFFBQVEsVUFBVTtBQUNoRiwyREFBMkQsUUFBUSx5QkFBeUI7QUFDNUYseURBQXlELFFBQVEsbUJBQW1CO0FBQ3BGLDZEQUE2RCxRQUFRLGVBQWU7QUFDcEYsNkRBQTZELFFBQVEsa0JBQWtCO0FBQ3ZGLHdFQUF3RSxRQUFRLFVBQVU7QUFDMUYsK0RBQStELFFBQVEsaUVBQWlFO0FBQ3hJLDJEQUEyRCxRQUFRLFdBQVc7QUFDOUU7QUFDQSx1REFBdUQsUUFBUSxTQUFTO0FBQ3hFLHFFQUFxRSxtRkFBTTtBQUMzRTtBQUNBO0FBQ0Esa0RBQWtELGlGQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGlGQUFLO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFFQUFxRTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2REFBTSxJQUFJLGlFQUFTO0FBQ3pDO0FBQ0E7QUFDQSxRQUFRLDJDQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBLFFBQVEsMkNBQUc7QUFDWCxxREFBcUQ7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbGtCQTtBQUNrRDtBQUNKO0FBQ047QUFDTjtBQUMrQztBQUNkO0FBQ25FO0FBQ0E7QUFDQSw0REFBNEQsMkVBQXFCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaURBQVM7QUFDMUM7QUFDQTtBQUNBLG9DQUFvQyx1REFBWTtBQUNoRDtBQUNBO0FBQ0Esc0NBQXNDLDJEQUFjO0FBQ3BEO0FBQ0E7QUFDQSw4QkFBOEIsMkNBQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkZBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RUE7QUFDd0U7QUFDakI7QUFDdkQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdFQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtGQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxvQkFBb0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3RHQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2pEQTtBQUN3RTtBQUNqQjtBQUN2RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0VBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcERBO0FBQzRDO0FBQ21DO0FBQ2pDO0FBQ29CO0FBQ3RCO0FBQzZCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxpRkFBSyxtQkFBbUIscURBQVc7QUFDekYsK0JBQStCLHFEQUFXO0FBQzFDLDBDQUEwQywyRUFBc0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVFQUFnQixlQUFlLGdFQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1RUFBZ0IsZUFBZSxnRUFBYTtBQUM1RDtBQUNBLDZDQUE2QyxnRUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUVBQWdCLGVBQWUsZ0VBQWE7QUFDNUQ7QUFDQSw2Q0FBNkMsZ0VBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVFQUFnQixlQUFlLGdFQUFhO0FBQzVEO0FBQ0E7QUFDQSxnQkFBZ0IsdUVBQWdCLGVBQWUsZ0VBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtGQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzREFBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0ZBQU0scUNBQXFDLHNCQUFzQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0VBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0VBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnRUFBYTtBQUN2QyxhQUFhLHVFQUFnQixlQUFlLGdFQUFhO0FBQ3pEO0FBQ0E7QUFDQSwwQkFBMEIsZ0VBQWE7QUFDdkMsYUFBYSx1RUFBZ0IsZUFBZSxnRUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0VBQWEsK0JBQStCLGdFQUFhO0FBQ25GO0FBQ0E7QUFDQSx5Q0FBeUMsZ0VBQWE7QUFDdEQsNEJBQTRCLFVBQVUsSUFBSSxLQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNYQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEO0FBQ2hEO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsV0FBVztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFdBQVc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxXQUFXO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFdBQVc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztB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O1FBRWxELE1BQU0sTUFBTSxHQUFHLElBQUksa0ZBQU0sRUFBRSxDQUFDO1FBQzVCLE1BQU0sQ0FBQyxjQUFjLENBQUMsaUZBQUssQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDL0MsTUFBTSxDQUFDLGNBQWMsQ0FBQyxpRkFBSyxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNqRCxNQUFNLENBQUMsY0FBYyxDQUFDLGlGQUFLLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRW5ELHFGQUFxRjtRQUNyRixNQUFNLE1BQU0sR0FBRyxJQUFJLDBGQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDMUMsTUFBTSxXQUFXLEdBQUcsSUFBSSwwRkFBVyxDQUFDO1lBQ2hDLE1BQU07WUFDTixrQkFBa0IsRUFBRSxDQUFDLFdBQWdCLEVBQUUsRUFBRSxDQUNyQywrQkFBK0IsQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDO1NBQ2hFLENBQUMsQ0FBQztRQUNILFdBQVcsQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRWpELE9BQU8sSUFBSSxtQkFBbUIsQ0FBQyxXQUFXLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDN0QsQ0FBQztJQUVPLGtCQUFrQjtRQUN0QixNQUFNLGFBQWEsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQy9ELGFBQWEsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUMzRCxDQUFDO0NBQ0o7QUFFRCxNQUFNLE1BQU0sR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO0FBQ2xDLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL0NvbW1vbi9kaXN0L2VzbS9FdmVudC9FdmVudEVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL0NvbW1vbi9kaXN0L2VzbS9Mb2dnZXIvTG9nZ2VyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9Db21tb24vZGlzdC9lc20vTWVzc2FnZXMvbWVzc2FnZV9oZWxwZXJzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9Db21tb24vZGlzdC9lc20vTWVzc2FnZXMvbWVzc2FnZV9yZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vQ29tbW9uL2Rpc3QvZXNtL01lc3NhZ2VzL3NpZ25hbGxpbmdfbWVzc2FnZXMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL0NvbW1vbi9kaXN0L2VzbS9Qcm90b2NvbC9LZWVwYWxpdmVNb25pdG9yLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9Db21tb24vZGlzdC9lc20vUHJvdG9jb2wvU2lnbmFsbGluZ1Byb3RvY29sLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9Db21tb24vZGlzdC9lc20vVHJhbnNwb3J0L1dlYlNvY2tldFRyYW5zcG9ydC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vQ29tbW9uL2Rpc3QvZXNtL1V0aWwvU2RwVXRpbHMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9QcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1Byb3BlcnR5S2V5LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L2Fzc2VydC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvYmluYXJ5LWZvcm1hdC1jb250cmFjdC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9iaW5hcnktcmVhZGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L2JpbmFyeS13cml0ZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvZ29vZy12YXJpbnQuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvanNvbi1mb3JtYXQtY29udHJhY3QuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvanNvbi10eXBpbmdzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L2xvd2VyLWNhbWVsLWNhc2UuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvbWVzc2FnZS10eXBlLWNvbnRyYWN0LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L21lc3NhZ2UtdHlwZS5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9vbmVvZi5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9wYi1sb25nLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L3JlZmxlY3Rpb24tYmluYXJ5LXJlYWRlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9yZWZsZWN0aW9uLWJpbmFyeS13cml0ZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvcmVmbGVjdGlvbi1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvcmVmbGVjdGlvbi1lcXVhbHMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvcmVmbGVjdGlvbi1pbmZvLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmLXRzL3J1bnRpbWUvYnVpbGQvZXMyMDE1L3JlZmxlY3Rpb24tanNvbi1yZWFkZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvcmVmbGVjdGlvbi1qc29uLXdyaXRlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9yZWZsZWN0aW9uLWxvbmctY29udmVydC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9yZWZsZWN0aW9uLW1lcmdlLXBhcnRpYWwuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWYtdHMvcnVudGltZS9idWlsZC9lczIwMTUvcmVmbGVjdGlvbi1zY2FsYXItZGVmYXVsdC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1Zi10cy9ydW50aW1lL2J1aWxkL2VzMjAxNS9yZWZsZWN0aW9uLXR5cGUtY2hlY2suanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9oeXBoZW5hdGUtc3R5bGUtbmFtZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2lzLWluLWJyb3dzZXIvZGlzdC9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLWNhbWVsLWNhc2UvZGlzdC9qc3MtcGx1Z2luLWNhbWVsLWNhc2UuZXNtLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvanNzLXBsdWdpbi1nbG9iYWwvZGlzdC9qc3MtcGx1Z2luLWdsb2JhbC5lc20uanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qc3MvZGlzdC9qc3MuZXNtLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2RwL3NkcC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Rpbnktd2FybmluZy9kaXN0L3Rpbnktd2FybmluZy5lc20uanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vQUZLL0FGS0NvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vQ29uZmlnL0NvbmZpZy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9Db25maWcvU2V0dGluZ0Jhc2UuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vQ29uZmlnL1NldHRpbmdGbGFnLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0NvbmZpZy9TZXR0aW5nTnVtYmVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0NvbmZpZy9TZXR0aW5nT3B0aW9uLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0NvbmZpZy9TZXR0aW5nVGV4dC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9EYXRhQ2hhbm5lbC9EYXRhQ2hhbm5lbENvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vRGF0YUNoYW5uZWwvRGF0YUNoYW5uZWxMYXRlbmN5VGVzdENvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vRGF0YUNoYW5uZWwvRGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlc3VsdHMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vRGF0YUNoYW5uZWwvRGF0YUNoYW5uZWxTZW5kZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vRGF0YUNoYW5uZWwvSW5pdGlhbFNldHRpbmdzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0RhdGFDaGFubmVsL0xhdGVuY3lUZXN0UmVzdWx0cy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9GcmVlemVGcmFtZS9GcmVlemVGcmFtZS5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9GcmVlemVGcmFtZS9GcmVlemVGcmFtZUNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vSW5wdXRzL0dhbWVwYWRDb250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0lucHV0cy9HYW1lcGFkVHlwZXMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vSW5wdXRzL0lucHV0Q2xhc3Nlc0ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vSW5wdXRzL0tleUNvZGVzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0lucHV0cy9LZXlib2FyZENvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vSW5wdXRzL01vdXNlQnV0dG9ucy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9JbnB1dHMvTW91c2VDb250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0lucHV0cy9Nb3VzZUNvbnRyb2xsZXJIb3ZlcmluZy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9JbnB1dHMvTW91c2VDb250cm9sbGVyTG9ja2VkLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL0lucHV0cy9TcGVjaWFsS2V5Q29kZXMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vSW5wdXRzL1RvdWNoQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9JbnB1dHMvVG91Y2hDb250cm9sbGVyRmFrZS5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9JbnB1dHMvWFJHYW1lcGFkQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9QZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIvQWdncmVnYXRlZFN0YXRzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1BlZXJDb25uZWN0aW9uQ29udHJvbGxlci9DYW5kaWRhdGVTdGF0LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1BlZXJDb25uZWN0aW9uQ29udHJvbGxlci9EYXRhQ2hhbm5lbFN0YXRzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1BlZXJDb25uZWN0aW9uQ29udHJvbGxlci9JbmJvdW5kUlRQU3RhdHMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vUGVlckNvbm5lY3Rpb25Db250cm9sbGVyL0xhdGVuY3lDYWxjdWxhdG9yLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1BlZXJDb25uZWN0aW9uQ29udHJvbGxlci9PdXRCb3VuZFJUUFN0YXRzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1BlZXJDb25uZWN0aW9uQ29udHJvbGxlci9QZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vUGVlckNvbm5lY3Rpb25Db250cm9sbGVyL1Nlc3Npb25TdGF0cy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9QZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIvU3RyZWFtU3RhdHMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vUGl4ZWxTdHJlYW1pbmcvUGl4ZWxTdHJlYW1pbmcuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vVWVJbnN0YW5jZU1lc3NhZ2UvUmVzcG9uc2VDb250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1VlSW5zdGFuY2VNZXNzYWdlL1NlbmRNZXNzYWdlQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9VZUluc3RhbmNlTWVzc2FnZS9TdHJlYW1NZXNzYWdlQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9VZUluc3RhbmNlTWVzc2FnZS9Ub1N0cmVhbWVyTWVzc2FnZXNDb250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1V0aWwvQnJvd3NlclV0aWxzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1V0aWwvRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1V0aWwvRmlsZVV0aWwuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vVXRpbC9JVVJMU2VhcmNoUGFyYW1zLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1V0aWwvSW5wdXRDb29yZFRyYW5zbGF0b3IuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL2xpYnJhcnkvZGlzdC9lc20vVXRpbC9SVENVdGlscy5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vbGlicmFyeS9kaXN0L2VzbS9WaWRlb1BsYXllci9TdHJlYW1Db250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1ZpZGVvUGxheWVyL1ZpZGVvUGxheWVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1dlYlJ0Y1BsYXllci9XZWJSdGNQbGF5ZXJDb250cm9sbGVyLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi9saWJyYXJ5L2Rpc3QvZXNtL1dlYlhSL1dlYlhSQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9BcHBsaWNhdGlvbi9BcHBsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9Db25maWcvQ29uZmlnVUkuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vQ29uZmlnL1NldHRpbmdVSUJhc2UuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vQ29uZmlnL1NldHRpbmdVSUZsYWcuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vQ29uZmlnL1NldHRpbmdVSU51bWJlci5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9Db25maWcvU2V0dGluZ1VJT3B0aW9uLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL0NvbmZpZy9TZXR0aW5nVUlUZXh0LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL092ZXJsYXkvQUZLT3ZlcmxheS5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9PdmVybGF5L0FjdGlvbk92ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vT3ZlcmxheS9CYXNlT3ZlcmxheS5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9PdmVybGF5L0Nvbm5lY3RPdmVybGF5LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL092ZXJsYXkvRGlzY29ubmVjdE92ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vT3ZlcmxheS9FcnJvck92ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vT3ZlcmxheS9JbmZvT3ZlcmxheS5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9PdmVybGF5L1BsYXlPdmVybGF5LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL092ZXJsYXkvVGV4dE92ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vU3R5bGVzL1BpeGVsU3RyZWFtaW5nQXBwbGljYXRpb25TdHlsZXMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vVUkvQ29udHJvbHMuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vVUkvRGF0YUNoYW5uZWxMYXRlbmN5VGVzdC5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9VSS9FZGl0VGV4dE1vZGFsLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL1VJL0Z1bGxzY3JlZW5JY29uLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL1VJL0xhYmVsbGVkQnV0dG9uLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL1VJL0xhdGVuY3lUZXN0LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL1VJL1Nlc3Npb25UZXN0LmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL1VJL1NldHRpbmdzSWNvbi5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9VSS9TZXR0aW5nc1BhbmVsLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL1VJL1N0YXRzSWNvbi5qcyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi4vLi4vdWktbGlicmFyeS9kaXN0L2VzbS9VSS9TdGF0c1BhbmVsLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL1VJL1VJQ29uZmlndXJhdGlvblR5cGVzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL1VJL1ZpZGVvUXBJbmRpY2F0b3IuanMiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kLy4uLy4uL3VpLWxpYnJhcnkvZGlzdC9lc20vVUkvWFJJY29uLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC8uLi8uLi91aS1saWJyYXJ5L2Rpc3QvZXNtL1V0aWwvTWF0aFV0aWxzLmpzIiwid2VicGFjazovL2VwaWNnYW1lcy1mcm9udGVuZC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vZXBpY2dhbWVzLWZyb250ZW5kL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9lcGljZ2FtZXMtZnJvbnRlbmQvLi9zcmMvc3RyZXNzdGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJlcGljZ2FtZXMtZnJvbnRlbmRcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZXBpY2dhbWVzLWZyb250ZW5kXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgKCkgPT4ge1xucmV0dXJuICIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBUbyBtYXRjaCBOb2RlSlMnIEV2ZW50RW1pdHRlciBzeW50YXggd2l0aG91dCBkb3duc3RyZWFtIGNvZGUgY2hhbmdlcyB3ZSBuZWVkIHRvIHVzZSBgYW55YC5cbi8vIFRoaXMgbWVhbnMgd2UgbmVlZCB0byBkaXNhYmxlIGxpbnRpbmcgYGFueWAgY2hlY2tzIG9uIHRoaXMgZmlsZS5cbi8vXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50ICovXG5jbGFzcyBQaXhlbFN0cmVhbWluZ0V2ZW50TGlzdGVuZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2FyZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoX2V2dCkge1xuICAgICAgICB0aGlzLl9jYWxsYmFjayguLi50aGlzLl9hcmdzKTtcbiAgICAgICAgLy8gUmVzZXQgc3RvcmFnZSBvZiBhcmdzLlxuICAgICAgICB0aGlzLl9hcmdzID0gW107XG4gICAgfVxuICAgIHNldEFyZ3MoLi4uYXJncykge1xuICAgICAgICB0aGlzLl9hcmdzID0gYXJncztcbiAgICB9XG59XG4vKipcbiAqIEEgZmVhdHVyZS1saW1pdGVkLCBidXQgX21vc3RseV8gZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgTm9kZSdzIEV2ZW50RW1pdHRlciB0eXBlIHRoYXQgaXMgaW1wbGVtZW50ZWQgdXNpbmcgRXZlbnRUYXJnZXQuXG4gKlxuICogRm9yIHRob3NlIHVuZmFtaWxpYXIgd2l0aCBOb2RlJ3MgRXZlbnRFbWl0dGVyLCBoZXJlIGlzIHNvbWUgaW5mbyBmcm9tIHRoZSBvZmZpY2lhbCBkb2NzOlxuICpcbiAqIFtJbiBOb2RlSlNdIGFsbCBvYmplY3RzIHRoYXQgZW1pdCBldmVudHMgYXJlIGluc3RhbmNlcyBvZiB0aGUgYEV2ZW50RW1pdHRlcmAgY2xhc3MuIFRoZXNlXG4gKiBvYmplY3RzIGV4cG9zZSBhbiBgZXZlbnRFbWl0dGVyLm9uKClgIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIG9uZSBvciBtb3JlXG4gKiBmdW5jdGlvbnMgdG8gYmUgYXR0YWNoZWQgdG8gbmFtZWQgZXZlbnRzIGVtaXR0ZWQgYnkgdGhlIG9iamVjdC4gVHlwaWNhbGx5LFxuICogZXZlbnQgbmFtZXMgYXJlIGNhbWVsLWNhc2VkIHN0cmluZ3MgYnV0IGFueSB2YWxpZCBKYXZhU2NyaXB0IHByb3BlcnR5IGtleVxuICogY2FuIGJlIHVzZWQuXG4gKlxuICogV2hlbiB0aGUgYEV2ZW50RW1pdHRlcmAgb2JqZWN0IGVtaXRzIGFuIGV2ZW50LCBhbGwgb2YgdGhlIGZ1bmN0aW9ucyBhdHRhY2hlZFxuICogdG8gdGhhdCBzcGVjaWZpYyBldmVudCBhcmUgY2FsbGVkIF9zeW5jaHJvbm91c2x5Xy4gQW55IHZhbHVlcyByZXR1cm5lZCBieSB0aGVcbiAqIGNhbGxlZCBsaXN0ZW5lcnMgYXJlIF9pZ25vcmVkXyBhbmQgZGlzY2FyZGVkLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBhIHNpbXBsZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZSB3aXRoIGEgc2luZ2xlXG4gKiBsaXN0ZW5lci4gVGhlIGBldmVudEVtaXR0ZXIub24oKWAgbWV0aG9kIGlzIHVzZWQgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLCB3aGlsZVxuICogdGhlIGBldmVudEVtaXR0ZXIuZW1pdCgpYCBtZXRob2QgaXMgdXNlZCB0byB0cmlnZ2VyIHRoZSBldmVudC5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnbm9kZTpldmVudHMnO1xuICpcbiAqIGNsYXNzIE15RW1pdHRlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7fVxuICpcbiAqIGNvbnN0IG15RW1pdHRlciA9IG5ldyBNeUVtaXR0ZXIoKTtcbiAqIG15RW1pdHRlci5vbignZXZlbnQnLCAoKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdhbiBldmVudCBvY2N1cnJlZCEnKTtcbiAqIH0pO1xuICogbXlFbWl0dGVyLmVtaXQoJ2V2ZW50Jyk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50RW1pdHRlciBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHJlbW92ZUxpc3RlbmVySW50ZXJuYWwoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy5fZXZlbnRMaXN0ZW5lcnMuaGFzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50UGFpciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRQYWlyLmNhbGxiYWNrID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBldmVudCB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50UGFpci5ldmVudExpc3RlbmVyV3JhcHBlcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIG91ciBpbnRlcm5hbCBtYXBcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3IgYGVtaXR0ZXIub24oZXZlbnROYW1lLCBsaXN0ZW5lcilgLlxuICAgICAqL1xuICAgIGFkZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub24oZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGBsaXN0ZW5lcmAgZnVuY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGZvciB0aGUgZXZlbnRcbiAgICAgKiBuYW1lZCBgZXZlbnROYW1lYC5cbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogc2VydmVyLm9uKCdjb25uZWN0aW9uJywgKHN0cmVhbSkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3NvbWVvbmUgY29ubmVjdGVkIScpO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAsIHNvIHRoYXQgY2FsbHMgY2FuIGJlIGNoYWluZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIFRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqL1xuICAgIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBXcmFwIG91ciBub3JtYWwgSlMgZnVuY3Rpb24gaW4gYSBldmVudCBsaXN0ZW5lciBpbnRlcmZhY2VcbiAgICAgICAgLy8gc28gd2UgY2FuIHVzZSBpdCB3aXRoIGV2ZW50IHRhcmdldC5cbiAgICAgICAgY29uc3QgZXZlbnRMaXN0ZW5lcldyYXBwZXIgPSBuZXcgUGl4ZWxTdHJlYW1pbmdFdmVudExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgc3VwZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXJXcmFwcGVyKTtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGV2ZW50IGxpc3RlbmVyL2Z1bmN0aW9uIHBhaXIgZm9yIGxhdGVyIHJlbW92YWwuXG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRMaXN0ZW5lcnMuaGFzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5ldyBBcnJheSgpKTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLl9ldmVudExpc3RlbmVyc1xuICAgICAgICAgICAgLmdldChldmVudE5hbWUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHVzaCh7IGNhbGxiYWNrOiBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lcldyYXBwZXI6IGV2ZW50TGlzdGVuZXJXcmFwcGVyIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhICoqb25lLXRpbWUqKiBgbGlzdGVuZXJgIGZ1bmN0aW9uIGZvciB0aGUgZXZlbnQgbmFtZWQgYGV2ZW50TmFtZWAuIFRoZVxuICAgICAqIG5leHQgdGltZSBgZXZlbnROYW1lYCBpcyB0cmlnZ2VyZWQsIHRoaXMgbGlzdGVuZXIgaXMgcmVtb3ZlZCBhbmQgdGhlbiBpbnZva2VkLlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBzZXJ2ZXIub25jZSgnY29ubmVjdGlvbicsIChzdHJlYW0pID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdBaCwgd2UgaGF2ZSBvdXIgZmlyc3QgdXNlciEnKTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgLCBzbyB0aGF0IGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICovXG4gICAgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gUGFzcyBvcHRpb25zIHNvIHRoaXMgZXZlbnQgY2FsbGJhY2sgaXMgb25seSBjYWxsZWQgb25jZVxuICAgICAgICBjb25zdCBldmVudExpc3RlbmVyT3B0cyA9IHsgb25jZTogdHJ1ZSB9O1xuICAgICAgICAvLyBXcmFwIG91ciBub3JtYWwgSlMgZnVuY3Rpb24gaW4gYSBldmVudCBsaXN0ZW5lciBpbnRlcmZhY2VcbiAgICAgICAgLy8gc28gd2UgY2FuIHVzZSBpdCB3aXRoIGV2ZW50IHRhcmdldCBhbmQgcmVtb3ZlIGl0IGZyb20gZXZlbnQgdGFyZ2V0IHdoZW4gdGhpcyBmdW5jdGlvbiBjb21wbGV0ZXMuXG4gICAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJXcmFwcGVyID0gbmV3IFBpeGVsU3RyZWFtaW5nRXZlbnRMaXN0ZW5lcigoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXIoYXJncyk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVySW50ZXJuYWwoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgICAgICBzdXBlci5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lcldyYXBwZXIsIGV2ZW50TGlzdGVuZXJPcHRzKTtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGV2ZW50IGxpc3RlbmVyL2Z1bmN0aW9uIHBhaXIgZm9yIGxhdGVyIHJlbW92YWwuXG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRMaXN0ZW5lcnMuaGFzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5ldyBBcnJheSgpKTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLl9ldmVudExpc3RlbmVyc1xuICAgICAgICAgICAgLmdldChldmVudE5hbWUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHVzaCh7IGNhbGxiYWNrOiBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lcldyYXBwZXI6IGV2ZW50TGlzdGVuZXJXcmFwcGVyIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGBsaXN0ZW5lcmAgZnJvbSB0aGlzIEV2ZW50RW1pdHRlci5cbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgY2FsbGJhY2sgPSAoc3RyZWFtKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygnc29tZW9uZSBjb25uZWN0ZWQhJyk7XG4gICAgICogfTtcbiAgICAgKiBzZXJ2ZXIub24oJ2Nvbm5lY3Rpb24nLCBjYWxsYmFjayk7XG4gICAgICogLy8gLi4uXG4gICAgICogc2VydmVyLnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0aW9uJywgY2FsbGJhY2spO1xuICAgICAqIGBgYFxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgLCBzbyB0aGF0IGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuICAgICAqL1xuICAgIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lckludGVybmFsKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIGBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKClgLlxuICAgICAqL1xuICAgIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgYGV2ZW50TmFtZWAuXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAsIHNvIHRoYXQgY2FsbHMgY2FuIGJlIGNoYWluZWQuXG4gICAgICovXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAodGhpcy5fZXZlbnRMaXN0ZW5lcnMuaGFzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgZWFjaCBldmVudCBsaXN0ZW5lciBmcm9tIHRoZSBldmVudCB0YXJnZXRcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXJQYWlyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyUGFpci5ldmVudExpc3RlbmVyV3JhcHBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVycyBtYXBwZWQgdG8gdGhpcyBldmVudCBmcm9tIG91ciBpbnRlcm5hbCBtYXBcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91c2x5IGNhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciB0aGUgZXZlbnQgbmFtZWQgYGV2ZW50TmFtZWAsIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgcmVnaXN0ZXJlZCwgcGFzc2luZyB0aGUgc3VwcGxpZWQgYXJndW1lbnRzXG4gICAgICogdG8gZWFjaC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnbm9kZTpldmVudHMnO1xuICAgICAqIGNvbnN0IG15RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgKlxuICAgICAqIC8vIEZpcnN0IGxpc3RlbmVyXG4gICAgICogbXlFbWl0dGVyLm9uKCdldmVudCcsIGZ1bmN0aW9uIGZpcnN0TGlzdGVuZXIoKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnSGVsbG9vb28hIGZpcnN0IGxpc3RlbmVyJyk7XG4gICAgICogfSk7XG4gICAgICogLy8gU2Vjb25kIGxpc3RlbmVyXG4gICAgICogbXlFbWl0dGVyLm9uKCdldmVudCcsIGZ1bmN0aW9uIHNlY29uZExpc3RlbmVyKGFyZzEsIGFyZzIpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGBldmVudCB3aXRoIHBhcmFtZXRlcnMgJHthcmcxfSwgJHthcmcyfSBpbiBzZWNvbmQgbGlzdGVuZXJgKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyBUaGlyZCBsaXN0ZW5lclxuICAgICAqIG15RW1pdHRlci5vbignZXZlbnQnLCBmdW5jdGlvbiB0aGlyZExpc3RlbmVyKC4uLmFyZ3MpIHtcbiAgICAgKiAgIGNvbnN0IHBhcmFtZXRlcnMgPSBhcmdzLmpvaW4oJywgJyk7XG4gICAgICogICBjb25zb2xlLmxvZyhgZXZlbnQgd2l0aCBwYXJhbWV0ZXJzICR7cGFyYW1ldGVyc30gaW4gdGhpcmQgbGlzdGVuZXJgKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG15RW1pdHRlci5saXN0ZW5lcnMoJ2V2ZW50JykpO1xuICAgICAqXG4gICAgICogbXlFbWl0dGVyLmVtaXQoJ2V2ZW50JywgMSwgMiwgMywgNCwgNSk7XG4gICAgICpcbiAgICAgKiAvLyBQcmludHM6XG4gICAgICogLy8gW1xuICAgICAqIC8vICAgW0Z1bmN0aW9uOiBmaXJzdExpc3RlbmVyXSxcbiAgICAgKiAvLyAgIFtGdW5jdGlvbjogc2Vjb25kTGlzdGVuZXJdLFxuICAgICAqIC8vICAgW0Z1bmN0aW9uOiB0aGlyZExpc3RlbmVyXVxuICAgICAqIC8vIF1cbiAgICAgKiAvLyBIZWxsb29vbyEgZmlyc3QgbGlzdGVuZXJcbiAgICAgKiAvLyBldmVudCB3aXRoIHBhcmFtZXRlcnMgMSwgMiBpbiBzZWNvbmQgbGlzdGVuZXJcbiAgICAgKiAvLyBldmVudCB3aXRoIHBhcmFtZXRlcnMgMSwgMiwgMywgNCwgNSBpbiB0aGlyZCBsaXN0ZW5lclxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudExpc3RlbmVycy5oYXMoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbnN1cmUgZWFjaCBvZiBvdXIgbGlzdGVuZXJzIGhhdmUgdGhlIGFyZ3MgdGhlIGNhbGxiYWNrIGluamVjdGVkXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyUGFpciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lclBhaXIuZXZlbnRMaXN0ZW5lcldyYXBwZXIuc2V0QXJncyguLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpcmUgb2ZmIHRoZSBhY3R1YWwgZXZlbnRcbiAgICAgICAgICAgIHN1cGVyLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KGV2ZW50TmFtZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50RW1pdHRlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuZXhwb3J0IHZhciBMb2dMZXZlbDtcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRpc2FibGVkXCJdID0gMF0gPSBcIkRpc2FibGVkXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJFcnJvclwiXSA9IDFdID0gXCJFcnJvclwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiV2FybmluZ1wiXSA9IDJdID0gXCJXYXJuaW5nXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJbmZvXCJdID0gM10gPSBcIkluZm9cIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRlYnVnXCJdID0gNF0gPSBcIkRlYnVnXCI7XG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZ2xvYmFsIGNvbnRleHQgZm9yIHRoZSBsb2dnZXIgY29uZmlndXJhdGlvbi5cbiAqIFRoaXMgY2Fubm90IGJlIHN0b3JlZCBzdGF0aWNhbGx5IGluIHRoZSBMb2dnZXIgY2xhc3MgYmVjYXVzZSB3ZSBzb21ldGltZXMgaGF2ZSBtdWx0aXBsZSBleGVjdXRpb25cbiAqIGNvbnRleHRzLCBzdWNoIGFzIHN0YXRzIHJlcG9ydGluZy4gSW5zdGVhZCB3ZSBzdG9yZSB0aGUgbG9nZ2VyIGNvbmZpZyBjb250ZXh0IG9uIHRoZSB3aW5kb3cgb2JqZWN0XG4gKiB0byBiZSBzaGFyZWQgd2l0aCBhbnkgTG9nZ2VyIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIExvZ2dlckNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxvZ0xldmVsID0gTG9nTGV2ZWwuRGVidWc7XG4gICAgICAgIHRoaXMuaW5jbHVkZVN0YWNrID0gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gb3ZlcnJpZGVMb2dnZXIobG9nZ2VyKSB7XG4gICAgTG9nZ2VyID0gbG9nZ2VyO1xufVxuLyoqXG4gKiBBIGJhc2ljIGNvbnNvbGUgbG9nZ2VyIHV0aWxpemVkIGJ5IHRoZSBQaXhlbCBTdHJlYW1pbmcgZnJvbnRlbmQgdG8gYWxsb3dcbiAqIGxvZ2dpbmcgdG8gdGhlIGJyb3dzZXIgY29uc29sZS5cbiAqL1xuZXhwb3J0IGNsYXNzIExvZ2dlclR5cGUge1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbG9nIHZlcmJvc2l0eSBsZXZlbFxuICAgICAqL1xuICAgIEluaXRMb2dnaW5nKGxvZ0xldmVsLCBpbmNsdWRlU3RhY2spIHtcbiAgICAgICAgdGhpcy5WYWxpZGF0ZUNvbnRleHQoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmxvZ0xldmVsID0gbG9nTGV2ZWw7XG4gICAgICAgIHRoaXMuY29udGV4dC5pbmNsdWRlU3RhY2sgPSBpbmNsdWRlU3RhY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ2dpbmcgb3V0cHV0IGZvciBkZWJ1Z2dpbmdcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZFxuICAgICAqL1xuICAgIERlYnVnKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5WYWxpZGF0ZUNvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5sb2dMZXZlbCA+PSBMb2dMZXZlbC5EZWJ1Zykge1xuICAgICAgICAgICAgdGhpcy5Db21tb25Mb2coJ0RlYnVnJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQmFzaWMgbG9nZ2luZyBvdXRwdXQgZm9yIHN0YW5kYXJkIG1lc3NhZ2VzXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWRcbiAgICAgKi9cbiAgICBJbmZvKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5WYWxpZGF0ZUNvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5sb2dMZXZlbCA+PSBMb2dMZXZlbC5JbmZvKSB7XG4gICAgICAgICAgICB0aGlzLkNvbW1vbkxvZygnSW5mbycsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ2dpbmcgZm9yIHdhcm5pbmdzXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWRcbiAgICAgKi9cbiAgICBXYXJuaW5nKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5WYWxpZGF0ZUNvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5sb2dMZXZlbCA+PSBMb2dMZXZlbC5XYXJuaW5nKSB7XG4gICAgICAgICAgICB0aGlzLkNvbW1vbkxvZygnV2FybmluZycsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVycm9yIGxvZ2dpbmdcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZFxuICAgICAqL1xuICAgIEVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5WYWxpZGF0ZUNvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5sb2dMZXZlbCA+PSBMb2dMZXZlbC5FcnJvcikge1xuICAgICAgICAgICAgdGhpcy5Db21tb25Mb2coJ0Vycm9yJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbW1vbiBsb2cgZnVuY3Rpb24gdGhhdCBhbGwgb3RoZXIgbG9nIGZ1bmN0aW9ucyBjYWxsIHRvLlxuICAgICAqIEBwYXJhbSBsZXZlbCAtIHRoZSBsZXZlbCBvZiB0aGlzIGxvZyBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBzdGFjayAtIGFuIG9wdGlvbmFsIHN0YWNrIHRyYWNlIHN0cmluZyBmcm9tIHdoZXJlIHRoZSBsb2cgbWVzc2FnZSB3YXMgY2FsbGVkLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gdGhlIG1lc3NhZ2UgdG8gYmUgbG9nZ2VkLlxuICAgICAqL1xuICAgIENvbW1vbkxvZyhsZXZlbCwgbWVzc2FnZSkge1xuICAgICAgICBsZXQgbG9nTWVzc2FnZSA9IGBbJHtsZXZlbH1dIC0gJHttZXNzYWdlfWA7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuaW5jbHVkZVN0YWNrKSB7XG4gICAgICAgICAgICBsb2dNZXNzYWdlICs9IGBcXG5TdGFjazogJHt0aGlzLkdldFN0YWNrVHJhY2UoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZXZlbCA9PT0gJ0Vycm9yJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihsb2dNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZXZlbCA9PT0gJ1dhcm5pbmcnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obG9nTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhsb2dNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYXB0dXJlcyB0aGUgc3RhY2sgYW5kIHJldHVybnMgaXRcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBzdGFja1xuICAgICAqL1xuICAgIEdldFN0YWNrVHJhY2UoKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGxldCBmb3JtYXR0ZWRTdGFjayA9ICdObyBTdGFjayBBdmFpbGFibGUgZm9yIHRoaXMgYnJvd3Nlcic7XG4gICAgICAgIC8vIGZvcm1hdCB0aGUgZXJyb3JcbiAgICAgICAgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdGFjayA9IGVycm9yLnN0YWNrLnRvU3RyaW5nKCkucmVwbGFjZSgvRXJyb3IvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRTdGFjaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2luY2UgdGhlcmUgY2FuIGJlIG11bHRpcGxlIGV4ZWN1dGlvbiBjb250ZXh0cywgKHN0YXRzIHJlcG9ydGluZyBhbmQgc29tZSB3ZWJ4ciBsb2dnaW5nIGNvbWVzIGZyb21cbiAgICAgKiBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRzIHdlIGNhbiBlbmQgdXAgd2l0aCBtdWx0aXBsZSBzdGF0aWMgTG9nZ2VyIGluc3RhbmNlcy4gSGVyZSB3ZSB0cnkgdG9cbiAgICAgKiB3b3JrIGFyb3VuZCBpdCBieSBzdG9yaW5nIHRoZSBjb250ZXh0IG9uIHRoZSB3aW5kb3cgb2JqZWN0LlxuICAgICAqL1xuICAgIFZhbGlkYXRlQ29udGV4dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cpIHtcbiAgICAgICAgICAgICAgICAvLyBubyB3aW5kb3cgb2JqZWN0IHNvIHdlIGNhbiBvbmx5IHN0b3JlIGEgbG9jYWwgY29udGV4dC5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBuZXcgTG9nZ2VyQ29udGV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXdpbmRvdy5sb2dnZXJDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV3IExvZ2dlckNvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9nZ2VyQ29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IHdpbmRvdy5sb2dnZXJDb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGxldCBMb2dnZXIgPSBuZXcgTG9nZ2VyVHlwZSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9nZ2VyLmpzLm1hcCIsImltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL0xvZ2dlci9Mb2dnZXInO1xuaW1wb3J0IHsgTWVzc2FnZVJlZ2lzdHJ5IH0gZnJvbSAnLi9tZXNzYWdlX3JlZ2lzdHJ5Jztcbi8qKlxuICogQSBoZWxwZXIgZm9yIGNyZWF0aW5nIHNpZ25hbGxpbmcgbWVzc2FnZXMuIFRha2VzIGluIG9wdGlvbmFsIGdpdmVuIHBhcmFtZXRlcnMgYW5kXG4gKiBpbmNsdWRlcyB0aGVtIGluIGEgbWVzc2FnZSBvYmplY3Qgd2l0aCB0aGUgJ3R5cGUnIGZpZWxkIHNldCBwcm9wZXJseSBmb3IgdGhlIG1lc3NhZ2VcbiAqIHR5cGUgc3VwcGxpZWQuXG4gKiBAcGFyYW0gbWVzc2FnZVR5cGUgLSBBIG1lc3NhZ2UgdHlwZSBmcm9tIE1lc3NhZ2VSZWdpc3RyeSB0aGF0IGluZGljYXRlcyB0aGUgdHlwZSBvZiBtZXNzYWdlIHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSBwYXJhbXMgLSBBbiBvcHRpb25hbCBvYmplY3Qgd2hvc2UgZmllbGRzIGFyZSBhZGRlZCB0byB0aGUgbmV3bHkgY3JlYXRlZCBtZXNzYWdlLlxuICogQHJldHVybnMgVGhlIHJlc3VsdGluZyBtZXNzYWdlIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2UobWVzc2FnZVR5cGUsIHBhcmFtcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlVHlwZS5jcmVhdGUoKTtcbiAgICBtZXNzYWdlLnR5cGUgPSBtZXNzYWdlVHlwZS50eXBlTmFtZTtcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgIG1lc3NhZ2VUeXBlLm1lcmdlUGFydGlhbChtZXNzYWdlLCBwYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbn1cbi8qKlxuICogVGVzdHMgdGhhdCB0aGUgc3VwcGxpZWQgbWVzc2FnZSBpcyB2YWxpZC4gVGhhdCBpcyBjb250YWlucyBhbGwgZXhwZWN0ZWQgZmllbGRzIGFuZFxuICogZG9lc24ndCBjb250YWluIGFueSB1bmtub3duIGZpZWxkcy5cbiAqIEBwYXJhbSBtc2cgLSBUaGUgbWVzc2FnZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm5zIFRoZSBtZXNzYWdlIHR5cGUgZnJvbSBNZXNzYWdlUmVnaXN0cnkgb2YgdGhlIHN1cHBsaWVkIG1lc3NhZ2Ugb2JqZWN0IGlmIGl0J3MgdmFsaWQsIG9yIG51bGwgaWYgaW52YWxpZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZShtc2cpIHtcbiAgICBsZXQgdmFsaWQgPSB0cnVlO1xuICAgIGlmICghbXNnLnR5cGUpIHtcbiAgICAgICAgTG9nZ2VyLkVycm9yKGBQYXJzZWQgbWVzc2FnZSBoYXMgbm8gdHlwZS4gUmVqZWN0ZWQuICR7SlNPTi5zdHJpbmdpZnkobXNnKX1gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gTWVzc2FnZVJlZ2lzdHJ5W21zZy50eXBlXTtcbiAgICBpZiAoIW1lc3NhZ2VUeXBlKSB7XG4gICAgICAgIExvZ2dlci5FcnJvcihgTWVzc2FnZSBpcyBvZiBhbiB1bmtub3duIHR5cGU6IFwiJHttc2cudHlwZX1cIi4gUmVqZWN0ZWQuYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZVR5cGUuZmllbGRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgbWVzc2FnZVR5cGUuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoIWZpZWxkLm9wdCkge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1zZywgZmllbGQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBNZXNzYWdlIFwiJHttc2cudHlwZX1cIlwiIGlzIG1pc3NpbmcgcmVxdWlyZWQgZmllbGQgXCIke2ZpZWxkLm5hbWV9XCIuIFJlamVjdGVkLmApO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBpbiBtc2cpIHtcbiAgICAgICAgY29uc3QgZm91bmQgPSBtZXNzYWdlVHlwZS5maWVsZHMuZmluZCgoZmllbGQpID0+IGZpZWxkLm5hbWUgPT09IGZpZWxkTmFtZSk7XG4gICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihgTWVzc2FnZSBcIiR7bXNnLnR5cGV9XCIgY29udGFpbnMgdW5rbm93biBmaWVsZCBcIiR7ZmllbGROYW1lfVwiLiBSZWplY3RlZC5gKTtcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkID8gbWVzc2FnZVR5cGUgOiBudWxsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZV9oZWxwZXJzLmpzLm1hcCIsImltcG9ydCAqIGFzIE1lc3NhZ2VzIGZyb20gJy4vc2lnbmFsbGluZ19tZXNzYWdlcyc7XG4vKipcbiAqIEEgbWFwIG9mIGFsbCB0aGUgc3VwcG9ydGVkIHNpZ25hbGxpbmcgbWVzc2FnZXMgaW4gdGhlIFBpeGVsIFN0cmVhbWluZ1xuICogc2lnbmFsbGluZyBwcm90b2NvbC4gVGhpcyBhbGxvd3MgbWFwcGluZyBvZiBzaWduYWxsaW5nIG1lc3NhZ2UgbmFtZXNcbiAqIHRvIGFjdHVhbCBtZXNzYWdlIHR5cGVzLlxuICovXG5leHBvcnQgY29uc3QgTWVzc2FnZVJlZ2lzdHJ5ID0ge1xuICAgIGFuc3dlcjogTWVzc2FnZXMuYW5zd2VyLFxuICAgIGNvbmZpZzogTWVzc2FnZXMuY29uZmlnLFxuICAgIGRpc2Nvbm5lY3RQbGF5ZXI6IE1lc3NhZ2VzLmRpc2Nvbm5lY3RQbGF5ZXIsXG4gICAgZW5kcG9pbnRJZDogTWVzc2FnZXMuZW5kcG9pbnRJZCxcbiAgICBlbmRwb2ludElkQ29uZmlybTogTWVzc2FnZXMuZW5kcG9pbnRJZENvbmZpcm0sXG4gICAgaWNlQ2FuZGlkYXRlOiBNZXNzYWdlcy5pY2VDYW5kaWRhdGUsXG4gICAgaWRlbnRpZnk6IE1lc3NhZ2VzLmlkZW50aWZ5LFxuICAgIGxpc3RTdHJlYW1lcnM6IE1lc3NhZ2VzLmxpc3RTdHJlYW1lcnMsXG4gICAgb2ZmZXI6IE1lc3NhZ2VzLm9mZmVyLFxuICAgIHBpbmc6IE1lc3NhZ2VzLnBpbmcsXG4gICAgcGxheWVyQ29ubmVjdGVkOiBNZXNzYWdlcy5wbGF5ZXJDb25uZWN0ZWQsXG4gICAgcGxheWVyQ291bnQ6IE1lc3NhZ2VzLnBsYXllckNvdW50LFxuICAgIHBsYXllckRpc2Nvbm5lY3RlZDogTWVzc2FnZXMucGxheWVyRGlzY29ubmVjdGVkLFxuICAgIHBvbmc6IE1lc3NhZ2VzLnBvbmcsXG4gICAgc3RhdHM6IE1lc3NhZ2VzLnN0YXRzLFxuICAgIHN0cmVhbWVyRGlzY29ubmVjdGVkOiBNZXNzYWdlcy5zdHJlYW1lckRpc2Nvbm5lY3RlZCxcbiAgICBzdHJlYW1lckxpc3Q6IE1lc3NhZ2VzLnN0cmVhbWVyTGlzdCxcbiAgICBzdWJzY3JpYmU6IE1lc3NhZ2VzLnN1YnNjcmliZSxcbiAgICB1bnN1YnNjcmliZTogTWVzc2FnZXMudW5zdWJzY3JpYmUsXG4gICAgbGF5ZXJQcmVmZXJlbmNlOiBNZXNzYWdlcy5sYXllclByZWZlcmVuY2UsXG4gICAgZGF0YUNoYW5uZWxSZXF1ZXN0OiBNZXNzYWdlcy5kYXRhQ2hhbm5lbFJlcXVlc3QsXG4gICAgcGVlckRhdGFDaGFubmVsczogTWVzc2FnZXMucGVlckRhdGFDaGFubmVscyxcbiAgICBwZWVyRGF0YUNoYW5uZWxzUmVhZHk6IE1lc3NhZ2VzLnBlZXJEYXRhQ2hhbm5lbHNSZWFkeSxcbiAgICBzdHJlYW1lckRhdGFDaGFubmVsczogTWVzc2FnZXMuc3RyZWFtZXJEYXRhQ2hhbm5lbHMsXG4gICAgc3RhcnRTdHJlYW1pbmc6IE1lc3NhZ2VzLnN0YXJ0U3RyZWFtaW5nLFxuICAgIHN0b3BTdHJlYW1pbmc6IE1lc3NhZ2VzLnN0b3BTdHJlYW1pbmdcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlX3JlZ2lzdHJ5LmpzLm1hcCIsImltcG9ydCB7IFdpcmVUeXBlIH0gZnJvbSBcIkBwcm90b2J1Zi10cy9ydW50aW1lXCI7XG5pbXBvcnQgeyBVbmtub3duRmllbGRIYW5kbGVyIH0gZnJvbSBcIkBwcm90b2J1Zi10cy9ydW50aW1lXCI7XG5pbXBvcnQgeyByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsIH0gZnJvbSBcIkBwcm90b2J1Zi10cy9ydW50aW1lXCI7XG5pbXBvcnQgeyBNZXNzYWdlVHlwZSB9IGZyb20gXCJAcHJvdG9idWYtdHMvcnVudGltZVwiO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgYmFzZV9tZXNzYWdlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiYmFzZV9tZXNzYWdlXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGJhc2VfbWVzc2FnZVxuICovXG5leHBvcnQgY29uc3QgYmFzZV9tZXNzYWdlID0gbmV3IGJhc2VfbWVzc2FnZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBwZWVyQ29ubmVjdGlvbk9wdGlvbnMkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJwZWVyQ29ubmVjdGlvbk9wdGlvbnNcIiwgW10pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHBlZXJDb25uZWN0aW9uT3B0aW9uc1xuICovXG5leHBvcnQgY29uc3QgcGVlckNvbm5lY3Rpb25PcHRpb25zID0gbmV3IHBlZXJDb25uZWN0aW9uT3B0aW9ucyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBjb25maWckVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJjb25maWdcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcInBlZXJDb25uZWN0aW9uT3B0aW9uc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogKCkgPT4gcGVlckNvbm5lY3Rpb25PcHRpb25zIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiBcInByb3RvY29sVmVyc2lvblwiLCBraW5kOiBcInNjYWxhclwiLCBvcHQ6IHRydWUsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogcGVlckNvbm5lY3Rpb25PcHRpb25zIHBlZXJDb25uZWN0aW9uT3B0aW9ucyAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBlZXJDb25uZWN0aW9uT3B0aW9ucyA9IHBlZXJDb25uZWN0aW9uT3B0aW9ucy5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UucGVlckNvbm5lY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBvcHRpb25hbCBzdHJpbmcgcHJvdG9jb2xWZXJzaW9uICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJvdG9jb2xWZXJzaW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogcGVlckNvbm5lY3Rpb25PcHRpb25zIHBlZXJDb25uZWN0aW9uT3B0aW9ucyA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBlZXJDb25uZWN0aW9uT3B0aW9ucylcbiAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uT3B0aW9ucy5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UucGVlckNvbm5lY3Rpb25PcHRpb25zLCB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIG9wdGlvbmFsIHN0cmluZyBwcm90b2NvbFZlcnNpb24gPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wcm90b2NvbFZlcnNpb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5wcm90b2NvbFZlcnNpb24pO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgY29uZmlnXG4gKi9cbmV4cG9ydCBjb25zdCBjb25maWcgPSBuZXcgY29uZmlnJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIGlkZW50aWZ5JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiaWRlbnRpZnlcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgaWRlbnRpZnlcbiAqL1xuZXhwb3J0IGNvbnN0IGlkZW50aWZ5ID0gbmV3IGlkZW50aWZ5JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIGVuZHBvaW50SWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJlbmRwb2ludElkXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogXCJwcm90b2NvbFZlcnNpb25cIiwga2luZDogXCJzY2FsYXJcIiwgb3B0OiB0cnVlLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuaWQgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgaWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBvcHRpb25hbCBzdHJpbmcgcHJvdG9jb2xWZXJzaW9uICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJvdG9jb2xWZXJzaW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyaW5nIGlkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaWQgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuaWQpO1xuICAgICAgICAvKiBvcHRpb25hbCBzdHJpbmcgcHJvdG9jb2xWZXJzaW9uID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucHJvdG9jb2xWZXJzaW9uICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UucHJvdG9jb2xWZXJzaW9uKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGVuZHBvaW50SWRcbiAqL1xuZXhwb3J0IGNvbnN0IGVuZHBvaW50SWQgPSBuZXcgZW5kcG9pbnRJZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBlbmRwb2ludElkQ29uZmlybSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImVuZHBvaW50SWRDb25maXJtXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJjb21taXR0ZWRJZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuY29tbWl0dGVkSWQgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgY29tbWl0dGVkSWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb21taXR0ZWRJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBjb21taXR0ZWRJZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNvbW1pdHRlZElkICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmNvbW1pdHRlZElkKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGVuZHBvaW50SWRDb25maXJtXG4gKi9cbmV4cG9ydCBjb25zdCBlbmRwb2ludElkQ29uZmlybSA9IG5ldyBlbmRwb2ludElkQ29uZmlybSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBzdHJlYW1lcklkQ2hhbmdlZCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInN0cmVhbWVySWRDaGFuZ2VkXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJuZXdJRFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UubmV3SUQgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgbmV3SUQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uZXdJRCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBuZXdJRCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm5ld0lEICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm5ld0lEKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbWVySWRDaGFuZ2VkXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJlYW1lcklkQ2hhbmdlZCA9IG5ldyBzdHJlYW1lcklkQ2hhbmdlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBsaXN0U3RyZWFtZXJzJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwibGlzdFN0cmVhbWVyc1wiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBsaXN0U3RyZWFtZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBsaXN0U3RyZWFtZXJzID0gbmV3IGxpc3RTdHJlYW1lcnMkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3Mgc3RyZWFtZXJMaXN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwic3RyZWFtZXJMaXN0XCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJpZHNcIiwga2luZDogXCJzY2FsYXJcIiwgcmVwZWF0OiAyIC8qUmVwZWF0VHlwZS5VTlBBQ0tFRCovLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuaWRzID0gW107XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmluZyBpZHMgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZHMucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyaW5nIGlkcyA9IDI7ICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5pZHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuaWRzW2ldKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbWVyTGlzdFxuICovXG5leHBvcnQgY29uc3Qgc3RyZWFtZXJMaXN0ID0gbmV3IHN0cmVhbWVyTGlzdCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBzdWJzY3JpYmUkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJzdWJzY3JpYmVcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcInN0cmVhbWVySWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLnN0cmVhbWVySWQgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc3RyZWFtZXJJZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmVhbWVySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBzdHJpbmcgc3RyZWFtZXJJZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnN0cmVhbWVySWQgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc3RyZWFtZXJJZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdWJzY3JpYmVcbiAqL1xuZXhwb3J0IGNvbnN0IHN1YnNjcmliZSA9IG5ldyBzdWJzY3JpYmUkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgdW5zdWJzY3JpYmUkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJ1bnN1YnNjcmliZVwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSB1bnN1YnNjcmliZVxuICovXG5leHBvcnQgY29uc3QgdW5zdWJzY3JpYmUgPSBuZXcgdW5zdWJzY3JpYmUkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3Mgc3Vic2NyaWJlRmFpbGVkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwic3Vic2NyaWJlRmFpbGVkXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJtZXNzYWdlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5tZXNzYWdlID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIG1lc3NhZ2UgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXNzYWdlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyaW5nIG1lc3NhZ2UgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5tZXNzYWdlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm1lc3NhZ2UpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3Vic2NyaWJlRmFpbGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzdWJzY3JpYmVGYWlsZWQgPSBuZXcgc3Vic2NyaWJlRmFpbGVkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHBsYXllckNvbm5lY3RlZCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInBsYXllckNvbm5lY3RlZFwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwiZGF0YUNoYW5uZWxcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiBcInNmdVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDUsIG5hbWU6IFwicGxheWVySWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLmRhdGFDaGFubmVsID0gZmFsc2U7XG4gICAgICAgIG1lc3NhZ2Uuc2Z1ID0gZmFsc2U7XG4gICAgICAgIG1lc3NhZ2UucGxheWVySWQgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIGRhdGFDaGFubmVsICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YUNoYW5uZWwgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgc2Z1ICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Z1ID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgcGxheWVySWQgKi8gNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wbGF5ZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIGJvb2wgZGF0YUNoYW5uZWwgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5kYXRhQ2hhbm5lbCAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLmRhdGFDaGFubmVsKTtcbiAgICAgICAgLyogYm9vbCBzZnUgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZnUgIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5zZnUpO1xuICAgICAgICAvKiBzdHJpbmcgcGxheWVySWQgPSA1OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wbGF5ZXJJZCAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoNSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5wbGF5ZXJJZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBwbGF5ZXJDb25uZWN0ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHBsYXllckNvbm5lY3RlZCA9IG5ldyBwbGF5ZXJDb25uZWN0ZWQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgcGxheWVyRGlzY29ubmVjdGVkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwicGxheWVyRGlzY29ubmVjdGVkXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJwbGF5ZXJJZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UucGxheWVySWQgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgcGxheWVySWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wbGF5ZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBwbGF5ZXJJZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBsYXllcklkICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnBsYXllcklkKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHBsYXllckRpc2Nvbm5lY3RlZFxuICovXG5leHBvcnQgY29uc3QgcGxheWVyRGlzY29ubmVjdGVkID0gbmV3IHBsYXllckRpc2Nvbm5lY3RlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBvZmZlciRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcIm9mZmVyXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJzZHBcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6IFwicGxheWVySWRcIiwga2luZDogXCJzY2FsYXJcIiwgb3B0OiB0cnVlLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogXCJzZnVcIiwga2luZDogXCJzY2FsYXJcIiwgb3B0OiB0cnVlLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDUsIG5hbWU6IFwibXVsdGlwbGV4XCIsIGtpbmQ6IFwic2NhbGFyXCIsIG9wdDogdHJ1ZSwgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgICAgICAgICB7IG5vOiA2LCBuYW1lOiBcInNjYWxhYmlsaXR5TW9kZVwiLCBraW5kOiBcInNjYWxhclwiLCBvcHQ6IHRydWUsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zZHAgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2RwICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2RwID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIG9wdGlvbmFsIHN0cmluZyBwbGF5ZXJJZCAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBsYXllcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIG9wdGlvbmFsIGJvb2wgc2Z1ICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Z1ID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBvcHRpb25hbCBib29sIG11bHRpcGxleCAqLyA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm11bHRpcGxleCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogb3B0aW9uYWwgc3RyaW5nIHNjYWxhYmlsaXR5TW9kZSAqLyA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNjYWxhYmlsaXR5TW9kZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBzZHAgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZHAgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2RwKTtcbiAgICAgICAgLyogb3B0aW9uYWwgc3RyaW5nIHBsYXllcklkID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGxheWVySWQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5wbGF5ZXJJZCk7XG4gICAgICAgIC8qIG9wdGlvbmFsIGJvb2wgc2Z1ID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Z1ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLnNmdSk7XG4gICAgICAgIC8qIG9wdGlvbmFsIGJvb2wgbXVsdGlwbGV4ID0gNTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubXVsdGlwbGV4ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDUsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLm11bHRpcGxleCk7XG4gICAgICAgIC8qIG9wdGlvbmFsIHN0cmluZyBzY2FsYWJpbGl0eU1vZGUgPSA2OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zY2FsYWJpbGl0eU1vZGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zY2FsYWJpbGl0eU1vZGUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugb2ZmZXJcbiAqL1xuZXhwb3J0IGNvbnN0IG9mZmVyID0gbmV3IG9mZmVyJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIGFuc3dlciRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImFuc3dlclwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwic2RwXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiBcInBsYXllcklkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIG9wdDogdHJ1ZSwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6IFwibWluQml0cmF0ZUJwc1wiLCBraW5kOiBcInNjYWxhclwiLCBvcHQ6IHRydWUsIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDUsIG5hbWU6IFwibWF4Qml0cmF0ZUJwc1wiLCBraW5kOiBcInNjYWxhclwiLCBvcHQ6IHRydWUsIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLnNkcCA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZHAgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZHAgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogb3B0aW9uYWwgc3RyaW5nIHBsYXllcklkICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGxheWVySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogb3B0aW9uYWwgaW50MzIgbWluQml0cmF0ZUJwcyAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1pbkJpdHJhdGVCcHMgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBvcHRpb25hbCBpbnQzMiBtYXhCaXRyYXRlQnBzICovIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWF4Qml0cmF0ZUJwcyA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyaW5nIHNkcCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNkcCAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZHApO1xuICAgICAgICAvKiBvcHRpb25hbCBzdHJpbmcgcGxheWVySWQgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wbGF5ZXJJZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnBsYXllcklkKTtcbiAgICAgICAgLyogb3B0aW9uYWwgaW50MzIgbWluQml0cmF0ZUJwcyA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm1pbkJpdHJhdGVCcHMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLm1pbkJpdHJhdGVCcHMpO1xuICAgICAgICAvKiBvcHRpb25hbCBpbnQzMiBtYXhCaXRyYXRlQnBzID0gNTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubWF4Qml0cmF0ZUJwcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg1LCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UubWF4Qml0cmF0ZUJwcyk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBhbnN3ZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGFuc3dlciA9IG5ldyBhbnN3ZXIkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgaWNlQ2FuZGlkYXRlRGF0YSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImljZUNhbmRpZGF0ZURhdGFcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJjYW5kaWRhdGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwic2RwTWlkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiBcInNkcE1MaW5lSW5kZXhcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9LFxuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogXCJ1c2VybmFtZUZyYWdtZW50XCIsIGtpbmQ6IFwic2NhbGFyXCIsIG9wdDogdHJ1ZSwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLmNhbmRpZGF0ZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2Uuc2RwTWlkID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zZHBNTGluZUluZGV4ID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgY2FuZGlkYXRlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2FuZGlkYXRlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZHBNaWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZHBNaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogaW50MzIgc2RwTUxpbmVJbmRleCAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNkcE1MaW5lSW5kZXggPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBvcHRpb25hbCBzdHJpbmcgdXNlcm5hbWVGcmFnbWVudCAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVzZXJuYW1lRnJhZ21lbnQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIGNhbmRpZGF0ZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNhbmRpZGF0ZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5jYW5kaWRhdGUpO1xuICAgICAgICAvKiBzdHJpbmcgc2RwTWlkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2RwTWlkICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNkcE1pZCk7XG4gICAgICAgIC8qIGludDMyIHNkcE1MaW5lSW5kZXggPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZHBNTGluZUluZGV4ICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2Uuc2RwTUxpbmVJbmRleCk7XG4gICAgICAgIC8qIG9wdGlvbmFsIHN0cmluZyB1c2VybmFtZUZyYWdtZW50ID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudXNlcm5hbWVGcmFnbWVudCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJuYW1lRnJhZ21lbnQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgaWNlQ2FuZGlkYXRlRGF0YVxuICovXG5leHBvcnQgY29uc3QgaWNlQ2FuZGlkYXRlRGF0YSA9IG5ldyBpY2VDYW5kaWRhdGVEYXRhJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIGljZUNhbmRpZGF0ZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImljZUNhbmRpZGF0ZVwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwiY2FuZGlkYXRlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiAoKSA9PiBpY2VDYW5kaWRhdGVEYXRhIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiBcInBsYXllcklkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIG9wdDogdHJ1ZSwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpY2VDYW5kaWRhdGVEYXRhIGNhbmRpZGF0ZSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNhbmRpZGF0ZSA9IGljZUNhbmRpZGF0ZURhdGEuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogb3B0aW9uYWwgc3RyaW5nIHBsYXllcklkICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGxheWVySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBpY2VDYW5kaWRhdGVEYXRhIGNhbmRpZGF0ZSA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNhbmRpZGF0ZSlcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZURhdGEuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmNhbmRpZGF0ZSwgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBvcHRpb25hbCBzdHJpbmcgcGxheWVySWQgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wbGF5ZXJJZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnBsYXllcklkKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGljZUNhbmRpZGF0ZVxuICovXG5leHBvcnQgY29uc3QgaWNlQ2FuZGlkYXRlID0gbmV3IGljZUNhbmRpZGF0ZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBkaXNjb25uZWN0UGxheWVyJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiZGlzY29ubmVjdFBsYXllclwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwicGxheWVySWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6IFwicmVhc29uXCIsIGtpbmQ6IFwic2NhbGFyXCIsIG9wdDogdHJ1ZSwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLnBsYXllcklkID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHBsYXllcklkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGxheWVySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogb3B0aW9uYWwgc3RyaW5nIHJlYXNvbiAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlYXNvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBwbGF5ZXJJZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBsYXllcklkICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnBsYXllcklkKTtcbiAgICAgICAgLyogb3B0aW9uYWwgc3RyaW5nIHJlYXNvbiA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnJlYXNvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnJlYXNvbik7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBkaXNjb25uZWN0UGxheWVyXG4gKi9cbmV4cG9ydCBjb25zdCBkaXNjb25uZWN0UGxheWVyID0gbmV3IGRpc2Nvbm5lY3RQbGF5ZXIkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgcGluZyRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInBpbmdcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcInRpbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudGltZSA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDMyIHRpbWUgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50aW1lID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBpbnQzMiB0aW1lID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudGltZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnRpbWUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgcGluZ1xuICovXG5leHBvcnQgY29uc3QgcGluZyA9IG5ldyBwaW5nJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHBvbmckVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJwb25nXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJ0aW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLnRpbWUgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiB0aW1lICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGltZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogaW50MzIgdGltZSA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnRpbWUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS50aW1lKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHBvbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHBvbmcgPSBuZXcgcG9uZyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBzdHJlYW1lckRpc2Nvbm5lY3RlZCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInN0cmVhbWVyRGlzY29ubmVjdGVkXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbWVyRGlzY29ubmVjdGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJlYW1lckRpc2Nvbm5lY3RlZCA9IG5ldyBzdHJlYW1lckRpc2Nvbm5lY3RlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBsYXllclByZWZlcmVuY2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJsYXllclByZWZlcmVuY2VcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiBcInNwYXRpYWxMYXllclwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiBcInRlbXBvcmFsTGF5ZXJcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9LFxuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogXCJwbGF5ZXJJZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2Uuc3BhdGlhbExheWVyID0gMDtcbiAgICAgICAgbWVzc2FnZS50ZW1wb3JhbExheWVyID0gMDtcbiAgICAgICAgbWVzc2FnZS5wbGF5ZXJJZCA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDMyIHNwYXRpYWxMYXllciAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNwYXRpYWxMYXllciA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDMyIHRlbXBvcmFsTGF5ZXIgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZW1wb3JhbExheWVyID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHBsYXllcklkICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGxheWVySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBpbnQzMiBzcGF0aWFsTGF5ZXIgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zcGF0aWFsTGF5ZXIgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5zcGF0aWFsTGF5ZXIpO1xuICAgICAgICAvKiBpbnQzMiB0ZW1wb3JhbExheWVyID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudGVtcG9yYWxMYXllciAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnRlbXBvcmFsTGF5ZXIpO1xuICAgICAgICAvKiBzdHJpbmcgcGxheWVySWQgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wbGF5ZXJJZCAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5wbGF5ZXJJZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBsYXllclByZWZlcmVuY2VcbiAqL1xuZXhwb3J0IGNvbnN0IGxheWVyUHJlZmVyZW5jZSA9IG5ldyBsYXllclByZWZlcmVuY2UkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgZGF0YUNoYW5uZWxSZXF1ZXN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiZGF0YUNoYW5uZWxSZXF1ZXN0XCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGRhdGFDaGFubmVsUmVxdWVzdFxuICovXG5leHBvcnQgY29uc3QgZGF0YUNoYW5uZWxSZXF1ZXN0ID0gbmV3IGRhdGFDaGFubmVsUmVxdWVzdCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBwZWVyRGF0YUNoYW5uZWxzJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwicGVlckRhdGFDaGFubmVsc1wiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwicGxheWVySWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6IFwic2VuZFN0cmVhbUlkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6IFwicmVjdlN0cmVhbUlkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLnBsYXllcklkID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zZW5kU3RyZWFtSWQgPSAwO1xuICAgICAgICBtZXNzYWdlLnJlY3ZTdHJlYW1JZCA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBwbGF5ZXJJZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBsYXllcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDMyIHNlbmRTdHJlYW1JZCAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlbmRTdHJlYW1JZCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDMyIHJlY3ZTdHJlYW1JZCAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlY3ZTdHJlYW1JZCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyaW5nIHBsYXllcklkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGxheWVySWQgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UucGxheWVySWQpO1xuICAgICAgICAvKiBpbnQzMiBzZW5kU3RyZWFtSWQgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZW5kU3RyZWFtSWQgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5zZW5kU3RyZWFtSWQpO1xuICAgICAgICAvKiBpbnQzMiByZWN2U3RyZWFtSWQgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5yZWN2U3RyZWFtSWQgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5yZWN2U3RyZWFtSWQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgcGVlckRhdGFDaGFubmVsc1xuICovXG5leHBvcnQgY29uc3QgcGVlckRhdGFDaGFubmVscyA9IG5ldyBwZWVyRGF0YUNoYW5uZWxzJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHBlZXJEYXRhQ2hhbm5lbHNSZWFkeSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInBlZXJEYXRhQ2hhbm5lbHNSZWFkeVwiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB2b2lkIDAgPyB0YXJnZXQgOiB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBwZWVyRGF0YUNoYW5uZWxzUmVhZHlcbiAqL1xuZXhwb3J0IGNvbnN0IHBlZXJEYXRhQ2hhbm5lbHNSZWFkeSA9IG5ldyBwZWVyRGF0YUNoYW5uZWxzUmVhZHkkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3Mgc3RyZWFtZXJEYXRhQ2hhbm5lbHMkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJzdHJlYW1lckRhdGFDaGFubmVsc1wiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwic2Z1SWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6IFwic2VuZFN0cmVhbUlkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6IFwicmVjdlN0cmVhbUlkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8gfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUoKHRoaXMubWVzc2FnZVByb3RvdHlwZSkpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSBcIlwiO1xuICAgICAgICBtZXNzYWdlLnNmdUlkID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zZW5kU3RyZWFtSWQgPSAwO1xuICAgICAgICBtZXNzYWdlLnJlY3ZTdHJlYW1JZCA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZnVJZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNmdUlkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDMyIHNlbmRTdHJlYW1JZCAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlbmRTdHJlYW1JZCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDMyIHJlY3ZTdHJlYW1JZCAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlY3ZTdHJlYW1JZCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyaW5nIHNmdUlkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Z1SWQgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2Z1SWQpO1xuICAgICAgICAvKiBpbnQzMiBzZW5kU3RyZWFtSWQgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZW5kU3RyZWFtSWQgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5zZW5kU3RyZWFtSWQpO1xuICAgICAgICAvKiBpbnQzMiByZWN2U3RyZWFtSWQgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5yZWN2U3RyZWFtSWQgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5yZWN2U3RyZWFtSWQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtZXJEYXRhQ2hhbm5lbHNcbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmVhbWVyRGF0YUNoYW5uZWxzID0gbmV3IHN0cmVhbWVyRGF0YUNoYW5uZWxzJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHN0YXJ0U3RyZWFtaW5nJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwic3RhcnRTdHJlYW1pbmdcIiwgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHR5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBcIlwiKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RhcnRTdHJlYW1pbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHN0YXJ0U3RyZWFtaW5nID0gbmV3IHN0YXJ0U3RyZWFtaW5nJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIHN0b3BTdHJlYW1pbmckVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJzdG9wU3RyZWFtaW5nXCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0b3BTdHJlYW1pbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHN0b3BTdHJlYW1pbmcgPSBuZXcgc3RvcFN0cmVhbWluZyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBwbGF5ZXJDb3VudCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInBsYXllckNvdW50XCIsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogXCJjb3VudFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKCh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5jb3VudCA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDMyIGNvdW50ICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY291bnQgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIGludDMyIGNvdW50ID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY291bnQgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5jb3VudCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBwbGF5ZXJDb3VudFxuICovXG5leHBvcnQgY29uc3QgcGxheWVyQ291bnQgPSBuZXcgcGxheWVyQ291bnQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3Mgc3RhdHMkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJzdGF0c1wiLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6IFwiZGF0YVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSgodGhpcy5tZXNzYWdlUHJvdG90eXBlKSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuZGF0YSA9IFwiXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHZvaWQgMCA/IHRhcmdldCA6IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBkYXRhICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IFwiXCIpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBkYXRhID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YSAhPT0gXCJcIilcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5kYXRhKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0YXRzXG4gKi9cbmV4cG9ydCBjb25zdCBzdGF0cyA9IG5ldyBzdGF0cyRUeXBlKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYWxsaW5nX21lc3NhZ2VzLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgKiBhcyBNZXNzYWdlcyBmcm9tICcuLi9NZXNzYWdlcy9zaWduYWxsaW5nX21lc3NhZ2VzJztcbmltcG9ydCAqIGFzIE1lc3NhZ2VIZWxwZXJzIGZyb20gJy4uL01lc3NhZ2VzL21lc3NhZ2VfaGVscGVycyc7XG4vKipcbiAqIFVzZWQgdG8gcmVndWxhcmx5IHBpbmcgYSBwcm90b2NvbCBjb25uZWN0aW9uIHRvIG1ha2Ugc3VyZSB0aGUgY29ubmVjdGlvbiBpcyBzdGlsbCBnb29kIGFuZCBvcGVuLlxuICogV2hlbiB0aGUgcG9uZyBkb2Vzbid0IGNvbWUgaW4gcmVzcG9uc2UgdG8gYSBwaW5nIGluIHRpbWUgYSBjYWxsYmFjayBpcyBmaXJlZCB0aGF0IGNhbiBiZSBoYW5kZWRcbiAqIGJ5IHRoZSBvd25lci5cbiAqL1xuZXhwb3J0IGNsYXNzIEtlZXBhbGl2ZU1vbml0b3Ige1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFJvdW5kIFRyaXAgVGltZSBvZiB0aGUgY3VycmVudCBjb25uZWN0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBnZXQgUlRUKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgbW9uaXRvciBhbmQgc3RhcnRzIHRoZSBwaW5nIHRpbWVyLiBJZiBhIHBvbmcgZG9lcyBub3QgY29tZSBiYWNrIGJ5IHRoZSB0aW1lIHdlIHdhbnRcbiAgICAgKiB0byBzZW5kIGEgc2Vjb25kIHBpbmcgdGhlbiB0aGUgY29ubmVjdGlvbiBpcyBjb25zaWRlcmVkIGRlYWQgYW5kIHRoZSBvblRpbWVvdXQgY2FsbGJhY2sgaXMgZmlyZWQuXG4gICAgICogQHBhcmFtIHByb3RvY29sIC0gVGhlIGNvbm5lY3Rpb24gdGhhdCB3ZSB3YW50IHRvIG1vbml0b3IuXG4gICAgICogQHBhcmFtIHRpbWVvdXQgLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgYmV0d2VlbiBwaW5nIG1lc3NhZ2VzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3RvY29sLCB0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ydHQgPSAwO1xuICAgICAgICB0aGlzLnByb3RvY29sID0gcHJvdG9jb2w7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHRoaXMub25SZXNwb25zZSA9IHRoaXMub25IZWFydGJlYXRSZXNwb25zZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnByb3RvY29sLnRyYW5zcG9ydC5vbignY2xvc2UnLCB0aGlzLnN0b3AuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnByb3RvY29sLm9uKCdwb25nJywgdGhpcy5vblJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmUgPSBzZXRJbnRlcnZhbCh0aGlzLnNlbmRIZWFydGJlYXQuYmluZCh0aGlzKSwgdGhpcy50aW1lb3V0KTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBhbGl2ZSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wub2ZmKCdwb25nJywgdGhpcy5vblJlc3BvbnNlKTtcbiAgICB9XG4gICAgc2VuZEhlYXJ0YmVhdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBpZiB3ZSBuZXZlciBnb3QgYSByZXNwb25zZSBmcm9tIHRoZSBsYXN0IGhlYXJ0YmVhdCwgYXNzdW1lIHRoZSBjb25uZWN0aW9uIGlzIGRlYWQgYW5kIHRpbWVvdXRcbiAgICAgICAgaWYgKHRoaXMuYWxpdmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLm9uVGltZW91dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFyayB0aGUgY29ubmVjdGlvbiBhcyB0ZW1wb3JhcmlseSBkZWFkIHVudGlsIHdlIGdldCBhIHJlc3BvbnNlIGZyb20gdGhlIHBpbmdcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb3RvY29sLnNlbmRNZXNzYWdlKE1lc3NhZ2VIZWxwZXJzLmNyZWF0ZU1lc3NhZ2UoTWVzc2FnZXMucGluZywgeyB0aW1lOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSB9KSk7XG4gICAgfVxuICAgIG9uSGVhcnRiZWF0UmVzcG9uc2UocG9uZ01zZykge1xuICAgICAgICAvLyB3ZSBnb3QgYSBwb25nIHJlc3BvbnNlIGZyb20gdGhlIG90aGVyIHNpZGUsIHRoZSBjb25uZWN0aW9uIGlzIGdvb2QuXG4gICAgICAgIC8vIHdlIGFsc28gc3RvcmUgdGhlIHJvdW5kIHRyaXAgdGltZSBpZiBhbnlvbmUgaXMgY3VyaW91c1xuICAgICAgICB0aGlzLnJ0dCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gcG9uZ01zZy50aW1lO1xuICAgICAgICB0aGlzLmFsaXZlID0gdHJ1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1LZWVwYWxpdmVNb25pdG9yLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9FdmVudC9FdmVudEVtaXR0ZXInO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vTG9nZ2VyL0xvZ2dlcic7XG4vKipcbiAqIFNpZ25hbGxpbmcgcHJvdG9jb2wgZm9yIGhhbmRsaW5nIG1lc3NhZ2VzIGZyb20gdGhlIHNpZ25hbGxpbmcgc2VydmVyLlxuICpcbiAqIExpc3RlbiBvbiB0aGlzIGVtaXR0ZXIgZm9yIG1lc3NhZ2VzLiBNZXNzYWdlIHR5cGUgaXMgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3IuXG4gKiBFeGFtcGxlOlxuICogICAgICBzaWduYWxsaW5nUHJvdG9jb2wub24oJ2NvbmZpZycsIChtZXNzYWdlOiBNZXNzYWdlcy5jb25maWcpID1cXD4gY29uc29sZS5sb2coYEdvdCBhIGNvbmZpZyBtZXNzYWdlOiAke21lc3NhZ2V9YCkpKTtcbiAqXG4gKiBUaGUgdHJhbnNwb3J0IGluIHRoaXMgY2xhc3Mgd2lsbCBhbHNvIGVtaXQgb24gbWVzc2FnZSBldmVudHMuXG4gKlxuICogRXZlbnRzIGVtaXR0ZWQgb24gdHJhbnNwb3J0OlxuICogICBtZXNzYWdlOlxuICogICAgICBFbWl0dGVkIGFueSB0aW1lIGEgbWVzc2FnZSBpcyByZWNlaXZlZCBieSB0aGUgdHJhbnNwb3J0LiBMaXN0ZW4gb24gdGhpcyBpZlxuICogICAgICB5b3Ugd2lzaCB0byBjYXB0dXJlIGFsbCBtZXNzYWdlcywgcmF0aGVyIHRoYW4gc3BlY2lmaWMgbWVzc2FnZXMgb25cbiAqICAgICAgJ21lc3NhZ2VIYW5kbGVycycuXG4gKlxuICogICBvdXQ6XG4gKiAgICAgIEVtaXR0ZWQgd2hlbiBzZW5kaW5nIGEgbWVzc2FnZSBvdXQgb24gdGhlIHRyYW5zcG9ydC4gU2ltaWxhciB0byAnbWVzc2FnZScgYnV0XG4gKiAgICAgIG9ubHkgZm9yIHdoZW4gbWVzc2FnZXMgYXJlIHNlbnQgZnJvbSB0aGlzIGVuZHBvaW50LiBVc2VmdWwgZm9yIGRlYnVnZ2luZy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpZ25hbGxpbmdQcm90b2NvbCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgc3RhdGljIGdldCBTSUdOQUxMSU5HX1ZFUlNJT04oKSB7XG4gICAgICAgIHJldHVybiAnMS4zLjAnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIHRyYW5zcG9ydC5vbk1lc3NhZ2UgPSAobXNnKSA9PiB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkTWVzc2FnZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKG1zZyk7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkRlYnVnKCdQcm90b2NvbCByZWNlaXZlZCA9PiBcXG4nICsgSlNPTi5zdHJpbmdpZnkocGFyc2VkRGF0YSwgdW5kZWZpbmVkLCA0KSk7XG4gICAgICAgICAgICAgICAgcGFyc2VkTWVzc2FnZSA9IHBhcnNlZERhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBFcnJvciBwYXJzaW5nIG1lc3NhZ2Ugc3RyaW5nICR7bXNnfS5cXG4ke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihgVW5rbm93biBlcnJvciB3aGlsZSBwYXJzaW5nIG1lc3NhZ2UgZGF0YSBpbiBoYW5kbGVPbk1lc3NhZ2VgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2FsbCB0aGUgaGFuZGxlcnNcbiAgICAgICAgICAgIHRyYW5zcG9ydC5lbWl0KCdtZXNzYWdlJywgcGFyc2VkTWVzc2FnZSk7IC8vIGVtaXQgdGhpcyBmb3IgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhbnkgbWVzc2FnZVxuICAgICAgICAgICAgaWYgKCF0aGlzLmVtaXQocGFyc2VkTWVzc2FnZS50eXBlLCBwYXJzZWRNZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIC8vIGVtaXQgdGhpcyBmb3IgbGlzdGVuZXJzIGxpc3RlbmluZyBmb3Igc3BlY2lmaWMgbWVzc2FnZXNcbiAgICAgICAgICAgICAgICAvLyBubyBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3VuaGFuZGxlZCcsIHBhcnNlZE1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc2tzIHRoZSB0cmFuc3BvcnQgdG8gY29ubmVjdCB0byB0aGUgZ2l2ZW4gVVJMLlxuICAgICAqIEBwYXJhbSB1cmwgLSBUaGUgdXJsIHRvIGNvbm5lY3QgdG8uXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgY29ubmVjdGlvbiBjYWxsIHN1Y2NlZWRlZC5cbiAgICAgKi9cbiAgICBjb25uZWN0KHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuY29ubmVjdCh1cmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc2tzIHRoZSB0cmFuc3BvcnQgdG8gZGlzY29ubmVjdCBmcm9tIGFueSBjb25uZWN0aW9uIGl0IG1pZ2h0IGhhdmUuXG4gICAgICogQHBhcmFtIGNvZGUgLSBBbiBvcHRpb25hbCBkaXNjb25uZWN0aW9uIGNvZGUuXG4gICAgICogQHBhcmFtIHJlYXNvbiAtIEFuIG9wdGlvbmFsIGRlc2NyaXB0aXZlIHN0cmluZyBmb3IgdGhlIGRpc2Nvbm5lY3QgcmVhc29uLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoY29kZSwgcmVhc29uKSB7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmRpc2Nvbm5lY3QoY29kZSwgcmVhc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc3BvcnQgaXMgY29ubmVjdGVkIGFuZCByZWFkeSB0byBzZW5kL3JlY2VpdmUgbWVzc2FnZXMuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgcHJvdG9jb2wgaXMgY29ubmVjdGVkLlxuICAgICAqL1xuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuaXNDb25uZWN0ZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFzc2VzIGEgbWVzc2FnZSB0byB0aGUgdHJhbnNwb3J0IHRvIHNlbmQgdG8gdGhlIG90aGVyIGVuZC5cbiAgICAgKiBAcGFyYW0gbXNnIC0gVGhlIG1lc3NhZ2UgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBzZW5kTWVzc2FnZShtc2cpIHtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkobXNnKSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmVtaXQoJ291dCcsIG1zZyk7IC8vIGVtaXQgdGhpcyBmb3IgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBvdXRnb2luZyBtZXNzYWdlc1xuICAgICAgICBMb2dnZXIuRGVidWcoJ1Byb3RvY29sIHNlbnQgPT4gXFxuJyArIEpTT04uc3RyaW5naWZ5KG1zZywgdW5kZWZpbmVkLCA0KSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2lnbmFsbGluZ1Byb3RvY29sLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi9Mb2dnZXIvTG9nZ2VyJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4uL0V2ZW50L0V2ZW50RW1pdHRlcic7XG4vKipcbiAqIFRoZSBjb250cm9sbGVyIGZvciB0aGUgV2ViU29ja2V0IGFuZCBhbGwgYXNzb2NpYXRlZCBtZXRob2RzXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJTb2NrZXRUcmFuc3BvcnQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgV2ViU29ja2V0VHJhbnNwb3J0IGZvciBicm93c2VyIGNvbnRleHRzLlxuICAgICAqIEBwYXJhbSBwcm90b2NvbHMgLSBBbiBvcHRpb25hbCBzdHJpbmcgb3IgbGlzdCBvZiBzdHJpbmdzIHRvIHBhc3MgdG8gdGhlIG5ldyB3ZWJzb2NrZXQgcHJvdG9jb2xzIHBhcmFtXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdG9jb2xzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuV1NfT1BFTl9TVEFURSA9IDE7XG4gICAgICAgIHRoaXMucHJvdG9jb2xzID0gcHJvdG9jb2xzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2Ugb3ZlciB0aGUgd2Vic29ja2V0LlxuICAgICAqIEBwYXJhbSBtc2cgLSBUaGUgbWVzc2FnZSB0byBzZW5kLlxuICAgICAqL1xuICAgIHNlbmRNZXNzYWdlKG1zZykge1xuICAgICAgICBpZiAodGhpcy53ZWJTb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0LnNlbmQobXNnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRvIHRoZSBzaWduYWxpbmcgc2VydmVyXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25VUkwgLSBUaGUgQWRkcmVzcyBvZiB0aGUgc2lnbmFsaW5nIHNlcnZlclxuICAgICAqIEByZXR1cm5zIElmIHRoZXJlIGlzIGEgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGNvbm5lY3QoY29ubmVjdGlvblVSTCkge1xuICAgICAgICBMb2dnZXIuSW5mbyhjb25uZWN0aW9uVVJMKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0ID0gbmV3IFdlYlNvY2tldChjb25uZWN0aW9uVVJMLCB0aGlzLnByb3RvY29scyk7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldC5vbm9wZW4gPSAoXykgPT4gdGhpcy5oYW5kbGVPbk9wZW4oKTtcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0Lm9uZXJyb3IgPSAoXykgPT4gdGhpcy5oYW5kbGVPbkVycm9yKCk7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldC5vbmNsb3NlID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU9uQ2xvc2UoZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQub25tZXNzYWdlID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU9uTWVzc2FnZShldmVudCk7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldC5vbm1lc3NhZ2ViaW5hcnkgPSAoZXZlbnQpID0+IHRoaXMuaGFuZGxlT25NZXNzYWdlQmluYXJ5KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IHRoaXMgdHJhbnNwb3J0LlxuICAgICAqIEBwYXJhbSBjb2RlIC0gQW4gb3B0aW9uYWwgZGlzY29ubmVjdCBjb2RlLlxuICAgICAqIEBwYXJhbSByZWFzb24gLSBBIGRlc2NyaXB0aXZlIHN0cmluZyBmb3IgdGhlIGRpc2Nvbm5lY3QgcmVhc29uLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoY29kZSwgcmVhc29uKSB7XG4gICAgICAgIGlmICh0aGlzLndlYlNvY2tldCkge1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQuY2xvc2UoY29kZSwgcmVhc29uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG91bGQgcmV0dXJuIHRydWUgd2hlbiB0aGUgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZCBhbmQgcmVhZHkgdG8gc2VuZC9yZWNlaXZlIG1lc3NhZ2VzLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQuXG4gICAgICovXG4gICAgaXNDb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMud2ViU29ja2V0ICYmIHRoaXMud2ViU29ja2V0LnJlYWR5U3RhdGUgIT0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGF0IGhhcHBlbnMgd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgaW4gYmluYXJ5IGZvcm1cbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBNZXNzYWdlIFJlY2VpdmVkXG4gICAgICovXG4gICAgaGFuZGxlT25NZXNzYWdlQmluYXJ5KGV2ZW50KSB7XG4gICAgICAgIC8vIGlmIHRoZSBldmVudCBpcyBlbXB0eSByZXR1cm5cbiAgICAgICAgaWYgKCFldmVudCB8fCAhZXZlbnQuZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSB0aGUgYmluYXJ5IGFuZCB0aGVuIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgICAgICBldmVudC5kYXRhXG4gICAgICAgICAgICAudGV4dCgpXG4gICAgICAgICAgICAudGhlbigobWVzc2FnZVN0cmluZykgPT4ge1xuICAgICAgICAgICAgLy8gYnVpbGQgYSBuZXcgbWVzc2FnZVxuICAgICAgICAgICAgY29uc3QgY29uc3RydWN0ZWRNZXNzYWdlID0gbmV3IE1lc3NhZ2VFdmVudCgnbWVzc2FnZUZyb21CaW5hcnknLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogbWVzc2FnZVN0cmluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBzZW5kIHRoZSBuZXcgc3RyaW5naWZpZWQgZXZlbnQgYmFjayBpbnRvIGBvbm1lc3NhZ2VgXG4gICAgICAgICAgICB0aGlzLmhhbmRsZU9uTWVzc2FnZShjb25zdHJ1Y3RlZE1lc3NhZ2UpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBGYWlsZWQgdG8gcGFyc2UgYmluYXJ5IGJsb2IgZnJvbSB3ZWJzb2NrZXQsIHJlYXNvbjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGF0IGhhcHBlbnMgd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWRcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBNZXNzYWdlIFJlY2VpdmVkXG4gICAgICovXG4gICAgaGFuZGxlT25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHdlYnNvY2tldCBtZXNzYWdlIGlzIGJpbmFyeSwgaWYgc28sIHN0cmluZ2lmeSBpdC5cbiAgICAgICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlT25NZXNzYWdlQmluYXJ5KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vbk1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25NZXNzYWdlKGV2ZW50LmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hlbiB0aGUgV2Vic29ja2V0IGlzIG9wZW5lZFxuICAgICAqL1xuICAgIGhhbmRsZU9uT3BlbigpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ0Nvbm5lY3RlZCB0byB0aGUgc2lnbmFsbGluZyBzZXJ2ZXIgdmlhIFdlYlNvY2tldCcpO1xuICAgICAgICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIG9uIHRoZSB3ZWJzb2NrZXRcbiAgICAgKi9cbiAgICBoYW5kbGVPbkVycm9yKCkge1xuICAgICAgICAvL0xvZ2dlci5FcnJvcihMb2dnZXIuR2V0U3RhY2tUcmFjZSgpLCAnV2ViU29ja2V0IGVycm9yJyk7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIHRoZSBXZWJzb2NrZXQgaXMgY2xvc2VkXG4gICAgICogQHBhcmFtIGV2ZW50IC0gQ2xvc2UgRXZlbnRcbiAgICAgKi9cbiAgICBoYW5kbGVPbkNsb3NlKGV2ZW50KSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCdEaXNjb25uZWN0ZWQgdG8gdGhlIHNpZ25hbGxpbmcgc2VydmVyIHZpYSBXZWJTb2NrZXQ6ICcgK1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoZXZlbnQuY29kZSkgK1xuICAgICAgICAgICAgJyAtICcgK1xuICAgICAgICAgICAgZXZlbnQucmVhc29uKTtcbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIGV2ZW50KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XZWJTb2NrZXRUcmFuc3BvcnQuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmV4cG9ydCBjbGFzcyBTRFBVdGlscyB7XG4gICAgc3RhdGljIGFkZFZpZGVvSGVhZGVyRXh0ZW5zaW9uVG9TZHAoc2RwLCB1cmkpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgaGlnaGVzdCB1c2VkIGhlYWRlciBleHRlbnNpb24gaWQgYnkgc29ydGluZyB0aGUgZXh0ZW5zaW9uIGlkcyB1c2VkLFxuICAgICAgICAvLyBlbGltaW5hdGluZyBkdXBsaWNhdGVzIGFuZCBhZGRpbmcgb25lLlxuICAgICAgICAvLyBUb2RvOiBVcGRhdGUgdGhpcyB3aGVuIFdlYlJUQyBpbiBDaHJvbWUgc3VwcG9ydHMgdGhlIGhlYWRlciBleHRlbnNpb24gQVBJLlxuICAgICAgICBjb25zdCB1c2VkSWRzID0gc2RwXG4gICAgICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgICAgICAuZmlsdGVyKChsaW5lKSA9PiBsaW5lLnN0YXJ0c1dpdGgoJ2E9ZXh0bWFwOicpKVxuICAgICAgICAgICAgLm1hcCgobGluZSkgPT4gcGFyc2VJbnQobGluZS5zcGxpdCgnICcpWzBdLnN1YnN0cmluZyg5KSwgMTApKVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgICAgICAgICAgLmZpbHRlcigoaXRlbSwgaW5kZXgsIGFycmF5KSA9PiBhcnJheS5pbmRleE9mKGl0ZW0pID09PSBpbmRleCk7XG4gICAgICAgIGNvbnN0IG5leHRJZCA9IHVzZWRJZHNbdXNlZElkcy5sZW5ndGggLSAxXSArIDE7XG4gICAgICAgIGNvbnN0IGV4dG1hcExpbmUgPSAnYT1leHRtYXA6JyArIG5leHRJZCArICcgJyArIHVyaSArICdcXHJcXG4nO1xuICAgICAgICBjb25zdCBzZWN0aW9ucyA9IHNkcC5zcGxpdCgnXFxubT0nKS5tYXAoKHBhcnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGluZGV4ID4gMCA/ICdtPScgKyBwYXJ0IDogcGFydCkudHJpbSgpICsgJ1xcclxcbic7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzZXNzaW9uUGFydCA9IHNlY3Rpb25zLnNoaWZ0KCk7XG4gICAgICAgIC8vIE9ubHkgYWRkIGV4dGVuc2lvbiB0byBtPXZpZGVvIG1lZGlhIHNlY3Rpb25cbiAgICAgICAgcmV0dXJuIChzZXNzaW9uUGFydCArXG4gICAgICAgICAgICBzZWN0aW9uc1xuICAgICAgICAgICAgICAgIC5tYXAoKG1lZGlhU2VjdGlvbikgPT4gbWVkaWFTZWN0aW9uLnN0YXJ0c1dpdGgoJ209dmlkZW8nKSA/IG1lZGlhU2VjdGlvbiArIGV4dG1hcExpbmUgOiBtZWRpYVNlY3Rpb24pXG4gICAgICAgICAgICAgICAgLmpvaW4oJycpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZHBVdGlscy5qcy5tYXAiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGUpIHtcbiAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICByZXR1cm4gZTtcbn1cbmV4cG9ydCB7IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgYXMgZGVmYXVsdCB9OyIsImltcG9ydCB0b1Byb3BlcnR5S2V5IGZyb20gXCIuL3RvUHJvcGVydHlLZXkuanNcIjtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG8gPSByW3RdO1xuICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7XG4gIHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogITFcbiAgfSksIGU7XG59XG5leHBvcnQgeyBfY3JlYXRlQ2xhc3MgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICByZXR1cm4gX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAobikge1xuICAgIGZvciAodmFyIGUgPSAxOyBlIDwgYXJndW1lbnRzLmxlbmd0aDsgZSsrKSB7XG4gICAgICB2YXIgdCA9IGFyZ3VtZW50c1tlXTtcbiAgICAgIGZvciAodmFyIHIgaW4gdCkgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIHIpICYmIChuW3JdID0gdFtyXSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9LCBfZXh0ZW5kcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuZXhwb3J0IHsgX2V4dGVuZHMgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBzZXRQcm90b3R5cGVPZiBmcm9tIFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiO1xuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2UodCwgbykge1xuICB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoby5wcm90b3R5cGUpLCB0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHQsIHNldFByb3RvdHlwZU9mKHQsIG8pO1xufVxuZXhwb3J0IHsgX2luaGVyaXRzTG9vc2UgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHIsIGUpIHtcbiAgaWYgKG51bGwgPT0gcikgcmV0dXJuIHt9O1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBuIGluIHIpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIG4pKSB7XG4gICAgaWYgKC0xICE9PSBlLmluZGV4T2YobikpIGNvbnRpbnVlO1xuICAgIHRbbl0gPSByW25dO1xuICB9XG4gIHJldHVybiB0O1xufVxuZXhwb3J0IHsgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZih0LCBlKSB7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gPSBlLCB0O1xuICB9LCBfc2V0UHJvdG90eXBlT2YodCwgZSk7XG59XG5leHBvcnQgeyBfc2V0UHJvdG90eXBlT2YgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfdHlwZW9mIGZyb20gXCIuL3R5cGVvZi5qc1wiO1xuZnVuY3Rpb24gdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbmV4cG9ydCB7IHRvUHJpbWl0aXZlIGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiLi90eXBlb2YuanNcIjtcbmltcG9ydCB0b1ByaW1pdGl2ZSBmcm9tIFwiLi90b1ByaW1pdGl2ZS5qc1wiO1xuZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7XG59XG5leHBvcnQgeyB0b1Byb3BlcnR5S2V5IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBfdHlwZW9mKG8pO1xufVxuZXhwb3J0IHsgX3R5cGVvZiBhcyBkZWZhdWx0IH07IiwiLyoqXG4gKiBhc3NlcnQgdGhhdCBjb25kaXRpb24gaXMgdHJ1ZSBvciB0aHJvdyBlcnJvciAod2l0aCBtZXNzYWdlKVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuLyoqXG4gKiBhc3NlcnQgdGhhdCB2YWx1ZSBjYW5ub3QgZXhpc3QgPSB0eXBlIGBuZXZlcmAuIHRocm93IHJ1bnRpbWUgZXJyb3IgaWYgaXQgZG9lcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5ldmVyKHZhbHVlLCBtc2cpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnICE9PSBudWxsICYmIG1zZyAhPT0gdm9pZCAwID8gbXNnIDogJ1VuZXhwZWN0ZWQgb2JqZWN0OiAnICsgdmFsdWUpO1xufVxuY29uc3QgRkxPQVQzMl9NQVggPSAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCBGTE9BVDMyX01JTiA9IC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCBVSU5UMzJfTUFYID0gMHhGRkZGRkZGRiwgSU5UMzJfTUFYID0gMFg3RkZGRkZGRiwgSU5UMzJfTUlOID0gLTBYODAwMDAwMDA7XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SW50MzIoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnQgMzI6ICcgKyB0eXBlb2YgYXJnKTtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJnKSB8fCBhcmcgPiBJTlQzMl9NQVggfHwgYXJnIDwgSU5UMzJfTUlOKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW50IDMyOiAnICsgYXJnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRVSW50MzIoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB1aW50IDMyOiAnICsgdHlwZW9mIGFyZyk7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGFyZykgfHwgYXJnID4gVUlOVDMyX01BWCB8fCBhcmcgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdWludCAzMjogJyArIGFyZyk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RmxvYXQzMihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZsb2F0IDMyOiAnICsgdHlwZW9mIGFyZyk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYXJnKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChhcmcgPiBGTE9BVDMyX01BWCB8fCBhcmcgPCBGTE9BVDMyX01JTilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZsb2F0IDMyOiAnICsgYXJnKTtcbn1cbiIsIi8vIGxvb2t1cCB0YWJsZSBmcm9tIGJhc2U2NCBjaGFyYWN0ZXIgdG8gYnl0ZVxubGV0IGVuY1RhYmxlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcbi8vIGxvb2t1cCB0YWJsZSBmcm9tIGJhc2U2NCBjaGFyYWN0ZXIgKmNvZGUqIHRvIGJ5dGUgYmVjYXVzZSBsb29rdXAgYnkgbnVtYmVyIGlzIGZhc3RcbmxldCBkZWNUYWJsZSA9IFtdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNUYWJsZS5sZW5ndGg7IGkrKylcbiAgICBkZWNUYWJsZVtlbmNUYWJsZVtpXS5jaGFyQ29kZUF0KDApXSA9IGk7XG4vLyBzdXBwb3J0IGJhc2U2NHVybCB2YXJpYW50c1xuZGVjVGFibGVbXCItXCIuY2hhckNvZGVBdCgwKV0gPSBlbmNUYWJsZS5pbmRleE9mKFwiK1wiKTtcbmRlY1RhYmxlW1wiX1wiLmNoYXJDb2RlQXQoMCldID0gZW5jVGFibGUuaW5kZXhPZihcIi9cIik7XG4vKipcbiAqIERlY29kZXMgYSBiYXNlNjQgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheS5cbiAqXG4gKiAtIGlnbm9yZXMgd2hpdGUtc3BhY2UsIGluY2x1ZGluZyBsaW5lIGJyZWFrcyBhbmQgdGFic1xuICogLSBhbGxvd3MgaW5uZXIgcGFkZGluZyAoY2FuIGRlY29kZSBjb25jYXRlbmF0ZWQgYmFzZTY0IHN0cmluZ3MpXG4gKiAtIGRvZXMgbm90IHJlcXVpcmUgcGFkZGluZ1xuICogLSB1bmRlcnN0YW5kcyBiYXNlNjR1cmwgZW5jb2Rpbmc6XG4gKiAgIFwiLVwiIGluc3RlYWQgb2YgXCIrXCIsXG4gKiAgIFwiX1wiIGluc3RlYWQgb2YgXCIvXCIsXG4gKiAgIG5vIHBhZGRpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NGRlY29kZShiYXNlNjRTdHIpIHtcbiAgICAvLyBlc3RpbWF0ZSBieXRlIHNpemUsIG5vdCBhY2NvdW50aW5nIGZvciBpbm5lciBwYWRkaW5nIGFuZCB3aGl0ZXNwYWNlXG4gICAgbGV0IGVzID0gYmFzZTY0U3RyLmxlbmd0aCAqIDMgLyA0O1xuICAgIC8vIGlmIChlcyAlIDMgIT09IDApXG4gICAgLy8gdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJhc2U2NCBzdHJpbmcnKTtcbiAgICBpZiAoYmFzZTY0U3RyW2Jhc2U2NFN0ci5sZW5ndGggLSAyXSA9PSAnPScpXG4gICAgICAgIGVzIC09IDI7XG4gICAgZWxzZSBpZiAoYmFzZTY0U3RyW2Jhc2U2NFN0ci5sZW5ndGggLSAxXSA9PSAnPScpXG4gICAgICAgIGVzIC09IDE7XG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZXMpLCBieXRlUG9zID0gMCwgLy8gcG9zaXRpb24gaW4gYnl0ZSBhcnJheVxuICAgIGdyb3VwUG9zID0gMCwgLy8gcG9zaXRpb24gaW4gYmFzZTY0IGdyb3VwXG4gICAgYiwgLy8gY3VycmVudCBieXRlXG4gICAgcCA9IDAgLy8gcHJldmlvdXMgYnl0ZVxuICAgIDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2U2NFN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBiID0gZGVjVGFibGVbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSldO1xuICAgICAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gRmFsbFRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgICAgICAgICBzd2l0Y2ggKGJhc2U2NFN0cltpXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgICAgICAgICBncm91cFBvcyA9IDA7IC8vIHJlc2V0IHN0YXRlIHdoZW4gcGFkZGluZyBmb3VuZFxuICAgICAgICAgICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgICAgICAgY2FzZSAnXFxyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCB3aGl0ZS1zcGFjZSwgYW5kIHBhZGRpbmdcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgaW52YWxpZCBiYXNlNjQgc3RyaW5nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZ3JvdXBQb3MpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBwID0gYjtcbiAgICAgICAgICAgICAgICBncm91cFBvcyA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYnl0ZXNbYnl0ZVBvcysrXSA9IHAgPDwgMiB8IChiICYgNDgpID4+IDQ7XG4gICAgICAgICAgICAgICAgcCA9IGI7XG4gICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGJ5dGVzW2J5dGVQb3MrK10gPSAocCAmIDE1KSA8PCA0IHwgKGIgJiA2MCkgPj4gMjtcbiAgICAgICAgICAgICAgICBwID0gYjtcbiAgICAgICAgICAgICAgICBncm91cFBvcyA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgYnl0ZXNbYnl0ZVBvcysrXSA9IChwICYgMykgPDwgNiB8IGI7XG4gICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChncm91cFBvcyA9PSAxKVxuICAgICAgICB0aHJvdyBFcnJvcihgaW52YWxpZCBiYXNlNjQgc3RyaW5nLmApO1xuICAgIHJldHVybiBieXRlcy5zdWJhcnJheSgwLCBieXRlUG9zKTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIGJ5dGUgYXJyYXkgdG8gYSBiYXNlNjQgc3RyaW5nLlxuICogQWRkcyBwYWRkaW5nIGF0IHRoZSBlbmQuXG4gKiBEb2VzIG5vdCBpbnNlcnQgbmV3bGluZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRlbmNvZGUoYnl0ZXMpIHtcbiAgICBsZXQgYmFzZTY0ID0gJycsIGdyb3VwUG9zID0gMCwgLy8gcG9zaXRpb24gaW4gYmFzZTY0IGdyb3VwXG4gICAgYiwgLy8gY3VycmVudCBieXRlXG4gICAgcCA9IDA7IC8vIGNhcnJ5IG92ZXIgZnJvbSBwcmV2aW91cyBieXRlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBiID0gYnl0ZXNbaV07XG4gICAgICAgIHN3aXRjaCAoZ3JvdXBQb3MpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbYiA+PiAyXTtcbiAgICAgICAgICAgICAgICBwID0gKGIgJiAzKSA8PCA0O1xuICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcCB8IGIgPj4gNF07XG4gICAgICAgICAgICAgICAgcCA9IChiICYgMTUpIDw8IDI7XG4gICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtwIHwgYiA+PiA2XTtcbiAgICAgICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbYiAmIDYzXTtcbiAgICAgICAgICAgICAgICBncm91cFBvcyA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcGFkZGluZyByZXF1aXJlZD9cbiAgICBpZiAoZ3JvdXBQb3MpIHtcbiAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW3BdO1xuICAgICAgICBiYXNlNjQgKz0gJz0nO1xuICAgICAgICBpZiAoZ3JvdXBQb3MgPT0gMSlcbiAgICAgICAgICAgIGJhc2U2NCArPSAnPSc7XG4gICAgfVxuICAgIHJldHVybiBiYXNlNjQ7XG59XG4iLCIvKipcbiAqIFRoaXMgaGFuZGxlciBpbXBsZW1lbnRzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBmb3IgdW5rbm93biBmaWVsZHMuXG4gKiBXaGVuIHJlYWRpbmcgZGF0YSwgdW5rbm93biBmaWVsZHMgYXJlIHN0b3JlZCBvbiB0aGUgbWVzc2FnZSwgaW4gYVxuICogc3ltYm9sIHByb3BlcnR5LlxuICogV2hlbiB3cml0aW5nIGRhdGEsIHRoZSBzeW1ib2wgcHJvcGVydHkgaXMgcXVlcmllZCBhbmQgdW5rbm93biBmaWVsZHNcbiAqIGFyZSBzZXJpYWxpemVkIGludG8gdGhlIG91dHB1dCBhZ2Fpbi5cbiAqL1xuZXhwb3J0IHZhciBVbmtub3duRmllbGRIYW5kbGVyO1xuKGZ1bmN0aW9uIChVbmtub3duRmllbGRIYW5kbGVyKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHN5bWJvbCB1c2VkIHRvIHN0b3JlIHVua25vd24gZmllbGRzIGZvciBhIG1lc3NhZ2UuXG4gICAgICogVGhlIHByb3BlcnR5IG11c3QgY29uZm9ybSB0byBgVW5rbm93bkZpZWxkQ29udGFpbmVyYC5cbiAgICAgKi9cbiAgICBVbmtub3duRmllbGRIYW5kbGVyLnN5bWJvbCA9IFN5bWJvbC5mb3IoXCJwcm90b2J1Zi10cy91bmtub3duXCIpO1xuICAgIC8qKlxuICAgICAqIFN0b3JlIGFuIHVua25vd24gZmllbGQgZHVyaW5nIGJpbmFyeSByZWFkIGRpcmVjdGx5IG9uIHRoZSBtZXNzYWdlLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvbXBhdGlibGUgd2l0aCBgQmluYXJ5UmVhZE9wdGlvbnMucmVhZFVua25vd25GaWVsZGAuXG4gICAgICovXG4gICAgVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgPSAodHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkYXRhKSA9PiB7XG4gICAgICAgIGxldCBjb250YWluZXIgPSBpcyhtZXNzYWdlKSA/IG1lc3NhZ2VbVW5rbm93bkZpZWxkSGFuZGxlci5zeW1ib2xdIDogbWVzc2FnZVtVbmtub3duRmllbGRIYW5kbGVyLnN5bWJvbF0gPSBbXTtcbiAgICAgICAgY29udGFpbmVyLnB1c2goeyBubzogZmllbGRObywgd2lyZVR5cGUsIGRhdGEgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZSB1bmtub3duIGZpZWxkcyBzdG9yZWQgZm9yIHRoZSBtZXNzYWdlIHRvIHRoZSB3cml0ZXIuXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29tcGF0aWJsZSB3aXRoIGBCaW5hcnlXcml0ZU9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzYC5cbiAgICAgKi9cbiAgICBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgPSAodHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcikgPT4ge1xuICAgICAgICBmb3IgKGxldCB7IG5vLCB3aXJlVHlwZSwgZGF0YSB9IG9mIFVua25vd25GaWVsZEhhbmRsZXIubGlzdChtZXNzYWdlKSlcbiAgICAgICAgICAgIHdyaXRlci50YWcobm8sIHdpcmVUeXBlKS5yYXcoZGF0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMaXN0IHVua25vd24gZmllbGRzIHN0b3JlZCBmb3IgdGhlIG1lc3NhZ2UuXG4gICAgICogTm90ZSB0aGF0IHRoZXJlIG1heSBiZSBtdWx0aXBsZXMgZmllbGRzIHdpdGggdGhlIHNhbWUgbnVtYmVyLlxuICAgICAqL1xuICAgIFVua25vd25GaWVsZEhhbmRsZXIubGlzdCA9IChtZXNzYWdlLCBmaWVsZE5vKSA9PiB7XG4gICAgICAgIGlmIChpcyhtZXNzYWdlKSkge1xuICAgICAgICAgICAgbGV0IGFsbCA9IG1lc3NhZ2VbVW5rbm93bkZpZWxkSGFuZGxlci5zeW1ib2xdO1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkTm8gPyBhbGwuZmlsdGVyKHVmID0+IHVmLm5vID09IGZpZWxkTm8pIDogYWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhc3QgdW5rbm93biBmaWVsZCBieSBmaWVsZCBudW1iZXIuXG4gICAgICovXG4gICAgVW5rbm93bkZpZWxkSGFuZGxlci5sYXN0ID0gKG1lc3NhZ2UsIGZpZWxkTm8pID0+IFVua25vd25GaWVsZEhhbmRsZXIubGlzdChtZXNzYWdlLCBmaWVsZE5vKS5zbGljZSgtMSlbMF07XG4gICAgY29uc3QgaXMgPSAobWVzc2FnZSkgPT4gbWVzc2FnZSAmJiBBcnJheS5pc0FycmF5KG1lc3NhZ2VbVW5rbm93bkZpZWxkSGFuZGxlci5zeW1ib2xdKTtcbn0pKFVua25vd25GaWVsZEhhbmRsZXIgfHwgKFVua25vd25GaWVsZEhhbmRsZXIgPSB7fSkpO1xuLyoqXG4gKiBNZXJnZXMgYmluYXJ5IHdyaXRlIG9yIHJlYWQgb3B0aW9ucy4gTGF0ZXIgdmFsdWVzIG92ZXJyaWRlIGVhcmxpZXIgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VCaW5hcnlPcHRpb25zKGEsIGIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhKSwgYik7XG59XG4vKipcbiAqIFByb3RvYnVmIGJpbmFyeSBmb3JtYXQgd2lyZSB0eXBlcy5cbiAqXG4gKiBBIHdpcmUgdHlwZSBwcm92aWRlcyBqdXN0IGVub3VnaCBpbmZvcm1hdGlvbiB0byBmaW5kIHRoZSBsZW5ndGggb2YgdGhlXG4gKiBmb2xsb3dpbmcgdmFsdWUuXG4gKlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9lbmNvZGluZyNzdHJ1Y3R1cmVcbiAqL1xuZXhwb3J0IHZhciBXaXJlVHlwZTtcbihmdW5jdGlvbiAoV2lyZVR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBpbnQzMiwgaW50NjQsIHVpbnQzMiwgdWludDY0LCBzaW50MzIsIHNpbnQ2NCwgYm9vbCwgZW51bVxuICAgICAqL1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiVmFyaW50XCJdID0gMF0gPSBcIlZhcmludFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGZpeGVkNjQsIHNmaXhlZDY0LCBkb3VibGUuXG4gICAgICogQWx3YXlzIDggYnl0ZXMgd2l0aCBsaXR0bGUtZW5kaWFuIGJ5dGUgb3JkZXIuXG4gICAgICovXG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJCaXQ2NFwiXSA9IDFdID0gXCJCaXQ2NFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIHN0cmluZywgYnl0ZXMsIGVtYmVkZGVkIG1lc3NhZ2VzLCBwYWNrZWQgcmVwZWF0ZWQgZmllbGRzXG4gICAgICpcbiAgICAgKiBPbmx5IHJlcGVhdGVkIG51bWVyaWMgdHlwZXMgKHR5cGVzIHdoaWNoIHVzZSB0aGUgdmFyaW50LCAzMi1iaXQsXG4gICAgICogb3IgNjQtYml0IHdpcmUgdHlwZXMpIGNhbiBiZSBwYWNrZWQuIEluIHByb3RvMywgc3VjaCBmaWVsZHMgYXJlXG4gICAgICogcGFja2VkIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJMZW5ndGhEZWxpbWl0ZWRcIl0gPSAyXSA9IFwiTGVuZ3RoRGVsaW1pdGVkXCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgZ3JvdXBzXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIlN0YXJ0R3JvdXBcIl0gPSAzXSA9IFwiU3RhcnRHcm91cFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGdyb3Vwc1xuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJFbmRHcm91cFwiXSA9IDRdID0gXCJFbmRHcm91cFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGZpeGVkMzIsIHNmaXhlZDMyLCBmbG9hdC5cbiAgICAgKiBBbHdheXMgNCBieXRlcyB3aXRoIGxpdHRsZS1lbmRpYW4gYnl0ZSBvcmRlci5cbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIkJpdDMyXCJdID0gNV0gPSBcIkJpdDMyXCI7XG59KShXaXJlVHlwZSB8fCAoV2lyZVR5cGUgPSB7fSkpO1xuIiwiaW1wb3J0IHsgV2lyZVR5cGUgfSBmcm9tIFwiLi9iaW5hcnktZm9ybWF0LWNvbnRyYWN0XCI7XG5pbXBvcnQgeyBQYkxvbmcsIFBiVUxvbmcgfSBmcm9tIFwiLi9wYi1sb25nXCI7XG5pbXBvcnQgeyB2YXJpbnQzMnJlYWQsIHZhcmludDY0cmVhZCB9IGZyb20gXCIuL2dvb2ctdmFyaW50XCI7XG5jb25zdCBkZWZhdWx0c1JlYWQgPSB7XG4gICAgcmVhZFVua25vd25GaWVsZDogdHJ1ZSxcbiAgICByZWFkZXJGYWN0b3J5OiBieXRlcyA9PiBuZXcgQmluYXJ5UmVhZGVyKGJ5dGVzKSxcbn07XG4vKipcbiAqIE1ha2Ugb3B0aW9ucyBmb3IgcmVhZGluZyBiaW5hcnkgZGF0YSBmb3JtIHBhcnRpYWwgb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVJlYWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHNSZWFkKSwgb3B0aW9ucykgOiBkZWZhdWx0c1JlYWQ7XG59XG5leHBvcnQgY2xhc3MgQmluYXJ5UmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihidWYsIHRleHREZWNvZGVyKSB7XG4gICAgICAgIHRoaXMudmFyaW50NjQgPSB2YXJpbnQ2NHJlYWQ7IC8vIGRpcnR5IGNhc3QgZm9yIGB0aGlzYFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVhZCBhIGB1aW50MzJgIGZpZWxkLCBhbiB1bnNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51aW50MzIgPSB2YXJpbnQzMnJlYWQ7IC8vIGRpcnR5IGNhc3QgZm9yIGB0aGlzYCBhbmQgYWNjZXNzIHRvIHByb3RlY3RlZCBgYnVmYFxuICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICAgICAgdGhpcy5sZW4gPSBidWYubGVuZ3RoO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyhidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLnRleHREZWNvZGVyID0gdGV4dERlY29kZXIgIT09IG51bGwgJiYgdGV4dERlY29kZXIgIT09IHZvaWQgMCA/IHRleHREZWNvZGVyIDogbmV3IFRleHREZWNvZGVyKFwidXRmLThcIiwge1xuICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICBpZ25vcmVCT006IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIHRhZyAtIGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlLlxuICAgICAqL1xuICAgIHRhZygpIHtcbiAgICAgICAgbGV0IHRhZyA9IHRoaXMudWludDMyKCksIGZpZWxkTm8gPSB0YWcgPj4+IDMsIHdpcmVUeXBlID0gdGFnICYgNztcbiAgICAgICAgaWYgKGZpZWxkTm8gPD0gMCB8fCB3aXJlVHlwZSA8IDAgfHwgd2lyZVR5cGUgPiA1KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0YWc6IGZpZWxkIG5vIFwiICsgZmllbGRObyArIFwiIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlKTtcbiAgICAgICAgcmV0dXJuIFtmaWVsZE5vLCB3aXJlVHlwZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNraXAgb25lIGVsZW1lbnQgb24gdGhlIHdpcmUgYW5kIHJldHVybiB0aGUgc2tpcHBlZCBkYXRhLlxuICAgICAqIFN1cHBvcnRzIFdpcmVUeXBlLlN0YXJ0R3JvdXAgc2luY2UgdjIuMC4wLWFscGhhLjIzLlxuICAgICAqL1xuICAgIHNraXAod2lyZVR5cGUpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBGYWxsVGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICAgICAgc3dpdGNoICh3aXJlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBXaXJlVHlwZS5WYXJpbnQ6XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLkJpdDY0OlxuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLkJpdDMyOlxuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDpcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gdGhpcy51aW50MzIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSBsZW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLlN0YXJ0R3JvdXA6XG4gICAgICAgICAgICAgICAgLy8gRnJvbSBkZXNjcmlwdG9yLnByb3RvOiBHcm91cCB0eXBlIGlzIGRlcHJlY2F0ZWQsIG5vdCBzdXBwb3J0ZWQgaW4gcHJvdG8zLlxuICAgICAgICAgICAgICAgIC8vIEJ1dCB3ZSBtdXN0IHN0aWxsIGJlIGFibGUgdG8gcGFyc2UgYW5kIHRyZWF0IGFzIHVua25vd24uXG4gICAgICAgICAgICAgICAgbGV0IHQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCh0ID0gdGhpcy50YWcoKVsxXSkgIT09IFdpcmVUeXBlLkVuZEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcCh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbnQgc2tpcCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnN1YmFycmF5KHN0YXJ0LCB0aGlzLnBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRocm93cyBlcnJvciBpZiBwb3NpdGlvbiBpbiBieXRlIGFycmF5IGlzIG91dCBvZiByYW5nZS5cbiAgICAgKi9cbiAgICBhc3NlcnRCb3VuZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA+IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJwcmVtYXR1cmUgRU9GXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGludDMyYCBmaWVsZCwgYSBzaWduZWQgMzIgYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBpbnQzMigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDMyKCkgfCAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHNpbnQzMmAgZmllbGQsIGEgc2lnbmVkLCB6aWd6YWctZW5jb2RlZCAzMi1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHNpbnQzMigpIHtcbiAgICAgICAgbGV0IHp6ZSA9IHRoaXMudWludDMyKCk7XG4gICAgICAgIC8vIGRlY29kZSB6aWd6YWdcbiAgICAgICAgcmV0dXJuICh6emUgPj4+IDEpIF4gLSh6emUgJiAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBpbnQ2NGAgZmllbGQsIGEgc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgaW50NjQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGJMb25nKC4uLnRoaXMudmFyaW50NjQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgdWludDY0YCBmaWVsZCwgYW4gdW5zaWduZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICB1aW50NjQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGJVTG9uZyguLi50aGlzLnZhcmludDY0KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHNpbnQ2NGAgZmllbGQsIGEgc2lnbmVkLCB6aWctemFnLWVuY29kZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBzaW50NjQoKSB7XG4gICAgICAgIGxldCBbbG8sIGhpXSA9IHRoaXMudmFyaW50NjQoKTtcbiAgICAgICAgLy8gZGVjb2RlIHppZyB6YWdcbiAgICAgICAgbGV0IHMgPSAtKGxvICYgMSk7XG4gICAgICAgIGxvID0gKChsbyA+Pj4gMSB8IChoaSAmIDEpIDw8IDMxKSBeIHMpO1xuICAgICAgICBoaSA9IChoaSA+Pj4gMSBeIHMpO1xuICAgICAgICByZXR1cm4gbmV3IFBiTG9uZyhsbywgaGkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGJvb2xgIGZpZWxkLCBhIHZhcmlhbnQuXG4gICAgICovXG4gICAgYm9vbCgpIHtcbiAgICAgICAgbGV0IFtsbywgaGldID0gdGhpcy52YXJpbnQ2NCgpO1xuICAgICAgICByZXR1cm4gbG8gIT09IDAgfHwgaGkgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgZml4ZWQzMmAgZmllbGQsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgZml4ZWQzMigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRVaW50MzIoKHRoaXMucG9zICs9IDQpIC0gNCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgc2ZpeGVkMzJgIGZpZWxkLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIHNmaXhlZDMyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldEludDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGZpeGVkNjRgIGZpZWxkLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0IGJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGZpeGVkNjQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGJVTG9uZyh0aGlzLnNmaXhlZDMyKCksIHRoaXMuc2ZpeGVkMzIoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgZml4ZWQ2NGAgZmllbGQsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQtYml0IGludGVnZXIuXG4gICAgICovXG4gICAgc2ZpeGVkNjQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGJMb25nKHRoaXMuc2ZpeGVkMzIoKSwgdGhpcy5zZml4ZWQzMigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBmbG9hdGAgZmllbGQsIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAgICovXG4gICAgZmxvYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0RmxvYXQzMigodGhpcy5wb3MgKz0gNCkgLSA0LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBkb3VibGVgIGZpZWxkLCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAgICovXG4gICAgZG91YmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldEZsb2F0NjQoKHRoaXMucG9zICs9IDgpIC0gOCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgYnl0ZXNgIGZpZWxkLCBsZW5ndGgtZGVsaW1pdGVkIGFyYml0cmFyeSBkYXRhLlxuICAgICAqL1xuICAgIGJ5dGVzKCkge1xuICAgICAgICBsZXQgbGVuID0gdGhpcy51aW50MzIoKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgc3RyaW5nYCBmaWVsZCwgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGNvbnZlcnRlZCB0byBVVEYtOCB0ZXh0LlxuICAgICAqL1xuICAgIHN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dERlY29kZXIuZGVjb2RlKHRoaXMuYnl0ZXMoKSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgUGJMb25nLCBQYlVMb25nIH0gZnJvbSBcIi4vcGItbG9uZ1wiO1xuaW1wb3J0IHsgdmFyaW50MzJ3cml0ZSwgdmFyaW50NjR3cml0ZSB9IGZyb20gXCIuL2dvb2ctdmFyaW50XCI7XG5pbXBvcnQgeyBhc3NlcnRGbG9hdDMyLCBhc3NlcnRJbnQzMiwgYXNzZXJ0VUludDMyIH0gZnJvbSBcIi4vYXNzZXJ0XCI7XG5jb25zdCBkZWZhdWx0c1dyaXRlID0ge1xuICAgIHdyaXRlVW5rbm93bkZpZWxkczogdHJ1ZSxcbiAgICB3cml0ZXJGYWN0b3J5OiAoKSA9PiBuZXcgQmluYXJ5V3JpdGVyKCksXG59O1xuLyoqXG4gKiBNYWtlIG9wdGlvbnMgZm9yIHdyaXRpbmcgYmluYXJ5IGRhdGEgZm9ybSBwYXJ0aWFsIG9wdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlXcml0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0c1dyaXRlKSwgb3B0aW9ucykgOiBkZWZhdWx0c1dyaXRlO1xufVxuZXhwb3J0IGNsYXNzIEJpbmFyeVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IodGV4dEVuY29kZXIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByZXZpb3VzIGZvcmsgc3RhdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICB0aGlzLnRleHRFbmNvZGVyID0gdGV4dEVuY29kZXIgIT09IG51bGwgJiYgdGV4dEVuY29kZXIgIT09IHZvaWQgMCA/IHRleHRFbmNvZGVyIDogbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuYnVmID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbGwgYnl0ZXMgd3JpdHRlbiBhbmQgcmVzZXQgdGhpcyB3cml0ZXIuXG4gICAgICovXG4gICAgZmluaXNoKCkge1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKG5ldyBVaW50OEFycmF5KHRoaXMuYnVmKSk7IC8vIGZsdXNoIHRoZSBidWZmZXJcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBsZW4gKz0gdGhpcy5jaHVua3NbaV0ubGVuZ3RoO1xuICAgICAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnl0ZXMuc2V0KHRoaXMuY2h1bmtzW2ldLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRoaXMuY2h1bmtzW2ldLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGEgbmV3IGZvcmsgZm9yIGxlbmd0aC1kZWxpbWl0ZWQgZGF0YSBsaWtlIGEgbWVzc2FnZVxuICAgICAqIG9yIGEgcGFja2VkIHJlcGVhdGVkIGZpZWxkLlxuICAgICAqXG4gICAgICogTXVzdCBiZSBqb2luZWQgbGF0ZXIgd2l0aCBgam9pbigpYC5cbiAgICAgKi9cbiAgICBmb3JrKCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2goeyBjaHVua3M6IHRoaXMuY2h1bmtzLCBidWY6IHRoaXMuYnVmIH0pO1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZiA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSm9pbiB0aGUgbGFzdCBmb3JrLiBXcml0ZSBpdHMgbGVuZ3RoIGFuZCBieXRlcywgdGhlblxuICAgICAqIHJldHVybiB0byB0aGUgcHJldmlvdXMgc3RhdGUuXG4gICAgICovXG4gICAgam9pbigpIHtcbiAgICAgICAgLy8gZ2V0IGNodW5rIG9mIGZvcmtcbiAgICAgICAgbGV0IGNodW5rID0gdGhpcy5maW5pc2goKTtcbiAgICAgICAgLy8gcmVzdG9yZSBwcmV2aW91cyBzdGF0ZVxuICAgICAgICBsZXQgcHJldiA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIGlmICghcHJldilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZSwgZm9yayBzdGFjayBlbXB0eScpO1xuICAgICAgICB0aGlzLmNodW5rcyA9IHByZXYuY2h1bmtzO1xuICAgICAgICB0aGlzLmJ1ZiA9IHByZXYuYnVmO1xuICAgICAgICAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgICAgIHRoaXMudWludDMyKGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSB0YWcgKGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlKS5cbiAgICAgKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gYHVpbnQzMiggKGZpZWxkTm8gPDwgMyB8IHR5cGUpID4+PiAwIClgLlxuICAgICAqXG4gICAgICogR2VuZXJhdGVkIGNvZGUgc2hvdWxkIGNvbXB1dGUgdGhlIHRhZyBhaGVhZCBvZiB0aW1lIGFuZCBjYWxsIGB1aW50MzIoKWAuXG4gICAgICovXG4gICAgdGFnKGZpZWxkTm8sIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDMyKChmaWVsZE5vIDw8IDMgfCB0eXBlKSA+Pj4gMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgY2h1bmsgb2YgcmF3IGJ5dGVzLlxuICAgICAqL1xuICAgIHJhdyhjaHVuaykge1xuICAgICAgICBpZiAodGhpcy5idWYubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKG5ldyBVaW50OEFycmF5KHRoaXMuYnVmKSk7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgdWludDMyYCB2YWx1ZSwgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cbiAgICAgKi9cbiAgICB1aW50MzIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0VUludDMyKHZhbHVlKTtcbiAgICAgICAgLy8gd3JpdGUgdmFsdWUgYXMgdmFyaW50IDMyLCBpbmxpbmVkIGZvciBzcGVlZFxuICAgICAgICB3aGlsZSAodmFsdWUgPiAweDdmKSB7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5wdXNoKCh2YWx1ZSAmIDB4N2YpIHwgMHg4MCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgaW50MzJgIHZhbHVlLCBhIHNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgICAqL1xuICAgIGludDMyKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEludDMyKHZhbHVlKTtcbiAgICAgICAgdmFyaW50MzJ3cml0ZSh2YWx1ZSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgYm9vbGAgdmFsdWUsIGEgdmFyaWFudC5cbiAgICAgKi9cbiAgICBib29sKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnVmLnB1c2godmFsdWUgPyAxIDogMCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBieXRlc2AgdmFsdWUsIGxlbmd0aC1kZWxpbWl0ZWQgYXJiaXRyYXJ5IGRhdGEuXG4gICAgICovXG4gICAgYnl0ZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy51aW50MzIodmFsdWUuYnl0ZUxlbmd0aCk7IC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgc3RyaW5nYCB2YWx1ZSwgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGNvbnZlcnRlZCB0byBVVEYtOCB0ZXh0LlxuICAgICAqL1xuICAgIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2h1bmsgPSB0aGlzLnRleHRFbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMudWludDMyKGNodW5rLmJ5dGVMZW5ndGgpOyAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGZsb2F0YCB2YWx1ZSwgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAgKi9cbiAgICBmbG9hdCh2YWx1ZSkge1xuICAgICAgICBhc3NlcnRGbG9hdDMyKHZhbHVlKTtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEZsb2F0MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBkb3VibGVgIHZhbHVlLCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAgICovXG4gICAgZG91YmxlKHZhbHVlKSB7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRGbG9hdDY0KDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgZml4ZWQzMmAgdmFsdWUsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgZml4ZWQzMih2YWx1ZSkge1xuICAgICAgICBhc3NlcnRVSW50MzIodmFsdWUpO1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0VWludDMyKDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgc2ZpeGVkMzJgIHZhbHVlLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIHNmaXhlZDMyKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEludDMyKHZhbHVlKTtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEludDMyKDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgc2ludDMyYCB2YWx1ZSwgYSBzaWduZWQsIHppZ3phZy1lbmNvZGVkIDMyLWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgc2ludDMyKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEludDMyKHZhbHVlKTtcbiAgICAgICAgLy8gemlnemFnIGVuY29kZVxuICAgICAgICB2YWx1ZSA9ICgodmFsdWUgPDwgMSkgXiAodmFsdWUgPj4gMzEpKSA+Pj4gMDtcbiAgICAgICAgdmFyaW50MzJ3cml0ZSh2YWx1ZSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgZml4ZWQ2NGAgdmFsdWUsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQtYml0IGludGVnZXIuXG4gICAgICovXG4gICAgc2ZpeGVkNjQodmFsdWUpIHtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcik7XG4gICAgICAgIGxldCBsb25nID0gUGJMb25nLmZyb20odmFsdWUpO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIGxvbmcubG8sIHRydWUpO1xuICAgICAgICB2aWV3LnNldEludDMyKDQsIGxvbmcuaGksIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBmaXhlZDY0YCB2YWx1ZSwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCA2NCBiaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBmaXhlZDY0KHZhbHVlKSB7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpO1xuICAgICAgICBsZXQgbG9uZyA9IFBiVUxvbmcuZnJvbSh2YWx1ZSk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgbG9uZy5sbywgdHJ1ZSk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoNCwgbG9uZy5oaSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGludDY0YCB2YWx1ZSwgYSBzaWduZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBpbnQ2NCh2YWx1ZSkge1xuICAgICAgICBsZXQgbG9uZyA9IFBiTG9uZy5mcm9tKHZhbHVlKTtcbiAgICAgICAgdmFyaW50NjR3cml0ZShsb25nLmxvLCBsb25nLmhpLCB0aGlzLmJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBzaW50NjRgIHZhbHVlLCBhIHNpZ25lZCwgemlnLXphZy1lbmNvZGVkIDY0LWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgc2ludDY0KHZhbHVlKSB7XG4gICAgICAgIGxldCBsb25nID0gUGJMb25nLmZyb20odmFsdWUpLCBcbiAgICAgICAgLy8gemlnemFnIGVuY29kZVxuICAgICAgICBzaWduID0gbG9uZy5oaSA+PiAzMSwgbG8gPSAobG9uZy5sbyA8PCAxKSBeIHNpZ24sIGhpID0gKChsb25nLmhpIDw8IDEpIHwgKGxvbmcubG8gPj4+IDMxKSkgXiBzaWduO1xuICAgICAgICB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgdWludDY0YCB2YWx1ZSwgYW4gdW5zaWduZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICB1aW50NjQodmFsdWUpIHtcbiAgICAgICAgbGV0IGxvbmcgPSBQYlVMb25nLmZyb20odmFsdWUpO1xuICAgICAgICB2YXJpbnQ2NHdyaXRlKGxvbmcubG8sIGxvbmcuaGksIHRoaXMuYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyBkaXN0cmlidXRpb24uXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgUHJvdG9jb2wgQnVmZmVyIGNvbXBpbGVyIGlzIG93bmVkIGJ5IHRoZSBvd25lclxuLy8gb2YgdGhlIGlucHV0IGZpbGUgdXNlZCB3aGVuIGdlbmVyYXRpbmcgaXQuICBUaGlzIGNvZGUgaXMgbm90XG4vLyBzdGFuZGFsb25lIGFuZCByZXF1aXJlcyBhIHN1cHBvcnQgbGlicmFyeSB0byBiZSBsaW5rZWQgd2l0aCBpdC4gIFRoaXNcbi8vIHN1cHBvcnQgbGlicmFyeSBpcyBpdHNlbGYgY292ZXJlZCBieSB0aGUgYWJvdmUgbGljZW5zZS5cbi8qKlxuICogUmVhZCBhIDY0IGJpdCB2YXJpbnQgYXMgdHdvIEpTIG51bWJlcnMuXG4gKlxuICogUmV0dXJucyB0dXBsZTpcbiAqIFswXTogbG93IGJpdHNcbiAqIFswXTogaGlnaCBiaXRzXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC9idWZmZXJfZGVjb2Rlci5qcyNMMTc1XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YXJpbnQ2NHJlYWQoKSB7XG4gICAgbGV0IGxvd0JpdHMgPSAwO1xuICAgIGxldCBoaWdoQml0cyA9IDA7XG4gICAgZm9yIChsZXQgc2hpZnQgPSAwOyBzaGlmdCA8IDI4OyBzaGlmdCArPSA3KSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgICAgIGxvd0JpdHMgfD0gKGIgJiAweDdGKSA8PCBzaGlmdDtcbiAgICAgICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBtaWRkbGVCeXRlID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgLy8gbGFzdCBmb3VyIGJpdHMgb2YgdGhlIGZpcnN0IDMyIGJpdCBudW1iZXJcbiAgICBsb3dCaXRzIHw9IChtaWRkbGVCeXRlICYgMHgwRikgPDwgMjg7XG4gICAgLy8gMyB1cHBlciBiaXRzIGFyZSBwYXJ0IG9mIHRoZSBuZXh0IDMyIGJpdCBudW1iZXJcbiAgICBoaWdoQml0cyA9IChtaWRkbGVCeXRlICYgMHg3MCkgPj4gNDtcbiAgICBpZiAoKG1pZGRsZUJ5dGUgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICAgIH1cbiAgICBmb3IgKGxldCBzaGlmdCA9IDM7IHNoaWZ0IDw9IDMxOyBzaGlmdCArPSA3KSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgICAgIGhpZ2hCaXRzIHw9IChiICYgMHg3RikgPDwgc2hpZnQ7XG4gICAgICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgICAgICByZXR1cm4gW2xvd0JpdHMsIGhpZ2hCaXRzXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdmFyaW50Jyk7XG59XG4vKipcbiAqIFdyaXRlIGEgNjQgYml0IHZhcmludCwgZ2l2ZW4gYXMgdHdvIEpTIG51bWJlcnMsIHRvIHRoZSBnaXZlbiBieXRlcyBhcnJheS5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL3dyaXRlci5qcyNMMzQ0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgYnl0ZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI4OyBpID0gaSArIDcpIHtcbiAgICAgICAgY29uc3Qgc2hpZnQgPSBsbyA+Pj4gaTtcbiAgICAgICAgY29uc3QgaGFzTmV4dCA9ICEoKHNoaWZ0ID4+PiA3KSA9PSAwICYmIGhpID09IDApO1xuICAgICAgICBjb25zdCBieXRlID0gKGhhc05leHQgPyBzaGlmdCB8IDB4ODAgOiBzaGlmdCkgJiAweEZGO1xuICAgICAgICBieXRlcy5wdXNoKGJ5dGUpO1xuICAgICAgICBpZiAoIWhhc05leHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzcGxpdEJpdHMgPSAoKGxvID4+PiAyOCkgJiAweDBGKSB8ICgoaGkgJiAweDA3KSA8PCA0KTtcbiAgICBjb25zdCBoYXNNb3JlQml0cyA9ICEoKGhpID4+IDMpID09IDApO1xuICAgIGJ5dGVzLnB1c2goKGhhc01vcmVCaXRzID8gc3BsaXRCaXRzIHwgMHg4MCA6IHNwbGl0Qml0cykgJiAweEZGKTtcbiAgICBpZiAoIWhhc01vcmVCaXRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDM7IGkgPCAzMTsgaSA9IGkgKyA3KSB7XG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gaGkgPj4+IGk7XG4gICAgICAgIGNvbnN0IGhhc05leHQgPSAhKChzaGlmdCA+Pj4gNykgPT0gMCk7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSAoaGFzTmV4dCA/IHNoaWZ0IHwgMHg4MCA6IHNoaWZ0KSAmIDB4RkY7XG4gICAgICAgIGJ5dGVzLnB1c2goYnl0ZSk7XG4gICAgICAgIGlmICghaGFzTmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ5dGVzLnB1c2goKGhpID4+PiAzMSkgJiAweDAxKTtcbn1cbi8vIGNvbnN0YW50cyBmb3IgYmluYXJ5IG1hdGhcbmNvbnN0IFRXT19QV1JfMzJfREJMID0gKDEgPDwgMTYpICogKDEgPDwgMTYpO1xuLyoqXG4gKiBQYXJzZSBkZWNpbWFsIHN0cmluZyBvZiA2NCBiaXQgaW50ZWdlciB2YWx1ZSBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBSZXR1cm5zIHR1cGxlOlxuICogWzBdOiBtaW51cyBzaWduP1xuICogWzFdOiBsb3cgYml0c1xuICogWzJdOiBoaWdoIGJpdHNcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50NjRmcm9tU3RyaW5nKGRlYykge1xuICAgIC8vIENoZWNrIGZvciBtaW51cyBzaWduLlxuICAgIGxldCBtaW51cyA9IGRlY1swXSA9PSAnLSc7XG4gICAgaWYgKG1pbnVzKVxuICAgICAgICBkZWMgPSBkZWMuc2xpY2UoMSk7XG4gICAgLy8gV29yayA2IGRlY2ltYWwgZGlnaXRzIGF0IGEgdGltZSwgYWN0aW5nIGxpa2Ugd2UncmUgY29udmVydGluZyBiYXNlIDFlNlxuICAgIC8vIGRpZ2l0cyB0byBiaW5hcnkuIFRoaXMgaXMgc2FmZSB0byBkbyB3aXRoIGZsb2F0aW5nIHBvaW50IG1hdGggYmVjYXVzZVxuICAgIC8vIE51bWJlci5pc1NhZmVJbnRlZ2VyKEFMTF8zMl9CSVRTICogMWU2KSA9PSB0cnVlLlxuICAgIGNvbnN0IGJhc2UgPSAxZTY7XG4gICAgbGV0IGxvd0JpdHMgPSAwO1xuICAgIGxldCBoaWdoQml0cyA9IDA7XG4gICAgZnVuY3Rpb24gYWRkMWU2ZGlnaXQoYmVnaW4sIGVuZCkge1xuICAgICAgICAvLyBOb3RlOiBOdW1iZXIoJycpIGlzIDAuXG4gICAgICAgIGNvbnN0IGRpZ2l0MWU2ID0gTnVtYmVyKGRlYy5zbGljZShiZWdpbiwgZW5kKSk7XG4gICAgICAgIGhpZ2hCaXRzICo9IGJhc2U7XG4gICAgICAgIGxvd0JpdHMgPSBsb3dCaXRzICogYmFzZSArIGRpZ2l0MWU2O1xuICAgICAgICAvLyBDYXJyeSBiaXRzIGZyb20gbG93Qml0cyB0byBoaWdoQml0c1xuICAgICAgICBpZiAobG93Qml0cyA+PSBUV09fUFdSXzMyX0RCTCkge1xuICAgICAgICAgICAgaGlnaEJpdHMgPSBoaWdoQml0cyArICgobG93Qml0cyAvIFRXT19QV1JfMzJfREJMKSB8IDApO1xuICAgICAgICAgICAgbG93Qml0cyA9IGxvd0JpdHMgJSBUV09fUFdSXzMyX0RCTDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGQxZTZkaWdpdCgtMjQsIC0xOCk7XG4gICAgYWRkMWU2ZGlnaXQoLTE4LCAtMTIpO1xuICAgIGFkZDFlNmRpZ2l0KC0xMiwgLTYpO1xuICAgIGFkZDFlNmRpZ2l0KC02KTtcbiAgICByZXR1cm4gW21pbnVzLCBsb3dCaXRzLCBoaWdoQml0c107XG59XG4vKipcbiAqIEZvcm1hdCA2NCBiaXQgaW50ZWdlciB2YWx1ZSAoYXMgdHdvIEpTIG51bWJlcnMpIHRvIGRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnQ2NHRvU3RyaW5nKGJpdHNMb3csIGJpdHNIaWdoKSB7XG4gICAgLy8gU2tpcCB0aGUgZXhwZW5zaXZlIGNvbnZlcnNpb24gaWYgdGhlIG51bWJlciBpcyBzbWFsbCBlbm91Z2ggdG8gdXNlIHRoZVxuICAgIC8vIGJ1aWx0LWluIGNvbnZlcnNpb25zLlxuICAgIGlmICgoYml0c0hpZ2ggPj4+IDApIDw9IDB4MUZGRkZGKSB7XG4gICAgICAgIHJldHVybiAnJyArIChUV09fUFdSXzMyX0RCTCAqIGJpdHNIaWdoICsgKGJpdHNMb3cgPj4+IDApKTtcbiAgICB9XG4gICAgLy8gV2hhdCB0aGlzIGNvZGUgaXMgZG9pbmcgaXMgZXNzZW50aWFsbHkgY29udmVydGluZyB0aGUgaW5wdXQgbnVtYmVyIGZyb21cbiAgICAvLyBiYXNlLTIgdG8gYmFzZS0xZTcsIHdoaWNoIGFsbG93cyB1cyB0byByZXByZXNlbnQgdGhlIDY0LWJpdCByYW5nZSB3aXRoXG4gICAgLy8gb25seSAzICh2ZXJ5IGxhcmdlKSBkaWdpdHMuIFRob3NlIGRpZ2l0cyBhcmUgdGhlbiB0cml2aWFsIHRvIGNvbnZlcnQgdG9cbiAgICAvLyBhIGJhc2UtMTAgc3RyaW5nLlxuICAgIC8vIFRoZSBtYWdpYyBudW1iZXJzIHVzZWQgaGVyZSBhcmUgLVxuICAgIC8vIDJeMjQgPSAxNjc3NzIxNiA9ICgxLDY3NzcyMTYpIGluIGJhc2UtMWU3LlxuICAgIC8vIDJeNDggPSAyODE0NzQ5NzY3MTA2NTYgPSAoMiw4MTQ3NDk3LDY3MTA2NTYpIGluIGJhc2UtMWU3LlxuICAgIC8vIFNwbGl0IDMyOjMyIHJlcHJlc2VudGF0aW9uIGludG8gMTY6MjQ6MjQgcmVwcmVzZW50YXRpb24gc28gb3VyXG4gICAgLy8gaW50ZXJtZWRpYXRlIGRpZ2l0cyBkb24ndCBvdmVyZmxvdy5cbiAgICBsZXQgbG93ID0gYml0c0xvdyAmIDB4RkZGRkZGO1xuICAgIGxldCBtaWQgPSAoKChiaXRzTG93ID4+PiAyNCkgfCAoYml0c0hpZ2ggPDwgOCkpID4+PiAwKSAmIDB4RkZGRkZGO1xuICAgIGxldCBoaWdoID0gKGJpdHNIaWdoID4+IDE2KSAmIDB4RkZGRjtcbiAgICAvLyBBc3NlbWJsZSBvdXIgdGhyZWUgYmFzZS0xZTcgZGlnaXRzLCBpZ25vcmluZyBjYXJyaWVzLiBUaGUgbWF4aW11bVxuICAgIC8vIHZhbHVlIGluIGEgZGlnaXQgYXQgdGhpcyBzdGVwIGlzIHJlcHJlc2VudGFibGUgYXMgYSA0OC1iaXQgaW50ZWdlciwgd2hpY2hcbiAgICAvLyBjYW4gYmUgc3RvcmVkIGluIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICBsZXQgZGlnaXRBID0gbG93ICsgKG1pZCAqIDY3NzcyMTYpICsgKGhpZ2ggKiA2NzEwNjU2KTtcbiAgICBsZXQgZGlnaXRCID0gbWlkICsgKGhpZ2ggKiA4MTQ3NDk3KTtcbiAgICBsZXQgZGlnaXRDID0gKGhpZ2ggKiAyKTtcbiAgICAvLyBBcHBseSBjYXJyaWVzIGZyb20gQSB0byBCIGFuZCBmcm9tIEIgdG8gQy5cbiAgICBsZXQgYmFzZSA9IDEwMDAwMDAwO1xuICAgIGlmIChkaWdpdEEgPj0gYmFzZSkge1xuICAgICAgICBkaWdpdEIgKz0gTWF0aC5mbG9vcihkaWdpdEEgLyBiYXNlKTtcbiAgICAgICAgZGlnaXRBICU9IGJhc2U7XG4gICAgfVxuICAgIGlmIChkaWdpdEIgPj0gYmFzZSkge1xuICAgICAgICBkaWdpdEMgKz0gTWF0aC5mbG9vcihkaWdpdEIgLyBiYXNlKTtcbiAgICAgICAgZGlnaXRCICU9IGJhc2U7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgYmFzZS0xZTcgZGlnaXRzIHRvIGJhc2UtMTAsIHdpdGggb3B0aW9uYWwgbGVhZGluZyB6ZXJvZXMuXG4gICAgZnVuY3Rpb24gZGVjaW1hbEZyb20xZTcoZGlnaXQxZTcsIG5lZWRMZWFkaW5nWmVyb3MpIHtcbiAgICAgICAgbGV0IHBhcnRpYWwgPSBkaWdpdDFlNyA/IFN0cmluZyhkaWdpdDFlNykgOiAnJztcbiAgICAgICAgaWYgKG5lZWRMZWFkaW5nWmVyb3MpIHtcbiAgICAgICAgICAgIHJldHVybiAnMDAwMDAwMCcuc2xpY2UocGFydGlhbC5sZW5ndGgpICsgcGFydGlhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydGlhbDtcbiAgICB9XG4gICAgcmV0dXJuIGRlY2ltYWxGcm9tMWU3KGRpZ2l0QywgLypuZWVkTGVhZGluZ1plcm9zPSovIDApICtcbiAgICAgICAgZGVjaW1hbEZyb20xZTcoZGlnaXRCLCAvKm5lZWRMZWFkaW5nWmVyb3M9Ki8gZGlnaXRDKSArXG4gICAgICAgIC8vIElmIHRoZSBmaW5hbCAxZTcgZGlnaXQgZGlkbid0IG5lZWQgbGVhZGluZyB6ZXJvcywgd2Ugd291bGQgaGF2ZVxuICAgICAgICAvLyByZXR1cm5lZCB2aWEgdGhlIHRyaXZpYWwgY29kZSBwYXRoIGF0IHRoZSB0b3AuXG4gICAgICAgIGRlY2ltYWxGcm9tMWU3KGRpZ2l0QSwgLypuZWVkTGVhZGluZ1plcm9zPSovIDEpO1xufVxuLyoqXG4gKiBXcml0ZSBhIDMyIGJpdCB2YXJpbnQsIHNpZ25lZCBvciB1bnNpZ25lZC4gU2FtZSBhcyBgdmFyaW50NjR3cml0ZSgwLCB2YWx1ZSwgYnl0ZXMpYFxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvMWIxODgzM2Y0ZjJhMmY2ODFmNGU0YTI1Y2RmM2IwYTQzMTE1ZWMyNi9qcy9iaW5hcnkvZW5jb2Rlci5qcyNMMTQ0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YXJpbnQzMndyaXRlKHZhbHVlLCBieXRlcykge1xuICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICAgIC8vIHdyaXRlIHZhbHVlIGFzIHZhcmludCAzMlxuICAgICAgICB3aGlsZSAodmFsdWUgPiAweDdmKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKCh2YWx1ZSAmIDB4N2YpIHwgMHg4MCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2godmFsdWUgJiAxMjcgfCAxMjgpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PiA3O1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzLnB1c2goMSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZWFkIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC9idWZmZXJfZGVjb2Rlci5qcyNMMjIwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YXJpbnQzMnJlYWQoKSB7XG4gICAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICBsZXQgcmVzdWx0ID0gYiAmIDB4N0Y7XG4gICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgcmVzdWx0IHw9IChiICYgMHg3RikgPDwgNztcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDdGKSA8PCAxNDtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDdGKSA8PCAyMTtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEV4dHJhY3Qgb25seSBsYXN0IDQgYml0c1xuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDBGKSA8PCAyODtcbiAgICBmb3IgKGxldCByZWFkQnl0ZXMgPSA1OyAoKGIgJiAweDgwKSAhPT0gMCkgJiYgcmVhZEJ5dGVzIDwgMTA7IHJlYWRCeXRlcysrKVxuICAgICAgICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgaWYgKChiICYgMHg4MCkgIT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHZhcmludCcpO1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgLy8gUmVzdWx0IGNhbiBoYXZlIDMyIGJpdHMsIGNvbnZlcnQgaXQgdG8gdW5zaWduZWRcbiAgICByZXR1cm4gcmVzdWx0ID4+PiAwO1xufVxuIiwiY29uc3QgZGVmYXVsdHNXcml0ZSA9IHtcbiAgICBlbWl0RGVmYXVsdFZhbHVlczogZmFsc2UsXG4gICAgZW51bUFzSW50ZWdlcjogZmFsc2UsXG4gICAgdXNlUHJvdG9GaWVsZE5hbWU6IGZhbHNlLFxuICAgIHByZXR0eVNwYWNlczogMCxcbn0sIGRlZmF1bHRzUmVhZCA9IHtcbiAgICBpZ25vcmVVbmtub3duRmllbGRzOiBmYWxzZSxcbn07XG4vKipcbiAqIE1ha2Ugb3B0aW9ucyBmb3IgcmVhZGluZyBKU09OIGRhdGEgZnJvbSBwYXJ0aWFsIG9wdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqc29uUmVhZE9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0c1JlYWQpLCBvcHRpb25zKSA6IGRlZmF1bHRzUmVhZDtcbn1cbi8qKlxuICogTWFrZSBvcHRpb25zIGZvciB3cml0aW5nIEpTT04gZGF0YSBmcm9tIHBhcnRpYWwgb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpzb25Xcml0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0c1dyaXRlKSwgb3B0aW9ucykgOiBkZWZhdWx0c1dyaXRlO1xufVxuLyoqXG4gKiBNZXJnZXMgSlNPTiB3cml0ZSBvciByZWFkIG9wdGlvbnMuIExhdGVyIHZhbHVlcyBvdmVycmlkZSBlYXJsaWVyIHZhbHVlcy4gVHlwZSByZWdpc3RyaWVzIGFyZSBtZXJnZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUpzb25PcHRpb25zKGEsIGIpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGxldCBjID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhKSwgYik7XG4gICAgYy50eXBlUmVnaXN0cnkgPSBbLi4uKChfYSA9IGEgPT09IG51bGwgfHwgYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYS50eXBlUmVnaXN0cnkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSwgLi4uKChfYiA9IGIgPT09IG51bGwgfHwgYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYi50eXBlUmVnaXN0cnkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKV07XG4gICAgcmV0dXJuIGM7XG59XG4iLCIvKipcbiAqIEdldCB0aGUgdHlwZSBvZiBhIEpTT04gdmFsdWUuXG4gKiBEaXN0aW5ndWlzaGVzIGJldHdlZW4gYXJyYXksIG51bGwgYW5kIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR5cGVvZkpzb25WYWx1ZSh2YWx1ZSkge1xuICAgIGxldCB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmICh0ID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn1cbi8qKlxuICogSXMgdGhpcyBhIEpTT04gb2JqZWN0IChpbnN0ZWFkIG9mIGFuIGFycmF5IG9yIG51bGwpP1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNKc29uT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbiIsIi8qKlxuICogQ29udmVydHMgc25ha2VfY2FzZSB0byBsb3dlckNhbWVsQ2FzZS5cbiAqXG4gKiBTaG91bGQgYmVoYXZlIGxpa2UgcHJvdG9jOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iL2U4YWUxMzdjOTY0NDRlYTMxMzQ4NWVkMTExOGM1ZTQzYjIwOTljZjEvc3JjL2dvb2dsZS9wcm90b2J1Zi9jb21waWxlci9qYXZhL2phdmFfaGVscGVycy5jYyNMMTE4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb3dlckNhbWVsQ2FzZShzbmFrZUNhc2UpIHtcbiAgICBsZXQgY2FwTmV4dCA9IGZhbHNlO1xuICAgIGNvbnN0IHNiID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbmFrZUNhc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5leHQgPSBzbmFrZUNhc2UuY2hhckF0KGkpO1xuICAgICAgICBpZiAobmV4dCA9PSAnXycpIHtcbiAgICAgICAgICAgIGNhcE5leHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9cXGQvLnRlc3QobmV4dCkpIHtcbiAgICAgICAgICAgIHNiLnB1c2gobmV4dCk7XG4gICAgICAgICAgICBjYXBOZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYXBOZXh0KSB7XG4gICAgICAgICAgICBzYi5wdXNoKG5leHQudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgICBjYXBOZXh0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICBzYi5wdXNoKG5leHQudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzYi5wdXNoKG5leHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzYi5qb2luKCcnKTtcbn1cbiIsIi8qKlxuICogVGhlIHN5bWJvbCB1c2VkIGFzIGEga2V5IG9uIG1lc3NhZ2Ugb2JqZWN0cyB0byBzdG9yZSB0aGUgbWVzc2FnZSB0eXBlLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIC0gaXQgaXMgaGVyZSB0byBzdGF5LCBidXRcbiAqIGltcGxlbWVudGF0aW9uIGRldGFpbHMgbWF5IGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAqL1xuZXhwb3J0IGNvbnN0IE1FU1NBR0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJwcm90b2J1Zi10cy9tZXNzYWdlLXR5cGVcIik7XG4iLCJpbXBvcnQgeyBNRVNTQUdFX1RZUEUgfSBmcm9tIFwiLi9tZXNzYWdlLXR5cGUtY29udHJhY3RcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZUZpZWxkSW5mbyB9IGZyb20gXCIuL3JlZmxlY3Rpb24taW5mb1wiO1xuaW1wb3J0IHsgUmVmbGVjdGlvblR5cGVDaGVjayB9IGZyb20gXCIuL3JlZmxlY3Rpb24tdHlwZS1jaGVja1wiO1xuaW1wb3J0IHsgUmVmbGVjdGlvbkpzb25SZWFkZXIgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWpzb24tcmVhZGVyXCI7XG5pbXBvcnQgeyBSZWZsZWN0aW9uSnNvbldyaXRlciB9IGZyb20gXCIuL3JlZmxlY3Rpb24tanNvbi13cml0ZXJcIjtcbmltcG9ydCB7IFJlZmxlY3Rpb25CaW5hcnlSZWFkZXIgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWJpbmFyeS1yZWFkZXJcIjtcbmltcG9ydCB7IFJlZmxlY3Rpb25CaW5hcnlXcml0ZXIgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWJpbmFyeS13cml0ZXJcIjtcbmltcG9ydCB7IHJlZmxlY3Rpb25DcmVhdGUgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWNyZWF0ZVwiO1xuaW1wb3J0IHsgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCB9IGZyb20gXCIuL3JlZmxlY3Rpb24tbWVyZ2UtcGFydGlhbFwiO1xuaW1wb3J0IHsgdHlwZW9mSnNvblZhbHVlIH0gZnJvbSBcIi4vanNvbi10eXBpbmdzXCI7XG5pbXBvcnQgeyBqc29uUmVhZE9wdGlvbnMsIGpzb25Xcml0ZU9wdGlvbnMsIH0gZnJvbSBcIi4vanNvbi1mb3JtYXQtY29udHJhY3RcIjtcbmltcG9ydCB7IHJlZmxlY3Rpb25FcXVhbHMgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWVxdWFsc1wiO1xuaW1wb3J0IHsgYmluYXJ5V3JpdGVPcHRpb25zIH0gZnJvbSBcIi4vYmluYXJ5LXdyaXRlclwiO1xuaW1wb3J0IHsgYmluYXJ5UmVhZE9wdGlvbnMgfSBmcm9tIFwiLi9iaW5hcnktcmVhZGVyXCI7XG5jb25zdCBiYXNlRGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pKTtcbi8qKlxuICogVGhpcyBzdGFuZGFyZCBtZXNzYWdlIHR5cGUgcHJvdmlkZXMgcmVmbGVjdGlvbi1iYXNlZFxuICogb3BlcmF0aW9ucyB0byB3b3JrIHdpdGggYSBtZXNzYWdlLlxuICovXG5leHBvcnQgY2xhc3MgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGZpZWxkcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmRlZmF1bHRDaGVja0RlcHRoID0gMTY7XG4gICAgICAgIHRoaXMudHlwZU5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcy5tYXAobm9ybWFsaXplRmllbGRJbmZvKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XG4gICAgICAgIHRoaXMubWVzc2FnZVByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBiYXNlRGVzY3JpcHRvcnMpLCB7IFtNRVNTQUdFX1RZUEVdOiB7IHZhbHVlOiB0aGlzIH0gfSkpO1xuICAgICAgICB0aGlzLnJlZlR5cGVDaGVjayA9IG5ldyBSZWZsZWN0aW9uVHlwZUNoZWNrKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZkpzb25SZWFkZXIgPSBuZXcgUmVmbGVjdGlvbkpzb25SZWFkZXIodGhpcyk7XG4gICAgICAgIHRoaXMucmVmSnNvbldyaXRlciA9IG5ldyBSZWZsZWN0aW9uSnNvbldyaXRlcih0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZCaW5SZWFkZXIgPSBuZXcgUmVmbGVjdGlvbkJpbmFyeVJlYWRlcih0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZCaW5Xcml0ZXIgPSBuZXcgUmVmbGVjdGlvbkJpbmFyeVdyaXRlcih0aGlzKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gcmVmbGVjdGlvbkNyZWF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9uZSB0aGUgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIFVua25vd24gZmllbGRzIGFyZSBkaXNjYXJkZWQuXG4gICAgICovXG4gICAgY2xvbmUobWVzc2FnZSkge1xuICAgICAgICBsZXQgY29weSA9IHRoaXMuY3JlYXRlKCk7XG4gICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgY29weSwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdHdvIG1lc3NhZ2Ugb2YgdGhlIHNhbWUgdHlwZSBoYXZlIHRoZSBzYW1lIGZpZWxkIHZhbHVlcy5cbiAgICAgKiBDaGVja3MgZm9yIGRlZXAgZXF1YWxpdHksIHRyYXZlcnNpbmcgcmVwZWF0ZWQgZmllbGRzLCBvbmVvZiBncm91cHMsIG1hcHNcbiAgICAgKiBhbmQgbWVzc2FnZXMgcmVjdXJzaXZlbHkuXG4gICAgICogV2lsbCBhbHNvIHJldHVybiB0cnVlIGlmIGJvdGggbWVzc2FnZXMgYXJlIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiByZWZsZWN0aW9uRXF1YWxzKHRoaXMsIGEsIGIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgZ2l2ZW4gdmFsdWUgYXNzaWduYWJsZSB0byBvdXIgbWVzc2FnZSB0eXBlXG4gICAgICogYW5kIGNvbnRhaW5zIG5vIFtleGNlc3MgcHJvcGVydGllc10oaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svaW50ZXJmYWNlcy5odG1sI2V4Y2Vzcy1wcm9wZXJ0eS1jaGVja3MpP1xuICAgICAqL1xuICAgIGlzKGFyZywgZGVwdGggPSB0aGlzLmRlZmF1bHRDaGVja0RlcHRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZlR5cGVDaGVjay5pcyhhcmcsIGRlcHRoLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSBnaXZlbiB2YWx1ZSBhc3NpZ25hYmxlIHRvIG91ciBtZXNzYWdlIHR5cGUsXG4gICAgICogcmVnYXJkbGVzcyBvZiBbZXhjZXNzIHByb3BlcnRpZXNdKGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL2ludGVyZmFjZXMuaHRtbCNleGNlc3MtcHJvcGVydHktY2hlY2tzKT9cbiAgICAgKi9cbiAgICBpc0Fzc2lnbmFibGUoYXJnLCBkZXB0aCA9IHRoaXMuZGVmYXVsdENoZWNrRGVwdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmVHlwZUNoZWNrLmlzKGFyZywgZGVwdGgsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3B5IHBhcnRpYWwgZGF0YSBpbnRvIHRoZSB0YXJnZXQgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBtZXJnZVBhcnRpYWwodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCB0YXJnZXQsIHNvdXJjZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBtZXNzYWdlIGZyb20gYmluYXJ5IGZvcm1hdC5cbiAgICAgKi9cbiAgICBmcm9tQmluYXJ5KGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG9wdCA9IGJpbmFyeVJlYWRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEJpbmFyeVJlYWQob3B0LnJlYWRlckZhY3RvcnkoZGF0YSksIGRhdGEuYnl0ZUxlbmd0aCwgb3B0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIG5ldyBtZXNzYWdlIGZyb20gYSBKU09OIHZhbHVlLlxuICAgICAqL1xuICAgIGZyb21Kc29uKGpzb24sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxKc29uUmVhZChqc29uLCBqc29uUmVhZE9wdGlvbnMob3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgbmV3IG1lc3NhZ2UgZnJvbSBhIEpTT04gc3RyaW5nLlxuICAgICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byBgVC5mcm9tSnNvbihKU09OLnBhcnNlKGpzb24pKWAuXG4gICAgICovXG4gICAgZnJvbUpzb25TdHJpbmcoanNvbiwgb3B0aW9ucykge1xuICAgICAgICBsZXQgdmFsdWUgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tSnNvbih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIHRoZSBtZXNzYWdlIHRvIGNhbm9uaWNhbCBKU09OIHZhbHVlLlxuICAgICAqL1xuICAgIHRvSnNvbihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsSnNvbldyaXRlKG1lc3NhZ2UsIGpzb25Xcml0ZU9wdGlvbnMob3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBtZXNzYWdlIHRvIGNhbm9uaWNhbCBKU09OIHN0cmluZy5cbiAgICAgKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gYEpTT04uc3RyaW5naWZ5KFQudG9Kc29uKHQpKWBcbiAgICAgKi9cbiAgICB0b0pzb25TdHJpbmcobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudG9Kc29uKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV0dHlTcGFjZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0aGUgbWVzc2FnZSB0byBiaW5hcnkgZm9ybWF0LlxuICAgICAqL1xuICAgIHRvQmluYXJ5KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG9wdCA9IGJpbmFyeVdyaXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCBvcHQud3JpdGVyRmFjdG9yeSgpLCBvcHQpLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGFuIGludGVybmFsIG1ldGhvZC4gSWYgeW91IGp1c3Qgd2FudCB0byByZWFkIGEgbWVzc2FnZSBmcm9tXG4gICAgICogSlNPTiwgdXNlIGBmcm9tSnNvbigpYCBvciBgZnJvbUpzb25TdHJpbmcoKWAuXG4gICAgICpcbiAgICAgKiBSZWFkcyBKU09OIHZhbHVlIGFuZCBtZXJnZXMgdGhlIGZpZWxkcyBpbnRvIHRoZSB0YXJnZXRcbiAgICAgKiBhY2NvcmRpbmcgdG8gcHJvdG9idWYgcnVsZXMuIElmIHRoZSB0YXJnZXQgaXMgb21pdHRlZCxcbiAgICAgKiBhIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGZpcnN0LlxuICAgICAqL1xuICAgIGludGVybmFsSnNvblJlYWQoanNvbiwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGlmIChqc29uICE9PSBudWxsICYmIHR5cGVvZiBqc29uID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoanNvbikpIHtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKTtcbiAgICAgICAgICAgIHRoaXMucmVmSnNvblJlYWRlci5yZWFkKGpzb24sIG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcGFyc2UgbWVzc2FnZSAke3RoaXMudHlwZU5hbWV9IGZyb20gSlNPTiAke3R5cGVvZkpzb25WYWx1ZShqc29uKX0uYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYW4gaW50ZXJuYWwgbWV0aG9kLiBJZiB5b3UganVzdCB3YW50IHRvIHdyaXRlIGEgbWVzc2FnZVxuICAgICAqIHRvIEpTT04sIHVzZSBgdG9Kc29uKClgIG9yIGB0b0pzb25TdHJpbmcoKS5cbiAgICAgKlxuICAgICAqIFdyaXRlcyBKU09OIHZhbHVlIGFuZCByZXR1cm5zIGl0LlxuICAgICAqL1xuICAgIGludGVybmFsSnNvbldyaXRlKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmSnNvbldyaXRlci53cml0ZShtZXNzYWdlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhbiBpbnRlcm5hbCBtZXRob2QuIElmIHlvdSBqdXN0IHdhbnQgdG8gd3JpdGUgYSBtZXNzYWdlXG4gICAgICogaW4gYmluYXJ5IGZvcm1hdCwgdXNlIGB0b0JpbmFyeSgpYC5cbiAgICAgKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIG1lc3NhZ2UgaW4gYmluYXJ5IGZvcm1hdCBhbmQgYXBwZW5kcyBpdCB0byB0aGUgZ2l2ZW5cbiAgICAgKiB3cml0ZXIuIFJldHVybnMgcGFzc2VkIHdyaXRlci5cbiAgICAgKi9cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlZkJpbldyaXRlci53cml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGFuIGludGVybmFsIG1ldGhvZC4gSWYgeW91IGp1c3Qgd2FudCB0byByZWFkIGEgbWVzc2FnZSBmcm9tXG4gICAgICogYmluYXJ5IGRhdGEsIHVzZSBgZnJvbUJpbmFyeSgpYC5cbiAgICAgKlxuICAgICAqIFJlYWRzIGRhdGEgZnJvbSBiaW5hcnkgZm9ybWF0IGFuZCBtZXJnZXMgdGhlIGZpZWxkcyBpbnRvXG4gICAgICogdGhlIHRhcmdldCBhY2NvcmRpbmcgdG8gcHJvdG9idWYgcnVsZXMuIElmIHRoZSB0YXJnZXQgaXNcbiAgICAgKiBvbWl0dGVkLCBhIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGZpcnN0LlxuICAgICAqL1xuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gdm9pZCAwID8gdGFyZ2V0IDogdGhpcy5jcmVhdGUoKTtcbiAgICAgICAgdGhpcy5yZWZCaW5SZWFkZXIucmVhZChyZWFkZXIsIG1lc3NhZ2UsIG9wdGlvbnMsIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbn1cbiIsIi8qKlxuICogSXMgdGhlIGdpdmVuIHZhbHVlIGEgdmFsaWQgb25lb2YgZ3JvdXA/XG4gKlxuICogV2UgcmVwcmVzZW50IHByb3RvYnVmIGBvbmVvZmAgYXMgYWxnZWJyYWljIGRhdGEgdHlwZXMgKEFEVCkgaW4gZ2VuZXJhdGVkXG4gKiBjb2RlLiBCdXQgd2hlbiB3b3JraW5nIHdpdGggbWVzc2FnZXMgb2YgdW5rbm93biB0eXBlLCB0aGUgQURUIGRvZXMgbm90XG4gKiBoZWxwIHVzLlxuICpcbiAqIFRoaXMgdHlwZSBndWFyZCBjaGVja3MgaWYgdGhlIGdpdmVuIG9iamVjdCBhZGhlcmVzIHRvIHRoZSBBRFQgcnVsZXMsIHdoaWNoXG4gKiBhcmUgYXMgZm9sbG93czpcbiAqXG4gKiAxKSBNdXN0IGJlIGFuIG9iamVjdC5cbiAqXG4gKiAyKSBNdXN0IGhhdmUgYSBcIm9uZW9mS2luZFwiIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkuXG4gKlxuICogMykgSWYgXCJvbmVvZktpbmRcIiBpcyBgdW5kZWZpbmVkYCwgbm8gbWVtYmVyIGZpZWxkIGlzIHNlbGVjdGVkLiBUaGUgb2JqZWN0XG4gKiBtdXN0IG5vdCBoYXZlIGFueSBvdGhlciBwcm9wZXJ0aWVzLlxuICpcbiAqIDQpIElmIFwib25lb2ZLaW5kXCIgaXMgYSBgc3RyaW5nYCwgdGhlIG1lbWJlciBmaWVsZCB3aXRoIHRoaXMgbmFtZSBpc1xuICogc2VsZWN0ZWQuXG4gKlxuICogNSkgSWYgYSBtZW1iZXIgZmllbGQgaXMgc2VsZWN0ZWQsIHRoZSBvYmplY3QgbXVzdCBoYXZlIGEgc2Vjb25kIHByb3BlcnR5XG4gKiB3aXRoIHRoaXMgbmFtZS4gVGhlIHByb3BlcnR5IG11c3Qgbm90IGJlIGB1bmRlZmluZWRgLlxuICpcbiAqIDYpIE5vIGV4dHJhIHByb3BlcnRpZXMgYXJlIGFsbG93ZWQuIFRoZSBvYmplY3QgaGFzIGVpdGhlciBvbmUgcHJvcGVydHlcbiAqIChubyBzZWxlY3Rpb24pIG9yIHR3byBwcm9wZXJ0aWVzIChzZWxlY3Rpb24pLlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT25lb2ZHcm91cChhbnkpIHtcbiAgICBpZiAodHlwZW9mIGFueSAhPSAnb2JqZWN0JyB8fCBhbnkgPT09IG51bGwgfHwgIWFueS5oYXNPd25Qcm9wZXJ0eSgnb25lb2ZLaW5kJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiBhbnkub25lb2ZLaW5kKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIGlmIChhbnlbYW55Lm9uZW9mS2luZF0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYW55KS5sZW5ndGggPT0gMjtcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGFueSkubGVuZ3RoID09IDE7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZmllbGQgaW4gYSBvbmVvZiBncm91cC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9uZW9mVmFsdWUob25lb2YsIGtpbmQpIHtcbiAgICByZXR1cm4gb25lb2Zba2luZF07XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0T25lb2ZWYWx1ZShvbmVvZiwga2luZCwgdmFsdWUpIHtcbiAgICBpZiAob25lb2Yub25lb2ZLaW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIG9uZW9mW29uZW9mLm9uZW9mS2luZF07XG4gICAgfVxuICAgIG9uZW9mLm9uZW9mS2luZCA9IGtpbmQ7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25lb2Zba2luZF0gPSB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0VW5rbm93bk9uZW9mVmFsdWUob25lb2YsIGtpbmQsIHZhbHVlKSB7XG4gICAgaWYgKG9uZW9mLm9uZW9mS2luZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSBvbmVvZltvbmVvZi5vbmVvZktpbmRdO1xuICAgIH1cbiAgICBvbmVvZi5vbmVvZktpbmQgPSBraW5kO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGtpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbmVvZltraW5kXSA9IHZhbHVlO1xuICAgIH1cbn1cbi8qKlxuICogUmVtb3ZlcyB0aGUgc2VsZWN0ZWQgZmllbGQgaW4gYSBvbmVvZiBncm91cC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIHJlY29tbWVuZGVkIHdheSB0byBtb2RpZnkgYSBvbmVvZiBncm91cCBpcyB0byBzZXRcbiAqIGEgbmV3IG9iamVjdDpcbiAqXG4gKiBgYGB0c1xuICogbWVzc2FnZS5yZXN1bHQgPSB7IG9uZW9mS2luZDogdW5kZWZpbmVkIH07XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyT25lb2ZWYWx1ZShvbmVvZikge1xuICAgIGlmIChvbmVvZi5vbmVvZktpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgb25lb2Zbb25lb2Yub25lb2ZLaW5kXTtcbiAgICB9XG4gICAgb25lb2Yub25lb2ZLaW5kID0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzZWxlY3RlZCB2YWx1ZSBvZiB0aGUgZ2l2ZW4gb25lb2YgZ3JvdXAuXG4gKlxuICogTm90IHRoYXQgdGhlIHJlY29tbWVuZGVkIHdheSB0byBhY2Nlc3MgYSBvbmVvZiBncm91cCBpcyB0byBjaGVja1xuICogdGhlIFwib25lb2ZLaW5kXCIgcHJvcGVydHkgYW5kIGxldCBUeXBlU2NyaXB0IG5hcnJvdyBkb3duIHRoZSB1bmlvblxuICogdHlwZSBmb3IgeW91OlxuICpcbiAqIGBgYHRzXG4gKiBpZiAobWVzc2FnZS5yZXN1bHQub25lb2ZLaW5kID09PSBcImVycm9yXCIpIHtcbiAqICAgbWVzc2FnZS5yZXN1bHQuZXJyb3I7IC8vIHN0cmluZ1xuICogfVxuICogYGBgXG4gKlxuICogSW4gdGhlIHJhcmUgY2FzZSB5b3UganVzdCBuZWVkIHRoZSB2YWx1ZSwgYW5kIGRvIG5vdCBjYXJlIGFib3V0XG4gKiB3aGljaCBwcm90b2J1ZiBmaWVsZCBpcyBzZWxlY3RlZCwgeW91IGNhbiB1c2UgdGhpcyBmdW5jdGlvblxuICogZm9yIGNvbnZlbmllbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0ZWRPbmVvZlZhbHVlKG9uZW9mKSB7XG4gICAgaWYgKG9uZW9mLm9uZW9mS2luZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBvbmVvZltvbmVvZi5vbmVvZktpbmRdO1xufVxuIiwiaW1wb3J0IHsgaW50NjRmcm9tU3RyaW5nLCBpbnQ2NHRvU3RyaW5nIH0gZnJvbSBcIi4vZ29vZy12YXJpbnRcIjtcbmxldCBCSTtcbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RCaSgpIHtcbiAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoOCkpO1xuICAgIGNvbnN0IG9rID0gZ2xvYmFsVGhpcy5CaWdJbnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAmJiB0eXBlb2YgZHYuZ2V0QmlnSW50NjQgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAmJiB0eXBlb2YgZHYuZ2V0QmlnVWludDY0ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgJiYgdHlwZW9mIGR2LnNldEJpZ0ludDY0ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgJiYgdHlwZW9mIGR2LnNldEJpZ1VpbnQ2NCA9PT0gXCJmdW5jdGlvblwiO1xuICAgIEJJID0gb2sgPyB7XG4gICAgICAgIE1JTjogQmlnSW50KFwiLTkyMjMzNzIwMzY4NTQ3NzU4MDhcIiksXG4gICAgICAgIE1BWDogQmlnSW50KFwiOTIyMzM3MjAzNjg1NDc3NTgwN1wiKSxcbiAgICAgICAgVU1JTjogQmlnSW50KFwiMFwiKSxcbiAgICAgICAgVU1BWDogQmlnSW50KFwiMTg0NDY3NDQwNzM3MDk1NTE2MTVcIiksXG4gICAgICAgIEM6IEJpZ0ludCxcbiAgICAgICAgVjogZHYsXG4gICAgfSA6IHVuZGVmaW5lZDtcbn1cbmRldGVjdEJpKCk7XG5mdW5jdGlvbiBhc3NlcnRCaShiaSkge1xuICAgIGlmICghYmkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJpZ0ludCB1bmF2YWlsYWJsZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vc3RhbW0vcHJvdG9idWYtdHMvYmxvYi92MS4wLjgvTUFOVUFMLm1kI2JpZ2ludC1zdXBwb3J0XCIpO1xufVxuLy8gdXNlZCB0byB2YWxpZGF0ZSBmcm9tKHN0cmluZykgaW5wdXQgKHdoZW4gYmlnaW50IGlzIHVuYXZhaWxhYmxlKVxuY29uc3QgUkVfREVDSU1BTF9TVFIgPSAvXi0/WzAtOV0rJC87XG4vLyBjb25zdGFudHMgZm9yIGJpbmFyeSBtYXRoXG5jb25zdCBUV09fUFdSXzMyX0RCTCA9IDB4MTAwMDAwMDAwO1xuY29uc3QgSEFMRl8yX1BXUl8zMiA9IDB4MDgwMDAwMDAwO1xuLy8gYmFzZSBjbGFzcyBmb3IgUGJMb25nIGFuZCBQYlVMb25nIHByb3ZpZGVzIHNoYXJlZCBjb2RlXG5jbGFzcyBTaGFyZWRQYkxvbmcge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBiaXRzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvLCBoaSkge1xuICAgICAgICB0aGlzLmxvID0gbG8gfCAwO1xuICAgICAgICB0aGlzLmhpID0gaGkgfCAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIGluc3RhbmNlIGVxdWFsIHRvIDA/XG4gICAgICovXG4gICAgaXNaZXJvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sbyA9PSAwICYmIHRoaXMuaGkgPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0byBhIG5hdGl2ZSBudW1iZXIuXG4gICAgICovXG4gICAgdG9OdW1iZXIoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmhpICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sbyA+Pj4gMCk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIocmVzdWx0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBjb252ZXJ0IHRvIHNhZmUgbnVtYmVyXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuICogNjQtYml0IHVuc2lnbmVkIGludGVnZXIgYXMgdHdvIDMyLWJpdCB2YWx1ZXMuXG4gKiBDb252ZXJ0cyBiZXR3ZWVuIGBzdHJpbmdgLCBgbnVtYmVyYCBhbmQgYGJpZ2ludGAgcmVwcmVzZW50YXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgUGJVTG9uZyBleHRlbmRzIFNoYXJlZFBiTG9uZyB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGluc3RhbmNlIGZyb20gYSBgc3RyaW5nYCwgYG51bWJlcmAgb3IgYGJpZ2ludGAuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKEJJKVxuICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIEZhbGxUaHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIjBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlpFUk87XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgaXMgbm8gaW50ZWdlcicpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEJJLkModmFsdWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuWkVSTztcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBCSS5DKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5aRVJPO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCBCSS5VTUlOKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduZWQgdmFsdWUgZm9yIHVsb25nJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IEJJLlVNQVgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vsb25nIHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgICAgICAgICBCSS5WLnNldEJpZ1VpbnQ2NCgwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGJVTG9uZyhCSS5WLmdldEludDMyKDAsIHRydWUpLCBCSS5WLmdldEludDMyKDQsIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIjBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlpFUk87XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIVJFX0RFQ0lNQUxfU1RSLnRlc3QodmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgaXMgbm8gaW50ZWdlcicpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgW21pbnVzLCBsbywgaGldID0gaW50NjRmcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbnVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduZWQgdmFsdWUgZm9yIHVsb25nJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGJVTG9uZyhsbywgaGkpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5aRVJPO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIGlzIG5vIGludGVnZXInKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbmVkIHZhbHVlIGZvciB1bG9uZycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBiVUxvbmcodmFsdWUsIHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gdmFsdWUgJyArIHR5cGVvZiB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdG8gZGVjaW1hbCBzdHJpbmcuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBCSSA/IHRoaXMudG9CaWdJbnQoKS50b1N0cmluZygpIDogaW50NjR0b1N0cmluZyh0aGlzLmxvLCB0aGlzLmhpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0byBuYXRpdmUgYmlnaW50LlxuICAgICAqL1xuICAgIHRvQmlnSW50KCkge1xuICAgICAgICBhc3NlcnRCaShCSSk7XG4gICAgICAgIEJJLlYuc2V0SW50MzIoMCwgdGhpcy5sbywgdHJ1ZSk7XG4gICAgICAgIEJJLlYuc2V0SW50MzIoNCwgdGhpcy5oaSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBCSS5WLmdldEJpZ1VpbnQ2NCgwLCB0cnVlKTtcbiAgICB9XG59XG4vKipcbiAqIHVsb25nIDAgc2luZ2xldG9uLlxuICovXG5QYlVMb25nLlpFUk8gPSBuZXcgUGJVTG9uZygwLCAwKTtcbi8qKlxuICogNjQtYml0IHNpZ25lZCBpbnRlZ2VyIGFzIHR3byAzMi1iaXQgdmFsdWVzLlxuICogQ29udmVydHMgYmV0d2VlbiBgc3RyaW5nYCwgYG51bWJlcmAgYW5kIGBiaWdpbnRgIHJlcHJlc2VudGF0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFBiTG9uZyBleHRlbmRzIFNoYXJlZFBiTG9uZyB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGluc3RhbmNlIGZyb20gYSBgc3RyaW5nYCwgYG51bWJlcmAgb3IgYGJpZ2ludGAuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKEJJKVxuICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIEZhbGxUaHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIjBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlpFUk87XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgaXMgbm8gaW50ZWdlcicpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEJJLkModmFsdWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuWkVSTztcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBCSS5DKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5aRVJPO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCBCSS5NSU4pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25lZCBsb25nIHRvbyBzbWFsbCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBCSS5NQVgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25lZCBsb25nIHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgICAgICAgICBCSS5WLnNldEJpZ0ludDY0KDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYkxvbmcoQkkuVi5nZXRJbnQzMigwLCB0cnVlKSwgQkkuVi5nZXRJbnQzMig0LCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIwXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5aRVJPO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFSRV9ERUNJTUFMX1NUUi50ZXN0KHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIGlzIG5vIGludGVnZXInKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IFttaW51cywgbG8sIGhpXSA9IGludDY0ZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW51cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhpID4gSEFMRl8yX1BXUl8zMiB8fCAoaGkgPT0gSEFMRl8yX1BXUl8zMiAmJiBsbyAhPSAwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25lZCBsb25nIHRvbyBzbWFsbCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhpID49IEhBTEZfMl9QV1JfMzIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25lZCBsb25nIHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGJsID0gbmV3IFBiTG9uZyhsbywgaGkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWludXMgPyBwYmwubmVnYXRlKCkgOiBwYmw7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlpFUk87XG4gICAgICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgaXMgbm8gaW50ZWdlcicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBQYkxvbmcodmFsdWUsIHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyBQYkxvbmcoLXZhbHVlLCAtdmFsdWUgLyBUV09fUFdSXzMyX0RCTCkubmVnYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biB2YWx1ZSAnICsgdHlwZW9mIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG8gd2UgaGF2ZSBhIG1pbnVzIHNpZ24/XG4gICAgICovXG4gICAgaXNOZWdhdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmhpICYgSEFMRl8yX1BXUl8zMikgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5lZ2F0ZSB0d28ncyBjb21wbGVtZW50LlxuICAgICAqIEludmVydCBhbGwgdGhlIGJpdHMgYW5kIGFkZCBvbmUgdG8gdGhlIHJlc3VsdC5cbiAgICAgKi9cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIGxldCBoaSA9IH50aGlzLmhpLCBsbyA9IHRoaXMubG87XG4gICAgICAgIGlmIChsbylcbiAgICAgICAgICAgIGxvID0gfmxvICsgMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaGkgKz0gMTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYkxvbmcobG8sIGhpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0byBkZWNpbWFsIHN0cmluZy5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKEJJKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CaWdJbnQoKS50b1N0cmluZygpO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICAgIGxldCBuID0gdGhpcy5uZWdhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiAnLScgKyBpbnQ2NHRvU3RyaW5nKG4ubG8sIG4uaGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnQ2NHRvU3RyaW5nKHRoaXMubG8sIHRoaXMuaGkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRvIG5hdGl2ZSBiaWdpbnQuXG4gICAgICovXG4gICAgdG9CaWdJbnQoKSB7XG4gICAgICAgIGFzc2VydEJpKEJJKTtcbiAgICAgICAgQkkuVi5zZXRJbnQzMigwLCB0aGlzLmxvLCB0cnVlKTtcbiAgICAgICAgQkkuVi5zZXRJbnQzMig0LCB0aGlzLmhpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIEJJLlYuZ2V0QmlnSW50NjQoMCwgdHJ1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiBsb25nIDAgc2luZ2xldG9uLlxuICovXG5QYkxvbmcuWkVSTyA9IG5ldyBQYkxvbmcoMCwgMCk7XG4iLCJpbXBvcnQgeyBVbmtub3duRmllbGRIYW5kbGVyLCBXaXJlVHlwZSB9IGZyb20gXCIuL2JpbmFyeS1mb3JtYXQtY29udHJhY3RcIjtcbmltcG9ydCB7IExvbmdUeXBlLCBTY2FsYXJUeXBlIH0gZnJvbSBcIi4vcmVmbGVjdGlvbi1pbmZvXCI7XG5pbXBvcnQgeyByZWZsZWN0aW9uTG9uZ0NvbnZlcnQgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWxvbmctY29udmVydFwiO1xuaW1wb3J0IHsgcmVmbGVjdGlvblNjYWxhckRlZmF1bHQgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLXNjYWxhci1kZWZhdWx0XCI7XG4vKipcbiAqIFJlYWRzIHByb3RvMyBtZXNzYWdlcyBpbiBiaW5hcnkgZm9ybWF0IHVzaW5nIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24uXG4gKlxuICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL2VuY29kaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWZsZWN0aW9uQmluYXJ5UmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpbmZvKSB7XG4gICAgICAgIHRoaXMuaW5mbyA9IGluZm87XG4gICAgfVxuICAgIHByZXBhcmUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkTm9Ub0ZpZWxkKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZHNJbnB1dCA9IChfYSA9IHRoaXMuaW5mby5maWVsZHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgdGhpcy5maWVsZE5vVG9GaWVsZCA9IG5ldyBNYXAoZmllbGRzSW5wdXQubWFwKGZpZWxkID0+IFtmaWVsZC5ubywgZmllbGRdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBtZXNzYWdlIGZyb20gYmluYXJ5IGZvcm1hdCBpbnRvIHRoZSB0YXJnZXQgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIFJlcGVhdGVkIGZpZWxkcyBhcmUgYXBwZW5kZWQuIE1hcCBlbnRyaWVzIGFyZSBhZGRlZCwgb3ZlcndyaXRpbmdcbiAgICAgKiBleGlzdGluZyBrZXlzLlxuICAgICAqXG4gICAgICogSWYgYSBtZXNzYWdlIGZpZWxkIGlzIGFscmVhZHkgcHJlc2VudCwgaXQgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGVcbiAgICAgKiBuZXcgZGF0YS5cbiAgICAgKi9cbiAgICByZWFkKHJlYWRlciwgbWVzc2FnZSwgb3B0aW9ucywgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZSgpO1xuICAgICAgICBjb25zdCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgLy8gcmVhZCB0aGUgdGFnIGFuZCBmaW5kIHRoZSBmaWVsZFxuICAgICAgICAgICAgY29uc3QgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKSwgZmllbGQgPSB0aGlzLmZpZWxkTm9Ub0ZpZWxkLmdldChmaWVsZE5vKTtcbiAgICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICBpZiAodSA9PSBcInRocm93XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMuaW5mby50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLmluZm8udHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRhcmdldCBvYmplY3QgZm9yIHRoZSBmaWVsZCB3ZSBhcmUgcmVhZGluZ1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IG1lc3NhZ2UsIHJlcGVhdGVkID0gZmllbGQucmVwZWF0LCBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gICAgICAgICAgICAvLyBpZiBmaWVsZCBpcyBtZW1iZXIgb2Ygb25lb2YgQURULCB1c2UgQURUIGFzIHRhcmdldFxuICAgICAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W2ZpZWxkLm9uZW9mXTtcbiAgICAgICAgICAgICAgICAvLyBpZiBvdGhlciBvbmVvZiBtZW1iZXIgc2VsZWN0ZWQsIHNldCBuZXcgQURUXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5vbmVvZktpbmQgIT09IGxvY2FsTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gbWVzc2FnZVtmaWVsZC5vbmVvZl0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6IGxvY2FsTmFtZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UgaGF2ZSBoYW5kbGVkIG9uZW9mIGFib3ZlLCB3ZSBqdXN0IGhhdmUgcmVhZCB0aGUgdmFsdWUgaW50byBgdGFyZ2V0W2xvY2FsTmFtZV1gXG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgbGV0IFQgPSBmaWVsZC5raW5kID09IFwiZW51bVwiID8gU2NhbGFyVHlwZS5JTlQzMiA6IGZpZWxkLlQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBMID0gZmllbGQua2luZCA9PSBcInNjYWxhclwiID8gZmllbGQuTCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXJyID0gdGFyZ2V0W2xvY2FsTmFtZV07IC8vIHNhZmUgdG8gYXNzdW1lIHByZXNlbmNlIG9mIGFycmF5LCBvbmVvZiBjYW5ub3QgY29udGFpbiByZXBlYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQgJiYgVCAhPSBTY2FsYXJUeXBlLlNUUklORyAmJiBUICE9IFNjYWxhclR5cGUuQllURVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZSA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCh0aGlzLnNjYWxhcihyZWFkZXIsIFQsIEwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCh0aGlzLnNjYWxhcihyZWFkZXIsIFQsIEwpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHRoaXMuc2NhbGFyKHJlYWRlciwgVCwgTCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFyciA9IHRhcmdldFtsb2NhbE5hbWVdOyAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBhcnJheSwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbXNnID0gZmllbGQuVCgpLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChtc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gZmllbGQuVCgpLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgdGFyZ2V0W2xvY2FsTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgICAgIGxldCBbbWFwS2V5LCBtYXBWYWxdID0gdGhpcy5tYXBFbnRyeShmaWVsZCwgcmVhZGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgbWFwIG9iamVjdCwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdW21hcEtleV0gPSBtYXBWYWw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBtYXAgZmllbGQsIGV4cGVjdGluZyBrZXkgZmllbGQgPSAxLCB2YWx1ZSBmaWVsZCA9IDJcbiAgICAgKi9cbiAgICBtYXBFbnRyeShmaWVsZCwgcmVhZGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBsZW5ndGggPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgIGxldCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBsZXQga2V5ID0gdW5kZWZpbmVkOyAvLyBqYXZhc2NyaXB0IG9ubHkgYWxsb3dzIG51bWJlciBvciBzdHJpbmcgZm9yIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgICAgIGxldCB2YWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLksgPT0gU2NhbGFyVHlwZS5CT09MKVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gcmVhZGVyLmJvb2woKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb25nIHR5cGVzIGFyZSByZWFkIGFzIHN0cmluZywgbnVtYmVyIHR5cGVzIGFyZSBva2F5IGFzIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5zY2FsYXIocmVhZGVyLCBmaWVsZC5LLCBMb25nVHlwZS5TVFJJTkcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5zY2FsYXIocmVhZGVyLCBmaWVsZC5WLlQsIGZpZWxkLlYuTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBmaWVsZC5WLlQoKS5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGluIG1hcCBlbnRyeSBmb3IgJHt0aGlzLmluZm8udHlwZU5hbWV9IyR7ZmllbGQubmFtZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBrZXlSYXcgPSByZWZsZWN0aW9uU2NhbGFyRGVmYXVsdChmaWVsZC5LKTtcbiAgICAgICAgICAgIGtleSA9IGZpZWxkLksgPT0gU2NhbGFyVHlwZS5CT09MID8ga2V5UmF3LnRvU3RyaW5nKCkgOiBrZXlSYXc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHJlZmxlY3Rpb25TY2FsYXJEZWZhdWx0KGZpZWxkLlYuVCwgZmllbGQuVi5MKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gZmllbGQuVi5UKCkuY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2tleSwgdmFsXTtcbiAgICB9XG4gICAgc2NhbGFyKHJlYWRlciwgdHlwZSwgbG9uZ1R5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIuZG91YmxlKCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgICAgICAgICAgIHJldHVybiByZWZsZWN0aW9uTG9uZ0NvbnZlcnQocmVhZGVyLmludDY0KCksIGxvbmdUeXBlKTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3Rpb25Mb25nQ29udmVydChyZWFkZXIudWludDY0KCksIGxvbmdUeXBlKTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgICAgICAgICAgIHJldHVybiByZWZsZWN0aW9uTG9uZ0NvbnZlcnQocmVhZGVyLmZpeGVkNjQoKSwgbG9uZ1R5cGUpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5maXhlZDMyKCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIuc2ZpeGVkMzIoKTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmbGVjdGlvbkxvbmdDb252ZXJ0KHJlYWRlci5zZml4ZWQ2NCgpLCBsb25nVHlwZSk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIuc2ludDMyKCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgICAgICAgICAgIHJldHVybiByZWZsZWN0aW9uTG9uZ0NvbnZlcnQocmVhZGVyLnNpbnQ2NCgpLCBsb25nVHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBVbmtub3duRmllbGRIYW5kbGVyLCBXaXJlVHlwZSB9IGZyb20gXCIuL2JpbmFyeS1mb3JtYXQtY29udHJhY3RcIjtcbmltcG9ydCB7IFJlcGVhdFR5cGUsIFNjYWxhclR5cGUgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWluZm9cIjtcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuL2Fzc2VydFwiO1xuaW1wb3J0IHsgUGJMb25nLCBQYlVMb25nIH0gZnJvbSBcIi4vcGItbG9uZ1wiO1xuLyoqXG4gKiBXcml0ZXMgcHJvdG8zIG1lc3NhZ2VzIGluIGJpbmFyeSBmb3JtYXQgdXNpbmcgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvZW5jb2RpbmdcbiAqL1xuZXhwb3J0IGNsYXNzIFJlZmxlY3Rpb25CaW5hcnlXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGluZm8pIHtcbiAgICAgICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICB9XG4gICAgcHJlcGFyZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgZmllbGRzSW5wdXQgPSB0aGlzLmluZm8uZmllbGRzID8gdGhpcy5pbmZvLmZpZWxkcy5jb25jYXQoKSA6IFtdO1xuICAgICAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHNJbnB1dC5zb3J0KChhLCBiKSA9PiBhLm5vIC0gYi5ubyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIHRoZSBtZXNzYWdlIHRvIGJpbmFyeSBmb3JtYXQuXG4gICAgICovXG4gICAgd3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUsIC8vIHRoaXMgd2lsbCBiZSBvdXIgZmllbGQgdmFsdWUsIHdoZXRoZXIgaXQgaXMgbWVtYmVyIG9mIGEgb25lb2Ygb3Igbm90XG4gICAgICAgICAgICBlbWl0RGVmYXVsdCwgLy8gd2hldGhlciB3ZSBlbWl0IHRoZSBkZWZhdWx0IHZhbHVlIChvbmx5IHRydWUgZm9yIG9uZW9mIG1lbWJlcnMpXG4gICAgICAgICAgICByZXBlYXRlZCA9IGZpZWxkLnJlcGVhdCwgbG9jYWxOYW1lID0gZmllbGQubG9jYWxOYW1lO1xuICAgICAgICAgICAgLy8gaGFuZGxlIG9uZW9mIEFEVFxuICAgICAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBtZXNzYWdlW2ZpZWxkLm9uZW9mXTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAub25lb2ZLaW5kICE9PSBsb2NhbE5hbWUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBpZiBmaWVsZCBpcyBub3Qgc2VsZWN0ZWQsIHNraXBcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGdyb3VwW2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgZW1pdERlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtZXNzYWdlW2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgZW1pdERlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGhhdmUgaGFuZGxlZCBvbmVvZiBhYm92ZS4gd2UganVzdCBoYXZlIHRvIGhvbm9yIGBlbWl0RGVmYXVsdGAuXG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgbGV0IFQgPSBmaWVsZC5raW5kID09IFwiZW51bVwiID8gU2NhbGFyVHlwZS5JTlQzMiA6IGZpZWxkLlQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBlYXRlZCA9PSBSZXBlYXRUeXBlLlBBQ0tFRClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhY2tlZCh3cml0ZXIsIFQsIGZpZWxkLm5vLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYWxhcih3cml0ZXIsIFQsIGZpZWxkLm5vLCBpdGVtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZpZWxkLm9wdCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NhbGFyKHdyaXRlciwgVCwgZmllbGQubm8sIHZhbHVlLCBlbWl0RGVmYXVsdCB8fCBmaWVsZC5vcHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydChBcnJheS5pc0FycmF5KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlKHdyaXRlciwgb3B0aW9ucywgZmllbGQuVCgpLCBmaWVsZC5ubywgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2Uod3JpdGVyLCBvcHRpb25zLCBmaWVsZC5UKCksIGZpZWxkLm5vLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwRW50cnkod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwga2V5LCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMuaW5mby50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICB9XG4gICAgbWFwRW50cnkod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwga2V5LCB2YWx1ZSkge1xuICAgICAgICB3cml0ZXIudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpO1xuICAgICAgICB3cml0ZXIuZm9yaygpO1xuICAgICAgICAvLyBqYXZhc2NyaXB0IG9ubHkgYWxsb3dzIG51bWJlciBvciBzdHJpbmcgZm9yIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIHdlIGNvbnZlcnQgZnJvbSBvdXIgcmVwcmVzZW50YXRpb24gdG8gdGhlIHByb3RvYnVmIHR5cGVcbiAgICAgICAgbGV0IGtleVZhbHVlID0ga2V5O1xuICAgICAgICBzd2l0Y2ggKGZpZWxkLkspIHtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgICAgICAgICAga2V5VmFsdWUgPSBOdW1iZXIucGFyc2VJbnQoa2V5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgICAgIGFzc2VydChrZXkgPT0gJ3RydWUnIHx8IGtleSA9PSAnZmFsc2UnKTtcbiAgICAgICAgICAgICAgICBrZXlWYWx1ZSA9IGtleSA9PSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd3JpdGUga2V5LCBleHBlY3Rpbmcga2V5IGZpZWxkIG51bWJlciA9IDFcbiAgICAgICAgdGhpcy5zY2FsYXIod3JpdGVyLCBmaWVsZC5LLCAxLCBrZXlWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgIC8vIHdyaXRlIHZhbHVlLCBleHBlY3RpbmcgdmFsdWUgZmllbGQgbnVtYmVyID0gMlxuICAgICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxhcih3cml0ZXIsIGZpZWxkLlYuVCwgMiwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZW51bSc6XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsYXIod3JpdGVyLCBTY2FsYXJUeXBlLklOVDMyLCAyLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2Uod3JpdGVyLCBvcHRpb25zLCBmaWVsZC5WLlQoKSwgMiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5qb2luKCk7XG4gICAgfVxuICAgIG1lc3NhZ2Uod3JpdGVyLCBvcHRpb25zLCBoYW5kbGVyLCBmaWVsZE5vLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaGFuZGxlci5pbnRlcm5hbEJpbmFyeVdyaXRlKHZhbHVlLCB3cml0ZXIudGFnKGZpZWxkTm8sIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKTtcbiAgICAgICAgd3JpdGVyLmpvaW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBzaW5nbGUgc2NhbGFyIHZhbHVlLlxuICAgICAqL1xuICAgIHNjYWxhcih3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlLCBlbWl0RGVmYXVsdCkge1xuICAgICAgICBsZXQgW3dpcmVUeXBlLCBtZXRob2QsIGlzRGVmYXVsdF0gPSB0aGlzLnNjYWxhckluZm8odHlwZSwgdmFsdWUpO1xuICAgICAgICBpZiAoIWlzRGVmYXVsdCB8fCBlbWl0RGVmYXVsdCkge1xuICAgICAgICAgICAgd3JpdGVyLnRhZyhmaWVsZE5vLCB3aXJlVHlwZSk7XG4gICAgICAgICAgICB3cml0ZXJbbWV0aG9kXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYW4gYXJyYXkgb2Ygc2NhbGFyIHZhbHVlcyBpbiBwYWNrZWQgZm9ybWF0LlxuICAgICAqL1xuICAgIHBhY2tlZCh3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBhc3NlcnQodHlwZSAhPT0gU2NhbGFyVHlwZS5CWVRFUyAmJiB0eXBlICE9PSBTY2FsYXJUeXBlLlNUUklORyk7XG4gICAgICAgIC8vIHdyaXRlIHRhZ1xuICAgICAgICB3cml0ZXIudGFnKGZpZWxkTm8sIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCk7XG4gICAgICAgIC8vIGJlZ2luIGxlbmd0aC1kZWxpbWl0ZWRcbiAgICAgICAgd3JpdGVyLmZvcmsoKTtcbiAgICAgICAgLy8gd3JpdGUgdmFsdWVzIHdpdGhvdXQgdGFnc1xuICAgICAgICBsZXQgWywgbWV0aG9kLF0gPSB0aGlzLnNjYWxhckluZm8odHlwZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXJbbWV0aG9kXSh2YWx1ZVtpXSk7XG4gICAgICAgIC8vIGVuZCBsZW5ndGggZGVsaW1pdGVkXG4gICAgICAgIHdyaXRlci5qb2luKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBpbmZvcm1hdGlvbiBmb3Igd3JpdGluZyBhIHNjYWxhciB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFJldHVybnMgdHVwbGU6XG4gICAgICogWzBdOiBhcHByb3ByaWF0ZSBXaXJlVHlwZVxuICAgICAqIFsxXTogbmFtZSBvZiB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIG9mIElCaW5hcnlXcml0ZXJcbiAgICAgKiBbMl06IHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZGVmYXVsdCB2YWx1ZVxuICAgICAqXG4gICAgICogSWYgYXJndW1lbnQgYHZhbHVlYCBpcyBvbWl0dGVkLCBbMl0gaXMgYWx3YXlzIGZhbHNlLlxuICAgICAqL1xuICAgIHNjYWxhckluZm8odHlwZSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IHQgPSBXaXJlVHlwZS5WYXJpbnQ7XG4gICAgICAgIGxldCBtO1xuICAgICAgICBsZXQgaSA9IHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBkID0gdmFsdWUgPT09IDA7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgICAgICAgICAgICAgIG0gPSBcImludDMyXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgICAgIGQgPSBpIHx8ICF2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdCA9IFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDtcbiAgICAgICAgICAgICAgICBtID0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgICAgIGQgPSB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbSA9IFwiYm9vbFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgICAgICAgICBtID0gXCJ1aW50MzJcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgICAgICAgICAgICAgdCA9IFdpcmVUeXBlLkJpdDY0O1xuICAgICAgICAgICAgICAgIG0gPSBcImRvdWJsZVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgICAgICAgICAgIHQgPSBXaXJlVHlwZS5CaXQzMjtcbiAgICAgICAgICAgICAgICBtID0gXCJmbG9hdFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgICAgICAgICAgIGQgPSBpIHx8IFBiTG9uZy5mcm9tKHZhbHVlKS5pc1plcm8oKTtcbiAgICAgICAgICAgICAgICBtID0gXCJpbnQ2NFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgICAgICAgICAgICBkID0gaSB8fCBQYlVMb25nLmZyb20odmFsdWUpLmlzWmVybygpO1xuICAgICAgICAgICAgICAgIG0gPSBcInVpbnQ2NFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgICAgICAgICAgICAgZCA9IGkgfHwgUGJVTG9uZy5mcm9tKHZhbHVlKS5pc1plcm8oKTtcbiAgICAgICAgICAgICAgICB0ID0gV2lyZVR5cGUuQml0NjQ7XG4gICAgICAgICAgICAgICAgbSA9IFwiZml4ZWQ2NFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgICAgICAgICAgIGQgPSBpIHx8ICF2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHQgPSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQ7XG4gICAgICAgICAgICAgICAgbSA9IFwiYnl0ZXNcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICAgICAgICAgIHQgPSBXaXJlVHlwZS5CaXQzMjtcbiAgICAgICAgICAgICAgICBtID0gXCJmaXhlZDMyXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgICAgICAgICAgdCA9IFdpcmVUeXBlLkJpdDMyO1xuICAgICAgICAgICAgICAgIG0gPSBcInNmaXhlZDMyXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgICAgICAgICAgICAgZCA9IGkgfHwgUGJMb25nLmZyb20odmFsdWUpLmlzWmVybygpO1xuICAgICAgICAgICAgICAgIHQgPSBXaXJlVHlwZS5CaXQ2NDtcbiAgICAgICAgICAgICAgICBtID0gXCJzZml4ZWQ2NFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICAgICAgICAgICAgICBtID0gXCJzaW50MzJcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICAgICAgZCA9IGkgfHwgUGJMb25nLmZyb20odmFsdWUpLmlzWmVybygpO1xuICAgICAgICAgICAgICAgIG0gPSBcInNpbnQ2NFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdCwgbSwgaSB8fCBkXTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyByZWZsZWN0aW9uU2NhbGFyRGVmYXVsdCB9IGZyb20gXCIuL3JlZmxlY3Rpb24tc2NhbGFyLWRlZmF1bHRcIjtcbmltcG9ydCB7IE1FU1NBR0VfVFlQRSB9IGZyb20gJy4vbWVzc2FnZS10eXBlLWNvbnRyYWN0Jztcbi8qKlxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgZ2VuZXJpYyBtZXNzYWdlLCB1c2luZyB0aGUgZmllbGRcbiAqIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVmbGVjdGlvbkNyZWF0ZSh0eXBlKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyB0ZXJuYXJ5IGNhbiBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAgICogVGhlIGBPYmplY3QuY3JlYXRlKClgIGNvZGUgcGF0aCB1dGlsaXplcyBhIG5ldyBgbWVzc2FnZVByb3RvdHlwZWBcbiAgICAgKiBwcm9wZXJ0eSBvbiB0aGUgYElNZXNzYWdlVHlwZWAgd2hpY2ggaGFzIHRoaXMgc2FtZSBgTUVTU0FHRV9UWVBFYFxuICAgICAqIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIGl0LiBEb2luZyBpdCB0aGlzIHdheSBtZWFucyB0aGF0IHdlIG9ubHlcbiAgICAgKiBwYXkgdGhlIGNvc3Qgb2YgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpYCBvbmNlIHBlciBgSU1lc3NhZ2VUeXBlYFxuICAgICAqIGNsYXNzIG9mIG9uY2UgcGVyIFwiaW5zdGFuY2VcIi4gVGhlIGZhbHN5IGNvZGUgcGF0aCBpcyBvbmx5IHByb3ZpZGVkXG4gICAgICogZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGluIGNhc2VzIHdoZXJlIHRoZSBydW50aW1lIGxpYnJhcnkgaXNcbiAgICAgKiB1cGRhdGVkIHdpdGhvdXQgYWxzbyB1cGRhdGluZyB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4gICAgICovXG4gICAgY29uc3QgbXNnID0gdHlwZS5tZXNzYWdlUHJvdG90eXBlXG4gICAgICAgID8gT2JqZWN0LmNyZWF0ZSh0eXBlLm1lc3NhZ2VQcm90b3R5cGUpXG4gICAgICAgIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBNRVNTQUdFX1RZUEUsIHsgdmFsdWU6IHR5cGUgfSk7XG4gICAgZm9yIChsZXQgZmllbGQgb2YgdHlwZS5maWVsZHMpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gICAgICAgIGlmIChmaWVsZC5vcHQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGZpZWxkLm9uZW9mKVxuICAgICAgICAgICAgbXNnW2ZpZWxkLm9uZW9mXSA9IHsgb25lb2ZLaW5kOiB1bmRlZmluZWQgfTtcbiAgICAgICAgZWxzZSBpZiAoZmllbGQucmVwZWF0KVxuICAgICAgICAgICAgbXNnW25hbWVdID0gW107XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgbXNnW25hbWVdID0gcmVmbGVjdGlvblNjYWxhckRlZmF1bHQoZmllbGQuVCwgZmllbGQuTCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHJlcXVpcmUgMCB0byBiZSBkZWZhdWx0IHZhbHVlIGZvciBhbGwgZW51bXNcbiAgICAgICAgICAgICAgICAgICAgbXNnW25hbWVdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgICAgICBtc2dbbmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtc2c7XG59XG4iLCJpbXBvcnQgeyBTY2FsYXJUeXBlIH0gZnJvbSBcIi4vcmVmbGVjdGlvbi1pbmZvXCI7XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0d28gbWVzc2FnZSBvZiB0aGUgc2FtZSB0eXBlIGhhdmUgdGhlIHNhbWUgZmllbGQgdmFsdWVzLlxuICogQ2hlY2tzIGZvciBkZWVwIGVxdWFsaXR5LCB0cmF2ZXJzaW5nIHJlcGVhdGVkIGZpZWxkcywgb25lb2YgZ3JvdXBzLCBtYXBzXG4gKiBhbmQgbWVzc2FnZXMgcmVjdXJzaXZlbHkuXG4gKiBXaWxsIGFsc28gcmV0dXJuIHRydWUgaWYgYm90aCBtZXNzYWdlcyBhcmUgYHVuZGVmaW5lZGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWZsZWN0aW9uRXF1YWxzKGluZm8sIGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFhIHx8ICFiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgZmllbGQgb2YgaW5mby5maWVsZHMpIHtcbiAgICAgICAgbGV0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgICAgICAgbGV0IHZhbF9hID0gZmllbGQub25lb2YgPyBhW2ZpZWxkLm9uZW9mXVtsb2NhbE5hbWVdIDogYVtsb2NhbE5hbWVdO1xuICAgICAgICBsZXQgdmFsX2IgPSBmaWVsZC5vbmVvZiA/IGJbZmllbGQub25lb2ZdW2xvY2FsTmFtZV0gOiBiW2xvY2FsTmFtZV07XG4gICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICBsZXQgdCA9IGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgPyBTY2FsYXJUeXBlLklOVDMyIDogZmllbGQuVDtcbiAgICAgICAgICAgICAgICBpZiAoIShmaWVsZC5yZXBlYXRcbiAgICAgICAgICAgICAgICAgICAgPyByZXBlYXRlZFByaW1pdGl2ZUVxKHQsIHZhbF9hLCB2YWxfYilcbiAgICAgICAgICAgICAgICAgICAgOiBwcmltaXRpdmVFcSh0LCB2YWxfYSwgdmFsX2IpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgIGlmICghKGZpZWxkLlYua2luZCA9PSBcIm1lc3NhZ2VcIlxuICAgICAgICAgICAgICAgICAgICA/IHJlcGVhdGVkTXNnRXEoZmllbGQuVi5UKCksIG9iamVjdFZhbHVlcyh2YWxfYSksIG9iamVjdFZhbHVlcyh2YWxfYikpXG4gICAgICAgICAgICAgICAgICAgIDogcmVwZWF0ZWRQcmltaXRpdmVFcShmaWVsZC5WLmtpbmQgPT0gXCJlbnVtXCIgPyBTY2FsYXJUeXBlLklOVDMyIDogZmllbGQuVi5ULCBvYmplY3RWYWx1ZXModmFsX2EpLCBvYmplY3RWYWx1ZXModmFsX2IpKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgbGV0IFQgPSBmaWVsZC5UKCk7XG4gICAgICAgICAgICAgICAgaWYgKCEoZmllbGQucmVwZWF0XG4gICAgICAgICAgICAgICAgICAgID8gcmVwZWF0ZWRNc2dFcShULCB2YWxfYSwgdmFsX2IpXG4gICAgICAgICAgICAgICAgICAgIDogVC5lcXVhbHModmFsX2EsIHZhbF9iKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IG9iamVjdFZhbHVlcyA9IE9iamVjdC52YWx1ZXM7XG5mdW5jdGlvbiBwcmltaXRpdmVFcSh0eXBlLCBhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlICE9PSBTY2FsYXJUeXBlLkJZVEVTKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGJhID0gYTtcbiAgICBsZXQgYmIgPSBiO1xuICAgIGlmIChiYS5sZW5ndGggIT09IGJiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChiYVtpXSAhPSBiYltpXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlcGVhdGVkUHJpbWl0aXZlRXEodHlwZSwgYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghcHJpbWl0aXZlRXEodHlwZSwgYVtpXSwgYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZXBlYXRlZE1zZ0VxKHR5cGUsIGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIXR5cGUuZXF1YWxzKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuIiwiaW1wb3J0IHsgbG93ZXJDYW1lbENhc2UgfSBmcm9tIFwiLi9sb3dlci1jYW1lbC1jYXNlXCI7XG4vKipcbiAqIFNjYWxhciB2YWx1ZSB0eXBlcy4gVGhpcyBpcyBhIHN1YnNldCBvZiBmaWVsZCB0eXBlcyBkZWNsYXJlZCBieSBwcm90b2J1ZlxuICogZW51bSBnb29nbGUucHJvdG9idWYuRmllbGREZXNjcmlwdG9yUHJvdG8uVHlwZSBUaGUgdHlwZXMgR1JPVVAgYW5kIE1FU1NBR0VcbiAqIGFyZSBvbWl0dGVkLCBidXQgdGhlIG51bWVyaWNhbCB2YWx1ZXMgYXJlIGlkZW50aWNhbC5cbiAqL1xuZXhwb3J0IHZhciBTY2FsYXJUeXBlO1xuKGZ1bmN0aW9uIChTY2FsYXJUeXBlKSB7XG4gICAgLy8gMCBpcyByZXNlcnZlZCBmb3IgZXJyb3JzLlxuICAgIC8vIE9yZGVyIGlzIHdlaXJkIGZvciBoaXN0b3JpY2FsIHJlYXNvbnMuXG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRE9VQkxFXCJdID0gMV0gPSBcIkRPVUJMRVwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZMT0FUXCJdID0gMl0gPSBcIkZMT0FUXCI7XG4gICAgLy8gTm90IFppZ1phZyBlbmNvZGVkLiAgTmVnYXRpdmUgbnVtYmVycyB0YWtlIDEwIGJ5dGVzLiAgVXNlIFRZUEVfU0lOVDY0IGlmXG4gICAgLy8gbmVnYXRpdmUgdmFsdWVzIGFyZSBsaWtlbHkuXG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiSU5UNjRcIl0gPSAzXSA9IFwiSU5UNjRcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJVSU5UNjRcIl0gPSA0XSA9IFwiVUlOVDY0XCI7XG4gICAgLy8gTm90IFppZ1phZyBlbmNvZGVkLiAgTmVnYXRpdmUgbnVtYmVycyB0YWtlIDEwIGJ5dGVzLiAgVXNlIFRZUEVfU0lOVDMyIGlmXG4gICAgLy8gbmVnYXRpdmUgdmFsdWVzIGFyZSBsaWtlbHkuXG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiSU5UMzJcIl0gPSA1XSA9IFwiSU5UMzJcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJGSVhFRDY0XCJdID0gNl0gPSBcIkZJWEVENjRcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJGSVhFRDMyXCJdID0gN10gPSBcIkZJWEVEMzJcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJCT09MXCJdID0gOF0gPSBcIkJPT0xcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTVFJJTkdcIl0gPSA5XSA9IFwiU1RSSU5HXCI7XG4gICAgLy8gVGFnLWRlbGltaXRlZCBhZ2dyZWdhdGUuXG4gICAgLy8gR3JvdXAgdHlwZSBpcyBkZXByZWNhdGVkIGFuZCBub3Qgc3VwcG9ydGVkIGluIHByb3RvMy4gSG93ZXZlciwgUHJvdG8zXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIHNob3VsZCBzdGlsbCBiZSBhYmxlIHRvIHBhcnNlIHRoZSBncm91cCB3aXJlIGZvcm1hdCBhbmRcbiAgICAvLyB0cmVhdCBncm91cCBmaWVsZHMgYXMgdW5rbm93biBmaWVsZHMuXG4gICAgLy8gVFlQRV9HUk9VUCA9IDEwLFxuICAgIC8vIFRZUEVfTUVTU0FHRSA9IDExLCAgLy8gTGVuZ3RoLWRlbGltaXRlZCBhZ2dyZWdhdGUuXG4gICAgLy8gTmV3IGluIHZlcnNpb24gMi5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJCWVRFU1wiXSA9IDEyXSA9IFwiQllURVNcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJVSU5UMzJcIl0gPSAxM10gPSBcIlVJTlQzMlwiO1xuICAgIC8vIFRZUEVfRU5VTSA9IDE0LFxuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNGSVhFRDMyXCJdID0gMTVdID0gXCJTRklYRUQzMlwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNGSVhFRDY0XCJdID0gMTZdID0gXCJTRklYRUQ2NFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNJTlQzMlwiXSA9IDE3XSA9IFwiU0lOVDMyXCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0lOVDY0XCJdID0gMThdID0gXCJTSU5UNjRcIjtcbn0pKFNjYWxhclR5cGUgfHwgKFNjYWxhclR5cGUgPSB7fSkpO1xuLyoqXG4gKiBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIDY0IGJpdCBpbnRlZ3JhbCB0eXBlcy4gRXF1aXZhbGVudCB0byB0aGVcbiAqIGZpZWxkIG9wdGlvbiBcImpzdHlwZVwiLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHByb3RvYnVmLXRzIHJlcHJlc2VudHMgNjQgYml0IHR5cGVzIGFzIGBiaWdpbnRgLlxuICpcbiAqIFlvdSBjYW4gY2hhbmdlIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBieSBlbmFibGluZyB0aGUgcGx1Z2luIHBhcmFtZXRlclxuICogYGxvbmdfdHlwZV9zdHJpbmdgLCB3aGljaCB3aWxsIHJlcHJlc2VudCA2NCBiaXQgdHlwZXMgYXMgYHN0cmluZ2AuXG4gKlxuICogQWx0ZXJuYXRpdmVseSwgeW91IGNhbiBjaGFuZ2UgdGhlIGJlaGF2aW91ciBmb3IgaW5kaXZpZHVhbCBmaWVsZHNcbiAqIHdpdGggdGhlIGZpZWxkIG9wdGlvbiBcImpzdHlwZVwiOlxuICpcbiAqIGBgYHByb3RvYnVmXG4gKiB1aW50NjQgbXlfZmllbGQgPSAxIFtqc3R5cGUgPSBKU19TVFJJTkddO1xuICogdWludDY0IG90aGVyX2ZpZWxkID0gMiBbanN0eXBlID0gSlNfTlVNQkVSXTtcbiAqIGBgYFxuICovXG5leHBvcnQgdmFyIExvbmdUeXBlO1xuKGZ1bmN0aW9uIChMb25nVHlwZSkge1xuICAgIC8qKlxuICAgICAqIFVzZSBKYXZhU2NyaXB0IGBiaWdpbnRgLlxuICAgICAqXG4gICAgICogRmllbGQgb3B0aW9uIGBbanN0eXBlID0gSlNfTk9STUFMXWAuXG4gICAgICovXG4gICAgTG9uZ1R5cGVbTG9uZ1R5cGVbXCJCSUdJTlRcIl0gPSAwXSA9IFwiQklHSU5UXCI7XG4gICAgLyoqXG4gICAgICogVXNlIEphdmFTY3JpcHQgYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBGaWVsZCBvcHRpb24gYFtqc3R5cGUgPSBKU19TVFJJTkddYC5cbiAgICAgKi9cbiAgICBMb25nVHlwZVtMb25nVHlwZVtcIlNUUklOR1wiXSA9IDFdID0gXCJTVFJJTkdcIjtcbiAgICAvKipcbiAgICAgKiBVc2UgSmF2YVNjcmlwdCBgbnVtYmVyYC5cbiAgICAgKlxuICAgICAqIExhcmdlIHZhbHVlcyB3aWxsIGxvb3NlIHByZWNpc2lvbi5cbiAgICAgKlxuICAgICAqIEZpZWxkIG9wdGlvbiBgW2pzdHlwZSA9IEpTX05VTUJFUl1gLlxuICAgICAqL1xuICAgIExvbmdUeXBlW0xvbmdUeXBlW1wiTlVNQkVSXCJdID0gMl0gPSBcIk5VTUJFUlwiO1xufSkoTG9uZ1R5cGUgfHwgKExvbmdUeXBlID0ge30pKTtcbi8qKlxuICogUHJvdG9idWYgMi4xLjAgaW50cm9kdWNlZCBwYWNrZWQgcmVwZWF0ZWQgZmllbGRzLlxuICogU2V0dGluZyB0aGUgZmllbGQgb3B0aW9uIGBbcGFja2VkID0gdHJ1ZV1gIGVuYWJsZXMgcGFja2luZy5cbiAqXG4gKiBJbiBwcm90bzMsIGFsbCByZXBlYXRlZCBmaWVsZHMgYXJlIHBhY2tlZCBieSBkZWZhdWx0LlxuICogU2V0dGluZyB0aGUgZmllbGQgb3B0aW9uIGBbcGFja2VkID0gZmFsc2VdYCBkaXNhYmxlcyBwYWNraW5nLlxuICpcbiAqIFBhY2tlZCByZXBlYXRlZCBmaWVsZHMgYXJlIGVuY29kZWQgd2l0aCBhIHNpbmdsZSB0YWcsXG4gKiB0aGVuIGEgbGVuZ3RoLWRlbGltaXRlciwgdGhlbiB0aGUgZWxlbWVudCB2YWx1ZXMuXG4gKlxuICogVW5wYWNrZWQgcmVwZWF0ZWQgZmllbGRzIGFyZSBlbmNvZGVkIHdpdGggYSB0YWcgYW5kXG4gKiB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50LlxuICpcbiAqIGBieXRlc2AgYW5kIGBzdHJpbmdgIGNhbm5vdCBiZSBwYWNrZWQuXG4gKi9cbmV4cG9ydCB2YXIgUmVwZWF0VHlwZTtcbihmdW5jdGlvbiAoUmVwZWF0VHlwZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCBpcyBub3QgcmVwZWF0ZWQuXG4gICAgICovXG4gICAgUmVwZWF0VHlwZVtSZXBlYXRUeXBlW1wiTk9cIl0gPSAwXSA9IFwiTk9cIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZmllbGQgaXMgcmVwZWF0ZWQgYW5kIHNob3VsZCBiZSBwYWNrZWQuXG4gICAgICogSW52YWxpZCBmb3IgYGJ5dGVzYCBhbmQgYHN0cmluZ2AsIHRoZXkgY2Fubm90IGJlIHBhY2tlZC5cbiAgICAgKi9cbiAgICBSZXBlYXRUeXBlW1JlcGVhdFR5cGVbXCJQQUNLRURcIl0gPSAxXSA9IFwiUEFDS0VEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGZpZWxkIGlzIHJlcGVhdGVkIGJ1dCBzaG91bGQgbm90IGJlIHBhY2tlZC5cbiAgICAgKiBUaGUgb25seSB2YWxpZCByZXBlYXQgdHlwZSBmb3IgcmVwZWF0ZWQgYGJ5dGVzYCBhbmQgYHN0cmluZ2AuXG4gICAgICovXG4gICAgUmVwZWF0VHlwZVtSZXBlYXRUeXBlW1wiVU5QQUNLRURcIl0gPSAyXSA9IFwiVU5QQUNLRURcIjtcbn0pKFJlcGVhdFR5cGUgfHwgKFJlcGVhdFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBUdXJucyBQYXJ0aWFsRmllbGRJbmZvIGludG8gRmllbGRJbmZvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRmllbGRJbmZvKGZpZWxkKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGZpZWxkLmxvY2FsTmFtZSA9IChfYSA9IGZpZWxkLmxvY2FsTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbG93ZXJDYW1lbENhc2UoZmllbGQubmFtZSk7XG4gICAgZmllbGQuanNvbk5hbWUgPSAoX2IgPSBmaWVsZC5qc29uTmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbG93ZXJDYW1lbENhc2UoZmllbGQubmFtZSk7XG4gICAgZmllbGQucmVwZWF0ID0gKF9jID0gZmllbGQucmVwZWF0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBSZXBlYXRUeXBlLk5PO1xuICAgIGZpZWxkLm9wdCA9IChfZCA9IGZpZWxkLm9wdCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogKGZpZWxkLnJlcGVhdCA/IGZhbHNlIDogZmllbGQub25lb2YgPyBmYWxzZSA6IGZpZWxkLmtpbmQgPT0gXCJtZXNzYWdlXCIpO1xuICAgIHJldHVybiBmaWVsZDtcbn1cbi8qKlxuICogUmVhZCBjdXN0b20gZmllbGQgb3B0aW9ucyBmcm9tIGEgZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCB1c2UgcmVhZEZpZWxkT3B0aW9uKClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRGaWVsZE9wdGlvbnMobWVzc2FnZVR5cGUsIGZpZWxkTmFtZSwgZXh0ZW5zaW9uTmFtZSwgZXh0ZW5zaW9uVHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBvcHRpb25zID0gKF9hID0gbWVzc2FnZVR5cGUuZmllbGRzLmZpbmQoKG0sIGkpID0+IG0ubG9jYWxOYW1lID09IGZpZWxkTmFtZSB8fCBpID09IGZpZWxkTmFtZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpb25zO1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnNbZXh0ZW5zaW9uTmFtZV0gPyBleHRlbnNpb25UeXBlLmZyb21Kc29uKG9wdGlvbnNbZXh0ZW5zaW9uTmFtZV0pIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRGaWVsZE9wdGlvbihtZXNzYWdlVHlwZSwgZmllbGROYW1lLCBleHRlbnNpb25OYW1lLCBleHRlbnNpb25UeXBlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG9wdGlvbnMgPSAoX2EgPSBtZXNzYWdlVHlwZS5maWVsZHMuZmluZCgobSwgaSkgPT4gbS5sb2NhbE5hbWUgPT0gZmllbGROYW1lIHx8IGkgPT0gZmllbGROYW1lKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGlvbnM7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvblZhbCA9IG9wdGlvbnNbZXh0ZW5zaW9uTmFtZV07XG4gICAgaWYgKG9wdGlvblZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25WYWw7XG4gICAgfVxuICAgIHJldHVybiBleHRlbnNpb25UeXBlID8gZXh0ZW5zaW9uVHlwZS5mcm9tSnNvbihvcHRpb25WYWwpIDogb3B0aW9uVmFsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRNZXNzYWdlT3B0aW9uKG1lc3NhZ2VUeXBlLCBleHRlbnNpb25OYW1lLCBleHRlbnNpb25UeXBlKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lc3NhZ2VUeXBlLm9wdGlvbnM7XG4gICAgY29uc3Qgb3B0aW9uVmFsID0gb3B0aW9uc1tleHRlbnNpb25OYW1lXTtcbiAgICBpZiAob3B0aW9uVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvblZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuc2lvblR5cGUgPyBleHRlbnNpb25UeXBlLmZyb21Kc29uKG9wdGlvblZhbCkgOiBvcHRpb25WYWw7XG59XG4iLCJpbXBvcnQgeyBpc0pzb25PYmplY3QsIHR5cGVvZkpzb25WYWx1ZSB9IGZyb20gXCIuL2pzb24tdHlwaW5nc1wiO1xuaW1wb3J0IHsgYmFzZTY0ZGVjb2RlIH0gZnJvbSBcIi4vYmFzZTY0XCI7XG5pbXBvcnQgeyBMb25nVHlwZSwgU2NhbGFyVHlwZSB9IGZyb20gXCIuL3JlZmxlY3Rpb24taW5mb1wiO1xuaW1wb3J0IHsgUGJMb25nLCBQYlVMb25nIH0gZnJvbSBcIi4vcGItbG9uZ1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRGbG9hdDMyLCBhc3NlcnRJbnQzMiwgYXNzZXJ0VUludDMyIH0gZnJvbSBcIi4vYXNzZXJ0XCI7XG5pbXBvcnQgeyByZWZsZWN0aW9uTG9uZ0NvbnZlcnQgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWxvbmctY29udmVydFwiO1xuLyoqXG4gKiBSZWFkcyBwcm90bzMgbWVzc2FnZXMgaW4gY2Fub25pY2FsIEpTT04gZm9ybWF0IHVzaW5nIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24uXG4gKlxuICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL3Byb3RvMyNqc29uXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWZsZWN0aW9uSnNvblJlYWRlciB7XG4gICAgY29uc3RydWN0b3IoaW5mbykge1xuICAgICAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgIH1cbiAgICBwcmVwYXJlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmZNYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5mTWFwID0ge307XG4gICAgICAgICAgICBjb25zdCBmaWVsZHNJbnB1dCA9IChfYSA9IHRoaXMuaW5mby5maWVsZHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHNJbnB1dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZk1hcFtmaWVsZC5uYW1lXSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgIHRoaXMuZk1hcFtmaWVsZC5qc29uTmFtZV0gPSBmaWVsZDtcbiAgICAgICAgICAgICAgICB0aGlzLmZNYXBbZmllbGQubG9jYWxOYW1lXSA9IGZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENhbm5vdCBwYXJzZSBKU09OIDx0eXBlIG9mIGpzb25WYWx1ZT4gZm9yIDx0eXBlIG5hbWU+IzxmaWVsZE5hbWU+LlxuICAgIGFzc2VydChjb25kaXRpb24sIGZpZWxkTmFtZSwganNvblZhbHVlKSB7XG4gICAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgICAgICBsZXQgd2hhdCA9IHR5cGVvZkpzb25WYWx1ZShqc29uVmFsdWUpO1xuICAgICAgICAgICAgaWYgKHdoYXQgPT0gXCJudW1iZXJcIiB8fCB3aGF0ID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgICAgIHdoYXQgPSBqc29uVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHBhcnNlIEpTT04gJHt3aGF0fSBmb3IgJHt0aGlzLmluZm8udHlwZU5hbWV9IyR7ZmllbGROYW1lfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgbWVzc2FnZSBmcm9tIGNhbm9uaWNhbCBKU09OIGZvcm1hdCBpbnRvIHRoZSB0YXJnZXQgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIFJlcGVhdGVkIGZpZWxkcyBhcmUgYXBwZW5kZWQuIE1hcCBlbnRyaWVzIGFyZSBhZGRlZCwgb3ZlcndyaXRpbmdcbiAgICAgKiBleGlzdGluZyBrZXlzLlxuICAgICAqXG4gICAgICogSWYgYSBtZXNzYWdlIGZpZWxkIGlzIGFscmVhZHkgcHJlc2VudCwgaXQgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGVcbiAgICAgKiBuZXcgZGF0YS5cbiAgICAgKi9cbiAgICByZWFkKGlucHV0LCBtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZSgpO1xuICAgICAgICBjb25zdCBvbmVvZnNIYW5kbGVkID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2pzb25LZXksIGpzb25WYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZk1hcFtqc29uS2V5XTtcbiAgICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCB1bmtub3duIGZpZWxkIHdoaWxlIHJlYWRpbmcgJHt0aGlzLmluZm8udHlwZU5hbWV9IGZyb20gSlNPTiBmb3JtYXQuIEpTT04ga2V5OiAke2pzb25LZXl9YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gICAgICAgICAgICAvLyBoYW5kbGUgb25lb2YgQURUXG4gICAgICAgICAgICBsZXQgdGFyZ2V0OyAvLyB0aGlzIHdpbGwgYmUgdGhlIHRhcmdldCBmb3IgdGhlIGZpZWxkIHZhbHVlLCB3aGV0aGVyIGl0IGlzIG1lbWJlciBvZiBhIG9uZW9mIG9yIG5vdFxuICAgICAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCAmJiAoZmllbGQua2luZCAhPT0gJ2VudW0nIHx8IGZpZWxkLlQoKVswXSAhPT0gJ2dvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWUnKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc2luY2UganNvbiBvYmplY3RzIGFyZSB1bm9yZGVyZWQgYnkgc3BlY2lmaWNhdGlvbiwgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHRha2UgdGhlIGxhc3Qgb2YgbXVsdGlwbGUgb25lb2ZzXG4gICAgICAgICAgICAgICAgaWYgKG9uZW9mc0hhbmRsZWQuaW5jbHVkZXMoZmllbGQub25lb2YpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpcGxlIG1lbWJlcnMgb2YgdGhlIG9uZW9mIGdyb3VwIFwiJHtmaWVsZC5vbmVvZn1cIiBvZiAke3RoaXMuaW5mby50eXBlTmFtZX0gYXJlIHByZXNlbnQgaW4gSlNPTi5gKTtcbiAgICAgICAgICAgICAgICBvbmVvZnNIYW5kbGVkLnB1c2goZmllbGQub25lb2YpO1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IG1lc3NhZ2VbZmllbGQub25lb2ZdID0ge1xuICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6IGxvY2FsTmFtZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UgaGF2ZSBoYW5kbGVkIG9uZW9mIGFib3ZlLiB3ZSBqdXN0IGhhdmUgcmVhZCB0aGUgdmFsdWUgaW50byBgdGFyZ2V0YC5cbiAgICAgICAgICAgIGlmIChmaWVsZC5raW5kID09ICdtYXAnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaW5wdXRcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2VydChpc0pzb25PYmplY3QoanNvblZhbHVlKSwgZmllbGQubmFtZSwganNvblZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBvdXIgdGFyZ2V0IHRvIHB1dCBtYXAgZW50cmllcyBpbnRvXG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRPYmogPSB0YXJnZXRbbG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICAvLyByZWFkIGVudHJpZXNcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtqc29uT2JqS2V5LCBqc29uT2JqVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGpzb25WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc3NlcnQoanNvbk9ialZhbHVlICE9PSBudWxsLCBmaWVsZC5uYW1lICsgXCIgbWFwIHZhbHVlXCIsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZWFkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWw7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGZpZWxkLlYuVCgpLmludGVybmFsSnNvblJlYWQoanNvbk9ialZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5lbnVtKGZpZWxkLlYuVCgpLCBqc29uT2JqVmFsdWUsIGZpZWxkLm5hbWUsIG9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHRoaXMuc2NhbGFyKGpzb25PYmpWYWx1ZSwgZmllbGQuVi5ULCBmaWVsZC5WLkwsIGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0KHZhbCAhPT0gdW5kZWZpbmVkLCBmaWVsZC5uYW1lICsgXCIgbWFwIHZhbHVlXCIsIGpzb25PYmpWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWQga2V5XG4gICAgICAgICAgICAgICAgICAgIGxldCBrZXkgPSBqc29uT2JqS2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuSyA9PSBTY2FsYXJUeXBlLkJPT0wpXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXkgPT0gXCJ0cnVlXCIgPyB0cnVlIDoga2V5ID09IFwiZmFsc2VcIiA/IGZhbHNlIDoga2V5O1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnNjYWxhcihrZXksIGZpZWxkLkssIExvbmdUeXBlLlNUUklORywgZmllbGQubmFtZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRPYmpba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5yZXBlYXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpbnB1dFxuICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0KEFycmF5LmlzQXJyYXkoanNvblZhbHVlKSwgZmllbGQubmFtZSwganNvblZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBvdXIgdGFyZ2V0IHRvIHB1dCBhcnJheSBlbnRyaWVzIGludG9cbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZEFyciA9IHRhcmdldFtsb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgIC8vIHJlYWQgYXJyYXkgZW50cmllc1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QganNvbkl0ZW0gb2YganNvblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0KGpzb25JdGVtICE9PSBudWxsLCBmaWVsZC5uYW1lLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGZpZWxkLlQoKS5pbnRlcm5hbEpzb25SZWFkKGpzb25JdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5lbnVtKGZpZWxkLlQoKSwganNvbkl0ZW0sIGZpZWxkLm5hbWUsIG9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHRoaXMuc2NhbGFyKGpzb25JdGVtLCBmaWVsZC5ULCBmaWVsZC5MLCBmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFzc2VydCh2YWwgIT09IHVuZGVmaW5lZCwgZmllbGQubmFtZSwganNvblZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRBcnIucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCAmJiBmaWVsZC5UKCkudHlwZU5hbWUgIT0gJ2dvb2dsZS5wcm90b2J1Zi5WYWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFzc2VydChmaWVsZC5vbmVvZiA9PT0gdW5kZWZpbmVkLCBmaWVsZC5uYW1lICsgXCIgKG9uZW9mIG1lbWJlcilcIiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGZpZWxkLlQoKS5pbnRlcm5hbEpzb25SZWFkKGpzb25WYWx1ZSwgb3B0aW9ucywgdGFyZ2V0W2xvY2FsTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHRoaXMuZW51bShmaWVsZC5UKCksIGpzb25WYWx1ZSwgZmllbGQubmFtZSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gdGhpcy5zY2FsYXIoanNvblZhbHVlLCBmaWVsZC5ULCBmaWVsZC5MLCBmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGBmYWxzZWAgZm9yIHVucmVjb2duaXplZCBzdHJpbmcgcmVwcmVzZW50YXRpb25zLlxuICAgICAqXG4gICAgICogZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZSBhY2NlcHRzIG9ubHkgSlNPTiBgbnVsbGAgKG9yIHRoZSBvbGQgYFwiTlVMTF9WQUxVRVwiYCkuXG4gICAgICovXG4gICAgZW51bSh0eXBlLCBqc29uLCBmaWVsZE5hbWUsIGlnbm9yZVVua25vd25GaWVsZHMpIHtcbiAgICAgICAgaWYgKHR5cGVbMF0gPT0gJ2dvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWUnKVxuICAgICAgICAgICAgYXNzZXJ0KGpzb24gPT09IG51bGwgfHwganNvbiA9PT0gXCJOVUxMX1ZBTFVFXCIsIGBVbmFibGUgdG8gcGFyc2UgZmllbGQgJHt0aGlzLmluZm8udHlwZU5hbWV9IyR7ZmllbGROYW1lfSwgZW51bSAke3R5cGVbMF19IG9ubHkgYWNjZXB0cyBudWxsLmApO1xuICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgIC8vIHdlIHJlcXVpcmUgMCB0byBiZSBkZWZhdWx0IHZhbHVlIGZvciBhbGwgZW51bXNcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBqc29uKSB7XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgYXNzZXJ0KE51bWJlci5pc0ludGVnZXIoanNvbiksIGBVbmFibGUgdG8gcGFyc2UgZmllbGQgJHt0aGlzLmluZm8udHlwZU5hbWV9IyR7ZmllbGROYW1lfSwgZW51bSBjYW4gb25seSBiZSBpbnRlZ3JhbCBudW1iZXIsIGdvdCAke2pzb259LmApO1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGxldCBsb2NhbEVudW1OYW1lID0ganNvbjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZVsyXSAmJiBqc29uLnN1YnN0cmluZygwLCB0eXBlWzJdLmxlbmd0aCkgPT09IHR5cGVbMl0pXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb2t1cCB3aXRob3V0IHRoZSBzaGFyZWQgcHJlZml4XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRW51bU5hbWUgPSBqc29uLnN1YnN0cmluZyh0eXBlWzJdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGV0IGVudW1OdW1iZXIgPSB0eXBlWzFdW2xvY2FsRW51bU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW51bU51bWJlciA9PT0gJ3VuZGVmaW5lZCcgJiYgaWdub3JlVW5rbm93bkZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgZW51bU51bWJlciA9PSBcIm51bWJlclwiLCBgVW5hYmxlIHRvIHBhcnNlIGZpZWxkICR7dGhpcy5pbmZvLnR5cGVOYW1lfSMke2ZpZWxkTmFtZX0sIGVudW0gJHt0eXBlWzBdfSBoYXMgbm8gdmFsdWUgZm9yIFwiJHtqc29ufVwiLmApO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnVtTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYFVuYWJsZSB0byBwYXJzZSBmaWVsZCAke3RoaXMuaW5mby50eXBlTmFtZX0jJHtmaWVsZE5hbWV9LCBjYW5ub3QgcGFyc2UgZW51bSB2YWx1ZSBmcm9tICR7dHlwZW9mIGpzb259XCIuYCk7XG4gICAgfVxuICAgIHNjYWxhcihqc29uLCB0eXBlLCBsb25nVHlwZSwgZmllbGROYW1lKSB7XG4gICAgICAgIGxldCBlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gZmxvYXQsIGRvdWJsZTogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgbnVtYmVyIG9yIG9uZSBvZiB0aGUgc3BlY2lhbCBzdHJpbmcgdmFsdWVzIFwiTmFOXCIsIFwiSW5maW5pdHlcIiwgYW5kIFwiLUluZmluaXR5XCIuXG4gICAgICAgICAgICAgICAgLy8gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuIEV4cG9uZW50IG5vdGF0aW9uIGlzIGFsc28gYWNjZXB0ZWQuXG4gICAgICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC4wO1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbiA9PT0gXCJOYU5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTmFOO1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbiA9PT0gXCJJbmZpbml0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24gPT09IFwiLUluZmluaXR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbiA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IFwiZW1wdHkgc3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gPT0gXCJzdHJpbmdcIiAmJiBqc29uLnRyaW0oKS5sZW5ndGggIT09IGpzb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gXCJleHRyYSB3aGl0ZXNwYWNlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YganNvbiAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgZmxvYXQgPSBOdW1iZXIoanNvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4oZmxvYXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gXCJub3QgYSBudW1iZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGZsb2F0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5maW5pdHkgYW5kIC1pbmZpbml0eSBhcmUgaGFuZGxlZCBieSBzdHJpbmcgcmVwcmVzZW50YXRpb24gYWJvdmUsIHNvIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBcInRvbyBsYXJnZSBvciBzbWFsbFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5GTE9BVClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEZsb2F0MzIoZmxvYXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvYXQ7XG4gICAgICAgICAgICAgICAgLy8gaW50MzIsIGZpeGVkMzIsIHVpbnQzMjogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBudW1iZXIuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgICAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW50MzI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgaW50MzIgPSBqc29uO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChqc29uID09PSBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IFwiZW1wdHkgc3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBqc29uID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uLnRyaW0oKS5sZW5ndGggIT09IGpzb24ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBcImV4dHJhIHdoaXRlc3BhY2VcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQzMiA9IE51bWJlcihqc29uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW50MzIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBTY2FsYXJUeXBlLlVJTlQzMilcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydFVJbnQzMihpbnQzMik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEludDMyKGludDMyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludDMyO1xuICAgICAgICAgICAgICAgIC8vIGludDY0LCBmaXhlZDY0LCB1aW50NjQ6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgc3RyaW5nLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3Rpb25Mb25nQ29udmVydChQYkxvbmcuWkVSTywgbG9uZ1R5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIiAmJiB0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWZsZWN0aW9uTG9uZ0NvbnZlcnQoUGJMb25nLmZyb20oanNvbiksIGxvbmdUeXBlKTtcbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWZsZWN0aW9uTG9uZ0NvbnZlcnQoUGJVTG9uZy5aRVJPLCBsb25nVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcIm51bWJlclwiICYmIHR5cGVvZiBqc29uICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3Rpb25Mb25nQ29udmVydChQYlVMb25nLmZyb20oanNvbiksIGxvbmdUeXBlKTtcbiAgICAgICAgICAgICAgICAvLyBib29sOlxuICAgICAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmc6XG4gICAgICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gXCJleHRyYSB3aGl0ZXNwYWNlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGpzb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gXCJpbnZhbGlkIFVURjhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICAgICAgICAgIC8vIGJ5dGVzOiBKU09OIHZhbHVlIHdpbGwgYmUgdGhlIGRhdGEgZW5jb2RlZCBhcyBhIHN0cmluZyB1c2luZyBzdGFuZGFyZCBiYXNlNjQgZW5jb2Rpbmcgd2l0aCBwYWRkaW5ncy5cbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgc3RhbmRhcmQgb3IgVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nIHdpdGgvd2l0aG91dCBwYWRkaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbCB8fCBqc29uID09PSBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNjRkZWNvZGUoanNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFzc2VydChmYWxzZSwgZmllbGROYW1lICsgKGUgPyBcIiAtIFwiICsgZSA6IFwiXCIpLCBqc29uKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBiYXNlNjRlbmNvZGUgfSBmcm9tIFwiLi9iYXNlNjRcIjtcbmltcG9ydCB7IFBiTG9uZywgUGJVTG9uZyB9IGZyb20gXCIuL3BiLWxvbmdcIjtcbmltcG9ydCB7IFNjYWxhclR5cGUgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWluZm9cIjtcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0RmxvYXQzMiwgYXNzZXJ0SW50MzIsIGFzc2VydFVJbnQzMiB9IGZyb20gXCIuL2Fzc2VydFwiO1xuLyoqXG4gKiBXcml0ZXMgcHJvdG8zIG1lc3NhZ2VzIGluIGNhbm9uaWNhbCBKU09OIGZvcm1hdCB1c2luZyByZWZsZWN0aW9uXG4gKiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvcHJvdG8zI2pzb25cbiAqL1xuZXhwb3J0IGNsYXNzIFJlZmxlY3Rpb25Kc29uV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpbmZvKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSAoX2EgPSBpbmZvLmZpZWxkcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBtZXNzYWdlIHRvIGEgSlNPTiBvYmplY3QsIGJhc2VkIG9uIHRoZSBmaWVsZCBkZXNjcmlwdG9ycy5cbiAgICAgKi9cbiAgICB3cml0ZShtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSB7fSwgc291cmNlID0gbWVzc2FnZTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgLy8gZmllbGQgaXMgbm90IHBhcnQgb2YgYSBvbmVvZiwgc2ltcGx5IHdyaXRlIGFzIGlzXG4gICAgICAgICAgICBpZiAoIWZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICAgICAgbGV0IGpzb25WYWx1ZSA9IHRoaXMuZmllbGQoZmllbGQsIHNvdXJjZVtmaWVsZC5sb2NhbE5hbWVdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGpzb25bb3B0aW9ucy51c2VQcm90b0ZpZWxkTmFtZSA/IGZpZWxkLm5hbWUgOiBmaWVsZC5qc29uTmFtZV0gPSBqc29uVmFsdWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmaWVsZCBpcyBwYXJ0IG9mIGEgb25lb2ZcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gc291cmNlW2ZpZWxkLm9uZW9mXTtcbiAgICAgICAgICAgIGlmIChncm91cC5vbmVvZktpbmQgIT09IGZpZWxkLmxvY2FsTmFtZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gbm90IHNlbGVjdGVkLCBza2lwXG4gICAgICAgICAgICBjb25zdCBvcHQgPSBmaWVsZC5raW5kID09ICdzY2FsYXInIHx8IGZpZWxkLmtpbmQgPT0gJ2VudW0nXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGVtaXREZWZhdWx0VmFsdWVzOiB0cnVlIH0pIDogb3B0aW9ucztcbiAgICAgICAgICAgIGxldCBqc29uVmFsdWUgPSB0aGlzLmZpZWxkKGZpZWxkLCBncm91cFtmaWVsZC5sb2NhbE5hbWVdLCBvcHQpO1xuICAgICAgICAgICAgYXNzZXJ0KGpzb25WYWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGpzb25bb3B0aW9ucy51c2VQcm90b0ZpZWxkTmFtZSA/IGZpZWxkLm5hbWUgOiBmaWVsZC5qc29uTmFtZV0gPSBqc29uVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIGZpZWxkKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBsZXQganNvblZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZmllbGQua2luZCA9PSAnbWFwJykge1xuICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGpzb25PYmogPSB7fTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeUtleSwgZW50cnlWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzLnNjYWxhcihmaWVsZC5WLlQsIGVudHJ5VmFsdWUsIGZpZWxkLm5hbWUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCh2YWwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gdmFsOyAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBmaWVsZC5WLlQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpcy5tZXNzYWdlKG1lc3NhZ2VUeXBlLCBlbnRyeVZhbHVlLCBmaWVsZC5uYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCh2YWwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gdmFsOyAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW51bUluZm8gPSBmaWVsZC5WLlQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGVudHJ5VmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgZW50cnlWYWx1ZSA9PSAnbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzLmVudW0oZW51bUluZm8sIGVudHJ5VmFsdWUsIGZpZWxkLm5hbWUsIGZhbHNlLCB0cnVlLCBvcHRpb25zLmVudW1Bc0ludGVnZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25PYmpbZW50cnlLZXkudG9TdHJpbmcoKV0gPSB2YWw7IC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzIHx8IE9iamVjdC5rZXlzKGpzb25PYmopLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAganNvblZhbHVlID0ganNvbk9iajtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZC5yZXBlYXQpIHtcbiAgICAgICAgICAgIGFzc2VydChBcnJheS5pc0FycmF5KHZhbHVlKSk7XG4gICAgICAgICAgICBjb25zdCBqc29uQXJyID0gW107XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuc2NhbGFyKGZpZWxkLlQsIHZhbHVlW2ldLCBmaWVsZC5uYW1lLCBmaWVsZC5vcHQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25BcnIucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudW1JbmZvID0gZmllbGQuVCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQodmFsdWVbaV0gPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWVbaV0gPT0gJ251bWJlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpcy5lbnVtKGVudW1JbmZvLCB2YWx1ZVtpXSwgZmllbGQubmFtZSwgZmllbGQub3B0LCB0cnVlLCBvcHRpb25zLmVudW1Bc0ludGVnZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25BcnIucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gZmllbGQuVCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzLm1lc3NhZ2UobWVzc2FnZVR5cGUsIHZhbHVlW2ldLCBmaWVsZC5uYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCh2YWwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uQXJyLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCBjb252ZXJ0ZWQgYXJyYXkgdG8ganNvbiBvdXRwdXRcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzIHx8IGpzb25BcnIubGVuZ3RoID4gMCB8fCBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzKVxuICAgICAgICAgICAgICAgIGpzb25WYWx1ZSA9IGpzb25BcnI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgIGpzb25WYWx1ZSA9IHRoaXMuc2NhbGFyKGZpZWxkLlQsIHZhbHVlLCBmaWVsZC5uYW1lLCBmaWVsZC5vcHQsIG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICBqc29uVmFsdWUgPSB0aGlzLmVudW0oZmllbGQuVCgpLCB2YWx1ZSwgZmllbGQubmFtZSwgZmllbGQub3B0LCBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzLCBvcHRpb25zLmVudW1Bc0ludGVnZXIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICBqc29uVmFsdWUgPSB0aGlzLm1lc3NhZ2UoZmllbGQuVCgpLCB2YWx1ZSwgZmllbGQubmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYG51bGxgIGFzIHRoZSBkZWZhdWx0IGZvciBnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlLlxuICAgICAqL1xuICAgIGVudW0odHlwZSwgdmFsdWUsIGZpZWxkTmFtZSwgb3B0aW9uYWwsIGVtaXREZWZhdWx0VmFsdWVzLCBlbnVtQXNJbnRlZ2VyKSB7XG4gICAgICAgIGlmICh0eXBlWzBdID09ICdnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlJylcbiAgICAgICAgICAgIHJldHVybiAhZW1pdERlZmF1bHRWYWx1ZXMgJiYgIW9wdGlvbmFsID8gdW5kZWZpbmVkIDogbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydChvcHRpb25hbCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiAhZW1pdERlZmF1bHRWYWx1ZXMgJiYgIW9wdGlvbmFsKVxuICAgICAgICAgICAgLy8gd2UgcmVxdWlyZSAwIHRvIGJlIGRlZmF1bHQgdmFsdWUgZm9yIGFsbCBlbnVtc1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyk7XG4gICAgICAgIGFzc2VydChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSk7XG4gICAgICAgIGlmIChlbnVtQXNJbnRlZ2VyIHx8ICF0eXBlWzFdLmhhc093blByb3BlcnR5KHZhbHVlKSlcbiAgICAgICAgICAgIC8vIGlmIHdlIGRvbid0IG5vdyB0aGUgZW51bSB2YWx1ZSwganVzdCByZXR1cm4gdGhlIG51bWJlclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAodHlwZVsyXSlcbiAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIGRyb3BwZWQgcHJlZml4XG4gICAgICAgICAgICByZXR1cm4gdHlwZVsyXSArIHR5cGVbMV1bdmFsdWVdO1xuICAgICAgICByZXR1cm4gdHlwZVsxXVt2YWx1ZV07XG4gICAgfVxuICAgIG1lc3NhZ2UodHlwZSwgdmFsdWUsIGZpZWxkTmFtZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzID8gbnVsbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHR5cGUuaW50ZXJuYWxKc29uV3JpdGUodmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzY2FsYXIodHlwZSwgdmFsdWUsIGZpZWxkTmFtZSwgb3B0aW9uYWwsIGVtaXREZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnQob3B0aW9uYWwpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZCA9IGVtaXREZWZhdWx0VmFsdWVzIHx8IG9wdGlvbmFsO1xuICAgICAgICAvLyBub2luc3BlY3Rpb24gRmFsbFRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgLy8gaW50MzIsIGZpeGVkMzIsIHVpbnQzMjogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBudW1iZXIuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlZCA/IDAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlZCA/IDAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VUludDMyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAvLyBmbG9hdCwgZG91YmxlOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBzcGVjaWFsIHN0cmluZyB2YWx1ZXMgXCJOYU5cIiwgXCJJbmZpbml0eVwiLCBhbmQgXCItSW5maW5pdHlcIi5cbiAgICAgICAgICAgIC8vIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLiBFeHBvbmVudCBub3RhdGlvbiBpcyBhbHNvIGFjY2VwdGVkLlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgICAgICAgICAgIGFzc2VydEZsb2F0MzIodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlZCA/IDAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTih2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnTmFOJztcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdJbmZpbml0eSc7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnLUluZmluaXR5JztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAvLyBzdHJpbmc6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVkID8gJycgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgLy8gYm9vbDpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlZCA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gJ2Jvb2xlYW4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAvLyBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIHN0cmluZy4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09ICdiaWdpbnQnKTtcbiAgICAgICAgICAgICAgICBsZXQgdWxvbmcgPSBQYlVMb25nLmZyb20odmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh1bG9uZy5pc1plcm8oKSAmJiAhZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVsb25nLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIHN0cmluZy4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PSAnYmlnaW50Jyk7XG4gICAgICAgICAgICAgICAgbGV0IGxvbmcgPSBQYkxvbmcuZnJvbSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvbmcuaXNaZXJvKCkgJiYgIWVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb25nLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBieXRlczogSlNPTiB2YWx1ZSB3aWxsIGJlIHRoZSBkYXRhIGVuY29kZWQgYXMgYSBzdHJpbmcgdXNpbmcgc3RhbmRhcmQgYmFzZTY0IGVuY29kaW5nIHdpdGggcGFkZGluZ3MuXG4gICAgICAgICAgICAvLyBFaXRoZXIgc3RhbmRhcmQgb3IgVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nIHdpdGgvd2l0aG91dCBwYWRkaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSk7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWQgPyBcIlwiIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNjRlbmNvZGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTG9uZ1R5cGUgfSBmcm9tIFwiLi9yZWZsZWN0aW9uLWluZm9cIjtcbi8qKlxuICogVXRpbGl0eSBtZXRob2QgdG8gY29udmVydCBhIFBiTG9uZyBvciBQYlVsb25nIHRvIGEgSmF2YVNjcmlwdFxuICogcmVwcmVzZW50YXRpb24gZHVyaW5nIHJ1bnRpbWUuXG4gKlxuICogV29ya3Mgd2l0aCBnZW5lcmF0ZWQgZmllbGQgaW5mb3JtYXRpb24sIGB1bmRlZmluZWRgIGlzIGVxdWl2YWxlbnRcbiAqIHRvIGBTVFJJTkdgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVmbGVjdGlvbkxvbmdDb252ZXJ0KGxvbmcsIHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBMb25nVHlwZS5CSUdJTlQ6XG4gICAgICAgICAgICByZXR1cm4gbG9uZy50b0JpZ0ludCgpO1xuICAgICAgICBjYXNlIExvbmdUeXBlLk5VTUJFUjpcbiAgICAgICAgICAgIHJldHVybiBsb25nLnRvTnVtYmVyKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIC8vIGNhc2UgTG9uZ1R5cGUuU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIGxvbmcudG9TdHJpbmcoKTtcbiAgICB9XG59XG4iLCIvKipcbiAqIENvcHkgcGFydGlhbCBkYXRhIGludG8gdGhlIHRhcmdldCBtZXNzYWdlLlxuICpcbiAqIElmIGEgc2luZ3VsYXIgc2NhbGFyIG9yIGVudW0gZmllbGQgaXMgcHJlc2VudCBpbiB0aGUgc291cmNlLCBpdFxuICogcmVwbGFjZXMgdGhlIGZpZWxkIGluIHRoZSB0YXJnZXQuXG4gKlxuICogSWYgYSBzaW5ndWxhciBtZXNzYWdlIGZpZWxkIGlzIHByZXNlbnQgaW4gdGhlIHNvdXJjZSwgaXQgaXMgbWVyZ2VkXG4gKiB3aXRoIHRoZSB0YXJnZXQgZmllbGQgYnkgY2FsbGluZyBtZXJnZVBhcnRpYWwoKSBvZiB0aGUgcmVzcG9uc2libGVcbiAqIG1lc3NhZ2UgdHlwZS5cbiAqXG4gKiBJZiBhIHJlcGVhdGVkIGZpZWxkIGlzIHByZXNlbnQgaW4gdGhlIHNvdXJjZSwgaXRzIHZhbHVlcyByZXBsYWNlXG4gKiBhbGwgdmFsdWVzIGluIHRoZSB0YXJnZXQgYXJyYXksIHJlbW92aW5nIGV4dHJhbmVvdXMgdmFsdWVzLlxuICogUmVwZWF0ZWQgbWVzc2FnZSBmaWVsZHMgYXJlIGNvcGllZCwgbm90IG1lcmdlZC5cbiAqXG4gKiBJZiBhIG1hcCBmaWVsZCBpcyBwcmVzZW50IGluIHRoZSBzb3VyY2UsIGVudHJpZXMgYXJlIGFkZGVkIHRvIHRoZVxuICogdGFyZ2V0IG1hcCwgcmVwbGFjaW5nIGVudHJpZXMgd2l0aCB0aGUgc2FtZSBrZXkuIEVudHJpZXMgdGhhdCBvbmx5XG4gKiBleGlzdCBpbiB0aGUgdGFyZ2V0IHJlbWFpbi4gRW50cmllcyB3aXRoIG1lc3NhZ2UgdmFsdWVzIGFyZSBjb3BpZWQsXG4gKiBub3QgbWVyZ2VkLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGRpZmZlcnMgZnJvbSBwcm90b2J1ZiBtZXJnZSBzZW1hbnRpY3MsXG4gKiB3aGljaCBhcHBlbmRzIHJlcGVhdGVkIGZpZWxkcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwoaW5mbywgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBsZXQgZmllbGRWYWx1ZSwgLy8gdGhlIGZpZWxkIHZhbHVlIHdlIGFyZSB3b3JraW5nIHdpdGhcbiAgICBpbnB1dCA9IHNvdXJjZSwgb3V0cHV0OyAvLyB3aGVyZSB3ZSB3YW50IG91ciBmaWVsZCB2YWx1ZSB0byBnb1xuICAgIGZvciAobGV0IGZpZWxkIG9mIGluZm8uZmllbGRzKSB7XG4gICAgICAgIGxldCBuYW1lID0gZmllbGQubG9jYWxOYW1lO1xuICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gaW5wdXRbZmllbGQub25lb2ZdOyAvLyB0aGlzIGlzIHRoZSBvbmVvZmBzIGdyb3VwIGluIHRoZSBzb3VyY2VcbiAgICAgICAgICAgIGlmICgoZ3JvdXAgPT09IG51bGwgfHwgZ3JvdXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyb3VwLm9uZW9mS2luZCkgPT0gdW5kZWZpbmVkKSB7IC8vIHRoZSB1c2VyIGlzIGZyZWUgdG8gb21pdFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyB3ZSBza2lwIHRoaXMgZmllbGQsIGFuZCBhbGwgb3RoZXIgbWVtYmVycyB0b29cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBncm91cFtuYW1lXTsgLy8gb3VyIHZhbHVlIGNvbWVzIGZyb20gdGhlIHRoZSBvbmVvZiBncm91cCBvZiB0aGUgc291cmNlXG4gICAgICAgICAgICBvdXRwdXQgPSB0YXJnZXRbZmllbGQub25lb2ZdOyAvLyBhbmQgb3VyIG91dHB1dCBpcyB0aGUgb25lb2YgZ3JvdXAgb2YgdGhlIHRhcmdldFxuICAgICAgICAgICAgb3V0cHV0Lm9uZW9mS2luZCA9IGdyb3VwLm9uZW9mS2luZDsgLy8gYWx3YXlzIHVwZGF0ZSBkaXNjcmltaW5hdG9yXG4gICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3V0cHV0W25hbWVdOyAvLyByZW1vdmUgYW55IGV4aXN0aW5nIHZhbHVlXG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIHNraXAgZnVydGhlciB3b3JrIG9uIGZpZWxkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWVsZFZhbHVlID0gaW5wdXRbbmFtZV07IC8vIHdlIGFyZSB1c2luZyB0aGUgc291cmNlIGRpcmVjdGx5XG4gICAgICAgICAgICBvdXRwdXQgPSB0YXJnZXQ7IC8vIHdlIHdhbnQgb3VyIGZpZWxkIHZhbHVlIHRvIGdvIGRpcmVjdGx5IGludG8gdGhlIHRhcmdldFxuICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIHNraXAgZnVydGhlciB3b3JrIG9uIGZpZWxkLCBleGlzdGluZyB2YWx1ZSBpcyB1c2VkIGFzIGlzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkLnJlcGVhdClcbiAgICAgICAgICAgIG91dHB1dFtuYW1lXS5sZW5ndGggPSBmaWVsZFZhbHVlLmxlbmd0aDsgLy8gcmVzaXplIHRhcmdldCBhcnJheSB0byBtYXRjaCBzb3VyY2UgYXJyYXlcbiAgICAgICAgLy8gbm93IHdlIGp1c3Qgd29yayB3aXRoIGBmaWVsZFZhbHVlYCBhbmQgYG91dHB1dGAgdG8gbWVyZ2UgdGhlIHZhbHVlXG4gICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVwZWF0KVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkVmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmFtZV1baV0gPSBmaWVsZFZhbHVlW2ldOyAvLyBub3QgYSByZWZlcmVuY2UgdHlwZVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W25hbWVdID0gZmllbGRWYWx1ZTsgLy8gbm90IGEgcmVmZXJlbmNlIHR5cGVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgbGV0IFQgPSBmaWVsZC5UKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLnJlcGVhdClcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZFZhbHVlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W25hbWVdW2ldID0gVC5jcmVhdGUoZmllbGRWYWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3V0cHV0W25hbWVdID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtuYW1lXSA9IFQuY3JlYXRlKGZpZWxkVmFsdWUpOyAvLyBub3RoaW5nIHRvIG1lcmdlIHdpdGhcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIFQubWVyZ2VQYXJ0aWFsKG91dHB1dFtuYW1lXSwgZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgLy8gTWFwIGFuZCByZXBlYXRlZCBmaWVsZHMgYXJlIHNpbXBseSBvdmVyd3JpdHRlbiwgbm90IGFwcGVuZGVkIG9yIG1lcmdlZFxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3V0cHV0W25hbWVdLCBmaWVsZFZhbHVlKTsgLy8gZWxlbWVudHMgYXJlIG5vdCByZWZlcmVuY2UgdHlwZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFQgPSBmaWVsZC5WLlQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgb2YgT2JqZWN0LmtleXMoZmllbGRWYWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W25hbWVdW2tdID0gVC5jcmVhdGUoZmllbGRWYWx1ZVtrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBMb25nVHlwZSwgU2NhbGFyVHlwZSB9IGZyb20gXCIuL3JlZmxlY3Rpb24taW5mb1wiO1xuaW1wb3J0IHsgcmVmbGVjdGlvbkxvbmdDb252ZXJ0IH0gZnJvbSBcIi4vcmVmbGVjdGlvbi1sb25nLWNvbnZlcnRcIjtcbmltcG9ydCB7IFBiTG9uZywgUGJVTG9uZyB9IGZyb20gXCIuL3BiLWxvbmdcIjtcbi8qKlxuICogQ3JlYXRlcyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgYSBzY2FsYXIgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZmxlY3Rpb25TY2FsYXJEZWZhdWx0KHR5cGUsIGxvbmdUeXBlID0gTG9uZ1R5cGUuU1RSSU5HKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgICAgIHJldHVybiByZWZsZWN0aW9uTG9uZ0NvbnZlcnQoUGJVTG9uZy5aRVJPLCBsb25nVHlwZSk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3Rpb25Mb25nQ29udmVydChQYkxvbmcuWkVSTywgbG9uZ1R5cGUpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICAgICAgICAgIC8vIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgICAgICAgICAvLyBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAgICAgICAgLy8gY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICAgICAgICAvLyBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBMb25nVHlwZSwgU2NhbGFyVHlwZSB9IGZyb20gXCIuL3JlZmxlY3Rpb24taW5mb1wiO1xuaW1wb3J0IHsgaXNPbmVvZkdyb3VwIH0gZnJvbSBcIi4vb25lb2ZcIjtcbi8vIG5vaW5zcGVjdGlvbiBKU01ldGhvZENhbkJlU3RhdGljXG5leHBvcnQgY2xhc3MgUmVmbGVjdGlvblR5cGVDaGVjayB7XG4gICAgY29uc3RydWN0b3IoaW5mbykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZmllbGRzID0gKF9hID0gaW5mby5maWVsZHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgIH1cbiAgICBwcmVwYXJlKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCByZXEgPSBbXSwga25vd24gPSBbXSwgb25lb2ZzID0gW107XG4gICAgICAgIGZvciAobGV0IGZpZWxkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9uZW9mcy5pbmNsdWRlcyhmaWVsZC5vbmVvZikpIHtcbiAgICAgICAgICAgICAgICAgICAgb25lb2ZzLnB1c2goZmllbGQub25lb2YpO1xuICAgICAgICAgICAgICAgICAgICByZXEucHVzaChmaWVsZC5vbmVvZik7XG4gICAgICAgICAgICAgICAgICAgIGtub3duLnB1c2goZmllbGQub25lb2YpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtub3duLnB1c2goZmllbGQubG9jYWxOYW1lKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZC5vcHQgfHwgZmllbGQucmVwZWF0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5wdXNoKGZpZWxkLmxvY2FsTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5yZXBlYXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnB1c2goZmllbGQubG9jYWxOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEucHVzaChmaWVsZC5sb2NhbE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YSA9IHsgcmVxLCBrbm93biwgb25lb2ZzOiBPYmplY3QudmFsdWVzKG9uZW9mcykgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIGFyZ3VtZW50IGEgdmFsaWQgbWVzc2FnZSBhcyBzcGVjaWZpZWQgYnkgdGhlXG4gICAgICogcmVmbGVjdGlvbiBpbmZvcm1hdGlvbj9cbiAgICAgKlxuICAgICAqIENoZWNrcyBhbGwgZmllbGQgdHlwZXMgcmVjdXJzaXZlbHkuIFRoZSBgZGVwdGhgXG4gICAgICogc3BlY2lmaWVzIGhvdyBkZWVwIGludG8gdGhlIHN0cnVjdHVyZSB0aGUgY2hlY2sgd2lsbCBiZS5cbiAgICAgKlxuICAgICAqIFdpdGggYSBkZXB0aCBvZiAwLCBvbmx5IHRoZSBwcmVzZW5jZSBvZiBmaWVsZHNcbiAgICAgKiBpcyBjaGVja2VkLlxuICAgICAqXG4gICAgICogV2l0aCBhIGRlcHRoIG9mIDEgb3IgbW9yZSwgdGhlIGZpZWxkIHR5cGVzIGFyZSBjaGVja2VkLlxuICAgICAqXG4gICAgICogV2l0aCBhIGRlcHRoIG9mIDIgb3IgbW9yZSwgdGhlIG1lbWJlcnMgb2YgbWFwLCByZXBlYXRlZFxuICAgICAqIGFuZCBtZXNzYWdlIGZpZWxkcyBhcmUgY2hlY2tlZC5cbiAgICAgKlxuICAgICAqIE1lc3NhZ2UgZmllbGRzIHdpbGwgYmUgY2hlY2tlZCByZWN1cnNpdmVseSB3aXRoIGRlcHRoIC0gMS5cbiAgICAgKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbWFwIGVudHJpZXMgLyByZXBlYXRlZCB2YWx1ZXMgYmVpbmcgY2hlY2tlZFxuICAgICAqIGlzIDwgZGVwdGguXG4gICAgICovXG4gICAgaXMobWVzc2FnZSwgZGVwdGgsIGFsbG93RXhjZXNzUHJvcGVydGllcyA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChkZXB0aCA8IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwgfHwgbWVzc2FnZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXNzYWdlICE9ICdvYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnByZXBhcmUoKTtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhtZXNzYWdlKSwgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgLy8gaWYgYSByZXF1aXJlZCBmaWVsZCBpcyBtaXNzaW5nIGluIGFyZywgdGhpcyBjYW5ub3QgYmUgYSBUXG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA8IGRhdGEucmVxLmxlbmd0aCB8fCBkYXRhLnJlcS5zb21lKG4gPT4gIWtleXMuaW5jbHVkZXMobikpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWFsbG93RXhjZXNzUHJvcGVydGllcykge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGFyZyBjb250YWlucyBhIGtleSB3ZSBkb250IGtub3csIHRoaXMgaXMgbm90IGEgbGl0ZXJhbCBUXG4gICAgICAgICAgICBpZiAoa2V5cy5zb21lKGsgPT4gIWRhdGEua25vd24uaW5jbHVkZXMoaykpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBcIldpdGggYSBkZXB0aCBvZiAwLCBvbmx5IHRoZSBwcmVzZW5jZSBhbmQgYWJzZW5jZSBvZiBmaWVsZHMgaXMgY2hlY2tlZC5cIlxuICAgICAgICAvLyBcIldpdGggYSBkZXB0aCBvZiAxIG9yIG1vcmUsIHRoZSBmaWVsZCB0eXBlcyBhcmUgY2hlY2tlZC5cIlxuICAgICAgICBpZiAoZGVwdGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBvbmVvZiBncm91cFxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgZGF0YS5vbmVvZnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gbWVzc2FnZVtuYW1lXTtcbiAgICAgICAgICAgIGlmICghaXNPbmVvZkdyb3VwKGdyb3VwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZ3JvdXAub25lb2ZLaW5kID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGRzLmZpbmQoZiA9PiBmLmxvY2FsTmFtZSA9PT0gZ3JvdXAub25lb2ZLaW5kKTtcbiAgICAgICAgICAgIGlmICghZmllbGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSBmb3VuZCBubyBmaWVsZCwgYnV0IGhhdmUgYSBraW5kLCBzb21ldGhpbmcgaXMgd3JvbmdcbiAgICAgICAgICAgIGlmICghdGhpcy5maWVsZChncm91cFtncm91cC5vbmVvZktpbmRdLCBmaWVsZCwgYWxsb3dFeGNlc3NQcm9wZXJ0aWVzLCBkZXB0aCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIHR5cGVzXG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5vbmVvZiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpZWxkKG1lc3NhZ2VbZmllbGQubG9jYWxOYW1lXSwgZmllbGQsIGFsbG93RXhjZXNzUHJvcGVydGllcywgZGVwdGgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZmllbGQoYXJnLCBmaWVsZCwgYWxsb3dFeGNlc3NQcm9wZXJ0aWVzLCBkZXB0aCkge1xuICAgICAgICBsZXQgcmVwZWF0ZWQgPSBmaWVsZC5yZXBlYXQ7XG4gICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkLm9wdDtcbiAgICAgICAgICAgICAgICBpZiAocmVwZWF0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxhcnMoYXJnLCBmaWVsZC5ULCBkZXB0aCwgZmllbGQuTCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGFyKGFyZywgZmllbGQuVCwgZmllbGQuTCk7XG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkLm9wdDtcbiAgICAgICAgICAgICAgICBpZiAocmVwZWF0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxhcnMoYXJnLCBTY2FsYXJUeXBlLklOVDMyLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGFyKGFyZywgU2NhbGFyVHlwZS5JTlQzMik7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGVhdGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcyhhcmcsIGZpZWxkLlQoKSwgYWxsb3dFeGNlc3NQcm9wZXJ0aWVzLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZShhcmcsIGZpZWxkLlQoKSwgYWxsb3dFeGNlc3NQcm9wZXJ0aWVzLCBkZXB0aCk7XG4gICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgIT0gJ29iamVjdCcgfHwgYXJnID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIDwgMilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hcEtleXMoYXJnLCBmaWVsZC5LLCBkZXB0aCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsYXJzKE9iamVjdC52YWx1ZXMoYXJnKSwgZmllbGQuVi5ULCBkZXB0aCwgZmllbGQuVi5MKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxhcnMoT2JqZWN0LnZhbHVlcyhhcmcpLCBTY2FsYXJUeXBlLklOVDMyLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcyhPYmplY3QudmFsdWVzKGFyZyksIGZpZWxkLlYuVCgpLCBhbGxvd0V4Y2Vzc1Byb3BlcnRpZXMsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG1lc3NhZ2UoYXJnLCB0eXBlLCBhbGxvd0V4Y2Vzc1Byb3BlcnRpZXMsIGRlcHRoKSB7XG4gICAgICAgIGlmIChhbGxvd0V4Y2Vzc1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmlzQXNzaWduYWJsZShhcmcsIGRlcHRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZS5pcyhhcmcsIGRlcHRoKTtcbiAgICB9XG4gICAgbWVzc2FnZXMoYXJnLCB0eXBlLCBhbGxvd0V4Y2Vzc1Byb3BlcnRpZXMsIGRlcHRoKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGVwdGggPCAyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChhbGxvd0V4Y2Vzc1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJnLmxlbmd0aCAmJiBpIDwgZGVwdGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuaXNBc3NpZ25hYmxlKGFyZ1tpXSwgZGVwdGggLSAxKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmcubGVuZ3RoICYmIGkgPCBkZXB0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmICghdHlwZS5pcyhhcmdbaV0sIGRlcHRoIC0gMSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2NhbGFyKGFyZywgdHlwZSwgbG9uZ1R5cGUpIHtcbiAgICAgICAgbGV0IGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChsb25nVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExvbmdUeXBlLkJJR0lOVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09IFwiYmlnaW50XCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTG9uZ1R5cGUuTlVNQkVSOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT0gXCJudW1iZXJcIiAmJiAhaXNOYU4oYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09IFwic3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT0gJ2Jvb2xlYW4nO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PSAnc3RyaW5nJztcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnIGluc3RhbmNlb2YgVWludDhBcnJheTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT0gJ251bWJlcicgJiYgIWlzTmFOKGFyZyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgICAgICAgICAgICAgLy8gY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICAgICAgICAgICAgLy8gY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgICAgICAgICAgICAgIC8vIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgICAgICAgICAgLy8gY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09ICdudW1iZXInICYmIE51bWJlci5pc0ludGVnZXIoYXJnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY2FsYXJzKGFyZywgdHlwZSwgZGVwdGgsIGxvbmdUeXBlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGVwdGggPCAyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZy5sZW5ndGggJiYgaSA8IGRlcHRoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNjYWxhcihhcmdbaV0sIHR5cGUsIGxvbmdUeXBlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbWFwS2V5cyhtYXAsIHR5cGUsIGRlcHRoKSB7XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMobWFwKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxhcnMoa2V5cy5zbGljZSgwLCBkZXB0aCkubWFwKGsgPT4gcGFyc2VJbnQoaykpLCB0eXBlLCBkZXB0aCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsYXJzKGtleXMuc2xpY2UoMCwgZGVwdGgpLm1hcChrID0+IGsgPT0gJ3RydWUnID8gdHJ1ZSA6IGsgPT0gJ2ZhbHNlJyA/IGZhbHNlIDogayksIHR5cGUsIGRlcHRoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGFycyhrZXlzLCB0eXBlLCBkZXB0aCwgTG9uZ1R5cGUuU1RSSU5HKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciwgcHJlZmVyLXRlbXBsYXRlICovXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC9bQS1aXS9nXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vXG52YXIgY2FjaGUgPSB7fVxuXG5mdW5jdGlvbiB0b0h5cGhlbkxvd2VyKG1hdGNoKSB7XG4gIHJldHVybiAnLScgKyBtYXRjaC50b0xvd2VyQ2FzZSgpXG59XG5cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShuYW1lKSB7XG4gIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHJldHVybiBjYWNoZVtuYW1lXVxuICB9XG5cbiAgdmFyIGhOYW1lID0gbmFtZS5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sIHRvSHlwaGVuTG93ZXIpXG4gIHJldHVybiAoY2FjaGVbbmFtZV0gPSBtc1BhdHRlcm4udGVzdChoTmFtZSkgPyAnLScgKyBoTmFtZSA6IGhOYW1lKVxufVxuXG5leHBvcnQgZGVmYXVsdCBoeXBoZW5hdGVTdHlsZU5hbWVcbiIsInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0IHZhciBpc0Jyb3dzZXIgPSAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHdpbmRvdykpID09PSBcIm9iamVjdFwiICYmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihkb2N1bWVudCkpID09PSAnb2JqZWN0JyAmJiBkb2N1bWVudC5ub2RlVHlwZSA9PT0gOTtcblxuZXhwb3J0IGRlZmF1bHQgaXNCcm93c2VyO1xuIiwiaW1wb3J0IGh5cGhlbmF0ZSBmcm9tICdoeXBoZW5hdGUtc3R5bGUtbmFtZSc7XG5cbi8qKlxuICogQ29udmVydCBjYW1lbCBjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBkYXNoIHNlcGFyYXRlZC5cbiAqL1xuXG5mdW5jdGlvbiBjb252ZXJ0Q2FzZShzdHlsZSkge1xuICB2YXIgY29udmVydGVkID0ge307XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgIHZhciBrZXkgPSBwcm9wLmluZGV4T2YoJy0tJykgPT09IDAgPyBwcm9wIDogaHlwaGVuYXRlKHByb3ApO1xuICAgIGNvbnZlcnRlZFtrZXldID0gc3R5bGVbcHJvcF07XG4gIH1cblxuICBpZiAoc3R5bGUuZmFsbGJhY2tzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUuZmFsbGJhY2tzKSkgY29udmVydGVkLmZhbGxiYWNrcyA9IHN0eWxlLmZhbGxiYWNrcy5tYXAoY29udmVydENhc2UpO2Vsc2UgY29udmVydGVkLmZhbGxiYWNrcyA9IGNvbnZlcnRDYXNlKHN0eWxlLmZhbGxiYWNrcyk7XG4gIH1cblxuICByZXR1cm4gY29udmVydGVkO1xufVxuLyoqXG4gKiBBbGxvdyBjYW1lbCBjYXNlZCBwcm9wZXJ0eSBuYW1lcyBieSBjb252ZXJ0aW5nIHRoZW0gYmFjayB0byBkYXNoZXJpemVkLlxuICovXG5cblxuZnVuY3Rpb24gY2FtZWxDYXNlKCkge1xuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlKSkge1xuICAgICAgLy8gSGFuZGxlIHJ1bGVzIGxpa2UgQGZvbnQtZmFjZSwgd2hpY2ggY2FuIGhhdmUgbXVsdGlwbGUgc3R5bGVzIGluIGFuIGFycmF5XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3R5bGUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0eWxlW2luZGV4XSA9IGNvbnZlcnRDYXNlKHN0eWxlW2luZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udmVydENhc2Uoc3R5bGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCwgcnVsZSkge1xuICAgIGlmIChwcm9wLmluZGV4T2YoJy0tJykgPT09IDApIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgaHlwaGVuYXRlZFByb3AgPSBoeXBoZW5hdGUocHJvcCk7IC8vIFRoZXJlIHdhcyBubyBjYW1lbCBjYXNlIGluIHBsYWNlXG5cbiAgICBpZiAocHJvcCA9PT0gaHlwaGVuYXRlZFByb3ApIHJldHVybiB2YWx1ZTtcbiAgICBydWxlLnByb3AoaHlwaGVuYXRlZFByb3AsIHZhbHVlKTsgLy8gQ29yZSB3aWxsIGlnbm9yZSB0aGF0IHByb3BlcnR5IHZhbHVlIHdlIHNldCB0aGUgcHJvcGVyIG9uZSBhYm92ZS5cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUsXG4gICAgb25DaGFuZ2VWYWx1ZTogb25DaGFuZ2VWYWx1ZVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjYW1lbENhc2U7XG4iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgeyBSdWxlTGlzdCB9IGZyb20gJ2pzcyc7XG5cbnZhciBhdCA9ICdAZ2xvYmFsJztcbnZhciBhdFByZWZpeCA9ICdAZ2xvYmFsICc7XG5cbnZhciBHbG9iYWxDb250YWluZXJSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR2xvYmFsQ29udGFpbmVyUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdnbG9iYWwnO1xuICAgIHRoaXMuYXQgPSBhdDtcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJ1bGVzID0gbmV3IFJ1bGVMaXN0KF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG5cbiAgICBmb3IgKHZhciBzZWxlY3RvciBpbiBzdHlsZXMpIHtcbiAgICAgIHRoaXMucnVsZXMuYWRkKHNlbGVjdG9yLCBzdHlsZXNbc2VsZWN0b3JdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgcnVsZS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gR2xvYmFsQ29udGFpbmVyUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFJ1bGUgPSBmdW5jdGlvbiBnZXRSdWxlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5nZXQobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgcmVnaXN0ZXIgcnVsZSwgcnVuIHBsdWdpbnMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZFJ1bGUgPSBmdW5jdGlvbiBhZGRSdWxlKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgaWYgKHJ1bGUpIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlIHJ1bGUsIHJ1biBwbHVnaW5zLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXBsYWNlUnVsZSA9IGZ1bmN0aW9uIHJlcGxhY2VSdWxlKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdmFyIG5ld1J1bGUgPSB0aGlzLnJ1bGVzLnJlcGxhY2UobmFtZSwgc3R5bGUsIG9wdGlvbnMpO1xuICAgIGlmIChuZXdSdWxlKSB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShuZXdSdWxlKTtcbiAgICByZXR1cm4gbmV3UnVsZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YocnVsZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmluZGV4T2YocnVsZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLnRvU3RyaW5nKG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBHbG9iYWxDb250YWluZXJSdWxlO1xufSgpO1xuXG52YXIgR2xvYmFsUHJlZml4ZWRSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR2xvYmFsUHJlZml4ZWRSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAnZ2xvYmFsJztcbiAgICB0aGlzLmF0ID0gYXQ7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdmFyIHNlbGVjdG9yID0ga2V5LnN1YnN0cihhdFByZWZpeC5sZW5ndGgpO1xuICAgIHRoaXMucnVsZSA9IG9wdGlvbnMuanNzLmNyZWF0ZVJ1bGUoc2VsZWN0b3IsIHN0eWxlLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgcGFyZW50OiB0aGlzXG4gICAgfSkpO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBHbG9iYWxQcmVmaXhlZFJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90bzIudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZSA/IHRoaXMucnVsZS50b1N0cmluZyhvcHRpb25zKSA6ICcnO1xuICB9O1xuXG4gIHJldHVybiBHbG9iYWxQcmVmaXhlZFJ1bGU7XG59KCk7XG5cbnZhciBzZXBhcmF0b3JSZWdFeHAgPSAvXFxzKixcXHMqL2c7XG5cbmZ1bmN0aW9uIGFkZFNjb3BlKHNlbGVjdG9yLCBzY29wZSkge1xuICB2YXIgcGFydHMgPSBzZWxlY3Rvci5zcGxpdChzZXBhcmF0b3JSZWdFeHApO1xuICB2YXIgc2NvcGVkID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIHNjb3BlZCArPSBzY29wZSArIFwiIFwiICsgcGFydHNbaV0udHJpbSgpO1xuICAgIGlmIChwYXJ0c1tpICsgMV0pIHNjb3BlZCArPSAnLCAnO1xuICB9XG5cbiAgcmV0dXJuIHNjb3BlZDtcbn1cblxuZnVuY3Rpb24gaGFuZGxlTmVzdGVkR2xvYmFsQ29udGFpbmVyUnVsZShydWxlLCBzaGVldCkge1xuICB2YXIgb3B0aW9ucyA9IHJ1bGUub3B0aW9ucyxcbiAgICAgIHN0eWxlID0gcnVsZS5zdHlsZTtcbiAgdmFyIHJ1bGVzID0gc3R5bGUgPyBzdHlsZVthdF0gOiBudWxsO1xuICBpZiAoIXJ1bGVzKSByZXR1cm47XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBydWxlcykge1xuICAgIHNoZWV0LmFkZFJ1bGUobmFtZSwgcnVsZXNbbmFtZV0sIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBzZWxlY3RvcjogYWRkU2NvcGUobmFtZSwgcnVsZS5zZWxlY3RvcilcbiAgICB9KSk7XG4gIH1cblxuICBkZWxldGUgc3R5bGVbYXRdO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVQcmVmaXhlZEdsb2JhbFJ1bGUocnVsZSwgc2hlZXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBydWxlLm9wdGlvbnMsXG4gICAgICBzdHlsZSA9IHJ1bGUuc3R5bGU7XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgIGlmIChwcm9wWzBdICE9PSAnQCcgfHwgcHJvcC5zdWJzdHIoMCwgYXQubGVuZ3RoKSAhPT0gYXQpIGNvbnRpbnVlO1xuICAgIHZhciBzZWxlY3RvciA9IGFkZFNjb3BlKHByb3Auc3Vic3RyKGF0Lmxlbmd0aCksIHJ1bGUuc2VsZWN0b3IpO1xuICAgIHNoZWV0LmFkZFJ1bGUoc2VsZWN0b3IsIHN0eWxlW3Byb3BdLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yXG4gICAgfSkpO1xuICAgIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgfVxufVxuLyoqXG4gKiBDb252ZXJ0IG5lc3RlZCBydWxlcyB0byBzZXBhcmF0ZSwgcmVtb3ZlIHRoZW0gZnJvbSBvcmlnaW5hbCBzdHlsZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBqc3NHbG9iYWwoKSB7XG4gIGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBudWxsO1xuXG4gICAgaWYgKG5hbWUgPT09IGF0KSB7XG4gICAgICByZXR1cm4gbmV3IEdsb2JhbENvbnRhaW5lclJ1bGUobmFtZSwgc3R5bGVzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZVswXSA9PT0gJ0AnICYmIG5hbWUuc3Vic3RyKDAsIGF0UHJlZml4Lmxlbmd0aCkgPT09IGF0UHJlZml4KSB7XG4gICAgICByZXR1cm4gbmV3IEdsb2JhbFByZWZpeGVkUnVsZShuYW1lLCBzdHlsZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gJ2dsb2JhbCcgfHwgcGFyZW50Lm9wdGlvbnMucGFyZW50ICYmIHBhcmVudC5vcHRpb25zLnBhcmVudC50eXBlID09PSAnZ2xvYmFsJykge1xuICAgICAgICBvcHRpb25zLnNjb3BlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5zZWxlY3RvciAmJiBvcHRpb25zLnNjb3BlZCA9PT0gZmFsc2UpIHtcbiAgICAgIG9wdGlvbnMuc2VsZWN0b3IgPSBuYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlLCBzaGVldCkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScgfHwgIXNoZWV0KSByZXR1cm47XG4gICAgaGFuZGxlTmVzdGVkR2xvYmFsQ29udGFpbmVyUnVsZShydWxlLCBzaGVldCk7XG4gICAgaGFuZGxlUHJlZml4ZWRHbG9iYWxSdWxlKHJ1bGUsIHNoZWV0KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25DcmVhdGVSdWxlOiBvbkNyZWF0ZVJ1bGUsXG4gICAgb25Qcm9jZXNzUnVsZTogb25Qcm9jZXNzUnVsZVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBqc3NHbG9iYWw7XG4iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgaXNJbkJyb3dzZXIgZnJvbSAnaXMtaW4tYnJvd3Nlcic7XG5pbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyc7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZSc7XG5pbXBvcnQgX2Fzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQnO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UnO1xuXG52YXIgcGxhaW5PYmplY3RDb25zdHJ1cmN0b3IgPSB7fS5jb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIGNsb25lU3R5bGUoc3R5bGUpIHtcbiAgaWYgKHN0eWxlID09IG51bGwgfHwgdHlwZW9mIHN0eWxlICE9PSAnb2JqZWN0JykgcmV0dXJuIHN0eWxlO1xuICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZSkpIHJldHVybiBzdHlsZS5tYXAoY2xvbmVTdHlsZSk7XG4gIGlmIChzdHlsZS5jb25zdHJ1Y3RvciAhPT0gcGxhaW5PYmplY3RDb25zdHJ1cmN0b3IpIHJldHVybiBzdHlsZTtcbiAgdmFyIG5ld1N0eWxlID0ge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZSkge1xuICAgIG5ld1N0eWxlW25hbWVdID0gY2xvbmVTdHlsZShzdHlsZVtuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3R5bGU7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcnVsZSBpbnN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVSdWxlKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgIG5hbWUgPSAndW5uYW1lZCc7XG4gIH1cblxuICB2YXIganNzID0gb3B0aW9ucy5qc3M7XG4gIHZhciBkZWNsQ29weSA9IGNsb25lU3R5bGUoZGVjbCk7XG4gIHZhciBydWxlID0ganNzLnBsdWdpbnMub25DcmVhdGVSdWxlKG5hbWUsIGRlY2xDb3B5LCBvcHRpb25zKTtcbiAgaWYgKHJ1bGUpIHJldHVybiBydWxlOyAvLyBJdCBpcyBhbiBhdC1ydWxlIGFuZCBpdCBoYXMgbm8gaW5zdGFuY2UuXG5cbiAgaWYgKG5hbWVbMF0gPT09ICdAJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gVW5rbm93biBydWxlIFwiICsgbmFtZSkgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGpvaW4gPSBmdW5jdGlvbiBqb2luKHZhbHVlLCBieSkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIC8vIFJlbW92ZSAhaW1wb3J0YW50IGZyb20gdGhlIHZhbHVlLCBpdCB3aWxsIGJlIHJlYWRkZWQgbGF0ZXIuXG4gICAgaWYgKHZhbHVlW2ldID09PSAnIWltcG9ydGFudCcpIGJyZWFrO1xuICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSBieTtcbiAgICByZXN1bHQgKz0gdmFsdWVbaV07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQ29udmVydHMgSlNTIGFycmF5IHZhbHVlIHRvIGEgQ1NTIHN0cmluZy5cbiAqXG4gKiBgbWFyZ2luOiBbWyc1cHgnLCAnMTBweCddXWAgPiBgbWFyZ2luOiA1cHggMTBweDtgXG4gKiBgYm9yZGVyOiBbJzFweCcsICcycHgnXWAgPiBgYm9yZGVyOiAxcHgsIDJweDtgXG4gKiBgbWFyZ2luOiBbWyc1cHgnLCAnMTBweCddLCAnIWltcG9ydGFudCddYCA+IGBtYXJnaW46IDVweCAxMHB4ICFpbXBvcnRhbnQ7YFxuICogYGNvbG9yOiBbJ3JlZCcsICFpbXBvcnRhbnRdYCA+IGBjb2xvcjogcmVkICFpbXBvcnRhbnQ7YFxuICovXG5cblxudmFyIHRvQ3NzVmFsdWUgPSBmdW5jdGlvbiB0b0Nzc1ZhbHVlKHZhbHVlKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgdmFyIGNzc1ZhbHVlID0gJyc7IC8vIFN1cHBvcnQgc3BhY2Ugc2VwYXJhdGVkIHZhbHVlcyB2aWEgYFtbJzVweCcsICcxMHB4J11dYC5cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVbaV0gPT09ICchaW1wb3J0YW50JykgYnJlYWs7XG4gICAgICBpZiAoY3NzVmFsdWUpIGNzc1ZhbHVlICs9ICcsICc7XG4gICAgICBjc3NWYWx1ZSArPSBqb2luKHZhbHVlW2ldLCAnICcpO1xuICAgIH1cbiAgfSBlbHNlIGNzc1ZhbHVlID0gam9pbih2YWx1ZSwgJywgJyk7IC8vIEFkZCAhaW1wb3J0YW50LCBiZWNhdXNlIGl0IHdhcyBpZ25vcmVkLlxuXG5cbiAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnIWltcG9ydGFudCcpIHtcbiAgICBjc3NWYWx1ZSArPSAnICFpbXBvcnRhbnQnO1xuICB9XG5cbiAgcmV0dXJuIGNzc1ZhbHVlO1xufTtcblxuZnVuY3Rpb24gZ2V0V2hpdGVzcGFjZVN5bWJvbHMob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZvcm1hdCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZWJyZWFrOiAnJyxcbiAgICAgIHNwYWNlOiAnJ1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxpbmVicmVhazogJ1xcbicsXG4gICAgc3BhY2U6ICcgJ1xuICB9O1xufVxuXG4vKipcbiAqIEluZGVudCBhIHN0cmluZy5cbiAqIGh0dHA6Ly9qc3BlcmYuY29tL2FycmF5LWpvaW4tdnMtZm9yXG4gKi9cblxuZnVuY3Rpb24gaW5kZW50U3RyKHN0ciwgaW5kZW50KSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaW5kZW50OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ICs9ICcgICc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0ICsgc3RyO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFJ1bGUgdG8gQ1NTIHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQ3NzKHNlbGVjdG9yLCBzdHlsZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAoIXN0eWxlKSByZXR1cm4gcmVzdWx0O1xuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkaW5kZW50ID0gX29wdGlvbnMuaW5kZW50LFxuICAgICAgaW5kZW50ID0gX29wdGlvbnMkaW5kZW50ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkaW5kZW50O1xuICB2YXIgZmFsbGJhY2tzID0gc3R5bGUuZmFsbGJhY2tzO1xuXG4gIGlmIChvcHRpb25zLmZvcm1hdCA9PT0gZmFsc2UpIHtcbiAgICBpbmRlbnQgPSAtSW5maW5pdHk7XG4gIH1cblxuICB2YXIgX2dldFdoaXRlc3BhY2VTeW1ib2xzID0gZ2V0V2hpdGVzcGFjZVN5bWJvbHMob3B0aW9ucyksXG4gICAgICBsaW5lYnJlYWsgPSBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMubGluZWJyZWFrLFxuICAgICAgc3BhY2UgPSBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMuc3BhY2U7XG5cbiAgaWYgKHNlbGVjdG9yKSBpbmRlbnQrKzsgLy8gQXBwbHkgZmFsbGJhY2tzIGZpcnN0LlxuXG4gIGlmIChmYWxsYmFja3MpIHtcbiAgICAvLyBBcnJheSBzeW50YXgge2ZhbGxiYWNrczogW3twcm9wOiB2YWx1ZX1dfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGZhbGxiYWNrcykpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBmYWxsYmFja3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBmYWxsYmFjayA9IGZhbGxiYWNrc1tpbmRleF07XG5cbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBmYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGZhbGxiYWNrW3Byb3BdO1xuXG4gICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSBsaW5lYnJlYWs7XG4gICAgICAgICAgICByZXN1bHQgKz0gaW5kZW50U3RyKHByb3AgKyBcIjpcIiArIHNwYWNlICsgdG9Dc3NWYWx1ZSh2YWx1ZSkgKyBcIjtcIiwgaW5kZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT2JqZWN0IHN5bnRheCB7ZmFsbGJhY2tzOiB7cHJvcDogdmFsdWV9fVxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gZmFsbGJhY2tzKSB7XG4gICAgICAgIHZhciBfdmFsdWUgPSBmYWxsYmFja3NbX3Byb3BdO1xuXG4gICAgICAgIGlmIChfdmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSBsaW5lYnJlYWs7XG4gICAgICAgICAgcmVzdWx0ICs9IGluZGVudFN0cihfcHJvcCArIFwiOlwiICsgc3BhY2UgKyB0b0Nzc1ZhbHVlKF92YWx1ZSkgKyBcIjtcIiwgaW5kZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9wcm9wMiBpbiBzdHlsZSkge1xuICAgIHZhciBfdmFsdWUyID0gc3R5bGVbX3Byb3AyXTtcblxuICAgIGlmIChfdmFsdWUyICE9IG51bGwgJiYgX3Byb3AyICE9PSAnZmFsbGJhY2tzJykge1xuICAgICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9IGxpbmVicmVhaztcbiAgICAgIHJlc3VsdCArPSBpbmRlbnRTdHIoX3Byb3AyICsgXCI6XCIgKyBzcGFjZSArIHRvQ3NzVmFsdWUoX3ZhbHVlMikgKyBcIjtcIiwgaW5kZW50KTtcbiAgICB9XG4gIH0gLy8gQWxsb3cgZW1wdHkgc3R5bGUgaW4gdGhpcyBjYXNlLCBiZWNhdXNlIHByb3BlcnRpZXMgd2lsbCBiZSBhZGRlZCBkeW5hbWljYWxseS5cblxuXG4gIGlmICghcmVzdWx0ICYmICFvcHRpb25zLmFsbG93RW1wdHkpIHJldHVybiByZXN1bHQ7IC8vIFdoZW4gcnVsZSBpcyBiZWluZyBzdHJpbmdpZmllZCBiZWZvcmUgc2VsZWN0b3Igd2FzIGRlZmluZWQuXG5cbiAgaWYgKCFzZWxlY3RvcikgcmV0dXJuIHJlc3VsdDtcbiAgaW5kZW50LS07XG4gIGlmIChyZXN1bHQpIHJlc3VsdCA9IFwiXCIgKyBsaW5lYnJlYWsgKyByZXN1bHQgKyBsaW5lYnJlYWs7XG4gIHJldHVybiBpbmRlbnRTdHIoXCJcIiArIHNlbGVjdG9yICsgc3BhY2UgKyBcIntcIiArIHJlc3VsdCwgaW5kZW50KSArIGluZGVudFN0cignfScsIGluZGVudCk7XG59XG5cbnZhciBlc2NhcGVSZWdleCA9IC8oW1tcXF0uIyokPjwrfj18XjooKSxcIidgXFxzXSkvZztcbnZhciBuYXRpdmVFc2NhcGUgPSB0eXBlb2YgQ1NTICE9PSAndW5kZWZpbmVkJyAmJiBDU1MuZXNjYXBlO1xudmFyIGVzY2FwZSA9IChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBuYXRpdmVFc2NhcGUgPyBuYXRpdmVFc2NhcGUoc3RyKSA6IHN0ci5yZXBsYWNlKGVzY2FwZVJlZ2V4LCAnXFxcXCQxJyk7XG59KTtcblxudmFyIEJhc2VTdHlsZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlU3R5bGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAnc3R5bGUnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB2YXIgc2hlZXQgPSBvcHRpb25zLnNoZWV0LFxuICAgICAgICBSZW5kZXJlciA9IG9wdGlvbnMuUmVuZGVyZXI7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgaWYgKHNoZWV0KSB0aGlzLnJlbmRlcmVyID0gc2hlZXQucmVuZGVyZXI7ZWxzZSBpZiAoUmVuZGVyZXIpIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IG9yIHNldCBhIHN0eWxlIHByb3BlcnR5LlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBCYXNlU3R5bGVSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucHJvcCA9IGZ1bmN0aW9uIHByb3AobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAvLyBJdCdzIGEgZ2V0dGVyLlxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5zdHlsZVtuYW1lXTsgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlIHZhbHVlIGhhcyBub3QgY2hhbmdlZC5cblxuICAgIHZhciBmb3JjZSA9IG9wdGlvbnMgPyBvcHRpb25zLmZvcmNlIDogZmFsc2U7XG4gICAgaWYgKCFmb3JjZSAmJiB0aGlzLnN0eWxlW25hbWVdID09PSB2YWx1ZSkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5wcm9jZXNzICE9PSBmYWxzZSkge1xuICAgICAgbmV3VmFsdWUgPSB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25DaGFuZ2VWYWx1ZSh2YWx1ZSwgbmFtZSwgdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIGlzRW1wdHkgPSBuZXdWYWx1ZSA9PSBudWxsIHx8IG5ld1ZhbHVlID09PSBmYWxzZTtcbiAgICB2YXIgaXNEZWZpbmVkID0gbmFtZSBpbiB0aGlzLnN0eWxlOyAvLyBWYWx1ZSBpcyBlbXB0eSBhbmQgd2Fzbid0IGRlZmluZWQgYmVmb3JlLlxuXG4gICAgaWYgKGlzRW1wdHkgJiYgIWlzRGVmaW5lZCAmJiAhZm9yY2UpIHJldHVybiB0aGlzOyAvLyBXZSBhcmUgZ29pbmcgdG8gcmVtb3ZlIHRoaXMgdmFsdWUuXG5cbiAgICB2YXIgcmVtb3ZlID0gaXNFbXB0eSAmJiBpc0RlZmluZWQ7XG4gICAgaWYgKHJlbW92ZSkgZGVsZXRlIHRoaXMuc3R5bGVbbmFtZV07ZWxzZSB0aGlzLnN0eWxlW25hbWVdID0gbmV3VmFsdWU7IC8vIFJlbmRlcmFibGUgaXMgZGVmaW5lZCBpZiBTdHlsZVNoZWV0IG9wdGlvbiBgbGlua2AgaXMgdHJ1ZS5cblxuICAgIGlmICh0aGlzLnJlbmRlcmFibGUgJiYgdGhpcy5yZW5kZXJlcikge1xuICAgICAgaWYgKHJlbW92ZSkgdGhpcy5yZW5kZXJlci5yZW1vdmVQcm9wZXJ0eSh0aGlzLnJlbmRlcmFibGUsIG5hbWUpO2Vsc2UgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLnJlbmRlcmFibGUsIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcblxuICAgIGlmIChzaGVldCAmJiBzaGVldC5hdHRhY2hlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ1tKU1NdIFJ1bGUgaXMgbm90IGxpbmtlZC4gTWlzc2luZyBzaGVldCBvcHRpb24gXCJsaW5rOiB0cnVlXCIuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIEJhc2VTdHlsZVJ1bGU7XG59KCk7XG52YXIgU3R5bGVSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZVN0eWxlUnVsZSkge1xuICBfaW5oZXJpdHNMb29zZShTdHlsZVJ1bGUsIF9CYXNlU3R5bGVSdWxlKTtcblxuICBmdW5jdGlvbiBTdHlsZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2VTdHlsZVJ1bGUuY2FsbCh0aGlzLCBrZXksIHN0eWxlLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgIHZhciBzZWxlY3RvciA9IG9wdGlvbnMuc2VsZWN0b3IsXG4gICAgICAgIHNjb3BlZCA9IG9wdGlvbnMuc2NvcGVkLFxuICAgICAgICBzaGVldCA9IG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIGdlbmVyYXRlSWQgPSBvcHRpb25zLmdlbmVyYXRlSWQ7XG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIF90aGlzLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yO1xuICAgIH0gZWxzZSBpZiAoc2NvcGVkICE9PSBmYWxzZSkge1xuICAgICAgX3RoaXMuaWQgPSBnZW5lcmF0ZUlkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBzaGVldCk7XG4gICAgICBfdGhpcy5zZWxlY3RvclRleHQgPSBcIi5cIiArIGVzY2FwZShfdGhpcy5pZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgc2VsZWN0b3Igc3RyaW5nLlxuICAgKiBBdHRlbnRpb246IHVzZSB0aGlzIHdpdGggY2F1dGlvbi4gTW9zdCBicm93c2VycyBkaWRuJ3QgaW1wbGVtZW50XG4gICAqIHNlbGVjdG9yVGV4dCBzZXR0ZXIsIHNvIHRoaXMgbWF5IHJlc3VsdCBpbiByZXJlbmRlcmluZyBvZiBlbnRpcmUgU3R5bGUgU2hlZXQuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90bzIgPSBTdHlsZVJ1bGUucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBBcHBseSBydWxlIHRvIGFuIGVsZW1lbnQgaW5saW5lLlxuICAgKi9cbiAgX3Byb3RvMi5hcHBseVRvID0gZnVuY3Rpb24gYXBwbHlUbyhyZW5kZXJhYmxlKSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcblxuICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgdmFyIGpzb24gPSB0aGlzLnRvSlNPTigpO1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIGpzb24pIHtcbiAgICAgICAgcmVuZGVyZXIuc2V0UHJvcGVydHkocmVuZGVyYWJsZSwgcHJvcCwganNvbltwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgcnVsZS5cbiAgICogRmFsbGJhY2tzIGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgKiBVc2VmdWwgZm9yIGlubGluZSBzdHlsZXMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvMi50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgdmFyIGpzb24gPSB7fTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5zdHlsZVtwcm9wXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSBqc29uW3Byb3BdID0gdmFsdWU7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIGpzb25bcHJvcF0gPSB0b0Nzc1ZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8yLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcbiAgICB2YXIgbGluayA9IHNoZWV0ID8gc2hlZXQub3B0aW9ucy5saW5rIDogZmFsc2U7XG4gICAgdmFyIG9wdHMgPSBsaW5rID8gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIGFsbG93RW1wdHk6IHRydWVcbiAgICB9KSA6IG9wdGlvbnM7XG4gICAgcmV0dXJuIHRvQ3NzKHRoaXMuc2VsZWN0b3JUZXh0LCB0aGlzLnN0eWxlLCBvcHRzKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU3R5bGVSdWxlLCBbe1xuICAgIGtleTogXCJzZWxlY3RvclwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHNlbGVjdG9yKSB7XG4gICAgICBpZiAoc2VsZWN0b3IgPT09IHRoaXMuc2VsZWN0b3JUZXh0KSByZXR1cm47XG4gICAgICB0aGlzLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yO1xuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcixcbiAgICAgICAgICByZW5kZXJhYmxlID0gdGhpcy5yZW5kZXJhYmxlO1xuICAgICAgaWYgKCFyZW5kZXJhYmxlIHx8ICFyZW5kZXJlcikgcmV0dXJuO1xuICAgICAgdmFyIGhhc0NoYW5nZWQgPSByZW5kZXJlci5zZXRTZWxlY3RvcihyZW5kZXJhYmxlLCBzZWxlY3Rvcik7IC8vIElmIHNlbGVjdG9yIHNldHRlciBpcyBub3QgaW1wbGVtZW50ZWQsIHJlcmVuZGVyIHRoZSBydWxlLlxuXG4gICAgICBpZiAoIWhhc0NoYW5nZWQpIHtcbiAgICAgICAgcmVuZGVyZXIucmVwbGFjZVJ1bGUocmVuZGVyYWJsZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzZWxlY3RvciBzdHJpbmcuXG4gICAgICovXG4gICAgLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3JUZXh0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdHlsZVJ1bGU7XG59KEJhc2VTdHlsZVJ1bGUpO1xudmFyIHBsdWdpblN0eWxlUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChrZXlbMF0gPT09ICdAJyB8fCBvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC50eXBlID09PSAna2V5ZnJhbWVzJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTdHlsZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0VG9TdHJpbmdPcHRpb25zID0ge1xuICBpbmRlbnQ6IDEsXG4gIGNoaWxkcmVuOiB0cnVlXG59O1xudmFyIGF0UmVnRXhwID0gL0AoW1xcdy1dKykvO1xuLyoqXG4gKiBDb25kaXRpb25hbCBydWxlIGZvciBAbWVkaWEsIEBzdXBwb3J0c1xuICovXG5cbnZhciBDb25kaXRpb25hbFJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb25kaXRpb25hbFJ1bGUoa2V5LCBzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAnY29uZGl0aW9uYWwnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB2YXIgYXRNYXRjaCA9IGtleS5tYXRjaChhdFJlZ0V4cCk7XG4gICAgdGhpcy5hdCA9IGF0TWF0Y2ggPyBhdE1hdGNoWzFdIDogJ3Vua25vd24nOyAvLyBLZXkgbWlnaHQgY29udGFpbiBhIHVuaXF1ZSBzdWZmaXggaW4gY2FzZSB0aGUgYG5hbWVgIHBhc3NlZCBieSB1c2VyIHdhcyBkdXBsaWNhdGUuXG5cbiAgICB0aGlzLnF1ZXJ5ID0gb3B0aW9ucy5uYW1lIHx8IFwiQFwiICsgdGhpcy5hdDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZXNbbmFtZV0pO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBydWxlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBDb25kaXRpb25hbFJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRSdWxlID0gZnVuY3Rpb24gZ2V0UnVsZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuZ2V0KG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihydWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuaW5kZXhPZihydWxlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZWdpc3RlciBydWxlLCBydW4gcGx1Z2lucy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZSA9IGZ1bmN0aW9uIGFkZFJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlLCBvcHRpb25zKTtcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBudWxsO1xuICAgIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlIHJ1bGUsIHJ1biBwbHVnaW5zLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXBsYWNlUnVsZSA9IGZ1bmN0aW9uIHJlcGxhY2VSdWxlKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdmFyIG5ld1J1bGUgPSB0aGlzLnJ1bGVzLnJlcGxhY2UobmFtZSwgc3R5bGUsIG9wdGlvbnMpO1xuICAgIGlmIChuZXdSdWxlKSB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShuZXdSdWxlKTtcbiAgICByZXR1cm4gbmV3UnVsZTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIF9nZXRXaGl0ZXNwYWNlU3ltYm9scyA9IGdldFdoaXRlc3BhY2VTeW1ib2xzKG9wdGlvbnMpLFxuICAgICAgICBsaW5lYnJlYWsgPSBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMubGluZWJyZWFrO1xuXG4gICAgaWYgKG9wdGlvbnMuaW5kZW50ID09IG51bGwpIG9wdGlvbnMuaW5kZW50ID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucy5pbmRlbnQ7XG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gPT0gbnVsbCkgb3B0aW9ucy5jaGlsZHJlbiA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnMuY2hpbGRyZW47XG5cbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXJ5ICsgXCIge31cIjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnJ1bGVzLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIHJldHVybiBjaGlsZHJlbiA/IHRoaXMucXVlcnkgKyBcIiB7XCIgKyBsaW5lYnJlYWsgKyBjaGlsZHJlbiArIGxpbmVicmVhayArIFwifVwiIDogJyc7XG4gIH07XG5cbiAgcmV0dXJuIENvbmRpdGlvbmFsUnVsZTtcbn0oKTtcbnZhciBrZXlSZWdFeHAgPSAvQGNvbnRhaW5lcnxAbWVkaWF8QHN1cHBvcnRzXFxzKy87XG52YXIgcGx1Z2luQ29uZGl0aW9uYWxSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBrZXlSZWdFeHAudGVzdChrZXkpID8gbmV3IENvbmRpdGlvbmFsUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykgOiBudWxsO1xuICB9XG59O1xuXG52YXIgZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxID0ge1xuICBpbmRlbnQ6IDEsXG4gIGNoaWxkcmVuOiB0cnVlXG59O1xudmFyIG5hbWVSZWdFeHAgPSAvQGtleWZyYW1lc1xccysoW1xcdy1dKykvO1xuLyoqXG4gKiBSdWxlIGZvciBAa2V5ZnJhbWVzXG4gKi9cblxudmFyIEtleWZyYW1lc1J1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBLZXlmcmFtZXNSdWxlKGtleSwgZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2tleWZyYW1lcyc7XG4gICAgdGhpcy5hdCA9ICdAa2V5ZnJhbWVzJztcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdmFyIG5hbWVNYXRjaCA9IGtleS5tYXRjaChuYW1lUmVnRXhwKTtcblxuICAgIGlmIChuYW1lTWF0Y2ggJiYgbmFtZU1hdGNoWzFdKSB7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lTWF0Y2hbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmFtZSA9ICdub25hbWUnO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBCYWQga2V5ZnJhbWVzIG5hbWUgXCIgKyBrZXkpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHRoaXMua2V5ID0gdGhpcy50eXBlICsgXCItXCIgKyB0aGlzLm5hbWU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB2YXIgc2NvcGVkID0gb3B0aW9ucy5zY29wZWQsXG4gICAgICAgIHNoZWV0ID0gb3B0aW9ucy5zaGVldCxcbiAgICAgICAgZ2VuZXJhdGVJZCA9IG9wdGlvbnMuZ2VuZXJhdGVJZDtcbiAgICB0aGlzLmlkID0gc2NvcGVkID09PSBmYWxzZSA/IHRoaXMubmFtZSA6IGVzY2FwZShnZW5lcmF0ZUlkKHRoaXMsIHNoZWV0KSk7XG4gICAgdGhpcy5ydWxlcyA9IG5ldyBSdWxlTGlzdChfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgcGFyZW50OiB0aGlzXG4gICAgfSkpO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBmcmFtZXMpIHtcbiAgICAgIHRoaXMucnVsZXMuYWRkKG5hbWUsIGZyYW1lc1tuYW1lXSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgcGFyZW50OiB0aGlzXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcy5wcm9jZXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IEtleWZyYW1lc1J1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxO1xuICAgIH1cblxuICAgIHZhciBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMgPSBnZXRXaGl0ZXNwYWNlU3ltYm9scyhvcHRpb25zKSxcbiAgICAgICAgbGluZWJyZWFrID0gX2dldFdoaXRlc3BhY2VTeW1ib2xzLmxpbmVicmVhaztcblxuICAgIGlmIChvcHRpb25zLmluZGVudCA9PSBudWxsKSBvcHRpb25zLmluZGVudCA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnMkMS5pbmRlbnQ7XG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gPT0gbnVsbCkgb3B0aW9ucy5jaGlsZHJlbiA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnMkMS5jaGlsZHJlbjtcblxuICAgIGlmIChvcHRpb25zLmNoaWxkcmVuID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXQgKyBcIiBcIiArIHRoaXMuaWQgKyBcIiB7fVwiO1xuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucnVsZXMudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgaWYgKGNoaWxkcmVuKSBjaGlsZHJlbiA9IFwiXCIgKyBsaW5lYnJlYWsgKyBjaGlsZHJlbiArIGxpbmVicmVhaztcbiAgICByZXR1cm4gdGhpcy5hdCArIFwiIFwiICsgdGhpcy5pZCArIFwiIHtcIiArIGNoaWxkcmVuICsgXCJ9XCI7XG4gIH07XG5cbiAgcmV0dXJuIEtleWZyYW1lc1J1bGU7XG59KCk7XG52YXIga2V5UmVnRXhwJDEgPSAvQGtleWZyYW1lc1xccysvO1xudmFyIHJlZlJlZ0V4cCA9IC9cXCQoW1xcdy1dKykvZztcblxudmFyIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUgPSBmdW5jdGlvbiBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbCwga2V5ZnJhbWVzKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWwucmVwbGFjZShyZWZSZWdFeHAsIGZ1bmN0aW9uIChtYXRjaCwgbmFtZSkge1xuICAgICAgaWYgKG5hbWUgaW4ga2V5ZnJhbWVzKSB7XG4gICAgICAgIHJldHVybiBrZXlmcmFtZXNbbmFtZV07XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gUmVmZXJlbmNlZCBrZXlmcmFtZXMgcnVsZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkLlwiKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuLyoqXG4gKiBSZXBsYWNlIHRoZSByZWZlcmVuY2UgZm9yIGEgYW5pbWF0aW9uIG5hbWUuXG4gKi9cblxuXG52YXIgcmVwbGFjZVJlZiA9IGZ1bmN0aW9uIHJlcGxhY2VSZWYoc3R5bGUsIHByb3AsIGtleWZyYW1lcykge1xuICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wXTtcbiAgdmFyIHJlZktleWZyYW1lID0gZmluZFJlZmVyZW5jZWRLZXlmcmFtZSh2YWx1ZSwga2V5ZnJhbWVzKTtcblxuICBpZiAocmVmS2V5ZnJhbWUgIT09IHZhbHVlKSB7XG4gICAgc3R5bGVbcHJvcF0gPSByZWZLZXlmcmFtZTtcbiAgfVxufTtcblxudmFyIHBsdWdpbktleWZyYW1lc1J1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleVJlZ0V4cCQxLnRlc3Qoa2V5KSA/IG5ldyBLZXlmcmFtZXNSdWxlKGtleSwgZnJhbWVzLCBvcHRpb25zKSA6IG51bGw7XG4gIH0sXG4gIC8vIEFuaW1hdGlvbiBuYW1lIHJlZiByZXBsYWNlci5cbiAgb25Qcm9jZXNzU3R5bGU6IGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlLCBzaGVldCkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScgfHwgIXNoZWV0KSByZXR1cm4gc3R5bGU7XG4gICAgaWYgKCdhbmltYXRpb24tbmFtZScgaW4gc3R5bGUpIHJlcGxhY2VSZWYoc3R5bGUsICdhbmltYXRpb24tbmFtZScsIHNoZWV0LmtleWZyYW1lcyk7XG4gICAgaWYgKCdhbmltYXRpb24nIGluIHN0eWxlKSByZXBsYWNlUmVmKHN0eWxlLCAnYW5pbWF0aW9uJywgc2hlZXQua2V5ZnJhbWVzKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH0sXG4gIG9uQ2hhbmdlVmFsdWU6IGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsLCBwcm9wLCBydWxlKSB7XG4gICAgdmFyIHNoZWV0ID0gcnVsZS5vcHRpb25zLnNoZWV0O1xuXG4gICAgaWYgKCFzaGVldCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgIGNhc2UgJ2FuaW1hdGlvbic6XG4gICAgICAgIHJldHVybiBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbCwgc2hlZXQua2V5ZnJhbWVzKTtcblxuICAgICAgY2FzZSAnYW5pbWF0aW9uLW5hbWUnOlxuICAgICAgICByZXR1cm4gZmluZFJlZmVyZW5jZWRLZXlmcmFtZSh2YWwsIHNoZWV0LmtleWZyYW1lcyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgS2V5ZnJhbWVSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZVN0eWxlUnVsZSkge1xuICBfaW5oZXJpdHNMb29zZShLZXlmcmFtZVJ1bGUsIF9CYXNlU3R5bGVSdWxlKTtcblxuICBmdW5jdGlvbiBLZXlmcmFtZVJ1bGUoKSB7XG4gICAgcmV0dXJuIF9CYXNlU3R5bGVSdWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBLZXlmcmFtZVJ1bGUucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcbiAgICB2YXIgbGluayA9IHNoZWV0ID8gc2hlZXQub3B0aW9ucy5saW5rIDogZmFsc2U7XG4gICAgdmFyIG9wdHMgPSBsaW5rID8gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIGFsbG93RW1wdHk6IHRydWVcbiAgICB9KSA6IG9wdGlvbnM7XG4gICAgcmV0dXJuIHRvQ3NzKHRoaXMua2V5LCB0aGlzLnN0eWxlLCBvcHRzKTtcbiAgfTtcblxuICByZXR1cm4gS2V5ZnJhbWVSdWxlO1xufShCYXNlU3R5bGVSdWxlKTtcbnZhciBwbHVnaW5LZXlmcmFtZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5wYXJlbnQgJiYgb3B0aW9ucy5wYXJlbnQudHlwZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgIHJldHVybiBuZXcgS2V5ZnJhbWVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG52YXIgRm9udEZhY2VSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRm9udEZhY2VSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAnZm9udC1mYWNlJztcbiAgICB0aGlzLmF0ID0gJ0Bmb250LWZhY2UnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gRm9udEZhY2VSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIF9nZXRXaGl0ZXNwYWNlU3ltYm9scyA9IGdldFdoaXRlc3BhY2VTeW1ib2xzKG9wdGlvbnMpLFxuICAgICAgICBsaW5lYnJlYWsgPSBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMubGluZWJyZWFrO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5zdHlsZSkpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuc3R5bGUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0ciArPSB0b0Nzcyh0aGlzLmF0LCB0aGlzLnN0eWxlW2luZGV4XSk7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlW2luZGV4ICsgMV0pIHN0ciArPSBsaW5lYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvQ3NzKHRoaXMuYXQsIHRoaXMuc3R5bGUsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBGb250RmFjZVJ1bGU7XG59KCk7XG52YXIga2V5UmVnRXhwJDIgPSAvQGZvbnQtZmFjZS87XG52YXIgcGx1Z2luRm9udEZhY2VSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGtleVJlZ0V4cCQyLnRlc3Qoa2V5KSA/IG5ldyBGb250RmFjZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykgOiBudWxsO1xuICB9XG59O1xuXG52YXIgVmlld3BvcnRSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmlld3BvcnRSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAndmlld3BvcnQnO1xuICAgIHRoaXMuYXQgPSAnQHZpZXdwb3J0JztcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFZpZXdwb3J0UnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiB0b0Nzcyh0aGlzLmtleSwgdGhpcy5zdHlsZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIFZpZXdwb3J0UnVsZTtcbn0oKTtcbnZhciBwbHVnaW5WaWV3cG9ydFJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5ID09PSAnQHZpZXdwb3J0JyB8fCBrZXkgPT09ICdALW1zLXZpZXdwb3J0JyA/IG5ldyBWaWV3cG9ydFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykgOiBudWxsO1xuICB9XG59O1xuXG52YXIgU2ltcGxlUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNpbXBsZVJ1bGUoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdzaW1wbGUnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXG5cbiAgdmFyIF9wcm90byA9IFNpbXBsZVJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSkge1xuICAgICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy52YWx1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc3RyICs9IHRoaXMua2V5ICsgXCIgXCIgKyB0aGlzLnZhbHVlW2luZGV4XSArIFwiO1wiO1xuICAgICAgICBpZiAodGhpcy52YWx1ZVtpbmRleCArIDFdKSBzdHIgKz0gJ1xcbic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMua2V5ICsgXCIgXCIgKyB0aGlzLnZhbHVlICsgXCI7XCI7XG4gIH07XG5cbiAgcmV0dXJuIFNpbXBsZVJ1bGU7XG59KCk7XG52YXIga2V5c01hcCA9IHtcbiAgJ0BjaGFyc2V0JzogdHJ1ZSxcbiAgJ0BpbXBvcnQnOiB0cnVlLFxuICAnQG5hbWVzcGFjZSc6IHRydWVcbn07XG52YXIgcGx1Z2luU2ltcGxlUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBrZXkgaW4ga2V5c01hcCA/IG5ldyBTaW1wbGVSdWxlKGtleSwgdmFsdWUsIG9wdGlvbnMpIDogbnVsbDtcbiAgfVxufTtcblxudmFyIHBsdWdpbnMgPSBbcGx1Z2luU3R5bGVSdWxlLCBwbHVnaW5Db25kaXRpb25hbFJ1bGUsIHBsdWdpbktleWZyYW1lc1J1bGUsIHBsdWdpbktleWZyYW1lUnVsZSwgcGx1Z2luRm9udEZhY2VSdWxlLCBwbHVnaW5WaWV3cG9ydFJ1bGUsIHBsdWdpblNpbXBsZVJ1bGVdO1xuXG52YXIgZGVmYXVsdFVwZGF0ZU9wdGlvbnMgPSB7XG4gIHByb2Nlc3M6IHRydWVcbn07XG52YXIgZm9yY2VVcGRhdGVPcHRpb25zID0ge1xuICBmb3JjZTogdHJ1ZSxcbiAgcHJvY2VzczogdHJ1ZVxuICAvKipcbiAgICogQ29udGFpbnMgcnVsZXMgb2JqZWN0cyBhbmQgYWxsb3dzIGFkZGluZy9yZW1vdmluZyBldGMuXG4gICAqIElzIHVzZWQgZm9yIGUuZy4gYnkgYFN0eWxlU2hlZXRgIG9yIGBDb25kaXRpb25hbFJ1bGVgLlxuICAgKi9cblxufTtcblxudmFyIFJ1bGVMaXN0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLy8gUnVsZXMgcmVnaXN0cnkgZm9yIGFjY2VzcyBieSAuZ2V0KCkgbWV0aG9kLlxuICAvLyBJdCBjb250YWlucyB0aGUgc2FtZSBydWxlIHJlZ2lzdGVyZWQgYnkgbmFtZSBhbmQgYnkgc2VsZWN0b3IuXG4gIC8vIE9yaWdpbmFsIHN0eWxlcyBvYmplY3QuXG4gIC8vIFVzZWQgdG8gZW5zdXJlIGNvcnJlY3QgcnVsZXMgb3JkZXIuXG4gIGZ1bmN0aW9uIFJ1bGVMaXN0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuICAgIHRoaXMucmF3ID0ge307XG4gICAgdGhpcy5pbmRleCA9IFtdO1xuICAgIHRoaXMuY291bnRlciA9IDA7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNsYXNzZXMgPSBvcHRpb25zLmNsYXNzZXM7XG4gICAgdGhpcy5rZXlmcmFtZXMgPSBvcHRpb25zLmtleWZyYW1lcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZWdpc3RlciBydWxlLlxuICAgKlxuICAgKiBXaWxsIG5vdCByZW5kZXIgYWZ0ZXIgU3R5bGUgU2hlZXQgd2FzIHJlbmRlcmVkIHRoZSBmaXJzdCB0aW1lLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBSdWxlTGlzdC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChuYW1lLCBkZWNsLCBydWxlT3B0aW9ucykge1xuICAgIHZhciBfdGhpcyRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBwYXJlbnQgPSBfdGhpcyRvcHRpb25zLnBhcmVudCxcbiAgICAgICAgc2hlZXQgPSBfdGhpcyRvcHRpb25zLnNoZWV0LFxuICAgICAgICBqc3MgPSBfdGhpcyRvcHRpb25zLmpzcyxcbiAgICAgICAgUmVuZGVyZXIgPSBfdGhpcyRvcHRpb25zLlJlbmRlcmVyLFxuICAgICAgICBnZW5lcmF0ZUlkID0gX3RoaXMkb3B0aW9ucy5nZW5lcmF0ZUlkLFxuICAgICAgICBzY29wZWQgPSBfdGhpcyRvcHRpb25zLnNjb3BlZDtcblxuICAgIHZhciBvcHRpb25zID0gX2V4dGVuZHMoe1xuICAgICAgY2xhc3NlczogdGhpcy5jbGFzc2VzLFxuICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICBzaGVldDogc2hlZXQsXG4gICAgICBqc3M6IGpzcyxcbiAgICAgIFJlbmRlcmVyOiBSZW5kZXJlcixcbiAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQsXG4gICAgICBzY29wZWQ6IHNjb3BlZCxcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBrZXlmcmFtZXM6IHRoaXMua2V5ZnJhbWVzLFxuICAgICAgc2VsZWN0b3I6IHVuZGVmaW5lZFxuICAgIH0sIHJ1bGVPcHRpb25zKTsgLy8gV2hlbiB1c2VyIHVzZXMgLmNyZWF0ZVN0eWxlU2hlZXQoKSwgZHVwbGljYXRlIG5hbWVzIGFyZSBub3QgcG9zc2libGUsIGJ1dFxuICAgIC8vIGBzaGVldC5hZGRSdWxlKClgIG9wZW5zIHRoZSBkb29yIGZvciBhbnkgZHVwbGljYXRlIHJ1bGUgbmFtZS4gV2hlbiB0aGlzIGhhcHBlbnNcbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2UgdGhlIGtleSB1bmlxdWUgd2l0aGluIHRoaXMgUnVsZUxpc3QgaW5zdGFuY2Ugc2NvcGUuXG5cblxuICAgIHZhciBrZXkgPSBuYW1lO1xuXG4gICAgaWYgKG5hbWUgaW4gdGhpcy5yYXcpIHtcbiAgICAgIGtleSA9IG5hbWUgKyBcIi1kXCIgKyB0aGlzLmNvdW50ZXIrKztcbiAgICB9IC8vIFdlIG5lZWQgdG8gc2F2ZSB0aGUgb3JpZ2luYWwgZGVjbCBiZWZvcmUgY3JlYXRpbmcgdGhlIHJ1bGVcbiAgICAvLyBiZWNhdXNlIGNhY2hlIHBsdWdpbiBuZWVkcyB0byB1c2UgaXQgYXMgYSBrZXkgdG8gcmV0dXJuIGEgY2FjaGVkIHJ1bGUuXG5cblxuICAgIHRoaXMucmF3W2tleV0gPSBkZWNsO1xuXG4gICAgaWYgKGtleSBpbiB0aGlzLmNsYXNzZXMpIHtcbiAgICAgIC8vIEUuZy4gcnVsZXMgaW5zaWRlIG9mIEBtZWRpYSBjb250YWluZXJcbiAgICAgIG9wdGlvbnMuc2VsZWN0b3IgPSBcIi5cIiArIGVzY2FwZSh0aGlzLmNsYXNzZXNba2V5XSk7XG4gICAgfVxuXG4gICAgdmFyIHJ1bGUgPSBjcmVhdGVSdWxlKGtleSwgZGVjbCwgb3B0aW9ucyk7XG4gICAgaWYgKCFydWxlKSByZXR1cm4gbnVsbDtcbiAgICB0aGlzLnJlZ2lzdGVyKHJ1bGUpO1xuICAgIHZhciBpbmRleCA9IG9wdGlvbnMuaW5kZXggPT09IHVuZGVmaW5lZCA/IHRoaXMuaW5kZXgubGVuZ3RoIDogb3B0aW9ucy5pbmRleDtcbiAgICB0aGlzLmluZGV4LnNwbGljZShpbmRleCwgMCwgcnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlcGxhY2UgcnVsZS5cbiAgICogQ3JlYXRlIGEgbmV3IHJ1bGUgYW5kIHJlbW92ZSBvbGQgb25lIGluc3RlYWQgb2Ygb3ZlcndyaXRpbmdcbiAgICogYmVjYXVzZSB3ZSB3YW50IHRvIGludm9rZSBvbkNyZWF0ZVJ1bGUgaG9vayB0byBtYWtlIHBsdWdpbnMgd29yay5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UobmFtZSwgZGVjbCwgcnVsZU9wdGlvbnMpIHtcbiAgICB2YXIgb2xkUnVsZSA9IHRoaXMuZ2V0KG5hbWUpO1xuICAgIHZhciBvbGRJbmRleCA9IHRoaXMuaW5kZXguaW5kZXhPZihvbGRSdWxlKTtcblxuICAgIGlmIChvbGRSdWxlKSB7XG4gICAgICB0aGlzLnJlbW92ZShvbGRSdWxlKTtcbiAgICB9XG5cbiAgICB2YXIgb3B0aW9ucyA9IHJ1bGVPcHRpb25zO1xuICAgIGlmIChvbGRJbmRleCAhPT0gLTEpIG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgcnVsZU9wdGlvbnMsIHtcbiAgICAgIGluZGV4OiBvbGRJbmRleFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmFkZChuYW1lLCBkZWNsLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgcnVsZSBieSBuYW1lIG9yIHNlbGVjdG9yLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZU9yU2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBbbmFtZU9yU2VsZWN0b3JdO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUocnVsZSkge1xuICAgIHRoaXMudW5yZWdpc3RlcihydWxlKTtcbiAgICBkZWxldGUgdGhpcy5yYXdbcnVsZS5rZXldO1xuICAgIHRoaXMuaW5kZXguc3BsaWNlKHRoaXMuaW5kZXguaW5kZXhPZihydWxlKSwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleC5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBSdW4gYG9uUHJvY2Vzc1J1bGUoKWAgcGx1Z2lucyBvbiBldmVyeSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICB2YXIgcGx1Z2lucyA9IHRoaXMub3B0aW9ucy5qc3MucGx1Z2luczsgLy8gV2UgbmVlZCB0byBjbG9uZSBhcnJheSBiZWNhdXNlIGlmIHdlIG1vZGlmeSB0aGUgaW5kZXggc29tZXdoZXJlIGVsc2UgZHVyaW5nIGEgbG9vcFxuICAgIC8vIHdlIGVuZCB1cCB3aXRoIHZlcnkgaGFyZC10by10cmFjay1kb3duIHNpZGUgZWZmZWN0cy5cblxuICAgIHRoaXMuaW5kZXguc2xpY2UoMCkuZm9yRWFjaChwbHVnaW5zLm9uUHJvY2Vzc1J1bGUsIHBsdWdpbnMpO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHJ1bGUgaW4gYC5tYXBgLCBgLmNsYXNzZXNgIGFuZCBgLmtleWZyYW1lc2AgbWFwcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihydWxlKSB7XG4gICAgdGhpcy5tYXBbcnVsZS5rZXldID0gcnVsZTtcblxuICAgIGlmIChydWxlIGluc3RhbmNlb2YgU3R5bGVSdWxlKSB7XG4gICAgICB0aGlzLm1hcFtydWxlLnNlbGVjdG9yXSA9IHJ1bGU7XG4gICAgICBpZiAocnVsZS5pZCkgdGhpcy5jbGFzc2VzW3J1bGUua2V5XSA9IHJ1bGUuaWQ7XG4gICAgfSBlbHNlIGlmIChydWxlIGluc3RhbmNlb2YgS2V5ZnJhbWVzUnVsZSAmJiB0aGlzLmtleWZyYW1lcykge1xuICAgICAgdGhpcy5rZXlmcmFtZXNbcnVsZS5uYW1lXSA9IHJ1bGUuaWQ7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udW5yZWdpc3RlciA9IGZ1bmN0aW9uIHVucmVnaXN0ZXIocnVsZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtydWxlLmtleV07XG5cbiAgICBpZiAocnVsZSBpbnN0YW5jZW9mIFN0eWxlUnVsZSkge1xuICAgICAgZGVsZXRlIHRoaXMubWFwW3J1bGUuc2VsZWN0b3JdO1xuICAgICAgZGVsZXRlIHRoaXMuY2xhc3Nlc1tydWxlLmtleV07XG4gICAgfSBlbHNlIGlmIChydWxlIGluc3RhbmNlb2YgS2V5ZnJhbWVzUnVsZSkge1xuICAgICAgZGVsZXRlIHRoaXMua2V5ZnJhbWVzW3J1bGUubmFtZV07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGZ1bmN0aW9uIHZhbHVlcyB3aXRoIGEgbmV3IGRhdGEuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgZGF0YTtcbiAgICB2YXIgb3B0aW9ucztcblxuICAgIGlmICh0eXBlb2YgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXTtcbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdO1xuICAgICAgbmFtZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHRoaXMudXBkYXRlT25lKHRoaXMuZ2V0KG5hbWUpLCBkYXRhLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuaW5kZXgubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHRoaXMudXBkYXRlT25lKHRoaXMuaW5kZXhbaW5kZXhdLCBkYXRhLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGUgcGx1Z2lucywgdXBkYXRlIHJ1bGUgcHJvcHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZU9uZSA9IGZ1bmN0aW9uIHVwZGF0ZU9uZShydWxlLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRVcGRhdGVPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyRvcHRpb25zMiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgcGx1Z2lucyA9IF90aGlzJG9wdGlvbnMyLmpzcy5wbHVnaW5zLFxuICAgICAgICBzaGVldCA9IF90aGlzJG9wdGlvbnMyLnNoZWV0OyAvLyBJdCBpcyBhIHJ1bGVzIGNvbnRhaW5lciBsaWtlIGZvciBlLmcuIENvbmRpdGlvbmFsUnVsZS5cblxuICAgIGlmIChydWxlLnJ1bGVzIGluc3RhbmNlb2YgUnVsZUxpc3QpIHtcbiAgICAgIHJ1bGUucnVsZXMudXBkYXRlKGRhdGEsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IHJ1bGUuc3R5bGU7XG4gICAgcGx1Z2lucy5vblVwZGF0ZShkYXRhLCBydWxlLCBzaGVldCwgb3B0aW9ucyk7IC8vIFdlIHJlbHkgb24gYSBuZXcgYHN0eWxlYCByZWYgaW4gY2FzZSBpdCB3YXMgbXV0YXRlZCBkdXJpbmcgb25VcGRhdGUgaG9vay5cblxuICAgIGlmIChvcHRpb25zLnByb2Nlc3MgJiYgc3R5bGUgJiYgc3R5bGUgIT09IHJ1bGUuc3R5bGUpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gcnVuIHRoZSBwbHVnaW5zIGluIGNhc2UgbmV3IGBzdHlsZWAgcmVsaWVzIG9uIHN5bnRheCBwbHVnaW5zLlxuICAgICAgcGx1Z2lucy5vblByb2Nlc3NTdHlsZShydWxlLnN0eWxlLCBydWxlLCBzaGVldCk7IC8vIFVwZGF0ZSBhbmQgYWRkIHByb3BzLlxuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHJ1bGUuc3R5bGUpIHtcbiAgICAgICAgdmFyIG5leHRWYWx1ZSA9IHJ1bGUuc3R5bGVbcHJvcF07XG4gICAgICAgIHZhciBwcmV2VmFsdWUgPSBzdHlsZVtwcm9wXTsgLy8gV2UgbmVlZCB0byB1c2UgYGZvcmNlOiB0cnVlYCBiZWNhdXNlIGBydWxlLnN0eWxlYCBoYXMgYmVlbiB1cGRhdGVkIGR1cmluZyBvblVwZGF0ZSBob29rLCBzbyBgcnVsZS5wcm9wKClgIHdpbGwgbm90IHVwZGF0ZSB0aGUgQ1NTT00gcnVsZS5cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBjb21wYXJpc29uIHRvIGF2b2lkIHVubmVlZGVkIGBydWxlLnByb3AoKWAgY2FsbHMsIHNpbmNlIHdlIGhhdmUgdGhlIG9sZCBgc3R5bGVgIG9iamVjdCBoZXJlLlxuXG4gICAgICAgIGlmIChuZXh0VmFsdWUgIT09IHByZXZWYWx1ZSkge1xuICAgICAgICAgIHJ1bGUucHJvcChwcm9wLCBuZXh0VmFsdWUsIGZvcmNlVXBkYXRlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmVtb3ZlIHByb3BzLlxuXG5cbiAgICAgIGZvciAodmFyIF9wcm9wIGluIHN0eWxlKSB7XG4gICAgICAgIHZhciBfbmV4dFZhbHVlID0gcnVsZS5zdHlsZVtfcHJvcF07XG4gICAgICAgIHZhciBfcHJldlZhbHVlID0gc3R5bGVbX3Byb3BdOyAvLyBXZSBuZWVkIHRvIHVzZSBgZm9yY2U6IHRydWVgIGJlY2F1c2UgYHJ1bGUuc3R5bGVgIGhhcyBiZWVuIHVwZGF0ZWQgZHVyaW5nIG9uVXBkYXRlIGhvb2ssIHNvIGBydWxlLnByb3AoKWAgd2lsbCBub3QgdXBkYXRlIHRoZSBDU1NPTSBydWxlLlxuICAgICAgICAvLyBXZSBkbyB0aGlzIGNvbXBhcmlzb24gdG8gYXZvaWQgdW5uZWVkZWQgYHJ1bGUucHJvcCgpYCBjYWxscywgc2luY2Ugd2UgaGF2ZSB0aGUgb2xkIGBzdHlsZWAgb2JqZWN0IGhlcmUuXG5cbiAgICAgICAgaWYgKF9uZXh0VmFsdWUgPT0gbnVsbCAmJiBfbmV4dFZhbHVlICE9PSBfcHJldlZhbHVlKSB7XG4gICAgICAgICAgcnVsZS5wcm9wKF9wcm9wLCBudWxsLCBmb3JjZVVwZGF0ZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHJ1bGVzIHRvIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcbiAgICB2YXIgbGluayA9IHNoZWV0ID8gc2hlZXQub3B0aW9ucy5saW5rIDogZmFsc2U7XG5cbiAgICB2YXIgX2dldFdoaXRlc3BhY2VTeW1ib2xzID0gZ2V0V2hpdGVzcGFjZVN5bWJvbHMob3B0aW9ucyksXG4gICAgICAgIGxpbmVicmVhayA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5saW5lYnJlYWs7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5pbmRleC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBydWxlID0gdGhpcy5pbmRleFtpbmRleF07XG4gICAgICB2YXIgY3NzID0gcnVsZS50b1N0cmluZyhvcHRpb25zKTsgLy8gTm8gbmVlZCB0byByZW5kZXIgYW4gZW1wdHkgcnVsZS5cblxuICAgICAgaWYgKCFjc3MgJiYgIWxpbmspIGNvbnRpbnVlO1xuICAgICAgaWYgKHN0cikgc3RyICs9IGxpbmVicmVhaztcbiAgICAgIHN0ciArPSBjc3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICByZXR1cm4gUnVsZUxpc3Q7XG59KCk7XG5cbnZhciBTdHlsZVNoZWV0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3R5bGVTaGVldChzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgdGhpcy5kZXBsb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xhc3NlcyA9IHt9O1xuICAgIHRoaXMua2V5ZnJhbWVzID0ge307XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHNoZWV0OiB0aGlzLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgY2xhc3NlczogdGhpcy5jbGFzc2VzLFxuICAgICAga2V5ZnJhbWVzOiB0aGlzLmtleWZyYW1lc1xuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMuUmVuZGVyZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgb3B0aW9ucy5SZW5kZXJlcih0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzID0gbmV3IFJ1bGVMaXN0KHRoaXMub3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGVzW25hbWVdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogQXR0YWNoIHJlbmRlcmFibGUgdG8gdGhlIHJlbmRlciB0cmVlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBTdHlsZVNoZWV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uYXR0YWNoID0gZnVuY3Rpb24gYXR0YWNoKCkge1xuICAgIGlmICh0aGlzLmF0dGFjaGVkKSByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5yZW5kZXJlcikgdGhpcy5yZW5kZXJlci5hdHRhY2goKTtcbiAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTsgLy8gT3JkZXIgaXMgaW1wb3J0YW50LCBiZWNhdXNlIHdlIGNhbid0IHVzZSBpbnNlcnRSdWxlIEFQSSBpZiBzdHlsZSBlbGVtZW50IGlzIG5vdCBhdHRhY2hlZC5cblxuICAgIGlmICghdGhpcy5kZXBsb3llZCkgdGhpcy5kZXBsb3koKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHJlbmRlcmFibGUgZnJvbSByZW5kZXIgdHJlZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGV0YWNoID0gZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgIGlmICghdGhpcy5hdHRhY2hlZCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHRoaXMucmVuZGVyZXIuZGV0YWNoKCk7XG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBydWxlIHRvIHRoZSBjdXJyZW50IHN0eWxlc2hlZXQuXG4gICAqIFdpbGwgaW5zZXJ0IGEgcnVsZSBhbHNvIGFmdGVyIHRoZSBzdHlsZXNoZWV0IGhhcyBiZWVuIHJlbmRlcmVkIGZpcnN0IHRpbWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZFJ1bGUgPSBmdW5jdGlvbiBhZGRSdWxlKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlOyAvLyBQbHVnaW5zIGNhbiBjcmVhdGUgcnVsZXMuXG4gICAgLy8gSW4gb3JkZXIgdG8gcHJlc2VydmUgdGhlIHJpZ2h0IG9yZGVyLCB3ZSBuZWVkIHRvIHF1ZXVlIGFsbCBgLmFkZFJ1bGVgIGNhbGxzLFxuICAgIC8vIHdoaWNoIGhhcHBlbiBhZnRlciB0aGUgZmlyc3QgYHJ1bGVzLmFkZCgpYCBjYWxsLlxuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQgJiYgIXF1ZXVlKSB0aGlzLnF1ZXVlID0gW107XG4gICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzLmFkZChuYW1lLCBkZWNsLCBvcHRpb25zKTtcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBudWxsO1xuICAgIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIGlmICghdGhpcy5kZXBsb3llZCkgcmV0dXJuIHJ1bGU7IC8vIERvbid0IGluc2VydCBydWxlIGRpcmVjdGx5IGlmIHRoZXJlIGlzIG5vIHN0cmluZ2lmaWVkIHZlcnNpb24geWV0LlxuICAgICAgLy8gSXQgd2lsbCBiZSBpbnNlcnRlZCBhbGwgdG9nZXRoZXIgd2hlbiAuYXR0YWNoIGlzIGNhbGxlZC5cblxuICAgICAgaWYgKHF1ZXVlKSBxdWV1ZS5wdXNoKHJ1bGUpO2Vsc2Uge1xuICAgICAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG5cbiAgICAgICAgaWYgKHRoaXMucXVldWUpIHtcbiAgICAgICAgICB0aGlzLnF1ZXVlLmZvckVhY2godGhpcy5pbnNlcnRSdWxlLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLnF1ZXVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9IC8vIFdlIGNhbid0IGFkZCBydWxlcyB0byBhIGRldGFjaGVkIHN0eWxlIG5vZGUuXG4gICAgLy8gV2Ugd2lsbCByZWRlcGxveSB0aGUgc2hlZXQgb25jZSB1c2VyIHdpbGwgYXR0YWNoIGl0LlxuXG5cbiAgICB0aGlzLmRlcGxveWVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlcGxhY2UgYSBydWxlIGluIHRoZSBjdXJyZW50IHN0eWxlc2hlZXQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlcGxhY2VSdWxlID0gZnVuY3Rpb24gcmVwbGFjZVJ1bGUobmFtZU9yU2VsZWN0b3IsIGRlY2wsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2xkUnVsZSA9IHRoaXMucnVsZXMuZ2V0KG5hbWVPclNlbGVjdG9yKTtcbiAgICBpZiAoIW9sZFJ1bGUpIHJldHVybiB0aGlzLmFkZFJ1bGUobmFtZU9yU2VsZWN0b3IsIGRlY2wsIG9wdGlvbnMpO1xuICAgIHZhciBuZXdSdWxlID0gdGhpcy5ydWxlcy5yZXBsYWNlKG5hbWVPclNlbGVjdG9yLCBkZWNsLCBvcHRpb25zKTtcblxuICAgIGlmIChuZXdSdWxlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShuZXdSdWxlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgaWYgKCF0aGlzLmRlcGxveWVkKSByZXR1cm4gbmV3UnVsZTsgLy8gRG9uJ3QgcmVwbGFjZSAvIGRlbGV0ZSBydWxlIGRpcmVjdGx5IGlmIHRoZXJlIGlzIG5vIHN0cmluZ2lmaWVkIHZlcnNpb24geWV0LlxuICAgICAgLy8gSXQgd2lsbCBiZSBpbnNlcnRlZCBhbGwgdG9nZXRoZXIgd2hlbiAuYXR0YWNoIGlzIGNhbGxlZC5cblxuICAgICAgaWYgKHRoaXMucmVuZGVyZXIpIHtcbiAgICAgICAgaWYgKCFuZXdSdWxlKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5kZWxldGVSdWxlKG9sZFJ1bGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG9sZFJ1bGUucmVuZGVyYWJsZSkge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVwbGFjZVJ1bGUob2xkUnVsZS5yZW5kZXJhYmxlLCBuZXdSdWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3UnVsZTtcbiAgICB9IC8vIFdlIGNhbid0IHJlcGxhY2UgcnVsZXMgdG8gYSBkZXRhY2hlZCBzdHlsZSBub2RlLlxuICAgIC8vIFdlIHdpbGwgcmVkZXBsb3kgdGhlIHNoZWV0IG9uY2UgdXNlciB3aWxsIGF0dGFjaCBpdC5cblxuXG4gICAgdGhpcy5kZXBsb3llZCA9IGZhbHNlO1xuICAgIHJldHVybiBuZXdSdWxlO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgcnVsZSBpbnRvIHRoZSBTdHlsZVNoZWV0XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluc2VydFJ1bGUgPSBmdW5jdGlvbiBpbnNlcnRSdWxlKHJ1bGUpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlcikge1xuICAgICAgdGhpcy5yZW5kZXJlci5pbnNlcnRSdWxlKHJ1bGUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuZCBhZGQgcnVsZXMuXG4gICAqIFdpbGwgcmVuZGVyIGFsc28gYWZ0ZXIgU3R5bGUgU2hlZXQgd2FzIHJlbmRlcmVkIHRoZSBmaXJzdCB0aW1lLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5hZGRSdWxlcyA9IGZ1bmN0aW9uIGFkZFJ1bGVzKHN0eWxlcywgb3B0aW9ucykge1xuICAgIHZhciBhZGRlZCA9IFtdO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIHZhciBydWxlID0gdGhpcy5hZGRSdWxlKG5hbWUsIHN0eWxlc1tuYW1lXSwgb3B0aW9ucyk7XG4gICAgICBpZiAocnVsZSkgYWRkZWQucHVzaChydWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHJ1bGUgYnkgbmFtZSBvciBzZWxlY3Rvci5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0UnVsZSA9IGZ1bmN0aW9uIGdldFJ1bGUobmFtZU9yU2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5nZXQobmFtZU9yU2VsZWN0b3IpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBydWxlIGJ5IG5hbWUuXG4gICAqIFJldHVybnMgYHRydWVgOiBpZiBydWxlIGhhcyBiZWVuIGRlbGV0ZWQgZnJvbSB0aGUgRE9NLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZWxldGVSdWxlID0gZnVuY3Rpb24gZGVsZXRlUnVsZShuYW1lKSB7XG4gICAgdmFyIHJ1bGUgPSB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcgPyBuYW1lIDogdGhpcy5ydWxlcy5nZXQobmFtZSk7XG5cbiAgICBpZiAoIXJ1bGUgfHwgLy8gU3R5bGUgc2hlZXQgd2FzIGNyZWF0ZWQgd2l0aG91dCBsaW5rOiB0cnVlIGFuZCBhdHRhY2hlZCwgaW4gdGhpcyBjYXNlIHdlXG4gICAgLy8gd29uJ3QgYmUgYWJsZSB0byByZW1vdmUgdGhlIENTUyBydWxlIGZyb20gdGhlIERPTS5cbiAgICB0aGlzLmF0dGFjaGVkICYmICFydWxlLnJlbmRlcmFibGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnJlbW92ZShydWxlKTtcblxuICAgIGlmICh0aGlzLmF0dGFjaGVkICYmIHJ1bGUucmVuZGVyYWJsZSAmJiB0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5kZWxldGVSdWxlKHJ1bGUucmVuZGVyYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBEZXBsb3kgcHVyZSBDU1Mgc3RyaW5nIHRvIGEgcmVuZGVyYWJsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVwbG95ID0gZnVuY3Rpb24gZGVwbG95KCkge1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyLmRlcGxveSgpO1xuICAgIHRoaXMuZGVwbG95ZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGZ1bmN0aW9uIHZhbHVlcyB3aXRoIGEgbmV3IGRhdGEuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMkcnVsZXM7XG5cbiAgICAoX3RoaXMkcnVsZXMgPSB0aGlzLnJ1bGVzKS51cGRhdGUuYXBwbHkoX3RoaXMkcnVsZXMsIGFyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBhIHNpbmdsZSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51cGRhdGVPbmUgPSBmdW5jdGlvbiB1cGRhdGVPbmUocnVsZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMucnVsZXMudXBkYXRlT25lKHJ1bGUsIGRhdGEsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHJ1bGVzIHRvIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMudG9TdHJpbmcob3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5cbnZhciBQbHVnaW5zUmVnaXN0cnkgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQbHVnaW5zUmVnaXN0cnkoKSB7XG4gICAgdGhpcy5wbHVnaW5zID0ge1xuICAgICAgaW50ZXJuYWw6IFtdLFxuICAgICAgZXh0ZXJuYWw6IFtdXG4gICAgfTtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0ge307XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUGx1Z2luc1JlZ2lzdHJ5LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQ2FsbCBgb25DcmVhdGVSdWxlYCBob29rcyBhbmQgcmV0dXJuIGFuIG9iamVjdCBpZiByZXR1cm5lZCBieSBhIGhvb2suXG4gICAqL1xuICBfcHJvdG8ub25DcmVhdGVSdWxlID0gZnVuY3Rpb24gb25DcmVhdGVSdWxlKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25DcmVhdGVSdWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcnVsZSA9IHRoaXMucmVnaXN0cnkub25DcmVhdGVSdWxlW2ldKG5hbWUsIGRlY2wsIG9wdGlvbnMpO1xuICAgICAgaWYgKHJ1bGUpIHJldHVybiBydWxlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIGBvblByb2Nlc3NSdWxlYCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25Qcm9jZXNzUnVsZSA9IGZ1bmN0aW9uIG9uUHJvY2Vzc1J1bGUocnVsZSkge1xuICAgIGlmIChydWxlLmlzUHJvY2Vzc2VkKSByZXR1cm47XG4gICAgdmFyIHNoZWV0ID0gcnVsZS5vcHRpb25zLnNoZWV0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1J1bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucmVnaXN0cnkub25Qcm9jZXNzUnVsZVtpXShydWxlLCBzaGVldCk7XG4gICAgfVxuXG4gICAgaWYgKHJ1bGUuc3R5bGUpIHRoaXMub25Qcm9jZXNzU3R5bGUocnVsZS5zdHlsZSwgcnVsZSwgc2hlZXQpO1xuICAgIHJ1bGUuaXNQcm9jZXNzZWQgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIGBvblByb2Nlc3NTdHlsZWAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uUHJvY2Vzc1N0eWxlID0gZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUsIHNoZWV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1N0eWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBydWxlLnN0eWxlID0gdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NTdHlsZVtpXShydWxlLnN0eWxlLCBydWxlLCBzaGVldCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsIGBvblByb2Nlc3NTaGVldGAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uUHJvY2Vzc1NoZWV0ID0gZnVuY3Rpb24gb25Qcm9jZXNzU2hlZXQoc2hlZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzU2hlZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucmVnaXN0cnkub25Qcm9jZXNzU2hlZXRbaV0oc2hlZXQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25VcGRhdGVgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblVwZGF0ZSA9IGZ1bmN0aW9uIG9uVXBkYXRlKGRhdGEsIHJ1bGUsIHNoZWV0LCBvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uVXBkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJ5Lm9uVXBkYXRlW2ldKGRhdGEsIHJ1bGUsIHNoZWV0LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uQ2hhbmdlVmFsdWVgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vbkNoYW5nZVZhbHVlID0gZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCwgcnVsZSkge1xuICAgIHZhciBwcm9jZXNzZWRWYWx1ZSA9IHZhbHVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uQ2hhbmdlVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb2Nlc3NlZFZhbHVlID0gdGhpcy5yZWdpc3RyeS5vbkNoYW5nZVZhbHVlW2ldKHByb2Nlc3NlZFZhbHVlLCBwcm9wLCBydWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvY2Vzc2VkVmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgcGx1Z2luLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51c2UgPSBmdW5jdGlvbiB1c2UobmV3UGx1Z2luLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgcXVldWU6ICdleHRlcm5hbCdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHBsdWdpbnMgPSB0aGlzLnBsdWdpbnNbb3B0aW9ucy5xdWV1ZV07IC8vIEF2b2lkcyBhcHBseWluZyBzYW1lIHBsdWdpbiB0d2ljZSwgYXQgbGVhc3QgYmFzZWQgb24gcmVmLlxuXG4gICAgaWYgKHBsdWdpbnMuaW5kZXhPZihuZXdQbHVnaW4pICE9PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBsdWdpbnMucHVzaChuZXdQbHVnaW4pO1xuICAgIHRoaXMucmVnaXN0cnkgPSBbXS5jb25jYXQodGhpcy5wbHVnaW5zLmV4dGVybmFsLCB0aGlzLnBsdWdpbnMuaW50ZXJuYWwpLnJlZHVjZShmdW5jdGlvbiAocmVnaXN0cnksIHBsdWdpbikge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBwbHVnaW4pIHtcbiAgICAgICAgaWYgKG5hbWUgaW4gcmVnaXN0cnkpIHtcbiAgICAgICAgICByZWdpc3RyeVtuYW1lXS5wdXNoKHBsdWdpbltuYW1lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBVbmtub3duIGhvb2sgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIikgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2lzdHJ5O1xuICAgIH0sIHtcbiAgICAgIG9uQ3JlYXRlUnVsZTogW10sXG4gICAgICBvblByb2Nlc3NSdWxlOiBbXSxcbiAgICAgIG9uUHJvY2Vzc1N0eWxlOiBbXSxcbiAgICAgIG9uUHJvY2Vzc1NoZWV0OiBbXSxcbiAgICAgIG9uQ2hhbmdlVmFsdWU6IFtdLFxuICAgICAgb25VcGRhdGU6IFtdXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFBsdWdpbnNSZWdpc3RyeTtcbn0oKTtcblxuLyoqXG4gKiBTaGVldHMgcmVnaXN0cnkgdG8gYWNjZXNzIGFsbCBpbnN0YW5jZXMgaW4gb25lIHBsYWNlLlxuICovXG5cbnZhciBTaGVldHNSZWdpc3RyeSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNoZWV0c1JlZ2lzdHJ5KCkge1xuICAgIHRoaXMucmVnaXN0cnkgPSBbXTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTaGVldHNSZWdpc3RyeS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgU3R5bGUgU2hlZXQuXG4gICAqL1xuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKHNoZWV0KSB7XG4gICAgdmFyIHJlZ2lzdHJ5ID0gdGhpcy5yZWdpc3RyeTtcbiAgICB2YXIgaW5kZXggPSBzaGVldC5vcHRpb25zLmluZGV4O1xuICAgIGlmIChyZWdpc3RyeS5pbmRleE9mKHNoZWV0KSAhPT0gLTEpIHJldHVybjtcblxuICAgIGlmIChyZWdpc3RyeS5sZW5ndGggPT09IDAgfHwgaW5kZXggPj0gdGhpcy5pbmRleCkge1xuICAgICAgcmVnaXN0cnkucHVzaChzaGVldCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGaW5kIGEgcG9zaXRpb24uXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWdpc3RyeVtpXS5vcHRpb25zLmluZGV4ID4gaW5kZXgpIHtcbiAgICAgICAgcmVnaXN0cnkuc3BsaWNlKGksIDAsIHNoZWV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVzZXQgdGhlIHJlZ2lzdHJ5LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMucmVnaXN0cnkgPSBbXTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGEgU3R5bGUgU2hlZXQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShzaGVldCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMucmVnaXN0cnkuaW5kZXhPZihzaGVldCk7XG4gICAgdGhpcy5yZWdpc3RyeS5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IGFsbCBhdHRhY2hlZCBzaGVldHMgdG8gYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKF90ZW1wKSB7XG4gICAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgICAgYXR0YWNoZWQgPSBfcmVmLmF0dGFjaGVkLFxuICAgICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgW1wiYXR0YWNoZWRcIl0pO1xuXG4gICAgdmFyIF9nZXRXaGl0ZXNwYWNlU3ltYm9scyA9IGdldFdoaXRlc3BhY2VTeW1ib2xzKG9wdGlvbnMpLFxuICAgICAgICBsaW5lYnJlYWsgPSBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMubGluZWJyZWFrO1xuXG4gICAgdmFyIGNzcyA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2hlZXQgPSB0aGlzLnJlZ2lzdHJ5W2ldO1xuXG4gICAgICBpZiAoYXR0YWNoZWQgIT0gbnVsbCAmJiBzaGVldC5hdHRhY2hlZCAhPT0gYXR0YWNoZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjc3MpIGNzcyArPSBsaW5lYnJlYWs7XG4gICAgICBjc3MgKz0gc2hlZXQudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNzcztcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU2hlZXRzUmVnaXN0cnksIFt7XG4gICAga2V5OiBcImluZGV4XCIsXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGhpZ2hlc3QgaW5kZXggbnVtYmVyLlxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnkubGVuZ3RoID09PSAwID8gMCA6IHRoaXMucmVnaXN0cnlbdGhpcy5yZWdpc3RyeS5sZW5ndGggLSAxXS5vcHRpb25zLmluZGV4O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTaGVldHNSZWdpc3RyeTtcbn0oKTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgZ2xvYmFsIHNoZWV0cyByZWdpc3RyeS4gT25seSBEb21SZW5kZXJlciB3aWxsIGFkZCBzaGVldHMgdG8gaXQuXG4gKiBPbiB0aGUgc2VydmVyIG9uZSBzaG91bGQgdXNlIGFuIG93biBTaGVldHNSZWdpc3RyeSBpbnN0YW5jZSBhbmQgYWRkIHRoZVxuICogc2hlZXRzIHRvIGl0LCBiZWNhdXNlIHlvdSBuZWVkIHRvIG1ha2Ugc3VyZSB0byBjcmVhdGUgYSBuZXcgcmVnaXN0cnkgZm9yXG4gKiBlYWNoIHJlcXVlc3QgaW4gb3JkZXIgdG8gbm90IGxlYWsgc2hlZXRzIGFjcm9zcyByZXF1ZXN0cy5cbiAqL1xuXG52YXIgc2hlZXRzID0gbmV3IFNoZWV0c1JlZ2lzdHJ5KCk7XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbi8qKlxuICogTm93IHRoYXQgYGdsb2JhbFRoaXNgIGlzIGF2YWlsYWJsZSBvbiBtb3N0IHBsYXRmb3Jtc1xuICogKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL2dsb2JhbFRoaXMjYnJvd3Nlcl9jb21wYXRpYmlsaXR5KVxuICogd2UgY2hlY2sgZm9yIGBnbG9iYWxUaGlzYCBmaXJzdC4gYGdsb2JhbFRoaXNgIGlzIG5lY2Vzc2FyeSBmb3IganNzXG4gKiB0byBydW4gaW4gQWdvcmljJ3Mgc2VjdXJlIHZlcnNpb24gb2YgSmF2YVNjcmlwdCAoU0VTKS4gVW5kZXIgU0VTLFxuICogYGdsb2JhbFRoaXNgIGV4aXN0cywgYnV0IGB3aW5kb3dgLCBgc2VsZmAsIGFuZCBgRnVuY3Rpb24oJ3JldHVyblxuICogdGhpcycpKClgIGFyZSBhbGwgdW5kZWZpbmVkIGZvciBzZWN1cml0eSByZWFzb25zLlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG4gKi9cbnZhciBnbG9iYWxUaGlzJDEgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT09IE1hdGggPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbnZhciBucyA9ICcyZjFhY2M2YzNhNjA2YjA4MmU1ZWVmNWU1NDQxNGZmYic7XG5pZiAoZ2xvYmFsVGhpcyQxW25zXSA9PSBudWxsKSBnbG9iYWxUaGlzJDFbbnNdID0gMDsgLy8gQnVuZGxlIG1heSBjb250YWluIG11bHRpcGxlIEpTUyB2ZXJzaW9ucyBhdCB0aGUgc2FtZSB0aW1lLiBJbiBvcmRlciB0byBpZGVudGlmeVxuLy8gdGhlIGN1cnJlbnQgdmVyc2lvbiB3aXRoIGp1c3Qgb25lIHNob3J0IG51bWJlciBhbmQgdXNlIGl0IGZvciBjbGFzc2VzIGdlbmVyYXRpb25cbi8vIHdlIHVzZSBhIGNvdW50ZXIuIEFsc28gaXQgaXMgbW9yZSBhY2N1cmF0ZSwgYmVjYXVzZSB1c2VyIGNhbiBtYW51YWxseSByZWV2YWx1YXRlXG4vLyB0aGUgbW9kdWxlLlxuXG52YXIgbW9kdWxlSWQgPSBnbG9iYWxUaGlzJDFbbnNdKys7XG5cbnZhciBtYXhSdWxlcyA9IDFlMTA7XG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBnZW5lcmF0ZXMgdW5pcXVlIGNsYXNzIG5hbWVzIGJhc2VkIG9uIGNvdW50ZXJzLlxuICogV2hlbiBuZXcgZ2VuZXJhdG9yIGZ1bmN0aW9uIGlzIGNyZWF0ZWQsIHJ1bGUgY291bnRlciBpcyByZXNldGVkLlxuICogV2UgbmVlZCB0byByZXNldCB0aGUgcnVsZSBjb3VudGVyIGZvciBTU1IgZm9yIGVhY2ggcmVxdWVzdC5cbiAqL1xuXG52YXIgY3JlYXRlR2VuZXJhdGVJZCA9IGZ1bmN0aW9uIGNyZWF0ZUdlbmVyYXRlSWQob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHJ1bGVDb3VudGVyID0gMDtcblxuICB2YXIgZ2VuZXJhdGVJZCA9IGZ1bmN0aW9uIGdlbmVyYXRlSWQocnVsZSwgc2hlZXQpIHtcbiAgICBydWxlQ291bnRlciArPSAxO1xuXG4gICAgaWYgKHJ1bGVDb3VudGVyID4gbWF4UnVsZXMpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gWW91IG1pZ2h0IGhhdmUgYSBtZW1vcnkgbGVhay4gUnVsZSBjb3VudGVyIGlzIGF0IFwiICsgcnVsZUNvdW50ZXIgKyBcIi5cIikgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIGpzc0lkID0gJyc7XG4gICAgdmFyIHByZWZpeCA9ICcnO1xuXG4gICAgaWYgKHNoZWV0KSB7XG4gICAgICBpZiAoc2hlZXQub3B0aW9ucy5jbGFzc05hbWVQcmVmaXgpIHtcbiAgICAgICAgcHJlZml4ID0gc2hlZXQub3B0aW9ucy5jbGFzc05hbWVQcmVmaXg7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGVldC5vcHRpb25zLmpzcy5pZCAhPSBudWxsKSB7XG4gICAgICAgIGpzc0lkID0gU3RyaW5nKHNoZWV0Lm9wdGlvbnMuanNzLmlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5taW5pZnkpIHtcbiAgICAgIC8vIFVzaW5nIFwiY1wiIGJlY2F1c2UgYSBudW1iZXIgY2FuJ3QgYmUgdGhlIGZpcnN0IGNoYXIgaW4gYSBjbGFzcyBuYW1lLlxuICAgICAgcmV0dXJuIFwiXCIgKyAocHJlZml4IHx8ICdjJykgKyBtb2R1bGVJZCArIGpzc0lkICsgcnVsZUNvdW50ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZpeCArIHJ1bGUua2V5ICsgXCItXCIgKyBtb2R1bGVJZCArIChqc3NJZCA/IFwiLVwiICsganNzSWQgOiAnJykgKyBcIi1cIiArIHJ1bGVDb3VudGVyO1xuICB9O1xuXG4gIHJldHVybiBnZW5lcmF0ZUlkO1xufTtcblxuLyoqXG4gKiBDYWNoZSB0aGUgdmFsdWUgZnJvbSB0aGUgZmlyc3QgdGltZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAqL1xuXG52YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgdmFyIHZhbHVlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdmFsdWUpIHZhbHVlID0gZm4oKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59O1xuLyoqXG4gKiBHZXQgYSBzdHlsZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuXG5cbnZhciBnZXRQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24gZ2V0UHJvcGVydHlWYWx1ZShjc3NSdWxlLCBwcm9wKSB7XG4gIHRyeSB7XG4gICAgLy8gU3VwcG9ydCBDU1NUT00uXG4gICAgaWYgKGNzc1J1bGUuYXR0cmlidXRlU3R5bGVNYXApIHtcbiAgICAgIHJldHVybiBjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwLmdldChwcm9wKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzUnVsZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJRSBtYXkgdGhyb3cgaWYgcHJvcGVydHkgaXMgdW5rbm93bi5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG4vKipcbiAqIFNldCBhIHN0eWxlIHByb3BlcnR5LlxuICovXG5cblxudmFyIHNldFByb3BlcnR5ID0gZnVuY3Rpb24gc2V0UHJvcGVydHkoY3NzUnVsZSwgcHJvcCwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgY3NzVmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgY3NzVmFsdWUgPSB0b0Nzc1ZhbHVlKHZhbHVlKTtcbiAgICB9IC8vIFN1cHBvcnQgQ1NTVE9NLlxuXG5cbiAgICBpZiAoY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcCkge1xuICAgICAgY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcC5zZXQocHJvcCwgY3NzVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5kZXhPZkltcG9ydGFudEZsYWcgPSBjc3NWYWx1ZSA/IGNzc1ZhbHVlLmluZGV4T2YoJyFpbXBvcnRhbnQnKSA6IC0xO1xuICAgICAgdmFyIGNzc1ZhbHVlV2l0aG91dEltcG9ydGFudEZsYWcgPSBpbmRleE9mSW1wb3J0YW50RmxhZyA+IC0xID8gY3NzVmFsdWUuc3Vic3RyKDAsIGluZGV4T2ZJbXBvcnRhbnRGbGFnIC0gMSkgOiBjc3NWYWx1ZTtcbiAgICAgIGNzc1J1bGUuc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgY3NzVmFsdWVXaXRob3V0SW1wb3J0YW50RmxhZywgaW5kZXhPZkltcG9ydGFudEZsYWcgPiAtMSA/ICdpbXBvcnRhbnQnIDogJycpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSUUgbWF5IHRocm93IGlmIHByb3BlcnR5IGlzIHVua25vd24uXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBSZW1vdmUgYSBzdHlsZSBwcm9wZXJ0eS5cbiAqL1xuXG5cbnZhciByZW1vdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIHJlbW92ZVByb3BlcnR5KGNzc1J1bGUsIHByb3ApIHtcbiAgdHJ5IHtcbiAgICAvLyBTdXBwb3J0IENTU1RPTS5cbiAgICBpZiAoY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcCkge1xuICAgICAgY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcC5kZWxldGUocHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNzc1J1bGUuc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIERPTUV4Y2VwdGlvbiBcXFwiXCIgKyBlcnIubWVzc2FnZSArIFwiXFxcIiB3YXMgdGhyb3duLiBUcmllZCB0byByZW1vdmUgcHJvcGVydHkgXFxcIlwiICsgcHJvcCArIFwiXFxcIi5cIikgOiB2b2lkIDA7XG4gIH1cbn07XG4vKipcbiAqIFNldCB0aGUgc2VsZWN0b3IuXG4gKi9cblxuXG52YXIgc2V0U2VsZWN0b3IgPSBmdW5jdGlvbiBzZXRTZWxlY3Rvcihjc3NSdWxlLCBzZWxlY3RvclRleHQpIHtcbiAgY3NzUnVsZS5zZWxlY3RvclRleHQgPSBzZWxlY3RvclRleHQ7IC8vIFJldHVybiBmYWxzZSBpZiBzZXR0ZXIgd2FzIG5vdCBzdWNjZXNzZnVsLlxuICAvLyBDdXJyZW50bHkgd29ya3MgaW4gY2hyb21lIG9ubHkuXG5cbiAgcmV0dXJuIGNzc1J1bGUuc2VsZWN0b3JUZXh0ID09PSBzZWxlY3RvclRleHQ7XG59O1xuLyoqXG4gKiBHZXRzIHRoZSBgaGVhZGAgZWxlbWVudCB1cG9uIHRoZSBmaXJzdCBjYWxsIGFuZCBjYWNoZXMgaXQuXG4gKiBXZSBhc3N1bWUgaXQgY2FuJ3QgYmUgbnVsbC5cbiAqL1xuXG5cbnZhciBnZXRIZWFkID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkJyk7XG59KTtcbi8qKlxuICogRmluZCBhdHRhY2hlZCBzaGVldCB3aXRoIGFuIGluZGV4IGhpZ2hlciB0aGFuIHRoZSBwYXNzZWQgb25lLlxuICovXG5cbmZ1bmN0aW9uIGZpbmRIaWdoZXJTaGVldChyZWdpc3RyeSwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNoZWV0ID0gcmVnaXN0cnlbaV07XG5cbiAgICBpZiAoc2hlZXQuYXR0YWNoZWQgJiYgc2hlZXQub3B0aW9ucy5pbmRleCA+IG9wdGlvbnMuaW5kZXggJiYgc2hlZXQub3B0aW9ucy5pbnNlcnRpb25Qb2ludCA9PT0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludCkge1xuICAgICAgcmV0dXJuIHNoZWV0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBGaW5kIGF0dGFjaGVkIHNoZWV0IHdpdGggdGhlIGhpZ2hlc3QgaW5kZXguXG4gKi9cblxuXG5mdW5jdGlvbiBmaW5kSGlnaGVzdFNoZWV0KHJlZ2lzdHJ5LCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSByZWdpc3RyeS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBzaGVldCA9IHJlZ2lzdHJ5W2ldO1xuXG4gICAgaWYgKHNoZWV0LmF0dGFjaGVkICYmIHNoZWV0Lm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgPT09IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQpIHtcbiAgICAgIHJldHVybiBzaGVldDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogRmluZCBhIGNvbW1lbnQgd2l0aCBcImpzc1wiIGluc2lkZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmRDb21tZW50Tm9kZSh0ZXh0KSB7XG4gIHZhciBoZWFkID0gZ2V0SGVhZCgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBoZWFkLmNoaWxkTm9kZXNbaV07XG5cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZS50cmltKCkgPT09IHRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBGaW5kIGEgbm9kZSBiZWZvcmUgd2hpY2ggd2UgY2FuIGluc2VydCB0aGUgc2hlZXQuXG4gKi9cblxuXG5mdW5jdGlvbiBmaW5kUHJldk5vZGUob3B0aW9ucykge1xuICB2YXIgcmVnaXN0cnkgPSBzaGVldHMucmVnaXN0cnk7XG5cbiAgaWYgKHJlZ2lzdHJ5Lmxlbmd0aCA+IDApIHtcbiAgICAvLyBUcnkgdG8gaW5zZXJ0IGJlZm9yZSB0aGUgbmV4dCBoaWdoZXIgc2hlZXQuXG4gICAgdmFyIHNoZWV0ID0gZmluZEhpZ2hlclNoZWV0KHJlZ2lzdHJ5LCBvcHRpb25zKTtcblxuICAgIGlmIChzaGVldCAmJiBzaGVldC5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFyZW50OiBzaGVldC5yZW5kZXJlci5lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICAgIG5vZGU6IHNoZWV0LnJlbmRlcmVyLmVsZW1lbnRcbiAgICAgIH07XG4gICAgfSAvLyBPdGhlcndpc2UgaW5zZXJ0IGFmdGVyIHRoZSBsYXN0IGF0dGFjaGVkLlxuXG5cbiAgICBzaGVldCA9IGZpbmRIaWdoZXN0U2hlZXQocmVnaXN0cnksIG9wdGlvbnMpO1xuXG4gICAgaWYgKHNoZWV0ICYmIHNoZWV0LnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJlbnQ6IHNoZWV0LnJlbmRlcmVyLmVsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgbm9kZTogc2hlZXQucmVuZGVyZXIuZWxlbWVudC5uZXh0U2libGluZ1xuICAgICAgfTtcbiAgICB9XG4gIH0gLy8gVHJ5IHRvIGZpbmQgYSBjb21tZW50IHBsYWNlaG9sZGVyIGlmIHJlZ2lzdHJ5IGlzIGVtcHR5LlxuXG5cbiAgdmFyIGluc2VydGlvblBvaW50ID0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludDtcblxuICBpZiAoaW5zZXJ0aW9uUG9pbnQgJiYgdHlwZW9mIGluc2VydGlvblBvaW50ID09PSAnc3RyaW5nJykge1xuICAgIHZhciBjb21tZW50ID0gZmluZENvbW1lbnROb2RlKGluc2VydGlvblBvaW50KTtcblxuICAgIGlmIChjb21tZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJlbnQ6IGNvbW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgbm9kZTogY29tbWVudC5uZXh0U2libGluZ1xuICAgICAgfTtcbiAgICB9IC8vIElmIHVzZXIgc3BlY2lmaWVzIGFuIGluc2VydGlvbiBwb2ludCBhbmQgaXQgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIGRvY3VtZW50IC1cbiAgICAvLyBiYWQgc3BlY2lmaWNpdHkgaXNzdWVzIG1heSBhcHBlYXIuXG5cblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gSW5zZXJ0aW9uIHBvaW50IFxcXCJcIiArIGluc2VydGlvblBvaW50ICsgXCJcXFwiIG5vdCBmb3VuZC5cIikgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEluc2VydCBzdHlsZSBlbGVtZW50IGludG8gdGhlIERPTS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlKHN0eWxlLCBvcHRpb25zKSB7XG4gIHZhciBpbnNlcnRpb25Qb2ludCA9IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQ7XG4gIHZhciBuZXh0Tm9kZSA9IGZpbmRQcmV2Tm9kZShvcHRpb25zKTtcblxuICBpZiAobmV4dE5vZGUgIT09IGZhbHNlICYmIG5leHROb2RlLnBhcmVudCkge1xuICAgIG5leHROb2RlLnBhcmVudC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHROb2RlLm5vZGUpO1xuICAgIHJldHVybjtcbiAgfSAvLyBXb3JrcyB3aXRoIGlmcmFtZXMgYW5kIGFueSBub2RlIHR5cGVzLlxuXG5cbiAgaWYgKGluc2VydGlvblBvaW50ICYmIHR5cGVvZiBpbnNlcnRpb25Qb2ludC5ub2RlVHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgaW5zZXJ0aW9uUG9pbnRFbGVtZW50ID0gaW5zZXJ0aW9uUG9pbnQ7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBpbnNlcnRpb25Qb2ludEVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGUsIGluc2VydGlvblBvaW50RWxlbWVudC5uZXh0U2libGluZyk7ZWxzZSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAnW0pTU10gSW5zZXJ0aW9uIHBvaW50IGlzIG5vdCBpbiB0aGUgRE9NLicpIDogdm9pZCAwO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGdldEhlYWQoKS5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG4vKipcbiAqIFJlYWQganNzIG5vbmNlIHNldHRpbmcgZnJvbSB0aGUgcGFnZSBpZiB0aGUgdXNlciBoYXMgc2V0IGl0LlxuICovXG5cblxudmFyIGdldE5vbmNlID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtwcm9wZXJ0eT1cImNzcC1ub25jZVwiXScpO1xuICByZXR1cm4gbm9kZSA/IG5vZGUuZ2V0QXR0cmlidXRlKCdjb250ZW50JykgOiBudWxsO1xufSk7XG5cbnZhciBfaW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIGluc2VydFJ1bGUoY29udGFpbmVyLCBydWxlLCBpbmRleCkge1xuICB0cnkge1xuICAgIGlmICgnaW5zZXJ0UnVsZScgaW4gY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXIuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gICAgfSAvLyBLZXlmcmFtZXMgcnVsZS5cbiAgICBlbHNlIGlmICgnYXBwZW5kUnVsZScgaW4gY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRSdWxlKHJ1bGUpO1xuICAgICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFwiICsgZXJyLm1lc3NhZ2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBjb250YWluZXIuY3NzUnVsZXNbaW5kZXhdO1xufTtcblxudmFyIGdldFZhbGlkUnVsZUluc2VydGlvbkluZGV4ID0gZnVuY3Rpb24gZ2V0VmFsaWRSdWxlSW5zZXJ0aW9uSW5kZXgoY29udGFpbmVyLCBpbmRleCkge1xuICB2YXIgbWF4SW5kZXggPSBjb250YWluZXIuY3NzUnVsZXMubGVuZ3RoOyAvLyBJbiBjYXNlIHByZXZpb3VzIGluc2VydGlvbiBmYWlscywgcGFzc2VkIGluZGV4IG1pZ2h0IGJlIHdyb25nXG5cbiAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHwgaW5kZXggPiBtYXhJbmRleCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHJldHVybiBtYXhJbmRleDtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG5cbnZhciBjcmVhdGVTdHlsZSA9IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlKCkge1xuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpOyAvLyBXaXRob3V0IGl0LCBJRSB3aWxsIGhhdmUgYSBicm9rZW4gc291cmNlIG9yZGVyIHNwZWNpZmljaXR5IGlmIHdlXG4gIC8vIGluc2VydCBydWxlcyBhZnRlciB3ZSBpbnNlcnQgdGhlIHN0eWxlIHRhZy5cbiAgLy8gSXQgc2VlbXMgdG8ga2ljay1vZmYgdGhlIHNvdXJjZSBvcmRlciBzcGVjaWZpY2l0eSBhbGdvcml0aG0uXG5cbiAgZWwudGV4dENvbnRlbnQgPSAnXFxuJztcbiAgcmV0dXJuIGVsO1xufTtcblxudmFyIERvbVJlbmRlcmVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLy8gV2lsbCBiZSBlbXB0eSBpZiBsaW5rOiB0cnVlIG9wdGlvbiBpcyBub3Qgc2V0LCBiZWNhdXNlXG4gIC8vIGl0IGlzIG9ubHkgZm9yIHVzZSB0b2dldGhlciB3aXRoIGluc2VydFJ1bGUgQVBJLlxuICBmdW5jdGlvbiBEb21SZW5kZXJlcihzaGVldCkge1xuICAgIHRoaXMuZ2V0UHJvcGVydHlWYWx1ZSA9IGdldFByb3BlcnR5VmFsdWU7XG4gICAgdGhpcy5zZXRQcm9wZXJ0eSA9IHNldFByb3BlcnR5O1xuICAgIHRoaXMucmVtb3ZlUHJvcGVydHkgPSByZW1vdmVQcm9wZXJ0eTtcbiAgICB0aGlzLnNldFNlbGVjdG9yID0gc2V0U2VsZWN0b3I7XG4gICAgdGhpcy5oYXNJbnNlcnRlZFJ1bGVzID0gZmFsc2U7XG4gICAgdGhpcy5jc3NSdWxlcyA9IFtdO1xuICAgIC8vIFRoZXJlIGlzIG5vIHNoZWV0IHdoZW4gdGhlIHJlbmRlcmVyIGlzIHVzZWQgZnJvbSBhIHN0YW5kYWxvbmUgU3R5bGVSdWxlLlxuICAgIGlmIChzaGVldCkgc2hlZXRzLmFkZChzaGVldCk7XG4gICAgdGhpcy5zaGVldCA9IHNoZWV0O1xuXG4gICAgdmFyIF9yZWYgPSB0aGlzLnNoZWV0ID8gdGhpcy5zaGVldC5vcHRpb25zIDoge30sXG4gICAgICAgIG1lZGlhID0gX3JlZi5tZWRpYSxcbiAgICAgICAgbWV0YSA9IF9yZWYubWV0YSxcbiAgICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudDtcblxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQgfHwgY3JlYXRlU3R5bGUoKTtcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWpzcycsICcnKTtcbiAgICBpZiAobWVkaWEpIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICAgIGlmIChtZXRhKSB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLW1ldGEnLCBtZXRhKTtcbiAgICB2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuICAgIGlmIChub25jZSkgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBzdHlsZSBlbGVtZW50IGludG8gcmVuZGVyIHRyZWUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IERvbVJlbmRlcmVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYXR0YWNoID0gZnVuY3Rpb24gYXR0YWNoKCkge1xuICAgIC8vIEluIHRoZSBjYXNlIHRoZSBlbGVtZW50IG5vZGUgaXMgZXh0ZXJuYWwgYW5kIGl0IGlzIGFscmVhZHkgaW4gdGhlIERPTS5cbiAgICBpZiAodGhpcy5lbGVtZW50LnBhcmVudE5vZGUgfHwgIXRoaXMuc2hlZXQpIHJldHVybjtcbiAgICBpbnNlcnRTdHlsZSh0aGlzLmVsZW1lbnQsIHRoaXMuc2hlZXQub3B0aW9ucyk7IC8vIFdoZW4gcnVsZXMgYXJlIGluc2VydGVkIHVzaW5nIGBpbnNlcnRSdWxlYCBBUEksIGFmdGVyIGBzaGVldC5kZXRhY2goKS5hdHRhY2goKWBcbiAgICAvLyBtb3N0IGJyb3dzZXJzIGNyZWF0ZSBhIG5ldyBDU1NTdHlsZVNoZWV0LCBleGNlcHQgb2YgYWxsIElFcy5cblxuICAgIHZhciBkZXBsb3llZCA9IEJvb2xlYW4odGhpcy5zaGVldCAmJiB0aGlzLnNoZWV0LmRlcGxveWVkKTtcblxuICAgIGlmICh0aGlzLmhhc0luc2VydGVkUnVsZXMgJiYgZGVwbG95ZWQpIHtcbiAgICAgIHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcyA9IGZhbHNlO1xuICAgICAgdGhpcy5kZXBsb3koKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBzdHlsZSBlbGVtZW50IGZyb20gcmVuZGVyIHRyZWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRldGFjaCA9IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICBpZiAoIXRoaXMuc2hlZXQpIHJldHVybjtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMuZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7IC8vIEluIHRoZSBtb3N0IGJyb3dzZXJzLCBydWxlcyBpbnNlcnRlZCB1c2luZyBpbnNlcnRSdWxlKCkgQVBJIHdpbGwgYmUgbG9zdCB3aGVuIHN0eWxlIGVsZW1lbnQgaXMgcmVtb3ZlZC5cbiAgICAvLyBUaG91Z2ggSUUgd2lsbCBrZWVwIHRoZW0gYW5kIHdlIG5lZWQgYSBjb25zaXN0ZW50IGJlaGF2aW9yLlxuXG4gICAgaWYgKHRoaXMuc2hlZXQub3B0aW9ucy5saW5rKSB7XG4gICAgICB0aGlzLmNzc1J1bGVzID0gW107XG4gICAgICB0aGlzLmVsZW1lbnQudGV4dENvbnRlbnQgPSAnXFxuJztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluamVjdCBDU1Mgc3RyaW5nIGludG8gZWxlbWVudC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVwbG95ID0gZnVuY3Rpb24gZGVwbG95KCkge1xuICAgIHZhciBzaGVldCA9IHRoaXMuc2hlZXQ7XG4gICAgaWYgKCFzaGVldCkgcmV0dXJuO1xuXG4gICAgaWYgKHNoZWV0Lm9wdGlvbnMubGluaykge1xuICAgICAgdGhpcy5pbnNlcnRSdWxlcyhzaGVldC5ydWxlcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LnRleHRDb250ZW50ID0gXCJcXG5cIiArIHNoZWV0LnRvU3RyaW5nKCkgKyBcIlxcblwiO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgUnVsZUxpc3QgaW50byBhbiBlbGVtZW50LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbnNlcnRSdWxlcyA9IGZ1bmN0aW9uIGluc2VydFJ1bGVzKHJ1bGVzLCBuYXRpdmVQYXJlbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmluZGV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmluc2VydFJ1bGUocnVsZXMuaW5kZXhbaV0sIGksIG5hdGl2ZVBhcmVudCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgYSBydWxlIGludG8gZWxlbWVudC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIGluc2VydFJ1bGUocnVsZSwgaW5kZXgsIG5hdGl2ZVBhcmVudCkge1xuICAgIGlmIChuYXRpdmVQYXJlbnQgPT09IHZvaWQgMCkge1xuICAgICAgbmF0aXZlUGFyZW50ID0gdGhpcy5lbGVtZW50LnNoZWV0O1xuICAgIH1cblxuICAgIGlmIChydWxlLnJ1bGVzKSB7XG4gICAgICB2YXIgcGFyZW50ID0gcnVsZTtcbiAgICAgIHZhciBsYXRlc3ROYXRpdmVQYXJlbnQgPSBuYXRpdmVQYXJlbnQ7XG5cbiAgICAgIGlmIChydWxlLnR5cGUgPT09ICdjb25kaXRpb25hbCcgfHwgcnVsZS50eXBlID09PSAna2V5ZnJhbWVzJykge1xuICAgICAgICB2YXIgX2luc2VydGlvbkluZGV4ID0gZ2V0VmFsaWRSdWxlSW5zZXJ0aW9uSW5kZXgobmF0aXZlUGFyZW50LCBpbmRleCk7IC8vIFdlIG5lZWQgdG8gcmVuZGVyIHRoZSBjb250YWluZXIgd2l0aG91dCBjaGlsZHJlbiBmaXJzdC5cblxuXG4gICAgICAgIGxhdGVzdE5hdGl2ZVBhcmVudCA9IF9pbnNlcnRSdWxlKG5hdGl2ZVBhcmVudCwgcGFyZW50LnRvU3RyaW5nKHtcbiAgICAgICAgICBjaGlsZHJlbjogZmFsc2VcbiAgICAgICAgfSksIF9pbnNlcnRpb25JbmRleCk7XG5cbiAgICAgICAgaWYgKGxhdGVzdE5hdGl2ZVBhcmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZkNzc1J1bGUocnVsZSwgX2luc2VydGlvbkluZGV4LCBsYXRlc3ROYXRpdmVQYXJlbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluc2VydFJ1bGVzKHBhcmVudC5ydWxlcywgbGF0ZXN0TmF0aXZlUGFyZW50KTtcbiAgICAgIHJldHVybiBsYXRlc3ROYXRpdmVQYXJlbnQ7XG4gICAgfVxuXG4gICAgdmFyIHJ1bGVTdHIgPSBydWxlLnRvU3RyaW5nKCk7XG4gICAgaWYgKCFydWxlU3RyKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGluc2VydGlvbkluZGV4ID0gZ2V0VmFsaWRSdWxlSW5zZXJ0aW9uSW5kZXgobmF0aXZlUGFyZW50LCBpbmRleCk7XG5cbiAgICB2YXIgbmF0aXZlUnVsZSA9IF9pbnNlcnRSdWxlKG5hdGl2ZVBhcmVudCwgcnVsZVN0ciwgaW5zZXJ0aW9uSW5kZXgpO1xuXG4gICAgaWYgKG5hdGl2ZVJ1bGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5oYXNJbnNlcnRlZFJ1bGVzID0gdHJ1ZTtcbiAgICB0aGlzLnJlZkNzc1J1bGUocnVsZSwgaW5zZXJ0aW9uSW5kZXgsIG5hdGl2ZVJ1bGUpO1xuICAgIHJldHVybiBuYXRpdmVSdWxlO1xuICB9O1xuXG4gIF9wcm90by5yZWZDc3NSdWxlID0gZnVuY3Rpb24gcmVmQ3NzUnVsZShydWxlLCBpbmRleCwgY3NzUnVsZSkge1xuICAgIHJ1bGUucmVuZGVyYWJsZSA9IGNzc1J1bGU7IC8vIFdlIG9ubHkgd2FudCB0byByZWZlcmVuY2UgdGhlIHRvcCBsZXZlbCBydWxlcywgZGVsZXRlUnVsZSBBUEkgZG9lc24ndCBzdXBwb3J0IHJlbW92aW5nIG5lc3RlZCBydWxlc1xuICAgIC8vIGxpa2UgcnVsZXMgaW5zaWRlIG1lZGlhIHF1ZXJpZXMgb3Iga2V5ZnJhbWVzXG5cbiAgICBpZiAocnVsZS5vcHRpb25zLnBhcmVudCBpbnN0YW5jZW9mIFN0eWxlU2hlZXQpIHtcbiAgICAgIHRoaXMuY3NzUnVsZXMuc3BsaWNlKGluZGV4LCAwLCBjc3NSdWxlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiBkZWxldGVSdWxlKGNzc1J1bGUpIHtcbiAgICB2YXIgc2hlZXQgPSB0aGlzLmVsZW1lbnQuc2hlZXQ7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKGNzc1J1bGUpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgICBzaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICB0aGlzLmNzc1J1bGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIENTUyBSdWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihjc3NSdWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuY3NzUnVsZXMuaW5kZXhPZihjc3NSdWxlKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgYSBuZXcgQ1NTIHJ1bGUgYW5kIHJlcGxhY2UgdGhlIGV4aXN0aW5nIG9uZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVwbGFjZVJ1bGUgPSBmdW5jdGlvbiByZXBsYWNlUnVsZShjc3NSdWxlLCBydWxlKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKGNzc1J1bGUpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLmVsZW1lbnQuc2hlZXQuZGVsZXRlUnVsZShpbmRleCk7XG4gICAgdGhpcy5jc3NSdWxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0aGlzLmluc2VydFJ1bGUocnVsZSwgaW5kZXgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIHJ1bGVzIGVsZW1lbnRzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRSdWxlcyA9IGZ1bmN0aW9uIGdldFJ1bGVzKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuc2hlZXQuY3NzUnVsZXM7XG4gIH07XG5cbiAgcmV0dXJuIERvbVJlbmRlcmVyO1xufSgpO1xuXG52YXIgaW5zdGFuY2VDb3VudGVyID0gMDtcblxudmFyIEpzcyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEpzcyhvcHRpb25zKSB7XG4gICAgdGhpcy5pZCA9IGluc3RhbmNlQ291bnRlcisrO1xuICAgIHRoaXMudmVyc2lvbiA9IFwiMTAuMTAuMFwiO1xuICAgIHRoaXMucGx1Z2lucyA9IG5ldyBQbHVnaW5zUmVnaXN0cnkoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBpZDoge1xuICAgICAgICBtaW5pZnk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgY3JlYXRlR2VuZXJhdGVJZDogY3JlYXRlR2VuZXJhdGVJZCxcbiAgICAgIFJlbmRlcmVyOiBpc0luQnJvd3NlciA/IERvbVJlbmRlcmVyIDogbnVsbCxcbiAgICAgIHBsdWdpbnM6IFtdXG4gICAgfTtcbiAgICB0aGlzLmdlbmVyYXRlSWQgPSBjcmVhdGVHZW5lcmF0ZUlkKHtcbiAgICAgIG1pbmlmeTogZmFsc2VcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5wbHVnaW5zLnVzZShwbHVnaW5zW2ldLCB7XG4gICAgICAgIHF1ZXVlOiAnaW50ZXJuYWwnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnNldHVwKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBQcmVwYXJlcyB2YXJpb3VzIG9wdGlvbnMsIGFwcGxpZXMgcGx1Z2lucy5cbiAgICogU2hvdWxkIG5vdCBiZSB1c2VkIHR3aWNlIG9uIHRoZSBzYW1lIGluc3RhbmNlLCBiZWNhdXNlIHRoZXJlIGlzIG5vIHBsdWdpbnNcbiAgICogZGVkdXBsaWNhdGlvbiBsb2dpYy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gSnNzLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0dXAgPSBmdW5jdGlvbiBzZXR1cChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNyZWF0ZUdlbmVyYXRlSWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkID0gb3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmlkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuaWQgPSBfZXh0ZW5kcyh7fSwgdGhpcy5vcHRpb25zLmlkLCBvcHRpb25zLmlkKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkIHx8IG9wdGlvbnMuaWQpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdGVJZCA9IHRoaXMub3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkKHRoaXMub3B0aW9ucy5pZCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgIT0gbnVsbCkgdGhpcy5vcHRpb25zLmluc2VydGlvblBvaW50ID0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludDtcblxuICAgIGlmICgnUmVuZGVyZXInIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5SZW5kZXJlciA9IG9wdGlvbnMuUmVuZGVyZXI7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuXG5cbiAgICBpZiAob3B0aW9ucy5wbHVnaW5zKSB0aGlzLnVzZS5hcHBseSh0aGlzLCBvcHRpb25zLnBsdWdpbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBTdHlsZSBTaGVldC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY3JlYXRlU3R5bGVTaGVldCA9IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlU2hlZXQoc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICAgIGluZGV4ID0gX29wdGlvbnMuaW5kZXg7XG5cbiAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgaW5kZXggPSBzaGVldHMuaW5kZXggPT09IDAgPyAwIDogc2hlZXRzLmluZGV4ICsgMTtcbiAgICB9XG5cbiAgICB2YXIgc2hlZXQgPSBuZXcgU3R5bGVTaGVldChzdHlsZXMsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBqc3M6IHRoaXMsXG4gICAgICBnZW5lcmF0ZUlkOiBvcHRpb25zLmdlbmVyYXRlSWQgfHwgdGhpcy5nZW5lcmF0ZUlkLFxuICAgICAgaW5zZXJ0aW9uUG9pbnQ6IHRoaXMub3B0aW9ucy5pbnNlcnRpb25Qb2ludCxcbiAgICAgIFJlbmRlcmVyOiB0aGlzLm9wdGlvbnMuUmVuZGVyZXIsXG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9KSk7XG4gICAgdGhpcy5wbHVnaW5zLm9uUHJvY2Vzc1NoZWV0KHNoZWV0KTtcbiAgICByZXR1cm4gc2hlZXQ7XG4gIH1cbiAgLyoqXG4gICAqIERldGFjaCB0aGUgU3R5bGUgU2hlZXQgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVtb3ZlU3R5bGVTaGVldCA9IGZ1bmN0aW9uIHJlbW92ZVN0eWxlU2hlZXQoc2hlZXQpIHtcbiAgICBzaGVldC5kZXRhY2goKTtcbiAgICBzaGVldHMucmVtb3ZlKHNoZWV0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgcnVsZSB3aXRob3V0IGEgU3R5bGUgU2hlZXQuXG4gICAqIFtEZXByZWNhdGVkXSB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY3JlYXRlUnVsZSA9IGZ1bmN0aW9uIGNyZWF0ZVJ1bGUkMShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChzdHlsZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdHlsZSA9IHt9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBFbmFibGUgcnVsZSB3aXRob3V0IG5hbWUgZm9yIGlubGluZSBzdHlsZXMuXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUnVsZSh1bmRlZmluZWQsIG5hbWUsIHN0eWxlKTtcbiAgICB9XG5cbiAgICB2YXIgcnVsZU9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGpzczogdGhpcyxcbiAgICAgIFJlbmRlcmVyOiB0aGlzLm9wdGlvbnMuUmVuZGVyZXJcbiAgICB9KTtcblxuICAgIGlmICghcnVsZU9wdGlvbnMuZ2VuZXJhdGVJZCkgcnVsZU9wdGlvbnMuZ2VuZXJhdGVJZCA9IHRoaXMuZ2VuZXJhdGVJZDtcbiAgICBpZiAoIXJ1bGVPcHRpb25zLmNsYXNzZXMpIHJ1bGVPcHRpb25zLmNsYXNzZXMgPSB7fTtcbiAgICBpZiAoIXJ1bGVPcHRpb25zLmtleWZyYW1lcykgcnVsZU9wdGlvbnMua2V5ZnJhbWVzID0ge307XG5cbiAgICB2YXIgcnVsZSA9IGNyZWF0ZVJ1bGUobmFtZSwgc3R5bGUsIHJ1bGVPcHRpb25zKTtcblxuICAgIGlmIChydWxlKSB0aGlzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShydWxlKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgcGx1Z2luLiBQYXNzZWQgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIHdpdGggYSBydWxlIGluc3RhbmNlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51c2UgPSBmdW5jdGlvbiB1c2UoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcGx1Z2luc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgX3RoaXMucGx1Z2lucy51c2UocGx1Z2luKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gSnNzO1xufSgpO1xuXG52YXIgY3JlYXRlSnNzID0gZnVuY3Rpb24gY3JlYXRlSnNzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBKc3Mob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFNoZWV0c01hbmFnZXIgaXMgbGlrZSBhIFdlYWtNYXAgd2hpY2ggaXMgZGVzaWduZWQgdG8gY291bnQgU3R5bGVTaGVldFxuICogaW5zdGFuY2VzIGFuZCBhdHRhY2gvZGV0YWNoIGF1dG9tYXRpY2FsbHkuXG4gKiBVc2VkIGluIHJlYWN0LWpzcy5cbiAqL1xuXG52YXIgU2hlZXRzTWFuYWdlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNoZWV0c01hbmFnZXIoKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuc2hlZXRzID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTaGVldHNNYW5hZ2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuc2hlZXRzLmdldChrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS5zaGVldDtcbiAgfTtcblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKGtleSwgc2hlZXQpIHtcbiAgICBpZiAodGhpcy5zaGVldHMuaGFzKGtleSkpIHJldHVybjtcbiAgICB0aGlzLmxlbmd0aCsrO1xuICAgIHRoaXMuc2hlZXRzLnNldChrZXksIHtcbiAgICAgIHNoZWV0OiBzaGVldCxcbiAgICAgIHJlZnM6IDBcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ubWFuYWdlID0gZnVuY3Rpb24gbWFuYWdlKGtleSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuc2hlZXRzLmdldChrZXkpO1xuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBpZiAoZW50cnkucmVmcyA9PT0gMCkge1xuICAgICAgICBlbnRyeS5zaGVldC5hdHRhY2goKTtcbiAgICAgIH1cblxuICAgICAgZW50cnkucmVmcysrO1xuICAgICAgcmV0dXJuIGVudHJ5LnNoZWV0O1xuICAgIH1cblxuICAgIHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gU2hlZXRzTWFuYWdlcjogY2FuJ3QgZmluZCBzaGVldCB0byBtYW5hZ2VcIik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICBfcHJvdG8udW5tYW5hZ2UgPSBmdW5jdGlvbiB1bm1hbmFnZShrZXkpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLnNoZWV0cy5nZXQoa2V5KTtcblxuICAgIGlmIChlbnRyeSkge1xuICAgICAgaWYgKGVudHJ5LnJlZnMgPiAwKSB7XG4gICAgICAgIGVudHJ5LnJlZnMtLTtcbiAgICAgICAgaWYgKGVudHJ5LnJlZnMgPT09IDApIGVudHJ5LnNoZWV0LmRldGFjaCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCBcIlNoZWV0c01hbmFnZXI6IGNhbid0IGZpbmQgc2hlZXQgdG8gdW5tYW5hZ2VcIik7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTaGVldHNNYW5hZ2VyLCBbe1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNoZWV0c01hbmFnZXI7XG59KCk7XG5cbi8qKlxuKiBFeHBvcnQgYSBjb25zdGFudCBpbmRpY2F0aW5nIGlmIHRoaXMgYnJvd3NlciBoYXMgQ1NTVE9NIHN1cHBvcnQuXG4qIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTgvMDMvY3Nzb21cbiovXG52YXIgaGFzQ1NTVE9NU3VwcG9ydCA9IHR5cGVvZiBDU1MgPT09ICdvYmplY3QnICYmIENTUyAhPSBudWxsICYmICdudW1iZXInIGluIENTUztcblxuLyoqXG4gKiBFeHRyYWN0cyBhIHN0eWxlcyBvYmplY3Qgd2l0aCBvbmx5IHByb3BzIHRoYXQgY29udGFpbiBmdW5jdGlvbiB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldER5bmFtaWNTdHlsZXMoc3R5bGVzKSB7XG4gIHZhciB0byA9IG51bGw7XG5cbiAgZm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuICAgIHZhciB2YWx1ZSA9IHN0eWxlc1trZXldO1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICghdG8pIHRvID0ge307XG4gICAgICB0b1trZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhciBleHRyYWN0ZWQgPSBnZXREeW5hbWljU3R5bGVzKHZhbHVlKTtcblxuICAgICAgaWYgKGV4dHJhY3RlZCkge1xuICAgICAgICBpZiAoIXRvKSB0byA9IHt9O1xuICAgICAgICB0b1trZXldID0gZXh0cmFjdGVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBBIGJldHRlciBhYnN0cmFjdGlvbiBvdmVyIENTUy5cbiAqXG4gKiBAY29weXJpZ2h0IE9sZWcgSXNvbmVuIChTbG9ib2Rza29pKSAvIElzb25lbiAyMDE0LXByZXNlbnRcbiAqIEB3ZWJzaXRlIGh0dHBzOi8vZ2l0aHViLmNvbS9jc3NpbmpzL2pzc1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cbnZhciBpbmRleCA9IGNyZWF0ZUpzcygpO1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbmV4cG9ydCB7IFJ1bGVMaXN0LCBTaGVldHNNYW5hZ2VyLCBTaGVldHNSZWdpc3RyeSwgY3JlYXRlSnNzIGFzIGNyZWF0ZSwgY3JlYXRlR2VuZXJhdGVJZCwgY3JlYXRlUnVsZSwgZ2V0RHluYW1pY1N0eWxlcywgaGFzQ1NTVE9NU3VwcG9ydCwgc2hlZXRzLCB0b0Nzc1ZhbHVlIH07XG4iLCIvKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gU0RQIGhlbHBlcnMuXG5jb25zdCBTRFBVdGlscyA9IHt9O1xuXG4vLyBHZW5lcmF0ZSBhbiBhbHBoYW51bWVyaWMgaWRlbnRpZmllciBmb3IgY25hbWUgb3IgbWlkcy5cbi8vIFRPRE86IHVzZSBVVUlEcyBpbnN0ZWFkPyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qZWQvOTgyODgzXG5TRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMik7XG59O1xuXG4vLyBUaGUgUlRDUCBDTkFNRSB1c2VkIGJ5IGFsbCBwZWVyY29ubmVjdGlvbnMgZnJvbSB0aGUgc2FtZSBKUy5cblNEUFV0aWxzLmxvY2FsQ05hbWUgPSBTRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIoKTtcblxuLy8gU3BsaXRzIFNEUCBpbnRvIGxpbmVzLCBkZWFsaW5nIHdpdGggYm90aCBDUkxGIGFuZCBMRi5cblNEUFV0aWxzLnNwbGl0TGluZXMgPSBmdW5jdGlvbihibG9iKSB7XG4gIHJldHVybiBibG9iLnRyaW0oKS5zcGxpdCgnXFxuJykubWFwKGxpbmUgPT4gbGluZS50cmltKCkpO1xufTtcbi8vIFNwbGl0cyBTRFAgaW50byBzZXNzaW9ucGFydCBhbmQgbWVkaWFzZWN0aW9ucy4gRW5zdXJlcyBDUkxGLlxuU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgY29uc3QgcGFydHMgPSBibG9iLnNwbGl0KCdcXG5tPScpO1xuICByZXR1cm4gcGFydHMubWFwKChwYXJ0LCBpbmRleCkgPT4gKGluZGV4ID4gMCA/XG4gICAgJ209JyArIHBhcnQgOiBwYXJ0KS50cmltKCkgKyAnXFxyXFxuJyk7XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBzZXNzaW9uIGRlc2NyaXB0aW9uLlxuU0RQVXRpbHMuZ2V0RGVzY3JpcHRpb24gPSBmdW5jdGlvbihibG9iKSB7XG4gIGNvbnN0IHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhibG9iKTtcbiAgcmV0dXJuIHNlY3Rpb25zICYmIHNlY3Rpb25zWzBdO1xufTtcblxuLy8gUmV0dXJucyB0aGUgaW5kaXZpZHVhbCBtZWRpYSBzZWN0aW9ucy5cblNEUFV0aWxzLmdldE1lZGlhU2VjdGlvbnMgPSBmdW5jdGlvbihibG9iKSB7XG4gIGNvbnN0IHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhibG9iKTtcbiAgc2VjdGlvbnMuc2hpZnQoKTtcbiAgcmV0dXJuIHNlY3Rpb25zO1xufTtcblxuLy8gUmV0dXJucyBsaW5lcyB0aGF0IHN0YXJ0IHdpdGggYSBjZXJ0YWluIHByZWZpeC5cblNEUFV0aWxzLm1hdGNoUHJlZml4ID0gZnVuY3Rpb24oYmxvYiwgcHJlZml4KSB7XG4gIHJldHVybiBTRFBVdGlscy5zcGxpdExpbmVzKGJsb2IpLmZpbHRlcihsaW5lID0+IGxpbmUuaW5kZXhPZihwcmVmaXgpID09PSAwKTtcbn07XG5cbi8vIFBhcnNlcyBhbiBJQ0UgY2FuZGlkYXRlIGxpbmUuIFNhbXBsZSBpbnB1dDpcbi8vIGNhbmRpZGF0ZTo3MDI3ODYzNTAgMiB1ZHAgNDE4MTk5MDIgOC44LjguOCA2MDc2OSB0eXAgcmVsYXkgcmFkZHIgOC44LjguOFxuLy8gcnBvcnQgNTU5OTZcIlxuLy8gSW5wdXQgY2FuIGJlIHByZWZpeGVkIHdpdGggYT0uXG5TRFBVdGlscy5wYXJzZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgbGV0IHBhcnRzO1xuICAvLyBQYXJzZSBib3RoIHZhcmlhbnRzLlxuICBpZiAobGluZS5pbmRleE9mKCdhPWNhbmRpZGF0ZTonKSA9PT0gMCkge1xuICAgIHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTIpLnNwbGl0KCcgJyk7XG4gIH0gZWxzZSB7XG4gICAgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMCkuc3BsaXQoJyAnKTtcbiAgfVxuXG4gIGNvbnN0IGNhbmRpZGF0ZSA9IHtcbiAgICBmb3VuZGF0aW9uOiBwYXJ0c1swXSxcbiAgICBjb21wb25lbnQ6IHsxOiAncnRwJywgMjogJ3J0Y3AnfVtwYXJ0c1sxXV0gfHwgcGFydHNbMV0sXG4gICAgcHJvdG9jb2w6IHBhcnRzWzJdLnRvTG93ZXJDYXNlKCksXG4gICAgcHJpb3JpdHk6IHBhcnNlSW50KHBhcnRzWzNdLCAxMCksXG4gICAgaXA6IHBhcnRzWzRdLFxuICAgIGFkZHJlc3M6IHBhcnRzWzRdLCAvLyBhZGRyZXNzIGlzIGFuIGFsaWFzIGZvciBpcC5cbiAgICBwb3J0OiBwYXJzZUludChwYXJ0c1s1XSwgMTApLFxuICAgIC8vIHNraXAgcGFydHNbNl0gPT0gJ3R5cCdcbiAgICB0eXBlOiBwYXJ0c1s3XSxcbiAgfTtcblxuICBmb3IgKGxldCBpID0gODsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgc3dpdGNoIChwYXJ0c1tpXSkge1xuICAgICAgY2FzZSAncmFkZHInOlxuICAgICAgICBjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncnBvcnQnOlxuICAgICAgICBjYW5kaWRhdGUucmVsYXRlZFBvcnQgPSBwYXJzZUludChwYXJ0c1tpICsgMV0sIDEwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0Y3B0eXBlJzpcbiAgICAgICAgY2FuZGlkYXRlLnRjcFR5cGUgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndWZyYWcnOlxuICAgICAgICBjYW5kaWRhdGUudWZyYWcgPSBwYXJ0c1tpICsgMV07IC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgICAgICBjYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudCA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAvLyBleHRlbnNpb24gaGFuZGxpbmcsIGluIHBhcnRpY3VsYXIgdWZyYWcuIERvbid0IG92ZXJ3cml0ZS5cbiAgICAgICAgaWYgKGNhbmRpZGF0ZVtwYXJ0c1tpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNhbmRpZGF0ZVtwYXJ0c1tpXV0gPSBwYXJ0c1tpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW5kaWRhdGU7XG59O1xuXG4vLyBUcmFuc2xhdGVzIGEgY2FuZGlkYXRlIG9iamVjdCBpbnRvIFNEUCBjYW5kaWRhdGUgYXR0cmlidXRlLlxuLy8gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBhPSBwcmVmaXghXG5TRFBVdGlscy53cml0ZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uKGNhbmRpZGF0ZSkge1xuICBjb25zdCBzZHAgPSBbXTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLmZvdW5kYXRpb24pO1xuXG4gIGNvbnN0IGNvbXBvbmVudCA9IGNhbmRpZGF0ZS5jb21wb25lbnQ7XG4gIGlmIChjb21wb25lbnQgPT09ICdydHAnKSB7XG4gICAgc2RwLnB1c2goMSk7XG4gIH0gZWxzZSBpZiAoY29tcG9uZW50ID09PSAncnRjcCcpIHtcbiAgICBzZHAucHVzaCgyKTtcbiAgfSBlbHNlIHtcbiAgICBzZHAucHVzaChjb21wb25lbnQpO1xuICB9XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5wcm90b2NvbC50b1VwcGVyQ2FzZSgpKTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLnByaW9yaXR5KTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLmFkZHJlc3MgfHwgY2FuZGlkYXRlLmlwKTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLnBvcnQpO1xuXG4gIGNvbnN0IHR5cGUgPSBjYW5kaWRhdGUudHlwZTtcbiAgc2RwLnB1c2goJ3R5cCcpO1xuICBzZHAucHVzaCh0eXBlKTtcbiAgaWYgKHR5cGUgIT09ICdob3N0JyAmJiBjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MgJiZcbiAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCkge1xuICAgIHNkcC5wdXNoKCdyYWRkcicpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyk7XG4gICAgc2RwLnB1c2goJ3Jwb3J0Jyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KTtcbiAgfVxuICBpZiAoY2FuZGlkYXRlLnRjcFR5cGUgJiYgY2FuZGlkYXRlLnByb3RvY29sLnRvTG93ZXJDYXNlKCkgPT09ICd0Y3AnKSB7XG4gICAgc2RwLnB1c2goJ3RjcHR5cGUnKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUudGNwVHlwZSk7XG4gIH1cbiAgaWYgKGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50IHx8IGNhbmRpZGF0ZS51ZnJhZykge1xuICAgIHNkcC5wdXNoKCd1ZnJhZycpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50IHx8IGNhbmRpZGF0ZS51ZnJhZyk7XG4gIH1cbiAgcmV0dXJuICdjYW5kaWRhdGU6JyArIHNkcC5qb2luKCcgJyk7XG59O1xuXG4vLyBQYXJzZXMgYW4gaWNlLW9wdGlvbnMgbGluZSwgcmV0dXJucyBhbiBhcnJheSBvZiBvcHRpb24gdGFncy5cbi8vIFNhbXBsZSBpbnB1dDpcbi8vIGE9aWNlLW9wdGlvbnM6Zm9vIGJhclxuU0RQVXRpbHMucGFyc2VJY2VPcHRpb25zID0gZnVuY3Rpb24obGluZSkge1xuICByZXR1cm4gbGluZS5zdWJzdHJpbmcoMTQpLnNwbGl0KCcgJyk7XG59O1xuXG4vLyBQYXJzZXMgYSBydHBtYXAgbGluZSwgcmV0dXJucyBSVENSdHBDb2RkZWNQYXJhbWV0ZXJzLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPXJ0cG1hcDoxMTEgb3B1cy80ODAwMC8yXG5TRFBVdGlscy5wYXJzZVJ0cE1hcCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgbGV0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcbiAgY29uc3QgcGFyc2VkID0ge1xuICAgIHBheWxvYWRUeXBlOiBwYXJzZUludChwYXJ0cy5zaGlmdCgpLCAxMCksIC8vIHdhczogaWRcbiAgfTtcblxuICBwYXJ0cyA9IHBhcnRzWzBdLnNwbGl0KCcvJyk7XG5cbiAgcGFyc2VkLm5hbWUgPSBwYXJ0c1swXTtcbiAgcGFyc2VkLmNsb2NrUmF0ZSA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7IC8vIHdhczogY2xvY2tyYXRlXG4gIHBhcnNlZC5jaGFubmVscyA9IHBhcnRzLmxlbmd0aCA9PT0gMyA/IHBhcnNlSW50KHBhcnRzWzJdLCAxMCkgOiAxO1xuICAvLyBsZWdhY3kgYWxpYXMsIGdvdCByZW5hbWVkIGJhY2sgdG8gY2hhbm5lbHMgaW4gT1JUQy5cbiAgcGFyc2VkLm51bUNoYW5uZWxzID0gcGFyc2VkLmNoYW5uZWxzO1xuICByZXR1cm4gcGFyc2VkO1xufTtcblxuLy8gR2VuZXJhdGVzIGEgcnRwbWFwIGxpbmUgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3Jcbi8vIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cblNEUFV0aWxzLndyaXRlUnRwTWFwID0gZnVuY3Rpb24oY29kZWMpIHtcbiAgbGV0IHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgfVxuICBjb25zdCBjaGFubmVscyA9IGNvZGVjLmNoYW5uZWxzIHx8IGNvZGVjLm51bUNoYW5uZWxzIHx8IDE7XG4gIHJldHVybiAnYT1ydHBtYXA6JyArIHB0ICsgJyAnICsgY29kZWMubmFtZSArICcvJyArIGNvZGVjLmNsb2NrUmF0ZSArXG4gICAgICAoY2hhbm5lbHMgIT09IDEgPyAnLycgKyBjaGFubmVscyA6ICcnKSArICdcXHJcXG4nO1xufTtcblxuLy8gUGFyc2VzIGEgZXh0bWFwIGxpbmUgKGhlYWRlcmV4dGVuc2lvbiBmcm9tIFJGQyA1Mjg1KS4gU2FtcGxlIGlucHV0OlxuLy8gYT1leHRtYXA6MiB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG4vLyBhPWV4dG1hcDoyL3NlbmRvbmx5IHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcblNEUFV0aWxzLnBhcnNlRXh0bWFwID0gZnVuY3Rpb24obGluZSkge1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDkpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgaWQ6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgZGlyZWN0aW9uOiBwYXJ0c1swXS5pbmRleE9mKCcvJykgPiAwID8gcGFydHNbMF0uc3BsaXQoJy8nKVsxXSA6ICdzZW5kcmVjdicsXG4gICAgdXJpOiBwYXJ0c1sxXSxcbiAgICBhdHRyaWJ1dGVzOiBwYXJ0cy5zbGljZSgyKS5qb2luKCcgJyksXG4gIH07XG59O1xuXG4vLyBHZW5lcmF0ZXMgYW4gZXh0bWFwIGxpbmUgZnJvbSBSVENSdHBIZWFkZXJFeHRlbnNpb25QYXJhbWV0ZXJzIG9yXG4vLyBSVENSdHBIZWFkZXJFeHRlbnNpb24uXG5TRFBVdGlscy53cml0ZUV4dG1hcCA9IGZ1bmN0aW9uKGhlYWRlckV4dGVuc2lvbikge1xuICByZXR1cm4gJ2E9ZXh0bWFwOicgKyAoaGVhZGVyRXh0ZW5zaW9uLmlkIHx8IGhlYWRlckV4dGVuc2lvbi5wcmVmZXJyZWRJZCkgK1xuICAgICAgKGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gJiYgaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRyZWN2J1xuICAgICAgICA/ICcvJyArIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb25cbiAgICAgICAgOiAnJykgK1xuICAgICAgJyAnICsgaGVhZGVyRXh0ZW5zaW9uLnVyaSArXG4gICAgICAoaGVhZGVyRXh0ZW5zaW9uLmF0dHJpYnV0ZXMgPyAnICcgKyBoZWFkZXJFeHRlbnNpb24uYXR0cmlidXRlcyA6ICcnKSArXG4gICAgICAnXFxyXFxuJztcbn07XG5cbi8vIFBhcnNlcyBhIGZtdHAgbGluZSwgcmV0dXJucyBkaWN0aW9uYXJ5LiBTYW1wbGUgaW5wdXQ6XG4vLyBhPWZtdHA6OTYgdmJyPW9uO2NuZz1vblxuLy8gQWxzbyBkZWFscyB3aXRoIHZicj1vbjsgY25nPW9uXG5TRFBVdGlscy5wYXJzZUZtdHAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnNlZCA9IHt9O1xuICBsZXQga3Y7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcobGluZS5pbmRleE9mKCcgJykgKyAxKS5zcGxpdCgnOycpO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAga3YgPSBwYXJ0c1tqXS50cmltKCkuc3BsaXQoJz0nKTtcbiAgICBwYXJzZWRba3ZbMF0udHJpbSgpXSA9IGt2WzFdO1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vLyBHZW5lcmF0ZXMgYSBmbXRwIGxpbmUgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVGbXRwID0gZnVuY3Rpb24oY29kZWMpIHtcbiAgbGV0IGxpbmUgPSAnJztcbiAgbGV0IHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgfVxuICBpZiAoY29kZWMucGFyYW1ldGVycyAmJiBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKS5sZW5ndGgpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKS5mb3JFYWNoKHBhcmFtID0+IHtcbiAgICAgIGlmIChjb2RlYy5wYXJhbWV0ZXJzW3BhcmFtXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtICsgJz0nICsgY29kZWMucGFyYW1ldGVyc1twYXJhbV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxpbmUgKz0gJ2E9Zm10cDonICsgcHQgKyAnICcgKyBwYXJhbXMuam9pbignOycpICsgJ1xcclxcbic7XG4gIH1cbiAgcmV0dXJuIGxpbmU7XG59O1xuXG4vLyBQYXJzZXMgYSBydGNwLWZiIGxpbmUsIHJldHVybnMgUlRDUFJ0Y3BGZWVkYmFjayBvYmplY3QuIFNhbXBsZSBpbnB1dDpcbi8vIGE9cnRjcC1mYjo5OCBuYWNrIHJwc2lcblNEUFV0aWxzLnBhcnNlUnRjcEZiID0gZnVuY3Rpb24obGluZSkge1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKGxpbmUuaW5kZXhPZignICcpICsgMSkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBwYXJ0cy5zaGlmdCgpLFxuICAgIHBhcmFtZXRlcjogcGFydHMuam9pbignICcpLFxuICB9O1xufTtcblxuLy8gR2VuZXJhdGUgYT1ydGNwLWZiIGxpbmVzIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cblNEUFV0aWxzLndyaXRlUnRjcEZiID0gZnVuY3Rpb24oY29kZWMpIHtcbiAgbGV0IGxpbmVzID0gJyc7XG4gIGxldCBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gIH1cbiAgaWYgKGNvZGVjLnJ0Y3BGZWVkYmFjayAmJiBjb2RlYy5ydGNwRmVlZGJhY2subGVuZ3RoKSB7XG4gICAgLy8gRklYTUU6IHNwZWNpYWwgaGFuZGxpbmcgZm9yIHRyci1pbnQ/XG4gICAgY29kZWMucnRjcEZlZWRiYWNrLmZvckVhY2goZmIgPT4ge1xuICAgICAgbGluZXMgKz0gJ2E9cnRjcC1mYjonICsgcHQgKyAnICcgKyBmYi50eXBlICtcbiAgICAgIChmYi5wYXJhbWV0ZXIgJiYgZmIucGFyYW1ldGVyLmxlbmd0aCA/ICcgJyArIGZiLnBhcmFtZXRlciA6ICcnKSArXG4gICAgICAgICAgJ1xcclxcbic7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxpbmVzO1xufTtcblxuLy8gUGFyc2VzIGEgUkZDIDU1NzYgc3NyYyBtZWRpYSBhdHRyaWJ1dGUuIFNhbXBsZSBpbnB1dDpcbi8vIGE9c3NyYzozNzM1OTI4NTU5IGNuYW1lOnNvbWV0aGluZ1xuU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHNwID0gbGluZS5pbmRleE9mKCcgJyk7XG4gIGNvbnN0IHBhcnRzID0ge1xuICAgIHNzcmM6IHBhcnNlSW50KGxpbmUuc3Vic3RyaW5nKDcsIHNwKSwgMTApLFxuICB9O1xuICBjb25zdCBjb2xvbiA9IGxpbmUuaW5kZXhPZignOicsIHNwKTtcbiAgaWYgKGNvbG9uID4gLTEpIHtcbiAgICBwYXJ0cy5hdHRyaWJ1dGUgPSBsaW5lLnN1YnN0cmluZyhzcCArIDEsIGNvbG9uKTtcbiAgICBwYXJ0cy52YWx1ZSA9IGxpbmUuc3Vic3RyaW5nKGNvbG9uICsgMSk7XG4gIH0gZWxzZSB7XG4gICAgcGFydHMuYXR0cmlidXRlID0gbGluZS5zdWJzdHJpbmcoc3AgKyAxKTtcbiAgfVxuICByZXR1cm4gcGFydHM7XG59O1xuXG4vLyBQYXJzZSBhIHNzcmMtZ3JvdXAgbGluZSAoc2VlIFJGQyA1NTc2KS4gU2FtcGxlIGlucHV0OlxuLy8gYT1zc3JjLWdyb3VwOnNlbWFudGljcyAxMiAzNFxuU0RQVXRpbHMucGFyc2VTc3JjR3JvdXAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTMpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgc2VtYW50aWNzOiBwYXJ0cy5zaGlmdCgpLFxuICAgIHNzcmNzOiBwYXJ0cy5tYXAoc3NyYyA9PiBwYXJzZUludChzc3JjLCAxMCkpLFxuICB9O1xufTtcblxuLy8gRXh0cmFjdHMgdGhlIE1JRCAoUkZDIDU4ODgpIGZyb20gYSBtZWRpYSBzZWN0aW9uLlxuLy8gUmV0dXJucyB0aGUgTUlEIG9yIHVuZGVmaW5lZCBpZiBubyBtaWQgbGluZSB3YXMgZm91bmQuXG5TRFBVdGlscy5nZXRNaWQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgbWlkID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1taWQ6JylbMF07XG4gIGlmIChtaWQpIHtcbiAgICByZXR1cm4gbWlkLnN1YnN0cmluZyg2KTtcbiAgfVxufTtcblxuLy8gUGFyc2VzIGEgZmluZ2VycHJpbnQgbGluZSBmb3IgRFRMUy1TUlRQLlxuU0RQVXRpbHMucGFyc2VGaW5nZXJwcmludCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxNCkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBhbGdvcml0aG06IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCksIC8vIGFsZ29yaXRobSBpcyBjYXNlLXNlbnNpdGl2ZSBpbiBFZGdlLlxuICAgIHZhbHVlOiBwYXJ0c1sxXS50b1VwcGVyQ2FzZSgpLCAvLyB0aGUgZGVmaW5pdGlvbiBpcyB1cHBlci1jYXNlIGluIFJGQyA0NTcyLlxuICB9O1xufTtcblxuLy8gRXh0cmFjdHMgRFRMUyBwYXJhbWV0ZXJzIGZyb20gU0RQIG1lZGlhIHNlY3Rpb24gb3Igc2Vzc2lvbnBhcnQuXG4vLyBGSVhNRTogZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgZnVuY3Rpb25zIHRoaXMgc2hvdWxkIG9ubHlcbi8vICAgZ2V0IHRoZSBmaW5nZXJwcmludCBsaW5lIGFzIGlucHV0LiBTZWUgYWxzbyBnZXRJY2VQYXJhbWV0ZXJzLlxuU0RQVXRpbHMuZ2V0RHRsc1BhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsXG4gICAgJ2E9ZmluZ2VycHJpbnQ6Jyk7XG4gIC8vIE5vdGU6IGE9c2V0dXAgbGluZSBpcyBpZ25vcmVkIHNpbmNlIHdlIHVzZSB0aGUgJ2F1dG8nIHJvbGUgaW4gRWRnZS5cbiAgcmV0dXJuIHtcbiAgICByb2xlOiAnYXV0bycsXG4gICAgZmluZ2VycHJpbnRzOiBsaW5lcy5tYXAoU0RQVXRpbHMucGFyc2VGaW5nZXJwcmludCksXG4gIH07XG59O1xuXG4vLyBTZXJpYWxpemVzIERUTFMgcGFyYW1ldGVycyB0byBTRFAuXG5TRFBVdGlscy53cml0ZUR0bHNQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zLCBzZXR1cFR5cGUpIHtcbiAgbGV0IHNkcCA9ICdhPXNldHVwOicgKyBzZXR1cFR5cGUgKyAnXFxyXFxuJztcbiAgcGFyYW1zLmZpbmdlcnByaW50cy5mb3JFYWNoKGZwID0+IHtcbiAgICBzZHAgKz0gJ2E9ZmluZ2VycHJpbnQ6JyArIGZwLmFsZ29yaXRobSArICcgJyArIGZwLnZhbHVlICsgJ1xcclxcbic7XG4gIH0pO1xuICByZXR1cm4gc2RwO1xufTtcblxuLy8gUGFyc2VzIGE9Y3J5cHRvIGxpbmVzIGludG9cbi8vICAgaHR0cHM6Ly9yYXdnaXQuY29tL2Fib2JhL2VkZ2VydGMvbWFzdGVyL21zb3J0Yy1yczQuaHRtbCNkaWN0aW9uYXJ5LXJ0Y3NydHBzZGVzcGFyYW1ldGVycy1tZW1iZXJzXG5TRFBVdGlscy5wYXJzZUNyeXB0b0xpbmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICB0YWc6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgY3J5cHRvU3VpdGU6IHBhcnRzWzFdLFxuICAgIGtleVBhcmFtczogcGFydHNbMl0sXG4gICAgc2Vzc2lvblBhcmFtczogcGFydHMuc2xpY2UoMyksXG4gIH07XG59O1xuXG5TRFBVdGlscy53cml0ZUNyeXB0b0xpbmUgPSBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XG4gIHJldHVybiAnYT1jcnlwdG86JyArIHBhcmFtZXRlcnMudGFnICsgJyAnICtcbiAgICBwYXJhbWV0ZXJzLmNyeXB0b1N1aXRlICsgJyAnICtcbiAgICAodHlwZW9mIHBhcmFtZXRlcnMua2V5UGFyYW1zID09PSAnb2JqZWN0J1xuICAgICAgPyBTRFBVdGlscy53cml0ZUNyeXB0b0tleVBhcmFtcyhwYXJhbWV0ZXJzLmtleVBhcmFtcylcbiAgICAgIDogcGFyYW1ldGVycy5rZXlQYXJhbXMpICtcbiAgICAocGFyYW1ldGVycy5zZXNzaW9uUGFyYW1zID8gJyAnICsgcGFyYW1ldGVycy5zZXNzaW9uUGFyYW1zLmpvaW4oJyAnKSA6ICcnKSArXG4gICAgJ1xcclxcbic7XG59O1xuXG4vLyBQYXJzZXMgdGhlIGNyeXB0byBrZXkgcGFyYW1ldGVycyBpbnRvXG4vLyAgIGh0dHBzOi8vcmF3Z2l0LmNvbS9hYm9iYS9lZGdlcnRjL21hc3Rlci9tc29ydGMtcnM0Lmh0bWwjcnRjc3J0cGtleXBhcmFtKlxuU0RQVXRpbHMucGFyc2VDcnlwdG9LZXlQYXJhbXMgPSBmdW5jdGlvbihrZXlQYXJhbXMpIHtcbiAgaWYgKGtleVBhcmFtcy5pbmRleE9mKCdpbmxpbmU6JykgIT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBwYXJ0cyA9IGtleVBhcmFtcy5zdWJzdHJpbmcoNykuc3BsaXQoJ3wnKTtcbiAgcmV0dXJuIHtcbiAgICBrZXlNZXRob2Q6ICdpbmxpbmUnLFxuICAgIGtleVNhbHQ6IHBhcnRzWzBdLFxuICAgIGxpZmVUaW1lOiBwYXJ0c1sxXSxcbiAgICBta2lWYWx1ZTogcGFydHNbMl0gPyBwYXJ0c1syXS5zcGxpdCgnOicpWzBdIDogdW5kZWZpbmVkLFxuICAgIG1raUxlbmd0aDogcGFydHNbMl0gPyBwYXJ0c1syXS5zcGxpdCgnOicpWzFdIDogdW5kZWZpbmVkLFxuICB9O1xufTtcblxuU0RQVXRpbHMud3JpdGVDcnlwdG9LZXlQYXJhbXMgPSBmdW5jdGlvbihrZXlQYXJhbXMpIHtcbiAgcmV0dXJuIGtleVBhcmFtcy5rZXlNZXRob2QgKyAnOidcbiAgICArIGtleVBhcmFtcy5rZXlTYWx0ICtcbiAgICAoa2V5UGFyYW1zLmxpZmVUaW1lID8gJ3wnICsga2V5UGFyYW1zLmxpZmVUaW1lIDogJycpICtcbiAgICAoa2V5UGFyYW1zLm1raVZhbHVlICYmIGtleVBhcmFtcy5ta2lMZW5ndGhcbiAgICAgID8gJ3wnICsga2V5UGFyYW1zLm1raVZhbHVlICsgJzonICsga2V5UGFyYW1zLm1raUxlbmd0aFxuICAgICAgOiAnJyk7XG59O1xuXG4vLyBFeHRyYWN0cyBhbGwgU0RFUyBwYXJhbWV0ZXJzLlxuU0RQVXRpbHMuZ2V0Q3J5cHRvUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCxcbiAgICAnYT1jcnlwdG86Jyk7XG4gIHJldHVybiBsaW5lcy5tYXAoU0RQVXRpbHMucGFyc2VDcnlwdG9MaW5lKTtcbn07XG5cbi8vIFBhcnNlcyBJQ0UgaW5mb3JtYXRpb24gZnJvbSBTRFAgbWVkaWEgc2VjdGlvbiBvciBzZXNzaW9ucGFydC5cbi8vIEZJWE1FOiBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBmdW5jdGlvbnMgdGhpcyBzaG91bGQgb25seVxuLy8gICBnZXQgdGhlIGljZS11ZnJhZyBhbmQgaWNlLXB3ZCBsaW5lcyBhcyBpbnB1dC5cblNEUFV0aWxzLmdldEljZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gIGNvbnN0IHVmcmFnID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsXG4gICAgJ2E9aWNlLXVmcmFnOicpWzBdO1xuICBjb25zdCBwd2QgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCxcbiAgICAnYT1pY2UtcHdkOicpWzBdO1xuICBpZiAoISh1ZnJhZyAmJiBwd2QpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB1c2VybmFtZUZyYWdtZW50OiB1ZnJhZy5zdWJzdHJpbmcoMTIpLFxuICAgIHBhc3N3b3JkOiBwd2Quc3Vic3RyaW5nKDEwKSxcbiAgfTtcbn07XG5cbi8vIFNlcmlhbGl6ZXMgSUNFIHBhcmFtZXRlcnMgdG8gU0RQLlxuU0RQVXRpbHMud3JpdGVJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIGxldCBzZHAgPSAnYT1pY2UtdWZyYWc6JyArIHBhcmFtcy51c2VybmFtZUZyYWdtZW50ICsgJ1xcclxcbicgK1xuICAgICAgJ2E9aWNlLXB3ZDonICsgcGFyYW1zLnBhc3N3b3JkICsgJ1xcclxcbic7XG4gIGlmIChwYXJhbXMuaWNlTGl0ZSkge1xuICAgIHNkcCArPSAnYT1pY2UtbGl0ZVxcclxcbic7XG4gIH1cbiAgcmV0dXJuIHNkcDtcbn07XG5cbi8vIFBhcnNlcyB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gYW5kIHJldHVybnMgUlRDUnRwUGFyYW1ldGVycy5cblNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IHtcbiAgICBjb2RlY3M6IFtdLFxuICAgIGhlYWRlckV4dGVuc2lvbnM6IFtdLFxuICAgIGZlY01lY2hhbmlzbXM6IFtdLFxuICAgIHJ0Y3A6IFtdLFxuICB9O1xuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgY29uc3QgbWxpbmUgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xuICBkZXNjcmlwdGlvbi5wcm9maWxlID0gbWxpbmVbMl07XG4gIGZvciAobGV0IGkgPSAzOyBpIDwgbWxpbmUubGVuZ3RoOyBpKyspIHsgLy8gZmluZCBhbGwgY29kZWNzIGZyb20gbWxpbmVbMy4uXVxuICAgIGNvbnN0IHB0ID0gbWxpbmVbaV07XG4gICAgY29uc3QgcnRwbWFwbGluZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KFxuICAgICAgbWVkaWFTZWN0aW9uLCAnYT1ydHBtYXA6JyArIHB0ICsgJyAnKVswXTtcbiAgICBpZiAocnRwbWFwbGluZSkge1xuICAgICAgY29uc3QgY29kZWMgPSBTRFBVdGlscy5wYXJzZVJ0cE1hcChydHBtYXBsaW5lKTtcbiAgICAgIGNvbnN0IGZtdHBzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoXG4gICAgICAgIG1lZGlhU2VjdGlvbiwgJ2E9Zm10cDonICsgcHQgKyAnICcpO1xuICAgICAgLy8gT25seSB0aGUgZmlyc3QgYT1mbXRwOjxwdD4gaXMgY29uc2lkZXJlZC5cbiAgICAgIGNvZGVjLnBhcmFtZXRlcnMgPSBmbXRwcy5sZW5ndGggPyBTRFBVdGlscy5wYXJzZUZtdHAoZm10cHNbMF0pIDoge307XG4gICAgICBjb2RlYy5ydGNwRmVlZGJhY2sgPSBTRFBVdGlscy5tYXRjaFByZWZpeChcbiAgICAgICAgbWVkaWFTZWN0aW9uLCAnYT1ydGNwLWZiOicgKyBwdCArICcgJylcbiAgICAgICAgLm1hcChTRFBVdGlscy5wYXJzZVJ0Y3BGYik7XG4gICAgICBkZXNjcmlwdGlvbi5jb2RlY3MucHVzaChjb2RlYyk7XG4gICAgICAvLyBwYXJzZSBGRUMgbWVjaGFuaXNtcyBmcm9tIHJ0cG1hcCBsaW5lcy5cbiAgICAgIHN3aXRjaCAoY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgJ1JFRCc6XG4gICAgICAgIGNhc2UgJ1VMUEZFQyc6XG4gICAgICAgICAgZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5wdXNoKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIG9ubHkgUkVEIGFuZCBVTFBGRUMgYXJlIHJlY29nbml6ZWQgYXMgRkVDIG1lY2hhbmlzbXMuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9ZXh0bWFwOicpLmZvckVhY2gobGluZSA9PiB7XG4gICAgZGVzY3JpcHRpb24uaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKFNEUFV0aWxzLnBhcnNlRXh0bWFwKGxpbmUpKTtcbiAgfSk7XG4gIGNvbnN0IHdpbGRjYXJkUnRjcEZiID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLWZiOiogJylcbiAgICAubWFwKFNEUFV0aWxzLnBhcnNlUnRjcEZiKTtcbiAgZGVzY3JpcHRpb24uY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgIHdpbGRjYXJkUnRjcEZiLmZvckVhY2goZmI9PiB7XG4gICAgICBjb25zdCBkdXBsaWNhdGUgPSBjb2RlYy5ydGNwRmVlZGJhY2suZmluZChleGlzdGluZ0ZlZWRiYWNrID0+IHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nRmVlZGJhY2sudHlwZSA9PT0gZmIudHlwZSAmJlxuICAgICAgICAgIGV4aXN0aW5nRmVlZGJhY2sucGFyYW1ldGVyID09PSBmYi5wYXJhbWV0ZXI7XG4gICAgICB9KTtcbiAgICAgIGlmICghZHVwbGljYXRlKSB7XG4gICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjay5wdXNoKGZiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIC8vIEZJWE1FOiBwYXJzZSBydGNwLlxuICByZXR1cm4gZGVzY3JpcHRpb247XG59O1xuXG4vLyBHZW5lcmF0ZXMgcGFydHMgb2YgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGRlc2NyaWJpbmcgdGhlIGNhcGFiaWxpdGllcyAvXG4vLyBwYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKGtpbmQsIGNhcHMpIHtcbiAgbGV0IHNkcCA9ICcnO1xuXG4gIC8vIEJ1aWxkIHRoZSBtbGluZS5cbiAgc2RwICs9ICdtPScgKyBraW5kICsgJyAnO1xuICBzZHAgKz0gY2Fwcy5jb2RlY3MubGVuZ3RoID4gMCA/ICc5JyA6ICcwJzsgLy8gcmVqZWN0IGlmIG5vIGNvZGVjcy5cbiAgc2RwICs9ICcgJyArIChjYXBzLnByb2ZpbGUgfHwgJ1VEUC9UTFMvUlRQL1NBVlBGJykgKyAnICc7XG4gIHNkcCArPSBjYXBzLmNvZGVjcy5tYXAoY29kZWMgPT4ge1xuICAgIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gICAgfVxuICAgIHJldHVybiBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgfSkuam9pbignICcpICsgJ1xcclxcbic7XG5cbiAgc2RwICs9ICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJztcbiAgc2RwICs9ICdhPXJ0Y3A6OSBJTiBJUDQgMC4wLjAuMFxcclxcbic7XG5cbiAgLy8gQWRkIGE9cnRwbWFwIGxpbmVzIGZvciBlYWNoIGNvZGVjLiBBbHNvIGZtdHAgYW5kIHJ0Y3AtZmIuXG4gIGNhcHMuY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0cE1hcChjb2RlYyk7XG4gICAgc2RwICs9IFNEUFV0aWxzLndyaXRlRm10cChjb2RlYyk7XG4gICAgc2RwICs9IFNEUFV0aWxzLndyaXRlUnRjcEZiKGNvZGVjKTtcbiAgfSk7XG4gIGxldCBtYXhwdGltZSA9IDA7XG4gIGNhcHMuY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgIGlmIChjb2RlYy5tYXhwdGltZSA+IG1heHB0aW1lKSB7XG4gICAgICBtYXhwdGltZSA9IGNvZGVjLm1heHB0aW1lO1xuICAgIH1cbiAgfSk7XG4gIGlmIChtYXhwdGltZSA+IDApIHtcbiAgICBzZHAgKz0gJ2E9bWF4cHRpbWU6JyArIG1heHB0aW1lICsgJ1xcclxcbic7XG4gIH1cblxuICBpZiAoY2Fwcy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgY2Fwcy5oZWFkZXJFeHRlbnNpb25zLmZvckVhY2goZXh0ZW5zaW9uID0+IHtcbiAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZUV4dG1hcChleHRlbnNpb24pO1xuICAgIH0pO1xuICB9XG4gIC8vIEZJWE1FOiB3cml0ZSBmZWNNZWNoYW5pc21zLlxuICByZXR1cm4gc2RwO1xufTtcblxuLy8gUGFyc2VzIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZlxuLy8gUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzLlxuU0RQVXRpbHMucGFyc2VSdHBFbmNvZGluZ1BhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgZW5jb2RpbmdQYXJhbWV0ZXJzID0gW107XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbik7XG4gIGNvbnN0IGhhc1JlZCA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignUkVEJykgIT09IC0xO1xuICBjb25zdCBoYXNVbHBmZWMgPSBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLmluZGV4T2YoJ1VMUEZFQycpICE9PSAtMTtcblxuICAvLyBmaWx0ZXIgYT1zc3JjOi4uLiBjbmFtZTosIGlnbm9yZSBQbGFuQi1tc2lkXG4gIGNvbnN0IHNzcmNzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpXG4gICAgLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKVxuICAgIC5maWx0ZXIocGFydHMgPT4gcGFydHMuYXR0cmlidXRlID09PSAnY25hbWUnKTtcbiAgY29uc3QgcHJpbWFyeVNzcmMgPSBzc3Jjcy5sZW5ndGggPiAwICYmIHNzcmNzWzBdLnNzcmM7XG4gIGxldCBzZWNvbmRhcnlTc3JjO1xuXG4gIGNvbnN0IGZsb3dzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjLWdyb3VwOkZJRCcpXG4gICAgLm1hcChsaW5lID0+IHtcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTcpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4gcGFydHMubWFwKHBhcnQgPT4gcGFyc2VJbnQocGFydCwgMTApKTtcbiAgICB9KTtcbiAgaWYgKGZsb3dzLmxlbmd0aCA+IDAgJiYgZmxvd3NbMF0ubGVuZ3RoID4gMSAmJiBmbG93c1swXVswXSA9PT0gcHJpbWFyeVNzcmMpIHtcbiAgICBzZWNvbmRhcnlTc3JjID0gZmxvd3NbMF1bMV07XG4gIH1cblxuICBkZXNjcmlwdGlvbi5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgaWYgKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1JUWCcgJiYgY29kZWMucGFyYW1ldGVycy5hcHQpIHtcbiAgICAgIGxldCBlbmNQYXJhbSA9IHtcbiAgICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXG4gICAgICAgIGNvZGVjUGF5bG9hZFR5cGU6IHBhcnNlSW50KGNvZGVjLnBhcmFtZXRlcnMuYXB0LCAxMCksXG4gICAgICB9O1xuICAgICAgaWYgKHByaW1hcnlTc3JjICYmIHNlY29uZGFyeVNzcmMpIHtcbiAgICAgICAgZW5jUGFyYW0ucnR4ID0ge3NzcmM6IHNlY29uZGFyeVNzcmN9O1xuICAgICAgfVxuICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xuICAgICAgaWYgKGhhc1JlZCkge1xuICAgICAgICBlbmNQYXJhbSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZW5jUGFyYW0pKTtcbiAgICAgICAgZW5jUGFyYW0uZmVjID0ge1xuICAgICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgICAgICAgIG1lY2hhbmlzbTogaGFzVWxwZmVjID8gJ3JlZCt1bHBmZWMnIDogJ3JlZCcsXG4gICAgICAgIH07XG4gICAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKGVuY1BhcmFtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAoZW5jb2RpbmdQYXJhbWV0ZXJzLmxlbmd0aCA9PT0gMCAmJiBwcmltYXJ5U3NyYykge1xuICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKHtcbiAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gd2Ugc3VwcG9ydCBib3RoIGI9QVMgYW5kIGI9VElBUyBidXQgaW50ZXJwcmV0IEFTIGFzIFRJQVMuXG4gIGxldCBiYW5kd2lkdGggPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdiPScpO1xuICBpZiAoYmFuZHdpZHRoLmxlbmd0aCkge1xuICAgIGlmIChiYW5kd2lkdGhbMF0uaW5kZXhPZignYj1USUFTOicpID09PSAwKSB7XG4gICAgICBiYW5kd2lkdGggPSBwYXJzZUludChiYW5kd2lkdGhbMF0uc3Vic3RyaW5nKDcpLCAxMCk7XG4gICAgfSBlbHNlIGlmIChiYW5kd2lkdGhbMF0uaW5kZXhPZignYj1BUzonKSA9PT0gMCkge1xuICAgICAgLy8gdXNlIGZvcm11bGEgZnJvbSBKU0VQIHRvIGNvbnZlcnQgYj1BUyB0byBUSUFTIHZhbHVlLlxuICAgICAgYmFuZHdpZHRoID0gcGFyc2VJbnQoYmFuZHdpZHRoWzBdLnN1YnN0cmluZyg1KSwgMTApICogMTAwMCAqIDAuOTVcbiAgICAgICAgICAtICg1MCAqIDQwICogOCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhbmR3aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZW5jb2RpbmdQYXJhbWV0ZXJzLmZvckVhY2gocGFyYW1zID0+IHtcbiAgICAgIHBhcmFtcy5tYXhCaXRyYXRlID0gYmFuZHdpZHRoO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlbmNvZGluZ1BhcmFtZXRlcnM7XG59O1xuXG4vLyBwYXJzZXMgaHR0cDovL2RyYWZ0Lm9ydGMub3JnLyNydGNydGNwcGFyYW1ldGVycypcblNEUFV0aWxzLnBhcnNlUnRjcFBhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgcnRjcFBhcmFtZXRlcnMgPSB7fTtcblxuICAvLyBHZXRzIHRoZSBmaXJzdCBTU1JDLiBOb3RlIHRoYXQgd2l0aCBSVFggdGhlcmUgbWlnaHQgYmUgbXVsdGlwbGVcbiAgLy8gU1NSQ3MuXG4gIGNvbnN0IHJlbW90ZVNzcmMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpXG4gICAgLmZpbHRlcihvYmogPT4gb2JqLmF0dHJpYnV0ZSA9PT0gJ2NuYW1lJylbMF07XG4gIGlmIChyZW1vdGVTc3JjKSB7XG4gICAgcnRjcFBhcmFtZXRlcnMuY25hbWUgPSByZW1vdGVTc3JjLnZhbHVlO1xuICAgIHJ0Y3BQYXJhbWV0ZXJzLnNzcmMgPSByZW1vdGVTc3JjLnNzcmM7XG4gIH1cblxuICAvLyBFZGdlIHVzZXMgdGhlIGNvbXBvdW5kIGF0dHJpYnV0ZSBpbnN0ZWFkIG9mIHJlZHVjZWRTaXplXG4gIC8vIGNvbXBvdW5kIGlzICFyZWR1Y2VkU2l6ZVxuICBjb25zdCByc2l6ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1yc2l6ZScpO1xuICBydGNwUGFyYW1ldGVycy5yZWR1Y2VkU2l6ZSA9IHJzaXplLmxlbmd0aCA+IDA7XG4gIHJ0Y3BQYXJhbWV0ZXJzLmNvbXBvdW5kID0gcnNpemUubGVuZ3RoID09PSAwO1xuXG4gIC8vIHBhcnNlcyB0aGUgcnRjcC1tdXggYXR0ctGWYnV0ZS5cbiAgLy8gTm90ZSB0aGF0IEVkZ2UgZG9lcyBub3Qgc3VwcG9ydCB1bm11eGVkIFJUQ1AuXG4gIGNvbnN0IG11eCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1tdXgnKTtcbiAgcnRjcFBhcmFtZXRlcnMubXV4ID0gbXV4Lmxlbmd0aCA+IDA7XG5cbiAgcmV0dXJuIHJ0Y3BQYXJhbWV0ZXJzO1xufTtcblxuU0RQVXRpbHMud3JpdGVSdGNwUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHJ0Y3BQYXJhbWV0ZXJzKSB7XG4gIGxldCBzZHAgPSAnJztcbiAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLnJlZHVjZWRTaXplKSB7XG4gICAgc2RwICs9ICdhPXJ0Y3AtcnNpemVcXHJcXG4nO1xuICB9XG4gIGlmIChydGNwUGFyYW1ldGVycy5tdXgpIHtcbiAgICBzZHAgKz0gJ2E9cnRjcC1tdXhcXHJcXG4nO1xuICB9XG4gIGlmIChydGNwUGFyYW1ldGVycy5zc3JjICE9PSB1bmRlZmluZWQgJiYgcnRjcFBhcmFtZXRlcnMuY25hbWUpIHtcbiAgICBzZHAgKz0gJ2E9c3NyYzonICsgcnRjcFBhcmFtZXRlcnMuc3NyYyArXG4gICAgICAnIGNuYW1lOicgKyBydGNwUGFyYW1ldGVycy5jbmFtZSArICdcXHJcXG4nO1xuICB9XG4gIHJldHVybiBzZHA7XG59O1xuXG5cbi8vIHBhcnNlcyBlaXRoZXIgYT1tc2lkOiBvciBhPXNzcmM6Li4uIG1zaWQgbGluZXMgYW5kIHJldHVybnNcbi8vIHRoZSBpZCBvZiB0aGUgTWVkaWFTdHJlYW0gYW5kIE1lZGlhU3RyZWFtVHJhY2suXG5TRFBVdGlscy5wYXJzZU1zaWQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgbGV0IHBhcnRzO1xuICBjb25zdCBzcGVjID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1tc2lkOicpO1xuICBpZiAoc3BlYy5sZW5ndGggPT09IDEpIHtcbiAgICBwYXJ0cyA9IHNwZWNbMF0uc3Vic3RyaW5nKDcpLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtzdHJlYW06IHBhcnRzWzBdLCB0cmFjazogcGFydHNbMV19O1xuICB9XG4gIGNvbnN0IHBsYW5CID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpXG4gICAgLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKVxuICAgIC5maWx0ZXIobXNpZFBhcnRzID0+IG1zaWRQYXJ0cy5hdHRyaWJ1dGUgPT09ICdtc2lkJyk7XG4gIGlmIChwbGFuQi5sZW5ndGggPiAwKSB7XG4gICAgcGFydHMgPSBwbGFuQlswXS52YWx1ZS5zcGxpdCgnICcpO1xuICAgIHJldHVybiB7c3RyZWFtOiBwYXJ0c1swXSwgdHJhY2s6IHBhcnRzWzFdfTtcbiAgfVxufTtcblxuLy8gU0NUUFxuLy8gcGFyc2VzIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2IGZpcnN0IGFuZCBmYWxscyBiYWNrXG4vLyB0byBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0wNVxuU0RQVXRpbHMucGFyc2VTY3RwRGVzY3JpcHRpb24gPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgbWxpbmUgPSBTRFBVdGlscy5wYXJzZU1MaW5lKG1lZGlhU2VjdGlvbik7XG4gIGNvbnN0IG1heFNpemVMaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1tYXgtbWVzc2FnZS1zaXplOicpO1xuICBsZXQgbWF4TWVzc2FnZVNpemU7XG4gIGlmIChtYXhTaXplTGluZS5sZW5ndGggPiAwKSB7XG4gICAgbWF4TWVzc2FnZVNpemUgPSBwYXJzZUludChtYXhTaXplTGluZVswXS5zdWJzdHJpbmcoMTkpLCAxMCk7XG4gIH1cbiAgaWYgKGlzTmFOKG1heE1lc3NhZ2VTaXplKSkge1xuICAgIG1heE1lc3NhZ2VTaXplID0gNjU1MzY7XG4gIH1cbiAgY29uc3Qgc2N0cFBvcnQgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHAtcG9ydDonKTtcbiAgaWYgKHNjdHBQb3J0Lmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9ydDogcGFyc2VJbnQoc2N0cFBvcnRbMF0uc3Vic3RyaW5nKDEyKSwgMTApLFxuICAgICAgcHJvdG9jb2w6IG1saW5lLmZtdCxcbiAgICAgIG1heE1lc3NhZ2VTaXplLFxuICAgIH07XG4gIH1cbiAgY29uc3Qgc2N0cE1hcExpbmVzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zY3RwbWFwOicpO1xuICBpZiAoc2N0cE1hcExpbmVzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBwYXJ0cyA9IHNjdHBNYXBMaW5lc1swXVxuICAgICAgLnN1YnN0cmluZygxMClcbiAgICAgIC5zcGxpdCgnICcpO1xuICAgIHJldHVybiB7XG4gICAgICBwb3J0OiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgICAgcHJvdG9jb2w6IHBhcnRzWzFdLFxuICAgICAgbWF4TWVzc2FnZVNpemUsXG4gICAgfTtcbiAgfVxufTtcblxuLy8gU0NUUFxuLy8gb3V0cHV0cyB0aGUgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYgdmVyc2lvbiB0aGF0IGFsbCBicm93c2Vyc1xuLy8gc3VwcG9ydCBieSBub3cgcmVjZWl2aW5nIGluIHRoaXMgZm9ybWF0LCB1bmxlc3Mgd2Ugb3JpZ2luYWxseSBwYXJzZWRcbi8vIGFzIHRoZSBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0wNSBmb3JtYXQgKGluZGljYXRlZCBieSB0aGUgbS1saW5lXG4vLyBwcm90b2NvbCBvZiBEVExTL1NDVFAgLS0gd2l0aG91dCBVRFAvIG9yIFRDUC8pXG5TRFBVdGlscy53cml0ZVNjdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKG1lZGlhLCBzY3RwKSB7XG4gIGxldCBvdXRwdXQgPSBbXTtcbiAgaWYgKG1lZGlhLnByb3RvY29sICE9PSAnRFRMUy9TQ1RQJykge1xuICAgIG91dHB1dCA9IFtcbiAgICAgICdtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucHJvdG9jb2wgKyAnXFxyXFxuJyxcbiAgICAgICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJyxcbiAgICAgICdhPXNjdHAtcG9ydDonICsgc2N0cC5wb3J0ICsgJ1xcclxcbicsXG4gICAgXTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBbXG4gICAgICAnbT0nICsgbWVkaWEua2luZCArICcgOSAnICsgbWVkaWEucHJvdG9jb2wgKyAnICcgKyBzY3RwLnBvcnQgKyAnXFxyXFxuJyxcbiAgICAgICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJyxcbiAgICAgICdhPXNjdHBtYXA6JyArIHNjdHAucG9ydCArICcgJyArIHNjdHAucHJvdG9jb2wgKyAnIDY1NTM1XFxyXFxuJyxcbiAgICBdO1xuICB9XG4gIGlmIChzY3RwLm1heE1lc3NhZ2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQucHVzaCgnYT1tYXgtbWVzc2FnZS1zaXplOicgKyBzY3RwLm1heE1lc3NhZ2VTaXplICsgJ1xcclxcbicpO1xuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJyk7XG59O1xuXG4vLyBHZW5lcmF0ZSBhIHNlc3Npb24gSUQgZm9yIFNEUC5cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLXJ0Y3dlYi1qc2VwLTIwI3NlY3Rpb24tNS4yLjFcbi8vIHJlY29tbWVuZHMgdXNpbmcgYSBjcnlwdG9ncmFwaGljYWxseSByYW5kb20gK3ZlIDY0LWJpdCB2YWx1ZVxuLy8gYnV0IHJpZ2h0IG5vdyB0aGlzIHNob3VsZCBiZSBhY2NlcHRhYmxlIGFuZCB3aXRoaW4gdGhlIHJpZ2h0IHJhbmdlXG5TRFBVdGlscy5nZW5lcmF0ZVNlc3Npb25JZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygpLnN1YnN0cigyLCAyMik7XG59O1xuXG4vLyBXcml0ZSBib2lsZXIgcGxhdGUgZm9yIHN0YXJ0IG9mIFNEUFxuLy8gc2Vzc0lkIGFyZ3VtZW50IGlzIG9wdGlvbmFsIC0gaWYgbm90IHN1cHBsaWVkIGl0IHdpbGxcbi8vIGJlIGdlbmVyYXRlZCByYW5kb21seVxuLy8gc2Vzc1ZlcnNpb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIDJcbi8vIHNlc3NVc2VyIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAndGhpc2lzYWRhcHRlcm9ydGMnXG5TRFBVdGlscy53cml0ZVNlc3Npb25Cb2lsZXJwbGF0ZSA9IGZ1bmN0aW9uKHNlc3NJZCwgc2Vzc1Zlciwgc2Vzc1VzZXIpIHtcbiAgbGV0IHNlc3Npb25JZDtcbiAgY29uc3QgdmVyc2lvbiA9IHNlc3NWZXIgIT09IHVuZGVmaW5lZCA/IHNlc3NWZXIgOiAyO1xuICBpZiAoc2Vzc0lkKSB7XG4gICAgc2Vzc2lvbklkID0gc2Vzc0lkO1xuICB9IGVsc2Uge1xuICAgIHNlc3Npb25JZCA9IFNEUFV0aWxzLmdlbmVyYXRlU2Vzc2lvbklkKCk7XG4gIH1cbiAgY29uc3QgdXNlciA9IHNlc3NVc2VyIHx8ICd0aGlzaXNhZGFwdGVyb3J0Yyc7XG4gIC8vIEZJWE1FOiBzZXNzLWlkIHNob3VsZCBiZSBhbiBOVFAgdGltZXN0YW1wLlxuICByZXR1cm4gJ3Y9MFxcclxcbicgK1xuICAgICAgJ289JyArIHVzZXIgKyAnICcgKyBzZXNzaW9uSWQgKyAnICcgKyB2ZXJzaW9uICtcbiAgICAgICAgJyBJTiBJUDQgMTI3LjAuMC4xXFxyXFxuJyArXG4gICAgICAncz0tXFxyXFxuJyArXG4gICAgICAndD0wIDBcXHJcXG4nO1xufTtcblxuLy8gR2V0cyB0aGUgZGlyZWN0aW9uIGZyb20gdGhlIG1lZGlhU2VjdGlvbiBvciB0aGUgc2Vzc2lvbnBhcnQuXG5TRFBVdGlscy5nZXREaXJlY3Rpb24gPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gIC8vIExvb2sgZm9yIHNlbmRyZWN2LCBzZW5kb25seSwgcmVjdm9ubHksIGluYWN0aXZlLCBkZWZhdWx0IHRvIHNlbmRyZWN2LlxuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHN3aXRjaCAobGluZXNbaV0pIHtcbiAgICAgIGNhc2UgJ2E9c2VuZHJlY3YnOlxuICAgICAgY2FzZSAnYT1zZW5kb25seSc6XG4gICAgICBjYXNlICdhPXJlY3Zvbmx5JzpcbiAgICAgIGNhc2UgJ2E9aW5hY3RpdmUnOlxuICAgICAgICByZXR1cm4gbGluZXNbaV0uc3Vic3RyaW5nKDIpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRklYTUU6IFdoYXQgc2hvdWxkIGhhcHBlbiBoZXJlP1xuICAgIH1cbiAgfVxuICBpZiAoc2Vzc2lvbnBhcnQpIHtcbiAgICByZXR1cm4gU0RQVXRpbHMuZ2V0RGlyZWN0aW9uKHNlc3Npb25wYXJ0KTtcbiAgfVxuICByZXR1cm4gJ3NlbmRyZWN2Jztcbn07XG5cblNEUFV0aWxzLmdldEtpbmQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIGNvbnN0IG1saW5lID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcbiAgcmV0dXJuIG1saW5lWzBdLnN1YnN0cmluZygyKTtcbn07XG5cblNEUFV0aWxzLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgcmV0dXJuIG1lZGlhU2VjdGlvbi5zcGxpdCgnICcsIDIpWzFdID09PSAnMCc7XG59O1xuXG5TRFBVdGlscy5wYXJzZU1MaW5lID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICBjb25zdCBwYXJ0cyA9IGxpbmVzWzBdLnN1YnN0cmluZygyKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IHBhcnRzWzBdLFxuICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzFdLCAxMCksXG4gICAgcHJvdG9jb2w6IHBhcnRzWzJdLFxuICAgIGZtdDogcGFydHMuc2xpY2UoMykuam9pbignICcpLFxuICB9O1xufTtcblxuU0RQVXRpbHMucGFyc2VPTGluZSA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnbz0nKVswXTtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygyKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHVzZXJuYW1lOiBwYXJ0c1swXSxcbiAgICBzZXNzaW9uSWQ6IHBhcnRzWzFdLFxuICAgIHNlc3Npb25WZXJzaW9uOiBwYXJzZUludChwYXJ0c1syXSwgMTApLFxuICAgIG5ldFR5cGU6IHBhcnRzWzNdLFxuICAgIGFkZHJlc3NUeXBlOiBwYXJ0c1s0XSxcbiAgICBhZGRyZXNzOiBwYXJ0c1s1XSxcbiAgfTtcbn07XG5cbi8vIGEgdmVyeSBuYWl2ZSBpbnRlcnByZXRhdGlvbiBvZiBhIHZhbGlkIFNEUC5cblNEUFV0aWxzLmlzVmFsaWRTRFAgPSBmdW5jdGlvbihibG9iKSB7XG4gIGlmICh0eXBlb2YgYmxvYiAhPT0gJ3N0cmluZycgfHwgYmxvYi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKGJsb2IpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxpbmVzW2ldLmxlbmd0aCA8IDIgfHwgbGluZXNbaV0uY2hhckF0KDEpICE9PSAnPScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVE9ETzogY2hlY2sgdGhlIG1vZGlmaWVyIGEgYml0IG1vcmUuXG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMuXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBTRFBVdGlscztcbn1cbiIsInZhciBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFpc1Byb2R1Y3Rpb24pIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRleHQgPSBcIldhcm5pbmc6IFwiICsgbWVzc2FnZTtcblxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2Fybih0ZXh0KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhyb3cgRXJyb3IodGV4dCk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB3YXJuaW5nO1xuIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IEZsYWdzLCBOdW1lcmljUGFyYW1ldGVycyB9IGZyb20gJy4uL0NvbmZpZy9Db25maWcnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuaW1wb3J0IHsgQWZrVGltZWRPdXRFdmVudCwgQWZrV2FybmluZ0FjdGl2YXRlRXZlbnQsIEFma1dhcm5pbmdEZWFjdGl2YXRlRXZlbnQsIEFma1dhcm5pbmdVcGRhdGVFdmVudCB9IGZyb20gJy4uL1V0aWwvRXZlbnRFbWl0dGVyJztcbmV4cG9ydCBjbGFzcyBBRktDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHBpeGVsU3RyZWFtaW5nLCBvbkRpc21pc3NBZmspIHtcbiAgICAgICAgLy8gdGltZSBvdXQgbG9naWMgZGV0YWlsc1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvdW50ZG93bkFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLndhcm5UaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jb3VudERvd24gPSAwO1xuICAgICAgICB0aGlzLmNvdW50RG93blRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZyA9IHBpeGVsU3RyZWFtaW5nO1xuICAgICAgICB0aGlzLm9uRGlzbWlzc0FmayA9IG9uRGlzbWlzc0FmaztcbiAgICAgICAgdGhpcy5vbkFGS1RpbWVkT3V0Q2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQUZLIHRpbWVkIG91dCwgZGlkIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoaXMgY2FsbGJhY2s/Jyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2RzIHRoYXQgb2NjdXIgd2hlbiBhbiBhZmsgZXZlbnQgbGlzdGVuZXIgaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIG9uQWZrQ2xpY2soKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jb3VudERvd25UaW1lcik7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSB8fCB0aGlzLmNvdW50ZG93bkFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydEFma1dhcm5pbmdUaW1lcigpO1xuICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBBZmtXYXJuaW5nRGVhY3RpdmF0ZUV2ZW50KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSB3YXJuaW5nIHRpbWVyIGlmIGEgdGltZW91dCBpcyBzZXQgZ3JlYXRlciB0aGF0IDAgc2Vjb25kc1xuICAgICAqL1xuICAgIHN0YXJ0QWZrV2FybmluZ1RpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZ2V0TnVtZXJpY1NldHRpbmdWYWx1ZShOdW1lcmljUGFyYW1ldGVycy5BRktUaW1lb3V0U2VjcykgPiAwICYmXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkFGS0RldGVjdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldEFma1dhcm5pbmdUaW1lcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSBhZmsgd2FybmluZyB0aW1lclxuICAgICAqL1xuICAgIHN0b3BBZmtXYXJuaW5nVGltZXIoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY291bnRkb3duQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLndhcm5UaW1lcik7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jb3VudERvd25UaW1lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdXNlIHRoZSB0aW1lciB3aGljaCB3aGVuIGVsYXBzZWQgd2lsbCB3YXJuIHRoZSB1c2VyIHRoZXkgYXJlIGluYWN0aXZlLlxuICAgICAqL1xuICAgIHBhdXNlQWZrV2FybmluZ1RpbWVyKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdXNlciBpbnRlcmFjdHMgdGhlbiByZXNldCB0aGUgd2FybmluZyB0aW1lci5cbiAgICAgKi9cbiAgICByZXNldEFma1dhcm5pbmdUaW1lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlICYmIHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuQUZLRGV0ZWN0aW9uKSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMud2FyblRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMud2FyblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmFjdGl2YXRlQWZrRXZlbnQoKSwgdGhpcy5jb25maWcuZ2V0TnVtZXJpY1NldHRpbmdWYWx1ZShOdW1lcmljUGFyYW1ldGVycy5BRktUaW1lb3V0U2VjcykgKiAxMDAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBBRksgb3ZlcmxheSBhbmQgYmVnaW4gdGhlIGNvdW50RG93blxuICAgICAqL1xuICAgIGFjdGl2YXRlQWZrRXZlbnQoKSB7XG4gICAgICAgIC8vIFBhdXNlIHRoZSB0aW1lciB3aGlsZSB0aGUgdXNlciBpcyBsb29raW5nIGF0IHRoZSBpbmFjdGl2aXR5IHdhcm5pbmcgb3ZlcmxheVxuICAgICAgICB0aGlzLnBhdXNlQWZrV2FybmluZ1RpbWVyKCk7XG4gICAgICAgIC8vIGluc3RhbnRpYXRlIGEgbmV3IG92ZXJsYXlcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBBZmtXYXJuaW5nQWN0aXZhdGVFdmVudCh7XG4gICAgICAgICAgICBjb3VudERvd246IHRoaXMuY291bnREb3duLFxuICAgICAgICAgICAgZGlzbWlzc0FmazogdGhpcy5vbkRpc21pc3NBZmtcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyB1cGRhdGUgb3VyIGNvdW50RG93biB0aW1lciBhbmQgb3ZlcmxheSBjb250ZW50c1xuICAgICAgICB0aGlzLmNvdW50RG93biA9IHRoaXMuY29uZmlnLmdldE51bWVyaWNTZXR0aW5nVmFsdWUoTnVtZXJpY1BhcmFtZXRlcnMuQUZLQ291bnRkb3duU2Vjcyk7XG4gICAgICAgIHRoaXMuY291bnRkb3duQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBBZmtXYXJuaW5nVXBkYXRlRXZlbnQoeyBjb3VudERvd246IHRoaXMuY291bnREb3duIH0pKTtcbiAgICAgICAgLy8gaWYgd2UgYXJlIGluIGxvY2tlZCBtb3VzZSBleGl0IHBvaW50ZXJsb2NrXG4gICAgICAgIGlmICghdGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5Ib3ZlcmluZ01vdXNlTW9kZSkpIHtcbiAgICAgICAgICAgIC8vIG1pbm9yIGhhY2sgdG8gYWxsZXZpYXRlIGlvcyBub3Qgc3VwcG9ydGluZyBwb2ludGVybG9ja1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmV4aXRQb2ludGVyTG9jaykge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmV4aXRQb2ludGVyTG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlc2V0IG91ciBjb3VudERvd24gaW50ZXJ2YWwgYWNjb3JkaW5nbHlcbiAgICAgICAgdGhpcy5jb3VudERvd25UaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY291bnREb3duLS07XG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudERvd24gPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB1c2VyIGZhaWxlZCB0byBjbGljayBzbyBoaWRlIHRoZSBvdmVybGF5IGFuZCBkaXNjb25uZWN0IHRoZW0uXG4gICAgICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBBZmtUaW1lZE91dEV2ZW50KCkpO1xuICAgICAgICAgICAgICAgIHRoaXMub25BRktUaW1lZE91dENhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ1lvdSBoYXZlIGJlZW4gZGlzY29ubmVjdGVkIGR1ZSB0byBpbmFjdGl2aXR5Jyk7XG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoIG9mZiB0aGUgYWZrIGZlYXR1cmUgYXMgc3RyZWFtIGhhcyBjbG9zZWRcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BBZmtXYXJuaW5nVGltZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuZGlzcGF0Y2hFdmVudChuZXcgQWZrV2FybmluZ1VwZGF0ZUV2ZW50KHsgY291bnREb3duOiB0aGlzLmNvdW50RG93biB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMDApO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFGS0NvbnRyb2xsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42JztcbmltcG9ydCB7IFNldHRpbmdGbGFnIH0gZnJvbSAnLi9TZXR0aW5nRmxhZyc7XG5pbXBvcnQgeyBTZXR0aW5nTnVtYmVyIH0gZnJvbSAnLi9TZXR0aW5nTnVtYmVyJztcbmltcG9ydCB7IFNldHRpbmdUZXh0IH0gZnJvbSAnLi9TZXR0aW5nVGV4dCc7XG5pbXBvcnQgeyBTZXR0aW5nT3B0aW9uIH0gZnJvbSAnLi9TZXR0aW5nT3B0aW9uJztcbmltcG9ydCB7IFNldHRpbmdzQ2hhbmdlZEV2ZW50IH0gZnJvbSAnLi4vVXRpbC9FdmVudEVtaXR0ZXInO1xuaW1wb3J0IHsgQnJvd3NlclV0aWxzIH0gZnJvbSAnLi4vVXRpbC9Ccm93c2VyVXRpbHMnO1xuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgZmxhZ3MgdGhhdCBjYW4gYmUgdG9nZ2xlZCBhbmQgYXJlIGNvcmUgdG8gYWxsIFBpeGVsIFN0cmVhbWluZyBleHBlcmllbmNlcy5cbiAqIFRoZXNlIGFyZSB1c2VkIGluIHRoZSBgQ29uZmlnLkZsYWdzYCBtYXAuXG4gKi9cbmV4cG9ydCBjbGFzcyBGbGFncyB7XG59XG5GbGFncy5BdXRvQ29ubmVjdCA9ICdBdXRvQ29ubmVjdCc7XG5GbGFncy5BdXRvUGxheVZpZGVvID0gJ0F1dG9QbGF5VmlkZW8nO1xuRmxhZ3MuQUZLRGV0ZWN0aW9uID0gJ1RpbWVvdXRJZklkbGUnO1xuRmxhZ3MuSG92ZXJpbmdNb3VzZU1vZGUgPSAnSG92ZXJpbmdNb3VzZSc7XG5GbGFncy5Gb3JjZU1vbm9BdWRpbyA9ICdGb3JjZU1vbm9BdWRpbyc7XG5GbGFncy5Gb3JjZVRVUk4gPSAnRm9yY2VUVVJOJztcbkZsYWdzLkZha2VNb3VzZVdpdGhUb3VjaGVzID0gJ0Zha2VNb3VzZVdpdGhUb3VjaGVzJztcbkZsYWdzLklzUXVhbGl0eUNvbnRyb2xsZXIgPSAnQ29udHJvbHNRdWFsaXR5JztcbkZsYWdzLk1hdGNoVmlld3BvcnRSZXNvbHV0aW9uID0gJ01hdGNoVmlld3BvcnRSZXMnO1xuRmxhZ3MuU3RhcnRWaWRlb011dGVkID0gJ1N0YXJ0VmlkZW9NdXRlZCc7XG5GbGFncy5TdXBwcmVzc0Jyb3dzZXJLZXlzID0gJ1N1cHByZXNzQnJvd3NlcktleXMnO1xuRmxhZ3MuVXNlTWljID0gJ1VzZU1pYyc7XG5GbGFncy5Vc2VNb2RhbEZvclRleHRJbnB1dCA9ICdVc2VNb2RhbEZvclRleHRJbnB1dCc7XG5GbGFncy5Vc2VDYW1lcmEgPSAnVXNlQ2FtZXJhJztcbkZsYWdzLktleWJvYXJkSW5wdXQgPSAnS2V5Ym9hcmRJbnB1dCc7XG5GbGFncy5Nb3VzZUlucHV0ID0gJ01vdXNlSW5wdXQnO1xuRmxhZ3MuVG91Y2hJbnB1dCA9ICdUb3VjaElucHV0JztcbkZsYWdzLkdhbWVwYWRJbnB1dCA9ICdHYW1lcGFkSW5wdXQnO1xuRmxhZ3MuWFJDb250cm9sbGVySW5wdXQgPSAnWFJDb250cm9sbGVySW5wdXQnO1xuRmxhZ3MuV2FpdEZvclN0cmVhbWVyID0gJ1dhaXRGb3JTdHJlYW1lcic7XG5GbGFncy5IaWRlVUkgPSAnSGlkZVVJJztcbkZsYWdzLkVuYWJsZUNhcHR1cmVUaW1lRXh0ID0gJ0VuYWJsZUNhcHR1cmVUaW1lRXh0JztcbkZsYWdzLkJyb3dzZXJTZW5kT2ZmZXIgPSAnQnJvd3NlclNlbmRPZmZlcic7XG5GbGFncy5MYXRlbmN5Q1NWID0gJ0xhdGVuY3lDU1YnO1xuZXhwb3J0IGNvbnN0IGlzRmxhZ0lkID0gKGlkKSA9PiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhGbGFncykuc29tZSgobmFtZSkgPT4gRmxhZ3NbbmFtZV0gPT09IGlkKTtcbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIG51bWVyaWMgcGFyYW1ldGVycyB0aGF0IGFyZSBjb3JlIHRvIGFsbCBQaXhlbCBTdHJlYW1pbmcgZXhwZXJpZW5jZXMuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgTnVtZXJpY1BhcmFtZXRlcnMge1xufVxuTnVtZXJpY1BhcmFtZXRlcnMuQUZLVGltZW91dFNlY3MgPSAnQUZLVGltZW91dCc7XG5OdW1lcmljUGFyYW1ldGVycy5BRktDb3VudGRvd25TZWNzID0gJ0FGS0NvdW50ZG93bic7XG5OdW1lcmljUGFyYW1ldGVycy5NaW5RUCA9ICdNaW5RUCc7XG5OdW1lcmljUGFyYW1ldGVycy5NYXhRUCA9ICdNYXhRUCc7XG5OdW1lcmljUGFyYW1ldGVycy5NaW5RdWFsaXR5ID0gJ01pblF1YWxpdHknO1xuTnVtZXJpY1BhcmFtZXRlcnMuTWF4UXVhbGl0eSA9ICdNYXhRdWFsaXR5Jztcbk51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNaW4gPSAnQ29tcGF0UXVhbGl0eU1pbic7XG5OdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWF4ID0gJ0NvbXBhdFF1YWxpdHlNYXgnO1xuTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDRlBTID0gJ1dlYlJUQ0ZQUyc7XG5OdW1lcmljUGFyYW1ldGVycy5XZWJSVENNaW5CaXRyYXRlID0gJ1dlYlJUQ01pbkJpdHJhdGUnO1xuTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWF4Qml0cmF0ZSA9ICdXZWJSVENNYXhCaXRyYXRlJztcbk51bWVyaWNQYXJhbWV0ZXJzLk1heFJlY29ubmVjdEF0dGVtcHRzID0gJ01heFJlY29ubmVjdEF0dGVtcHRzJztcbk51bWVyaWNQYXJhbWV0ZXJzLlN0cmVhbWVyQXV0b0pvaW5JbnRlcnZhbCA9ICdTdHJlYW1lckF1dG9Kb2luSW50ZXJ2YWwnO1xuTnVtZXJpY1BhcmFtZXRlcnMuS2VlcGFsaXZlRGVsYXkgPSAnS2VlcGFsaXZlRGVsYXknO1xuZXhwb3J0IGNvbnN0IGlzTnVtZXJpY0lkID0gKGlkKSA9PiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhOdW1lcmljUGFyYW1ldGVycykuc29tZSgobmFtZSkgPT4gTnVtZXJpY1BhcmFtZXRlcnNbbmFtZV0gPT09IGlkKTtcbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHRleHR1YWwgcGFyYW1ldGVycyB0aGF0IGFyZSBjb3JlIHRvIGFsbCBQaXhlbCBTdHJlYW1pbmcgZXhwZXJpZW5jZXMuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgVGV4dFBhcmFtZXRlcnMge1xufVxuVGV4dFBhcmFtZXRlcnMuU2lnbmFsbGluZ1NlcnZlclVybCA9ICdzcyc7XG5leHBvcnQgY29uc3QgaXNUZXh0SWQgPSAoaWQpID0+IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFRleHRQYXJhbWV0ZXJzKS5zb21lKChuYW1lKSA9PiBUZXh0UGFyYW1ldGVyc1tuYW1lXSA9PT0gaWQpO1xuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgZW51bSBiYXNlZCBwYXJhbWV0ZXJzIHRoYXQgYXJlIGNvcmUgdG8gYWxsIFBpeGVsIFN0cmVhbWluZyBleHBlcmllbmNlcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBPcHRpb25QYXJhbWV0ZXJzIHtcbn1cbk9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkQ29kZWMgPSAnUHJlZmVycmVkQ29kZWMnO1xuT3B0aW9uUGFyYW1ldGVycy5TdHJlYW1lcklkID0gJ1N0cmVhbWVySWQnO1xuT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRRdWFsaXR5ID0gJ1ByZWZlcnJlZFF1YWxpdHknO1xuZXhwb3J0IGNvbnN0IGlzT3B0aW9uSWQgPSAoaWQpID0+IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9wdGlvblBhcmFtZXRlcnMpLnNvbWUoKG5hbWUpID0+IE9wdGlvblBhcmFtZXRlcnNbbmFtZV0gPT09IGlkKTtcbmV4cG9ydCBjbGFzcyBDb25maWcge1xuICAgIC8vIC0tLS0tLS0tLS0tLSBTZXR0aW5ncyAtLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIC8qIEEgbWFwIG9mIGZsYWdzIHRoYXQgY2FuIGJlIHRvZ2dsZWQgLSBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCBpbiB0aGUgYXBwbGljYXRpb24gLSBlLmcuIFVzZSBNaWM/ICovXG4gICAgICAgIHRoaXMuZmxhZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qIEEgbWFwIG9mIG51bWVyaWNhbCBzZXR0aW5ncyAtIG9wdGlvbnMgdGhhdCBjYW4gYmUgaW4gdGhlIGFwcGxpY2F0aW9uIC0gZS5nLiBNaW5CaXRyYXRlICovXG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qIEEgbWFwIG9mIHRleHQgc2V0dGluZ3MgLSBlLmcuIHNpZ25hbGxpbmcgc2VydmVyIHVybCAqL1xuICAgICAgICB0aGlzLnRleHRQYXJhbWV0ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiBBIG1hcCBvZiBlbnVtIGJhc2VkIHNldHRpbmdzIC0gZS5nLiBwcmVmZXJyZWQgY29kZWMgKi9cbiAgICAgICAgdGhpcy5vcHRpb25QYXJhbWV0ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCB7IGluaXRpYWxTZXR0aW5ncywgdXNlVXJsUGFyYW1zLCB3ZWJTb2NrZXRQcm90b2NvbHMgfSA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5fdXNlVXJsUGFyYW1zID0gISF1c2VVcmxQYXJhbXM7XG4gICAgICAgIHRoaXMuX3dlYlNvY2tldFByb3RvY29scyA9IHdlYlNvY2tldFByb3RvY29scztcbiAgICAgICAgdGhpcy5wb3B1bGF0ZURlZmF1bHRTZXR0aW5ncyh0aGlzLl91c2VVcmxQYXJhbXMsIGluaXRpYWxTZXR0aW5ncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgcmVhZGluZyBjb25maWd1cmF0aW9uIGluaXRpYWwgdmFsdWVzIGZyb20gVVJMIHBhcmFtZXRlcnMsIGFuZFxuICAgICAqIHBlcnNpc3RpbmcgY2hhbmdlcyBpbiBVUkwgd2hlbiBjaGFuZ2VkLlxuICAgICAqL1xuICAgIGdldCB1c2VVcmxQYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91c2VVcmxQYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBwcm90b2NvbCBvciBsaXN0IG9mIHByb3RvY29scyB0byBwYXNzIHRvIHRoZSB3ZWJzb2NrZXQgaWYgc2V0LlxuICAgICAqL1xuICAgIGdldCB3ZWJTb2NrZXRQcm90b2NvbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWJTb2NrZXRQcm90b2NvbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlIHRoZSBkZWZhdWx0IHNldHRpbmdzIGZvciBhIFBpeGVsIFN0cmVhbWluZyBhcHBsaWNhdGlvblxuICAgICAqL1xuICAgIHBvcHVsYXRlRGVmYXVsdFNldHRpbmdzKHVzZVVybFBhcmFtcywgc2V0dGluZ3MpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRleHQgUGFyYW1ldGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZXh0UGFyYW1ldGVycy5zZXQoVGV4dFBhcmFtZXRlcnMuU2lnbmFsbGluZ1NlcnZlclVybCwgbmV3IFNldHRpbmdUZXh0KFRleHRQYXJhbWV0ZXJzLlNpZ25hbGxpbmdTZXJ2ZXJVcmwsICdTaWduYWxsaW5nIHVybCcsICdVcmwgb2YgdGhlIHNpZ25hbGxpbmcgc2VydmVyJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBUZXh0UGFyYW1ldGVycy5TaWduYWxsaW5nU2VydmVyVXJsKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tUZXh0UGFyYW1ldGVycy5TaWduYWxsaW5nU2VydmVyVXJsXVxuICAgICAgICAgICAgOiAobG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonID8gJ3dzczovLycgOiAnd3M6Ly8nKSArXG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lICtcbiAgICAgICAgICAgICAgICAvLyBmb3IgcmVhZGFiaWxpdHksIHdlIG9taXQgdGhlIHBvcnQgaWYgaXQncyA4MFxuICAgICAgICAgICAgICAgICh3aW5kb3cubG9jYXRpb24ucG9ydCA9PT0gJzgwJyB8fCB3aW5kb3cubG9jYXRpb24ucG9ydCA9PT0gJydcbiAgICAgICAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICAgICAgICA6IGA6JHt3aW5kb3cubG9jYXRpb24ucG9ydH1gKSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMub3B0aW9uUGFyYW1ldGVycy5zZXQoT3B0aW9uUGFyYW1ldGVycy5TdHJlYW1lcklkLCBuZXcgU2V0dGluZ09wdGlvbihPcHRpb25QYXJhbWV0ZXJzLlN0cmVhbWVySWQsICdTdHJlYW1lciBJRCcsICdUaGUgSUQgb2YgdGhlIHN0cmVhbWVyIHRvIHN0cmVhbS4nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIE9wdGlvblBhcmFtZXRlcnMuU3RyZWFtZXJJZClcbiAgICAgICAgICAgID8gc2V0dGluZ3NbT3B0aW9uUGFyYW1ldGVycy5TdHJlYW1lcklkXVxuICAgICAgICAgICAgOiAnJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBPcHRpb25QYXJhbWV0ZXJzLlN0cmVhbWVySWQpXG4gICAgICAgICAgICA/IFtzZXR0aW5nc1tPcHRpb25QYXJhbWV0ZXJzLlN0cmVhbWVySWRdXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICBjb25zdCBnZXREZWZhdWx0VmlkZW9Db2RlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZGVvQ29kZWNzID0gQnJvd3NlclV0aWxzLmdldFN1cHBvcnRlZFZpZGVvQ29kZWNzKCk7XG4gICAgICAgICAgICAvLyBJZiBvbmx5IG9uZSBvcHRpb24sIHRoZW4gc2VsZWN0IHRoYXQuXG4gICAgICAgICAgICBpZiAodmlkZW9Db2RlY3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW9Db2RlY3NbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2aWRlb0NvZGVjcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdENvZGVjID0gdmlkZW9Db2RlY3NbMF07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb2RlYyBvZiB2aWRlb0NvZGVjcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZWMuc3RhcnRzV2l0aCgnSDI2NCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZWM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRDb2RlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIExvZ2dlci5FcnJvcignQ291bGQgbm90IGZpbmQgYW55IHJlYXNvbmFibGUgdmlkZW8gY29kZWMgdG8gYXNzaWduIGFzIGEgZGVmYXVsdC4nKTtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWF0Y2hTcGVjaWZpZWRDb2RlY1RvQ2xvc2VzdFN1cHBvcnRlZCA9IGZ1bmN0aW9uIChzcGVjaWZpZWRDb2RlYykge1xuICAgICAgICAgICAgY29uc3QgYnJvd3NlclN1cHBvcnRlZENvZGVjcyA9IEJyb3dzZXJVdGlscy5nZXRTdXBwb3J0ZWRWaWRlb0NvZGVjcygpO1xuICAgICAgICAgICAgLy8gQ29kZWMgc3VwcGxpZWQgaW4gdXJsIHBhcmFtIGlzIGFuIGV4YWN0IG1hdGNoIGZvciB0aGUgYnJvd3NlciBjb2RlYy5cbiAgICAgICAgICAgIC8vIChlLmcuIEgyNjQgbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQ9MTtwYWNrZXRpemF0aW9uLW1vZGU9MTtwcm9maWxlLWxldmVsLWlkPTQyZTAxZilcbiAgICAgICAgICAgIGlmIChicm93c2VyU3VwcG9ydGVkQ29kZWNzLmluY2x1ZGVzKHNwZWNpZmllZENvZGVjKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVjaWZpZWRDb2RlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRyeSB0byBtYXRjaCB0aGUgc3RhcnQgb2Ygd2hhdGV2ZXIgaXMgcGFzc2VkIGludG8gdGhlIHVybCBwYXJhbWV0ZXIgd2l0aCB3aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJyb3dzZXJDb2RlYyBvZiBicm93c2VyU3VwcG9ydGVkQ29kZWNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyb3dzZXJDb2RlYy5zdGFydHNXaXRoKHNwZWNpZmllZENvZGVjKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3NlckNvZGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIHdlcmVuJ3QgYWJsZSB0byBtYXRjaCwganVzdCByZXR1cm4gdGhlIGNvZGVjIGFzIGZyb20gdGhlIFVSTCBhcy1pcy5cbiAgICAgICAgICAgIHJldHVybiBzcGVjaWZpZWRDb2RlYztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVudW0gUGFyYW1ldGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpb25QYXJhbWV0ZXJzLnNldChPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZENvZGVjLCBuZXcgU2V0dGluZ09wdGlvbihPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZENvZGVjLCAnUHJlZmVycmVkIENvZGVjJywgJ1RoZSBwcmVmZXJyZWQgY29kZWMgdG8gYmUgdXNlZCBkdXJpbmcgY29kZWMgbmVnb3RpYXRpb24nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkQ29kZWMpXG4gICAgICAgICAgICA/IG1hdGNoU3BlY2lmaWVkQ29kZWNUb0Nsb3Nlc3RTdXBwb3J0ZWQoc2V0dGluZ3NbT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRDb2RlY10pXG4gICAgICAgICAgICA6IGdldERlZmF1bHRWaWRlb0NvZGVjKCksIEJyb3dzZXJVdGlscy5nZXRTdXBwb3J0ZWRWaWRlb0NvZGVjcygpLCB1c2VVcmxQYXJhbXMsIG1hdGNoU3BlY2lmaWVkQ29kZWNUb0Nsb3Nlc3RTdXBwb3J0ZWQpKTtcbiAgICAgICAgdGhpcy5vcHRpb25QYXJhbWV0ZXJzLnNldChPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZFF1YWxpdHksIG5ldyBTZXR0aW5nT3B0aW9uKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkUXVhbGl0eSwgJ1ByZWZlcnJlZCBRdWFsaXR5JywgJ1RoZSBwcmVmZXJyZWQgcXVhbGl0eSBvZiB0aGUgc3RyZWFtIChvbmx5IGFwcGxpY2FibGUgd2hlbiB1c2luZyB0aGUgU0ZVKScsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRRdWFsaXR5KVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZFF1YWxpdHldXG4gICAgICAgICAgICA6ICdEZWZhdWx0JywgWydEZWZhdWx0J10sIHVzZVVybFBhcmFtcykpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQm9vbGVhbiBwYXJhbWV0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5BdXRvQ29ubmVjdCwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLkF1dG9Db25uZWN0LCAnQXV0byBjb25uZWN0IHRvIHN0cmVhbScsICdXaGV0aGVyIHdlIHNob3VsZCBhdHRlbXB0IHRvIGF1dG8gY29ubmVjdCB0byB0aGUgc2lnbmFsbGluZyBzZXJ2ZXIgb3Igc2hvdyBhIGNsaWNrIHRvIHN0YXJ0IHByb21wdC4nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLkF1dG9Db25uZWN0KVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5BdXRvQ29ubmVjdF1cbiAgICAgICAgICAgIDogZmFsc2UsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5BdXRvUGxheVZpZGVvLCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuQXV0b1BsYXlWaWRlbywgJ0F1dG8gcGxheSB2aWRlbycsICdXaGVuIHZpZGVvIGlzIHJlYWR5IGF1dG9tYXRpY2FsbHkgc3RhcnQgcGxheWluZyBpdCBhcyBvcHBvc2VkIHRvIHNob3dpbmcgYSBwbGF5IGJ1dHRvbi4nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLkF1dG9QbGF5VmlkZW8pXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLkF1dG9QbGF5VmlkZW9dXG4gICAgICAgICAgICA6IHRydWUsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5Vc2VNaWMsIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5Vc2VNaWMsICdVc2UgbWljcm9waG9uZScsICdNYWtlIGJyb3dzZXIgcmVxdWVzdCBtaWNyb3Bob25lIGFjY2VzcyBhbmQgb3BlbiBhbiBpbnB1dCBhdWRpbyB0cmFjay4nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLlVzZU1pYylcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuVXNlTWljXVxuICAgICAgICAgICAgOiBmYWxzZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLlVzZU1vZGFsRm9yVGV4dElucHV0LCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuVXNlTW9kYWxGb3JUZXh0SW5wdXQsICdVc2UgbW9kYWwgZm9yIHRleHQgaW5wdXQnLCAnV2hlbiBlbnRlcmluZyBpbnB1dCBpbnRvIGEgc3RyZWFtZWQgVUUgdGV4dCB3aWRnZXQsIHVzZSBhbiBpbnB1dCBtb2RhbC4nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLlVzZU1vZGFsRm9yVGV4dElucHV0KVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5Vc2VNb2RhbEZvclRleHRJbnB1dF1cbiAgICAgICAgICAgIDogdHJ1ZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLlVzZUNhbWVyYSwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLlVzZUNhbWVyYSwgJ1VzZSB3ZWJjYW0nLCAnTWFrZSBicm93c2VyIHJlcXVlc3Qgd2ViY2FtIGFjY2VzcyBhbmQgb3BlbiBhIGlucHV0IHZpZGVvIHRyYWNrLicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuVXNlQ2FtZXJhKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5Vc2VDYW1lcmFdXG4gICAgICAgICAgICA6IGZhbHNlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuU3RhcnRWaWRlb011dGVkLCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuU3RhcnRWaWRlb011dGVkLCAnU3RhcnQgdmlkZW8gbXV0ZWQnLCAnVmlkZW8gd2lsbCBzdGFydCBtdXRlZCBpZiB0cnVlLicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuU3RhcnRWaWRlb011dGVkKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5TdGFydFZpZGVvTXV0ZWRdXG4gICAgICAgICAgICA6IGZhbHNlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuU3VwcHJlc3NCcm93c2VyS2V5cywgbmV3IFNldHRpbmdGbGFnKEZsYWdzLlN1cHByZXNzQnJvd3NlcktleXMsICdTdXBwcmVzcyBicm93c2VyIGtleXMnLCAnU3VwcHJlc3MgY2VydGFpbiBicm93c2VyIGtleXMgdGhhdCB3ZSB1c2UgaW4gVUUsIGZvciBleGFtcGxlIEY1IHRvIHNob3cgc2hhZGVyIGNvbXBsZXhpdHkgaW5zdGVhZCBvZiByZWZyZXNoIHRoZSBwYWdlLicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuU3VwcHJlc3NCcm93c2VyS2V5cylcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuU3VwcHJlc3NCcm93c2VyS2V5c11cbiAgICAgICAgICAgIDogdHJ1ZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLklzUXVhbGl0eUNvbnRyb2xsZXIsIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5Jc1F1YWxpdHlDb250cm9sbGVyLCAnSXMgcXVhbGl0eSBjb250cm9sbGVyPycsICdUcnVlIGlmIHRoaXMgcGVlciBjb250cm9scyBzdHJlYW0gcXVhbGl0eScsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuSXNRdWFsaXR5Q29udHJvbGxlcilcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuSXNRdWFsaXR5Q29udHJvbGxlcl1cbiAgICAgICAgICAgIDogdHJ1ZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLkZvcmNlTW9ub0F1ZGlvLCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuRm9yY2VNb25vQXVkaW8sICdGb3JjZSBtb25vIGF1ZGlvJywgJ0ZvcmNlIGJyb3dzZXIgdG8gcmVxdWVzdCBtb25vIGF1ZGlvIGluIHRoZSBTRFAnLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLkZvcmNlTW9ub0F1ZGlvKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5Gb3JjZU1vbm9BdWRpb11cbiAgICAgICAgICAgIDogZmFsc2UsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5Gb3JjZVRVUk4sIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5Gb3JjZVRVUk4sICdGb3JjZSBUVVJOJywgJ09ubHkgZ2VuZXJhdGUgVFVSTi9SZWxheWVkIElDRSBjYW5kaWRhdGVzLicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuRm9yY2VUVVJOKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5Gb3JjZVRVUk5dXG4gICAgICAgICAgICA6IGZhbHNlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuQUZLRGV0ZWN0aW9uLCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuQUZLRGV0ZWN0aW9uLCAnQUZLIGlmIGlkbGUnLCAnVGltZW91dCB0aGUgZXhwZXJpZW5jZSBpZiB1c2VyIGlzIEFGSyBmb3IgYSBwZXJpb2QuJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5BRktEZXRlY3Rpb24pXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLkFGS0RldGVjdGlvbl1cbiAgICAgICAgICAgIDogZmFsc2UsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5NYXRjaFZpZXdwb3J0UmVzb2x1dGlvbiwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLk1hdGNoVmlld3BvcnRSZXNvbHV0aW9uLCAnTWF0Y2ggdmlld3BvcnQgcmVzb2x1dGlvbicsICdQaXhlbCBTdHJlYW1pbmcgd2lsbCBiZSBpbnN0cnVjdGVkIHRvIGR5bmFtaWNhbGx5IHJlc2l6ZSB0aGUgdmlkZW8gc3RyZWFtIHRvIG1hdGNoIHRoZSBzaXplIG9mIHRoZSB2aWRlbyBlbGVtZW50LicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuTWF0Y2hWaWV3cG9ydFJlc29sdXRpb24pXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLk1hdGNoVmlld3BvcnRSZXNvbHV0aW9uXVxuICAgICAgICAgICAgOiBmYWxzZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLkhvdmVyaW5nTW91c2VNb2RlLCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuSG92ZXJpbmdNb3VzZU1vZGUsICdDb250cm9sIFNjaGVtZTogTG9ja2VkIE1vdXNlJywgJ0VpdGhlciBsb2NrZWQgbW91c2UsIHdoZXJlIHRoZSBwb2ludGVyIGlzIGNvbnN1bWVkIGJ5IHRoZSB2aWRlbyBhbmQgbG9ja2VkIHRvIGl0LCBvciBob3ZlcmluZyBtb3VzZSwgd2hlcmUgdGhlIG1vdXNlIGlzIG5vdCBjb25zdW1lZC4nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLkhvdmVyaW5nTW91c2VNb2RlKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5Ib3ZlcmluZ01vdXNlTW9kZV1cbiAgICAgICAgICAgIDogZmFsc2UsIHVzZVVybFBhcmFtcywgKGlzSG92ZXJpbmdNb3VzZSwgc2V0dGluZykgPT4ge1xuICAgICAgICAgICAgc2V0dGluZy5sYWJlbCA9IGBDb250cm9sIFNjaGVtZTogJHtpc0hvdmVyaW5nTW91c2UgPyAnSG92ZXJpbmcnIDogJ0xvY2tlZCd9IE1vdXNlYDtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5GYWtlTW91c2VXaXRoVG91Y2hlcywgbmV3IFNldHRpbmdGbGFnKEZsYWdzLkZha2VNb3VzZVdpdGhUb3VjaGVzLCAnRmFrZSBtb3VzZSB3aXRoIHRvdWNoZXMnLCAnQSBzaW5nbGUgZmluZ2VyIHRvdWNoIGlzIGNvbnZlcnRlZCBpbnRvIGEgbW91c2UgZXZlbnQuIFRoaXMgYWxsb3dzIGEgbm9uLXRvdWNoIGFwcGxpY2F0aW9uIHRvIGJlIGNvbnRyb2xsZWQgcGFydGlhbGx5IHZpYSBhIHRvdWNoIGRldmljZS4nLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLkZha2VNb3VzZVdpdGhUb3VjaGVzKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5GYWtlTW91c2VXaXRoVG91Y2hlc11cbiAgICAgICAgICAgIDogZmFsc2UsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5LZXlib2FyZElucHV0LCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuS2V5Ym9hcmRJbnB1dCwgJ0tleWJvYXJkIGlucHV0JywgJ0lmIGVuYWJsZWQsIHNlbmQga2V5Ym9hcmQgZXZlbnRzIHRvIHN0cmVhbWVyJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5LZXlib2FyZElucHV0KVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5LZXlib2FyZElucHV0XVxuICAgICAgICAgICAgOiB0cnVlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuTW91c2VJbnB1dCwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLk1vdXNlSW5wdXQsICdNb3VzZSBpbnB1dCcsICdJZiBlbmFibGVkLCBzZW5kIG1vdXNlIGV2ZW50cyB0byBzdHJlYW1lcicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuTW91c2VJbnB1dClcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuTW91c2VJbnB1dF1cbiAgICAgICAgICAgIDogdHJ1ZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLlRvdWNoSW5wdXQsIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5Ub3VjaElucHV0LCAnVG91Y2ggaW5wdXQnLCAnSWYgZW5hYmxlZCwgc2VuZCB0b3VjaCBldmVudHMgdG8gc3RyZWFtZXInLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLlRvdWNoSW5wdXQpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLlRvdWNoSW5wdXRdXG4gICAgICAgICAgICA6IHRydWUsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5HYW1lcGFkSW5wdXQsIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5HYW1lcGFkSW5wdXQsICdHYW1lcGFkIGlucHV0JywgJ0lmIGVuYWJsZWQsIHNlbmQgZ2FtZXBhZCBldmVudHMgdG8gc3RyZWFtZXInLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLkdhbWVwYWRJbnB1dClcbiAgICAgICAgICAgID8gc2V0dGluZ3NbRmxhZ3MuR2FtZXBhZElucHV0XVxuICAgICAgICAgICAgOiB0cnVlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuWFJDb250cm9sbGVySW5wdXQsIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5YUkNvbnRyb2xsZXJJbnB1dCwgJ1hSIGNvbnRyb2xsZXIgaW5wdXQnLCAnSWYgZW5hYmxlZCwgc2VuZCBYUiBjb250cm9sbGVyIGV2ZW50cyB0byBzdHJlYW1lcicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuWFJDb250cm9sbGVySW5wdXQpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLlhSQ29udHJvbGxlcklucHV0XVxuICAgICAgICAgICAgOiB0cnVlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuV2FpdEZvclN0cmVhbWVyLCBuZXcgU2V0dGluZ0ZsYWcoRmxhZ3MuV2FpdEZvclN0cmVhbWVyLCAnV2FpdCBmb3Igc3RyZWFtZXInLCAnV2lsbCBjb250aW51ZSB0cnlpbmcgdG8gY29ubmVjdCB0byB0aGUgZmlyc3Qgc3RyZWFtZXIgYXZhaWxhYmxlLicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuV2FpdEZvclN0cmVhbWVyKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5XYWl0Rm9yU3RyZWFtZXJdXG4gICAgICAgICAgICA6IHRydWUsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5IaWRlVUksIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5IaWRlVUksICdIaWRlIHRoZSBVSSBvdmVybGF5JywgJ1dpbGwgaGlkZSBhbGwgVUkgb3ZlcmxheSBkZXRhaWxzJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5IaWRlVUkpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLkhpZGVVSV1cbiAgICAgICAgICAgIDogZmFsc2UsIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLmZsYWdzLnNldChGbGFncy5FbmFibGVDYXB0dXJlVGltZUV4dCwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLkVuYWJsZUNhcHR1cmVUaW1lRXh0LCAnRW5hYmxlIGFicy1jYXB0dXJlLXRpbWUnLCAnRW5hYmxlcyB0aGUgYWJzLWNhcHR1cmUtdGltZSBSVFAgaGVhZGVyIGV4dGVuc2lvbicsIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgRmxhZ3MuRW5hYmxlQ2FwdHVyZVRpbWVFeHQpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLkVuYWJsZUNhcHR1cmVUaW1lRXh0XVxuICAgICAgICAgICAgOiBmYWxzZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMuZmxhZ3Muc2V0KEZsYWdzLkJyb3dzZXJTZW5kT2ZmZXIsIG5ldyBTZXR0aW5nRmxhZyhGbGFncy5Ccm93c2VyU2VuZE9mZmVyLCAnQnJvd3NlciBzZW5kIG9mZmVyICg0LjI3IE9OTFkpJywgJ0Jyb3dzZXIgd2lsbCBpbml0aWF0ZSB0aGUgV2ViUlRDIGhhbmRzaGFrZSBieSBzZW5kaW5nIHRoZSBvZmZlciB0byB0aGUgc3RyZWFtZXIgKDQuMjcgT05MWSknLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIEZsYWdzLkJyb3dzZXJTZW5kT2ZmZXIpXG4gICAgICAgICAgICA/IHNldHRpbmdzW0ZsYWdzLkJyb3dzZXJTZW5kT2ZmZXJdXG4gICAgICAgICAgICA6IGZhbHNlLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5mbGFncy5zZXQoRmxhZ3MuTGF0ZW5jeUNTViwgbmV3IFNldHRpbmdGbGFnKEZsYWdzLkxhdGVuY3lDU1YsICdFeHBvcnQgTGF0ZW5jeSBDU1YnLCAnU2hvd3MgYSBidXR0b24gaW4gdGhlIHN0YXRzIHBhbmVsIHRoYXQgYWxsb3dzIHRvIHJ1biBhIGxhdGVuY3kgdGVzdCBhbmQgZXhwb3J0IHRoZSByZXN1bHRzIHRvIGEgQ1NWIGZpbGUuJywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBGbGFncy5MYXRlbmN5Q1NWKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tGbGFncy5MYXRlbmN5Q1NWXVxuICAgICAgICAgICAgOiBmYWxzZSwgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1lcmljIHBhcmFtZXRlcnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLkFGS1RpbWVvdXRTZWNzLCBuZXcgU2V0dGluZ051bWJlcihOdW1lcmljUGFyYW1ldGVycy5BRktUaW1lb3V0U2VjcywgJ0FGSyB0aW1lb3V0JywgJ1RoZSB0aW1lIChpbiBzZWNvbmRzKSBpdCB0YWtlcyBmb3IgdGhlIGFwcGxpY2F0aW9uIHRvIHRpbWUgb3V0IGlmIEFGSyB0aW1lb3V0IGlzIGVuYWJsZWQuJywgMCAvKm1pbiovLCBudWxsIC8qbWF4Ki8sIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgTnVtZXJpY1BhcmFtZXRlcnMuQUZLVGltZW91dFNlY3MpXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLkFGS1RpbWVvdXRTZWNzXVxuICAgICAgICAgICAgOiAxMjAgLyp2YWx1ZSovLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycy5zZXQoTnVtZXJpY1BhcmFtZXRlcnMuQUZLQ291bnRkb3duU2VjcywgbmV3IFNldHRpbmdOdW1iZXIoTnVtZXJpY1BhcmFtZXRlcnMuQUZLQ291bnRkb3duU2VjcywgJ0FGSyBjb3VudGRvd24nLCAnVGhlIHRpbWUgKGluIHNlY29uZHMpIGZvciBhIHVzZXIgdG8gcmVzcG9uZCBiZWZvcmUgdGhlIHN0cmVhbSBpcyBlbmRlZCBhZnRlciBhbiBBRksgdGltZW91dC4nLCAxMCAvKm1pbiovLCBudWxsIC8qbWF4Ki8sIDEwIC8qdmFsdWUqLywgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLk1heFJlY29ubmVjdEF0dGVtcHRzLCBuZXcgU2V0dGluZ051bWJlcihOdW1lcmljUGFyYW1ldGVycy5NYXhSZWNvbm5lY3RBdHRlbXB0cywgJ01heCBSZWNvbm5lY3RzJywgJ01heGltdW0gbnVtYmVyIG9mIHJlY29ubmVjdHMgdGhlIGFwcGxpY2F0aW9uIHdpbGwgYXR0ZW1wdCB3aGVuIGEgc3RyZWFtZXIgZGlzY29ubmVjdHMuJywgMCAvKm1pbiovLCA5OTkgLyptYXgqLywgc2V0dGluZ3MgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgTnVtZXJpY1BhcmFtZXRlcnMuTWF4UmVjb25uZWN0QXR0ZW1wdHMpXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLk1heFJlY29ubmVjdEF0dGVtcHRzXVxuICAgICAgICAgICAgOiAzIC8qdmFsdWUqLywgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLk1pblFQLCBuZXcgU2V0dGluZ051bWJlcihOdW1lcmljUGFyYW1ldGVycy5NaW5RUCwgJ01pbiBRUCcsICdUaGUgbG93ZXIgYm91bmQgZm9yIHRoZSBxdWFudGl6YXRpb24gcGFyYW1ldGVyIChRUCkgb2YgdGhlIGVuY29kZXIuIDAgPSBCZXN0IHF1YWxpdHksIDUxID0gd29yc3QgcXVhbGl0eS4nLCAwIC8qbWluKi8sIDUxIC8qbWF4Ki8sIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgTnVtZXJpY1BhcmFtZXRlcnMuTWluUVApXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLk1pblFQXVxuICAgICAgICAgICAgOiAwIC8qdmFsdWUqLywgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLk1heFFQLCBuZXcgU2V0dGluZ051bWJlcihOdW1lcmljUGFyYW1ldGVycy5NYXhRUCwgJ01heCBRUCcsICdUaGUgdXBwZXIgYm91bmQgZm9yIHRoZSBxdWFudGl6YXRpb24gcGFyYW1ldGVyIChRUCkgb2YgdGhlIGVuY29kZXIuIDAgPSBCZXN0IHF1YWxpdHksIDUxID0gd29yc3QgcXVhbGl0eS4nLCAwIC8qbWluKi8sIDUxIC8qbWF4Ki8sIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgTnVtZXJpY1BhcmFtZXRlcnMuTWF4UVApXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLk1heFFQXVxuICAgICAgICAgICAgOiA1MSAvKnZhbHVlKi8sIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzLnNldChOdW1lcmljUGFyYW1ldGVycy5NaW5RdWFsaXR5LCBuZXcgU2V0dGluZ051bWJlcihOdW1lcmljUGFyYW1ldGVycy5NaW5RdWFsaXR5LCAnTWluIFF1YWxpdHknLCAnVGhlIGxvd2VyIGJvdW5kIGZvciB0aGUgcXVhbGl0eSBmYWN0b3Igb2YgdGhlIGVuY29kZXIuIDAgPSBXb3JzdCBxdWFsaXR5LCAxMDAgPSBCZXN0IHF1YWxpdHkuJywgMCAvKm1pbiovLCAxMDAgLyptYXgqLywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBOdW1lcmljUGFyYW1ldGVycy5NaW5RdWFsaXR5KVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tOdW1lcmljUGFyYW1ldGVycy5NaW5RdWFsaXR5XVxuICAgICAgICAgICAgOiAwIC8qdmFsdWUqLywgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLk1heFF1YWxpdHksIG5ldyBTZXR0aW5nTnVtYmVyKE51bWVyaWNQYXJhbWV0ZXJzLk1heFF1YWxpdHksICdNYXggUXVhbGl0eScsICdUaGUgdXBwZXIgYm91bmQgZm9yIHRoZSBxdWFsaXR5IGZhY3RvciBvZiB0aGUgZW5jb2Rlci4gMCA9IFdvcnN0IHF1YWxpdHksIDEwMCA9IEJlc3QgcXVhbGl0eS4nLCAwIC8qbWluKi8sIDEwMCAvKm1heCovLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIE51bWVyaWNQYXJhbWV0ZXJzLk1heFF1YWxpdHkpXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLk1heFF1YWxpdHldXG4gICAgICAgICAgICA6IDEwMCAvKnZhbHVlKi8sIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzLnNldChOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWluLCBuZXcgU2V0dGluZ051bWJlcihOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWluLCAnTWluIFF1YWxpdHknLCAnVGhlIGxvd2VyIGJvdW5kIGZvciBlbmNvZGluZyBxdWFsaXR5LiAwID0gV29yc3QsIDEwMCA9IEJlc3QuJywgMCAvKm1pbiovLCAxMDAgLyptYXgqLywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWluKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWluXVxuICAgICAgICAgICAgOiAwIC8qdmFsdWUqLywgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNYXgsIG5ldyBTZXR0aW5nTnVtYmVyKE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNYXgsICdNYXggUXVhbGl0eScsICdUaGUgdXBwZXIgYm91bmQgZm9yIGVuY29kaW5nIHF1YWxpdHkuIDAgPSBXb3JzdCwgMTAwID0gQmVzdC4nLCAwIC8qbWluKi8sIDEwMCAvKm1heCovLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNYXgpXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNYXhdXG4gICAgICAgICAgICA6IDEwMCAvKnZhbHVlKi8sIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzLnNldChOdW1lcmljUGFyYW1ldGVycy5XZWJSVENGUFMsIG5ldyBTZXR0aW5nTnVtYmVyKE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ0ZQUywgJ01heCBGUFMnLCAnVGhlIG1heGltdW0gRlBTIHRoYXQgV2ViUlRDIHdpbGwgdHJ5IHRvIHRyYW5zbWl0IGZyYW1lcyBhdC4nLCAxIC8qbWluKi8sIDk5OSAvKm1heCovLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ0ZQUylcbiAgICAgICAgICAgID8gc2V0dGluZ3NbTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDRlBTXVxuICAgICAgICAgICAgOiA2MCAvKnZhbHVlKi8sIHVzZVVybFBhcmFtcykpO1xuICAgICAgICB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzLnNldChOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNaW5CaXRyYXRlLCBuZXcgU2V0dGluZ051bWJlcihOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNaW5CaXRyYXRlLCAnTWluIEJpdHJhdGUgKGticHMpJywgJ1RoZSBtaW5pbXVtIGJpdHJhdGUgdGhhdCBXZWJSVEMgc2hvdWxkIHVzZS4nLCAwIC8qbWluKi8sIDUwMDAwMCAvKm1heCovLCBzZXR0aW5ncyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsIE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01pbkJpdHJhdGUpXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01pbkJpdHJhdGVdXG4gICAgICAgICAgICA6IDAgLyp2YWx1ZSovLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycy5zZXQoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWF4Qml0cmF0ZSwgbmV3IFNldHRpbmdOdW1iZXIoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWF4Qml0cmF0ZSwgJ01heCBCaXRyYXRlIChrYnBzKScsICdUaGUgbWF4aW11bSBiaXRyYXRlIHRoYXQgV2ViUlRDIHNob3VsZCB1c2UuJywgMCAvKm1pbiovLCA1MDAwMDAgLyptYXgqLywgc2V0dGluZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNYXhCaXRyYXRlKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNYXhCaXRyYXRlXVxuICAgICAgICAgICAgOiAwIC8qdmFsdWUqLywgdXNlVXJsUGFyYW1zKSk7XG4gICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuc2V0KE51bWVyaWNQYXJhbWV0ZXJzLlN0cmVhbWVyQXV0b0pvaW5JbnRlcnZhbCwgbmV3IFNldHRpbmdOdW1iZXIoTnVtZXJpY1BhcmFtZXRlcnMuU3RyZWFtZXJBdXRvSm9pbkludGVydmFsLCAnU3RyZWFtZXIgQXV0byBKb2luIEludGVydmFsIChtcyknLCAnRGVsYXkgYmV0d2VlbiByZXRyaWVzIHdoZW4gd2FpdGluZyBmb3IgYW4gYXZhaWxhYmxlIHN0cmVhbWVyLicsIDUwMCAvKm1pbiovLCA5MDAwMDAgLyptYXgqLywgc2V0dGluZ3MgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgTnVtZXJpY1BhcmFtZXRlcnMuU3RyZWFtZXJBdXRvSm9pbkludGVydmFsKVxuICAgICAgICAgICAgPyBzZXR0aW5nc1tOdW1lcmljUGFyYW1ldGVycy5TdHJlYW1lckF1dG9Kb2luSW50ZXJ2YWxdXG4gICAgICAgICAgICA6IDMwMDAgLyp2YWx1ZSovLCB1c2VVcmxQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycy5zZXQoTnVtZXJpY1BhcmFtZXRlcnMuS2VlcGFsaXZlRGVsYXksIG5ldyBTZXR0aW5nTnVtYmVyKE51bWVyaWNQYXJhbWV0ZXJzLktlZXBhbGl2ZURlbGF5LCAnQ29ubmVjdGlvbiBLZWVwYWxpdmUgZGVsYXknLCAnRGVsYXkgYmV0d2VlbiBrZWVwYWxpdmUgcGluZ3MgdG8gdGhlIHNpZ25hbGxpbmcgc2VydmVyLicsIDAgLyptaW4qLywgOTAwMDAwIC8qbWF4Ki8sIHNldHRpbmdzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgTnVtZXJpY1BhcmFtZXRlcnMuS2VlcGFsaXZlRGVsYXkpXG4gICAgICAgICAgICA/IHNldHRpbmdzW051bWVyaWNQYXJhbWV0ZXJzLktlZXBhbGl2ZURlbGF5XVxuICAgICAgICAgICAgOiAzMDAwMCAvKnZhbHVlKi8sIHVzZVVybFBhcmFtcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjYWxsYmFjayB0byBmaXJlIHdoZW4gdGhlIG51bWVyaWMgc2V0dGluZyBpcyB0b2dnbGVkLlxuICAgICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIGZsYWcuXG4gICAgICogQHBhcmFtIG9uQ2hhbmdlZExpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBmaXJlIHdoZW4gdGhlIG51bWVyaWMgdmFsdWUgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBfYWRkT25OdW1lcmljU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihpZCwgb25DaGFuZ2VkTGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycy5nZXQoaWQpLmFkZE9uQ2hhbmdlZExpc3RlbmVyKG9uQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYWRkT25PcHRpb25TZXR0aW5nQ2hhbmdlZExpc3RlbmVyKGlkLCBvbkNoYW5nZWRMaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25QYXJhbWV0ZXJzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uUGFyYW1ldGVycy5nZXQoaWQpLmFkZE9uQ2hhbmdlZExpc3RlbmVyKG9uQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBudW1lcmljIHNldHRpbmcgd2UgYXJlIGludGVyZXN0ZWQgaW4gZ2V0dGluZyBhIHZhbHVlIGZvci5cbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtZXJpYyB2YWx1ZSBzdG9yZWQgaW4gdGhlIHBhcmFtZXRlciB3aXRoIHRoZSBwYXNzZWQgaWQuXG4gICAgICovXG4gICAgZ2V0TnVtZXJpY1NldHRpbmdWYWx1ZShpZCkge1xuICAgICAgICBpZiAodGhpcy5udW1lcmljUGFyYW1ldGVycy5oYXMoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW1lcmljUGFyYW1ldGVycy5nZXQoaWQpLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgbm8gbnVtZXJpYyBzZXR0aW5nIHdpdGggdGhlIGlkIG9mICR7aWR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgdGV4dCBzZXR0aW5nIHdlIGFyZSBpbnRlcmVzdGVkIGluIGdldHRpbmcgYSB2YWx1ZSBmb3IuXG4gICAgICogQHJldHVybnMgVGhlIHRleHQgdmFsdWUgc3RvcmVkIGluIHRoZSBwYXJhbWV0ZXIgd2l0aCB0aGUgcGFzc2VkIGlkLlxuICAgICAqL1xuICAgIGdldFRleHRTZXR0aW5nVmFsdWUoaWQpIHtcbiAgICAgICAgaWYgKHRoaXMudGV4dFBhcmFtZXRlcnMuaGFzKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dFBhcmFtZXRlcnMuZ2V0KGlkKS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgbm8gbnVtZXJpYyBzZXR0aW5nIHdpdGggdGhlIGlkIG9mICR7aWR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IG51bWJlciBpbiB0aGUgc2V0dGluZy5cbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBudW1lcmljIHNldHRpbmcgd2UgYXJlIGludGVyZXN0ZWQgaW4uXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBudW1lcmljIHZhbHVlIHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXROdW1lcmljU2V0dGluZyhpZCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5udW1lcmljUGFyYW1ldGVycy5nZXQoaWQpLm51bWJlciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBubyBudW1lcmljIHNldHRpbmcgd2l0aCB0aGUgaWQgb2YgJHtpZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjYWxsYmFjayB0byBmaXJlIHdoZW4gdGhlIGZsYWcgaXMgdG9nZ2xlZC5cbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBmbGFnLlxuICAgICAqIEBwYXJhbSBvbkNoYW5nZUxpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBmaXJlIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuXG4gICAgICovXG4gICAgX2FkZE9uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihpZCwgb25DaGFuZ2VMaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLmZsYWdzLmdldChpZCkub25DaGFuZ2UgPSBvbkNoYW5nZUxpc3RlbmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiB0aGUgdGV4dCBpcyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIGZsYWcuXG4gICAgICogQHBhcmFtIG9uQ2hhbmdlTGlzdGVuZXIgVGhlIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBfYWRkT25UZXh0U2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihpZCwgb25DaGFuZ2VMaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy50ZXh0UGFyYW1ldGVycy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLnRleHRQYXJhbWV0ZXJzLmdldChpZCkub25DaGFuZ2UgPSBvbkNoYW5nZUxpc3RlbmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb3B0aW9uIHdoaWNoIGhhcyB0aGUgZ2l2ZW4gaWQuXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgb3B0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSBTZXR0aW5nT3B0aW9uIG9iamVjdCBtYXRjaGluZyBpZFxuICAgICAqL1xuICAgIGdldFNldHRpbmdPcHRpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uUGFyYW1ldGVycy5nZXQoaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBjb25maWd1cmF0aW9uIGZsYWcgd2hpY2ggaGFzIHRoZSBnaXZlbiBpZC5cbiAgICAgKiBAcGFyYW0gaWQgVGhlIHVuaXF1ZSBpZCBmb3IgdGhlIGZsYWcuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZmxhZyBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGlzRmxhZ0VuYWJsZWQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MuZ2V0KGlkKS5mbGFnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgZmxhZyB0byBiZSBlbmFibGVkL2Rpc2FibGVkLlxuICAgICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIGZsYWcgdG8gdG9nZ2xlLlxuICAgICAqIEBwYXJhbSBmbGFnRW5hYmxlZCBUcnVlIGlmIHRoZSBmbGFnIHNob3VsZCBiZSBlbmFibGVkLlxuICAgICAqL1xuICAgIHNldEZsYWdFbmFibGVkKGlkLCBmbGFnRW5hYmxlZCkge1xuICAgICAgICBpZiAoIXRoaXMuZmxhZ3MuaGFzKGlkKSkge1xuICAgICAgICAgICAgTG9nZ2VyLldhcm5pbmcoYENhbm5vdCB0b2dnbGUgZmxhZyBjYWxsZWQgJHtpZH0gLSBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgQ29uZmlnLmZsYWdzIG1hcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MuZ2V0KGlkKS5mbGFnID0gZmxhZ0VuYWJsZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB0ZXh0IHNldHRpbmcuXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgc2V0dGluZ1xuICAgICAqIEBwYXJhbSBzZXR0aW5nVmFsdWUgVGhlIHZhbHVlIHRvIHNldCBpbiB0aGUgc2V0dGluZy5cbiAgICAgKi9cbiAgICBzZXRUZXh0U2V0dGluZyhpZCwgc2V0dGluZ1ZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy50ZXh0UGFyYW1ldGVycy5oYXMoaWQpKSB7XG4gICAgICAgICAgICBMb2dnZXIuV2FybmluZyhgQ2Fubm90IHNldCB0ZXh0IHNldHRpbmcgY2FsbGVkICR7aWR9IC0gaXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIENvbmZpZy50ZXh0UGFyYW1ldGVycyBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRleHRQYXJhbWV0ZXJzLmdldChpZCkudGV4dCA9IHNldHRpbmdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG9wdGlvbiBzZXR0aW5nIGxpc3Qgb2Ygb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBzZXR0aW5nXG4gICAgICogQHBhcmFtIHNldHRpbmdPcHRpb25zIFRoZSB2YWx1ZXMgdGhlIHNldHRpbmcgY291bGQgdGFrZVxuICAgICAqL1xuICAgIHNldE9wdGlvblNldHRpbmdPcHRpb25zKGlkLCBzZXR0aW5nT3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9uUGFyYW1ldGVycy5oYXMoaWQpKSB7XG4gICAgICAgICAgICBMb2dnZXIuV2FybmluZyhgQ2Fubm90IHNldCB0ZXh0IHNldHRpbmcgY2FsbGVkICR7aWR9IC0gaXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIENvbmZpZy5vcHRpb25QYXJhbWV0ZXJzIG1hcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uUGFyYW1ldGVycy5nZXQoaWQpLm9wdGlvbnMgPSBzZXR0aW5nT3B0aW9ucztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgb3B0aW9uIGVudW0gc2V0dGluZ3Mgc2VsZWN0ZWQgb3B0aW9uLlxuICAgICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIHNldHRpbmdcbiAgICAgKiBAcGFyYW0gc2V0dGluZ09wdGlvbnMgVGhlIHZhbHVlIHRvIHNlbGVjdCBvdXQgb2YgYWxsIHRoZSBvcHRpb25zXG4gICAgICovXG4gICAgc2V0T3B0aW9uU2V0dGluZ1ZhbHVlKGlkLCBzZXR0aW5nVmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvblBhcmFtZXRlcnMuaGFzKGlkKSkge1xuICAgICAgICAgICAgTG9nZ2VyLldhcm5pbmcoYENhbm5vdCBzZXQgdGV4dCBzZXR0aW5nIGNhbGxlZCAke2lkfSAtIGl0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBDb25maWcuZW51bVBhcmFtZXRlcnMgbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uU2V0dGluZyA9IHRoaXMub3B0aW9uUGFyYW1ldGVycy5nZXQoaWQpO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdPcHRpb25zID0gb3B0aW9uU2V0dGluZy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKCFleGlzdGluZ09wdGlvbnMuaW5jbHVkZXMoc2V0dGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nT3B0aW9ucy5wdXNoKHNldHRpbmdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgb3B0aW9uU2V0dGluZy5vcHRpb25zID0gZXhpc3RpbmdPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9uU2V0dGluZy5zZWxlY3RlZCA9IHNldHRpbmdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxhYmVsIGZvciB0aGUgZmxhZy5cbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBmbGFnLlxuICAgICAqIEBwYXJhbSBsYWJlbCBUaGUgbmV3IGxhYmVsIHRvIHVzZSBmb3IgdGhlIGZsYWcuXG4gICAgICovXG4gICAgc2V0RmxhZ0xhYmVsKGlkLCBsYWJlbCkge1xuICAgICAgICBpZiAoIXRoaXMuZmxhZ3MuaGFzKGlkKSkge1xuICAgICAgICAgICAgTG9nZ2VyLldhcm5pbmcoYENhbm5vdCBzZXQgbGFiZWwgZm9yIGZsYWcgY2FsbGVkICR7aWR9IC0gaXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIENvbmZpZy5mbGFncyBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZsYWdzLmdldChpZCkubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBzdWJzZXQgb2YgYWxsIHNldHRpbmdzIGluIG9uZSBmdW5jdGlvbiBjYWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNldHRpbmdzIEEgKHBhcnRpYWwpIGxpc3Qgb2Ygc2V0dGluZ3MgdG8gc2V0XG4gICAgICovXG4gICAgc2V0U2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2V0dGluZ3MpKSB7XG4gICAgICAgICAgICBpZiAoaXNGbGFnSWQoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmxhZ0VuYWJsZWQoa2V5LCBzZXR0aW5nc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTnVtZXJpY0lkKGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE51bWVyaWNTZXR0aW5nKGtleSwgc2V0dGluZ3Nba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1RleHRJZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUZXh0U2V0dGluZyhrZXksIHNldHRpbmdzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPcHRpb25JZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25TZXR0aW5nVmFsdWUoa2V5LCBzZXR0aW5nc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHNldHRpbmdzXG4gICAgICogQHJldHVybnMgQWxsIHNldHRpbmcgdmFsdWVzIGFzIGFuIG9iamVjdCB3aXRoIHNldHRpbmcgaWRzIGFzIGtleXNcbiAgICAgKi9cbiAgICBnZXRTZXR0aW5ncygpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5mbGFncy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzW2tleV0gPSB2YWx1ZS5mbGFnO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWUubnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMudGV4dFBhcmFtZXRlcnMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWUudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLm9wdGlvblBhcmFtZXRlcnMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWUuc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIEZsYWcgc2V0dGluZ3MgYXMgYW4gYXJyYXkuXG4gICAgICogQHJldHVybnMgQWxsIFNldHRpbmdGbGFnIG9iamVjdHNcbiAgICAgKi9cbiAgICBnZXRGbGFncygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5mbGFncy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgVGV4dCBzZXR0aW5ncyBhcyBhbiBhcnJheS5cbiAgICAgKiBAcmV0dXJucyBBbGwgU2V0dGluZ1RleHQgb2JqZWN0c1xuICAgICAqL1xuICAgIGdldFRleHRTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy50ZXh0UGFyYW1ldGVycy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgTnVtYmVyIHNldHRpbmdzIGFzIGFuIGFycmF5LlxuICAgICAqIEByZXR1cm5zIEFsbCBTZXR0aW5nTnVtYmVyIG9iamVjdHNcbiAgICAgKi9cbiAgICBnZXROdW1lcmljU2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubnVtZXJpY1BhcmFtZXRlcnMudmFsdWVzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIE9wdGlvbiBzZXR0aW5ncyBhcyBhbiBhcnJheS5cbiAgICAgKiBAcmV0dXJucyBBbGwgU2V0dGluZ09wdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgZ2V0T3B0aW9uU2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMub3B0aW9uUGFyYW1ldGVycy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXQgZXZlbnRzIHdoZW4gc2V0dGluZ3MgY2hhbmdlLlxuICAgICAqIEBwYXJhbSBldmVudEVtaXR0ZXJcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJPbkNoYW5nZUV2ZW50cyhldmVudEVtaXR0ZXIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5mbGFncy5rZXlzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZsYWcgPSB0aGlzLmZsYWdzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgICAgICBmbGFnLm9uQ2hhbmdlRW1pdCA9IChuZXdWYWx1ZSkgPT4gZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFNldHRpbmdzQ2hhbmdlZEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGZsYWcuaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmbGFnJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGZsYWdcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5udW1lcmljUGFyYW1ldGVycy5rZXlzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bWJlciA9IHRoaXMubnVtZXJpY1BhcmFtZXRlcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAobnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyLm9uQ2hhbmdlRW1pdCA9IChuZXdWYWx1ZSkgPT4gZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFNldHRpbmdzQ2hhbmdlZEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG51bWJlci5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBudW1iZXJcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy50ZXh0UGFyYW1ldGVycy5rZXlzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLnRleHRQYXJhbWV0ZXJzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0Lm9uQ2hhbmdlRW1pdCA9IChuZXdWYWx1ZSkgPT4gZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFNldHRpbmdzQ2hhbmdlZEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRleHQuaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRleHRcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5vcHRpb25QYXJhbWV0ZXJzLmtleXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gdGhpcy5vcHRpb25QYXJhbWV0ZXJzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5vbkNoYW5nZUVtaXQgPSAobmV3VmFsdWUpID0+IGV2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBTZXR0aW5nc0NoYW5nZWRFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBvcHRpb24uaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdvcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogb3B0aW9uXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgZW51bSBhc3NvY2lhdGVkIHdpdGggdGhlIG1vdXNlIGJlaW5nIGxvY2tlZCBvciBob3ZlcmluZ1xuICovXG5leHBvcnQgdmFyIENvbnRyb2xTY2hlbWVUeXBlO1xuKGZ1bmN0aW9uIChDb250cm9sU2NoZW1lVHlwZSkge1xuICAgIENvbnRyb2xTY2hlbWVUeXBlW0NvbnRyb2xTY2hlbWVUeXBlW1wiTG9ja2VkTW91c2VcIl0gPSAwXSA9IFwiTG9ja2VkTW91c2VcIjtcbiAgICBDb250cm9sU2NoZW1lVHlwZVtDb250cm9sU2NoZW1lVHlwZVtcIkhvdmVyaW5nTW91c2VcIl0gPSAxXSA9IFwiSG92ZXJpbmdNb3VzZVwiO1xufSkoQ29udHJvbFNjaGVtZVR5cGUgfHwgKENvbnRyb2xTY2hlbWVUeXBlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbmZpZy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhIHNldHRpbmcgdGhhdCBoYXMgYSB0ZXh0IGxhYmVsIGFuZCBhbiBhcmJpdHJhcnkgc2V0dGluZyB2YWx1ZSBpdCBzdG9yZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXR0aW5nQmFzZSB7XG4gICAgY29uc3RydWN0b3IoaWQsIGxhYmVsLCBkZXNjcmlwdGlvbiwgZGVmYXVsdFNldHRpbmdWYWx1ZSwgZGVmYXVsdE9uQ2hhbmdlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIC8qIERvIG5vdGhpbmcsIHRvIGJlIG92ZXJyaWRkZW4uICovXG4gICAgfSkge1xuICAgICAgICB0aGlzLnBhcnNlVVJMUGFyYW1zKCk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBkZWZhdWx0T25DaGFuZ2VMaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUVtaXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAvKiBEbyBub3RoaW5nLCB0byBiZSBvdmVycmlkZGVuLiAqL1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB0aGlzLnZhbHVlID0gZGVmYXVsdFNldHRpbmdWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsYWJlbCB0ZXh0IGZvciB0aGUgc2V0dGluZy5cbiAgICAgKiBAcGFyYW0gbGFiZWwgc2V0dGluZyBsYWJlbC5cbiAgICAgKi9cbiAgICBzZXQgbGFiZWwoaW5MYWJlbCkge1xuICAgICAgICB0aGlzLl9sYWJlbCA9IGluTGFiZWw7XG4gICAgICAgIHRoaXMub25DaGFuZ2VFbWl0KHRoaXMuX3ZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIGxhYmVsIHRleHQgZm9yIHRoZSBzZXR0aW5nLlxuICAgICAqL1xuICAgIGdldCBsYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhYmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFRoZSBzZXR0aW5nJ3MgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc2V0dGluZydzIHN0b3JlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gaW5WYWx1ZSBUaGUgbmV3IHZhbHVlIGZvciB0aGUgc2V0dGluZy5cbiAgICAgKi9cbiAgICBzZXQgdmFsdWUoaW5WYWx1ZSkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IGluVmFsdWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2UodGhpcy5fdmFsdWUsIHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlRW1pdCh0aGlzLl92YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcnNpc3QgdGhlIHNldHRpbmcgdmFsdWUgaW4gVVJMLlxuICAgICAqL1xuICAgIHVwZGF0ZVVSTFBhcmFtcygpIHtcbiAgICAgICAgaWYgKHRoaXMudXNlVXJsUGFyYW1zKSB7XG4gICAgICAgICAgICAvLyBzZXQgdXJsIHBhcmFtc1xuICAgICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlU3RyaW5nID0gdGhpcy5nZXRWYWx1ZUFzU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBfdmFsdWVdIG9mIHVybFBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgPT0gdGhpcy5pZC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybFBhcmFtcy5zZXQobmFtZSwgdmFsdWVTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBzZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNldCkge1xuICAgICAgICAgICAgICAgIHVybFBhcmFtcy5zZXQodGhpcy5pZCwgdmFsdWVTdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCAnJywgdXJsUGFyYW1zLnRvU3RyaW5nKCkgIT09ICcnID8gYCR7bG9jYXRpb24ucGF0aG5hbWV9PyR7dXJsUGFyYW1zfWAgOiBgJHtsb2NhdGlvbi5wYXRobmFtZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3Mgc3ViIHR5cGVzIHRvIHByb3ZpZGUgdGhlaXIgdmFsdWUgZm9yIHRoZSB1cmwgc2VhcmNoIHBhcmFtcy5cbiAgICAgKi9cbiAgICBnZXRWYWx1ZUFzU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHBhcnNlVVJMUGFyYW1zKCkge1xuICAgICAgICB0aGlzLl91cmxQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIHBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5fdXJsUGFyYW1zW25hbWUudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNVUkxQYXJhbShuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCkgaW4gdGhpcy5fdXJsUGFyYW1zO1xuICAgIH1cbiAgICBnZXRVUkxQYXJhbShuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1VSTFBhcmFtKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXJsUGFyYW1zW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNldHRpbmdCYXNlLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBTZXR0aW5nQmFzZSB9IGZyb20gJy4vU2V0dGluZ0Jhc2UnO1xuLyoqXG4gKiBBIGJvb2xlYW4gZmxhZyBzZXR0aW5nIG9iamVjdCB3aXRoIGEgdGV4dCBsYWJlbC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNldHRpbmdGbGFnIGV4dGVuZHMgU2V0dGluZ0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBsYWJlbCwgZGVzY3JpcHRpb24sIGRlZmF1bHRGbGFnVmFsdWUsIHVzZVVybFBhcmFtcywgZGVmYXVsdE9uQ2hhbmdlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIC8qIERvIG5vdGhpbmcsIHRvIGJlIG92ZXJyaWRkZW4uICovXG4gICAgfSkge1xuICAgICAgICBzdXBlcihpZCwgbGFiZWwsIGRlc2NyaXB0aW9uLCBkZWZhdWx0RmxhZ1ZhbHVlLCBkZWZhdWx0T25DaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgIGlmICghdXNlVXJsUGFyYW1zIHx8ICF0aGlzLmhhc1VSTFBhcmFtKHRoaXMuaWQpKSB7XG4gICAgICAgICAgICB0aGlzLmZsYWcgPSBkZWZhdWx0RmxhZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFyc2UgZmxhZyBmcm9tIHVybCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICBjb25zdCB1cmxQYXJhbUZsYWcgPSB0aGlzLmdldFVSTFBhcmFtKHRoaXMuaWQpO1xuICAgICAgICAgICAgdGhpcy5mbGFnID0gdXJsUGFyYW1GbGFnLnRvTG93ZXJDYXNlKCkgIT0gJ2ZhbHNlJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZVVybFBhcmFtcyA9IHVzZVVybFBhcmFtcztcbiAgICB9XG4gICAgZ2V0VmFsdWVBc1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZyA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhpcyBmbGFnLlxuICAgICAqL1xuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgdGhpcy5mbGFnID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiBUaGUgc2V0dGluZydzIHZhbHVlLlxuICAgICAqL1xuICAgIGdldCBmbGFnKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHNldHRpbmcncyBzdG9yZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIGluVmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHNldHRpbmcuXG4gICAgICovXG4gICAgc2V0IGZsYWcoaW5WYWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gaW5WYWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXR0aW5nRmxhZy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgU2V0dGluZ0Jhc2UgfSBmcm9tICcuL1NldHRpbmdCYXNlJztcbi8qKlxuICogQSBudW1iZXIgc2V0dGluZyBvYmplY3Qgd2l0aCBhIHRleHQgbGFiZWwuIE1pbiBhbmQgbWF4IGxpbWl0IHRoZSByYW5nZSBvZiBhbGxvd2VkIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNldHRpbmdOdW1iZXIgZXh0ZW5kcyBTZXR0aW5nQmFzZSB7XG4gICAgY29uc3RydWN0b3IoaWQsIGxhYmVsLCBkZXNjcmlwdGlvbiwgbWluLCBtYXgsIGRlZmF1bHROdW1iZXIsIHVzZVVybFBhcmFtcywgZGVmYXVsdE9uQ2hhbmdlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIC8qIERvIG5vdGhpbmcsIHRvIGJlIG92ZXJyaWRkZW4uICovXG4gICAgfSkge1xuICAgICAgICBzdXBlcihpZCwgbGFiZWwsIGRlc2NyaXB0aW9uLCBkZWZhdWx0TnVtYmVyLCBkZWZhdWx0T25DaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX21pbiA9IG1pbjtcbiAgICAgICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgICAgICAvLyBhdHRlbXB0IHRvIHJlYWQgdGhlIG51bWJlciBmcm9tIHRoZSB1cmwgcGFyYW1zXG4gICAgICAgIGlmICghdXNlVXJsUGFyYW1zIHx8ICF0aGlzLmhhc1VSTFBhcmFtKHRoaXMuaWQpKSB7XG4gICAgICAgICAgICB0aGlzLm51bWJlciA9IGRlZmF1bHROdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IE51bWJlci5wYXJzZUZsb2F0KHRoaXMuZ2V0VVJMUGFyYW0odGhpcy5pZCkpO1xuICAgICAgICAgICAgdGhpcy5udW1iZXIgPSBOdW1iZXIuaXNOYU4ocGFyc2VkVmFsdWUpID8gZGVmYXVsdE51bWJlciA6IHBhcnNlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNlVXJsUGFyYW1zID0gdXNlVXJsUGFyYW1zO1xuICAgIH1cbiAgICBnZXRWYWx1ZUFzU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1iZXIudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBudW1iZXIgdmFsdWUgKHdpbGwgYmUgY2xhbXBlZCB3aXRoaW4gcmFuZ2UpLlxuICAgICAqL1xuICAgIHNldCBudW1iZXIobmV3TnVtYmVyKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmNsYW1wKG5ld051bWJlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgc3RvcmVkLlxuICAgICAqL1xuICAgIGdldCBudW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgYSBudW1iZXIgYmV0d2VlbiB0aGUgbWluIGFuZCBtYXggdmFsdWVzIChpbmNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSBpbk51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEByZXR1cm5zIFRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKi9cbiAgICBjbGFtcChpbk51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5fbWluID09IG51bGwgJiYgdGhpcy5fbWF4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpbk51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9taW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuX21heCwgaW5OdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX21heCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5fbWluLCBpbk51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4odGhpcy5fbWF4LCBpbk51bWJlciksIHRoaXMuX21pbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBtaW5pbXVtIHZhbHVlXG4gICAgICovXG4gICAgZ2V0IG1pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBtYXhpbXVtIHZhbHVlXG4gICAgICovXG4gICAgZ2V0IG1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgY2hhbmdlIGxpc3RlbmVyIHRvIHRoZSBudW1iZXIgb2JqZWN0LlxuICAgICAqL1xuICAgIGFkZE9uQ2hhbmdlZExpc3RlbmVyKG9uQ2hhbmdlZEZ1bmMpIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlZEZ1bmM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2V0dGluZ051bWJlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuaW1wb3J0IHsgU2V0dGluZ0Jhc2UgfSBmcm9tICcuL1NldHRpbmdCYXNlJztcbi8qKlxuICogQW4gT3B0aW9uIHNldHRpbmcgb2JqZWN0IHdpdGggYSB0ZXh0IGxhYmVsLiBBbGxvd3MgeW91IHRvIHNwZWNpZnkgYW4gYXJyYXkgb2Ygb3B0aW9ucyBhbmQgc2VsZWN0IG9uZSBvZiB0aGVtLlxuICovXG5leHBvcnQgY2xhc3MgU2V0dGluZ09wdGlvbiBleHRlbmRzIFNldHRpbmdCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgbGFiZWwsIGRlc2NyaXB0aW9uLCBkZWZhdWx0VGV4dFZhbHVlLCBvcHRpb25zLCB1c2VVcmxQYXJhbXMsIGRlZmF1bHRVcmxQYXJhbVJlc29sdmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8qIFJldHVybiB0aGUgc3RyaW5nIGFzLWlzIGJ5IGRlZmF1bHQgKi9cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIGRlZmF1bHRPbkNoYW5nZUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAvKiBEbyBub3RoaW5nLCB0byBiZSBvdmVycmlkZGVuLiAqL1xuICAgIH0pIHtcbiAgICAgICAgc3VwZXIoaWQsIGxhYmVsLCBkZXNjcmlwdGlvbiwgZGVmYXVsdFRleHRWYWx1ZSwgZGVmYXVsdE9uQ2hhbmdlTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLl91cmxQYXJhbVJlc29sdmVyID0gZGVmYXVsdFVybFBhcmFtUmVzb2x2ZXI7XG4gICAgICAgIGNvbnN0IHN0cmluZ1RvTWF0Y2ggPSB0aGlzLmhhc1VSTFBhcmFtKHRoaXMuaWQpXG4gICAgICAgICAgICA/IHRoaXMuX3VybFBhcmFtUmVzb2x2ZXIodGhpcy5nZXRVUkxQYXJhbSh0aGlzLmlkKSlcbiAgICAgICAgICAgIDogZGVmYXVsdFRleHRWYWx1ZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDogW3N0cmluZ1RvTWF0Y2hdO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gc3RyaW5nVG9NYXRjaDtcbiAgICAgICAgdGhpcy51c2VVcmxQYXJhbXMgPSB1c2VVcmxQYXJhbXM7XG4gICAgfVxuICAgIGdldFZhbHVlQXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjaGFuZ2UgbGlzdGVuZXIgdG8gdGhlIHNlbGVjdCBlbGVtZW50LlxuICAgICAqL1xuICAgIGFkZE9uQ2hhbmdlZExpc3RlbmVyKG9uQ2hhbmdlZEZ1bmMpIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlZEZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEFsbCBhdmFpbGFibGUgb3B0aW9ucyBhcyBhbiBhcnJheVxuICAgICAqL1xuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gdmFsdWVzIEFycmF5IG9mIG9wdGlvbnNcbiAgICAgKi9cbiAgICBzZXQgb3B0aW9ucyh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHZhbHVlcztcbiAgICAgICAgdGhpcy5vbkNoYW5nZUVtaXQodGhpcy5zZWxlY3RlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFNlbGVjdGVkIG9wdGlvbiBhcyBhIHN0cmluZ1xuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBzZWxlY3RlZCBvcHRpb24gaWYgaXQgbWF0Y2hlcyBvbmUgb2YgdGhlIGF2YWlsYWJsZSBvcHRpb25zXG4gICAgICogQHBhcmFtIHZhbHVlIFNlbGVjdGVkIG9wdGlvblxuICAgICAqL1xuICAgIHNldCBzZWxlY3RlZCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG9wdGlvbnMgY29udGFpbnMgdGhlIHZhbHVlLCB0aGVuIHNldCB0aGF0IGFzIHNlbGVjdGVkXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoYENvdWxkIG5vdCBzZXQgXCIke3ZhbHVlfVwiIGFzIHRoZSBzZWxlY3RlZCBvcHRpb24gZm9yICR7dGhpcy5pZH0gYmVjYXVzZSBpdCB3YXNuJ3Qgb25lIG9mIHRoZSBvcHRpb25zLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdXJsIHBhcmFtZXRlciByZXNvbHZlciB0byBkbyBzb21lIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBzdHJpbmcgdmFsdWVcbiAgICAgKiB0aGF0IGlzIGV4dHJhY3RlZCBmcm9tIHRoZSB1cmwgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0gdXJsUGFyYW0gQSBmdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIGV4dHJhY3RlZCB1cmwgcGFyYW1ldGVyIHN0cmluZyBmb3IgdGhpcyBzZXR0aW5nIHRvIHNvbWV0aGluZyBlbHNlLlxuICAgICAqL1xuICAgIHNldCB1cmxQYXJhbVJlc29sdmVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3VybFBhcmFtUmVzb2x2ZXIgPSB2YWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXR0aW5nT3B0aW9uLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBTZXR0aW5nQmFzZSB9IGZyb20gJy4vU2V0dGluZ0Jhc2UnO1xuLyoqXG4gKiBBIHRleHQgc2V0dGluZyBvYmplY3Qgd2l0aCBhIHRleHQgbGFiZWwuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXR0aW5nVGV4dCBleHRlbmRzIFNldHRpbmdCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgbGFiZWwsIGRlc2NyaXB0aW9uLCBkZWZhdWx0VGV4dFZhbHVlLCB1c2VVcmxQYXJhbXMsIGRlZmF1bHRPbkNoYW5nZUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAvKiBEbyBub3RoaW5nLCB0byBiZSBvdmVycmlkZGVuLiAqL1xuICAgIH0pIHtcbiAgICAgICAgc3VwZXIoaWQsIGxhYmVsLCBkZXNjcmlwdGlvbiwgZGVmYXVsdFRleHRWYWx1ZSwgZGVmYXVsdE9uQ2hhbmdlTGlzdGVuZXIpO1xuICAgICAgICBpZiAoIXVzZVVybFBhcmFtcyB8fCAhdGhpcy5oYXNVUkxQYXJhbSh0aGlzLmlkKSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gZGVmYXVsdFRleHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhcnNlIGZsYWcgZnJvbSB1cmwgcGFyYW1ldGVyc1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy5nZXRVUkxQYXJhbSh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZVVybFBhcmFtcyA9IHVzZVVybFBhcmFtcztcbiAgICB9XG4gICAgZ2V0VmFsdWVBc1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiBUaGUgc2V0dGluZydzIHZhbHVlLlxuICAgICAqL1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzZXR0aW5nJ3Mgc3RvcmVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSBpblZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBzZXR0aW5nLlxuICAgICAqL1xuICAgIHNldCB0ZXh0KGluVmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGluVmFsdWU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2V0dGluZ1RleHQuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42Jztcbi8qKlxuICogSGFuZGxlcyB0aGUgU2VuZGluZyBhbmQgUmVjZWl2aW5nIG9mIG1lc3NhZ2VzIHRvIHRoZSBVRSBJbnN0YW5jZSB2aWEgdGhlIERhdGEgQ2hhbm5lbFxuICovXG5leHBvcnQgY2xhc3MgRGF0YUNoYW5uZWxDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pc1JlY2VpdmluZ0ZyZWV6ZUZyYW1lID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgY3VycmVudCBzdGF0ZSBvZiBhIGRhdGFjaGFubmVsIGNvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBEYXRhQ2hhbm5lbENvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXREYXRhQ2hhbm5lbEluc3RhbmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gQ3JlYXRlIGFuZCBTZXQgdXAgYSBEYXRhIENoYW5uZWxcbiAgICAgKiBAcGFyYW0gcGVlckNvbm5lY3Rpb24gLSBUaGUgUlRDIFBlZXIgQ29ubmVjdGlvblxuICAgICAqIEBwYXJhbSBsYWJlbCAtIExhYmVsIG9mIHRoZSBEYXRhIENoYW5uZWxcbiAgICAgKiBAcGFyYW0gZGF0YWNoYW5uZWxPcHRpb25zIC0gT3B0aW9uYWwgUlRDIERhdGFDaGFubmVsIG9wdGlvbnNcbiAgICAgKi9cbiAgICBjcmVhdGVEYXRhQ2hhbm5lbChwZWVyQ29ubmVjdGlvbiwgbGFiZWwsIGRhdGFjaGFubmVsT3B0aW9ucykge1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uID0gcGVlckNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbE9wdGlvbnMgPSBkYXRhY2hhbm5lbE9wdGlvbnM7XG4gICAgICAgIGlmIChkYXRhY2hhbm5lbE9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhY2hhbm5lbE9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuZGF0YWNoYW5uZWxPcHRpb25zLm9yZGVyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwgPSB0aGlzLnBlZXJDb25uZWN0aW9uLmNyZWF0ZURhdGFDaGFubmVsKHRoaXMubGFiZWwsIHRoaXMuZGF0YWNoYW5uZWxPcHRpb25zKTtcbiAgICAgICAgdGhpcy5zZXR1cERhdGFDaGFubmVsKCk7XG4gICAgfVxuICAgIHNldHVwRGF0YUNoYW5uZWwoKSB7XG4gICAgICAgIC8vV2UgV2FudCBhbiBBcnJheSBCdWZmZXIgbm90IGEgYmxvYlxuICAgICAgICB0aGlzLmRhdGFDaGFubmVsLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsLm9ub3BlbiA9IChldikgPT4gdGhpcy5oYW5kbGVPbk9wZW4oZXYpO1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsLm9uY2xvc2UgPSAoZXYpID0+IHRoaXMuaGFuZGxlT25DbG9zZShldik7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwub25tZXNzYWdlID0gKGV2KSA9PiB0aGlzLmhhbmRsZU9uTWVzc2FnZShldik7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWwub25lcnJvciA9IChldikgPT4gdGhpcy5oYW5kbGVPbkVycm9yKGV2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIHRoZSBEYXRhIENoYW5uZWwgaXMgb3BlbmVkXG4gICAgICovXG4gICAgaGFuZGxlT25PcGVuKGV2KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgTG9nZ2VyLkluZm8oYERhdGEgQ2hhbm5lbCAoJHt0aGlzLmxhYmVsfSkgb3BlbmVkLmApO1xuICAgICAgICB0aGlzLm9uT3BlbigoX2EgPSB0aGlzLmRhdGFDaGFubmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFiZWwsIGV2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIHRoZSBEYXRhIENoYW5uZWwgaXMgY2xvc2VkXG4gICAgICovXG4gICAgaGFuZGxlT25DbG9zZShldikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIExvZ2dlci5JbmZvKGBEYXRhIENoYW5uZWwgKCR7dGhpcy5sYWJlbH0pIGNsb3NlZC5gKTtcbiAgICAgICAgdGhpcy5vbkNsb3NlKChfYSA9IHRoaXMuZGF0YUNoYW5uZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYWJlbCwgZXYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkXG4gICAgICogQHBhcmFtIGV2ZW50IC0gTWVzc2FnZSBFdmVudFxuICAgICAqL1xuICAgIGhhbmRsZU9uTWVzc2FnZShldmVudCkge1xuICAgICAgICAvLyBIaWdoZXIgbG9nIGxldmVsIHRvIHByZXZlbnQgbG9nIHNwYW0gd2l0aCBtZXNzYWdlcyByZWNlaXZlZFxuICAgICAgICBMb2dnZXIuSW5mbyhgRGF0YSBDaGFubmVsICgke3RoaXMubGFiZWx9KSBtZXNzYWdlOiAke2V2ZW50fWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gYW4gZXJyb3IgaXMgdGhyb3duXG4gICAgICogQHBhcmFtIGV2ZW50IC0gRXJyb3IgRXZlbnRcbiAgICAgKi9cbiAgICBoYW5kbGVPbkVycm9yKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgTG9nZ2VyLkluZm8oYERhdGEgQ2hhbm5lbCAoJHt0aGlzLmxhYmVsfSkgZXJyb3I6ICR7ZXZlbnR9YCk7XG4gICAgICAgIHRoaXMub25FcnJvcigoX2EgPSB0aGlzLmRhdGFDaGFubmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFiZWwsIGV2ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdG8gcmVnaXN0ZXIgb25PcGVuIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gbGFiZWwgRGF0YSBjaGFubmVsIGxhYmVsIChcImRhdGFjaGFubmVsXCIsIFwic2VuZC1kYXRhY2hhbm5lbFwiLCBcInJlY3YtZGF0YWNoYW5uZWxcIilcbiAgICAgKiBAcGFyYW0gZXYgZXZlbnRcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb25PcGVuKGxhYmVsLCBldikge1xuICAgICAgICAvLyBlbXB0eSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRvIHJlZ2lzdGVyIG9uQ2xvc2UgaGFuZGxlclxuICAgICAqIEBwYXJhbSBsYWJlbCBEYXRhIGNoYW5uZWwgbGFiZWwgKFwiZGF0YWNoYW5uZWxcIiwgXCJzZW5kLWRhdGFjaGFubmVsXCIsIFwicmVjdi1kYXRhY2hhbm5lbFwiKVxuICAgICAqIEBwYXJhbSBldiBldmVudFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBvbkNsb3NlKGxhYmVsLCBldikge1xuICAgICAgICAvLyBlbXB0eSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRvIHJlZ2lzdGVyIG9uRXJyb3IgaGFuZGxlclxuICAgICAqIEBwYXJhbSBsYWJlbCBEYXRhIGNoYW5uZWwgbGFiZWwgKFwiZGF0YWNoYW5uZWxcIiwgXCJzZW5kLWRhdGFjaGFubmVsXCIsIFwicmVjdi1kYXRhY2hhbm5lbFwiKVxuICAgICAqIEBwYXJhbSBldiBldmVudFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBvbkVycm9yKGxhYmVsLCBldikge1xuICAgICAgICAvLyBlbXB0eSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0YUNoYW5uZWxDb250cm9sbGVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG5pbXBvcnQgeyBEYXRhQ2hhbm5lbExhdGVuY3lUZXN0UmVjb3JkIH0gZnJvbSAnLi9EYXRhQ2hhbm5lbExhdGVuY3lUZXN0UmVzdWx0cyc7XG5leHBvcnQgY2xhc3MgRGF0YUNoYW5uZWxMYXRlbmN5VGVzdENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKHNpbmssIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxIYW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2luayA9IHNpbms7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5yZWNvcmRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNlcSA9IDA7XG4gICAgfVxuICAgIHN0YXJ0KGNvbmZpZykge1xuICAgICAgICBpZiAodGhpcy5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5yZWNvcmRzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxIYW5kbGUgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5zdGFydFRpbWUgPj0gY29uZmlnLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGNvbmZpZy5yZXF1ZXN0U2l6ZSwgY29uZmlnLnJlc3BvbnNlU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmJpbmQodGhpcyksIE1hdGguZmxvb3IoMTAwMCAvIGNvbmZpZy5ycHMpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFsSGFuZGxlKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSGFuZGxlKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxIYW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMucHJvZHVjZVJlc3VsdCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9kdWNlUmVzdWx0KCkge1xuICAgICAgICBjb25zdCByZXN1bHRSZWNvcmRzID0gbmV3IE1hcCh0aGlzLnJlY29yZHMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVjb3JkczogcmVzdWx0UmVjb3JkcyxcbiAgICAgICAgICAgIGRhdGFDaGFubmVsUnR0OiBNYXRoLmNlaWwoQXJyYXkuZnJvbSh0aGlzLnJlY29yZHMudmFsdWVzKCkpLnJlZHVjZSgoYWNjLCBuZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIChuZXh0LnBsYXllclJlY2VpdmVkVGltZXN0YW1wIC0gbmV4dC5wbGF5ZXJTZW50VGltZXN0YW1wKTtcbiAgICAgICAgICAgIH0sIDApIC8gdGhpcy5yZWNvcmRzLnNpemUpLFxuICAgICAgICAgICAgcGxheWVyVG9TdHJlYW1lclRpbWU6IE1hdGguY2VpbChBcnJheS5mcm9tKHRoaXMucmVjb3Jkcy52YWx1ZXMoKSkucmVkdWNlKChhY2MsIG5leHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjICsgKG5leHQuc3RyZWFtZXJSZWNlaXZlZFRpbWVzdGFtcCAtIG5leHQucGxheWVyU2VudFRpbWVzdGFtcCk7XG4gICAgICAgICAgICB9LCAwKSAvIHRoaXMucmVjb3Jkcy5zaXplKSxcbiAgICAgICAgICAgIHN0cmVhbWVyVG9QbGF5ZXJUaW1lOiBNYXRoLmNlaWwoQXJyYXkuZnJvbSh0aGlzLnJlY29yZHMudmFsdWVzKCkpLnJlZHVjZSgoYWNjLCBuZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIChuZXh0LnBsYXllclJlY2VpdmVkVGltZXN0YW1wIC0gbmV4dC5zdHJlYW1lclNlbnRUaW1lc3RhbXApO1xuICAgICAgICAgICAgfSwgMCkgLyB0aGlzLnJlY29yZHMuc2l6ZSksXG4gICAgICAgICAgICBleHBvcnRMYXRlbmN5QXNDU1Y6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY3N2ID0gJ1RpbWVzdGFtcDtSVFQ7UGxheWVyVG9TdHJlYW1lcjtTdHJlYW1lclRvUGxheWVyO1xcbic7XG4gICAgICAgICAgICAgICAgcmVzdWx0UmVjb3Jkcy5mb3JFYWNoKChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY3N2ICs9IHJlY29yZC5wbGF5ZXJTZW50VGltZXN0YW1wICsgJzsnO1xuICAgICAgICAgICAgICAgICAgICBjc3YgKz0gcmVjb3JkLnBsYXllclJlY2VpdmVkVGltZXN0YW1wIC0gcmVjb3JkLnBsYXllclNlbnRUaW1lc3RhbXAgKyAnOyc7XG4gICAgICAgICAgICAgICAgICAgIGNzdiArPSByZWNvcmQuc3RyZWFtZXJSZWNlaXZlZFRpbWVzdGFtcCAtIHJlY29yZC5wbGF5ZXJTZW50VGltZXN0YW1wICsgJzsnO1xuICAgICAgICAgICAgICAgICAgICBjc3YgKz0gcmVjb3JkLnBsYXllclJlY2VpdmVkVGltZXN0YW1wIC0gcmVjb3JkLnN0cmVhbWVyU2VudFRpbWVzdGFtcCArICc7JztcbiAgICAgICAgICAgICAgICAgICAgY3N2ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjc3Y7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlzUnVubmluZygpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5pbnRlcnZhbEhhbmRsZTtcbiAgICB9XG4gICAgcmVjZWl2ZShyZXNwb25zZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoJ1VuZGVmaW5lZCByZXNwb25zZSBmcm9tIHNlcnZlcicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlY29yZCA9IHRoaXMucmVjb3Jkcy5nZXQocmVzcG9uc2UuU2VxKTtcbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgcmVjb3JkLnVwZGF0ZShyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZFJlcXVlc3QocmVxdWVzdFNpemUsIHJlc3BvbnNlU2l6ZSkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KHJlcXVlc3RTaXplLCByZXNwb25zZVNpemUpO1xuICAgICAgICBjb25zdCByZWNvcmQgPSBuZXcgRGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlY29yZChyZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5yZWNvcmRzLnNldChyZWNvcmQuc2VxLCByZWNvcmQpO1xuICAgICAgICB0aGlzLnNpbmsocmVxdWVzdCk7XG4gICAgfVxuICAgIGNyZWF0ZVJlcXVlc3QocmVxdWVzdFNpemUsIHJlc3BvbnNlU2l6ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgU2VxOiB0aGlzLnNlcSsrLFxuICAgICAgICAgICAgRmlsbFJlc3BvbnNlU2l6ZTogcmVzcG9uc2VTaXplLFxuICAgICAgICAgICAgRmlsbGVyOiByZXF1ZXN0U2l6ZSA/ICdBJy5yZXBlYXQocmVxdWVzdFNpemUpIDogJydcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhQ2hhbm5lbExhdGVuY3lUZXN0Q29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuZXhwb3J0IGNsYXNzIERhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZWNvcmQge1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5zZXEgPSByZXF1ZXN0LlNlcTtcbiAgICAgICAgdGhpcy5wbGF5ZXJTZW50VGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0RmlsbGVyU2l6ZSA9IHJlcXVlc3QuRmlsbGVyID8gcmVxdWVzdC5GaWxsZXIubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgdXBkYXRlKHJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMucGxheWVyUmVjZWl2ZWRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnN0cmVhbWVyUmVjZWl2ZWRUaW1lc3RhbXAgPSByZXNwb25zZS5SZWNlaXZlZFRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5zdHJlYW1lclNlbnRUaW1lc3RhbXAgPSByZXNwb25zZS5TZW50VGltZXN0YW1wO1xuICAgICAgICB0aGlzLnJlc3BvbnNlRmlsbGVyU2l6ZSA9IHJlc3BvbnNlLkZpbGxlciA/IHJlc3BvbnNlLkZpbGxlci5sZW5ndGggOiAwO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXN1bHRzLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG4vKipcbiAqIEEgY2xhc3MgZm9yIHNlbmRpbmcgZGF0YSBjaGFubmVsIG1lc3NhZ2VzXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhQ2hhbm5lbFNlbmRlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGFDaGFubmVsUHJvdmlkZXIgLSBEYXRhIGNoYW5uZWwgb2JqZWN0IHR5cGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkYXRhQ2hhbm5lbFByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWxQcm92aWRlciA9IGRhdGFDaGFubmVsUHJvdmlkZXI7XG4gICAgfVxuICAgIGNhblNlbmQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5kYXRhQ2hhbm5lbFByb3ZpZGVyLmdldERhdGFDaGFubmVsSW5zdGFuY2UoKS5kYXRhQ2hhbm5lbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFubmVsUHJvdmlkZXIuZ2V0RGF0YUNoYW5uZWxJbnN0YW5jZSgpLmRhdGFDaGFubmVsLnJlYWR5U3RhdGUgPT0gJ29wZW4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBEYXRhIG92ZXIgdGhlIERhdGEgY2hhbm5lbCB0byB0aGUgVUUgSW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gZGF0YSAtIE1lc3NhZ2UgRGF0YSBBcnJheSBCdWZmZXJcbiAgICAgKi9cbiAgICBzZW5kRGF0YShkYXRhKSB7XG4gICAgICAgIC8vIHJlc2V0IHRoZSBhZmsgaW5hY3Rpdml0eVxuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbEluc3RhbmNlID0gdGhpcy5kYXRhQ2hhbm5lbFByb3ZpZGVyLmdldERhdGFDaGFubmVsSW5zdGFuY2UoKTtcbiAgICAgICAgaWYgKGRhdGFDaGFubmVsSW5zdGFuY2UuZGF0YUNoYW5uZWwucmVhZHlTdGF0ZSA9PSAnb3BlbicpIHtcbiAgICAgICAgICAgIGRhdGFDaGFubmVsSW5zdGFuY2UuZGF0YUNoYW5uZWwuc2VuZChkYXRhKTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKGBNZXNzYWdlIFNlbnQ6ICR7bmV3IFVpbnQ4QXJyYXkoZGF0YSl9YCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0QWZrV2FybmluZ1RpbWVyT25EYXRhU2VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBNZXNzYWdlIEZhaWxlZDogJHtuZXcgVWludDhBcnJheShkYXRhKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBvdmVycmlkZSBtZXRob2QgZm9yIHJlc2V0dGluZyB0aGUgQWZrIHdhcm5pbmcgdGltZXIgd2hlbiBkYXRhIGlzIHNlbnQgb3ZlciB0aGUgZGF0YSBjaGFubmVsXG4gICAgICovXG4gICAgcmVzZXRBZmtXYXJuaW5nVGltZXJPbkRhdGFTZW5kKCkge1xuICAgICAgICAvLyBCYXNlIEZ1bmN0aW9uYWxpdHk6IERvIE5vdGhpbmdcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhQ2hhbm5lbFNlbmRlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBMYXRlbmN5IFRlc3QgUmVzdWx0cyBEYXRhXG4gKi9cbmV4cG9ydCBjbGFzcyBJbml0aWFsU2V0dGluZ3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLlBpeGVsU3RyZWFtaW5nU2V0dGluZ3MgPSBuZXcgUGl4ZWxTdHJlYW1pbmdTZXR0aW5ncygpO1xuICAgICAgICB0aGlzLkVuY29kZXJTZXR0aW5ncyA9IG5ldyBFbmNvZGVyU2V0dGluZ3MoKTtcbiAgICAgICAgdGhpcy5XZWJSVENTZXR0aW5ncyA9IG5ldyBXZWJSVENTZXR0aW5ncygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgRlBTIGFuZCBNYXhGUFMgc3RhdHMgYmV0d2VlbiA0LjI3IGFuZCA1XG4gICAgICovXG4gICAgdWVDb21wYXRpYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5XZWJSVENTZXR0aW5ncy5NYXhGUFMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5XZWJSVENTZXR0aW5ncy5GUFMgPSB0aGlzLldlYlJUQ1NldHRpbmdzLk1heEZQUztcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBjbGFzcyBmb3IgaGFuZGxpbmcgUGl4ZWwgU3RyZWFtaW5nIGRldGFpbHNcbiAqL1xuZXhwb3J0IGNsYXNzIFBpeGVsU3RyZWFtaW5nU2V0dGluZ3Mge1xufVxuLyoqXG4gKiBBIGNsYXNzIGZvciBoYW5kbGluZyBlbmNvZGVyIHN0YXRzXG4gKi9cbmV4cG9ydCBjbGFzcyBFbmNvZGVyU2V0dGluZ3Mge1xufVxuLyoqXG4gKiBBIGNsYXNzIGZvciBoYW5kbGluZyB3ZWIgcnRjIHN0YXRzXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJSVENTZXR0aW5ncyB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jbml0aWFsU2V0dGluZ3MuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42Jztcbi8qKlxuICogTGF0ZW5jeSBUZXN0IFJlc3VsdHMgRGF0YVxuICovXG5leHBvcnQgY2xhc3MgTGF0ZW5jeVRlc3RSZXN1bHRzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy9GaWVsZHMgU2V0IGZyb20gdGhlIGxhdGVuY3kgcGF5bG9hZCByZWdhcmRsZXNzIG9mIHZlcnNpb25cbiAgICAgICAgdGhpcy5SZWNlaXB0VGltZU1zID0gbnVsbDtcbiAgICAgICAgdGhpcy5UcmFuc21pc3Npb25UaW1lTXMgPSBudWxsO1xuICAgICAgICAvL0ZpZWxkcyBTZXQgZnJvbSB0aGUgbGF0ZW5jeSBwYXlsb2FkIGZyb20gNC4yNy4yXG4gICAgICAgIHRoaXMuUHJlQ2FwdHVyZVRpbWVNcyA9IG51bGw7XG4gICAgICAgIHRoaXMuUG9zdENhcHR1cmVUaW1lTXMgPSBudWxsO1xuICAgICAgICB0aGlzLlByZUVuY29kZVRpbWVNcyA9IG51bGw7XG4gICAgICAgIHRoaXMuUG9zdEVuY29kZVRpbWVNcyA9IG51bGw7XG4gICAgICAgIC8vRmllbGRzIFNldCBmcm9tIHRoZSBsYXRlbmN5IHBheWxvYWQgZnJvbSA1LjBcbiAgICAgICAgdGhpcy5FbmNvZGVNcyA9IG51bGw7XG4gICAgICAgIHRoaXMuQ2FwdHVyZVRvU2VuZE1zID0gbnVsbDtcbiAgICAgICAgLy9GaWVsZHMgU2V0IHdoZW4gcHJvY2Vzc2VkXG4gICAgICAgIHRoaXMudGVzdFN0YXJ0VGltZU1zID0gMDtcbiAgICAgICAgdGhpcy5icm93c2VyUmVjZWlwdFRpbWVNcyA9IDA7XG4gICAgICAgIC8vRmllbGRzIHNldCBmcm9tIGNhbGN1bGF0aW9uc1xuICAgICAgICB0aGlzLmxhdGVuY3lFeGNsdWRpbmdEZWNvZGUgPSAwO1xuICAgICAgICB0aGlzLnRlc3REdXJhdGlvbiA9IDA7XG4gICAgICAgIC8vdWVMYXRlbmN5OiBudW1iZXIgPSAwO1xuICAgICAgICB0aGlzLm5ldHdvcmtMYXRlbmN5ID0gMDtcbiAgICAgICAgdGhpcy5icm93c2VyU2VuZExhdGVuY3kgPSAwO1xuICAgICAgICB0aGlzLmZyYW1lRGlzcGxheURlbHRhVGltZU1zID0gMDtcbiAgICAgICAgdGhpcy5lbmRUb0VuZExhdGVuY3kgPSAwO1xuICAgICAgICAvL3VlUGl4ZWxTdHJlYW1MYXRlbmN5OiBudW1iZXIgPSAwO1xuICAgICAgICB0aGlzLmVuY29kZUxhdGVuY3kgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBEZWx0YSBUaW1lIE1pbGxpc2Vjb25kc1xuICAgICAqIEBwYXJhbSBEZWx0YVRpbWVNcyAtIERlbHRhIFRpbWUgTWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgc2V0RnJhbWVEaXNwbGF5RGVsdGFUaW1lKERlbHRhVGltZU1zKSB7XG4gICAgICAgIGlmICh0aGlzLmZyYW1lRGlzcGxheURlbHRhVGltZU1zID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZnJhbWVEaXNwbGF5RGVsdGFUaW1lTXMgPSBNYXRoLnJvdW5kKERlbHRhVGltZU1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBlbmNvZGVyIHRpbWVzIGFuZCBzZXQgdGhlbVxuICAgICAqL1xuICAgIHByb2Nlc3NGaWVsZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLkVuY29kZU1zID09IG51bGwgJiYgKHRoaXMuUHJlRW5jb2RlVGltZU1zICE9IG51bGwgfHwgdGhpcy5Qb3N0RW5jb2RlVGltZU1zICE9IG51bGwpKSB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbyhgU2V0dGluZyBFbmNvZGUgTXMgXFxuICR7dGhpcy5Qb3N0RW5jb2RlVGltZU1zfSBcXG4gJHt0aGlzLlByZUVuY29kZVRpbWVNc31gKTtcbiAgICAgICAgICAgIHRoaXMuRW5jb2RlTXMgPSB0aGlzLlBvc3RFbmNvZGVUaW1lTXMgLSB0aGlzLlByZUVuY29kZVRpbWVNcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5DYXB0dXJlVG9TZW5kTXMgPT0gbnVsbCAmJlxuICAgICAgICAgICAgKHRoaXMuUHJlQ2FwdHVyZVRpbWVNcyAhPSBudWxsIHx8IHRoaXMuUG9zdENhcHR1cmVUaW1lTXMgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKGBTZXR0aW5nIENhcHR1cmVUb1NlbmRNcyBNcyBcXG4gJHt0aGlzLlBvc3RDYXB0dXJlVGltZU1zfSBcXG4gJHt0aGlzLlByZUNhcHR1cmVUaW1lTXN9YCk7XG4gICAgICAgICAgICB0aGlzLkNhcHR1cmVUb1NlbmRNcyA9IHRoaXMuUG9zdENhcHR1cmVUaW1lTXMgLSB0aGlzLlByZUNhcHR1cmVUaW1lTXM7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYXRlbmN5VGVzdFJlc3VsdHMuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogQSBjbGFzcyBmb3IgbWFuYWdpbmcgdGhlIGZyZWV6ZSBmcmFtZSBvYmplY3RcbiAqL1xuZXhwb3J0IGNsYXNzIEZyZWV6ZUZyYW1lIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBmcmVlemUgZnJhbWVcbiAgICAgKiBAcGFyYW0gcm9vdERpdiB0aGUgZGl2IHRoYXQgYSBmcmVlemUgZnJhbWUgZWxlbWVudCB3aWxsIGJlIGluamVjdGVkIGludG9cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihyb290RGl2KSB7XG4gICAgICAgIHRoaXMuZnJlZXplRnJhbWVIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lV2lkdGggPSAwO1xuICAgICAgICB0aGlzLnJvb3REaXYgPSByb290RGl2O1xuICAgICAgICAvLyBjcmVhdGUgdGhlIG92ZXJsYXlcbiAgICAgICAgdGhpcy5yb290RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LmlkID0gJ2ZyZWV6ZUZyYW1lJztcbiAgICAgICAgdGhpcy5yb290RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LnN0eWxlLnpJbmRleCA9ICcyMCc7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgaW1hZ2UgcGxhY2UgaG9sZGVyXG4gICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBpbWFnZSBpbnRvIHRoZSByb290IGVsZW1lbnQgYW5kIGFwcGVuZCB0aGUgZWxlbWVudCB0byB0aGUgcm9vdCBkaXZcbiAgICAgICAgdGhpcy5yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmltYWdlRWxlbWVudCk7XG4gICAgICAgIHRoaXMucm9vdERpdi5hcHBlbmRDaGlsZCh0aGlzLnJvb3RFbGVtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmcmVlemUgZnJhbWUgZWxlbWVudCBmb3Igc2hvd2luZ1xuICAgICAqL1xuICAgIHNldEVsZW1lbnRGb3JTaG93KCkge1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZyZWV6ZSBmcmFtZSBlbGVtZW50IGZvciBoaWRpbmdcbiAgICAgKi9cbiAgICBzZXRFbGVtZW50Rm9ySGlkZSgpIHtcbiAgICAgICAgdGhpcy5yb290RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGZyZWV6ZSBmcmFtZXMgaW1hZ2Ugc291cmNlXG4gICAgICogQHBhcmFtIGpwZWcgLSB0aGUgZnJlZXplIGZyYW1lIGltYWdlIGFzIGEgYnl0ZSBhcnJheSBkYXRhXG4gICAgICovXG4gICAgdXBkYXRlSW1hZ2VFbGVtZW50U291cmNlKGpwZWcpIHtcbiAgICAgICAgY29uc3QgYmFzZTY0ID0gYnRvYShqcGVnLnJlZHVjZSgoZGF0YSwgYnl0ZSkgPT4gZGF0YSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSksICcnKSk7XG4gICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50LnNyYyA9ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LCcgKyBiYXNlNjQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZGltZW5zaW9ucyBmb3IgdGhlIGZyZWV6ZSBmcmFtZSBmcm9tIHRoZSBlbGVtZW50IGFuZCByZXNpemUgaXRcbiAgICAgKi9cbiAgICBzZXREaW1lbnNpb25zRnJvbUVsZW1lbnRBbmRSZXNpemUoKSB7XG4gICAgICAgIHRoaXMuZnJlZXplRnJhbWVIZWlnaHQgPSB0aGlzLmltYWdlRWxlbWVudC5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lV2lkdGggPSB0aGlzLmltYWdlRWxlbWVudC5uYXR1cmFsV2lkdGg7XG4gICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBhIGZyZWV6ZSBmcmFtZSBlbGVtZW50XG4gICAgICovXG4gICAgcmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5mcmVlemVGcmFtZVdpZHRoICE9PSAwICYmIHRoaXMuZnJlZXplRnJhbWVIZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgIGxldCBkaXNwbGF5V2lkdGggPSAwO1xuICAgICAgICAgICAgbGV0IGRpc3BsYXlIZWlnaHQgPSAwO1xuICAgICAgICAgICAgbGV0IGRpc3BsYXlUb3AgPSAwO1xuICAgICAgICAgICAgbGV0IGRpc3BsYXlMZWZ0ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEFzcGVjdFJhdGlvID0gdGhpcy5yb290RGl2LmNsaWVudFdpZHRoIC8gdGhpcy5yb290RGl2LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHZpZGVvQXNwZWN0UmF0aW8gPSB0aGlzLmZyZWV6ZUZyYW1lV2lkdGggLyB0aGlzLmZyZWV6ZUZyYW1lSGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHBhcmVudEFzcGVjdFJhdGlvIDwgdmlkZW9Bc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlXaWR0aCA9IHRoaXMucm9vdERpdi5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBkaXNwbGF5SGVpZ2h0ID0gTWF0aC5mbG9vcih0aGlzLnJvb3REaXYuY2xpZW50V2lkdGggLyB2aWRlb0FzcGVjdFJhdGlvKTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5VG9wID0gTWF0aC5mbG9vcigodGhpcy5yb290RGl2LmNsaWVudEhlaWdodCAtIGRpc3BsYXlIZWlnaHQpICogMC41KTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5TGVmdCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5V2lkdGggPSBNYXRoLmZsb29yKHRoaXMucm9vdERpdi5jbGllbnRIZWlnaHQgKiB2aWRlb0FzcGVjdFJhdGlvKTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5SGVpZ2h0ID0gdGhpcy5yb290RGl2LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICBkaXNwbGF5VG9wID0gMDtcbiAgICAgICAgICAgICAgICBkaXNwbGF5TGVmdCA9IE1hdGguZmxvb3IoKHRoaXMucm9vdERpdi5jbGllbnRXaWR0aCAtIGRpc3BsYXlXaWR0aCkgKiAwLjUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yb290RWxlbWVudC5zdHlsZS53aWR0aCA9IHRoaXMucm9vdERpdi5vZmZzZXRXaWR0aCArICdweCc7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMucm9vdERpdi5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5yb290RWxlbWVudC5zdHlsZS5sZWZ0ID0gMCArICdweCc7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbGVtZW50LnN0eWxlLnRvcCA9IDAgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5pbWFnZUVsZW1lbnQuc3R5bGUud2lkdGggPSBkaXNwbGF5V2lkdGggKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5pbWFnZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gZGlzcGxheUhlaWdodCArICdweCc7XG4gICAgICAgICAgICB0aGlzLmltYWdlRWxlbWVudC5zdHlsZS5sZWZ0ID0gZGlzcGxheUxlZnQgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5pbWFnZUVsZW1lbnQuc3R5bGUudG9wID0gZGlzcGxheVRvcCArICdweCc7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GcmVlemVGcmFtZS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuaW1wb3J0IHsgRnJlZXplRnJhbWUgfSBmcm9tICcuL0ZyZWV6ZUZyYW1lJztcbi8qKlxuICogQSBjbGFzcyBmb3IgY29udHJvbGxpbmcgZnJlZXplIGZyYW1lIGZ1bmN0aW9uYWxpdHlcbiAqL1xuZXhwb3J0IGNsYXNzIEZyZWV6ZUZyYW1lQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgZnJlZXplIGZyYW1lIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gcm9vdERpdiAtIHRoZSBkaXYgdGhhdCBhIGZyZWV6ZSBmcmFtZSBlbGVtZW50IHdpbGwgYmUgaW5qZWN0ZWQgaW50b1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJvb3REaXYpIHtcbiAgICAgICAgdGhpcy5yZWNlaXZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5qcGVnID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZnJlZXplRnJhbWVEZWxheSA9IDUwO1xuICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lID0gbmV3IEZyZWV6ZUZyYW1lKHJvb3REaXYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBmcmVlemUgZnJhbWUgaWYgaXQgaXMgdmFsaWRcbiAgICAgKi9cbiAgICBzaG93RnJlZXplRnJhbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lLnNldEVsZW1lbnRGb3JTaG93KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgZnJlZXplIGZyYW1lIGFuZCBzZXQgdGhlIHZhbGlkaXR5IHRvIGZhbHNlXG4gICAgICovXG4gICAgaGlkZUZyZWV6ZUZyYW1lKCkge1xuICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZnJlZXplRnJhbWUuc2V0RWxlbWVudEZvckhpZGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBmcmVlemUgZnJhbWVzIGltYWdlIHNvdXJjZSBhbmQgbG9hZCBpdFxuICAgICAqIEBwYXJhbSBqcGVnIC0gdGhlIGZyZWV6ZSBmcmFtZSBpbWFnZSBhcyBhIGJ5dGUgYXJyYXkgZGF0YVxuICAgICAqIEBwYXJhbSBvbkxvYWRDYWxsQmFjayAtIGEgY2FsbCBiYWNrIGZvciBtYW5hZ2luZyBpZiB0aGUgcGxheSBvdmVybGF5IG5lZWRzIHRvIGJlIHNob3duIG9yIG5vdFxuICAgICAqL1xuICAgIHVwZGF0ZUZyZWV6ZUZyYW1lQW5kU2hvdyhqcGVnLCBvbkxvYWRDYWxsQmFjaykge1xuICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lLnVwZGF0ZUltYWdlRWxlbWVudFNvdXJjZShqcGVnKTtcbiAgICAgICAgdGhpcy5mcmVlemVGcmFtZS5pbWFnZUVsZW1lbnQub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5mcmVlemVGcmFtZS5zZXREaW1lbnNpb25zRnJvbUVsZW1lbnRBbmRSZXNpemUoKTtcbiAgICAgICAgICAgIG9uTG9hZENhbGxCYWNrKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIG5ldyBmcmVlemUgZnJhbWUgaW1hZ2UgYW5kIHVwZGF0ZSBpdFxuICAgICAqIEBwYXJhbSB2aWV3IC0gdGhlIGZyZWV6ZSBmcmFtZSBpbWFnZSBhcyBhIGJ5dGUgYXJyYXkgZGF0YVxuICAgICAqIEBwYXJhbSBvbkxvYWRDYWxsQmFjayAtIGEgY2FsbCBiYWNrIGZvciBtYW5hZ2luZyBpZiB0aGUgcGxheSBvdmVybGF5IG5lZWRzIHRvIGJlIHNob3duIG9yIG5vdFxuICAgICAqL1xuICAgIHByb2Nlc3NGcmVlemVGcmFtZU1lc3NhZ2Uodmlldywgb25Mb2FkQ2FsbEJhY2spIHtcbiAgICAgICAgLy8gUmVzZXQgZnJlZXplIGZyYW1lIGlmIHdlIGdvdCBhIGZyZWV6ZSBmcmFtZSBtZXNzYWdlIGFuZCB3ZSBhcmUgbm90IFwicmVjZWl2aW5nXCIgeWV0LlxuICAgICAgICBpZiAoIXRoaXMucmVjZWl2aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlY2VpdmluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICAgICAgdGhpcy5qcGVnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4dHJhY3QgdG90YWwgc2l6ZSBvZiBmcmVlemUgZnJhbWUgKGFjcm9zcyBhbGwgY2h1bmtzKVxuICAgICAgICB0aGlzLnNpemUgPSBuZXcgRGF0YVZpZXcodmlldy5zbGljZSgxLCA1KS5idWZmZXIpLmdldEludDMyKDAsIHRydWUpO1xuICAgICAgICAvLyBHZXQgdGhlIGpwZWcgcGFydCBvZiB0aGUgcGF5bG9hZFxuICAgICAgICBjb25zdCBqcGVnQnl0ZXMgPSB2aWV3LnNsaWNlKDEgKyA0KTtcbiAgICAgICAgLy8gQXBwZW5kIHRvIGV4aXN0aW5nIGpwZWcgdGhhdCBob2xkcyB0aGUgZnJlZXplIGZyYW1lXG4gICAgICAgIGlmICh0aGlzLmpwZWcpIHtcbiAgICAgICAgICAgIGNvbnN0IGpwZWcgPSBuZXcgVWludDhBcnJheSh0aGlzLmpwZWcubGVuZ3RoICsganBlZ0J5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBqcGVnLnNldCh0aGlzLmpwZWcsIDApO1xuICAgICAgICAgICAganBlZy5zZXQoanBlZ0J5dGVzLCB0aGlzLmpwZWcubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuanBlZyA9IGpwZWc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gZXhpc3RpbmcgZnJlZXplIGZyYW1lIGpwZWcsIG1ha2Ugb25lXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5qcGVnID0ganBlZ0J5dGVzO1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oYHJlY2VpdmVkIGZpcnN0IGNodW5rIG9mIGZyZWV6ZSBmcmFtZTogJHt0aGlzLmpwZWcubGVuZ3RofS8ke3RoaXMuc2l6ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5pc2hlZCByZWNlaXZpbmcgZnJlZXplIGZyYW1lLCB3ZSBjYW4gc2hvdyBpdCBub3dcbiAgICAgICAgaWYgKHRoaXMuanBlZy5sZW5ndGggPT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oYHJlY2VpdmVkIGNvbXBsZXRlIGZyZWV6ZSBmcmFtZSAke3RoaXMuc2l6ZX1gKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRnJlZXplRnJhbWVBbmRTaG93KHRoaXMuanBlZywgb25Mb2FkQ2FsbEJhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHJlY2VpdmVkIG1vcmUgZGF0YSB0aGFuIHRoZSBmcmVlemUgZnJhbWUgcGF5bG9hZCBtZXNzYWdlIGluZGljYXRlICh0aGlzIGlzIGFuIGVycm9yKVxuICAgICAgICBlbHNlIGlmICh0aGlzLmpwZWcubGVuZ3RoID4gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoYHJlY2VpdmVkIGJpZ2dlciBmcmVlemUgZnJhbWUgdGhhbiBhZHZlcnRpc2VkOiAke3RoaXMuanBlZy5sZW5ndGh9LyR7dGhpcy5zaXplfWApO1xuICAgICAgICAgICAgdGhpcy5qcGVnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZyZWV6ZUZyYW1lQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgZGVlcENvcHlHYW1lcGFkIH0gZnJvbSAnLi9HYW1lcGFkVHlwZXMnO1xuLyoqXG4gKiBHYW1lcGFkIGxheW91dCBjb2RlcyBlbnVtXG4gKi9cbmV4cG9ydCB2YXIgR2FtZXBhZExheW91dDtcbihmdW5jdGlvbiAoR2FtZXBhZExheW91dCkge1xuICAgIEdhbWVwYWRMYXlvdXRbR2FtZXBhZExheW91dFtcIlJpZ2h0Q2x1c3RlckJvdHRvbUJ1dHRvblwiXSA9IDBdID0gXCJSaWdodENsdXN0ZXJCb3R0b21CdXR0b25cIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJSaWdodENsdXN0ZXJSaWdodEJ1dHRvblwiXSA9IDFdID0gXCJSaWdodENsdXN0ZXJSaWdodEJ1dHRvblwiO1xuICAgIEdhbWVwYWRMYXlvdXRbR2FtZXBhZExheW91dFtcIlJpZ2h0Q2x1c3RlckxlZnRCdXR0b25cIl0gPSAyXSA9IFwiUmlnaHRDbHVzdGVyTGVmdEJ1dHRvblwiO1xuICAgIEdhbWVwYWRMYXlvdXRbR2FtZXBhZExheW91dFtcIlJpZ2h0Q2x1c3RlclRvcEJ1dHRvblwiXSA9IDNdID0gXCJSaWdodENsdXN0ZXJUb3BCdXR0b25cIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJMZWZ0U2hvdWxkZXJcIl0gPSA0XSA9IFwiTGVmdFNob3VsZGVyXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiUmlnaHRTaG91bGRlclwiXSA9IDVdID0gXCJSaWdodFNob3VsZGVyXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiTGVmdFRyaWdnZXJcIl0gPSA2XSA9IFwiTGVmdFRyaWdnZXJcIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJSaWdodFRyaWdnZXJcIl0gPSA3XSA9IFwiUmlnaHRUcmlnZ2VyXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiU2VsZWN0T3JCYWNrXCJdID0gOF0gPSBcIlNlbGVjdE9yQmFja1wiO1xuICAgIEdhbWVwYWRMYXlvdXRbR2FtZXBhZExheW91dFtcIlN0YXJ0T3JGb3J3YXJkXCJdID0gOV0gPSBcIlN0YXJ0T3JGb3J3YXJkXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiTGVmdEFuYWxvZ1ByZXNzXCJdID0gMTBdID0gXCJMZWZ0QW5hbG9nUHJlc3NcIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJSaWdodEFuYWxvZ1ByZXNzXCJdID0gMTFdID0gXCJSaWdodEFuYWxvZ1ByZXNzXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiTGVmdENsdXN0ZXJUb3BCdXR0b25cIl0gPSAxMl0gPSBcIkxlZnRDbHVzdGVyVG9wQnV0dG9uXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiTGVmdENsdXN0ZXJCb3R0b21CdXR0b25cIl0gPSAxM10gPSBcIkxlZnRDbHVzdGVyQm90dG9tQnV0dG9uXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiTGVmdENsdXN0ZXJMZWZ0QnV0dG9uXCJdID0gMTRdID0gXCJMZWZ0Q2x1c3RlckxlZnRCdXR0b25cIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJMZWZ0Q2x1c3RlclJpZ2h0QnV0dG9uXCJdID0gMTVdID0gXCJMZWZ0Q2x1c3RlclJpZ2h0QnV0dG9uXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiQ2VudHJlQnV0dG9uXCJdID0gMTZdID0gXCJDZW50cmVCdXR0b25cIjtcbiAgICAvLyBBeGVzXG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiTGVmdFN0aWNrSG9yaXpvbnRhbFwiXSA9IDBdID0gXCJMZWZ0U3RpY2tIb3Jpem9udGFsXCI7XG4gICAgR2FtZXBhZExheW91dFtHYW1lcGFkTGF5b3V0W1wiTGVmdFN0aWNrVmVydGljYWxcIl0gPSAxXSA9IFwiTGVmdFN0aWNrVmVydGljYWxcIjtcbiAgICBHYW1lcGFkTGF5b3V0W0dhbWVwYWRMYXlvdXRbXCJSaWdodFN0aWNrSG9yaXpvbnRhbFwiXSA9IDJdID0gXCJSaWdodFN0aWNrSG9yaXpvbnRhbFwiO1xuICAgIEdhbWVwYWRMYXlvdXRbR2FtZXBhZExheW91dFtcIlJpZ2h0U3RpY2tWZXJ0aWNhbFwiXSA9IDNdID0gXCJSaWdodFN0aWNrVmVydGljYWxcIjtcbn0pKEdhbWVwYWRMYXlvdXQgfHwgKEdhbWVwYWRMYXlvdXQgPSB7fSkpO1xuLyoqXG4gKiBIYW5kbGVzIGdhbWVwYWQgZXZlbnRzIGZyb20gdGhlIGRvY3VtZW50IHRvIHNlbmQgdG8gdGhlIHN0cmVhbWVyLlxuICovXG5leHBvcnQgY2xhc3MgR2FtZXBhZENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbU1lc3NhZ2VDb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIgPSBzdHJlYW1NZXNzYWdlQ29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5vbkdhbWVwYWRDb25uZWN0ZWRMaXN0ZW5lciA9IHRoaXMub25HYW1lcGFkQ29ubmVjdGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25HYW1lcGFkRGlzY29ubmVjdGVkTGlzdGVuZXIgPSB0aGlzLm9uR2FtZXBhZERpc2Nvbm5lY3RlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJlZm9yZVVubG9hZExpc3RlbmVyID0gdGhpcy5vbkJlZm9yZVVubG9hZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9ICh3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKS5iaW5kKHdpbmRvdyk7XG4gICAgfVxuICAgIHJlZ2lzdGVyKCkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdGhpcy5iZWZvcmVVbmxvYWRMaXN0ZW5lcik7XG4gICAgICAgIGNvbnN0IGJyb3dzZXJXaW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIGlmICgnR2FtZXBhZEV2ZW50JyBpbiBicm93c2VyV2luZG93KSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZ2FtZXBhZGNvbm5lY3RlZCcsIHRoaXMub25HYW1lcGFkQ29ubmVjdGVkTGlzdGVuZXIpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2dhbWVwYWRkaXNjb25uZWN0ZWQnLCB0aGlzLm9uR2FtZXBhZERpc2Nvbm5lY3RlZExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnV2ViS2l0R2FtZXBhZEV2ZW50JyBpbiBicm93c2VyV2luZG93KSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0Z2FtZXBhZGNvbm5lY3RlZCcsIHRoaXMub25HYW1lcGFkQ29ubmVjdGVkTGlzdGVuZXIpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdGdhbWVwYWRkaXNjb25uZWN0ZWQnLCB0aGlzLm9uR2FtZXBhZERpc2Nvbm5lY3RlZExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJzID0gW107XG4gICAgICAgIGlmIChuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZ2FtZXBhZCBvZiBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChnYW1lcGFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25HYW1lcGFkQ29ubmVjdGVkKG5ldyBHYW1lcGFkRXZlbnQoJ2dhbWVwYWRjb25uZWN0ZWQnLCB7IGdhbWVwYWQgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZ2FtZXBhZGNvbm5lY3RlZCcsIHRoaXMub25HYW1lcGFkQ29ubmVjdGVkTGlzdGVuZXIpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZ2FtZXBhZGRpc2Nvbm5lY3RlZCcsIHRoaXMub25HYW1lcGFkRGlzY29ubmVjdGVkTGlzdGVuZXIpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0Z2FtZXBhZGNvbm5lY3RlZCcsIHRoaXMub25HYW1lcGFkQ29ubmVjdGVkTGlzdGVuZXIpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0Z2FtZXBhZGRpc2Nvbm5lY3RlZCcsIHRoaXMub25HYW1lcGFkRGlzY29ubmVjdGVkTGlzdGVuZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXIgb2YgdGhpcy5jb250cm9sbGVycykge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIgJiYgY29udHJvbGxlci5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdHYW1lcGFkRGlzY29ubmVjdGVkJykoW2NvbnRyb2xsZXIuaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJzID0gW107XG4gICAgfVxuICAgIG9uR2FtZXBhZFJlc3BvbnNlUmVjZWl2ZWQoZ2FtZXBhZElkKSB7XG4gICAgICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzKSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlciAmJiBjb250cm9sbGVyLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmlkID0gZ2FtZXBhZElkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9uR2FtZXBhZENvbm5lY3RlZChldmVudCkge1xuICAgICAgICBjb25zdCBnYW1lcGFkID0gZXZlbnQuZ2FtZXBhZDtcbiAgICAgICAgY29uc3QgbmV3Q29udHJvbGxlciA9IHtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZTogZGVlcENvcHlHYW1lcGFkKGdhbWVwYWQpLFxuICAgICAgICAgICAgcHJldlN0YXRlOiBkZWVwQ29weUdhbWVwYWQoZ2FtZXBhZCksXG4gICAgICAgICAgICBpZDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnNbZ2FtZXBhZC5pbmRleF0gPSBuZXdDb250cm9sbGVyO1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMudXBkYXRlU3RhdHVzKCkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0dhbWVwYWRDb25uZWN0ZWQnKSgpO1xuICAgIH1cbiAgICBvbkdhbWVwYWREaXNjb25uZWN0ZWQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZ2FtZXBhZCA9IGV2ZW50LmdhbWVwYWQ7XG4gICAgICAgIGNvbnN0IGRlbGV0ZWRDb250cm9sbGVyID0gdGhpcy5jb250cm9sbGVyc1tnYW1lcGFkLmluZGV4XTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY29udHJvbGxlcnNbZ2FtZXBhZC5pbmRleF07XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnMgPSB0aGlzLmNvbnRyb2xsZXJzLmZpbHRlcigoY29udHJvbGxlcikgPT4gY29udHJvbGxlciAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGRlbGV0ZWRDb250cm9sbGVyLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnR2FtZXBhZERpc2Nvbm5lY3RlZCcpKFtcbiAgICAgICAgICAgICAgICBkZWxldGVkQ29udHJvbGxlci5pZFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2NhbkdhbWVwYWRzKCkge1xuICAgICAgICBjb25zdCBnYW1lcGFkcyA9IG5hdmlnYXRvci5nZXRHYW1lcGFkc1xuICAgICAgICAgICAgPyBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKVxuICAgICAgICAgICAgOiBuYXZpZ2F0b3Iud2Via2l0R2V0R2FtZXBhZHNcbiAgICAgICAgICAgICAgICA/IG5hdmlnYXRvci53ZWJraXRHZXRHYW1lcGFkcygpXG4gICAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnYW1lcGFkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGdhbWVwYWRzW2ldICYmIHRoaXMuY29udHJvbGxlcnNbZ2FtZXBhZHNbaV0uaW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJzW2dhbWVwYWRzW2ldLmluZGV4XS5jdXJyZW50U3RhdGUgPSBnYW1lcGFkc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTdGF0dXMoKSB7XG4gICAgICAgIHRoaXMuc2NhbkdhbWVwYWRzKCk7XG4gICAgICAgIGNvbnN0IHRvU3RyZWFtZXJIYW5kbGVycyA9IHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzO1xuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgbXVsdGlwbGUgY29udHJvbGxlcnMgaW4gdGhlIGNhc2UgdGhlIG11bHRpcGxlIGdhbWVwYWRzIGFyZSBjb25uZWN0ZWRcbiAgICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuY29udHJvbGxlcnMpIHtcbiAgICAgICAgICAgIGlmICghY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCByZWNlaXZlZCBhbiBpZCAocG9zc2libGUgaWYgdXNpbmcgYW4gb2xkZXIgdmVyc2lvbiBvZiBVRSksIHJldHVybiB0byBvcmlnaW5hbCBmdW5jdGlvbmFsaXR5XG4gICAgICAgICAgICBjb25zdCBjb250cm9sbGVySWQgPSBjb250cm9sbGVyLmlkID09PSB1bmRlZmluZWQgPyB0aGlzLmNvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcikgOiBjb250cm9sbGVyLmlkO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gY29udHJvbGxlci5jdXJyZW50U3RhdGU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRyb2xsZXIuY3VycmVudFN0YXRlLmJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50QnV0dG9uID0gY29udHJvbGxlci5jdXJyZW50U3RhdGUuYnV0dG9uc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0J1dHRvbiA9IGNvbnRyb2xsZXIucHJldlN0YXRlLmJ1dHRvbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCdXR0b24ucHJlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmVzc1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBHYW1lcGFkTGF5b3V0LkxlZnRUcmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVRXMgbGVmdCBhbmFsb2cgaGFzIGEgYnV0dG9uIGluZGV4IG9mIDVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0dhbWVwYWRBbmFsb2cnKShbY29udHJvbGxlcklkLCA1LCBjdXJyZW50QnV0dG9uLnZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSBHYW1lcGFkTGF5b3V0LlJpZ2h0VHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVUVzIHJpZ2h0IGFuYWxvZyBoYXMgYSBidXR0b24gaW5kZXggb2YgNlxuICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnR2FtZXBhZEFuYWxvZycpKFtjb250cm9sbGVySWQsIDYsIGN1cnJlbnRCdXR0b24udmFsdWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0dhbWVwYWRCdXR0b25QcmVzc2VkJykoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQnV0dG9uLnByZXNzZWQgPyAxIDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnJlbnRCdXR0b24ucHJlc3NlZCAmJiBwcmV2aW91c0J1dHRvbi5wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbGVhc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gR2FtZXBhZExheW91dC5MZWZ0VHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVUVzIGxlZnQgYW5hbG9nIGhhcyBhIGJ1dHRvbiBpbmRleCBvZiA1XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdHYW1lcGFkQW5hbG9nJykoW2NvbnRyb2xsZXJJZCwgNSwgMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gR2FtZXBhZExheW91dC5SaWdodFRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVFcyByaWdodCBhbmFsb2cgaGFzIGEgYnV0dG9uIGluZGV4IG9mIDZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0dhbWVwYWRBbmFsb2cnKShbY29udHJvbGxlcklkLCA2LCAwXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdHYW1lcGFkQnV0dG9uUmVsZWFzZWQnKShbY29udHJvbGxlcklkLCBpLCAwXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgZ2FtZXBhZCBheGVzICh3ZSB3aWxsIGluY3JlbWVudCBpbiBsb3RzIG9mIDIgYXMgdGhlcmUgaXMgMiBheGVzIHBlciBzdGljaylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudFN0YXRlLmF4ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBIb3Jpem9udGFsIGF4ZXMgYXJlIGV2ZW4gbnVtYmVyZWRcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gcGFyc2VGbG9hdChjdXJyZW50U3RhdGUuYXhlc1tpXS50b0ZpeGVkKDQpKTtcbiAgICAgICAgICAgICAgICAvLyBWZXJ0aWNhbCBheGVzIGFyZSBvZGQgbnVtYmVyZWRcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vZ2FtZXBhZC8jcmVtYXBwaW5nIEdhbWVwYWQgYnJvd3NlciBzaWRlIHN0YW5kYXJkIG1hcHBpbmcgaGFzIHBvc2l0aXZlIGRvd24sIG5lZ2F0aXZlIHVwLiBUaGlzIGlzIGRvd25yaWdodCBkaXNndXN0aW5nLiBTbyB3ZSBmaXggaXQuXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IC1wYXJzZUZsb2F0KGN1cnJlbnRTdGF0ZS5heGVzW2kgKyAxXS50b0ZpeGVkKDQpKTtcbiAgICAgICAgICAgICAgICAvLyBVRSdzIGFuYWxvZyBheGVzIGZvbGxvdyB0aGUgc2FtZSBvcmRlciBhcyB0aGUgYnJvd3NlcnMsIGJ1dCBzdGFydCBhdCBpbmRleCAxIHNvIHdlIHdpbGwgb2Zmc2V0IGFzIHN1Y2hcbiAgICAgICAgICAgICAgICB0b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdHYW1lcGFkQW5hbG9nJykoW2NvbnRyb2xsZXJJZCwgaSArIDEsIHhdKTsgLy8gSG9yaXpvbnRhbCBheGVzLCBvbmx5IG9mZnNldCBieSAxXG4gICAgICAgICAgICAgICAgdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnR2FtZXBhZEFuYWxvZycpKFtjb250cm9sbGVySWQsIGkgKyAyLCB5XSk7IC8vIFZlcnRpY2FsIGF4ZXMsIG9mZnNldCBieSB0d28gKDEgdG8gbWF0Y2ggVUVzIGF4ZXMgY29udmVudGlvbiBhbmQgdGhlbiBhbm90aGVyIDEgZm9yIHRoZSB2ZXJ0aWNhbCBheGVzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlckluZGV4ID0gdGhpcy5jb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyc1tjb250cm9sbGVySW5kZXhdLnByZXZTdGF0ZSA9IGRlZXBDb3B5R2FtZXBhZChjdXJyZW50U3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2xsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMudXBkYXRlU3RhdHVzKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uQmVmb3JlVW5sb2FkKF8pIHtcbiAgICAgICAgLy8gV2hlbiBhIHVzZXIgbmF2aWdhdGVzIGF3YXkgZnJvbSB0aGUgcGFnZSwgd2UgbmVlZCB0byBpbmZvcm0gVUUgb2YgYWxsIHRoZSBkaXNjb25uZWN0aW5nXG4gICAgICAgIC8vIGNvbnRyb2xsZXJzXG4gICAgICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRyb2xsZXIgfHwgY29udHJvbGxlci5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0dhbWVwYWREaXNjb25uZWN0ZWQnKShbY29udHJvbGxlci5pZF0pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2FtZXBhZENvbnRyb2xsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogRGVlcCBjb3BpZXMgdGhlIHZhbHVlcyBmcm9tIGEgZ2FtZXBhZCBieSBmaXJzdCBjb252ZXJ0aW5nIGl0IHRvIGEgSlNPTiBvYmplY3QgYW5kIHRoZW4gYmFjayB0byBhIGdhbWVwYWRcbiAqXG4gKiBAcGFyYW0gZ2FtZXBhZCB0aGUgb3JpZ2luYWwgZ2FtZXBhZFxuICogQHJldHVybnMgYSBuZXcgZ2FtZXBhZCBvYmplY3QsIHBvcHVsYXRlZCB3aXRoIHRoZSBvcmlnaW5hbCBnYW1lcGFkcyB2YWx1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDb3B5R2FtZXBhZChnYW1lcGFkKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBidXR0b25zOiBnYW1lcGFkLmJ1dHRvbnMubWFwKChiKSA9PiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHByZXNzZWQ6IGIucHJlc3NlZCxcbiAgICAgICAgICAgIHRvdWNoZWQ6IGIudG91Y2hlZCxcbiAgICAgICAgICAgIHZhbHVlOiBiLnZhbHVlXG4gICAgICAgIH0pKSksXG4gICAgICAgIGF4ZXM6IGdhbWVwYWQuYXhlc1xuICAgIH0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdhbWVwYWRUeXBlcy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgS2V5Ym9hcmRDb250cm9sbGVyIH0gZnJvbSAnLi9LZXlib2FyZENvbnRyb2xsZXInO1xuaW1wb3J0IHsgTW91c2VDb250cm9sbGVyTG9ja2VkIH0gZnJvbSAnLi9Nb3VzZUNvbnRyb2xsZXJMb2NrZWQnO1xuaW1wb3J0IHsgTW91c2VDb250cm9sbGVySG92ZXJpbmcgfSBmcm9tICcuL01vdXNlQ29udHJvbGxlckhvdmVyaW5nJztcbmltcG9ydCB7IFRvdWNoQ29udHJvbGxlciB9IGZyb20gJy4vVG91Y2hDb250cm9sbGVyJztcbmltcG9ydCB7IFRvdWNoQ29udHJvbGxlckZha2UgfSBmcm9tICcuL1RvdWNoQ29udHJvbGxlckZha2UnO1xuaW1wb3J0IHsgR2FtZXBhZENvbnRyb2xsZXIgfSBmcm9tICcuL0dhbWVwYWRDb250cm9sbGVyJztcbmltcG9ydCB7IENvbnRyb2xTY2hlbWVUeXBlIH0gZnJvbSAnLi4vQ29uZmlnL0NvbmZpZyc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG4vKipcbiAqIENsYXNzIGZvciBtYWtpbmcgYW5kIHNldHRpbmcgdXAgaW5wdXQgY2xhc3MgdHlwZXNcbiAqL1xuZXhwb3J0IGNsYXNzIElucHV0Q2xhc3Nlc0ZhY3Rvcnkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB0b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlciAtIFN0cmVhbSBtZXNzYWdlIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHZpZGVvRWxlbWVudFByb3ZpZGVyIC0gVmlkZW8gUGxheWVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIGNvb3JkaW5hdGVDb252ZXJ0ZXIgLSBBIGNvb3JkaW5hdGVDb252ZXJ0ZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlciwgdmlkZW9FbGVtZW50UHJvdmlkZXIsIGNvb3JkaW5hdGVDb252ZXJ0ZXIpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVLZXlzID0gbmV3IEFjdGl2ZUtleXMoKTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlciA9IHRvU3RyZWFtZXJNZXNzYWdlc1Byb3ZpZGVyO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFByb3ZpZGVyID0gdmlkZW9FbGVtZW50UHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlciA9IGNvb3JkaW5hdGVDb252ZXJ0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBicm93c2VyIGtleSBldmVudHMuXG4gICAgICovXG4gICAgcmVnaXN0ZXJLZXlCb2FyZChjb25maWcpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ1JlZ2lzdGVyIEtleWJvYXJkIEV2ZW50cycpO1xuICAgICAgICBjb25zdCBrZXlib2FyZENvbnRyb2xsZXIgPSBuZXcgS2V5Ym9hcmRDb250cm9sbGVyKHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXIsIGNvbmZpZywgdGhpcy5hY3RpdmVLZXlzKTtcbiAgICAgICAga2V5Ym9hcmRDb250cm9sbGVyLnJlZ2lzdGVyKCk7XG4gICAgICAgIHJldHVybiBrZXlib2FyZENvbnRyb2xsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJlZ2lzdGVyIG1vdXNlIGV2ZW50cyBiYXNlZCBvbiBhIGNvbnRyb2wgdHlwZVxuICAgICAqIEBwYXJhbSBjb250cm9sU2NoZW1lIC0gaWYgdGhlIG1vdXNlIGlzIGVpdGhlciBob3ZlcmluZyBvciBsb2NrZWRcbiAgICAgKi9cbiAgICByZWdpc3Rlck1vdXNlKGNvbnRyb2xTY2hlbWUpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ1JlZ2lzdGVyIE1vdXNlIEV2ZW50cycpO1xuICAgICAgICBsZXQgbW91c2VDb250cm9sbGVyO1xuICAgICAgICBpZiAoY29udHJvbFNjaGVtZSA9PSBDb250cm9sU2NoZW1lVHlwZS5Ib3ZlcmluZ01vdXNlKSB7XG4gICAgICAgICAgICBtb3VzZUNvbnRyb2xsZXIgPSBuZXcgTW91c2VDb250cm9sbGVySG92ZXJpbmcodGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlciwgdGhpcy52aWRlb0VsZW1lbnRQcm92aWRlciwgdGhpcy5jb29yZGluYXRlQ29udmVydGVyLCB0aGlzLmFjdGl2ZUtleXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW91c2VDb250cm9sbGVyID0gbmV3IE1vdXNlQ29udHJvbGxlckxvY2tlZCh0aGlzLnRvU3RyZWFtZXJNZXNzYWdlc1Byb3ZpZGVyLCB0aGlzLnZpZGVvRWxlbWVudFByb3ZpZGVyLCB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIsIHRoaXMuYWN0aXZlS2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgbW91c2VDb250cm9sbGVyLnJlZ2lzdGVyKCk7XG4gICAgICAgIHJldHVybiBtb3VzZUNvbnRyb2xsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJlZ2lzdGVyIHRvdWNoIGV2ZW50c1xuICAgICAqIEBwYXJhbSBmYWtlTW91c2VUb3VjaCAtIHRoZSBmYWtlZCBtb3VzZSB0b3VjaCBldmVudFxuICAgICAqL1xuICAgIHJlZ2lzdGVyVG91Y2goZmFrZU1vdXNlVG91Y2gpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ1JlZ2lzdGVyaW5nIFRvdWNoJyk7XG4gICAgICAgIGxldCB0b3VjaENvbnRyb2xsZXI7XG4gICAgICAgIGlmIChmYWtlTW91c2VUb3VjaCkge1xuICAgICAgICAgICAgdG91Y2hDb250cm9sbGVyID0gbmV3IFRvdWNoQ29udHJvbGxlckZha2UodGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlciwgdGhpcy52aWRlb0VsZW1lbnRQcm92aWRlciwgdGhpcy5jb29yZGluYXRlQ29udmVydGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvdWNoQ29udHJvbGxlciA9IG5ldyBUb3VjaENvbnRyb2xsZXIodGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlciwgdGhpcy52aWRlb0VsZW1lbnRQcm92aWRlciwgdGhpcy5jb29yZGluYXRlQ29udmVydGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0b3VjaENvbnRyb2xsZXIucmVnaXN0ZXIoKTtcbiAgICAgICAgcmV0dXJuIHRvdWNoQ29udHJvbGxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmVnaXN0ZXJzIGEgZ2FtZXBhZFxuICAgICAqL1xuICAgIHJlZ2lzdGVyR2FtZVBhZCgpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ1JlZ2lzdGVyIEdhbWUgUGFkJyk7XG4gICAgICAgIGNvbnN0IGdhbWVwYWRDb250cm9sbGVyID0gbmV3IEdhbWVwYWRDb250cm9sbGVyKHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXIpO1xuICAgICAgICBnYW1lcGFkQ29udHJvbGxlci5yZWdpc3RlcigpO1xuICAgICAgICByZXR1cm4gZ2FtZXBhZENvbnRyb2xsZXI7XG4gICAgfVxufVxuLyoqXG4gKiBBIGNsYXNzIHRoYXQga2VlcHMgdHJhY2sgb2YgY3VycmVudCBhY3RpdmUga2V5c1xuICovXG5leHBvcnQgY2xhc3MgQWN0aXZlS2V5cyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlS2V5cyA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZUtleXMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGFycmF5IG9mIGFjdGl2ZSBrZXlzXG4gICAgICogQHJldHVybnMgLSBhbiBhcnJheSBvZiBhY3RpdmUga2V5c1xuICAgICAqL1xuICAgIGdldEFjdGl2ZUtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUtleXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5wdXRDbGFzc2VzRmFjdG9yeS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLypcbiAqIE5ldyBicm93c2VyIEFQSXMgaGF2ZSBtb3ZlZCBhd2F5IGZyb20gS2V5Ym9hcmRFdmVudC5rZXlDb2RlIHRvIEtleWJvYXJkRXZlbnQuQ29kZS5cbiAqIEZvciBkZXRhaWxzIHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5Q29kZSNjb25zdGFudHNfZm9yX2tleWNvZGVfdmFsdWVcbiAqIFdlIHN0aWxsIHVzZSBvbGQgS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGludGVnZXJzIGluIHRoZSBVRSBDKysgc2lkZSwgc28gd2UgbmVlZCBhIHdheSB0byBtYXAgdGhlIG5ld1xuICogc3RyaW5nLWJhc2VkIEtleWJvYXJkRXZlbnQuQ29kZSB0byB0aGUgb2xkIGludGVnZXJzLlxuICovXG5leHBvcnQgY29uc3QgQ29kZVRvS2V5Q29kZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIEVzY2FwZTogMjcsXG4gICAgRGlnaXQwOiA0OCxcbiAgICBEaWdpdDE6IDQ5LFxuICAgIERpZ2l0MjogNTAsXG4gICAgRGlnaXQzOiA1MSxcbiAgICBEaWdpdDQ6IDUyLFxuICAgIERpZ2l0NTogNTMsXG4gICAgRGlnaXQ2OiA1NCxcbiAgICBEaWdpdDc6IDU1LFxuICAgIERpZ2l0ODogNTYsXG4gICAgRGlnaXQ5OiA1NyxcbiAgICBNaW51czogMTczLFxuICAgIEVxdWFsOiAxODcsXG4gICAgQmFja3NwYWNlOiA4LFxuICAgIFRhYjogOSxcbiAgICBLZXlROiA4MSxcbiAgICBLZXlXOiA4NyxcbiAgICBLZXlFOiA2OSxcbiAgICBLZXlSOiA4MixcbiAgICBLZXlUOiA4NCxcbiAgICBLZXlZOiA4OSxcbiAgICBLZXlVOiA4NSxcbiAgICBLZXlJOiA3MyxcbiAgICBLZXlPOiA3OSxcbiAgICBLZXlQOiA4MCxcbiAgICBCcmFja2V0TGVmdDogMjE5LFxuICAgIEJyYWNrZXRSaWdodDogMjIxLFxuICAgIEVudGVyOiAxMyxcbiAgICBDb250cm9sTGVmdDogMTcsXG4gICAgS2V5QTogNjUsXG4gICAgS2V5UzogODMsXG4gICAgS2V5RDogNjgsXG4gICAgS2V5RjogNzAsXG4gICAgS2V5RzogNzEsXG4gICAgS2V5SDogNzIsXG4gICAgS2V5SjogNzQsXG4gICAgS2V5SzogNzUsXG4gICAgS2V5TDogNzYsXG4gICAgU2VtaWNvbG9uOiAxODYsXG4gICAgUXVvdGU6IDIyMixcbiAgICBCYWNrcXVvdGU6IDE5MixcbiAgICBTaGlmdExlZnQ6IDE2LFxuICAgIEJhY2tzbGFzaDogMjIwLFxuICAgIEtleVo6IDkwLFxuICAgIEtleVg6IDg4LFxuICAgIEtleUM6IDY3LFxuICAgIEtleVY6IDg2LFxuICAgIEtleUI6IDY2LFxuICAgIEtleU46IDc4LFxuICAgIEtleU06IDc3LFxuICAgIENvbW1hOiAxODgsXG4gICAgUGVyaW9kOiAxOTAsXG4gICAgU2xhc2g6IDE5MSxcbiAgICBTaGlmdFJpZ2h0OiAyNTMsXG4gICAgQWx0TGVmdDogMTgsXG4gICAgU3BhY2U6IDMyLFxuICAgIENhcHNMb2NrOiAyMCxcbiAgICBGMTogMTEyLFxuICAgIEYyOiAxMTMsXG4gICAgRjM6IDExNCxcbiAgICBGNDogMTE1LFxuICAgIEY1OiAxMTYsXG4gICAgRjY6IDExNyxcbiAgICBGNzogMTE4LFxuICAgIEY4OiAxMTksXG4gICAgRjk6IDEyMCxcbiAgICBGMTA6IDEyMSxcbiAgICBGMTE6IDEyMixcbiAgICBGMTI6IDEyMyxcbiAgICBQYXVzZTogMTksXG4gICAgU2Nyb2xsTG9jazogMTQ1LFxuICAgIE51bXBhZERpdmlkZTogMTExLFxuICAgIE51bXBhZE11bHRpcGx5OiAxMDYsXG4gICAgTnVtcGFkU3VidHJhY3Q6IDEwOSxcbiAgICBOdW1wYWRBZGQ6IDEwNyxcbiAgICBOdW1wYWREZWNpbWFsOiAxMTAsXG4gICAgTnVtcGFkOTogMTA1LFxuICAgIE51bXBhZDg6IDEwNCxcbiAgICBOdW1wYWQ3OiAxMDMsXG4gICAgTnVtcGFkNjogMTAyLFxuICAgIE51bXBhZDU6IDEwMSxcbiAgICBOdW1wYWQ0OiAxMDAsXG4gICAgTnVtcGFkMzogOTksXG4gICAgTnVtcGFkMjogOTgsXG4gICAgTnVtcGFkMTogOTcsXG4gICAgTnVtcGFkMDogOTYsXG4gICAgTnVtTG9jazogMTQ0LFxuICAgIENvbnRyb2xSaWdodDogMjU0LFxuICAgIEFsdFJpZ2h0OiAyNTUsXG4gICAgSG9tZTogMzYsXG4gICAgRW5kOiAzNSxcbiAgICBBcnJvd1VwOiAzOCxcbiAgICBBcnJvd0xlZnQ6IDM3LFxuICAgIEFycm93UmlnaHQ6IDM5LFxuICAgIEFycm93RG93bjogNDAsXG4gICAgUGFnZVVwOiAzMyxcbiAgICBQYWdlRG93bjogMzQsXG4gICAgSW5zZXJ0OiA0NSxcbiAgICBEZWxldGU6IDQ2LFxuICAgIENvbnRleHRNZW51OiA5M1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1LZXlDb2Rlcy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgU3BlY2lhbEtleUNvZGVzIH0gZnJvbSAnLi9TcGVjaWFsS2V5Q29kZXMnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuaW1wb3J0IHsgRmxhZ3MgfSBmcm9tICcuLi9Db25maWcvQ29uZmlnJztcbmltcG9ydCB7IENvZGVUb0tleUNvZGUgfSBmcm9tICcuL0tleUNvZGVzJztcbi8qKlxuICogSGFuZGxlcyB0aGUgS2V5Ym9hcmQgSW5wdXRzIGZvciB0aGUgZG9jdW1lbnRcbiAqL1xuZXhwb3J0IGNsYXNzIEtleWJvYXJkQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3Ioc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIsIGNvbmZpZywgYWN0aXZlS2V5cykge1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyID0gc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmFjdGl2ZUtleXMgPSBhY3RpdmVLZXlzO1xuICAgICAgICB0aGlzLm9uS2V5RG93bkxpc3RlbmVyID0gdGhpcy5oYW5kbGVPbktleURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbktleVVwTGlzdGVuZXIgPSB0aGlzLmhhbmRsZU9uS2V5VXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbktleVByZXNzTGlzdGVuZXIgPSB0aGlzLmhhbmRsZU9uS2V5UHJlc3MuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bkxpc3RlbmVyKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uS2V5VXBMaXN0ZW5lcik7XG4gICAgICAgIC8vVGhpcyBoYXMgYmVlbiBkZXByZWNhdGVkIGFzIGF0IEp1biAxMyAyMDIxXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgdGhpcy5vbktleVByZXNzTGlzdGVuZXIpO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleURvd25MaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5vbktleVVwTGlzdGVuZXIpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHRoaXMub25LZXlQcmVzc0xpc3RlbmVyKTtcbiAgICB9XG4gICAgaGFuZGxlT25LZXlEb3duKGtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBrZXlDb2RlID0gdGhpcy5nZXRLZXljb2RlKGtleWJvYXJkRXZlbnQpO1xuICAgICAgICBpZiAoIWtleUNvZGUgfHwga2V5Q29kZSA9PT0gMjI5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9TdHJlYW1lckhhbmRsZXJzID0gdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnM7XG4gICAgICAgIChfYSA9IHRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0tleURvd24nKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKFt0aGlzLmdldEtleWNvZGUoa2V5Ym9hcmRFdmVudCksIGtleWJvYXJkRXZlbnQucmVwZWF0ID8gMSA6IDBdKTtcbiAgICAgICAgY29uc3QgYWN0aXZlS2V5cyA9IHRoaXMuYWN0aXZlS2V5cy5nZXRBY3RpdmVLZXlzKCk7XG4gICAgICAgIGFjdGl2ZUtleXMucHVzaChrZXlDb2RlKTtcbiAgICAgICAgLy8gQmFja3NwYWNlIGlzIG5vdCBjb25zaWRlcmVkIGEga2V5cHJlc3MgaW4gSmF2YVNjcmlwdCBidXQgd2UgbmVlZCBpdFxuICAgICAgICAvLyB0byBiZSBzbyBjaGFyYWN0ZXJzIG1heSBiZSBkZWxldGVkIGluIGEgVUUgdGV4dCBlbnRyeSBmaWVsZC5cbiAgICAgICAgLy8gc2luY2Uga2V5cHJlc3MgaXMgZGVwcmVjYXRlZCB3ZSByZWFsbHkgc2hvdWxkIGJlIHNlbmRpbmcgYWxsIGtleXMgdG8ga2V5cHJlc3NcbiAgICAgICAgLy8gb3Igd2UgY2hhbmdlIGV2ZXJ5dGhpbmcgdG8gaGFuZGxlIHRoZSBkZXByZWNhdGlvbiBvZiB0aGVzZSBwYXJ0c1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gU3BlY2lhbEtleUNvZGVzLmJhY2tTcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVPbktleVByZXNzKG5ldyBLZXlib2FyZEV2ZW50KCdrZXlwcmVzcycsIHtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZTogU3BlY2lhbEtleUNvZGVzLmJhY2tTcGFjZSxcbiAgICAgICAgICAgICAgICBrZXlDb2RlOiBTcGVjaWFsS2V5Q29kZXMuYmFja1NwYWNlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuU3VwcHJlc3NCcm93c2VyS2V5cykgJiYgdGhpcy5pc0tleUNvZGVCcm93c2VyS2V5KGtleUNvZGUpKSB7XG4gICAgICAgICAgICBrZXlib2FyZEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlT25LZXlVcChrZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qga2V5Q29kZSA9IHRoaXMuZ2V0S2V5Y29kZShrZXlib2FyZEV2ZW50KTtcbiAgICAgICAgaWYgKCFrZXlDb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9TdHJlYW1lckhhbmRsZXJzID0gdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnM7XG4gICAgICAgIChfYSA9IHRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0tleVVwJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYShba2V5Q29kZV0pO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5TdXBwcmVzc0Jyb3dzZXJLZXlzKSAmJiB0aGlzLmlzS2V5Q29kZUJyb3dzZXJLZXkoa2V5Q29kZSkpIHtcbiAgICAgICAgICAgIGtleWJvYXJkRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVPbktleVByZXNzKGtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBrZXlDb2RlID0gdGhpcy5nZXRLZXljb2RlKGtleWJvYXJkRXZlbnQpO1xuICAgICAgICBpZiAoIWtleUNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b1N0cmVhbWVySGFuZGxlcnMgPSB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycztcbiAgICAgICAgKF9hID0gdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnS2V5UHJlc3MnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKFtrZXlDb2RlXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEtleWNvZGUgb2YgdGhlIEtleSBwcmVzc2VkXG4gICAgICogQHBhcmFtIGtleWJvYXJkRXZlbnQgLSBLZXkgYm9hcmQgRXZlbnRcbiAgICAgKiBAcmV0dXJucyAtIHRoZSBrZXkgY29kZSBvZiB0aGUgS2V5XG4gICAgICovXG4gICAgZ2V0S2V5Y29kZShrZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUga2V5Q29kZSBwcm9wZXJ0eSBiZWNhdXNlIGJyb3dzZXIgQVBJIGlzIGRlcHJlY2F0ZWQgdGhlbiB1c2UgS2V5Ym9hcmRFdmVudC5jb2RlIGluc3RlYWQuXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5Q29kZSNjb25zdGFudHNfZm9yX2tleWNvZGVfdmFsdWVcbiAgICAgICAgaWYgKCEoJ2tleUNvZGUnIGluIGtleWJvYXJkRXZlbnQpKSB7XG4gICAgICAgICAgICAvLyB0aGlzIHR5cGUgYXNzZXJ0aW9uIGhlcmUgaXMgcmVxdWlyZWQgYmVjYXVzZSBpZiAna2V5Q29kZScgZG9lc250IGV4aXN0IGluIGtleWJvYXJkRXZlbnQgdGhlblxuICAgICAgICAgICAgLy8gaXQgY2Fubm90IGJlIGEgS2V5Ym9hcmRFdmVudCBhbmQgc28gaXQgZ2V0cyBuYXJyb3dlZCB0byAnbmV2ZXInXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGtleWJvYXJkRXZlbnQ7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IEtleWJvYXJkRXZlbnQuY29kZSBzdHJpbmcgaW50byBpbnRlZ2VyLWJhc2VkIGtleSBjb2RlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zLlxuICAgICAgICAgICAgaWYgKGV2ZW50LmNvZGUgaW4gQ29kZVRvS2V5Q29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb2RlVG9LZXlDb2RlW2V2ZW50LmNvZGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLldhcm5pbmcoYEtleWJvYXJkIGNvZGUgb2YgJHtldmVudC5jb2RlfSBpcyBub3Qgc3VwcG9ydGVkIGluIG91ciBtYXBwaW5nLCBpZ25vcmluZyB0aGlzIGtleS5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBtYWRlIGl0IGhlcmUgS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGlzIHN0aWxsIHN1cHBvcnRlZCBzbyB3ZSBjYW4gc2FmZWx5IHVzZSBpdC5cbiAgICAgICAgaWYgKGtleWJvYXJkRXZlbnQua2V5Q29kZSA9PT0gU3BlY2lhbEtleUNvZGVzLnNoaWZ0ICYmIGtleWJvYXJkRXZlbnQuY29kZSA9PT0gJ1NoaWZ0UmlnaHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gU3BlY2lhbEtleUNvZGVzLnJpZ2h0U2hpZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5Ym9hcmRFdmVudC5rZXlDb2RlID09PSBTcGVjaWFsS2V5Q29kZXMuY29udHJvbCAmJlxuICAgICAgICAgICAga2V5Ym9hcmRFdmVudC5jb2RlID09PSAnQ29udHJvbFJpZ2h0Jykge1xuICAgICAgICAgICAgcmV0dXJuIFNwZWNpYWxLZXlDb2Rlcy5yaWdodENvbnRyb2w7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5Ym9hcmRFdmVudC5rZXlDb2RlID09PSBTcGVjaWFsS2V5Q29kZXMuYWx0ICYmIGtleWJvYXJkRXZlbnQuY29kZSA9PT0gJ0FsdFJpZ2h0Jykge1xuICAgICAgICAgICAgcmV0dXJuIFNwZWNpYWxLZXlDb2Rlcy5yaWdodEFsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlib2FyZEV2ZW50LmtleUNvZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnJvd3NlciBrZXlzIGRvIG5vdCBoYXZlIGEgY2hhckNvZGUgc28gd2Ugb25seSBuZWVkIHRvIHRlc3Qga2V5Q29kZS5cbiAgICAgKiBAcGFyYW0ga2V5Q29kZSAtIHRoZSBicm93c2VyIGtleWNvZGUgbnVtYmVyXG4gICAgICovXG4gICAgaXNLZXlDb2RlQnJvd3NlcktleShrZXlDb2RlKSB7XG4gICAgICAgIC8vIEZ1bmN0aW9uIGtleXMgb3IgdGFiIGtleSBhcmUgY29uc2lkZXJlZCBcImJyb3dzZXIga2V5c1wiIHRoYXQgd2UgbWF5IHdpc2ggdG8gc3VwcHJlc3MgYnkgcHJldmVudGluZyB0aGVtIGJlaW5nIHByb2Nlc3MgYnkgYnJvd3Nlci5cbiAgICAgICAgcmV0dXJuIChrZXlDb2RlID49IDExMiAmJiBrZXlDb2RlIDw9IDEyMykgfHwga2V5Q29kZSA9PT0gOTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1LZXlib2FyZENvbnRyb2xsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogTW91c2UgQnV0dG9uIERhdGFcbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9idXR0b259XG4gKi9cbmV4cG9ydCBjbGFzcyBNb3VzZUJ1dHRvbiB7XG59XG5Nb3VzZUJ1dHRvbi5tYWluQnV0dG9uID0gMDsgLy8gTGVmdCBidXR0b24uXG5Nb3VzZUJ1dHRvbi5hdXhpbGlhcnlCdXR0b24gPSAxOyAvLyBXaGVlbCBidXR0b24uXG5Nb3VzZUJ1dHRvbi5zZWNvbmRhcnlCdXR0b24gPSAyOyAvLyBSaWdodCBidXR0b24uXG5Nb3VzZUJ1dHRvbi5mb3VydGhCdXR0b24gPSAzOyAvLyBCcm93c2VyIEJhY2sgYnV0dG9uLlxuTW91c2VCdXR0b24uZmlmdGhCdXR0b24gPSA0OyAvLyBCcm93c2VyIEZvcndhcmQgYnV0dG9uLlxuLyoqXG4gKiBNb3VzZSBCdXR0b24gTWFzayBEYXRhXG4gKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvYnV0dG9uc31cbiAqL1xuZXhwb3J0IGNsYXNzIE1vdXNlQnV0dG9uc01hc2sge1xufVxuTW91c2VCdXR0b25zTWFzay5wcmltYXJ5QnV0dG9uID0gMTsgLy8gTGVmdCBidXR0b24uXG5Nb3VzZUJ1dHRvbnNNYXNrLnNlY29uZGFyeUJ1dHRvbiA9IDI7IC8vIFJpZ2h0IGJ1dHRvbi5cbk1vdXNlQnV0dG9uc01hc2suYXV4aWxpYXJ5QnV0dG9uID0gNDsgLy8gV2hlZWwgYnV0dG9uLlxuTW91c2VCdXR0b25zTWFzay5mb3VydGhCdXR0b24gPSA4OyAvLyBCcm93c2VyIEJhY2sgYnV0dG9uLlxuTW91c2VCdXR0b25zTWFzay5maWZ0aEJ1dHRvbiA9IDE2OyAvLyBCcm93c2VyIEZvcndhcmQgYnV0dG9uLlxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TW91c2VCdXR0b25zLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBNb3VzZUJ1dHRvbnNNYXNrLCBNb3VzZUJ1dHRvbiB9IGZyb20gJy4vTW91c2VCdXR0b25zJztcbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIG1vdXNlIGNvbnRyb2xsZXJzLiBTaW5jZSB0aGVyZSBpcyBhIGJ1bmNoIG9mIHNoYXJlZCBiZWhhdmlvdXIgYmV0d2VlbiBsb2NrZWQgYW5kXG4gKiBob3ZlciBtb3VzZSBjb250cm9sbGVycyB0aGlzIGlzIHdoZXJlIHRoYXQgc2hhcmVkIGJlaGF2aW91ciBsaXZlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIE1vdXNlQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3Ioc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIsIHZpZGVvUGxheWVyLCBjb29yZGluYXRlQ29udmVydGVyLCBhY3RpdmVLZXlzKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIgPSBzdHJlYW1NZXNzYWdlQ29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5jb29yZGluYXRlQ29udmVydGVyID0gY29vcmRpbmF0ZUNvbnZlcnRlcjtcbiAgICAgICAgdGhpcy52aWRlb1BsYXllciA9IHZpZGVvUGxheWVyO1xuICAgICAgICB0aGlzLmFjdGl2ZUtleXMgPSBhY3RpdmVLZXlzO1xuICAgICAgICB0aGlzLm9uRW50ZXJMaXN0ZW5lciA9IHRoaXMub25Nb3VzZUVudGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25MZWF2ZUxpc3RlbmVyID0gdGhpcy5vbk1vdXNlTGVhdmUuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJNb3VzZUVudGVyQW5kTGVhdmVFdmVudHMoKTtcbiAgICB9XG4gICAgdW5yZWdpc3RlcigpIHtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyTW91c2VFbnRlckFuZExlYXZlRXZlbnRzKCk7XG4gICAgfVxuICAgIHJlZ2lzdGVyTW91c2VFbnRlckFuZExlYXZlRXZlbnRzKCkge1xuICAgICAgICBjb25zdCB2aWRlb0VsZW1lbnRQYXJlbnQgPSB0aGlzLnZpZGVvUGxheWVyLmdldFZpZGVvUGFyZW50RWxlbWVudCgpO1xuICAgICAgICB2aWRlb0VsZW1lbnRQYXJlbnQgPT09IG51bGwgfHwgdmlkZW9FbGVtZW50UGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25FbnRlckxpc3RlbmVyKTtcbiAgICAgICAgdmlkZW9FbGVtZW50UGFyZW50ID09PSBudWxsIHx8IHZpZGVvRWxlbWVudFBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTGVhdmVMaXN0ZW5lcik7XG4gICAgfVxuICAgIHVucmVnaXN0ZXJNb3VzZUVudGVyQW5kTGVhdmVFdmVudHMoKSB7XG4gICAgICAgIGNvbnN0IHZpZGVvRWxlbWVudFBhcmVudCA9IHRoaXMudmlkZW9QbGF5ZXIuZ2V0VmlkZW9QYXJlbnRFbGVtZW50KCk7XG4gICAgICAgIHZpZGVvRWxlbWVudFBhcmVudCA9PT0gbnVsbCB8fCB2aWRlb0VsZW1lbnRQYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZGVvRWxlbWVudFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbkVudGVyTGlzdGVuZXIpO1xuICAgICAgICB2aWRlb0VsZW1lbnRQYXJlbnQgPT09IG51bGwgfHwgdmlkZW9FbGVtZW50UGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25MZWF2ZUxpc3RlbmVyKTtcbiAgICB9XG4gICAgb25Nb3VzZUVudGVyKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdNb3VzZUVudGVyJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYSgpO1xuICAgICAgICB0aGlzLnByZXNzTW91c2VCdXR0b25zKGV2ZW50LmJ1dHRvbnMsIGV2ZW50LngsIGV2ZW50LnkpO1xuICAgIH1cbiAgICBvbk1vdXNlTGVhdmUoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlTGVhdmUnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKCk7XG4gICAgICAgIHRoaXMucmVsZWFzZU1vdXNlQnV0dG9ucyhldmVudC5idXR0b25zLCBldmVudC54LCBldmVudC55KTtcbiAgICB9XG4gICAgcmVsZWFzZU1vdXNlQnV0dG9ucyhidXR0b25zLCBYLCBZKSB7XG4gICAgICAgIGNvbnN0IGNvb3JkID0gdGhpcy5jb29yZGluYXRlQ29udmVydGVyLnRyYW5zbGF0ZVVuc2lnbmVkKFgsIFkpO1xuICAgICAgICBpZiAoYnV0dG9ucyAmIE1vdXNlQnV0dG9uc01hc2sucHJpbWFyeUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5zZW5kTW91c2VVcChNb3VzZUJ1dHRvbi5tYWluQnV0dG9uLCBjb29yZC54LCBjb29yZC55KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9ucyAmIE1vdXNlQnV0dG9uc01hc2suc2Vjb25kYXJ5QnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRNb3VzZVVwKE1vdXNlQnV0dG9uLnNlY29uZGFyeUJ1dHRvbiwgY29vcmQueCwgY29vcmQueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbnMgJiBNb3VzZUJ1dHRvbnNNYXNrLmF1eGlsaWFyeUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5zZW5kTW91c2VVcChNb3VzZUJ1dHRvbi5hdXhpbGlhcnlCdXR0b24sIGNvb3JkLngsIGNvb3JkLnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25zICYgTW91c2VCdXR0b25zTWFzay5mb3VydGhCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1vdXNlVXAoTW91c2VCdXR0b24uZm91cnRoQnV0dG9uLCBjb29yZC54LCBjb29yZC55KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9ucyAmIE1vdXNlQnV0dG9uc01hc2suZmlmdGhCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1vdXNlVXAoTW91c2VCdXR0b24uZmlmdGhCdXR0b24sIGNvb3JkLngsIGNvb3JkLnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXNzTW91c2VCdXR0b25zKGJ1dHRvbnMsIFgsIFkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoWCwgWSk7XG4gICAgICAgIGlmIChidXR0b25zICYgTW91c2VCdXR0b25zTWFzay5wcmltYXJ5QnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRNb3VzZURvd24oTW91c2VCdXR0b24ubWFpbkJ1dHRvbiwgY29vcmQueCwgY29vcmQueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbnMgJiBNb3VzZUJ1dHRvbnNNYXNrLnNlY29uZGFyeUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5zZW5kTW91c2VEb3duKE1vdXNlQnV0dG9uLnNlY29uZGFyeUJ1dHRvbiwgY29vcmQueCwgY29vcmQueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbnMgJiBNb3VzZUJ1dHRvbnNNYXNrLmF1eGlsaWFyeUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5zZW5kTW91c2VEb3duKE1vdXNlQnV0dG9uLmF1eGlsaWFyeUJ1dHRvbiwgY29vcmQueCwgY29vcmQueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbnMgJiBNb3VzZUJ1dHRvbnNNYXNrLmZvdXJ0aEJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5zZW5kTW91c2VEb3duKE1vdXNlQnV0dG9uLmZvdXJ0aEJ1dHRvbiwgY29vcmQueCwgY29vcmQueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbnMgJiBNb3VzZUJ1dHRvbnNNYXNrLmZpZnRoQnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRNb3VzZURvd24oTW91c2VCdXR0b24uZmlmdGhCdXR0b24sIGNvb3JkLngsIGNvb3JkLnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRNb3VzZURvd24oYnV0dG9uLCBYLCBZKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdNb3VzZURvd24nKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKFtidXR0b24sIFgsIFldKTtcbiAgICB9XG4gICAgc2VuZE1vdXNlVXAoYnV0dG9uLCBYLCBZKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoWCwgWSk7XG4gICAgICAgIChfYSA9IHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VVcCcpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoW2J1dHRvbiwgY29vcmQueCwgY29vcmQueV0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1vdXNlQ29udHJvbGxlci5qcy5tYXAiLCJpbXBvcnQgeyBNb3VzZUNvbnRyb2xsZXIgfSBmcm9tICcuL01vdXNlQ29udHJvbGxlcic7XG4vKipcbiAqIEEgbW91c2UgY29udHJvbGxlciB0aGF0IGFsbG93cyB0aGUgbW91c2UgdG8gZnJlZWx5IGZsb2F0IG92ZXIgdGhlIHZpZGVvIGRvY3VtZW50LlxuICovXG5leHBvcnQgY2xhc3MgTW91c2VDb250cm9sbGVySG92ZXJpbmcgZXh0ZW5kcyBNb3VzZUNvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLCB2aWRlb1BsYXllciwgY29vcmRpbmF0ZUNvbnZlcnRlciwgYWN0aXZlS2V5cykge1xuICAgICAgICBzdXBlcihzdHJlYW1NZXNzYWdlQ29udHJvbGxlciwgdmlkZW9QbGF5ZXIsIGNvb3JkaW5hdGVDb252ZXJ0ZXIsIGFjdGl2ZUtleXMpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudCA9IHZpZGVvUGxheWVyLmdldFZpZGVvUGFyZW50RWxlbWVudCgpO1xuICAgICAgICB0aGlzLm9uTW91c2VVcExpc3RlbmVyID0gdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bkxpc3RlbmVyID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VEYmxDbGlja0xpc3RlbmVyID0gdGhpcy5vbk1vdXNlRGJsQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlV2hlZWxMaXN0ZW5lciA9IHRoaXMub25Nb3VzZVdoZWVsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmVMaXN0ZW5lciA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkNvbnRleHRNZW51TGlzdGVuZXIgPSB0aGlzLm9uQ29udGV4dE1lbnUuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoKSB7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyKCk7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd25MaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLm9uQ29udGV4dE1lbnVMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbk1vdXNlV2hlZWxMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5vbk1vdXNlRGJsQ2xpY2tMaXN0ZW5lcik7XG4gICAgfVxuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd25MaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLm9uQ29udGV4dE1lbnVMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbk1vdXNlV2hlZWxMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5vbk1vdXNlRGJsQ2xpY2tMaXN0ZW5lcik7XG4gICAgICAgIHN1cGVyLnVucmVnaXN0ZXIoKTtcbiAgICB9XG4gICAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VEb3duJykoW2V2ZW50LmJ1dHRvbiwgY29vcmQueCwgY29vcmQueV0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VVcCcpKFtldmVudC5idXR0b24sIGNvb3JkLngsIGNvb3JkLnldKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgb25Db250ZXh0TWVudShldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb29yZCA9IHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlci50cmFuc2xhdGVVbnNpZ25lZChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlU2lnbmVkKGV2ZW50Lm1vdmVtZW50WCwgZXZlbnQubW92ZW1lbnRZKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdNb3VzZU1vdmUnKShbXG4gICAgICAgICAgICBjb29yZC54LFxuICAgICAgICAgICAgY29vcmQueSxcbiAgICAgICAgICAgIGRlbHRhLngsXG4gICAgICAgICAgICBkZWx0YS55XG4gICAgICAgIF0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBvbk1vdXNlV2hlZWwoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VXaGVlbCcpKFtcbiAgICAgICAgICAgIGV2ZW50LndoZWVsRGVsdGEsXG4gICAgICAgICAgICBjb29yZC54LFxuICAgICAgICAgICAgY29vcmQueVxuICAgICAgICBdKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgb25Nb3VzZURibENsaWNrKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvb3JkID0gdGhpcy5jb29yZGluYXRlQ29udmVydGVyLnRyYW5zbGF0ZVVuc2lnbmVkKGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlRG91YmxlJykoW2V2ZW50LmJ1dHRvbiwgY29vcmQueCwgY29vcmQueV0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1vdXNlQ29udHJvbGxlckhvdmVyaW5nLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG5pbXBvcnQgeyBNb3VzZUNvbnRyb2xsZXIgfSBmcm9tICcuL01vdXNlQ29udHJvbGxlcic7XG4vKipcbiAqIEEgbW91c2UgY29udHJvbGxlciB0aGF0IGxvY2tzIHRoZSBtb3VzZSB0byB0aGUgdmlkZW8gZG9jdW1lbnQgYW5kIHByZXZlbnRzIGl0IGZyb20gbGVhdmluZyB0aGUgd2luZG93XG4gKi9cbmV4cG9ydCBjbGFzcyBNb3VzZUNvbnRyb2xsZXJMb2NrZWQgZXh0ZW5kcyBNb3VzZUNvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLCB2aWRlb1BsYXllciwgY29vcmRpbmF0ZUNvbnZlcnRlciwgYWN0aXZlS2V5cykge1xuICAgICAgICBzdXBlcihzdHJlYW1NZXNzYWdlQ29udHJvbGxlciwgdmlkZW9QbGF5ZXIsIGNvb3JkaW5hdGVDb252ZXJ0ZXIsIGFjdGl2ZUtleXMpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudCA9IHZpZGVvUGxheWVyLmdldFZpZGVvUGFyZW50RWxlbWVudCgpO1xuICAgICAgICB0aGlzLnggPSB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMueSA9IHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCAvIDI7XG4gICAgICAgIHRoaXMubm9ybWFsaXplZENvb3JkID0gdGhpcy5jb29yZGluYXRlQ29udmVydGVyLnRyYW5zbGF0ZVVuc2lnbmVkKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgdGhpcy5vblJlcXVlc3RMb2NrTGlzdGVuZXIgPSB0aGlzLm9uUmVxdWVzdExvY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkxvY2tTdGF0ZUNoYW5nZUxpc3RlbmVyID0gdGhpcy5vbkxvY2tTdGF0ZUNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VVcExpc3RlbmVyID0gdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bkxpc3RlbmVyID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VEYmxDbGlja0xpc3RlbmVyID0gdGhpcy5vbk1vdXNlRGJsQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlV2hlZWxMaXN0ZW5lciA9IHRoaXMub25Nb3VzZVdoZWVsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmVMaXN0ZW5lciA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoKSB7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyKCk7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlcXVlc3RQb2ludGVyTG9jayA9XG4gICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5yZXF1ZXN0UG9pbnRlckxvY2sgfHwgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQubW96UmVxdWVzdFBvaW50ZXJMb2NrO1xuICAgICAgICBkb2N1bWVudC5leGl0UG9pbnRlckxvY2sgPSBkb2N1bWVudC5leGl0UG9pbnRlckxvY2sgfHwgZG9jdW1lbnQubW96RXhpdFBvaW50ZXJMb2NrO1xuICAgICAgICBpZiAodGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVxdWVzdFBvaW50ZXJMb2NrKSB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25SZXF1ZXN0TG9ja0xpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybG9ja2NoYW5nZScsIHRoaXMub25Mb2NrU3RhdGVDaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21venBvaW50ZXJsb2NrY2hhbmdlJywgdGhpcy5vbkxvY2tTdGF0ZUNoYW5nZUxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bkxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMub25Nb3VzZVdoZWVsTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMub25Nb3VzZURibENsaWNrTGlzdGVuZXIpO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBjb25zdCBwb2ludGVyTG9ja0VsZW1lbnQgPSBkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQgfHwgZG9jdW1lbnQubW96UG9pbnRlckxvY2tFbGVtZW50O1xuICAgICAgICBpZiAoZG9jdW1lbnQuZXhpdFBvaW50ZXJMb2NrICYmIHBvaW50ZXJMb2NrRWxlbWVudCA9PT0gdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4aXRQb2ludGVyTG9jaygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vblJlcXVlc3RMb2NrTGlzdGVuZXIpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybG9ja2NoYW5nZScsIHRoaXMub25Mb2NrU3RhdGVDaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21venBvaW50ZXJsb2NrY2hhbmdlJywgdGhpcy5vbkxvY2tTdGF0ZUNoYW5nZUxpc3RlbmVyKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZUxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bkxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMub25Nb3VzZVdoZWVsTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMub25Nb3VzZURibENsaWNrTGlzdGVuZXIpO1xuICAgICAgICBzdXBlci51bnJlZ2lzdGVyKCk7XG4gICAgfVxuICAgIG9uUmVxdWVzdExvY2soKSB7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlcXVlc3RQb2ludGVyTG9jaygpO1xuICAgIH1cbiAgICBvbkxvY2tTdGF0ZUNoYW5nZSgpIHtcbiAgICAgICAgY29uc3QgcG9pbnRlckxvY2tFbGVtZW50ID0gZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50IHx8IGRvY3VtZW50Lm1velBvaW50ZXJMb2NrRWxlbWVudDtcbiAgICAgICAgaWYgKHBvaW50ZXJMb2NrRWxlbWVudCA9PT0gdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQpIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdQb2ludGVyIGxvY2tlZCcpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdUaGUgcG9pbnRlciBsb2NrIHN0YXR1cyBpcyBub3cgdW5sb2NrZWQnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICAvLyBJZiBtb3VzZSBsb3NlcyBmb2N1cywgc2VuZCBhIGtleSB1cCBmb3IgYWxsIG9mIHRoZSBjdXJyZW50bHkgaGVsZC1kb3duIGtleXNcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGFzIHdoZW4gdGhlIG1vdXNlIGxvc2VzIGZvY3VzLCB0aGUgd2luZG93cyBzdG9wcyBsaXN0ZW5pbmcgZm9yIGV2ZW50cyBhbmQgYXMgc3VjaFxuICAgICAgICAgICAgLy8gdGhlIGtleXVwIGxpc3RlbmVyIHdvbid0IGdldCBmaXJlZFxuICAgICAgICAgICAgY29uc3QgYWN0aXZlS2V5cyA9IHRoaXMuYWN0aXZlS2V5cy5nZXRBY3RpdmVLZXlzKCk7XG4gICAgICAgICAgICBhY3RpdmVLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnS2V5VXAnKShba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlRG93bicpKFtcbiAgICAgICAgICAgIGV2ZW50LmJ1dHRvbixcbiAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgc3RvcmUgdmFsdWUgb2YgdGhpcy5jb29yZCBhcyBvcHBvc2VkIHRvIHRoZSBtb3VzZUV2ZW50LngveSBhcyB0aGUgbW91c2VFdmVudCBsb2NhdGlvblxuICAgICAgICAgICAgLy8gdXNlcyB0aGUgc3lzdGVtIGN1cnNvciBsb2NhdGlvbiB3aGljaCBoYXNuJ3QgbW92ZWRcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZENvb3JkLngsXG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWRDb29yZC55XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdNb3VzZVVwJykoW1xuICAgICAgICAgICAgZXZlbnQuYnV0dG9uLFxuICAgICAgICAgICAgLy8gV2UgdXNlIHRoZSBzdG9yZSB2YWx1ZSBvZiB0aGlzLmNvb3JkIGFzIG9wcG9zZWQgdG8gdGhlIG1vdXNlRXZlbnQueC95IGFzIHRoZSBtb3VzZUV2ZW50IGxvY2F0aW9uXG4gICAgICAgICAgICAvLyB1c2VzIHRoZSBzeXN0ZW0gY3Vyc29yIGxvY2F0aW9uIHdoaWNoIGhhc24ndCBtb3ZlZFxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkQ29vcmQueCxcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZENvb3JkLnlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0eWxlV2lkdGggPSB0aGlzLnZpZGVvUGxheWVyLmdldFZpZGVvUGFyZW50RWxlbWVudCgpLmNsaWVudFdpZHRoO1xuICAgICAgICBjb25zdCBzdHlsZUhlaWdodCA9IHRoaXMudmlkZW9QbGF5ZXIuZ2V0VmlkZW9QYXJlbnRFbGVtZW50KCkuY2xpZW50SGVpZ2h0O1xuICAgICAgICB0aGlzLnggKz0gZXZlbnQubW92ZW1lbnRYO1xuICAgICAgICB0aGlzLnkgKz0gZXZlbnQubW92ZW1lbnRZO1xuICAgICAgICB3aGlsZSAodGhpcy54ID4gc3R5bGVXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy54IC09IHN0eWxlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMueSA+IHN0eWxlSGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnkgLT0gc3R5bGVIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMueCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMueCArPSBzdHlsZVdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnkgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnkgKz0gc3R5bGVIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3JtYWxpemVkQ29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlci50cmFuc2xhdGVTaWduZWQoZXZlbnQubW92ZW1lbnRYLCBldmVudC5tb3ZlbWVudFkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlTW92ZScpKFtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZENvb3JkLngsXG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWRDb29yZC55LFxuICAgICAgICAgICAgZGVsdGEueCxcbiAgICAgICAgICAgIGRlbHRhLnlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIG9uTW91c2VXaGVlbChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlV2hlZWwnKShbXG4gICAgICAgICAgICBldmVudC53aGVlbERlbHRhLFxuICAgICAgICAgICAgLy8gV2UgdXNlIHRoZSBzdG9yZSB2YWx1ZSBvZiB0aGlzLmNvb3JkIGFzIG9wcG9zZWQgdG8gdGhlIG1vdXNlRXZlbnQueC95IGFzIHRoZSBtb3VzZUV2ZW50IGxvY2F0aW9uXG4gICAgICAgICAgICAvLyB1c2VzIHRoZSBzeXN0ZW0gY3Vyc29yIGxvY2F0aW9uIHdoaWNoIGhhc24ndCBtb3ZlZFxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkQ29vcmQueCxcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZENvb3JkLnlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIG9uTW91c2VEYmxDbGljayhldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlRG91YmxlJykoW1xuICAgICAgICAgICAgZXZlbnQuYnV0dG9uLFxuICAgICAgICAgICAgLy8gV2UgdXNlIHRoZSBzdG9yZSB2YWx1ZSBvZiB0aGlzLmNvb3JkIGFzIG9wcG9zZWQgdG8gdGhlIG1vdXNlRXZlbnQueC95IGFzIHRoZSBtb3VzZUV2ZW50IGxvY2F0aW9uXG4gICAgICAgICAgICAvLyB1c2VzIHRoZSBzeXN0ZW0gY3Vyc29yIGxvY2F0aW9uIHdoaWNoIGhhc24ndCBtb3ZlZFxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkQ29vcmQueCxcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZENvb3JkLnlcbiAgICAgICAgXSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TW91c2VDb250cm9sbGVyTG9ja2VkLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIFJlZ2lzdGVycyB0aGUgU3BlY2lhbCBLZXkgY29kZXNcbiAqICBNdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIEphdmFTY3JpcHRLZXlDb2RlVG9GS2V5IEMrKyBhcnJheS5cbiAqIFRoZSBpbmRleCBvZiB0aGUgZW50cnkgaW4gdGhlIGFycmF5IGlzIHRoZSBzcGVjaWFsIGtleSBjb2RlIGdpdmVuIGJlbG93LlxuICovXG5leHBvcnQgY2xhc3MgU3BlY2lhbEtleUNvZGVzIHtcbn1cblNwZWNpYWxLZXlDb2Rlcy5iYWNrU3BhY2UgPSA4O1xuU3BlY2lhbEtleUNvZGVzLnNoaWZ0ID0gMTY7XG5TcGVjaWFsS2V5Q29kZXMuY29udHJvbCA9IDE3O1xuU3BlY2lhbEtleUNvZGVzLmFsdCA9IDE4O1xuU3BlY2lhbEtleUNvZGVzLnJpZ2h0U2hpZnQgPSAyNTM7XG5TcGVjaWFsS2V5Q29kZXMucmlnaHRDb250cm9sID0gMjU0O1xuU3BlY2lhbEtleUNvZGVzLnJpZ2h0QWx0ID0gMjU1O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3BlY2lhbEtleUNvZGVzLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG4vKipcbiAqIFRoZSBiYXNpYyB0b3VjaCBjb250cm9sbGVyIHRoYXQgaGFuZGxlcyB0aGUgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRvdWNoQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3Ioc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIsIHZpZGVvUGxheWVyLCBjb29yZGluYXRlQ29udmVydGVyKSB7XG4gICAgICAgIHRoaXMuZmluZ2VycyA9IFs5LCA4LCA3LCA2LCA1LCA0LCAzLCAyLCAxLCAwXTtcbiAgICAgICAgdGhpcy5maW5nZXJJZHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubWF4Qnl0ZVZhbHVlID0gMjU1O1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyID0gc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMudmlkZW9QbGF5ZXIgPSB2aWRlb1BsYXllcjtcbiAgICAgICAgdGhpcy5jb29yZGluYXRlQ29udmVydGVyID0gY29vcmRpbmF0ZUNvbnZlcnRlcjtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQgPSB2aWRlb1BsYXllci5nZXRWaWRlb0VsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5vblRvdWNoU3RhcnRMaXN0ZW5lciA9IHRoaXMub25Ub3VjaFN0YXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Ub3VjaEVuZExpc3RlbmVyID0gdGhpcy5vblRvdWNoRW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Ub3VjaE1vdmVMaXN0ZW5lciA9IHRoaXMub25Ub3VjaE1vdmUuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoKSB7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmRMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmVMaXN0ZW5lcik7XG4gICAgfVxuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmRMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmVMaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlbWVtYmVyVG91Y2godG91Y2gpIHtcbiAgICAgICAgY29uc3QgZmluZ2VyID0gdGhpcy5maW5nZXJzLnBvcCgpO1xuICAgICAgICBpZiAoZmluZ2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdleGhhdXN0ZWQgdG91Y2ggaWRlbnRpZmllcnMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmdlcklkcy5zZXQodG91Y2guaWRlbnRpZmllciwgZmluZ2VyKTtcbiAgICB9XG4gICAgZm9yZ2V0VG91Y2godG91Y2gpIHtcbiAgICAgICAgdGhpcy5maW5nZXJzLnB1c2godGhpcy5maW5nZXJJZHMuZ2V0KHRvdWNoLmlkZW50aWZpZXIpKTtcbiAgICAgICAgLy8gU29ydCBhcnJheSBiYWNrIGludG8gZGVzY2VuZGluZyBvcmRlci4gVGhpcyBtZWFucyBpZiBmaW5nZXIgJzEnIHdlcmUgdG8gbGlmdCBhZnRlciBmaW5nZXIgJzAnLCB3ZSB3b3VsZCBlbnN1cmUgdGhhdCAwIHdpbGwgYmUgdGhlIGZpcnN0IGluZGV4IHRvIHBvcFxuICAgICAgICB0aGlzLmZpbmdlcnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIgLSBhO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5maW5nZXJJZHMuZGVsZXRlKHRvdWNoLmlkZW50aWZpZXIpO1xuICAgIH1cbiAgICBvblRvdWNoU3RhcnQodG91Y2hFdmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIHRoaXMucmVtZW1iZXJUb3VjaCh0b3VjaEV2ZW50LmNoYW5nZWRUb3VjaGVzW3RdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXRUb3VjaERhdGEoJ1RvdWNoU3RhcnQnLCB0b3VjaEV2ZW50LmNoYW5nZWRUb3VjaGVzKTtcbiAgICAgICAgdG91Y2hFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBvblRvdWNoRW5kKHRvdWNoRXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0VG91Y2hEYXRhKCdUb3VjaEVuZCcsIHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXMpO1xuICAgICAgICAvLyBSZS1jeWNsZSB1bmlxdWUgaWRlbnRpZmllcnMgcHJldmlvdXNseSBhc3NpZ25lZCB0byBlYWNoIHRvdWNoLlxuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIHRoaXMuZm9yZ2V0VG91Y2godG91Y2hFdmVudC5jaGFuZ2VkVG91Y2hlc1t0XSk7XG4gICAgICAgIH1cbiAgICAgICAgdG91Y2hFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBvblRvdWNoTW92ZSh0b3VjaEV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdFRvdWNoRGF0YSgnVG91Y2hNb3ZlJywgdG91Y2hFdmVudC50b3VjaGVzKTtcbiAgICAgICAgdG91Y2hFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBlbWl0VG91Y2hEYXRhKHR5cGUsIHRvdWNoZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy52aWRlb1BsYXllci5nZXRWaWRlb1BhcmVudEVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgdG9TdHJlYW1lckhhbmRsZXJzID0gdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnM7XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdG91Y2hlcy5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgY29uc3QgbnVtVG91Y2hlcyA9IDE7IC8vIHRoZSBudW1iZXIgb2YgdG91Y2hlcyB0byBiZSBzZW50IHRoaXMgbWVzc2FnZVxuICAgICAgICAgICAgY29uc3QgdG91Y2ggPSB0b3VjaGVzW3RdO1xuICAgICAgICAgICAgY29uc3QgeCA9IHRvdWNoLmNsaWVudFggLSBvZmZzZXQubGVmdDtcbiAgICAgICAgICAgIGNvbnN0IHkgPSB0b3VjaC5jbGllbnRZIC0gb2Zmc2V0LnRvcDtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKGBGJHt0aGlzLmZpbmdlcklkcy5nZXQodG91Y2guaWRlbnRpZmllcil9PSgke3h9LCAke3l9KWApO1xuICAgICAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoeCwgeSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdUb3VjaFN0YXJ0JzpcbiAgICAgICAgICAgICAgICAgICAgdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnVG91Y2hTdGFydCcpKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVRvdWNoZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmQueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZ2VySWRzLmdldCh0b3VjaC5pZGVudGlmaWVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF4Qnl0ZVZhbHVlICogKHRvdWNoLmZvcmNlID4gMCA/IHRvdWNoLmZvcmNlIDogMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZC5pblJhbmdlID8gMSA6IDBcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RvdWNoRW5kJzpcbiAgICAgICAgICAgICAgICAgICAgdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnVG91Y2hFbmQnKShbXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1Ub3VjaGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmdlcklkcy5nZXQodG91Y2guaWRlbnRpZmllciksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1heEJ5dGVWYWx1ZSAqIHRvdWNoLmZvcmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmQuaW5SYW5nZSA/IDEgOiAwXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUb3VjaE1vdmUnOlxuICAgICAgICAgICAgICAgICAgICB0b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdUb3VjaE1vdmUnKShbXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1Ub3VjaGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmdlcklkcy5nZXQodG91Y2guaWRlbnRpZmllciksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1heEJ5dGVWYWx1ZSAqICh0b3VjaC5mb3JjZSA+IDAgPyB0b3VjaC5mb3JjZSA6IDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmQuaW5SYW5nZSA/IDEgOiAwXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRvdWNoQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTW91c2VCdXR0b24gfSBmcm9tICcuL01vdXNlQnV0dG9ucyc7XG4vKipcbiAqIEFsbG93cyBmb3IgdGhlIHVzYWdlIG9mIGZha2UgdG91Y2ggZXZlbnRzXG4gKi9cbmV4cG9ydCBjbGFzcyBUb3VjaENvbnRyb2xsZXJGYWtlIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJlYW1NZXNzYWdlQ29udHJvbGxlciwgdmlkZW9QbGF5ZXIsIGNvb3JkaW5hdGVDb252ZXJ0ZXIpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlciA9IHN0cmVhbU1lc3NhZ2VDb250cm9sbGVyO1xuICAgICAgICB0aGlzLnZpZGVvUGxheWVyID0gdmlkZW9QbGF5ZXI7XG4gICAgICAgIHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlciA9IGNvb3JkaW5hdGVDb252ZXJ0ZXI7XG4gICAgICAgIHRoaXMub25Ub3VjaFN0YXJ0TGlzdGVuZXIgPSB0aGlzLm9uVG91Y2hTdGFydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uVG91Y2hFbmRMaXN0ZW5lciA9IHRoaXMub25Ub3VjaEVuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uVG91Y2hNb3ZlTGlzdGVuZXIgPSB0aGlzLm9uVG91Y2hNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50UGFyZW50Q2xpZW50UmVjdCA9IHRoaXMudmlkZW9QbGF5ZXIuZ2V0VmlkZW9QYXJlbnRFbGVtZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICAgIHJlZ2lzdGVyKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnRMaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kTGlzdGVuZXIpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlTGlzdGVuZXIpO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnRMaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kTGlzdGVuZXIpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlTGlzdGVuZXIpO1xuICAgIH1cbiAgICBvblRvdWNoU3RhcnQodG91Y2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpIHx8IHRvdWNoLnRhcmdldCAhPT0gdGhpcy52aWRlb1BsYXllci5nZXRWaWRlb0VsZW1lbnQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZha2VUb3VjaEZpbmdlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdF90b3VjaCA9IHRvdWNoLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgdGhpcy5mYWtlVG91Y2hGaW5nZXIgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGZpcnN0X3RvdWNoLmlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgeDogZmlyc3RfdG91Y2guY2xpZW50WCAtIHRoaXMudmlkZW9FbGVtZW50UGFyZW50Q2xpZW50UmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgIHk6IGZpcnN0X3RvdWNoLmNsaWVudFkgLSB0aGlzLnZpZGVvRWxlbWVudFBhcmVudENsaWVudFJlY3QudG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50UGFyZW50ID0gdGhpcy52aWRlb1BsYXllci5nZXRWaWRlb1BhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlRXZlbnQgPSBuZXcgTW91c2VFdmVudCgnbW91c2VlbnRlcicsIGZpcnN0X3RvdWNoKTtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudFBhcmVudC5kaXNwYXRjaEV2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQodGhpcy5mYWtlVG91Y2hGaW5nZXIueCwgdGhpcy5mYWtlVG91Y2hGaW5nZXIueSk7XG4gICAgICAgICAgICBjb25zdCB0b1N0cmVhbWVySGFuZGxlcnMgPSB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycztcbiAgICAgICAgICAgIHRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ01vdXNlRG93bicpKFtNb3VzZUJ1dHRvbi5tYWluQnV0dG9uLCBjb29yZC54LCBjb29yZC55XSk7XG4gICAgICAgIH1cbiAgICAgICAgdG91Y2gucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgb25Ub3VjaEVuZCh0b3VjaEV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSB8fCB0aGlzLmZha2VUb3VjaEZpbmdlciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50UGFyZW50ID0gdGhpcy52aWRlb1BsYXllci5nZXRWaWRlb1BhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgY29uc3QgdG9TdHJlYW1lckhhbmRsZXJzID0gdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnM7XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdG91Y2hFdmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgY29uc3QgdG91Y2ggPSB0b3VjaEV2ZW50LmNoYW5nZWRUb3VjaGVzW3RdO1xuICAgICAgICAgICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMuZmFrZVRvdWNoRmluZ2VyLmlkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHRvdWNoLmNsaWVudFggLSB0aGlzLnZpZGVvRWxlbWVudFBhcmVudENsaWVudFJlY3QubGVmdDtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gdG91Y2guY2xpZW50WSAtIHRoaXMudmlkZW9FbGVtZW50UGFyZW50Q2xpZW50UmVjdC50b3A7XG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoeCwgeSk7XG4gICAgICAgICAgICAgICAgdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VVcCcpKFtNb3VzZUJ1dHRvbi5tYWluQnV0dG9uLCBjb29yZC54LCBjb29yZC55XSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbW91c2VFdmVudCA9IG5ldyBNb3VzZUV2ZW50KCdtb3VzZWxlYXZlJywgdG91Y2gpO1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudFBhcmVudC5kaXNwYXRjaEV2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmFrZVRvdWNoRmluZ2VyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b3VjaEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIG9uVG91Y2hNb3ZlKHRvdWNoRXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpIHx8IHRoaXMuZmFrZVRvdWNoRmluZ2VyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b1N0cmVhbWVySGFuZGxlcnMgPSB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycztcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0b3VjaEV2ZW50LnRvdWNoZXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRvdWNoID0gdG91Y2hFdmVudC50b3VjaGVzW3RdO1xuICAgICAgICAgICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMuZmFrZVRvdWNoRmluZ2VyLmlkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHRvdWNoLmNsaWVudFggLSB0aGlzLnZpZGVvRWxlbWVudFBhcmVudENsaWVudFJlY3QubGVmdDtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gdG91Y2guY2xpZW50WSAtIHRoaXMudmlkZW9FbGVtZW50UGFyZW50Q2xpZW50UmVjdC50b3A7XG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlVW5zaWduZWQoeCwgeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLmNvb3JkaW5hdGVDb252ZXJ0ZXIudHJhbnNsYXRlU2lnbmVkKHggLSB0aGlzLmZha2VUb3VjaEZpbmdlci54LCB5IC0gdGhpcy5mYWtlVG91Y2hGaW5nZXIueSk7XG4gICAgICAgICAgICAgICAgdG9TdHJlYW1lckhhbmRsZXJzLmdldCgnTW91c2VNb3ZlJykoW2Nvb3JkLngsIGNvb3JkLnksIGRlbHRhLngsIGRlbHRhLnldKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZha2VUb3VjaEZpbmdlci54ID0geDtcbiAgICAgICAgICAgICAgICB0aGlzLmZha2VUb3VjaEZpbmdlci55ID0geTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b3VjaEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG91Y2hDb250cm9sbGVyRmFrZS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgZGVlcENvcHlHYW1lcGFkIH0gZnJvbSAnLi9HYW1lcGFkVHlwZXMnO1xuLyoqXG4gKiBUaGUgY2xhc3MgdGhhdCBoYW5kbGVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIFhSIGdhbWVwYWRzIGFuZCBjb250cm9sbGVycy5cbiAqL1xuZXhwb3J0IGNsYXNzIFhSR2FtZXBhZENvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB0b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlciAtIFN0cmVhbSBtZXNzYWdlIGluc3RhbmNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlciA9IHRvU3RyZWFtZXJNZXNzYWdlc1Byb3ZpZGVyO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXJzID0gW107XG4gICAgfVxuICAgIHVwZGF0ZVN0YXR1cyhzb3VyY2UsIGZyYW1lLCByZWZTcGFjZSkge1xuICAgICAgICBpZiAoc291cmNlLmdhbWVwYWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGdhbWVwYWRQb3NlID0gZnJhbWUuZ2V0UG9zZShzb3VyY2UuZ3JpcFNwYWNlLCByZWZTcGFjZSk7XG4gICAgICAgICAgICBpZiAoIWdhbWVwYWRQb3NlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN5c3RlbSA9IDA7XG4gICAgICAgICAgICBpZiAoc291cmNlLnByb2ZpbGVzLmluY2x1ZGVzKCdodGMtdml2ZScpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZS5wcm9maWxlcy5pbmNsdWRlcygnb2N1bHVzLXRvdWNoJykpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETyAod2lsbGlhbS5iZWxjaGVyKTogQWRkIG90aGVyIHByb2ZpbGVzIChRdWVzdCwgTWljcm9zb2Z0IE1peGVkIFJlYWxpdHksIGV0YylcbiAgICAgICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnWFJTeXN0ZW0nKShbc3lzdGVtXSk7XG4gICAgICAgICAgICAvLyBEZWZhdWx0OiBBbnlIYW5kICgyKVxuICAgICAgICAgICAgbGV0IGhhbmRlZG5lc3MgPSAyO1xuICAgICAgICAgICAgc3dpdGNoIChzb3VyY2UuaGFuZGVkbmVzcykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICBoYW5kZWRuZXNzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICBoYW5kZWRuZXNzID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZW5kIGNvbnRyb2xsZXIgdHJhbnNmb3JtXG4gICAgICAgICAgICBjb25zdCBtYXRyaXggPSBnYW1lcGFkUG9zZS50cmFuc2Zvcm0ubWF0cml4O1xuICAgICAgICAgICAgY29uc3QgbWF0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBtYXRbaV0gPSBuZXcgRmxvYXQzMkFycmF5KFttYXRyaXhbaV1dKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdYUkNvbnRyb2xsZXJUcmFuc2Zvcm0nKShbXG4gICAgICAgICAgICAgICAgbWF0WzBdLCBtYXRbNF0sIG1hdFs4XSwgbWF0WzEyXSxcbiAgICAgICAgICAgICAgICBtYXRbMV0sIG1hdFs1XSwgbWF0WzldLCBtYXRbMTNdLFxuICAgICAgICAgICAgICAgIG1hdFsyXSwgbWF0WzZdLCBtYXRbMTBdLCBtYXRbMTRdLFxuICAgICAgICAgICAgICAgIG1hdFszXSwgbWF0WzddLCBtYXRbMTFdLCBtYXRbMTVdLFxuICAgICAgICAgICAgICAgIGhhbmRlZG5lc3NcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gSGFuZGxlIGNvbnRyb2xsZXIgYnV0dG9ucyBhbmQgYXhlc1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbGxlcnNbaGFuZGVkbmVzc10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcnNbaGFuZGVkbmVzc10gPSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZTdGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyc1toYW5kZWRuZXNzXS5wcmV2U3RhdGUgPSBkZWVwQ29weUdhbWVwYWQoc291cmNlLmdhbWVwYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyc1toYW5kZWRuZXNzXS5jdXJyZW50U3RhdGUgPSBkZWVwQ29weUdhbWVwYWQoc291cmNlLmdhbWVwYWQpO1xuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY29udHJvbGxlcnNbaGFuZGVkbmVzc107XG4gICAgICAgICAgICBjb25zdCBjdXJyU3RhdGUgPSBjb250cm9sbGVyLmN1cnJlbnRTdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZTdGF0ZSA9IGNvbnRyb2xsZXIucHJldlN0YXRlO1xuICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGJ1dHRvbnNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyclN0YXRlLmJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyQnV0dG9uID0gY3VyclN0YXRlLmJ1dHRvbnNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkJ1dHRvbiA9IHByZXZTdGF0ZS5idXR0b25zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyQnV0dG9uLnByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJlc3NcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNSZXBlYXQgPSBwcmV2QnV0dG9uLnByZXNzZWQgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNQcm92aWRlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdYUkJ1dHRvblByZXNzZWQnKShbXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kZWRuZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVwZWF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyckJ1dHRvbi52YWx1ZVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJldkJ1dHRvbi5wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnWFJCdXR0b25SZWxlYXNlZCcpKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRlZG5lc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJCdXR0b24udG91Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0b3VjaGVkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVwZWF0ID0gcHJldkJ1dHRvbi50b3VjaGVkID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnWFJCdXR0b25Ub3VjaGVkJykoW1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGVkbmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1JlcGVhdFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJldkJ1dHRvbi50b3VjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnWFJCdXR0b25Ub3VjaFJlbGVhc2VkJykoW1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGVkbmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBnYW1lcGFkIGF4ZXNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyclN0YXRlLmF4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJBeGlzVmFsdWUgPSBjdXJyU3RhdGUuYXhlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2QXhpc1ZhbHVlID0gcHJldlN0YXRlLmF4ZXNbaV07XG4gICAgICAgICAgICAgICAgLy8gT25seSBzZW5kIGF4aXMgdXBkYXRlIGlmIHRoZXJlIGlzIGEgY2hhbmdlXG4gICAgICAgICAgICAgICAgaWYgKGN1ckF4aXNWYWx1ZSAhPSBwcmV2QXhpc1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzUHJvdmlkZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnWFJBbmFsb2cnKShbXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kZWRuZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckF4aXNWYWx1ZVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJzW2hhbmRlZG5lc3NdLnByZXZTdGF0ZSA9IGN1cnJTdGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVhSR2FtZXBhZENvbnRyb2xsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IEluYm91bmRWaWRlb1N0YXRzLCBJbmJvdW5kQXVkaW9TdGF0cyB9IGZyb20gJy4vSW5ib3VuZFJUUFN0YXRzJztcbmltcG9ydCB7IERhdGFDaGFubmVsU3RhdHMgfSBmcm9tICcuL0RhdGFDaGFubmVsU3RhdHMnO1xuaW1wb3J0IHsgQ2FuZGlkYXRlU3RhdCB9IGZyb20gJy4vQ2FuZGlkYXRlU3RhdCc7XG5pbXBvcnQgeyBSZW1vdGVPdXRib3VuZFJUUFN0YXRzLCBPdXRib3VuZFJUUFN0YXRzIH0gZnJvbSAnLi9PdXRCb3VuZFJUUFN0YXRzJztcbmltcG9ydCB7IFNlc3Npb25TdGF0cyB9IGZyb20gJy4vU2Vzc2lvblN0YXRzJztcbmltcG9ydCB7IFN0cmVhbVN0YXRzIH0gZnJvbSAnLi9TdHJlYW1TdGF0cyc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG4vKipcbiAqIFRoZSBBZ2dyZWdhdGVkIFN0YXRzIHRoYXQgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIFJUQyBTdGF0cyBSZXBvcnRcbiAqL1xuZXhwb3J0IGNsYXNzIEFnZ3JlZ2F0ZWRTdGF0cyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaW5ib3VuZFZpZGVvU3RhdHMgPSBuZXcgSW5ib3VuZFZpZGVvU3RhdHMoKTtcbiAgICAgICAgdGhpcy5pbmJvdW5kQXVkaW9TdGF0cyA9IG5ldyBJbmJvdW5kQXVkaW9TdGF0cygpO1xuICAgICAgICB0aGlzLmNhbmRpZGF0ZVBhaXJzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuZGF0YWNoYW5uZWxTdGF0cyA9IG5ldyBEYXRhQ2hhbm5lbFN0YXRzKCk7XG4gICAgICAgIHRoaXMubG9jYWxDYW5kaWRhdGVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMucmVtb3RlQ2FuZGlkYXRlcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLm91dGJvdW5kVmlkZW9TdGF0cyA9IG5ldyBPdXRib3VuZFJUUFN0YXRzKCk7XG4gICAgICAgIHRoaXMub3V0Ym91bmRBdWRpb1N0YXRzID0gbmV3IE91dGJvdW5kUlRQU3RhdHMoKTtcbiAgICAgICAgdGhpcy5yZW1vdGVPdXRib3VuZEF1ZGlvU3RhdHMgPSBuZXcgUmVtb3RlT3V0Ym91bmRSVFBTdGF0cygpO1xuICAgICAgICB0aGlzLnJlbW90ZU91dGJvdW5kVmlkZW9TdGF0cyA9IG5ldyBSZW1vdGVPdXRib3VuZFJUUFN0YXRzKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvblN0YXRzID0gbmV3IFNlc3Npb25TdGF0cygpO1xuICAgICAgICB0aGlzLnN0cmVhbVN0YXRzID0gbmV3IFN0cmVhbVN0YXRzKCk7XG4gICAgICAgIHRoaXMuY29kZWNzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHYXRoZXIgYWxsIHRoZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBSVEMgUGVlciBDb25uZWN0aW9uIFJlcG9ydFxuICAgICAqIEBwYXJhbSBydGNTdGF0c1JlcG9ydCAtIFJUQyBTdGF0cyBSZXBvcnRcbiAgICAgKi9cbiAgICBwcm9jZXNzU3RhdHMocnRjU3RhdHNSZXBvcnQpIHtcbiAgICAgICAgdGhpcy5sb2NhbENhbmRpZGF0ZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5yZW1vdGVDYW5kaWRhdGVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuY2FuZGlkYXRlUGFpcnMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgcnRjU3RhdHNSZXBvcnQuZm9yRWFjaCgoc3RhdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHN0YXQudHlwZTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NhbmRpZGF0ZS1wYWlyJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDYW5kaWRhdGVQYWlyKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjZXJ0aWZpY2F0ZSc6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvZGVjJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDb2RlYyhzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF0YS1jaGFubmVsJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW5ib3VuZC1ydHAnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUluYm91bmRSVFAoc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xvY2FsLWNhbmRpZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTG9jYWxDYW5kaWRhdGUoc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21lZGlhLXNvdXJjZSc6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21lZGlhLXBsYXlvdXQnOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdvdXRib3VuZC1ydHAnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUxvY2FsT3V0Ym91bmQoc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BlZXItY29ubmVjdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JlbW90ZS1jYW5kaWRhdGUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlbW90ZUNhbmRpZGF0ZShzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVtb3RlLWluYm91bmQtcnRwJzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVtb3RlLW91dGJvdW5kLXJ0cCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVtb3RlT3V0Ym91bmQoc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYWNrJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFjayhzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndHJhbnNwb3J0JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFuc3BvcnQoc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmVhbSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU3RyZWFtKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoJ3VuaGFuZGxlZCBTdGF0IFR5cGUnKTtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkluZm8oc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBzdHJlYW0gc3RhdHMgZGF0YSBmcm9tIHdlYnJ0Y1xuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXQgLSB0aGUgc3RhdHMgY29taW5nIGluIGZyb20gd2VicnRjXG4gICAgICovXG4gICAgaGFuZGxlU3RyZWFtKHN0YXQpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1TdGF0cyA9IHN0YXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIEljZSBDYW5kaWRhdGUgUGFpciBEYXRhXG4gICAgICogQHBhcmFtIHN0YXQgLSB0aGUgc3RhdHMgY29taW5nIGluIGZyb20gaWNlIGNhbmRpZGF0ZXNcbiAgICAgKi9cbiAgICBoYW5kbGVDYW5kaWRhdGVQYWlyKHN0YXQpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBjYW5kaWRhdGUgcGFpciB0byB0aGUgY2FuZGlkYXRlIHBhaXIgYXJyYXlcbiAgICAgICAgdGhpcy5jYW5kaWRhdGVQYWlycy5wdXNoKHN0YXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBEYXRhIENoYW5uZWwgRGF0YVxuICAgICAqIEBwYXJhbSBzdGF0IC0gdGhlIHN0YXRzIGNvbWluZyBpbiBmcm9tIHRoZSBkYXRhIGNoYW5uZWxcbiAgICAgKi9cbiAgICBoYW5kbGVEYXRhQ2hhbm5lbChzdGF0KSB7XG4gICAgICAgIHRoaXMuZGF0YWNoYW5uZWxTdGF0cy5ieXRlc1JlY2VpdmVkID0gc3RhdC5ieXRlc1JlY2VpdmVkO1xuICAgICAgICB0aGlzLmRhdGFjaGFubmVsU3RhdHMuYnl0ZXNTZW50ID0gc3RhdC5ieXRlc1NlbnQ7XG4gICAgICAgIHRoaXMuZGF0YWNoYW5uZWxTdGF0cy5kYXRhQ2hhbm5lbElkZW50aWZpZXIgPSBzdGF0LmRhdGFDaGFubmVsSWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbFN0YXRzLmlkID0gc3RhdC5pZDtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbFN0YXRzLmxhYmVsID0gc3RhdC5sYWJlbDtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbFN0YXRzLm1lc3NhZ2VzUmVjZWl2ZWQgPSBzdGF0Lm1lc3NhZ2VzUmVjZWl2ZWQ7XG4gICAgICAgIHRoaXMuZGF0YWNoYW5uZWxTdGF0cy5tZXNzYWdlc1NlbnQgPSBzdGF0Lm1lc3NhZ2VzU2VudDtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbFN0YXRzLnByb3RvY29sID0gc3RhdC5wcm90b2NvbDtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbFN0YXRzLnN0YXRlID0gc3RhdC5zdGF0ZTtcbiAgICAgICAgdGhpcy5kYXRhY2hhbm5lbFN0YXRzLnRpbWVzdGFtcCA9IHN0YXQudGltZXN0YW1wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBMb2NhbCBJY2UgQ2FuZGlkYXRlIERhdGFcbiAgICAgKiBAcGFyYW0gc3RhdCAtIGxvY2FsIHN0YXRzXG4gICAgICovXG4gICAgaGFuZGxlTG9jYWxDYW5kaWRhdGUoc3RhdCkge1xuICAgICAgICBjb25zdCBsb2NhbENhbmRpZGF0ZSA9IG5ldyBDYW5kaWRhdGVTdGF0KCk7XG4gICAgICAgIGxvY2FsQ2FuZGlkYXRlLmxhYmVsID0gJ2xvY2FsLWNhbmRpZGF0ZSc7XG4gICAgICAgIGxvY2FsQ2FuZGlkYXRlLmFkZHJlc3MgPSBzdGF0LmFkZHJlc3M7XG4gICAgICAgIGxvY2FsQ2FuZGlkYXRlLnBvcnQgPSBzdGF0LnBvcnQ7XG4gICAgICAgIGxvY2FsQ2FuZGlkYXRlLnByb3RvY29sID0gc3RhdC5wcm90b2NvbDtcbiAgICAgICAgbG9jYWxDYW5kaWRhdGUuY2FuZGlkYXRlVHlwZSA9IHN0YXQuY2FuZGlkYXRlVHlwZTtcbiAgICAgICAgbG9jYWxDYW5kaWRhdGUuaWQgPSBzdGF0LmlkO1xuICAgICAgICBsb2NhbENhbmRpZGF0ZS5yZWxheVByb3RvY29sID0gc3RhdC5yZWxheVByb3RvY29sO1xuICAgICAgICBsb2NhbENhbmRpZGF0ZS50cmFuc3BvcnRJZCA9IHN0YXQudHJhbnNwb3J0SWQ7XG4gICAgICAgIHRoaXMubG9jYWxDYW5kaWRhdGVzLnB1c2gobG9jYWxDYW5kaWRhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBSZW1vdGUgSWNlIENhbmRpZGF0ZSBEYXRhXG4gICAgICogQHBhcmFtIHN0YXQgLSBpY2UgY2FuZGlkYXRlIHN0YXRzXG4gICAgICovXG4gICAgaGFuZGxlUmVtb3RlQ2FuZGlkYXRlKHN0YXQpIHtcbiAgICAgICAgY29uc3QgcmVtb3RlQ2FuZGlkYXRlID0gbmV3IENhbmRpZGF0ZVN0YXQoKTtcbiAgICAgICAgcmVtb3RlQ2FuZGlkYXRlLmxhYmVsID0gJ3JlbW90ZS1jYW5kaWRhdGUnO1xuICAgICAgICByZW1vdGVDYW5kaWRhdGUuYWRkcmVzcyA9IHN0YXQuYWRkcmVzcztcbiAgICAgICAgcmVtb3RlQ2FuZGlkYXRlLnBvcnQgPSBzdGF0LnBvcnQ7XG4gICAgICAgIHJlbW90ZUNhbmRpZGF0ZS5wcm90b2NvbCA9IHN0YXQucHJvdG9jb2w7XG4gICAgICAgIHJlbW90ZUNhbmRpZGF0ZS5pZCA9IHN0YXQuaWQ7XG4gICAgICAgIHJlbW90ZUNhbmRpZGF0ZS5jYW5kaWRhdGVUeXBlID0gc3RhdC5jYW5kaWRhdGVUeXBlO1xuICAgICAgICByZW1vdGVDYW5kaWRhdGUucmVsYXlQcm90b2NvbCA9IHN0YXQucmVsYXlQcm90b2NvbDtcbiAgICAgICAgcmVtb3RlQ2FuZGlkYXRlLnRyYW5zcG9ydElkID0gc3RhdC50cmFuc3BvcnRJZDtcbiAgICAgICAgdGhpcy5yZW1vdGVDYW5kaWRhdGVzLnB1c2gocmVtb3RlQ2FuZGlkYXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgSW5ib3VuZCBSVFAgQXVkaW8gYW5kIFZpZGVvIERhdGFcbiAgICAgKiBAcGFyYW0gc3RhdCAtIGluYm91bmQgcnRwIHN0YXRzXG4gICAgICovXG4gICAgaGFuZGxlSW5ib3VuZFJUUChzdGF0KSB7XG4gICAgICAgIHN3aXRjaCAoc3RhdC5raW5kKSB7XG4gICAgICAgICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGJpdHJhdGUgYmV0d2VlbiBzdGF0IHVwZGF0ZXNcbiAgICAgICAgICAgICAgICBpZiAoc3RhdC5ieXRlc1JlY2VpdmVkID4gdGhpcy5pbmJvdW5kVmlkZW9TdGF0cy5ieXRlc1JlY2VpdmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHN0YXQudGltZXN0YW1wID4gdGhpcy5pbmJvdW5kVmlkZW9TdGF0cy50aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmJvdW5kVmlkZW9TdGF0cy5iaXRyYXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICg4ICogKHN0YXQuYnl0ZXNSZWNlaXZlZCAtIHRoaXMuaW5ib3VuZFZpZGVvU3RhdHMuYnl0ZXNSZWNlaXZlZCkpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3RhdC50aW1lc3RhbXAgLSB0aGlzLmluYm91bmRWaWRlb1N0YXRzLnRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5ib3VuZFZpZGVvU3RhdHMuYml0cmF0ZSA9IE1hdGguZmxvb3IodGhpcy5pbmJvdW5kVmlkZW9TdGF0cy5iaXRyYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29weSBtZW1iZXJzIGZyb20gc3RhdCBpbnRvIGB0aGlzLmluYm91bmRWaWRlb1N0YXRzYFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHN0YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmJvdW5kVmlkZW9TdGF0c1trZXldID0gc3RhdFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgICAgICAgICAgICBpZiAoc3RhdC5ieXRlc1JlY2VpdmVkID4gdGhpcy5pbmJvdW5kQXVkaW9TdGF0cy5ieXRlc1JlY2VpdmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHN0YXQudGltZXN0YW1wID4gdGhpcy5pbmJvdW5kQXVkaW9TdGF0cy50aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmJvdW5kQXVkaW9TdGF0cy5iaXRyYXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICg4ICogKHN0YXQuYnl0ZXNSZWNlaXZlZCAtIHRoaXMuaW5ib3VuZEF1ZGlvU3RhdHMuYnl0ZXNSZWNlaXZlZCkpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3RhdC50aW1lc3RhbXAgLSB0aGlzLmluYm91bmRBdWRpb1N0YXRzLnRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5ib3VuZEF1ZGlvU3RhdHMuYml0cmF0ZSA9IE1hdGguZmxvb3IodGhpcy5pbmJvdW5kQXVkaW9TdGF0cy5iaXRyYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29weSBtZW1iZXJzIGZyb20gc3RhdCBpbnRvIGB0aGlzLmluYm91bmRBdWRpb1N0YXRzYFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHN0YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmJvdW5kQXVkaW9TdGF0c1trZXldID0gc3RhdFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBLaW5kIHNob3VsZCBiZSBhdWRpbyBvciB2aWRlbywgd2UgZ290ICR7c3RhdC5raW5kfSAtIHRoYXQncyB1bnN1cHBvcnRlZC5gKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBcImxvY2FsXCIgb3V0Ym91bmQgUlRQIEF1ZGlvIGFuZCBWaWRlbyBzdGF0cy5cbiAgICAgKiBAcGFyYW0gc3RhdCAtIGxvY2FsIG91dGJvdW5kIHJ0cCBzdGF0c1xuICAgICAqL1xuICAgIGhhbmRsZUxvY2FsT3V0Ym91bmQoc3RhdCkge1xuICAgICAgICBjb25zdCBsb2NhbE91dGJvdW5kU3RhdHMgPSBzdGF0LmtpbmQgPT09ICdhdWRpbycgPyB0aGlzLm91dGJvdW5kQXVkaW9TdGF0cyA6IHRoaXMub3V0Ym91bmRWaWRlb1N0YXRzO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMuYWN0aXZlID0gc3RhdC5hY3RpdmU7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5jb2RlY0lkID0gc3RhdC5jb2RlY0lkO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMuYnl0ZXNTZW50ID0gc3RhdC5ieXRlc1NlbnQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5mcmFtZUhlaWdodCA9IHN0YXQuZnJhbWVIZWlnaHQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5mcmFtZVdpZHRoID0gc3RhdC5mcmFtZVdpZHRoO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMuZnJhbWVzRW5jb2RlZCA9IHN0YXQuZnJhbWVzRW5jb2RlZDtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLmZyYW1lc1BlclNlY29uZCA9IHN0YXQuZnJhbWVzUGVyU2Vjb25kO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMuaGVhZGVyQnl0ZXNTZW50ID0gc3RhdC5oZWFkZXJCeXRlc1NlbnQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5pZCA9IHN0YXQuaWQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5rZXlGcmFtZXNFbmNvZGVkID0gc3RhdC5rZXlGcmFtZXNFbmNvZGVkO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMua2luZCA9IHN0YXQua2luZDtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLm1lZGlhU291cmNlSWQgPSBzdGF0Lm1lZGlhU291cmNlSWQ7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5taWQgPSBzdGF0Lm1pZDtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLm5hY2tDb3VudCA9IHN0YXQubmFja0NvdW50O1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMucGFja2V0c1NlbnQgPSBzdGF0LnBhY2tldHNTZW50O1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMucXBTdW0gPSBzdGF0LnFwU3VtO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMgPSBzdGF0LnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMucXVhbGl0eUxpbWl0YXRpb25SZWFzb24gPSBzdGF0LnF1YWxpdHlMaW1pdGF0aW9uUmVhc29uO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMucmVtb3RlSWQgPSBzdGF0LnJlbW90ZUlkO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMucmV0cmFuc21pdHRlZEJ5dGVzU2VudCA9IHN0YXQucmV0cmFuc21pdHRlZEJ5dGVzU2VudDtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLnJpZCA9IHN0YXQucmlkO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMuc2NhbGFiaWxpdHlNb2RlID0gc3RhdC5zY2FsYWJpbGl0eU1vZGU7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy5zc3JjID0gc3RhdC5zc3JjO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMudGFyZ2V0Qml0cmF0ZSA9IHN0YXQudGFyZ2V0Qml0cmF0ZTtcbiAgICAgICAgbG9jYWxPdXRib3VuZFN0YXRzLnRpbWVzdGFtcCA9IHN0YXQudGltZXN0YW1wO1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMudG90YWxFbmNvZGVUaW1lID0gc3RhdC50b3RhbEVuY29kZVRpbWU7XG4gICAgICAgIGxvY2FsT3V0Ym91bmRTdGF0cy50b3RhbEVuY29kZUJ5dGVzVGFyZ2V0ID0gc3RhdC50b3RhbEVuY29kZUJ5dGVzVGFyZ2V0O1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMudG90YWxQYWNrZXRTZW5kRGVsYXkgPSBzdGF0LnRvdGFsUGFja2V0U2VuZERlbGF5O1xuICAgICAgICBsb2NhbE91dGJvdW5kU3RhdHMudHJhbnNwb3J0SWQgPSBzdGF0LnRyYW5zcG9ydElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBcInJlbW90ZVwiIG91dGJvdW5kIFJUUCBBdWRpbyBhbmQgVmlkZW8gc3RhdHMuXG4gICAgICogQHBhcmFtIHN0YXQgLSByZW1vdGUgb3V0Ym91bmQgcnRwIHN0YXRzXG4gICAgICovXG4gICAgaGFuZGxlUmVtb3RlT3V0Ym91bmQoc3RhdCkge1xuICAgICAgICBjb25zdCByZW1vdGVPdXRib3VuZFN0YXRzID0gc3RhdC5raW5kID09PSAnYXVkaW8nID8gdGhpcy5yZW1vdGVPdXRib3VuZEF1ZGlvU3RhdHMgOiB0aGlzLnJlbW90ZU91dGJvdW5kVmlkZW9TdGF0cztcbiAgICAgICAgcmVtb3RlT3V0Ym91bmRTdGF0cy5ieXRlc1NlbnQgPSBzdGF0LmJ5dGVzU2VudDtcbiAgICAgICAgcmVtb3RlT3V0Ym91bmRTdGF0cy5jb2RlY0lkID0gc3RhdC5jb2RlY0lkO1xuICAgICAgICByZW1vdGVPdXRib3VuZFN0YXRzLmlkID0gc3RhdC5pZDtcbiAgICAgICAgcmVtb3RlT3V0Ym91bmRTdGF0cy5raW5kID0gc3RhdC5raW5kO1xuICAgICAgICByZW1vdGVPdXRib3VuZFN0YXRzLmxvY2FsSWQgPSBzdGF0LmxvY2FsSWQ7XG4gICAgICAgIHJlbW90ZU91dGJvdW5kU3RhdHMucGFja2V0c1NlbnQgPSBzdGF0LnBhY2tldHNTZW50O1xuICAgICAgICByZW1vdGVPdXRib3VuZFN0YXRzLnJlbW90ZVRpbWVzdGFtcCA9IHN0YXQucmVtb3RlVGltZXN0YW1wO1xuICAgICAgICByZW1vdGVPdXRib3VuZFN0YXRzLnJlcG9ydHNTZW50ID0gc3RhdC5yZXBvcnRzU2VudDtcbiAgICAgICAgcmVtb3RlT3V0Ym91bmRTdGF0cy5yb3VuZFRyaXBUaW1lTWVhc3VyZW1lbnRzID0gc3RhdC5yb3VuZFRyaXBUaW1lTWVhc3VyZW1lbnRzO1xuICAgICAgICByZW1vdGVPdXRib3VuZFN0YXRzLnNzcmMgPSBzdGF0LnNzcmM7XG4gICAgICAgIHJlbW90ZU91dGJvdW5kU3RhdHMudGltZXN0YW1wID0gc3RhdC50aW1lc3RhbXA7XG4gICAgICAgIHJlbW90ZU91dGJvdW5kU3RhdHMudG90YWxSb3VuZFRyaXBUaW1lID0gc3RhdC50b3RhbFJvdW5kVHJpcFRpbWU7XG4gICAgICAgIHJlbW90ZU91dGJvdW5kU3RhdHMudHJhbnNwb3J0SWQgPSBzdGF0LnRyYW5zcG9ydElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBJbmJvdW5kIFZpZGVvIFRyYWNrIERhdGFcbiAgICAgKiBAcGFyYW0gc3RhdCAtIHZpZGVvIHRyYWNrIHN0YXRzXG4gICAgICovXG4gICAgaGFuZGxlVHJhY2soc3RhdCkge1xuICAgICAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gZXh0cmFjdCBzdGF0cyBmcm9tIHRoZSB2aWRlbyB0cmFja1xuICAgICAgICBpZiAoc3RhdC50eXBlID09PSAndHJhY2snICYmIChzdGF0LnRyYWNrSWRlbnRpZmllciA9PT0gJ3ZpZGVvX2xhYmVsJyB8fCBzdGF0LmtpbmQgPT09ICd2aWRlbycpKSB7XG4gICAgICAgICAgICB0aGlzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lc0Ryb3BwZWQgPSBzdGF0LmZyYW1lc0Ryb3BwZWQ7XG4gICAgICAgICAgICB0aGlzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lc1JlY2VpdmVkID0gc3RhdC5mcmFtZXNSZWNlaXZlZDtcbiAgICAgICAgICAgIHRoaXMuaW5ib3VuZFZpZGVvU3RhdHMuZnJhbWVIZWlnaHQgPSBzdGF0LmZyYW1lSGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZVdpZHRoID0gc3RhdC5mcmFtZVdpZHRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVRyYW5zcG9ydChzdGF0KSB7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0U3RhdHMgPSBzdGF0O1xuICAgIH1cbiAgICBoYW5kbGVDb2RlYyhzdGF0KSB7XG4gICAgICAgIGNvbnN0IGNvZGVjSWQgPSBzdGF0LmlkO1xuICAgICAgICB0aGlzLmNvZGVjcy5zZXQoY29kZWNJZCwgc3RhdCk7XG4gICAgfVxuICAgIGhhbmRsZVNlc3Npb25TdGF0aXN0aWNzKHZpZGVvU3RhcnRUaW1lLCBpbnB1dENvbnRyb2xsZXIsIHZpZGVvRW5jb2RlckF2Z1FQKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhVGltZSA9IERhdGUubm93KCkgLSB2aWRlb1N0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5zZXNzaW9uU3RhdHMucnVuVGltZSA9IG5ldyBEYXRlKGRlbHRhVGltZSkudG9JU09TdHJpbmcoKS5zdWJzdHIoMTEsIDgpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xzU3RyZWFtSW5wdXQgPSBpbnB1dENvbnRyb2xsZXIgPT09IG51bGwgPyAnTm90IHNlbnQgeWV0JyA6IGlucHV0Q29udHJvbGxlciA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgICAgIHRoaXMuc2Vzc2lvblN0YXRzLmNvbnRyb2xzU3RyZWFtSW5wdXQgPSBjb250cm9sc1N0cmVhbUlucHV0O1xuICAgICAgICB0aGlzLnNlc3Npb25TdGF0cy52aWRlb0VuY29kZXJBdmdRUCA9IHZpZGVvRW5jb2RlckF2Z1FQO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHZhbHVlIGNvbWluZyBpbiBmcm9tIG91ciBzdGF0cyBpcyBhY3R1YWxseSBhIG51bWJlclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSBudW1iZXIgdG8gYmUgY2hlY2tlZFxuICAgICAqL1xuICAgIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIHJldHVybiB0aGUgYWN0aXZlIGNhbmRpZGF0ZSBwYWlyXG4gICAgICogQHJldHVybnMgVGhlIGNhbmRpZGF0ZSBwYWlyIHRoYXQgaXMgY3VycmVudGx5IHJlY2VpdmluZyBkYXRhXG4gICAgICovXG4gICAgZ2V0QWN0aXZlQ2FuZGlkYXRlUGFpcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlUGFpcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIFJUQ1RyYW5zcG9ydCBzdGF0IGlzIG5vdCB1bmRlZmluZWRcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0U3RhdHMpIHtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY2FuZGlkYXRlIHBhaXIgdGhhdCBtYXRjaGVzIHRoZSB0cmFuc3BvcnQgY2FuZGlkYXRlIHBhaXIgaWRcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkUGFpciA9IHRoaXMuY2FuZGlkYXRlUGFpcnMuZmluZCgoY2FuZGlkYXRlUGFpcikgPT4gY2FuZGlkYXRlUGFpci5pZCA9PT0gdGhpcy50cmFuc3BvcnRTdGF0cy5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRQYWlyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZFBhaXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBgLnNlbGVjdGVkYCBtZW1iZXIgb2YgdGhlIGNhbmRpZGF0ZSBwYWlyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUGFpciA9IHRoaXMuY2FuZGlkYXRlUGFpcnMuZmluZCgoY2FuZGlkYXRlUGFpcikgPT4gY2FuZGlkYXRlUGFpci5zZWxlY3RlZCk7XG4gICAgICAgIGlmIChzZWxlY3RlZFBhaXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRQYWlyO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWdncmVnYXRlZFN0YXRzLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIElDRSBDYW5kaWRhdGUgU3RhdCBjb2xsZWN0ZWQgZnJvbSB0aGUgUlRDIFN0YXRzIFJlcG9ydFxuICovXG5leHBvcnQgY2xhc3MgQ2FuZGlkYXRlU3RhdCB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW5kaWRhdGVTdGF0LmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIERhdGEgQ2hhbm5lbCBTdGF0cyBjb2xsZWN0ZWQgZnJvbSB0aGUgUlRDIFN0YXRzIFJlcG9ydFxuICovXG5leHBvcnQgY2xhc3MgRGF0YUNoYW5uZWxTdGF0cyB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhQ2hhbm5lbFN0YXRzLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIEluYm91bmQgQXVkaW8gU3RhdHMgY29sbGVjdGVkIGZyb20gdGhlIFJUQyBTdGF0cyBSZXBvcnRcbiAqL1xuZXhwb3J0IGNsYXNzIEluYm91bmRBdWRpb1N0YXRzIHtcbn1cbi8qKlxuICogSW5ib3VuZCBWaWRlbyBTdGF0cyBjb2xsZWN0ZWQgZnJvbSB0aGUgUlRDIFN0YXRzIFJlcG9ydFxuICovXG5leHBvcnQgY2xhc3MgSW5ib3VuZFZpZGVvU3RhdHMge1xufVxuLyoqXG4gKiBJbmJvdW5kIFN0YXRzIGNvbGxlY3RlZCBmcm9tIHRoZSBSVEMgU3RhdHMgUmVwb3J0XG4gKi9cbmV4cG9ydCBjbGFzcyBJbmJvdW5kUlRQU3RhdHMge1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5ib3VuZFJUUFN0YXRzLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIFJlcHJlc2VudHMgZWl0aGVyIGE6XG4gKiAtIHN5bmNocm9uaXphdGlvbiBzb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENSdHBSZWNlaXZlci9nZXRTeW5jaHJvbml6YXRpb25Tb3VyY2VzXG4gKiAtIGNvbnRyaWJ1dGluZyBzb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENSdHBSZWNlaXZlci9nZXRDb250cmlidXRpbmdTb3VyY2VzXG4gKiBXaGljaCBhbHNvIChpZiBicm93c2VyIHN1cHBvcnRzIGl0KSBtYXkgb3B0aW9uYWxsIGNvbnRhaW4gZmllbGRzIGZvciBjYXB0dXJlVGltZXN0YW1wICsgc2VuZGVyQ2FwdHVyZVRpbWVPZmZzZXRcbiAqIGlmIHRoZSBhYnMtY2FwdHVyZS10aW1lIFJUUCBoZWFkZXIgZXh0ZW5zaW9uIGlzIGVuYWJsZWQgKGN1cnJlbnRseSB0aGlzIG9ubHkgd29ya3MgaW4gQ2hyb21pdW0gYmFzZWQgYnJvd3NlcnMpLlxuICovXG5jbGFzcyBSVENSdHBDYXB0dXJlU291cmNlIHtcbn1cbi8qKlxuICogRnJhbWVUaW1pbmdJbmZvIGlzIGEgQ2hyb21pdW0tc3BlY2lmaWMgc2V0IG9mIFdlYlJUQyBzdGF0cyB1c2VmdWwgZm9yIGxhdGVuY3kgY2FsY3VsYXRpb24uIEl0IGlzIHN0b3JlZCBpbiBXZWJSVEMgc3RhdHMgYXMgYGdvb2dUaW1pbmdGcmFtZUluZm9gLlxuICogSXQgaXMgZGVmaW5lZCBhcyBhbiBSVFAgaGVhZGVyIGV4dGVuc2lvbiBoZXJlOiBodHRwczovL3dlYnJ0Yy5nb29nbGVzb3VyY2UuY29tL3NyYy8rL3JlZnMvaGVhZHMvbWFpbi9kb2NzL25hdGl2ZS1jb2RlL3J0cC1oZHJleHQvdmlkZW8tdGltaW5nL1JFQURNRS5tZFxuICogSXQgaXMgZGVmaW5lZCBpbiBzb3VyY2UgY29kZSBoZXJlOiBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFpbjp0aGlyZF9wYXJ0eS93ZWJydGMvYXBpL3ZpZGVvL3ZpZGVvX3RpbWluZy5jYztsPTgyO2RyYz04ZDM5OTgxNzI4MmUzYzEyZWQ1NGViMjNlYzQyYTVlNDE4Mjk4ZWM2XG4gKiBJdCBpcyBkaXNjdXNzZWQgYnkgaXRzIGF1dGhvciBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdzNjL3dlYnJ0Yy1wcm92aXNpb25hbC1zdGF0cy9pc3N1ZXMvNDAjaXNzdWVjb21tZW50LTEyNzI5MTY2OTJcbiAqIEluIHN1bW1hcnkgaXQgYSBjb21tYS1kZWxpbWl0ZWQgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIGZvbGxvd2luZyAoaW4gdGhpcyBvcmRlcik6XG4gKiAxKSAgUlRQIHRpbWVzdGFtcDogdGhlIFJUUCB0aW1lc3RhbXAgb2YgdGhlIGZyYW1lXG4gKiAyKSAgQ2FwdHVyZSB0aW1lOiB0aW1lc3RhbXAgd2hlbiB0aGlzIGZyYW1lIHdhcyBjYXB0dXJlZFxuICogMykgIEVuY29kZSBzdGFydDogdGltZXN0YW1wIHdoZW4gdGhpcyBmcmFtZSBzdGFydGVkIHRvIGJlIGVuY29kZWRcbiAqIDQpICBFbmNvZGUgZmluaXNoOiB0aW1lc3RhbXAgd2hlbiB0aGlzIGZyYW1lIGZpbmlzaGVkIGVuY29kaW5nXG4gKiA1KSAgUGFja2V0aXphdGlvbiBmaW5pc2g6IHRpbWVzdGFtcCB3aGVuIHRoaXMgZnJhbWUgd2FzIHNwbGl0IGludG8gcGFja2V0cyBhbmQgd2FzIHJlYWR5IHRvIGJlIHNlbnQgb3ZlciB0aGUgbmV0d29ya1xuICogNikgIFBhY2VyIGV4aXQ6IHRpbWVzdGFtcCB3aGVuIGxhc3QgcGFja2V0IG9mIHRoaXMgZnJhbWUgd2FzIHNlbnQgb3ZlciB0aGUgbmV0d29yayBieSB0aGUgc2VuZGVyIGF0IHRoaXMgdGltZXN0YW1wXG4gKiA3KSAgTmV0d29yayB0aW1lc3RhbXAxOiBwbGFjZSBmb3IgdGhlIFNGVSB0byBtYXJrIHdoZW4gdGhlIGZyYW1lIHN0YXJ0ZWQgYmVpbmcgZm9yd2FyZGVkLiBBcHBsaWNhdGlvbiBzcGVjaWZpYy5cbiAqIDgpICBOZXR3b3JrIHRpbWVzdGFtcDI6IHBsYWNlIGZvciB0aGUgU0ZVIHRvIG1hcmsgd2hlbiB0aGUgZnJhbWUgZmluaXNoZWQgYmVpbmcgZm9yd2FyZGVkLiBBcHBsaWNhdGlvbiBzcGVjaWZpYy5cbiAqIDkpICBSZWNlaXZlIHN0YXJ0OiB0aW1lc3RhbXAgd2hlbiB0aGUgZmlyc3QgcGFja2V0IG9mIHRoaXMgZnJhbWUgd2FzIHJlY2VpdmVkXG4gKiAxMCkgUmVjZWl2ZSBmaW5pc2g6IHRpbWVzdGFtcCB3aGVuIHRoZSBsYXN0IHBhY2tldCBvZiB0aGlzIGZyYW1lIHdhcyByZWNlaXZlZFxuICogMTEpIERlY29kZSBzdGFydDogIHRpbWVzdGFtcCB3aGVuIHRoZSBmcmFtZSB3YXMgcGFzc2VkIHRvIGRlY29kZXJcbiAqIDEyKSBEZWNvZGUgZmluaXNoOiAgdGltZXN0YW1wIHdoZW4gdGhlIGZyYW1lIHdhcyBkZWNvZGVkXG4gKiAxMykgUmVuZGVyIHRpbWU6ICB0aW1lc3RhbXAgb2YgdGhlIHByb2plY3RlZCByZW5kZXIgdGltZSBmb3IgdGhpcyBmcmFtZVxuICogMTQpIFwiaXMgb3V0bGllclwiOiBhIGZsYWcgZm9yIGlmIHRoaXMgZnJhbWUgaXMgYmlnZ2VyIGluIGVuY29kZWQgc2l6ZSB0aGFuIHRoZSBhdmVyYWdlIGZyYW1lIGJ5IGF0IGxlYXN0IDV4LlxuICogMTUpIFwidHJpZ2dlcmVkIGJ5IHRpbWVyXCI6IGEgZmxhZyBmb3IgaWYgdGhpcyByZXBvcnQgd2FzIHRyaWdnZXJlZCBieSB0aGUgdGltZXIgKFRoZSByZXBvcnQgaXMgc2VudCBldmVyeSAyMDBtcylcbiAqL1xuZXhwb3J0IGNsYXNzIEZyYW1lVGltaW5nSW5mbyB7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgYSBjb21iaW5hdGlvbiBvZiBsYXRlbmN5IHN0YXRpc3RpY3MgdXNpbmcgcHVyZWx5IFdlYlJUQyBBUEkuXG4gKi9cbmV4cG9ydCBjbGFzcyBMYXRlbmN5Q2FsY3VsYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qIENsb2NrIG9mZnNldCBiZXR3ZWVuIHBlZXIgY2xvY2tzIGNhbm5vdCBhbHdheXMgYmUgY2FsY3VsYXRlZCBhcyBpdCByZWxpZXMgb2YgbGF0ZXN0IHNlbmRlciByZXBvcnRzLlxuICAgICAgICAgKiBzbyB3ZSBzdG9yZSB0aGUgbGFzdCB0aW1lIHdlIGhhZCBhIHZhbGlkIGNsb2NrIG9mZnNldCBpbiB0aGUgYXNzdW1wdGlvbiB0aGF0IGNsb2NrcyBoYXZlbid0IGRyaWZ0ZWQgdG9vIG11Y2ggc2luY2UgdGhlbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGF0ZXN0U2VuZGVyUmVjdkNsb2NrT2Zmc2V0ID0gbnVsbDtcbiAgICB9XG4gICAgY2FsY3VsYXRlKHN0YXRzLCByZWNlaXZlcnMpIHtcbiAgICAgICAgY29uc3QgbGF0ZW5jeUluZm8gPSBuZXcgTGF0ZW5jeUluZm8oKTtcbiAgICAgICAgY29uc3QgcnR0TVMgPSB0aGlzLmdldFJUVE1zKHN0YXRzKTtcbiAgICAgICAgaWYgKHJ0dE1TICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLnJ0dE1zID0gcnR0TVM7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgc2VuZGVyIGxhdGVuY3kgdXNpbmcgdGhlIGZpcnN0IHZhbGlkIHZpZGVvIHNzcmMvY3NyY1xuICAgICAgICAgICAgY29uc3QgY2FwdHVyZVNvdXJjZSA9IHRoaXMuZ2V0Q2FwdHVyZVNvdXJjZShyZWNlaXZlcnMpO1xuICAgICAgICAgICAgaWYgKGNhcHR1cmVTb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbmRlckxhdGVuY3lNcyA9IHRoaXMuY2FsY3VsYXRlU2VuZGVyTGF0ZW5jeShzdGF0cywgY2FwdHVyZVNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbmRlckxhdGVuY3lNcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsYXRlbmN5SW5mby5zZW5kZXJMYXRlbmN5TXMgPSBzZW5kZXJMYXRlbmN5TXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJydGMtc3RhdHMvI2RvbS1ydGNpbmJvdW5kcnRwc3RyZWFtc3RhdHMtdG90YWxwcm9jZXNzaW5nZGVsYXlcbiAgICAgICAgaWYgKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLnRvdGFsUHJvY2Vzc2luZ0RlbGF5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lc0RlY29kZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGF0ZW5jeUluZm8uYXZlcmFnZVByb2Nlc3NpbmdEZWxheU1zID1cbiAgICAgICAgICAgICAgICAoc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMudG90YWxQcm9jZXNzaW5nRGVsYXkgLyBzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZXNEZWNvZGVkKSAqIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1zdGF0cy8jZG9tLXJ0Y2luYm91bmRydHBzdHJlYW1zdGF0cy1qaXR0ZXJidWZmZXJtaW5pbXVtZGVsYXlcbiAgICAgICAgaWYgKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmppdHRlckJ1ZmZlckRlbGF5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmppdHRlckJ1ZmZlckVtaXR0ZWRDb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYXRlbmN5SW5mby5hdmVyYWdlSml0dGVyQnVmZmVyRGVsYXlNcyA9XG4gICAgICAgICAgICAgICAgKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmppdHRlckJ1ZmZlckRlbGF5IC9cbiAgICAgICAgICAgICAgICAgICAgc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuaml0dGVyQnVmZmVyRW1pdHRlZENvdW50KSAqXG4gICAgICAgICAgICAgICAgICAgIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1zdGF0cy8jZG9tLXJ0Y2luYm91bmRydHBzdHJlYW1zdGF0cy10b3RhbGRlY29kZXRpbWVcbiAgICAgICAgaWYgKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lc0RlY29kZWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMudG90YWxEZWNvZGVUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLmF2ZXJhZ2VEZWNvZGVMYXRlbmN5TXMgPVxuICAgICAgICAgICAgICAgIChzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy50b3RhbERlY29kZVRpbWUgLyBzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZXNEZWNvZGVkKSAqIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1zdGF0cy8jZG9tLXJ0Y2luYm91bmRydHBzdHJlYW1zdGF0cy1mcmFtZXNhc3NlbWJsZWRmcm9tbXVsdGlwbGVwYWNrZXRzXG4gICAgICAgIGlmIChzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy50b3RhbEFzc2VtYmx5VGltZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZXNBc3NlbWJsZWRGcm9tTXVsdGlwbGVQYWNrZXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLmF2ZXJhZ2VBc3NlbWJseURlbGF5TXMgPVxuICAgICAgICAgICAgICAgIChzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy50b3RhbEFzc2VtYmx5VGltZSAvXG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lc0Fzc2VtYmxlZEZyb21NdWx0aXBsZVBhY2tldHMpICpcbiAgICAgICAgICAgICAgICAgICAgMTAwMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRyYWN0IGV4dHJhIENocm9tZS1zcGVjaWZpYyBzdGF0cyBsaWtlIGVuY29kaW5nIGxhdGVuY3lcbiAgICAgICAgaWYgKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmdvb2dUaW1pbmdGcmFtZUluZm8gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuZ29vZ1RpbWluZ0ZyYW1lSW5mby5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsYXRlbmN5SW5mby5mcmFtZVRpbWluZyA9IHRoaXMuZXh0cmFjdEZyYW1lVGltaW5nSW5mbyhzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5nb29nVGltaW5nRnJhbWVJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgRTJFIGxhdGVuY3kgdXNpbmcgdmlkZW8tdGltaW5nIGNhcHR1cmUgdG8gc2VuZCB0aW1lICsgb25lIHdheSBuZXR3b3JrIGxhdGVuY3kgKyByZWNlaXZlci1zaWRlIGxhdGVuY3lcbiAgICAgICAgaWYgKGxhdGVuY3lJbmZvLmZyYW1lVGltaW5nICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLmZyYW1lVGltaW5nLmNhcHR1cmVUb1NlbmRMYXRlbmN5TXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgbGF0ZW5jeUluZm8uYXZlcmFnZVByb2Nlc3NpbmdEZWxheU1zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLnJ0dE1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLmF2ZXJhZ2VFMkVMYXRlbmN5ID1cbiAgICAgICAgICAgICAgICBsYXRlbmN5SW5mby5mcmFtZVRpbWluZy5jYXB0dXJlVG9TZW5kTGF0ZW5jeU1zICtcbiAgICAgICAgICAgICAgICAgICAgbGF0ZW5jeUluZm8ucnR0TXMgKiAwLjUgK1xuICAgICAgICAgICAgICAgICAgICBsYXRlbmN5SW5mby5hdmVyYWdlUHJvY2Vzc2luZ0RlbGF5TXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIEUyRSBsYXRlbmN5IGFzIGFicy1jYXB0dXJlLXRpbWUgY2FwdHVyZSB0byBzZW5kIGxhdGVuY3kgKyBvbmUgd2F5IG5ldHdvcmsgbGF0ZW5jeSArIHJlY2VpdmVyLXNpZGUgbGF0ZW5jeVxuICAgICAgICBpZiAobGF0ZW5jeUluZm8uc2VuZGVyTGF0ZW5jeU1zICE9IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgbGF0ZW5jeUluZm8uYXZlcmFnZVByb2Nlc3NpbmdEZWxheU1zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLnJ0dE1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhdGVuY3lJbmZvLmF2ZXJhZ2VFMkVMYXRlbmN5ID1cbiAgICAgICAgICAgICAgICBsYXRlbmN5SW5mby5zZW5kZXJMYXRlbmN5TXMgKyBsYXRlbmN5SW5mby5ydHRNcyAqIDAuNSArIGxhdGVuY3lJbmZvLmF2ZXJhZ2VQcm9jZXNzaW5nRGVsYXlNcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF0ZW5jeUluZm87XG4gICAgfVxuICAgIGV4dHJhY3RGcmFtZVRpbWluZ0luZm8oZ29vZ1RpbWluZ0ZyYW1lSW5mbykge1xuICAgICAgICBjb25zdCB0aW1pbmdJbmZvID0gbmV3IEZyYW1lVGltaW5nSW5mbygpO1xuICAgICAgICBjb25zdCB0aW1pbmdJbmZvQXJyID0gZ29vZ1RpbWluZ0ZyYW1lSW5mby5zcGxpdCgnLCcpO1xuICAgICAgICAvLyBTaG91bGQgaGF2ZSBleGFjdGx5IDE1IGVsZW1lbnRzIGFjY29yZGluZyB0bzpcbiAgICAgICAgLy8gaHR0cHM6Ly9zb3VyY2UuY2hyb21pdW0ub3JnL2Nocm9taXVtL2Nocm9taXVtL3NyYy8rL21haW46dGhpcmRfcGFydHkvd2VicnRjL2FwaS92aWRlby92aWRlb190aW1pbmcuY2M7bD04MjtkcmM9OGQzOTk4MTcyODJlM2MxMmVkNTRlYjIzZWM0MmE1ZTQxODI5OGVjNlxuICAgICAgICBpZiAodGltaW5nSW5mb0Fyci5sZW5ndGggPT09IDE1KSB7XG4gICAgICAgICAgICB0aW1pbmdJbmZvLnJ0cFRpbWVzdGFtcCA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzBdKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8uY2FwdHVyZVRpbWVzdGFtcCA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzFdKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8uZW5jb2RlU3RhcnRUaW1lc3RhbXAgPSBOdW1iZXIucGFyc2VJbnQodGltaW5nSW5mb0FyclsyXSk7XG4gICAgICAgICAgICB0aW1pbmdJbmZvLmVuY29kZUZpbmlzaFRpbWVzdGFtcCA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzNdKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8ucGFja2V0aXplckZpbmlzaFRpbWVzdGFtcCA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzRdKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8ucGFjZXJFeGl0VGltZXN0YW1wID0gTnVtYmVyLnBhcnNlSW50KHRpbWluZ0luZm9BcnJbNV0pO1xuICAgICAgICAgICAgdGltaW5nSW5mby5uZXR3b3JrVGltZXN0YW1wMSA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzZdKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8ubmV0d29ya1RpbWVzdGFtcDIgPSBOdW1iZXIucGFyc2VJbnQodGltaW5nSW5mb0Fycls3XSk7XG4gICAgICAgICAgICB0aW1pbmdJbmZvLnJlY2VpdmVTdGFydCA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzhdKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8ucmVjZWl2ZUZpbmlzaCA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzldKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8uZGVjb2RlU3RhcnQgPSBOdW1iZXIucGFyc2VJbnQodGltaW5nSW5mb0FyclsxMF0pO1xuICAgICAgICAgICAgdGltaW5nSW5mby5kZWNvZGVGaW5pc2ggPSBOdW1iZXIucGFyc2VJbnQodGltaW5nSW5mb0FyclsxMV0pO1xuICAgICAgICAgICAgdGltaW5nSW5mby5yZW5kZXJUaW1lID0gTnVtYmVyLnBhcnNlSW50KHRpbWluZ0luZm9BcnJbMTJdKTtcbiAgICAgICAgICAgIHRpbWluZ0luZm8uaXNPdXRsaWVyID0gTnVtYmVyLnBhcnNlSW50KHRpbWluZ0luZm9BcnJbMTNdKSA+IDA7XG4gICAgICAgICAgICB0aW1pbmdJbmZvLmlzVHJpZ2dlcmVkQnlUaW1lciA9IE51bWJlci5wYXJzZUludCh0aW1pbmdJbmZvQXJyWzE0XSkgPiAwO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHNvbWUgbGF0ZW5jeSBzdGF0c1xuICAgICAgICAgICAgdGltaW5nSW5mby5lbmNvZGVyTGF0ZW5jeU1zID0gdGltaW5nSW5mby5lbmNvZGVGaW5pc2hUaW1lc3RhbXAgLSB0aW1pbmdJbmZvLmVuY29kZVN0YXJ0VGltZXN0YW1wO1xuICAgICAgICAgICAgdGltaW5nSW5mby5wYWNrZXRpemVMYXRlbmN5TXMgPVxuICAgICAgICAgICAgICAgIHRpbWluZ0luZm8ucGFja2V0aXplckZpbmlzaFRpbWVzdGFtcCAtIHRpbWluZ0luZm8uZW5jb2RlRmluaXNoVGltZXN0YW1wO1xuICAgICAgICAgICAgdGltaW5nSW5mby5wYWNlckxhdGVuY3lNcyA9IHRpbWluZ0luZm8ucGFjZXJFeGl0VGltZXN0YW1wIC0gdGltaW5nSW5mby5wYWNrZXRpemVyRmluaXNoVGltZXN0YW1wO1xuICAgICAgICAgICAgdGltaW5nSW5mby5jYXB0dXJlVG9TZW5kTGF0ZW5jeU1zID0gdGltaW5nSW5mby5wYWNlckV4aXRUaW1lc3RhbXAgLSB0aW1pbmdJbmZvLmNhcHR1cmVUaW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbWluZ0luZm87XG4gICAgfVxuICAgIGNhbGN1bGF0ZVNlbmRlckxhdGVuY3koc3RhdHMsIGNhcHR1cmVTb3VyY2UpIHtcbiAgICAgICAgLy8gVGhlIGNhbGN1bGF0aW9uIHBlcmZvcm1lZCBpbiB0aGlzIGZ1bmN0aW9uIGlzIGFzIHBlciB0aGUgcHJvY2VkdXJlIGRlZmluZWQgaGVyZTpcbiAgICAgICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1leHRlbnNpb25zLyNkb20tcnRjcnRwY29udHJpYnV0aW5nc291cmNlLXNlbmRlcmNhcHR1cmV0aW1lb2Zmc2V0XG4gICAgICAgIC8vIEdldCB0aGUgc2VuZGVyIGNhcHR1cmUgaW4gdGhlIHNlbmRlcidzIGNsb2NrXG4gICAgICAgIGNvbnN0IHNlbmRlckNhcHR1cmVUaW1lc3RhbXAgPSBjYXB0dXJlU291cmNlLmNhcHR1cmVUaW1lc3RhbXAgKyBjYXB0dXJlU291cmNlLnNlbmRlckNhcHR1cmVUaW1lT2Zmc2V0O1xuICAgICAgICBsZXQgc2VuZFJlY3ZDbG9ja09mZnNldCA9IHRoaXMuY2FsY3VsYXRlU2VuZGVyUmVjZWl2ZXJDbG9ja09mZnNldChzdGF0cyk7XG4gICAgICAgIC8vIFVzZSBsYXRlc3QgY2xvY2sgb2Zmc2V0IGlmIHdlIGNvdWxkbid0IGNhbGN1bGF0ZSBvbmUgbm93XG4gICAgICAgIGlmIChzZW5kUmVjdkNsb2NrT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhdGVzdFNlbmRlclJlY3ZDbG9ja09mZnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VuZFJlY3ZDbG9ja09mZnNldCA9IHRoaXMubGF0ZXN0U2VuZGVyUmVjdkNsb2NrT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxhdGVzdFNlbmRlclJlY3ZDbG9ja09mZnNldCA9IHNlbmRSZWN2Q2xvY2tPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBicmluZ3Mgc2VuZGVyIGNsb2NrIHJvdWdobHkgaW5saW5lIHdpdGggcmVjdiBjbG9ja1xuICAgICAgICBjb25zdCByZWN2Q2FwdHVyZVRpbWVzdGFtcE5UUCA9IHNlbmRlckNhcHR1cmVUaW1lc3RhbXAgKyBzZW5kUmVjdkNsb2NrT2Zmc2V0O1xuICAgICAgICAvLyBBcyBkZWZpbmVkIGluIENocm9tZSBzb3VyY2U6IGh0dHBzOi8vY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9leHRlcm5hbC93ZWJydGMvKy9tYXN0ZXIvc3lzdGVtX3dyYXBwZXJzL2luY2x1ZGUvY2xvY2suaCMyNlxuICAgICAgICBjb25zdCBudHAxOTcwID0gMjIwODk4ODgwMDAwMDtcbiAgICAgICAgY29uc3QgcmVjdkNhcHR1cmVUaW1lc3RhbXAgPSByZWN2Q2FwdHVyZVRpbWVzdGFtcE5UUCAtIG50cDE5NzA7XG4gICAgICAgIGNvbnN0IHNlbmRlckxhdGVuY3kgPSBjYXB0dXJlU291cmNlLnRpbWVzdGFtcCAtIHJlY3ZDYXB0dXJlVGltZXN0YW1wO1xuICAgICAgICByZXR1cm4gc2VuZGVyTGF0ZW5jeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgZmlyc3QgdmFsaWQgc3NyYyBvciBjc3JjIHRoYXQgaGFzIGNhcHR1cmUgdGltZSBmaWVsZHMgcHJlc2VudCBmcm9tIGFicy1jYXB0dXJlLXRpbWUgaGVhZGVyIGV4dGVuc2lvbi5cbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXJzIFRoZSBSVFAgcmVjZXZpZXJzIHRoaXMgcGVlciBjb25uZWN0aW9uIGhhcy5cbiAgICAgKiBAcmV0dXJucyBBIHNpbmdsZSB2YWxpZCBzc3JjIG9yIGNzcmMgdGhhdCBoYXMgY2FwdHVyZSB0aW1lIGZpZWxkcyBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUgKGUuZy4gaW4gbm9uLWNocm9taXVtIGJyb3dzZXJzIGl0IHdpbGwgYmUgbnVsbCkuXG4gICAgICovXG4gICAgZ2V0Q2FwdHVyZVNvdXJjZShyZWNlaXZlcnMpIHtcbiAgICAgICAgLy8gV2Ugb25seSB3YW50IHZpZGVvIHJlY2VpdmVyc1xuICAgICAgICByZWNlaXZlcnMgPSByZWNlaXZlcnMuZmlsdGVyKChyZWNlaXZlcikgPT4gcmVjZWl2ZXIudHJhY2sua2luZCA9PT0gJ3ZpZGVvJyk7XG4gICAgICAgIGZvciAoY29uc3QgcmVjZWl2ZXIgb2YgcmVjZWl2ZXJzKSB7XG4gICAgICAgICAgICAvLyBHbyB0aHJvdWdoIGFsbCBzc3JjIGFuZCBjc3JjIHRvIGNoZWNrIGZvciBjYXB0dXJlIHRpbWVzdGFtcFxuICAgICAgICAgICAgLy8gTm90ZTogQ29udmVyc2lvbiB0byBgYW55YCBoZXJlIGlzIGJlY2F1c2UgVFMgZG9lcyBub3QgaGF2ZSBjYXB0dXJlVGltZXN0YW1wIGV0YyBkZWZpbmVkIGluIHRoZSB0eXBlc1xuICAgICAgICAgICAgLy8gdGhlc2UgZmllbGRzIG9ubHkgZXhpc3QgaW4gQ2hyb21pdW0gY3VycmVudGx5LlxuICAgICAgICAgICAgY29uc3Qgc291cmNlcyA9IHJlY2VpdmVyXG4gICAgICAgICAgICAgICAgLmdldFN5bmNocm9uaXphdGlvblNvdXJjZXMoKVxuICAgICAgICAgICAgICAgIC5jb25jYXQocmVjZWl2ZXIuZ2V0Q29udHJpYnV0aW5nU291cmNlcygpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3JjIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3JjLmNhcHR1cmVUaW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBzcmMuc2VuZGVyQ2FwdHVyZVRpbWVPZmZzZXQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBzcmMudGltZXN0YW1wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FwdHVyZVNyYyA9IG5ldyBSVENSdHBDYXB0dXJlU291cmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhcHR1cmVTcmMudGltZXN0YW1wID0gc3JjLnRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgY2FwdHVyZVNyYy5jYXB0dXJlVGltZXN0YW1wID0gc3JjLmNhcHR1cmVUaW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgICAgIGNhcHR1cmVTcmMuc2VuZGVyQ2FwdHVyZVRpbWVPZmZzZXQgPSBzcmMuc2VuZGVyQ2FwdHVyZVRpbWVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYXB0dXJlU3JjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY2FsY3VsYXRlU2VuZGVyUmVjZWl2ZXJDbG9ja09mZnNldChzdGF0cykge1xuICAgICAgICAvLyBUaGUgY2FsY3VsYXRpb24gcGVyZm9ybWVkIGluIHRoaXMgZnVuY3Rpb24gaXMgYXMgcGVyIHRoZSBwcm9jZWR1cmUgZGVmaW5lZCBoZXJlOlxuICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLWV4dGVuc2lvbnMvI2RvbS1ydGNydHBjb250cmlidXRpbmdzb3VyY2Utc2VuZGVyY2FwdHVyZXRpbWVvZmZzZXRcbiAgICAgICAgY29uc3QgaGFzUmVtb3RlT3V0Ym91bmRWaWRlb1N0YXRzID0gc3RhdHMucmVtb3RlT3V0Ym91bmRWaWRlb1N0YXRzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHN0YXRzLnJlbW90ZU91dGJvdW5kVmlkZW9TdGF0cy50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgc3RhdHMucmVtb3RlT3V0Ym91bmRWaWRlb1N0YXRzLnJlbW90ZVRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBOb3RlOiBBcyBvZiBDaHJvbWUgMTMyLCByZW1vdGUtb3V0Ym91bmQtcnRwIHN0YXRzIGZvciB2aWRlbyBhcmUgbm90IHlldCBpbXBsZW1lbnRlZCAoYXVkaW8gd29ya3MpLlxuICAgICAgICAvLyBUaGlzIGNvZGVwYXRoIHNob3VsZCBhY3RpdmF0ZSBvbmNlIHRoZXkgZG8gYmVnaW4gdG8gd29yay5cbiAgICAgICAgaWYgKCFoYXNSZW1vdGVPdXRib3VuZFZpZGVvU3RhdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbW90ZVN0YXRzQXJyaXZlZFRpbWVzdGFtcCA9IHN0YXRzLnJlbW90ZU91dGJvdW5kVmlkZW9TdGF0cy50aW1lc3RhbXA7XG4gICAgICAgIGNvbnN0IHJlbW90ZVN0YXRzU2VudFRpbWVzdGFtcCA9IHN0YXRzLnJlbW90ZU91dGJvdW5kVmlkZW9TdGF0cy5yZW1vdGVUaW1lc3RhbXA7XG4gICAgICAgIGNvbnN0IHJ0dE1zID0gdGhpcy5nZXRSVFRNcyhzdGF0cyk7XG4gICAgICAgIGlmIChyZW1vdGVTdGF0c0Fycml2ZWRUaW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgcmVtb3RlU3RhdHNTZW50VGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHJ0dE1zICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBvbmV3YXlEZWxheSA9IHJ0dE1zICogMC41O1xuICAgICAgICAgICAgcmV0dXJuIHJlbW90ZVN0YXRzQXJyaXZlZFRpbWVzdGFtcCAtIChyZW1vdGVTdGF0c1NlbnRUaW1lc3RhbXAgKyBvbmV3YXlEZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ291bGQgbm90IGdldCBzdGF0cyB0byBjYWxjdWxhdGUgc2VuZGVyL3JlY2VpdmVyIGNsb2NrIG9mZnNldFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJUVE1zKHN0YXRzKSB7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgaXQgZnJvbSB0aGUgYWN0aXZlIGNhbmRpZGF0ZSBwYWlyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUNhbmRpZGF0ZVBhaXIgPSBzdGF0cy5nZXRBY3RpdmVDYW5kaWRhdGVQYWlyKCk7XG4gICAgICAgIGlmICghIWFjdGl2ZUNhbmRpZGF0ZVBhaXIgJiYgYWN0aXZlQ2FuZGlkYXRlUGFpci5jdXJyZW50Um91bmRUcmlwVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJSVFRTZWNvbmRzID0gYWN0aXZlQ2FuZGlkYXRlUGFpci5jdXJyZW50Um91bmRUcmlwVGltZTtcbiAgICAgICAgICAgIHJldHVybiBjdXJSVFRTZWNvbmRzICogMTAwMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZXh0IHRyeSB0byBnZXQgaXQgZnJvbSByZW1vdGUtb3V0Ym91bmQtcnRwIHZpZGVvIHN0YXRzXG4gICAgICAgIGlmICghIXN0YXRzLnJlbW90ZU91dGJvdW5kVmlkZW9TdGF0cyAmJlxuICAgICAgICAgICAgc3RhdHMucmVtb3RlT3V0Ym91bmRWaWRlb1N0YXRzLnRvdGFsUm91bmRUcmlwVGltZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzdGF0cy5yZW1vdGVPdXRib3VuZFZpZGVvU3RhdHMucm91bmRUcmlwVGltZU1lYXN1cmVtZW50cyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzdGF0cy5yZW1vdGVPdXRib3VuZFZpZGVvU3RhdHMucm91bmRUcmlwVGltZU1lYXN1cmVtZW50cyA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGF2Z1J0dFNlY29uZHMgPSBzdGF0cy5yZW1vdGVPdXRib3VuZFZpZGVvU3RhdHMudG90YWxSb3VuZFRyaXBUaW1lIC9cbiAgICAgICAgICAgICAgICBzdGF0cy5yZW1vdGVPdXRib3VuZFZpZGVvU3RhdHMucm91bmRUcmlwVGltZU1lYXN1cmVtZW50cztcbiAgICAgICAgICAgIHJldHVybiBhdmdSdHRTZWNvbmRzICogMTAwMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZXh0IHRyeSB0byBnZXQgaXQgZnJvbSByZW1vdGUtb3V0Ym91bmQtcnRwIGF1ZGlvIHN0YXRzXG4gICAgICAgIGlmICghIXN0YXRzLnJlbW90ZU91dGJvdW5kQXVkaW9TdGF0cyAmJlxuICAgICAgICAgICAgc3RhdHMucmVtb3RlT3V0Ym91bmRBdWRpb1N0YXRzLnRvdGFsUm91bmRUcmlwVGltZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzdGF0cy5yZW1vdGVPdXRib3VuZEF1ZGlvU3RhdHMucm91bmRUcmlwVGltZU1lYXN1cmVtZW50cyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzdGF0cy5yZW1vdGVPdXRib3VuZEF1ZGlvU3RhdHMucm91bmRUcmlwVGltZU1lYXN1cmVtZW50cyA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGF2Z1J0dFNlY29uZHMgPSBzdGF0cy5yZW1vdGVPdXRib3VuZEF1ZGlvU3RhdHMudG90YWxSb3VuZFRyaXBUaW1lIC9cbiAgICAgICAgICAgICAgICBzdGF0cy5yZW1vdGVPdXRib3VuZEF1ZGlvU3RhdHMucm91bmRUcmlwVGltZU1lYXN1cmVtZW50cztcbiAgICAgICAgICAgIHJldHVybiBhdmdSdHRTZWNvbmRzICogMTAwMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBsYXRlbmN5IGluZm9ybWF0aW9uIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIFdlYlJUQyBBUEkuXG4gKiBNb3N0IHN0YXRzIGFyZSBjYWxjdWxhdGVkIGZvbGxvd2luZyB0aGUgc3BlYzpcbiAqIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJydGMtc3RhdHMvI2RpY3Rpb25hcnktcnRjaW5ib3VuZHJ0cHN0cmVhbXN0YXRzLW1lbWJlcnNcbiAqL1xuZXhwb3J0IGNsYXNzIExhdGVuY3lJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHRha2VuIGZyb20gdGhlIG1vbWVudCBhIGZyYW1lIGlzIGRvbmUgY2FwdHVyaW5nIHRvIHRoZSBtb21lbnQgaXQgaXMgc2VudCBvdmVyIHRoZSBuZXR3b3JrLlxuICAgICAgICAgKiBOb3RlOiBUaGlzIGNhbiBvbmx5IGJlIGNhbGN1bGF0ZWQgaWYgYm90aCBvZmZlciBhbmQgYW5zd2VyIGNvbnRhaW4gdGhlXG4gICAgICAgICAqIHRoZSBSVFAgaGVhZGVyIGV4dGVuc2lvbiBmb3IgYHZpZGVvLXRpbWluZ2AgKENocm9tZSBvbmx5IGZvciBub3cpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbmRlckxhdGVuY3lNcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHRha2VuIGZyb20gdGhlIG1vbWVudCBhIGZyYW1lIGlzIGRvbmUgY2FwdHVyaW5nIHRvIHRoZSBtb21lbnQgaXQgaXMgc2VudCBvdmVyIHRoZSBuZXR3b3JrLlxuICAgICAgICAgKiBOb3RlOiBUaGlzIGNhbiBvbmx5IGJlIGNhbGN1bGF0ZWQgaWYgYm90aCBvZmZlciBhbmQgYW5zd2VyIGNvbnRhaW4gdGhlXG4gICAgICAgICAqIHRoZSBSVFAgaGVhZGVyIGV4dGVuc2lvbiBmb3IgYGFicy1jYXB0dXJlLXRpbWVgIChDaHJvbWUgb25seSBmb3Igbm93KVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZW5kZXJMYXRlbmN5QWJzQ2FwdHVyZVRpbWVNcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyogVGhlIHJvdW5kIHRyaXAgdGltZSAobWlsbGlzZWNvbmRzKSBiZXR3ZWVuIGVhY2ggc2VuZGVyLT5yZWNlaXZlci0+c2VuZGVyICovXG4gICAgICAgIHRoaXMucnR0TXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qIEF2ZXJhZ2UgdGltZSB0YWtlbiAobWlsbGlzZWNvbmRzKSBmcm9tIHZpZGVvIHBhY2tldCByZWNlaXB0IHRvIHBvc3QtZGVjb2RlLiAqL1xuICAgICAgICB0aGlzLmF2ZXJhZ2VQcm9jZXNzaW5nRGVsYXlNcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyogQXZlcmFnZSB0aW1lIHRha2VuIChtaWxsaXNlY29uZHMpIGluc2lkZSB0aGUgaml0dGVyIGJ1ZmZlciAod2hpY2ggaXMgcG9zdC1yZWNlaXB0IGJ1dCBwcmUtZGVjb2RlKS4gKi9cbiAgICAgICAgdGhpcy5hdmVyYWdlSml0dGVyQnVmZmVyRGVsYXlNcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyogQXZlcmFnZSB0aW1lIHRha2VuIChtaWxsaXNlY29uZHMpIHRvIGRlY29kZSBhIHZpZGVvIGZyYW1lLiAqL1xuICAgICAgICB0aGlzLmF2ZXJhZ2VEZWNvZGVMYXRlbmN5TXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qIEF2ZXJhZ2UgdGltZSB0YWtlbiAobWlsbGlzZWNvbmRzKSB0byBiZXR3ZWVuIHJlY2VpcHQgb2YgdGhlIGZpcnN0IGFuZCBsYXN0IHZpZGVvIHBhY2tldCBvZiBhLiAqL1xuICAgICAgICB0aGlzLmF2ZXJhZ2VBc3NlbWJseURlbGF5TXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qIFRoZSBzZW5kZXIgbGF0ZW5jeSArIFJUVC8yICsgcHJvY2Vzc2luZyBkZWxheSAqL1xuICAgICAgICB0aGlzLmF2ZXJhZ2VFMkVMYXRlbmN5ID0gdW5kZWZpbmVkO1xuICAgICAgICAvKiBUaW1pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHdvcnN0IHBlcmZvcm1pbmcgZnJhbWUgc2luY2UgdGhlIGxhc3QgZ2V0U3RhdHMgY2FsbCAob25seSB3b3JrcyBvbiBDaHJvbWUpICovXG4gICAgICAgIHRoaXMuZnJhbWVUaW1pbmcgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGF0ZW5jeUNhbGN1bGF0b3IuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogT3V0Ym91bmQgUlRQIHN0YXRzIGNvbGxlY3RlZCBmcm9tIHRoZSBSVEMgU3RhdHMgUmVwb3J0IHVuZGVyIGBvdXRib3VuZC1ydHBgLlxuICogV3JhcHBlciBhcm91bmQ6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENPdXRib3VuZFJ0cFN0cmVhbVN0YXRzXG4gKiBUaGVzZSBhcmUgc3RhdHMgZm9yIHZpZGVvIHdlIGFyZSBzZW5kaW5nIHRvIGEgcmVtb3RlIHBlZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBPdXRib3VuZFJUUFN0YXRzIHtcbn1cbi8qKlxuICogUmVtb3RlIG91dGJvdW5kIHN0YXRzIGNvbGxlY3RlZCBmcm9tIHRoZSBSVEMgU3RhdHMgUmVwb3J0IHVuZGVyIGByZW1vdGUtb3V0Ym91bmQtcnRwYC5cbiAqIFdyYXBwZXIgYXJvdW5kOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUlRDUmVtb3RlT3V0Ym91bmRSdHBTdHJlYW1TdGF0c1xuICogVGhlc2UgYXJlIHN0YXRzIGZvciBtZWRpYSB3ZSBhcmUgcmVjZWl2aW5nIGZyb20gYSByZW1vdGUgcGVlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlbW90ZU91dGJvdW5kUlRQU3RhdHMge1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3V0Qm91bmRSVFBTdGF0cy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG5pbXBvcnQgeyBPcHRpb25QYXJhbWV0ZXJzLCBGbGFncyB9IGZyb20gJy4uL0NvbmZpZy9Db25maWcnO1xuaW1wb3J0IHsgQWdncmVnYXRlZFN0YXRzIH0gZnJvbSAnLi9BZ2dyZWdhdGVkU3RhdHMnO1xuaW1wb3J0IHsgcGFyc2VSdHBQYXJhbWV0ZXJzLCBzcGxpdFNlY3Rpb25zIH0gZnJvbSAnc2RwJztcbmltcG9ydCB7IFJUQ1V0aWxzIH0gZnJvbSAnLi4vVXRpbC9SVENVdGlscyc7XG5pbXBvcnQgeyBTRFBVdGlscyB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42JztcbmltcG9ydCB7IExhdGVuY3lDYWxjdWxhdG9yIH0gZnJvbSAnLi9MYXRlbmN5Q2FsY3VsYXRvcic7XG5leHBvcnQgY29uc3Qga0Fic0NhcHR1cmVUaW1lID0gJ2h0dHA6Ly93d3cud2VicnRjLm9yZy9leHBlcmltZW50cy9ydHAtaGRyZXh0L2Ficy1jYXB0dXJlLXRpbWUnO1xuLyoqXG4gKiBIYW5kbGVzIHRoZSBQZWVyIENvbm5lY3Rpb25cbiAqL1xuZXhwb3J0IGNsYXNzIFBlZXJDb25uZWN0aW9uQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFJUQyBQZWVyIENvbm5lY3Rpb24gY2xpZW50XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQZWVyIGNvbm5lY3Rpb24gT3B0aW9uc1xuICAgICAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlnIGZvciBvdXIgUFMgZXhwZXJpZW5jZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjb25maWcsIHByZWZlcnJlZENvZGVjKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmNyZWF0ZVBlZXJDb25uZWN0aW9uKG9wdGlvbnMsIHByZWZlcnJlZENvZGVjKTtcbiAgICAgICAgdGhpcy5sYXRlbmN5Q2FsY3VsYXRvciA9IG5ldyBMYXRlbmN5Q2FsY3VsYXRvcigpO1xuICAgIH1cbiAgICBjcmVhdGVQZWVyQ29ubmVjdGlvbihvcHRpb25zLCBwcmVmZXJyZWRDb2RlYykge1xuICAgICAgICAvLyBTZXQgdGhlIElDRSB0cmFuc3BvcnQgdG8gcmVsYXkgaWYgVFVSTiBlbmFibGVkXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkZvcmNlVFVSTikpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaWNlVHJhbnNwb3J0UG9saWN5ID0gJ3JlbGF5JztcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdGb3JjaW5nIFRVUk4gdXNhZ2UgYnkgc2V0dGluZyBJQ0UgVHJhbnNwb3J0IFBvbGljeSBpbiBwZWVyIGNvbm5lY3Rpb24gY29uZmlnLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1aWxkIGEgbmV3IHBlZXIgY29ubmVjdGlvbiB3aXRoIHRoZSBvcHRpb25zXG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24gPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24ob3B0aW9ucyk7XG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IChldikgPT4gdGhpcy5oYW5kbGVTaWduYWxTdGF0ZUNoYW5nZShldik7XG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoZXYpID0+IHRoaXMuaGFuZGxlSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKGV2KTtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlID0gKGV2KSA9PiB0aGlzLmhhbmRsZUljZUdhdGhlcmluZ1N0YXRlQ2hhbmdlKGV2KTtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbnRyYWNrID0gKGV2KSA9PiB0aGlzLmhhbmRsZU9uVHJhY2soZXYpO1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gKGV2KSA9PiB0aGlzLmhhbmRsZUljZUNhbmRpZGF0ZShldik7XG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25kYXRhY2hhbm5lbCA9IChldikgPT4gdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbChldik7XG4gICAgICAgIHRoaXMuYWdncmVnYXRlZFN0YXRzID0gbmV3IEFnZ3JlZ2F0ZWRTdGF0cygpO1xuICAgICAgICB0aGlzLnByZWZlcnJlZENvZGVjID0gcHJlZmVycmVkQ29kZWM7XG4gICAgICAgIHRoaXMudXBkYXRlQ29kZWNTZWxlY3Rpb24gPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gb2ZmZXIgZm9yIHRoZSBXZWIgUlRDIGhhbmRzaGFrZSBhbmQgc2VuZCB0aGUgb2ZmZXIgdG8gdGhlIHNpZ25hbGluZyBzZXJ2ZXIgdmlhIHdlYnNvY2tldFxuICAgICAqIEBwYXJhbSBvZmZlck9wdGlvbnMgLSBSVEMgT2ZmZXIgT3B0aW9uc1xuICAgICAqL1xuICAgIGNyZWF0ZU9mZmVyKG9mZmVyT3B0aW9ucywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnQ3JlYXRlIE9mZmVyJyk7XG4gICAgICAgICAgICBjb25zdCBpc0xvY2FsaG9zdENvbm5lY3Rpb24gPSBsb2NhdGlvbi5ob3N0bmFtZSA9PT0gJ2xvY2FsaG9zdCcgfHwgbG9jYXRpb24uaG9zdG5hbWUgPT09ICcxMjcuMC4wLjEnO1xuICAgICAgICAgICAgY29uc3QgaXNIdHRwc0Nvbm5lY3Rpb24gPSBsb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gICAgICAgICAgICBsZXQgdXNlTWljID0gY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuVXNlTWljKTtcbiAgICAgICAgICAgIGxldCB1c2VDYW1lcmEgPSBjb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5Vc2VDYW1lcmEpO1xuICAgICAgICAgICAgaWYgKCh1c2VNaWMgfHwgdXNlQ2FtZXJhKSAmJiAhKGlzTG9jYWxob3N0Q29ubmVjdGlvbiB8fCBpc0h0dHBzQ29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB1c2VNaWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB1c2VDYW1lcmEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoJ01pY3JvcGhvbmUgYW5kIFdlYmNhbSBhY2Nlc3MgaW4gdGhlIGJyb3dzZXIgd2lsbCBub3Qgd29yayBpZiB5b3UgYXJlIG5vdCBvbiBIVFRQUyBvciBsb2NhbGhvc3QuIERpc2FibGluZyBtaWMgYW5kIHdlYmNhbSBhY2Nlc3MuJyk7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKFwiRm9yIHRlc3RpbmcgeW91IGNhbiBlbmFibGUgSFRUUCBtaWNyb3Bob25lIGFjY2VzcyBDaHJvbWUgYnkgdmlzaXRpbmcgY2hyb21lOi8vZmxhZ3MvIGFuZCBlbmFibGluZyAndW5zYWZlbHktdHJlYXQtaW5zZWN1cmUtb3JpZ2luLWFzLXNlY3VyZSdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldHVwVHJhbnNjZWl2ZXJzQXN5bmModXNlTWljLCB1c2VDYW1lcmEpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3JlYXRlT2ZmZXIob2ZmZXJPcHRpb25zKS50aGVuKChvZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1RleHRPdmVybGF5Q29ubmVjdGluZygpO1xuICAgICAgICAgICAgICAgICAgICBvZmZlci5zZHAgPSB0aGlzLm11bmdlU0RQKG9mZmVyLnNkcCwgdXNlTWljKTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2VuZFdlYlJUQ09mZmVyKG9mZmVyKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1RleHRPdmVybGF5U2V0dXBGYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY2VpdmUgb2ZmZXIgZnJvbSBVRSBzaWRlIGFuZCBwcm9jZXNzIGl0IGFzIHRoZSByZW1vdGUgZGVzY3JpcHRpb24gb2YgdGhpcyBwZWVyIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICByZWNlaXZlT2ZmZXIob2ZmZXIsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ1JlY2VpdmUgT2ZmZXInKTtcbiAgICAgICAgICAgIC8vIElmIFVFIG9yIEpTU3RyZWFtZXIgZGlkIHNlbmQgYWJzLWNhcHR1cmUtdGltZSBSVFAgaGVhZGVyIGV4dGVuc2lvbiB0byBhIG5vbi1DaHJvbWUgYnJvd3NlclxuICAgICAgICAgICAgLy8gdGhlbiByZW1vdmUgaXQgZnJvbSB0aGUgU0RQIGJlY2F1c2UgaWYgRmlyZWZveCBkZXRlY3RzIGl0IGluIG9mZmVyIG9yIGFuc3dlciBpdCB3aWxsIGZhaWwgdG8gY29ubmVjdFxuICAgICAgICAgICAgLy8gZHVlIGhhdmluZyAxNSBvciBtb3JlIGhlYWRlciBleHRlbnNpb25zOiBodHRwczovL21haWxhcmNoaXZlLmlldGYub3JnL2FyY2gvbXNnL3J0Y3dlYi9RUm5XTnVXekd1TFJvdldkSGtvZE5QNlZPZ2cvXG4gICAgICAgICAgICBpZiAodGhpcy5pc0ZpcmVmb3goKSkge1xuICAgICAgICAgICAgICAgIC8vIGV4YW1wbGU6IGE9ZXh0bWFwOjE1IGh0dHA6Ly93d3cud2VicnRjLm9yZy9leHBlcmltZW50cy9ydHAtaGRyZXh0L2Ficy1jYXB0dXJlLXRpbWVcbiAgICAgICAgICAgICAgICBvZmZlci5zZHAgPSBvZmZlci5zZHAucmVwbGFjZSgvXmE9ZXh0bWFwOlxcZCsgaHR0cDpcXC9cXC93d3dcXC53ZWJydGNcXC5vcmdcXC9leHBlcmltZW50c1xcL3J0cC1oZHJleHRcXC9hYnMtY2FwdHVyZS10aW1lXFxyXFxuL2dtLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEZpcmUgZXZlbnQgZm9yIHdoZW4gcmVtb3RlIG9mZmVyIGRlc2NyaXB0aW9uIGlzIHNldFxuICAgICAgICAgICAgICAgIHRoaXMub25TZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNMb2NhbGhvc3RDb25uZWN0aW9uID0gbG9jYXRpb24uaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnIHx8IGxvY2F0aW9uLmhvc3RuYW1lID09PSAnMTI3LjAuMC4xJztcbiAgICAgICAgICAgICAgICBjb25zdCBpc0h0dHBzQ29ubmVjdGlvbiA9IGxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgICAgICAgICAgICAgICBsZXQgdXNlTWljID0gY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuVXNlTWljKTtcbiAgICAgICAgICAgICAgICBsZXQgdXNlQ2FtZXJhID0gY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuVXNlQ2FtZXJhKTtcbiAgICAgICAgICAgICAgICBpZiAoKHVzZU1pYyB8fCB1c2VDYW1lcmEpICYmICEoaXNMb2NhbGhvc3RDb25uZWN0aW9uIHx8IGlzSHR0cHNDb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICB1c2VNaWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdXNlQ2FtZXJhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcignTWljcm9waG9uZSBhbmQgV2ViY2FtIGFjY2VzcyBpbiB0aGUgYnJvd3NlciB3aWxsIG5vdCB3b3JrIGlmIHlvdSBhcmUgbm90IG9uIEhUVFBTIG9yIGxvY2FsaG9zdC4gRGlzYWJsaW5nIG1pYyBhbmQgd2ViY2FtIGFjY2Vzcy4nKTtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKFwiRm9yIHRlc3RpbmcgeW91IGNhbiBlbmFibGUgSFRUUCBtaWNyb3Bob25lIGFjY2VzcyBDaHJvbWUgYnkgdmlzaXRpbmcgY2hyb21lOi8vZmxhZ3MvIGFuZCBlbmFibGluZyAndW5zYWZlbHktdHJlYXQtaW5zZWN1cmUtb3JpZ2luLWFzLXNlY3VyZSdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCBvdXIgbGlzdCBvZiBwcmVmZXJyZWQgY29kZWNzLCBpbiBvcmRlciBvZiBwcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0T3B0aW9uU2V0dGluZ09wdGlvbnMoT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRDb2RlYywgdGhpcy5mdXp6eUludGVyc2VjdFVFQW5kQnJvd3NlckNvZGVjcyhvZmZlcikpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBUcmFuc2NlaXZlcnNBc3luYyh1c2VNaWMsIHVzZUNhbWVyYSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNyZWF0ZUFuc3dlcigpLnRoZW4oKEFuc3dlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgQW5zd2VyLnNkcCA9IHRoaXMubXVuZ2VTRFAoQW5zd2VyLnNkcCwgdXNlTWljKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0TG9jYWxEZXNjcmlwdGlvbihBbnN3ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25TZXRMb2NhbERlc2NyaXB0aW9uKChfYSA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbERlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBjcmVhdGVBbnN3ZXIoKSBmYWlsZWQgLSAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgUmVtb3RlIERlc2NyaXB0b3IgZnJvbSB0aGUgc2lnbmFsaW5nIHNlcnZlciB0byB0aGUgUlRDIFBlZXIgQ29ubmVjdGlvblxuICAgICAqIEBwYXJhbSBhbnN3ZXIgLSBSVEMgU2Vzc2lvbiBEZXNjcmlwdG9yIGZyb20gdGhlIFNpZ25hbGluZyBTZXJ2ZXJcbiAgICAgKi9cbiAgICByZWNlaXZlQW5zd2VyKGFuc3dlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAvLyBBZGQgb3VyIGxpc3Qgb2YgcHJlZmVycmVkIGNvZGVjcywgaW4gb3JkZXIgb2YgcHJlZmVyZW5jZVxuICAgICAgICB0aGlzLmNvbmZpZy5zZXRPcHRpb25TZXR0aW5nT3B0aW9ucyhPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZENvZGVjLCB0aGlzLmZ1enp5SW50ZXJzZWN0VUVBbmRCcm93c2VyQ29kZWNzKGFuc3dlcikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBBZ2dyZWdhdGVkIFN0YXRzIGFuZCB0aGVuIGZpcmUgYSBvblZpZGVvIFN0YXRzIGV2ZW50XG4gICAgICovXG4gICAgZ2VuZXJhdGVTdGF0cygpIHtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5nZXRTdGF0cygpLnRoZW4oKHN0YXRzRGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZ2dyZWdhdGVkU3RhdHMucHJvY2Vzc1N0YXRzKHN0YXRzRGF0YSk7XG4gICAgICAgICAgICB0aGlzLm9uVmlkZW9TdGF0cyh0aGlzLmFnZ3JlZ2F0ZWRTdGF0cyk7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgbGF0ZW5jeSB1c2luZyBzdGF0cyBhbmQgdmlkZW8gcmVjZWl2ZXJzIGFuZCB0aGVuIGNhbGwgdGhlIGhhbmRsaW5nIGZ1bmN0aW9uXG4gICAgICAgICAgICBjb25zdCBsYXRlbmN5SW5mbyA9IHRoaXMubGF0ZW5jeUNhbGN1bGF0b3IuY2FsY3VsYXRlKHRoaXMuYWdncmVnYXRlZFN0YXRzLCB0aGlzLnBlZXJDb25uZWN0aW9uLmdldFJlY2VpdmVycygpKTtcbiAgICAgICAgICAgIHRoaXMub25MYXRlbmN5Q2FsY3VsYXRlZChsYXRlbmN5SW5mbyk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByZWZlcnJlZCBjb2RlYyBzZWxlY3Rpb24gYmFzZWQgb24gd2hhdCB3YXMgYWN0dWFsbHkgbmVnb3RpYXRlZFxuICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlQ29kZWNTZWxlY3Rpb24gJiYgISF0aGlzLmFnZ3JlZ2F0ZWRTdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5jb2RlY0lkKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBxdWFsaWZpZWQgY29kZWMgbmFtZSBmcm9tIHRoZSBtaW1ldHlwZSBhbmQgZm10cFxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVjU3RhdHMgPSB0aGlzLmFnZ3JlZ2F0ZWRTdGF0cy5jb2RlY3MuZ2V0KHRoaXMuYWdncmVnYXRlZFN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmNvZGVjSWQpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlY1N0YXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlY1Nob3J0bmFtZSA9IGNvZGVjU3RhdHMubWltZVR5cGUucmVwbGFjZSgndmlkZW8vJywgJycpO1xuICAgICAgICAgICAgICAgIGxldCBmdWxsQ29kZWNOYW1lID0gY29kZWNTaG9ydG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVjU3RhdHMuc2RwRm10cExpbmUgJiYgY29kZWNTdGF0cy5zZHBGbXRwTGluZS50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxDb2RlY05hbWUgPSBgJHtjb2RlY1Nob3J0bmFtZX0gJHtjb2RlY1N0YXRzLnNkcEZtdHBMaW5lLnRyaW0oKX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhbGxCcm93c2VyQ29kZWNzID0gdGhpcy5jb25maWcuZ2V0U2V0dGluZ09wdGlvbihPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZENvZGVjKS5vcHRpb25zO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBsaXN0IG9mIGNvZGVjcyBkaXJlY3RseSBjb250YWlucyB0aGUgb25lIHRoYXQgd2FzIG5lZ290aWF0ZWQsIHNlbGVjdCB0aGF0XG4gICAgICAgICAgICAgICAgaWYgKGFsbEJyb3dzZXJDb2RlY3MuaW5jbHVkZXMoZnVsbENvZGVjTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0T3B0aW9uU2V0dGluZ1ZhbHVlKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkQ29kZWMsIGZ1bGxDb2RlY05hbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkbid0IG1hdGNoIG9uIHRoZSBmdWxsIG5hbWUsIHRyeSB0byBtYXRjaCBvbiBqdXN0IHRoZSBjb2RlYyBzaG9ydG5hbWVcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZExpc3QgPSBhbGxCcm93c2VyQ29kZWNzLmZpbHRlcigob3B0aW9uKSA9PiBvcHRpb24uaW5kZXhPZihjb2RlY1Nob3J0bmFtZSkgIT09IC0xKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWRMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0T3B0aW9uU2V0dGluZ1ZhbHVlKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkQ29kZWMsIGZpbHRlcmVkTGlzdFswXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSBUaGUgUGVlciBDb25uZWN0aW9uXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgdGhlIFNlc3Npb24gRGVzY3JpcHRvclxuICAgICAqIEBwYXJhbSBzZHAgLSBTZXNzaW9uIERlc2NyaXB0b3IgYXMgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gdXNlTWljIC0gSXMgdGhlIG1pY3JvcGhvbmUgaW4gdXNlXG4gICAgICogQHJldHVybnMgQSBtb2RpZmllZCBTZXNzaW9uIERlc2NyaXB0b3JcbiAgICAgKi9cbiAgICBtdW5nZVNEUChzZHAsIHVzZU1pYykge1xuICAgICAgICBsZXQgbXVuZ2VkU0RQID0gc2RwLnJlcGxhY2UoLyhhPWZtdHA6XFxkKyAuKmxldmVsLWFzeW1tZXRyeS1hbGxvd2VkPS4qKVxcclxcbi9nbSwgJyQxO3gtZ29vZ2xlLXN0YXJ0LWJpdHJhdGU9MTAwMDA7eC1nb29nbGUtbWF4LWJpdHJhdGU9MTAwMDAwXFxyXFxuJyk7XG4gICAgICAgIC8vIHNldCBtYXggYml0cmF0ZSB0byBoaWdoZXN0IGJpdHJhdGUgT3B1cyBzdXBwb3J0c1xuICAgICAgICBsZXQgYXVkaW9TRFAgPSAnbWF4YXZlcmFnZWJpdHJhdGU9NTEwMDAwOyc7XG4gICAgICAgIGlmICh1c2VNaWMpIHtcbiAgICAgICAgICAgIC8vIHNldCB0aGUgbWF4IGNhcHR1cmUgcmF0ZSB0byA0OGtoeiAoc28gd2UgY2FuIHNlbmQgaGlnaCBxdWFsaXR5IGF1ZGlvIGZyb20gbWljKVxuICAgICAgICAgICAgYXVkaW9TRFAgKz0gJ3Nwcm9wLW1heGNhcHR1cmVyYXRlPTQ4MDAwOyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yY2UgbW9ubyBvciBzdGVyZW8gYmFzZWQgb24gd2hldGhlciA/Zm9yY2VNb25vIHdhcyBwYXNzZWQgb3Igbm90XG4gICAgICAgIGF1ZGlvU0RQICs9IHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuRm9yY2VNb25vQXVkaW8pID8gJ3N0ZXJlbz0wOycgOiAnc3RlcmVvPTE7JztcbiAgICAgICAgLy8gZW5hYmxlIGluLWJhbmQgZm9yd2FyZCBlcnJvciBjb3JyZWN0aW9uIGZvciBvcHVzIGF1ZGlvXG4gICAgICAgIGF1ZGlvU0RQICs9ICd1c2VpbmJhbmRmZWM9MSc7XG4gICAgICAgIC8vIFdlIHVzZSB0aGUgbGluZSAndXNlaW5iYW5kZmVjPTEnICh3aGljaCBPcHVzIHVzZXMpIHRvIHNldCBvdXIgT3B1cyBzcGVjaWZpYyBhdWRpbyBwYXJhbWV0ZXJzLlxuICAgICAgICBtdW5nZWRTRFAgPSBtdW5nZWRTRFAucmVwbGFjZSgndXNlaW5iYW5kZmVjPTEnLCBhdWRpb1NEUCk7XG4gICAgICAgIC8vIEFkZCBhYnMtY2FwdHVyZS10aW1lIFJUUCBoZWFkZXIgZXh0ZW5zaW9uIGlmIHdlIGhhdmUgZW5hYmxlZCB0aGUgc2V0dGluZy5cbiAgICAgICAgLy8gTm90ZTogQXMgYXQgRmViIDIwMjUsIENocm9taXVtIGJhc2VkIGJyb3dzZXJzIGFyZSB0aGUgb25seSBvbmVzIHRoYXQgc3VwcG9ydCB0aGlzIGFuZFxuICAgICAgICAvLyBtdW5naW5nIGl0IGludG8gdGhlIGFuc3dlciBpbiBGaXJlZm94IHdpbGwgY2F1c2UgdGhlIGNvbm5lY3Rpb24gdG8gZmFpbC5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuRW5hYmxlQ2FwdHVyZVRpbWVFeHQpICYmICF0aGlzLmlzRmlyZWZveCgpKSB7XG4gICAgICAgICAgICBtdW5nZWRTRFAgPSBTRFBVdGlscy5hZGRWaWRlb0hlYWRlckV4dGVuc2lvblRvU2RwKG11bmdlZFNEUCwga0Fic0NhcHR1cmVUaW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXVuZ2VkU0RQO1xuICAgIH1cbiAgICBpc0ZpcmVmb3goKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gYSBJY2UgQ2FuZGlkYXRlIGlzIHJlY2VpdmVkIGFkZCB0byB0aGUgUlRDIFBlZXIgQ29ubmVjdGlvblxuICAgICAqIEBwYXJhbSBpY2VDYW5kaWRhdGUgLSBSVEMgSWNlIENhbmRpZGF0ZSBmcm9tIHRoZSBTaWduYWxpbmcgU2VydmVyXG4gICAgICovXG4gICAgaGFuZGxlT25JY2UoaWNlQ2FuZGlkYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ3BlZXJjb25uZWN0aW9uIGhhbmRsZU9uSWNlJyk7XG4gICAgICAgIC8vIC8vIGlmIGZvcmNpbmcgVFVSTiwgcmVqZWN0IGFueSBjYW5kaWRhdGVzIG5vdCByZWxheVxuICAgICAgICBpZiAodGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5Gb3JjZVRVUk4pKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBubyByZWxheSBhZGRyZXNzIGlzIGZvdW5kLCBpZiBzbywgd2UgYXJlIGFzc3VtaW5nIGl0IG1lYW5zIG5vIFRVUk4gc2VydmVyXG4gICAgICAgICAgICBpZiAoaWNlQ2FuZGlkYXRlLmNhbmRpZGF0ZS5pbmRleE9mKCdyZWxheScpIDwgMCkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5JbmZvKGBEcm9wcGluZyBjYW5kaWRhdGUgYmVjYXVzZSBpdCB3YXMgbm90IFRVUk4gcmVsYXkuIHwgVHlwZT0gJHtpY2VDYW5kaWRhdGUudHlwZX0gfCBQcm90b2NvbD0gJHtpY2VDYW5kaWRhdGUucHJvdG9jb2x9IHwgQWRkcmVzcz0ke2ljZUNhbmRpZGF0ZS5hZGRyZXNzfSB8IFBvcnQ9JHtpY2VDYW5kaWRhdGUucG9ydH0gfGApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkSWNlQ2FuZGlkYXRlKGljZUNhbmRpZGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIFJUQyBQZWVyIENvbm5lY3Rpb24gU2lnbmFsaW5nIHNlcnZlciBzdGF0ZSBDaGFuZ2VzXG4gICAgICogQHBhcmFtIHN0YXRlIC0gU2lnbmFsaW5nIFNlcnZlciBTdGF0ZSBDaGFuZ2UgRXZlbnRcbiAgICAgKi9cbiAgICBoYW5kbGVTaWduYWxTdGF0ZUNoYW5nZShzdGF0ZSkge1xuICAgICAgICBMb2dnZXIuSW5mbygnc2lnbmFsaW5nIHN0YXRlIGNoYW5nZTogJyArIHN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHdoZW4gdGhlIEljZSBDb25uZWN0aW9uIFN0YXRlIENoYW5nZXNcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJY2UgQ29ubmVjdGlvbiBTdGF0ZVxuICAgICAqL1xuICAgIGhhbmRsZUljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZShzdGF0ZSkge1xuICAgICAgICBMb2dnZXIuSW5mbygnaWNlIGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlOiAnICsgc3RhdGUpO1xuICAgICAgICB0aGlzLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHdoZW4gdGhlIEljZSBHYXRoZXJpbmcgU3RhdGUgQ2hhbmdlc1xuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEljZSBHYXRoZXJpbmcgU3RhdGUgQ2hhbmdlXG4gICAgICovXG4gICAgaGFuZGxlSWNlR2F0aGVyaW5nU3RhdGVDaGFuZ2Uoc3RhdGUpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ2ljZSBnYXRoZXJpbmcgc3RhdGUgY2hhbmdlOiAnICsgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIHRoZSBvblRyYWNrIG1ldGhvZFxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSB3ZWJSdGMgdHJhY2sgZXZlbnRcbiAgICAgKi9cbiAgICBoYW5kbGVPblRyYWNrKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5zdHJlYW1zLmxlbmd0aCA8IDEgfHwgZXZlbnQuc3RyZWFtc1swXS5pZCA9PSAncHJvYmF0b3InKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LnRyYWNrLmtpbmQgPT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgdGhpcy52aWRlb1RyYWNrID0gZXZlbnQudHJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LnRyYWNrLmtpbmQgPT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgdGhpcy5hdWRpb1RyYWNrID0gZXZlbnQudHJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblRyYWNrKGV2ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIHRoZSBvblBlZXJJY2VDYW5kaWRhdGVcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgcGVlciBpY2UgY2FuZGlkYXRlXG4gICAgICovXG4gICAgaGFuZGxlSWNlQ2FuZGlkYXRlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMub25QZWVySWNlQ2FuZGlkYXRlKGV2ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIHRoZSBvbkRhdGFDaGFubmVsXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIHBlZXIncyBkYXRhIGNoYW5uZWxcbiAgICAgKi9cbiAgICBoYW5kbGVEYXRhQ2hhbm5lbChldmVudCkge1xuICAgICAgICB0aGlzLm9uRGF0YUNoYW5uZWwoZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBvdmVycmlkZSBtZXRob2QgZm9yIG9uVHJhY2sgZm9yIHVzZSBvdXRzaWRlIG9mIHRoZSBQZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gdHJhY2tFdmVudCAtIFRoZSB3ZWJSdGMgdHJhY2sgZXZlbnRcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb25UcmFjayh0cmFja0V2ZW50KSB7XG4gICAgICAgIC8vIERlZmF1bHQgRnVuY3Rpb25hbGl0eTogRG8gTm90aGluZ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBvdmVycmlkZSBtZXRob2QgZm9yIG9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlIGZvciB1c2Ugb3V0c2lkZSBvZiB0aGUgUGVlckNvbm5lY3Rpb25Db250cm9sbGVyXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIHdlYlJ0YyBpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgZXZlbnRcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBGdW5jdGlvbmFsaXR5OiBEbyBOb3RoaW5nXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIG92ZXJyaWRlIG1ldGhvZCBmb3Igb25QZWVySWNlQ2FuZGlkYXRlIGZvciB1c2Ugb3V0c2lkZSBvZiB0aGUgUGVlckNvbm5lY3Rpb25Db250cm9sbGVyXG4gICAgICogQHBhcmFtIHBlZXJDb25uZWN0aW9uSWNlRXZlbnQgLSBUaGUgcGVlciBpY2UgY2FuZGlkYXRlXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIG9uUGVlckljZUNhbmRpZGF0ZShwZWVyQ29ubmVjdGlvbkljZUV2ZW50KSB7XG4gICAgICAgIC8vIERlZmF1bHQgRnVuY3Rpb25hbGl0eTogRG8gTm90aGluZ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBvdmVycmlkZSBtZXRob2QgZm9yIG9uRGF0YUNoYW5uZWwgZm9yIHVzZSBvdXRzaWRlIG9mIHRoZSBQZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gZGF0YWNoYW5uZWxFdmVudCAtIFRoZSBwZWVyJ3MgZGF0YSBjaGFubmVsXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIG9uRGF0YUNoYW5uZWwoZGF0YWNoYW5uZWxFdmVudCkge1xuICAgICAgICAvLyBEZWZhdWx0IEZ1bmN0aW9uYWxpdHk6IERvIE5vdGhpbmdcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gVUUgYW5kIGJyb3dzZXIgY29kZWNzLCB3aXRoIGZ1enp5IG1hdGNoaW5nIGlmIHNvbWUgcGFyYW1ldGVycyBhcmUgbWlzbWF0Y2hlZC5cbiAgICAgKiBAcGFyYW0gc2RwIFRoZSByZW1vdGUgc2RwXG4gICAgICogQHJldHVybnMgVGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIGJyb3dzZXIgc3VwcG9ydGVkIGNvZGVjcyBhbmQgdWUgc3VwcG9ydGVkIGNvZGVjcy5cbiAgICAgKi9cbiAgICBmdXp6eUludGVyc2VjdFVFQW5kQnJvd3NlckNvZGVjcyhzZHApIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBidWlsZCBhbiBhcnJheSBvZiBhbGwgc3VwcG9ydGVkIGNvZGVjcyBvbiBib3RoIHNpZGVzXG4gICAgICAgIGNvbnN0IGFsbFN1cHBvcnRlZENvZGVjcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICBjb25zdCBhbGxVRUNvZGVjcyA9IHRoaXMucGFyc2VBdmFpbGFibGVDb2RlY3Moc2RwKTtcbiAgICAgICAgY29uc3QgYWxsQnJvd3NlckNvZGVjcyA9IHRoaXMuY29uZmlnLmdldFNldHRpbmdPcHRpb24oT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRDb2RlYykub3B0aW9ucztcbiAgICAgICAgZm9yIChjb25zdCB1ZUNvZGVjIG9mIGFsbFVFQ29kZWNzKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBicm93c2VyIGNvZGVjcyBkaXJlY3RseSBtYXRjaGVzIFVFIGNvZGVjICh3aXRoIHBhcmFtZXRlcnMgYW5kIGV2ZXJ5dGhpbmcpXG4gICAgICAgICAgICBpZiAoYWxsQnJvd3NlckNvZGVjcy5pbmNsdWRlcyh1ZUNvZGVjKSkge1xuICAgICAgICAgICAgICAgIGFsbFN1cHBvcnRlZENvZGVjcy5wdXNoKHVlQ29kZWMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGNoZWNrIGlmIGJyb3dzZXIgY29kZWMgYXQgbGVhc3QgY29udGFpbnMgYSBtYXRjaCBmb3IgdGhlIFVFIGNvZGVjIG5hbWUgKHdpdGhvdXQgcGFyYW1ldGVycykuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1ZUNvZGVjTmFtZUFuZFBhcmFtcyA9IHVlQ29kZWMuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1ZUNvZGVjTmFtZSA9IHVlQ29kZWNOYW1lQW5kUGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYnJvd3NlckNvZGVjIG9mIGFsbEJyb3dzZXJDb2RlY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyb3dzZXJDb2RlYy5pbmNsdWRlcyh1ZUNvZGVjTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHBhc3MgYnJvd3NlciBjb2RlYyBoZXJlIGFzIHRoZXkgb3B0aW9uIGNvbnRhaW4gZXh0cmEgcGFyYW1ldGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbFN1cHBvcnRlZENvZGVjcy5wdXNoKGJyb3dzZXJDb2RlYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxsU3VwcG9ydGVkQ29kZWNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXR1cCB0cmFja3Mgb24gdGhlIFJUQyBQZWVyIENvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0gdXNlTWljIC0gaXMgbWljIGluIHVzZVxuICAgICAqIEBwYXJhbSB1c2VDYW1lcmEgLSBpcyB3ZWJjYW0gaW4gdXNlXG4gICAgICovXG4gICAgc2V0dXBUcmFuc2NlaXZlcnNBc3luYyh1c2VNaWMsIHVzZUNhbWVyYSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgICAgIGxldCBoYXNWaWRlb1JlY2VpdmVyID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zY2VpdmVyIG9mIChfYiA9IChfYSA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRUcmFuc2NlaXZlcnMoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNjZWl2ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIucmVjZWl2ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sgJiZcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sua2luZCA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICAgICAgICBoYXNWaWRlb1JlY2VpdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0dXAgYSB0cmFuc2NlaXZlciBmb3Igc2VuZGluZyB3ZWJjYW0gdmlkZW8gdG8gVUUgYW5kIHJlY2VpdmluZyB2aWRlbyBmcm9tIFVFXG4gICAgICAgICAgICBpZiAoIXVzZUNhbWVyYSkge1xuICAgICAgICAgICAgICAgIGlmICghaGFzVmlkZW9SZWNlaXZlcikge1xuICAgICAgICAgICAgICAgICAgICAoX2MgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJywgeyBkaXJlY3Rpb246ICdyZWN2b25seScgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5zZXR1cFZpZGVvU2VuZGVyKGhhc1ZpZGVvUmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFJUQ1J0cFJlY2VpdmVyLmdldENhcGFiaWxpdGllcyAmJiB0aGlzLnByZWZlcnJlZENvZGVjICE9ICcnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0cmFuc2NlaXZlciBvZiAoX2UgPSAoX2QgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZ2V0VHJhbnNjZWl2ZXJzKCkpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIucmVjZWl2ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAndmlkZW8nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5zZXRDb2RlY1ByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgb3VyIHByZWZlcnJlZCBjb2RlYyBmcm9tIHRoZSBjb2RlY3Mgb3B0aW9ucyBkcm9wIGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZlcnJlZFJUUENvZGVjID0gdGhpcy5wcmVmZXJyZWRDb2RlYy5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZmVycmVkUlRDUnRwQ29kZWNDYXBhYmlsaXR5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiAndmlkZW8vJyArIHByZWZlcnJlZFJUUENvZGVjWzBdIC8qIE5hbWUgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvY2tSYXRlOiA5MDAwMCAvKiBBbGwgY3VycmVudCB2aWRlbyBmb3JtYXRzIGluIGJyb3dzZXJzIGhhdmUgOTBraHogY2xvY2sgcmF0ZSAqLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZHBGbXRwTGluZTogcHJlZmVycmVkUlRQQ29kZWNbMV0gPyBwcmVmZXJyZWRSVFBDb2RlY1sxXSA6ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgYSBsaXN0IG9mIGNvZGVjcyB3ZSB3aWxsIHN1cHBvcnQgd2l0aCBvdXIgcHJlZmVycmVkIG9uZSBpbiB0aGUgZmlyc3QgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG91clN1cHBvcnRlZENvZGVjcyA9IFtwcmVmZXJyZWRSVENSdHBDb2RlY0NhcGFiaWxpdHldO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBhbGwgY29kZWNzIHRoZSBicm93c2VyIHN1cHBvcnRzIGFuZCBhZGQgdGhlbSB0byB0aGUgbGlzdCAoaW4gYW55IG9yZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgUlRDUnRwUmVjZWl2ZXIuZ2V0Q2FwYWJpbGl0aWVzKCd2aWRlbycpLmNvZGVjcy5mb3JFYWNoKChicm93c2VyU3VwcG9ydGVkQ29kZWMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBhZGQgb3VyIHByZWZlcnJlZCBjb2RlYyBhZ2FpbiwgYnV0IGFkZCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnJvd3NlclN1cHBvcnRlZENvZGVjLm1pbWVUeXBlICE9IHByZWZlcnJlZFJUQ1J0cENvZGVjQ2FwYWJpbGl0eS5taW1lVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXJTdXBwb3J0ZWRDb2RlY3MucHVzaChicm93c2VyU3VwcG9ydGVkQ29kZWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoYnJvd3NlclN1cHBvcnRlZENvZGVjID09PSBudWxsIHx8IGJyb3dzZXJTdXBwb3J0ZWRDb2RlYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3NlclN1cHBvcnRlZENvZGVjLnNkcEZtdHBMaW5lKSAhPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocHJlZmVycmVkUlRDUnRwQ29kZWNDYXBhYmlsaXR5ID09PSBudWxsIHx8IHByZWZlcnJlZFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlZmVycmVkUlRDUnRwQ29kZWNDYXBhYmlsaXR5LnNkcEZtdHBMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXJTdXBwb3J0ZWRDb2RlY3MucHVzaChicm93c2VyU3VwcG9ydGVkQ29kZWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb2RlYyBvZiBvdXJTdXBwb3J0ZWRDb2RlY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvZGVjID09PSBudWxsIHx8IGNvZGVjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2RlYy5zZHBGbXRwTGluZSkgPT09IHVuZGVmaW5lZCB8fCBjb2RlYy5zZHBGbXRwTGluZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgZHluYW1pY2FsbHkgYWRkIG1lbWJlcnMgdG8gdGhlIGNvZGVjLCBzbyBpbnN0ZWFkIHJlbW92ZSB0aGUgZmllbGQgaWYgaXQncyBlbXB0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29kZWMuc2RwRm10cExpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuc2V0Q29kZWNQcmVmZXJlbmNlcyhvdXJTdXBwb3J0ZWRDb2RlY3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhhc0F1ZGlvUmVjZWl2ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNjZWl2ZXIgb2YgKF9nID0gKF9mID0gdGhpcy5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmdldFRyYW5zY2VpdmVycygpKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBbXSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlciAmJlxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlciAmJlxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjayAmJlxuICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0F1ZGlvUmVjZWl2ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXR1cCBhIHRyYW5zY2VpdmVyIGZvciBzZW5kaW5nIG1pYyBhdWRpbyB0byBVRSBhbmQgcmVjZWl2aW5nIGF1ZGlvIGZyb20gVUVcbiAgICAgICAgICAgIGlmICghdXNlTWljKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNBdWRpb1JlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIChfaCA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5hZGRUcmFuc2NlaXZlcignYXVkaW8nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdyZWN2b25seSdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5zZXR1cEF1ZGlvU2VuZGVyKGhhc0F1ZGlvUmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0dXBWaWRlb1NlbmRlcihoYXNWaWRlb1JlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIG1lZGlhIHNlbmQgb3B0aW9uc1xuICAgICAgICAgICAgY29uc3QgbWVkaWFTZW5kT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB2aWRlbzogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIE5vdGUgdXNpbmcgd2ViY2FtIG9uIGFuZHJvaWQgY2hyb21lIHJlcXVpcmVzIFNTTCBvciBjaHJvbWU6Ly9mbGFncy8gXCJ1bnNhZmVseS10cmVhdC1pbnNlY3VyZS1vcmlnaW4tYXMtc2VjdXJlXCJcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKG1lZGlhU2VuZE9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNWaWRlb1JlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNjZWl2ZXIgb2YgKF9iID0gKF9hID0gdGhpcy5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRyYW5zY2VpdmVycygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJUQ1V0aWxzLmNhblRyYW5zY2VpdmVyUmVjZWl2ZVZpZGVvKHRyYW5zY2VpdmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHJhY2sgb2Ygc3RyZWFtLmdldFRyYWNrcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFjay5raW5kICYmIHRyYWNrLmtpbmQgPT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayh0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnc2VuZHJlY3YnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRyYWNrIG9mIHN0cmVhbS5nZXRUcmFja3MoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrLmtpbmQgJiYgdHJhY2sua2luZCA9PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9jID0gdGhpcy5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFkZFRyYW5zY2VpdmVyKHRyYWNrLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ3NlbmRyZWN2J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNWaWRlb1JlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIChfZCA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hZGRUcmFuc2NlaXZlcigndmlkZW8nLCB7IGRpcmVjdGlvbjogJ3JlY3Zvbmx5JyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXR1cEF1ZGlvU2VuZGVyKGhhc0F1ZGlvUmVjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIC8vIHNldCB0aGUgYXVkaW8gb3B0aW9ucyBiYXNlZCBvbiBtaWMgdXNhZ2VcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBhdXRvR2FpbkNvbnRyb2w6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgICAgICAgICBlY2hvQ2FuY2VsbGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYXRlbmN5OiAwLFxuICAgICAgICAgICAgICAgIG5vaXNlU3VwcHJlc3Npb246IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNhbXBsZVJhdGU6IDQ4MDAwLFxuICAgICAgICAgICAgICAgIHNhbXBsZVNpemU6IDE2LFxuICAgICAgICAgICAgICAgIHZvbHVtZTogMS4wXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gc2V0IHRoZSBtZWRpYSBzZW5kIG9wdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IG1lZGlhU2VuZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdmlkZW86IGZhbHNlLFxuICAgICAgICAgICAgICAgIGF1ZGlvOiBhdWRpb09wdGlvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBOb3RlIHVzaW5nIG1pYyBvbiBhbmRyb2lkIGNocm9tZSByZXF1aXJlcyBTU0wgb3IgY2hyb21lOi8vZmxhZ3MvIFwidW5zYWZlbHktdHJlYXQtaW5zZWN1cmUtb3JpZ2luLWFzLXNlY3VyZVwiXG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShtZWRpYVNlbmRPcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzQXVkaW9SZWNlaXZlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zY2VpdmVyIG9mIChfYiA9IChfYSA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRUcmFuc2NlaXZlcnMoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSVENVdGlscy5jYW5UcmFuc2NlaXZlclJlY2VpdmVBdWRpbyh0cmFuc2NlaXZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRyYWNrIG9mIHN0cmVhbS5nZXRUcmFja3MoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2sua2luZCAmJiB0cmFjay5raW5kID09ICdhdWRpbycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRlci5yZXBsYWNlVHJhY2sodHJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRyZWN2JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0cmFjayBvZiBzdHJlYW0uZ2V0VHJhY2tzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFjay5raW5kICYmIHRyYWNrLmtpbmQgPT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYyA9IHRoaXMucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hZGRUcmFuc2NlaXZlcih0cmFjaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdzZW5kcmVjdidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghaGFzQXVkaW9SZWNlaXZlcikge1xuICAgICAgICAgICAgICAgICAgICAoX2QgPSB0aGlzLnBlZXJDb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAncmVjdm9ubHknXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuZCBvdmVycmlkZSBldmVudCBmb3Igd2hlbiB0aGUgdmlkZW8gc3RhdHMgYXJlIGZpcmVkXG4gICAgICogQHBhcmFtIGV2ZW50IC0gQWdncmVnYXRlZCBTdGF0c1xuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBvblZpZGVvU3RhdHMoZXZlbnQpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBGdW5jdGlvbmFsaXR5OiBEbyBOb3RoaW5nXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuZCBvdmVycmlkZSBldmVudCBmb3Igd2hlbiBsYXRlbmN5IGluZm8gaXMgY2FsY3VsYXRlZFxuICAgICAqIEBwYXJhbSBsYXRlbmN5SW5mbyAtIENhbGN1bGF0ZWQgbGF0ZW5jeSBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb25MYXRlbmN5Q2FsY3VsYXRlZChsYXRlbmN5SW5mbykge1xuICAgICAgICAvLyBEZWZhdWx0IEZ1bmN0aW9uYWxpdHk6IERvIE5vdGhpbmdcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZlbnQgdG8gc2VuZCB0aGUgUlRDIG9mZmVyIHRvIHRoZSBTaWduYWxpbmcgc2VydmVyXG4gICAgICogQHBhcmFtIG9mZmVyIC0gUlRDIE9mZmVyXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIG9uU2VuZFdlYlJUQ09mZmVyKG9mZmVyKSB7XG4gICAgICAgIC8vIERlZmF1bHQgRnVuY3Rpb25hbGl0eTogRG8gTm90aGluZ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHJlbW90ZSBvZmZlciBkZXNjcmlwdGlvbiBpcyBzZXQuXG4gICAgICogQHBhcmFtIG9mZmVyIC0gUlRDIE9mZmVyXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIG9uU2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBGdW5jdGlvbmFsaXR5OiBEbyBOb3RoaW5nXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmUgd2hlbiBsb2NhbCBkZXNjcmlwdGlvbiBhbnN3ZXIgaXMgc2V0LlxuICAgICAqIEBwYXJhbSBhbnN3ZXIgLSBSVEMgQW5zd2VyXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIG9uU2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBGdW5jdGlvbmFsaXR5OiBEbyBOb3RoaW5nXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIG92ZXJyaWRlIGZvciBzaG93aW5nIHRoZSBQZWVyIGNvbm5lY3Rpb24gY29ubmVjdGluZyBPdmVybGF5XG4gICAgICovXG4gICAgc2hvd1RleHRPdmVybGF5Q29ubmVjdGluZygpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBGdW5jdGlvbmFsaXR5OiBEbyBOb3RoaW5nXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIG92ZXJyaWRlIGZvciBzaG93aW5nIHRoZSBQZWVyIGNvbm5lY3Rpb24gRmFpbGVkIG92ZXJsYXlcbiAgICAgKi9cbiAgICBzaG93VGV4dE92ZXJsYXlTZXR1cEZhaWx1cmUoKSB7XG4gICAgICAgIC8vIERlZmF1bHQgRnVuY3Rpb25hbGl0eTogRG8gTm90aGluZ1xuICAgIH1cbiAgICBwYXJzZUF2YWlsYWJsZUNvZGVjcyhydGNTZXNzaW9uRGVzY3JpcHRpb24pIHtcbiAgICAgICAgLy8gTm8gcG9pbnQgaW4gdXBkYXRpbmcgdGhlIGF2YWlsYWJsZSBjb2RlY3MgaWYgb24gRkZcbiAgICAgICAgaWYgKCFSVENSdHBSZWNlaXZlci5nZXRDYXBhYmlsaXRpZXMpXG4gICAgICAgICAgICByZXR1cm4gWydPbmx5IGF2YWlsYWJsZSBvbiBDaHJvbWUnXTtcbiAgICAgICAgY29uc3QgdWVTdXBwb3J0ZWRDb2RlY3MgPSBbXTtcbiAgICAgICAgY29uc3Qgc2VjdGlvbnMgPSBzcGxpdFNlY3Rpb25zKHJ0Y1Nlc3Npb25EZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAvLyBkaXNjYXJkIHRoZSBzZXNzaW9uIGluZm9ybWF0aW9uIGFzIHdlIG9ubHkgd2FudCBtZWRpYSByZWxhdGVkIGluZm9cbiAgICAgICAgc2VjdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgc2VjdGlvbnMuZm9yRWFjaCgobWVkaWFTZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNvZGVjcyB9ID0gcGFyc2VSdHBQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbik7XG4gICAgICAgICAgICAvLyBGaWx0ZXIgb25seSBmb3IgVlBYIC8gSDI2WCAvIEFWMVxuICAgICAgICAgICAgY29uc3QgbWF0Y2hlciA9IC8oVlBcXGR8SDI2XFxkfEFWMSkuKi87XG4gICAgICAgICAgICBjb2RlY3MuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ciA9IGMubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGMucGFyYW1ldGVycyB8fCB7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKHApID0+IHAgKyAnPScgKyBjLnBhcmFtZXRlcnNbcF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignOycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlci5leGVjKHN0cik7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjLm5hbWUgPT0gJ1ZQOScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVFIGFuc3dlcnMgZG9uJ3Qgc3BlY2lmeSBwcm9maWxlIGJ1dCB3ZSBrbm93IHdlIHdhbnQgcHJvZmlsZSAwXG4gICAgICAgICAgICAgICAgICAgICAgICBjLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb2ZpbGUtaWQnOiAnMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZWNTdHIgPSBjLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGMucGFyYW1ldGVycyB8fCB7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKChwKSA9PiBwICsgJz0nICsgYy5wYXJhbWV0ZXJzW3BdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCc7Jyk7XG4gICAgICAgICAgICAgICAgICAgIHVlU3VwcG9ydGVkQ29kZWNzLnB1c2goY29kZWNTdHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVlU3VwcG9ydGVkQ29kZWNzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBTZXNzaW9uIHN0YXRpc3RpY3NcbiAqL1xuZXhwb3J0IGNsYXNzIFNlc3Npb25TdGF0cyB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXNzaW9uU3RhdHMuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogQ2xhc3MgdG8gaG9sZCB0aGUgc3RyZWFtIHN0YXRzIGRhdGEgY29taW5nIGluIGZyb20gd2ViUnRjXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1TdGF0cyB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdHJlYW1TdGF0cy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgT3B0aW9uUGFyYW1ldGVycyB9IGZyb20gJy4uL0NvbmZpZy9Db25maWcnO1xuaW1wb3J0IHsgV2ViUnRjUGxheWVyQ29udHJvbGxlciB9IGZyb20gJy4uL1dlYlJ0Y1BsYXllci9XZWJSdGNQbGF5ZXJDb250cm9sbGVyJztcbmltcG9ydCB7IEZsYWdzLCBOdW1lcmljUGFyYW1ldGVycyB9IGZyb20gJy4uL0NvbmZpZy9Db25maWcnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuaW1wb3J0IHsgUGl4ZWxTdHJlYW1pbmdFdmVudEVtaXR0ZXIsIEluaXRpYWxTZXR0aW5nc0V2ZW50LCBMYXRlbmN5Q2FsY3VsYXRlZEV2ZW50LCBMYXRlbmN5VGVzdFJlc3VsdEV2ZW50LCBTdGF0c1JlY2VpdmVkRXZlbnQsIFN0cmVhbUxvYWRpbmdFdmVudCwgU3RyZWFtUHJlQ29ubmVjdEV2ZW50LCBTdHJlYW1SZWNvbm5lY3RFdmVudCwgU3RyZWFtUHJlRGlzY29ubmVjdEV2ZW50LCBWaWRlb0VuY29kZXJBdmdRUEV2ZW50LCBWaWRlb0luaXRpYWxpemVkRXZlbnQsIFdlYlJ0Y0F1dG9Db25uZWN0RXZlbnQsIFdlYlJ0Y0Nvbm5lY3RlZEV2ZW50LCBXZWJSdGNDb25uZWN0aW5nRXZlbnQsIFdlYlJ0Y0Rpc2Nvbm5lY3RlZEV2ZW50LCBXZWJSdGNGYWlsZWRFdmVudCwgV2ViUnRjU2RwRXZlbnQsIERhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXNwb25zZUV2ZW50LCBEYXRhQ2hhbm5lbExhdGVuY3lUZXN0UmVzdWx0RXZlbnQsIFBsYXllckNvdW50RXZlbnQsIFdlYlJ0Y1RDUFJlbGF5RGV0ZWN0ZWRFdmVudCwgU3Vic2NyaWJlRmFpbGVkRXZlbnQsIFdlYlJ0Y1NkcE9mZmVyRXZlbnQsIFdlYlJ0Y1NkcEFuc3dlckV2ZW50IH0gZnJvbSAnLi4vVXRpbC9FdmVudEVtaXR0ZXInO1xuaW1wb3J0IHsgV2ViWFJDb250cm9sbGVyIH0gZnJvbSAnLi4vV2ViWFIvV2ViWFJDb250cm9sbGVyJztcbmltcG9ydCB7IE1lc3NhZ2VEaXJlY3Rpb24gfSBmcm9tICcuLi9VZUluc3RhbmNlTWVzc2FnZS9TdHJlYW1NZXNzYWdlQ29udHJvbGxlcic7XG5pbXBvcnQgeyBEYXRhQ2hhbm5lbExhdGVuY3lUZXN0Q29udHJvbGxlciB9IGZyb20gJy4uL0RhdGFDaGFubmVsL0RhdGFDaGFubmVsTGF0ZW5jeVRlc3RDb250cm9sbGVyJztcbmltcG9ydCB7IFJUQ1V0aWxzIH0gZnJvbSAnLi4vVXRpbC9SVENVdGlscyc7XG5pbXBvcnQgeyBJVVJMU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vVXRpbC9JVVJMU2VhcmNoUGFyYW1zJztcbi8qKlxuICogVGhlIGtleSBjbGFzcyBmb3IgdGhlIGJyb3dzZXIgc2lkZSBvZiBhIFBpeGVsIFN0cmVhbWluZyBhcHBsaWNhdGlvbiwgaXQgaW5jbHVkZXM6XG4gKiBXZWJSVEMgaGFuZGxpbmcsIFhSIHN1cHBvcnQsIGlucHV0IGhhbmRsaW5nLCBhbmQgZW1pdHRlcnMgZm9yIGxpZmV0aW1lIGFuZCBzdGF0ZSBjaGFuZ2UgZXZlbnRzLlxuICogVXNlcnMgYXJlIGVuY291cmFnZWQgdG8gdXNlIHRoaXMgY2xhc3MgYXMgaXMsIHRocm91Z2ggY29tcG9zaXRpb24sIG9yIGV4dGVuZCBpdC4gSW4gYW55IGNhc2UsXG4gKiB0aGlzIHdpbGwgbGlrZWx5IGJlIHRoZSBjb3JlIG9mIHlvdXIgUGl4ZWwgU3RyZWFtaW5nIGV4cGVyaWVuY2UgaW4gdGVybXMgb2YgZnVuY3Rpb25hbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBpeGVsU3RyZWFtaW5nIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gQSBuZXdseSBpbnN0YW50aWF0ZWQgY29uZmlnIG9iamVjdFxuICAgICAqIEBwYXJhbSBvdmVycmlkZXMgLSBQYXJhbWV0ZXJzIHRvIG92ZXJyaWRlIGRlZmF1bHQgYmVoYXZpb3VyXG4gICAgICogcmV0dXJucyB0aGUgYmFzZSBQaXhlbCBzdHJlYW1pbmcgb2JqZWN0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBvdmVycmlkZXMpIHtcbiAgICAgICAgdGhpcy5hbGxvd0NvbnNvbGVDb21tYW5kcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgaWYgKG92ZXJyaWRlcyA9PT0gbnVsbCB8fCBvdmVycmlkZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG92ZXJyaWRlcy52aWRlb0VsZW1lbnRQYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvRWxlbWVudFBhcmVudCA9IG92ZXJyaWRlcy52aWRlb0VsZW1lbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyID0gbmV3IFBpeGVsU3RyZWFtaW5nRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJlU2V0dGluZ3MoKTtcbiAgICAgICAgLy8gc2V0dXAgV2ViUlRDXG4gICAgICAgIHRoaXMuc2V0V2ViUnRjUGxheWVyQ29udHJvbGxlcihuZXcgV2ViUnRjUGxheWVyQ29udHJvbGxlcih0aGlzLmNvbmZpZywgdGhpcykpO1xuICAgICAgICB0aGlzLl93ZWJYckNvbnRyb2xsZXIgPSBuZXcgV2ViWFJDb250cm9sbGVyKHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLl9zZXR1cFdlYlJ0Y1RDUFJlbGF5RGV0ZWN0aW9uID0gdGhpcy5fc2V0dXBXZWJSdGNUQ1BSZWxheURldGVjdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSB3ZWJSdGNDb25uZWN0ZWQgZXZlbnRcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYlJ0Y0Nvbm5lY3RlZCcsIChfKSA9PiB7XG4gICAgICAgICAgICAvLyBCaW5kIHRvIHRoZSBzdGF0cyByZWNlaXZlZCBldmVudFxuICAgICAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3N0YXRzUmVjZWl2ZWQnLCB0aGlzLl9zZXR1cFdlYlJ0Y1RDUFJlbGF5RGV0ZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdmlkZW8gc3RyZWFtIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0IHZpZGVvRWxlbWVudFBhcmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl92aWRlb0VsZW1lbnRQYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvRWxlbWVudFBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fdmlkZW9FbGVtZW50UGFyZW50LmlkID0gJ3ZpZGVvRWxlbWVudFBhcmVudCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZGVvRWxlbWVudFBhcmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIHRoZSBzZXR0aW5ncyB3aXRoIG9uIGNoYW5nZSBsaXN0ZW5lcnMgYW5kIGFueSBhZGRpdGlvbmFsIHBlciBleHBlcmllbmNlIHNldHRpbmdzLlxuICAgICAqL1xuICAgIGNvbmZpZ3VyZVNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25TZXR0aW5nQ2hhbmdlZExpc3RlbmVyKEZsYWdzLklzUXVhbGl0eUNvbnRyb2xsZXIsICh3YW50c1F1YWxpdHlDb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2V0dGluZyBoYXMgYmVlbiBzZXQgdG8gdHJ1ZSAoZWl0aGVyIHByb2dyYW1tYXRpY2FsbHkgb3IgdGhlIHVzZXIgaGFzIGZsaWNrZWQgdGhlIHRvZ2dsZSlcbiAgICAgICAgICAgIC8vIGFuZCB3ZSBhcmVuJ3QgY3VycmVudGx5IHF1YWxpdHkgY29udHJvbGxlciwgc2VuZCB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgaWYgKHdhbnRzUXVhbGl0eUNvbnRyb2xsZXIgPT09IHRydWUgJiYgIXRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuaXNRdWFsaXR5Q29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZFJlcXVlc3RRdWFsaXR5Q29udHJvbE93bmVyc2hpcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihGbGFncy5BRktEZXRlY3Rpb24sIChpc0FGS0VuYWJsZWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2V0QWZrRW5hYmxlZChpc0FGS0VuYWJsZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihGbGFncy5NYXRjaFZpZXdwb3J0UmVzb2x1dGlvbiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci51cGRhdGVWaWRlb1N0cmVhbVNpemUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPblNldHRpbmdDaGFuZ2VkTGlzdGVuZXIoRmxhZ3MuSG92ZXJpbmdNb3VzZU1vZGUsIChpc0hvdmVyaW5nTW91c2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldEZsYWdMYWJlbChGbGFncy5Ib3ZlcmluZ01vdXNlTW9kZSwgYENvbnRyb2wgU2NoZW1lOiAke2lzSG92ZXJpbmdNb3VzZSA/ICdIb3ZlcmluZycgOiAnTG9ja2VkJ30gTW91c2VgKTtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2V0TW91c2VJbnB1dEVuYWJsZWQodGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5Nb3VzZUlucHV0KSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB1c2VyIGlucHV0XG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPblNldHRpbmdDaGFuZ2VkTGlzdGVuZXIoRmxhZ3MuS2V5Ym9hcmRJbnB1dCwgKGlzRW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZXRLZXlib2FyZElucHV0RW5hYmxlZChpc0VuYWJsZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihGbGFncy5Nb3VzZUlucHV0LCAoaXNFbmFibGVkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnNldE1vdXNlSW5wdXRFbmFibGVkKGlzRW5hYmxlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25TZXR0aW5nQ2hhbmdlZExpc3RlbmVyKEZsYWdzLkZha2VNb3VzZVdpdGhUb3VjaGVzLCAoX2lzRmFrZU1vdXNlRW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZXRUb3VjaElucHV0RW5hYmxlZCh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLlRvdWNoSW5wdXQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPblNldHRpbmdDaGFuZ2VkTGlzdGVuZXIoRmxhZ3MuVG91Y2hJbnB1dCwgKGlzRW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZXRUb3VjaElucHV0RW5hYmxlZChpc0VuYWJsZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihGbGFncy5HYW1lcGFkSW5wdXQsIChpc0VuYWJsZWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2V0R2FtZVBhZElucHV0RW5hYmxlZChpc0VuYWJsZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZGlyZWN0IHFwIHNldHRpbmdzXG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPbk51bWVyaWNTZXR0aW5nQ2hhbmdlZExpc3RlbmVyKE51bWVyaWNQYXJhbWV0ZXJzLk1pblFQLCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCctLS0tLS0tLSAgU2VuZGluZyBNaW5RUCAgLS0tLS0tLS0nKTtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZEVuY29kZXJNaW5RUChuZXdWYWx1ZSk7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgICAgICAgICAgY29uc3QgcXVhbGl0eSA9IE1hdGgudHJ1bmMoMTAwICogKDEgLSBuZXdWYWx1ZSAvIDUxKSk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXROdW1lcmljU2V0dGluZyhOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWF4LCBxdWFsaXR5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPbk51bWVyaWNTZXR0aW5nQ2hhbmdlZExpc3RlbmVyKE51bWVyaWNQYXJhbWV0ZXJzLk1heFFQLCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCctLS0tLS0tLSAgU2VuZGluZyBNYXhRUCAgLS0tLS0tLS0nKTtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZEVuY29kZXJNYXhRUChuZXdWYWx1ZSk7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgICAgICAgICAgY29uc3QgcXVhbGl0eSA9IE1hdGgudHJ1bmMoMTAwICogKDEgLSBuZXdWYWx1ZSAvIDUxKSk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXROdW1lcmljU2V0dGluZyhOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWluLCBxdWFsaXR5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGRpcmVjdCBxdWFsaXR5IGZhY3RvciBzZXR0aW5nc1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25OdW1lcmljU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihOdW1lcmljUGFyYW1ldGVycy5NaW5RdWFsaXR5LCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCctLS0tLS0tLSAgU2VuZGluZyBNaW5RdWFsaXR5ICAtLS0tLS0tLScpO1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZW5kRW5jb2Rlck1pblF1YWxpdHkobmV3VmFsdWUpO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nKTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldE51bWVyaWNTZXR0aW5nKE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNaW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPbk51bWVyaWNTZXR0aW5nQ2hhbmdlZExpc3RlbmVyKE51bWVyaWNQYXJhbWV0ZXJzLk1heFF1YWxpdHksIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tICBTZW5kaW5nIE1heFF1YWxpdHkgIC0tLS0tLS0tJyk7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnNlbmRFbmNvZGVyTWF4UXVhbGl0eShuZXdWYWx1ZSk7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0TnVtZXJpY1NldHRpbmcoTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1heCwgbmV3VmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gbmV3IHF1YWxpdHkgdmFsdWUgdGhhdCBnZXRzIHNjYWxlZCB0byBxcCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uTnVtZXJpY1NldHRpbmdDaGFuZ2VkTGlzdGVuZXIoTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1pbiwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IDUxIC0gKG5ld1ZhbHVlIC8gMTAwKSAqIDUxO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tICBTZW5kaW5nIE1pblFQIGZyb20gcXVhbGl0eSB2YWx1ZSAgLS0tLS0tLS0nKTtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZEVuY29kZXJNYXhRUChuZXdWYWx1ZSk7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uTnVtZXJpY1NldHRpbmdDaGFuZ2VkTGlzdGVuZXIoTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1heCwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IDUxIC0gKG5ld1ZhbHVlIC8gMTAwKSAqIDUxO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tICBTZW5kaW5nIE1heFFQIGZyb20gcXVhbGl0eSB2YWx1ZSAgLS0tLS0tLS0nKTtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZEVuY29kZXJNaW5RUChuZXdWYWx1ZSk7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2ViUlRDIHNldHRpbmdzXG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPbk51bWVyaWNTZXR0aW5nQ2hhbmdlZExpc3RlbmVyKE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01pbkJpdHJhdGUsIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tICBTZW5kaW5nIHdlYiBydGMgc2V0dGluZ3MgIC0tLS0tLS0tJyk7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnNlbmRXZWJSVENNaW5CaXRyYXRlKG5ld1ZhbHVlICogMTAwMCAvKiBrYnBzIHRvIGJwcyAqLyk7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uTnVtZXJpY1NldHRpbmdDaGFuZ2VkTGlzdGVuZXIoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWF4Qml0cmF0ZSwgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnLS0tLS0tLS0gIFNlbmRpbmcgd2ViIHJ0YyBzZXR0aW5ncyAgLS0tLS0tLS0nKTtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZFdlYlJUQ01heEJpdHJhdGUobmV3VmFsdWUgKiAxMDAwIC8qIGticHMgdG8gYnBzICovKTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25OdW1lcmljU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihOdW1lcmljUGFyYW1ldGVycy5XZWJSVENGUFMsIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tICBTZW5kaW5nIHdlYiBydGMgc2V0dGluZ3MgIC0tLS0tLS0tJyk7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnNlbmRXZWJSVENGcHMobmV3VmFsdWUpO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnLl9hZGRPbk9wdGlvblNldHRpbmdDaGFuZ2VkTGlzdGVuZXIoT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRDb2RlYywgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fd2ViUnRjQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2V0UHJlZmVycmVkQ29kZWMobmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcuX3JlZ2lzdGVyT25DaGFuZ2VFdmVudHModGhpcy5fZXZlbnRFbWl0dGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBpbnB1dCBjb250cm9sIG93bmVyc2hpcFxuICAgICAqIEBwYXJhbSBpbnB1dENvbnRyb2xPd25lcnNoaXAgLSBkb2VzIHRoZSB1c2VyIGhhdmUgaW5wdXQgY29udHJvbCBvd25lcnNoaXBcbiAgICAgKi9cbiAgICBfb25JbnB1dENvbnRyb2xPd25lcnNoaXAoaW5wdXRDb250cm9sT3duZXJzaGlwKSB7XG4gICAgICAgIHRoaXMuX2lucHV0Q29udHJvbGxlciA9IGlucHV0Q29udHJvbE93bmVyc2hpcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgdGhlIFdlYlJUQ1BsYXllckNvbnRyb2xsZXIgaW50ZXJmYWNlIHRvIHByb3ZpZGUgV2ViUlRDUGxheWVyQ29udHJvbGxlciBmdW5jdGlvbmFsaXR5IHdpdGhpbiB0aGlzIGNsYXNzIGFuZCBzZXQgdXAgYW55dGhpbmcgdGhhdCByZXF1aXJlcyBpdFxuICAgICAqIEBwYXJhbSB3ZWJSdGNQbGF5ZXJDb250cm9sbGVyIC0gYSBXZWJSdGNQbGF5ZXJDb250cm9sbGVyIGNvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzZXRXZWJSdGNQbGF5ZXJDb250cm9sbGVyKHdlYlJ0Y1BsYXllckNvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlciA9IHdlYlJ0Y1BsYXllckNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2V0UHJlZmVycmVkQ29kZWModGhpcy5jb25maWcuZ2V0U2V0dGluZ09wdGlvbihPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZENvZGVjKS5zZWxlY3RlZCk7XG4gICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIucmVzaXplUGxheWVyU3R5bGUoKTtcbiAgICAgICAgLy8gY29ubmVjdCBpZiBhdXRvIGNvbm5lY3QgZmxhZyBpcyBlbmFibGVkXG4gICAgICAgIHRoaXMuY2hlY2tGb3JBdXRvQ29ubmVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRvIHNpZ25hbGluZyBzZXJ2ZXIuXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFN0cmVhbVByZUNvbm5lY3RFdmVudCgpKTtcbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5jb25uZWN0VG9TaWduYWxsaW5nU2VydmVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29ubmVjdHMgdG8gdGhlIHNpZ25hbGluZyBzZXJ2ZXIuIElmIGNvbm5lY3Rpb24gaXMgdXAsIGRpc2Nvbm5lY3RzIGZpcnN0XG4gICAgICogYmVmb3JlIGVzdGFibGlzaGluZyBhIG5ldyBjb25uZWN0aW9uXG4gICAgICovXG4gICAgcmVjb25uZWN0KCkge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgU3RyZWFtUmVjb25uZWN0RXZlbnQoKSk7XG4gICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIudHJ5UmVjb25uZWN0KCdSZWNvbm5lY3RpbmcuLi4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCBmcm9tIHRoZSBzaWduYWxpbmcgc2VydmVyIGFuZCBjbG9zZSBvcGVuIHBlZXIgY29ubmVjdGlvbnMuXG4gICAgICovXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFN0cmVhbVByZURpc2Nvbm5lY3RFdmVudCgpKTtcbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGF5IHRoZSBzdHJlYW0uIENhbiBiZSBjYWxsZWQgb25seSBhZnRlciBhIHBlZXIgY29ubmVjdGlvbiBoYXMgYmVlbiBlc3RhYmxpc2hlZC5cbiAgICAgKi9cbiAgICBwbGF5KCkge1xuICAgICAgICB0aGlzLl9vblN0cmVhbUxvYWRpbmcoKTtcbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5wbGF5U3RyZWFtKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF1dG8gY29ubmVjdCBpZiBBdXRvQ29ubmVjdCBmbGFnIGlzIGVuYWJsZWRcbiAgICAgKi9cbiAgICBjaGVja0ZvckF1dG9Db25uZWN0KCkge1xuICAgICAgICAvLyBzZXQgdXAgaWYgdGhlIGF1dG8gcGxheSB3aWxsIGJlIHVzZWQgb3IgcmVndWxhciBjbGljayB0byBzdGFydFxuICAgICAgICBpZiAodGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5BdXRvQ29ubmVjdCkpIHtcbiAgICAgICAgICAgIC8vIGlmIGF1dG9wbGF5aW5nIHNob3cgYW4gaW5mbyBvdmVybGF5IHdoaWxlIHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBjb25uZWN0aW9uIHRvIGJlZ2luXG4gICAgICAgICAgICB0aGlzLl9vbldlYlJ0Y0F1dG9Db25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLmNvbm5lY3RUb1NpZ25hbGxpbmdTZXJ2ZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHVubXV0ZSB0aGUgbWljcm9waG9uZSB0cmFjayB3aGljaCBpcyBzZW50IHRvIFVucmVhbCBFbmdpbmUuXG4gICAgICogQnkgZGVmYXVsdCwgd2lsbCBvbmx5IHVubXV0ZSBhbiBleGlzdGluZyBtaWMgdHJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9yY2VFbmFibGUgQ2FuIGJlIHVzZWQgZm9yIGNhc2VzIHdoZW4gdGhpcyBvYmplY3Qgd2Fzbid0IGluaXRpYWxpemVkIHdpdGggYSBtaWMgdHJhY2suXG4gICAgICogSWYgdGhpcyBwYXJhbWV0ZXIgaXMgdHJ1ZSwgdGhlIGNvbm5lY3Rpb24gd2lsbCBiZSByZXN0YXJ0ZWQgd2l0aCBhIG1pY3JvcGhvbmUuXG4gICAgICogV2FybmluZzogdGhpcyB0YWtlcyBzb21lIHRpbWUsIGFzIGEgZnVsbCByZW5lZ290aWF0aW9uIGFuZCByZWNvbm5lY3Rpb24gd2lsbCBoYXBwZW4uXG4gICAgICovXG4gICAgdW5tdXRlTWljcm9waG9uZShmb3JjZUVuYWJsZSA9IGZhbHNlKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYW4gZXhpc3RpbmcgbWljIHRyYWNrLCB3ZSBqdXN0IHNldCBtdXRlZCBzdGF0ZVxuICAgICAgICBpZiAodGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZCgnVXNlTWljJykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TWljcm9waG9uZU11dGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHByZS1leGlzdGluZyBtaWMgdHJhY2ssIGFuZCBjYWxsZXIgaXMgb2sgd2l0aCBmdWxsIHJlc2V0LCB3ZSBlbmFibGUgYW5kIHJlc2V0XG4gICAgICAgIGlmIChmb3JjZUVuYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0RmxhZ0VuYWJsZWQoJ1VzZU1pYycsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBwcmVmZXIgbm90IHRvIGZvcmNlIGEgcmVjb25uZWN0aW9uLCBqdXN0IHdhcm4gdGhlIHVzZXIgdGhhdCB0aGlzIG9wZXJhdGlvbiBkaWRuJ3QgaGFwcGVuXG4gICAgICAgIExvZ2dlci5XYXJuaW5nKCdUcnlpbmcgdG8gdW5tdXRlIG1pYywgYnV0IFBpeGVsU3RyZWFtaW5nIHdhcyBpbml0aWFsaXplZCB3aXRoIG5vIG1pY3JvcGhvbmUgdHJhY2suIENhbGwgd2l0aCBmb3JjZUVuYWJsZSA9PSB0cnVlIHRvIHJlLWNvbm5lY3Qgd2l0aCBhIG1pYyB0cmFjay4nKTtcbiAgICB9XG4gICAgbXV0ZU1pY3JvcGhvbmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKCdVc2VNaWMnKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRNaWNyb3Bob25lTXV0ZWQodHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgd2Fzbid0IGEgbWljIHRyYWNrLCBqdXN0IGxldCB1c2VyIGtub3cgdGhlcmUncyBub3RoaW5nIHRvIG11dGVcbiAgICAgICAgTG9nZ2VyLkluZm8oJ1RyeWluZyB0byBtdXRlIG1pYywgYnV0IFBpeGVsU3RyZWFtaW5nIGhhcyBubyBtaWNyb3Bob25lIHRyYWNrLCBzbyBzZW5kaW5nIHNvdW5kIGlzIGFscmVhZHkgZGlzYWJsZWQuJyk7XG4gICAgfVxuICAgIHNldE1pY3JvcGhvbmVNdXRlZChtdXRlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgZm9yIChjb25zdCB0cmFuc2NlaXZlciBvZiAoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLl93ZWJSdGNDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGVlckNvbm5lY3Rpb25Db250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGVlckNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRUcmFuc2NlaXZlcnMoKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogW10pIHtcbiAgICAgICAgICAgIGlmIChSVENVdGlscy5jYW5UcmFuc2NlaXZlclNlbmRBdWRpbyh0cmFuc2NlaXZlcikpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2suZW5hYmxlZCA9ICFtdXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgdW5tdXRlIHRoZSB2aWRlbyB0cmFjayB3aGljaCBpcyBzZW50IHRvIFVucmVhbCBFbmdpbmUuXG4gICAgICogQnkgZGVmYXVsdCwgd2lsbCBvbmx5IHVubXV0ZSBhbiBleGlzdGluZyB2aWRlbyB0cmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JjZUVuYWJsZSBDYW4gYmUgdXNlZCBmb3IgY2FzZXMgd2hlbiB0aGlzIG9iamVjdCB3YXNuJ3QgaW5pdGlhbGl6ZWQgd2l0aCBhIHZpZGVvIHRyYWNrLlxuICAgICAqIElmIHRoaXMgcGFyYW1ldGVyIGlzIHRydWUsIHRoZSBjb25uZWN0aW9uIHdpbGwgYmUgcmVzdGFydGVkIHdpdGggYSBjYW1lcmEuXG4gICAgICogV2FybmluZzogdGhpcyB0YWtlcyBzb21lIHRpbWUsIGFzIGEgZnVsbCByZW5lZ290aWF0aW9uIGFuZCByZWNvbm5lY3Rpb24gd2lsbCBoYXBwZW4uXG4gICAgICovXG4gICAgdW5tdXRlQ2FtZXJhKGZvcmNlRW5hYmxlID0gZmFsc2UpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBhbiBleGlzdGluZyB2aWRlbyB0cmFjaywgd2UganVzdCBzZXQgbXV0ZWQgc3RhdGVcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoJ1VzZUNhbWVyYScpKSB7XG4gICAgICAgICAgICB0aGlzLnNldENhbWVyYU11dGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHByZS1leGlzdGluZyB2aWRlbyB0cmFjaywgYW5kIGNhbGxlciBpcyBvayB3aXRoIGZ1bGwgcmVzZXQsIHdlIGVuYWJsZSBhbmQgcmVzZXRcbiAgICAgICAgaWYgKGZvcmNlRW5hYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXRGbGFnRW5hYmxlZCgnVXNlQ2FtZXJhJywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIHByZWZlciBub3QgdG8gZm9yY2UgYSByZWNvbm5lY3Rpb24sIGp1c3Qgd2FybiB0aGUgdXNlciB0aGF0IHRoaXMgb3BlcmF0aW9uIGRpZG4ndCBoYXBwZW5cbiAgICAgICAgTG9nZ2VyLldhcm5pbmcoJ1RyeWluZyB0byB1bm11dGUgdmlkZW8sIGJ1dCBQaXhlbFN0cmVhbWluZyB3YXMgaW5pdGlhbGl6ZWQgd2l0aCBubyB2aWRlbyB0cmFjay4gQ2FsbCB3aXRoIGZvcmNlRW5hYmxlID09IHRydWUgdG8gcmUtY29ubmVjdCB3aXRoIGEgdmlkZW8gdHJhY2suJyk7XG4gICAgfVxuICAgIG11dGVDYW1lcmEoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKCdVc2VDYW1lcmEnKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDYW1lcmFNdXRlZCh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSB3YXNuJ3QgYSBtaWMgdHJhY2ssIGp1c3QgbGV0IHVzZXIga25vdyB0aGVyZSdzIG5vdGhpbmcgdG8gbXV0ZVxuICAgICAgICBMb2dnZXIuSW5mbygnVHJ5aW5nIHRvIG11dGUgY2FtZXJhLCBidXQgUGl4ZWxTdHJlYW1pbmcgaGFzIG5vIHZpZGVvIHRyYWNrLCBzbyBzZW5kaW5nIHZpZGVvIGlzIGFscmVhZHkgZGlzYWJsZWQuJyk7XG4gICAgfVxuICAgIHNldENhbWVyYU11dGVkKG11dGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBmb3IgKGNvbnN0IHRyYW5zY2VpdmVyIG9mIChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wZWVyQ29ubmVjdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdldFRyYW5zY2VpdmVycygpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBbXSkge1xuICAgICAgICAgICAgaWYgKFJUQ1V0aWxzLmNhblRyYW5zY2VpdmVyU2VuZFZpZGVvKHRyYW5zY2VpdmVyKSkge1xuICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRlci50cmFjay5lbmFibGVkID0gIW11dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZW1pdCBhbiBldmVudCB3aGVuIGF1dG8gY29ubmVjdGluZyBvY2N1cnNcbiAgICAgKi9cbiAgICBfb25XZWJSdGNBdXRvQ29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFdlYlJ0Y0F1dG9Db25uZWN0RXZlbnQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGVtaXQgYW4gZXZlbnQgZm9yIHdoZW4gU0RQIG5lZ290aWF0aW9uIGlzIGZ1bGx5IGZpbmlzaGVkLlxuICAgICAqL1xuICAgIF9vbldlYlJ0Y1NkcCgpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFdlYlJ0Y1NkcEV2ZW50KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBlbWl0IGFuIFNEUCBvZmZlciBhZnRlciBpdCBoYXMgYmVlbiBzZXQuXG4gICAgICovXG4gICAgX29uV2ViUnRjU2RwT2ZmZXIob2ZmZXIpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFdlYlJ0Y1NkcE9mZmVyRXZlbnQoeyBzZHA6IG9mZmVyIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZW1pdCBhbiBTRFAgYW5zd2VyIGFmdGVyIGl0IGhhcyBiZWVuIHNldC5cbiAgICAgKi9cbiAgICBfb25XZWJSdGNTZHBBbnN3ZXIoYW5zd2VyKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBXZWJSdGNTZHBBbnN3ZXJFdmVudCh7IHNkcDogYW5zd2VyIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gY2FsbCB0byBlbWl0IGEgYGxhdGVuY3lDYWxjdWxhdGVkYCBldmVudC5cbiAgICAgKi9cbiAgICBfb25MYXRlbmN5Q2FsY3VsYXRlZChsYXRlbmN5SW5mbykge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgTGF0ZW5jeUNhbGN1bGF0ZWRFdmVudCh7IGxhdGVuY3lJbmZvIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZW1pdHMgYSBTdHJlYW1Mb2FkaW5nIGV2ZW50XG4gICAgICovXG4gICAgX29uU3RyZWFtTG9hZGluZygpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFN0cmVhbUxvYWRpbmdFdmVudCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB0aGUgdmlkZW8gaXMgZGlzY29ubmVjdGVkIC0gZW1pdHMgZ2l2ZW4gZXZlbnRTdHJpbmcgb3IgYW4gb3ZlcnJpZGVcbiAgICAgKiBtZXNzYWdlIGZyb20gd2ViUnRjQ29udHJvbGxlciBpZiBvbmUgaGFzIGJlZW4gc2V0XG4gICAgICogQHBhcmFtIGV2ZW50U3RyaW5nIC0gYSBzdHJpbmcgZGVzY3JpYmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gY2xvc2VkXG4gICAgICogQHBhcmFtIGFsbG93Q2xpY2tUb1JlY29ubmVjdCAtIHRydWUgaWYgd2Ugd2FudCB0byBhbGxvdyB0aGUgdXNlciB0byByZXRyeSB0aGUgY29ubmVjdGlvbiB3aXRoIGEgY2xpY2tcbiAgICAgKi9cbiAgICBfb25EaXNjb25uZWN0KGV2ZW50U3RyaW5nLCBhbGxvd0NsaWNrVG9SZWNvbm5lY3QpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFdlYlJ0Y0Rpc2Nvbm5lY3RlZEV2ZW50KHtcbiAgICAgICAgICAgIGV2ZW50U3RyaW5nOiBldmVudFN0cmluZyxcbiAgICAgICAgICAgIGFsbG93Q2xpY2tUb1JlY29ubmVjdDogYWxsb3dDbGlja1RvUmVjb25uZWN0XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIFdlYiBSdGMgaXMgY29ubmVjdGluZ1xuICAgICAqL1xuICAgIF9vbldlYlJ0Y0Nvbm5lY3RpbmcoKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBXZWJSdGNDb25uZWN0aW5nRXZlbnQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hlbiBXZWIgUnRjIGhhcyBjb25uZWN0ZWRcbiAgICAgKi9cbiAgICBfb25XZWJSdGNDb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBXZWJSdGNDb25uZWN0ZWRFdmVudCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIFdlYiBSdGMgZmFpbHMgdG8gY29ubmVjdFxuICAgICAqL1xuICAgIF9vbldlYlJ0Y0ZhaWxlZCgpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFdlYlJ0Y0ZhaWxlZEV2ZW50KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgd2hlbiB0aGUgVmlkZW8gaGFzIGJlZW4gSW5pdGlhbGl6ZWRcbiAgICAgKi9cbiAgICBfb25WaWRlb0luaXRpYWxpemVkKCkge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgVmlkZW9Jbml0aWFsaXplZEV2ZW50KCkpO1xuICAgICAgICB0aGlzLl92aWRlb1N0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB1cCBmdW5jdGlvbmFsaXR5IHRvIGhhcHBlbiB3aGVuIHJlY2VpdmluZyBsYXRlbmN5IHRlc3QgcmVzdWx0c1xuICAgICAqIEBwYXJhbSBsYXRlbmN5IC0gbGF0ZW5jeSB0ZXN0IHJlc3VsdHMgb2JqZWN0XG4gICAgICovXG4gICAgX29uTGF0ZW5jeVRlc3RSZXN1bHQobGF0ZW5jeVRpbWluZ3MpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IExhdGVuY3lUZXN0UmVzdWx0RXZlbnQoeyBsYXRlbmN5VGltaW5ncyB9KSk7XG4gICAgfVxuICAgIF9vbkRhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgRGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlc3BvbnNlRXZlbnQoeyByZXNwb25zZSB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB1cCBmdW5jdGlvbmFsaXR5IHRvIGhhcHBlbiB3aGVuIHJlY2VpdmluZyB2aWRlbyBzdGF0aXN0aWNzXG4gICAgICogQHBhcmFtIHZpZGVvU3RhdHMgLSB2aWRlbyBzdGF0aXN0aWNzIGFzIGEgYWdncmVnYXRlIHN0YXRzIG9iamVjdFxuICAgICAqL1xuICAgIF9vblZpZGVvU3RhdHModmlkZW9TdGF0cykge1xuICAgICAgICAvLyBEdXJhdGlvblxuICAgICAgICBpZiAoIXRoaXMuX3ZpZGVvU3RhcnRUaW1lIHx8IHRoaXMuX3ZpZGVvU3RhcnRUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICB2aWRlb1N0YXRzLmhhbmRsZVNlc3Npb25TdGF0aXN0aWNzKHRoaXMuX3ZpZGVvU3RhcnRUaW1lLCB0aGlzLl9pbnB1dENvbnRyb2xsZXIsIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIudmlkZW9BdmdRcCk7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBTdGF0c1JlY2VpdmVkRXZlbnQoeyBhZ2dyZWdhdGVkU3RhdHM6IHZpZGVvU3RhdHMgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgZnVuY3Rpb25hbGl0eSB0byBoYXBwZW4gd2hlbiBjYWxjdWxhdGluZyB0aGUgYXZlcmFnZSB2aWRlbyBlbmNvZGVyIHFwXG4gICAgICogQHBhcmFtIFFQIC0gdGhlIHF1YWxpdHkgbnVtYmVyIG9mIHRoZSBzdHJlYW1cbiAgICAgKi9cbiAgICBfb25WaWRlb0VuY29kZXJBdmdRUChRUCkge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgVmlkZW9FbmNvZGVyQXZnUVBFdmVudCh7IGF2Z1FQOiBRUCB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB1cCBmdW5jdGlvbmFsaXR5IHRvIGhhcHBlbiB3aGVuIHJlY2VpdmluZyBhbmQgaGFuZGxpbmcgaW5pdGlhbCBzZXR0aW5ncyBmb3IgdGhlIFVFIGFwcFxuICAgICAqIEBwYXJhbSBzZXR0aW5ncyAtIGluaXRpYWwgVUUgYXBwIHNldHRpbmdzXG4gICAgICovXG4gICAgX29uSW5pdGlhbFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IEluaXRpYWxTZXR0aW5nc0V2ZW50KHsgc2V0dGluZ3MgfSkpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuUGl4ZWxTdHJlYW1pbmdTZXR0aW5ncykge1xuICAgICAgICAgICAgdGhpcy5hbGxvd0NvbnNvbGVDb21tYW5kcyA9IChfYSA9IHNldHRpbmdzLlBpeGVsU3RyZWFtaW5nU2V0dGluZ3MuQWxsb3dQaXhlbFN0cmVhbWluZ0NvbW1hbmRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93Q29uc29sZUNvbW1hbmRzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5JbmZvKCctQWxsb3dQaXhlbFN0cmVhbWluZ0NvbW1hbmRzPWZhbHNlLCBzZW5kaW5nIGFyYml0cmFyeSBjb25zb2xlIGNvbW1hbmRzIGZyb20gYnJvd3NlciB0byBVRSBpcyBkaXNhYmxlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VVcmxQYXJhbXMgPSB0aGlzLmNvbmZpZy51c2VVcmxQYXJhbXM7XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBJVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgICAgICBMb2dnZXIuSW5mbyhgdXNpbmcgVVJMIHBhcmFtZXRlcnMgJHt1c2VVcmxQYXJhbXN9YCk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5FbmNvZGVyU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIC8vIGhlcmUgd2Ugc2hvdWxkIGVpdGhlciBnZXQgTWluL01heFFQIGZyb20gUFMxXG4gICAgICAgICAgICAvLyBvciBNaW4vTWF4UXVhbGl0eSBmcm9tIFBTMlxuICAgICAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIHNldCBvbmUgc2V0IG9yIHRoZSBvdGhlciBhcyB0aGV5IGNvbnZlcmdlIGluIENvbXBhdFF1YWxpdHlNaW4vTWF4IGFuZFxuICAgICAgICAgICAgLy8gd2UgZG9udCB3YW50IHRvIGhhdmUgdGhlbSBjb25mbGljdCB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLkVuY29kZXJTZXR0aW5ncy5NaW5RUCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldE51bWVyaWNTZXR0aW5nKE51bWVyaWNQYXJhbWV0ZXJzLk1pblFQLCBcbiAgICAgICAgICAgICAgICAvLyBJZiBhIHNldHRpbmcgaXMgc2V0IGluIHRoZSBVUkwsIG1ha2Ugc3VyZSB3ZSByZXNwZWN0IHRoYXQgdmFsdWUgYXMgb3Bwb3NlZCB0byB3aGF0IHRoZSBhcHBsaWNhdGlvbiBzZW5kcyB1c1xuICAgICAgICAgICAgICAgIHVzZVVybFBhcmFtcyAmJiB1cmxQYXJhbXMuaGFzKE51bWVyaWNQYXJhbWV0ZXJzLk1pblFQKVxuICAgICAgICAgICAgICAgICAgICA/IE51bWJlci5wYXJzZUZsb2F0KHVybFBhcmFtcy5nZXQoTnVtZXJpY1BhcmFtZXRlcnMuTWluUVApKVxuICAgICAgICAgICAgICAgICAgICA6IHNldHRpbmdzLkVuY29kZXJTZXR0aW5ncy5NaW5RUCB8fCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXROdW1lcmljU2V0dGluZyhOdW1lcmljUGFyYW1ldGVycy5NYXhRUCwgdXNlVXJsUGFyYW1zICYmIHVybFBhcmFtcy5oYXMoTnVtZXJpY1BhcmFtZXRlcnMuTWF4UVApXG4gICAgICAgICAgICAgICAgICAgID8gTnVtYmVyLnBhcnNlRmxvYXQodXJsUGFyYW1zLmdldChOdW1lcmljUGFyYW1ldGVycy5NYXhRUCkpXG4gICAgICAgICAgICAgICAgICAgIDogc2V0dGluZ3MuRW5jb2RlclNldHRpbmdzLk1heFFQIHx8IDUxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5FbmNvZGVyU2V0dGluZ3MuTWluUXVhbGl0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldE51bWVyaWNTZXR0aW5nKE51bWVyaWNQYXJhbWV0ZXJzLk1pblF1YWxpdHksIFxuICAgICAgICAgICAgICAgIC8vIElmIGEgc2V0dGluZyBpcyBzZXQgaW4gdGhlIFVSTCwgbWFrZSBzdXJlIHdlIHJlc3BlY3QgdGhhdCB2YWx1ZSBhcyBvcHBvc2VkIHRvIHdoYXQgdGhlIGFwcGxpY2F0aW9uIHNlbmRzIHVzXG4gICAgICAgICAgICAgICAgdXNlVXJsUGFyYW1zICYmIHVybFBhcmFtcy5oYXMoTnVtZXJpY1BhcmFtZXRlcnMuTWluUXVhbGl0eSlcbiAgICAgICAgICAgICAgICAgICAgPyBOdW1iZXIucGFyc2VGbG9hdCh1cmxQYXJhbXMuZ2V0KE51bWVyaWNQYXJhbWV0ZXJzLk1pblF1YWxpdHkpKVxuICAgICAgICAgICAgICAgICAgICA6IHNldHRpbmdzLkVuY29kZXJTZXR0aW5ncy5NaW5RdWFsaXR5IHx8IDApO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldE51bWVyaWNTZXR0aW5nKE51bWVyaWNQYXJhbWV0ZXJzLk1heFF1YWxpdHksIHVzZVVybFBhcmFtcyAmJiB1cmxQYXJhbXMuaGFzKE51bWVyaWNQYXJhbWV0ZXJzLk1heFF1YWxpdHkpXG4gICAgICAgICAgICAgICAgICAgID8gTnVtYmVyLnBhcnNlRmxvYXQodXJsUGFyYW1zLmdldChOdW1lcmljUGFyYW1ldGVycy5NYXhRdWFsaXR5KSlcbiAgICAgICAgICAgICAgICAgICAgOiBzZXR0aW5ncy5FbmNvZGVyU2V0dGluZ3MuTWF4UXVhbGl0eSB8fCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlc2UgdHdvIGFyZSBqdXN0IHVzZWQgdG8gY29udmVyZ2UgcXVhbGl0eSBhbmQgcXAgYW5kIGJlaGF2ZSBzbGlnaHRseSBkaWZmZXJlbnRseSBzaW5jZSB0aGV5XG4gICAgICAgICAgICAvLyBzaG91bGRudCBleGlzdCBpbiBFbmNvZGVyU2V0dGluZ3NcbiAgICAgICAgICAgIGlmICh1c2VVcmxQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodXJsUGFyYW1zLmhhcyhOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWluKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXROdW1lcmljU2V0dGluZyhOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWluLCBOdW1iZXIucGFyc2VGbG9hdCh1cmxQYXJhbXMuZ2V0KE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNaW4pKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1cmxQYXJhbXMuaGFzKE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNYXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldE51bWVyaWNTZXR0aW5nKE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNYXgsIE51bWJlci5wYXJzZUZsb2F0KHVybFBhcmFtcy5nZXQoTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1heCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLldlYlJUQ1NldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXROdW1lcmljU2V0dGluZyhOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNaW5CaXRyYXRlLCB1c2VVcmxQYXJhbXMgJiYgdXJsUGFyYW1zLmhhcyhOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNaW5CaXRyYXRlKVxuICAgICAgICAgICAgICAgID8gTnVtYmVyLnBhcnNlRmxvYXQodXJsUGFyYW1zLmdldChOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNaW5CaXRyYXRlKSlcbiAgICAgICAgICAgICAgICA6IHNldHRpbmdzLldlYlJUQ1NldHRpbmdzLk1pbkJpdHJhdGUgLyAxMDAwIC8qIGJwcyB0byBrYnBzICovKTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNldE51bWVyaWNTZXR0aW5nKE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01heEJpdHJhdGUsIHVzZVVybFBhcmFtcyAmJiB1cmxQYXJhbXMuaGFzKE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01heEJpdHJhdGUpXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIucGFyc2VGbG9hdCh1cmxQYXJhbXMuZ2V0KE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01heEJpdHJhdGUpKVxuICAgICAgICAgICAgICAgIDogc2V0dGluZ3MuV2ViUlRDU2V0dGluZ3MuTWF4Qml0cmF0ZSAvIDEwMDAgLyogYnBzIHRvIGticHMgKi8pO1xuICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0TnVtZXJpY1NldHRpbmcoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDRlBTLCB1c2VVcmxQYXJhbXMgJiYgdXJsUGFyYW1zLmhhcyhOdW1lcmljUGFyYW1ldGVycy5XZWJSVENGUFMpXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIucGFyc2VGbG9hdCh1cmxQYXJhbXMuZ2V0KE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ0ZQUykpXG4gICAgICAgICAgICAgICAgOiBzZXR0aW5ncy5XZWJSVENTZXR0aW5ncy5GUFMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB1cCBmdW5jdGlvbmFsaXR5IHRvIGhhcHBlbiB3aGVuIHNldHRpbmcgcXVhbGl0eSBjb250cm9sIG93bmVyc2hpcCBvZiBhIHN0cmVhbVxuICAgICAqIEBwYXJhbSBoYXNRdWFsaXR5T3duZXJzaGlwIC0gZG9lcyB0aGlzIHVzZXIgaGF2ZSBxdWFsaXR5IG93bmVyc2hpcCBvZiB0aGUgc3RyZWFtIHRydWUgLyBmYWxzZVxuICAgICAqL1xuICAgIF9vblF1YWxpdHlDb250cm9sT3duZXJzaGlwKGhhc1F1YWxpdHlPd25lcnNoaXApIHtcbiAgICAgICAgdGhpcy5jb25maWcuc2V0RmxhZ0VuYWJsZWQoRmxhZ3MuSXNRdWFsaXR5Q29udHJvbGxlciwgaGFzUXVhbGl0eU93bmVyc2hpcCk7XG4gICAgfVxuICAgIF9vblBsYXllckNvdW50KHBsYXllckNvdW50KSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBQbGF5ZXJDb3VudEV2ZW50KHsgY291bnQ6IHBsYXllckNvdW50IH0pKTtcbiAgICB9XG4gICAgX29uU3Vic2NyaWJlRmFpbGVkKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmRpc3BhdGNoRXZlbnQobmV3IFN1YnNjcmliZUZhaWxlZEV2ZW50KHsgbWVzc2FnZTogbWVzc2FnZSB9KSk7XG4gICAgfVxuICAgIC8vIFNldHMgdXAgdG8gZW1pdCB0aGUgd2VicnRjIHRjcCByZWxheSBkZXRlY3QgZXZlbnRcbiAgICBfc2V0dXBXZWJSdGNUQ1BSZWxheURldGVjdGlvbihzdGF0c1JlY2VpdmVkRXZlbnQpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBhY3RpdmUgY2FuZGlkYXRlIHBhaXJcbiAgICAgICAgY29uc3QgYWN0aXZlQ2FuZGlkYXRlUGFpciA9IHN0YXRzUmVjZWl2ZWRFdmVudC5kYXRhLmFnZ3JlZ2F0ZWRTdGF0cy5nZXRBY3RpdmVDYW5kaWRhdGVQYWlyKCk7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBhY3RpdmUgY2FuZGlkYXRlIHBhaXIgaXMgbm90IG51bGxcbiAgICAgICAgaWYgKGFjdGl2ZUNhbmRpZGF0ZVBhaXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBsb2NhbCBjYW5kaWRhdGUgYXNzaWduZWQgdG8gdGhlIGFjdGl2ZSBjYW5kaWRhdGUgcGFpclxuICAgICAgICAgICAgY29uc3QgbG9jYWxDYW5kaWRhdGUgPSBzdGF0c1JlY2VpdmVkRXZlbnQuZGF0YS5hZ2dyZWdhdGVkU3RhdHMubG9jYWxDYW5kaWRhdGVzLmZpbmQoKGNhbmRpZGF0ZSkgPT4gY2FuZGlkYXRlLmlkID09IGFjdGl2ZUNhbmRpZGF0ZVBhaXIubG9jYWxDYW5kaWRhdGVJZCwgbnVsbCk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbG9jYWwgY2FuZGlkYXRlIGlzIG5vdCBudWxsLCBjYW5kaWRhdGUgdHlwZSBpcyByZWxheSBhbmQgdGhlIHJlbGF5IHByb3RvY29sIGlzIHRjcFxuICAgICAgICAgICAgaWYgKGxvY2FsQ2FuZGlkYXRlICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBsb2NhbENhbmRpZGF0ZS5jYW5kaWRhdGVUeXBlID09ICdyZWxheScgJiZcbiAgICAgICAgICAgICAgICBsb2NhbENhbmRpZGF0ZS5yZWxheVByb3RvY29sID09ICd0Y3AnKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgd2ViIHJ0YyB0Y3AgcmVsYXkgZGV0ZWN0ZWQgZXZlbnRcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChuZXcgV2ViUnRjVENQUmVsYXlEZXRlY3RlZEV2ZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGNoZWNrIGlzIGNvbXBsZXRlZCBhbmQgdGhlIHN0YXRzIGxpc3RlbiBldmVudCBjYW4gYmUgcmVtb3ZlZFxuICAgICAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0YXRzUmVjZWl2ZWQnLCB0aGlzLl9zZXR1cFdlYlJ0Y1RDUFJlbGF5RGV0ZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGEgY29ubmVjdGlvbiBsYXRlbmN5IHRlc3QuXG4gICAgICogTk9URTogVGhlcmUgYXJlIHBsYW5zIHRvIHJlZmFjdG9yIGFsbCByZXF1ZXN0KiBmdW5jdGlvbnMuIEV4cGVjdCBjaGFuZ2VzIGlmIHlvdSB1c2UgdGhpcyFcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHJlcXVlc3RMYXRlbmN5VGVzdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWJSdGNDb250cm9sbGVyLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zZW5kTGF0ZW5jeVRlc3QoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgYSBkYXRhIGNoYW5uZWwgbGF0ZW5jeSB0ZXN0LlxuICAgICAqIE5PVEU6IFRoZXJlIGFyZSBwbGFucyB0byByZWZhY3RvciBhbGwgcmVxdWVzdCogZnVuY3Rpb25zLiBFeHBlY3QgY2hhbmdlcyBpZiB5b3UgdXNlIHRoaXMhXG4gICAgICovXG4gICAgcmVxdWVzdERhdGFDaGFubmVsTGF0ZW5jeVRlc3QoY29uZmlnKSB7XG4gICAgICAgIGlmICghdGhpcy5fd2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZGF0YUNoYW5uZWxMYXRlbmN5VGVzdENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFDaGFubmVsTGF0ZW5jeVRlc3RDb250cm9sbGVyID0gbmV3IERhdGFDaGFubmVsTGF0ZW5jeVRlc3RDb250cm9sbGVyKHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZERhdGFDaGFubmVsTGF0ZW5jeVRlc3QuYmluZCh0aGlzLl93ZWJSdGNDb250cm9sbGVyKSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5kaXNwYXRjaEV2ZW50KG5ldyBEYXRhQ2hhbm5lbExhdGVuY3lUZXN0UmVzdWx0RXZlbnQoeyByZXN1bHQgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXNwb25zZScsICh7IGRhdGE6IHsgcmVzcG9uc2UgfSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWxMYXRlbmN5VGVzdENvbnRyb2xsZXIucmVjZWl2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNoYW5uZWxMYXRlbmN5VGVzdENvbnRyb2xsZXIuc3RhcnQoY29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBmb3IgdGhlIFVFIGFwcGxpY2F0aW9uIHRvIHNob3cgRlBTIGNvdW50ZXIuXG4gICAgICogTk9URTogVGhlcmUgYXJlIHBsYW5zIHRvIHJlZmFjdG9yIGFsbCByZXF1ZXN0KiBmdW5jdGlvbnMuIEV4cGVjdCBjaGFuZ2VzIGlmIHlvdSB1c2UgdGhpcyFcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHJlcXVlc3RTaG93RnBzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnNlbmRTaG93RnBzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGZvciBhIG5ldyBJRnJhbWUgZnJvbSB0aGUgVUUgYXBwbGljYXRpb24uXG4gICAgICogTk9URTogVGhlcmUgYXJlIHBsYW5zIHRvIHJlZmFjdG9yIGFsbCByZXF1ZXN0KiBmdW5jdGlvbnMuIEV4cGVjdCBjaGFuZ2VzIGlmIHlvdSB1c2UgdGhpcyFcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHJlcXVlc3RJZnJhbWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fd2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZElmcmFtZVJlcXVlc3QoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSB0byBVRSBhcHBsaWNhdGlvbi4gVGhlIGRhdGEgd2lsbCBiZSBydW4gdGhyb3VnaCBKU09OLnN0cmluZ2lmeSgpIHNvIGUuZy4gc3RyaW5nc1xuICAgICAqIGFuZCBhbnkgc2VyaWFsaXphYmxlIHBsYWluIEpTT04gb2JqZWN0cyB3aXRoIG5vIHJlY3VycmVuY2UgY2FuIGJlIHNlbnQuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBzdWNjZWVkZWQsIGZhbHNlIGlmIHJlamVjdGVkXG4gICAgICovXG4gICAgZW1pdFVJSW50ZXJhY3Rpb24oZGVzY3JpcHRvcikge1xuICAgICAgICBpZiAoIXRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIudmlkZW9QbGF5ZXIuaXNWaWRlb1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLmVtaXRVSUludGVyYWN0aW9uKGRlc2NyaXB0b3IpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIGNvbW1hbmQgdG8gVUUgYXBwbGljYXRpb24uIEJsb2NrcyBDb25zb2xlQ29tbWFuZCBkZXNjcmlwdG9ycyB1bmxlc3MgVUVcbiAgICAgKiBoYXMgc2lnbmFsZWQgdGhhdCBpdCBhbGxvd3MgY29uc29sZSBjb21tYW5kcy5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHN1Y2NlZWRlZCwgZmFsc2UgaWYgcmVqZWN0ZWRcbiAgICAgKi9cbiAgICBlbWl0Q29tbWFuZChkZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmICghdGhpcy5fd2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5hbGxvd0NvbnNvbGVDb21tYW5kcyAmJiAnQ29uc29sZUNvbW1hbmQnIGluIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLmVtaXRDb21tYW5kKGRlc2NyaXB0b3IpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIGNvbnNvbGUgY29tbWFuZCB0byBVRSBhcHBsaWNhdGlvbi4gT25seSBhbGxvd2VkIGlmIFVFIGhhcyBzaWduYWxlZCB0aGF0IGl0IGFsbG93c1xuICAgICAqIGNvbnNvbGUgY29tbWFuZHMuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBzdWNjZWVkZWQsIGZhbHNlIGlmIHJlamVjdGVkXG4gICAgICovXG4gICAgZW1pdENvbnNvbGVDb21tYW5kKGNvbW1hbmQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93Q29uc29sZUNvbW1hbmRzIHx8ICF0aGlzLl93ZWJSdGNDb250cm9sbGVyLnZpZGVvUGxheWVyLmlzVmlkZW9SZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5lbWl0Q29uc29sZUNvbW1hbmQoY29tbWFuZCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBVRSB0ZXh0IGJveCB3aWRnZXQuXG4gICAgICogQHBhcmFtIGNvbnRlbnRzIFRoZSBuZXcgY29udGVudHMgb2YgdGhlIFVFIHRleHQgYm94LlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG1lc3NhZ2UgY291bGQgYmUgc2VudC5cbiAgICAgKi9cbiAgICBzZW5kVGV4dGJveEVudHJ5KGNvbnRlbnRzKSB7XG4gICAgICAgIGlmICghdGhpcy5fd2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci5pc1ZpZGVvUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZFRleHRib3hFbnRyeShjb250ZW50cyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBVRSAtPiBicm93c2VyIHJlc3BvbnNlIGV2ZW50IGxpc3RlbmVyXG4gICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcmVzcG9uc2UgaGFuZGxlclxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIFRoZSBtZXRob2QgdG8gYmUgYWN0aXZhdGVkIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkXG4gICAgICovXG4gICAgYWRkUmVzcG9uc2VFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIucmVzcG9uc2VDb250cm9sbGVyLmFkZFJlc3BvbnNlRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIFVFIC0+IGJyb3dzZXIgcmVzcG9uc2UgZXZlbnQgbGlzdGVuZXJcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSByZXNwb25zZSBoYW5kbGVyXG4gICAgICovXG4gICAgcmVtb3ZlUmVzcG9uc2VFdmVudExpc3RlbmVyKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5yZXNwb25zZUNvbnRyb2xsZXIucmVtb3ZlUmVzcG9uc2VFdmVudExpc3RlbmVyKG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBhIG5ldyBldmVudC5cbiAgICAgKiBAcGFyYW0gZSBldmVudFxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudEVtaXR0ZXIuZGlzcGF0Y2hFdmVudChlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYW4gZXZlbnQgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0gdHlwZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXIuXG4gICAgICogQHBhcmFtIHR5cGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZS9kaXNhYmxlIFhSIG1vZGUuXG4gICAgICovXG4gICAgdG9nZ2xlWFIoKSB7XG4gICAgICAgIHRoaXMud2ViWHJDb250cm9sbGVyLnhyQ2xpY2tlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXNzIGluIGEgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBzaWduYWxsaW5nIHNlcnZlciBVUkwuXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgaWYgeW91IG5lZWQgdG8gcHJvZ3JhbW1hdGljYWxseSBjb25zdHJ1Y3QgeW91ciBzaWduYWxsaW5nIHNlcnZlciBVUkwuXG4gICAgICogQHBhcmFtIHNpZ25hbGxpbmdVcmxCdWlsZGVyRnVuYyBBIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzIGEgc2lnbmFsbGluZyBzZXJ2ZXIgdXJsLlxuICAgICAqL1xuICAgIHNldFNpZ25hbGxpbmdVcmxCdWlsZGVyKHNpZ25hbGxpbmdVcmxCdWlsZGVyRnVuYykge1xuICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnNpZ25hbGxpbmdVcmxCdWlsZGVyID0gc2lnbmFsbGluZ1VybEJ1aWxkZXJGdW5jO1xuICAgIH1cbiAgICBnZXQgd2ViUnRjQ29udHJvbGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBnZXR0ZXIgZm9yIHRoZSB3ZWJzb2NrZXQgY29udHJvbGxlci4gQWNjZXNzIHRvIHRoaXMgcHJvcGVydHkgYWxsb3dzIHlvdSB0byBzZW5kXG4gICAgICogY3VzdG9tIHdlYnNvY2tldCBtZXNzYWdlcy5cbiAgICAgKi9cbiAgICBnZXQgc2lnbmFsbGluZ1Byb3RvY29sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2ViUnRjQ29udHJvbGxlci5wcm90b2NvbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIGdldHRlciBmb3IgdGhlIHdlYlhyQ29udHJvbGxlciBjb250cm9sbGVyLiBVc2VkIGZvciBhbGwgWFIgZmVhdHVyZXMuXG4gICAgICovXG4gICAgZ2V0IHdlYlhyQ29udHJvbGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlYlhyQ29udHJvbGxlcjtcbiAgICB9XG4gICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihuYW1lLCBkaXJlY3Rpb24sIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIgJiYgdHlwZW9mIGhhbmRsZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBMb2dnZXIuV2FybmluZyhgVW5hYmxlIHRvIHJlZ2lzdGVyIGFuIHVuZGVmaW5lZCBoYW5kbGVyIGZvciAke25hbWV9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyICYmIHR5cGVvZiBoYW5kbGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5fd2ViUnRjQ29udHJvbGxlci5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKGRpcmVjdGlvbiwgbmFtZSwgKGRhdGEpID0+IHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcihuYW1lLCBkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl93ZWJSdGNDb250cm9sbGVyLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoZGlyZWN0aW9uLCBuYW1lLCAoZGF0YSkgPT4gaGFuZGxlcihkYXRhKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRvU3RyZWFtZXJIYW5kbGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzO1xuICAgIH1cbiAgICBpc1JlY29ubmVjdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlYlJ0Y0NvbnRyb2xsZXIuaXNSZWNvbm5lY3Rpbmc7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGl4ZWxTdHJlYW1pbmcuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42JztcbmV4cG9ydCBjbGFzcyBSZXNwb25zZUNvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJlc3BvbnNlRXZlbnRMaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIHJlc3BvbnNlIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSByZXNwb25zZSBtYXBcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSByZXNwb25zZVxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIFRoZSBtZXRob2QgdG8gYmUgYWN0aXZhdGVkIHdoZW4gdGhlIHJlc3BvbnNlIGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgYWRkUmVzcG9uc2VFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2VFdmVudExpc3RlbmVycy5zZXQobmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSByZXNwb25zZSBldmVudCBsaXN0ZW5lciB0byB0aGUgcmVzcG9uc2UgbWFwXG4gICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcmVzcG9uc2VcbiAgICAgKi9cbiAgICByZW1vdmVSZXNwb25zZUV2ZW50TGlzdGVuZXIobmFtZSkge1xuICAgICAgICB0aGlzLnJlc3BvbnNlRXZlbnRMaXN0ZW5lcnMuZGVsZXRlKG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYSByZXNwb25zZSB3aGVuIHJlY2VpdmluZyBvbmUgZm9ybSB0aGUgc3RyZWFtZXJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIERhdGEgcmVjZWl2ZWQgZnJvbSB0aGUgZGF0YSBjaGFubmVsIHdpdGggdGhlIGNvbW1hbmQgaW4gcXVlc3Rpb25cbiAgICAgKi9cbiAgICBvblJlc3BvbnNlKG1lc3NhZ2UpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ0RhdGFDaGFubmVsUmVjZWl2ZU1lc3NhZ2VUeXBlLlJlc3BvbnNlJyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTE2JykuZGVjb2RlKG1lc3NhZ2Uuc2xpY2UoMSkpO1xuICAgICAgICBMb2dnZXIuSW5mbyhyZXNwb25zZXMpO1xuICAgICAgICB0aGlzLnJlc3BvbnNlRXZlbnRMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyKHJlc3BvbnNlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlc3BvbnNlQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuZXhwb3J0IGNsYXNzIFNlbmRNZXNzYWdlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGFDaGFubmVsU2VuZGVyIC0gRGF0YSBjaGFubmVsIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHRvU3RyZWFtZXJNZXNzYWdlc01hcFByb3ZpZGVyIC0gU3RyZWFtIE1lc3NhZ2VzIGluc3RhbmNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGF0YUNoYW5uZWxTZW5kZXIsIHRvU3RyZWFtZXJNZXNzYWdlc01hcFByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWxTZW5kZXIgPSBkYXRhQ2hhbm5lbFNlbmRlcjtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNNYXBQcm92aWRlciA9IHRvU3RyZWFtZXJNZXNzYWdlc01hcFByb3ZpZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgbWVzc2FnZSB0byB0aGUgc3RyZWFtZXIgdGhyb3VnaCB0aGUgZGF0YSBjaGFubmVsXG4gICAgICogQHBhcmFtIG1lc3NhZ2VUeXBlIC0gdGhlIHR5cGUgb2YgbWVzc2FnZSB3ZSBhcmUgc2VuZGluZ1xuICAgICAqIEBwYXJhbSBtZXNzYWdlRGF0YSAtIHRoZSBtZXNzYWdlIGRhdGEgd2UgYXJlIHNlbmRpbmcgb3ZlciB0aGUgZGF0YSBjaGFubmVsXG4gICAgICogQHJldHVybnMgLSBuaWxcbiAgICAgKi9cbiAgICBzZW5kTWVzc2FnZVRvU3RyZWFtZXIobWVzc2FnZVR5cGUsIG1lc3NhZ2VEYXRhKSB7XG4gICAgICAgIGlmIChtZXNzYWdlRGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtZXNzYWdlRGF0YSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvU3RyZWFtZXJNZXNzYWdlcyA9IHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzTWFwUHJvdmlkZXIudG9TdHJlYW1lck1lc3NhZ2VzO1xuICAgICAgICBjb25zdCBtZXNzYWdlRm9ybWF0ID0gdG9TdHJlYW1lck1lc3NhZ2VzLmdldChtZXNzYWdlVHlwZSk7XG4gICAgICAgIGlmIChtZXNzYWdlRm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihgQXR0ZW1wdGVkIHRvIHNlbmQgYSBtZXNzYWdlIHRvIHRoZSBzdHJlYW1lciB3aXRoIG1lc3NhZ2UgdHlwZTogJHttZXNzYWdlVHlwZX0sIGJ1dCB0aGUgZnJvbnRlbmQgaGFzbid0IGJlZW4gY29uZmlndXJlZCB0byBzZW5kIHN1Y2ggYSBtZXNzYWdlLiBDaGVjayB5b3UndmUgYWRkZWQgdGhlIG1lc3NhZ2UgdHlwZSBpbiB5b3VyIGNwcGApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlRm9ybWF0LnN0cnVjdHVyZSAmJiBtZXNzYWdlRGF0YSAmJiBtZXNzYWdlRm9ybWF0LnN0cnVjdHVyZS5sZW5ndGggIT09IG1lc3NhZ2VEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBQcm92aWRlZCBtZXNzYWdlIGRhdGEgZG9lc24ndCBtYXRjaCBleHBlY3RlZCBsYXlvdXQuIEV4cGVjdGVkIFsgJHttZXNzYWdlRm9ybWF0LnN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIC5tYXAoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndWludDgnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50b1N0cmluZygpfSBdIGJ1dCByZWNlaXZlZCBbICR7bWVzc2FnZURhdGEubWFwKChlbGVtZW50KSA9PiB0eXBlb2YgZWxlbWVudCkudG9TdHJpbmcoKX0gXWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBieXRlTGVuZ3RoID0gMDtcbiAgICAgICAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgLy8gT25lIGxvb3AgdG8gY2FsY3VsYXRlIHRoZSBsZW5ndGggaW4gYnl0ZXMgb2YgYWxsIG9mIHRoZSBwcm92aWRlZCBkYXRhXG4gICAgICAgIG1lc3NhZ2VEYXRhLmZvckVhY2goKGVsZW1lbnQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2VGb3JtYXQuc3RydWN0dXJlW2lkeF07XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgICAgICAgICAgICAgYnl0ZUxlbmd0aCArPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGggKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGggKz0gODtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gMiBieXRlcyBmb3Igc3RyaW5nIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIC8vIDIgYnl0ZXMgcGVyIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgICAgYnl0ZUxlbmd0aCArPSAyICogdGV4dEVuY29kZXIuZW5jb2RlKGVsZW1lbnQpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcihieXRlTGVuZ3RoICsgMSkpO1xuICAgICAgICBkYXRhLnNldFVpbnQ4KDAsIG1lc3NhZ2VGb3JtYXQuaWQpO1xuICAgICAgICBsZXQgYnl0ZU9mZnNldCA9IDE7XG4gICAgICAgIG1lc3NhZ2VEYXRhLmZvckVhY2goKGVsZW1lbnQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2VGb3JtYXQuc3RydWN0dXJlW2lkeF07XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0VWludDgoYnl0ZU9mZnNldCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRVaW50MTYoYnl0ZU9mZnNldCwgZWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEludDE2KGJ5dGVPZmZzZXQsIGVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIGVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0RmxvYXQ2NChieXRlT2Zmc2V0LCBlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldCArPSA4O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNldFVpbnQxNihieXRlT2Zmc2V0LCBlbGVtZW50Lmxlbmd0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldFVpbnQxNihieXRlT2Zmc2V0LCBlbGVtZW50LmNoYXJDb2RlQXQoaSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGFDaGFubmVsU2VuZGVyLmNhblNlbmQoKSkge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oYERhdGEgY2hhbm5lbCBjYW5ub3Qgc2VuZCB5ZXQsIHNraXBwaW5nIHNlbmRpbmcgbWVzc2FnZTogJHttZXNzYWdlVHlwZX0gLSAke25ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyKX1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFDaGFubmVsU2VuZGVyLnNlbmREYXRhKGRhdGEuYnVmZmVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZW5kTWVzc2FnZUNvbnRyb2xsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42JztcbmV4cG9ydCBjbGFzcyBUb1N0cmVhbWVyTWVzc2FnZSB7XG59XG5leHBvcnQgY2xhc3MgU3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZnJvbVN0cmVhbWVyTWVzc2FnZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlIHRoZSBEZWZhdWx0IG1lc3NhZ2UgcHJvdG9jb2xcbiAgICAgKi9cbiAgICBwb3B1bGF0ZURlZmF1bHRQcm90b2NvbCgpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogQ29udHJvbCBNZXNzYWdlcy4gUmFuZ2UgPSAwLi40OS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnSUZyYW1lUmVxdWVzdCcsIHtcbiAgICAgICAgICAgIGlkOiAwLFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdSZXF1ZXN0UXVhbGl0eUNvbnRyb2wnLCB7XG4gICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgIHN0cnVjdHVyZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnRnBzUmVxdWVzdCcsIHtcbiAgICAgICAgICAgIGlkOiAyLFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdBdmVyYWdlQml0cmF0ZVJlcXVlc3QnLCB7XG4gICAgICAgICAgICBpZDogMyxcbiAgICAgICAgICAgIHN0cnVjdHVyZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnU3RhcnRTdHJlYW1pbmcnLCB7XG4gICAgICAgICAgICBpZDogNCxcbiAgICAgICAgICAgIHN0cnVjdHVyZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnU3RvcFN0cmVhbWluZycsIHtcbiAgICAgICAgICAgIGlkOiA1LFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdMYXRlbmN5VGVzdCcsIHtcbiAgICAgICAgICAgIGlkOiA2LFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3N0cmluZyddXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ1JlcXVlc3RJbml0aWFsU2V0dGluZ3MnLCB7XG4gICAgICAgICAgICBpZDogNyxcbiAgICAgICAgICAgIHN0cnVjdHVyZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnVGVzdEVjaG8nLCB7XG4gICAgICAgICAgICBpZDogOCxcbiAgICAgICAgICAgIHN0cnVjdHVyZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnRGF0YUNoYW5uZWxMYXRlbmN5VGVzdCcsIHtcbiAgICAgICAgICAgIGlkOiA5LFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgLypcbiAgICAgICAgICogSW5wdXQgTWVzc2FnZXMuIFJhbmdlID0gNTAuLjg5LlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gR2VuZXJpYyBJbnB1dCBNZXNzYWdlcy4gUmFuZ2UgPSA1MC4uNTkuXG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnVUlJbnRlcmFjdGlvbicsIHtcbiAgICAgICAgICAgIGlkOiA1MCxcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWydzdHJpbmcnXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdDb21tYW5kJywge1xuICAgICAgICAgICAgaWQ6IDUxLFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3N0cmluZyddXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ1RleHRib3hFbnRyeScsIHtcbiAgICAgICAgICAgIGlkOiA1MixcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWydzdHJpbmcnXVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gS2V5Ym9hcmQgSW5wdXQgTWVzc2FnZS4gUmFuZ2UgPSA2MC4uNjkuXG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnS2V5RG93bicsIHtcbiAgICAgICAgICAgIGlkOiA2MCxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAga2V5Q29kZSAgaXNSZXBlYXRcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWyd1aW50OCcsICd1aW50OCddXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ0tleVVwJywge1xuICAgICAgICAgICAgaWQ6IDYxLFxuICAgICAgICAgICAgLy8gICAgICAgICAgICBrZXlDb2RlXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsndWludDgnXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdLZXlQcmVzcycsIHtcbiAgICAgICAgICAgIGlkOiA2MixcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgY2hhcmNvZGVcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWyd1aW50MTYnXVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTW91c2UgSW5wdXQgTWVzc2FnZXMuIFJhbmdlID0gNzAuLjc5LlxuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ01vdXNlRW50ZXInLCB7XG4gICAgICAgICAgICBpZDogNzAsXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ01vdXNlTGVhdmUnLCB7XG4gICAgICAgICAgICBpZDogNzEsXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ01vdXNlRG93bicsIHtcbiAgICAgICAgICAgIGlkOiA3MixcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICBidXR0b24gICAgIHggICAgICAgICB5XG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsndWludDgnLCAndWludDE2JywgJ3VpbnQxNiddXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ01vdXNlVXAnLCB7XG4gICAgICAgICAgICBpZDogNzMsXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgYnV0dG9uICAgICB4ICAgICAgICAgeVxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3VpbnQ4JywgJ3VpbnQxNicsICd1aW50MTYnXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdNb3VzZU1vdmUnLCB7XG4gICAgICAgICAgICBpZDogNzQsXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgeCAgICAgICAgICAgeSAgICAgIGRlbHRhWCAgICBkZWx0YVlcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWyd1aW50MTYnLCAndWludDE2JywgJ2ludDE2JywgJ2ludDE2J11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnTW91c2VXaGVlbCcsIHtcbiAgICAgICAgICAgIGlkOiA3NSxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICBkZWx0YSAgICAgICB4ICAgICAgICB5XG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsnaW50MTYnLCAndWludDE2JywgJ3VpbnQxNiddXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlcy5zZXQoJ01vdXNlRG91YmxlJywge1xuICAgICAgICAgICAgaWQ6IDc2LFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGJ1dHRvbiAgICAgeCAgICAgICAgIHlcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWyd1aW50OCcsICd1aW50MTYnLCAndWludDE2J11cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRvdWNoIElucHV0IE1lc3NhZ2VzLiBSYW5nZSA9IDgwLi44OS5cbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdUb3VjaFN0YXJ0Jywge1xuICAgICAgICAgICAgaWQ6IDgwLFxuICAgICAgICAgICAgLy8gICAgICAgICAgbnVtdG91Y2hlcygxKSAgIHggICAgICAgeSAgICAgICAgaWR4ICAgICBmb3JjZSAgICAgdmFsaWRcbiAgICAgICAgICAgIHN0cnVjdHVyZTogWyd1aW50OCcsICd1aW50MTYnLCAndWludDE2JywgJ3VpbnQ4JywgJ3VpbnQ4JywgJ3VpbnQ4J11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnVG91Y2hFbmQnLCB7XG4gICAgICAgICAgICBpZDogODEsXG4gICAgICAgICAgICAvLyAgICAgICAgICBudW10b3VjaGVzKDEpICAgeCAgICAgICB5ICAgICAgICBpZHggICAgIGZvcmNlICAgICB2YWxpZFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3VpbnQ4JywgJ3VpbnQxNicsICd1aW50MTYnLCAndWludDgnLCAndWludDgnLCAndWludDgnXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdUb3VjaE1vdmUnLCB7XG4gICAgICAgICAgICBpZDogODIsXG4gICAgICAgICAgICAvLyAgICAgICAgICBudW10b3VjaGVzKDEpICAgeCAgICAgICB5ICAgICAgIGlkeCAgICAgIGZvcmNlICAgICB2YWxpZFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3VpbnQ4JywgJ3VpbnQxNicsICd1aW50MTYnLCAndWludDgnLCAndWludDgnLCAndWludDgnXVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gR2FtZXBhZCBJbnB1dCBNZXNzYWdlcy4gUmFuZ2UgPSA5MC4uOTlcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdHYW1lcGFkQ29ubmVjdGVkJywge1xuICAgICAgICAgICAgaWQ6IDkzLFxuICAgICAgICAgICAgc3RydWN0dXJlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdHYW1lcGFkQnV0dG9uUHJlc3NlZCcsIHtcbiAgICAgICAgICAgIGlkOiA5MCxcbiAgICAgICAgICAgIC8vICAgICAgICAgY3RybGVySWQgICBidXR0b24gIGlzUmVwZWF0XG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsndWludDgnLCAndWludDgnLCAndWludDgnXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KCdHYW1lcGFkQnV0dG9uUmVsZWFzZWQnLCB7XG4gICAgICAgICAgICBpZDogOTEsXG4gICAgICAgICAgICAvLyAgICAgICAgIGN0cmxlcklkICAgYnV0dG9uICBpc1JlcGVhdCgwKVxuICAgICAgICAgICAgc3RydWN0dXJlOiBbJ3VpbnQ4JywgJ3VpbnQ4JywgJ3VpbnQ4J11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnR2FtZXBhZEFuYWxvZycsIHtcbiAgICAgICAgICAgIGlkOiA5MixcbiAgICAgICAgICAgIC8vICAgICAgICAgY3RybGVySWQgICBidXR0b24gIGFuYWxvZ1ZhbHVlXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsndWludDgnLCAndWludDgnLCAnZG91YmxlJ11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzLnNldCgnR2FtZXBhZERpc2Nvbm5lY3RlZCcsIHtcbiAgICAgICAgICAgIGlkOiA5NCxcbiAgICAgICAgICAgIC8vICAgICAgICAgIGN0cmxlcklkXG4gICAgICAgICAgICBzdHJ1Y3R1cmU6IFsndWludDgnXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJNZXNzYWdlcy5zZXQoMCwgJ1F1YWxpdHlDb250cm9sT3duZXJzaGlwJyk7XG4gICAgICAgIHRoaXMuZnJvbVN0cmVhbWVyTWVzc2FnZXMuc2V0KDEsICdSZXNwb25zZScpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCgyLCAnQ29tbWFuZCcpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCgzLCAnRnJlZXplRnJhbWUnKTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJNZXNzYWdlcy5zZXQoNCwgJ1VuZnJlZXplRnJhbWUnKTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJNZXNzYWdlcy5zZXQoNSwgJ1ZpZGVvRW5jb2RlckF2Z1FQJyk7XG4gICAgICAgIHRoaXMuZnJvbVN0cmVhbWVyTWVzc2FnZXMuc2V0KDYsICdMYXRlbmN5VGVzdCcpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCg3LCAnSW5pdGlhbFNldHRpbmdzJyk7XG4gICAgICAgIHRoaXMuZnJvbVN0cmVhbWVyTWVzc2FnZXMuc2V0KDgsICdGaWxlRXh0ZW5zaW9uJyk7XG4gICAgICAgIHRoaXMuZnJvbVN0cmVhbWVyTWVzc2FnZXMuc2V0KDksICdGaWxlTWltZVR5cGUnKTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJNZXNzYWdlcy5zZXQoMTAsICdGaWxlQ29udGVudHMnKTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJNZXNzYWdlcy5zZXQoMTEsICdUZXN0RWNobycpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCgxMiwgJ0lucHV0Q29udHJvbE93bmVyc2hpcCcpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCgxMywgJ0dhbWVwYWRSZXNwb25zZScpO1xuICAgICAgICB0aGlzLmZyb21TdHJlYW1lck1lc3NhZ2VzLnNldCgxNCwgJ0RhdGFDaGFubmVsTGF0ZW5jeVRlc3QnKTtcbiAgICAgICAgdGhpcy5mcm9tU3RyZWFtZXJNZXNzYWdlcy5zZXQoMjU1LCAnUHJvdG9jb2wnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBtZXNzYWdlIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZURpcmVjdGlvbiAtIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG1lc3NhZ2U7IHRvU3RyZWFtZXIgb3IgZnJvbVN0cmVhbWVyXG4gICAgICogQHBhcmFtIG1lc3NhZ2VUeXBlIC0gdGhlIHR5cGUgb2YgdGhlIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gbWVzc2FnZUhhbmRsZXIgLSB0aGUgZnVuY3Rpb24gb3IgbWV0aG9kIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhpcyBoYW5kbGVyIGlzIGNhbGxlZFxuICAgICAqL1xuICAgIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIobWVzc2FnZURpcmVjdGlvbiwgbWVzc2FnZVR5cGUsIG1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZURpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXI6XG4gICAgICAgICAgICAgICAgdGhpcy50b1N0cmVhbWVySGFuZGxlcnMuc2V0KG1lc3NhZ2VUeXBlLCBtZXNzYWdlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyOlxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbVN0cmVhbWVySGFuZGxlcnMuc2V0KG1lc3NhZ2VUeXBlLCBtZXNzYWdlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIExvZ2dlci5JbmZvKGBVbmtub3duIG1lc3NhZ2UgZGlyZWN0aW9uICR7bWVzc2FnZURpcmVjdGlvbn1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVGhlIGVudW0gZm9yIG1lc3NhZ2UgZGlyZWN0aW9uc1xuICovXG5leHBvcnQgdmFyIE1lc3NhZ2VEaXJlY3Rpb247XG4oZnVuY3Rpb24gKE1lc3NhZ2VEaXJlY3Rpb24pIHtcbiAgICBNZXNzYWdlRGlyZWN0aW9uW01lc3NhZ2VEaXJlY3Rpb25bXCJUb1N0cmVhbWVyXCJdID0gMF0gPSBcIlRvU3RyZWFtZXJcIjtcbiAgICBNZXNzYWdlRGlyZWN0aW9uW01lc3NhZ2VEaXJlY3Rpb25bXCJGcm9tU3RyZWFtZXJcIl0gPSAxXSA9IFwiRnJvbVN0cmVhbWVyXCI7XG59KShNZXNzYWdlRGlyZWN0aW9uIHx8IChNZXNzYWdlRGlyZWN0aW9uID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5leHBvcnQgY2xhc3MgVG9TdHJlYW1lck1lc3NhZ2VzQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHNlbmRNZXNzYWdlQ29udHJvbGxlciAtIFN0cmVhbSBtZXNzYWdlIGNvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZW5kTWVzc2FnZUNvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIgPSBzZW5kTWVzc2FnZUNvbnRyb2xsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgUmVxdWVzdCB0byBUYWtlIFF1YWxpdHkgQ29udHJvbCB0byB0aGUgVUUgSW5zdGFuY2VcbiAgICAgKi9cbiAgICBTZW5kUmVxdWVzdFF1YWxpdHlDb250cm9sKCkge1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1JlcXVlc3RRdWFsaXR5Q29udHJvbCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIE1heCBGUFMgUmVxdWVzdCB0byB0aGUgVUUgSW5zdGFuY2VcbiAgICAgKi9cbiAgICBTZW5kTWF4RnBzUmVxdWVzdCgpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdGcHNSZXF1ZXN0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgQXZlcmFnZSBCaXRyYXRlIFJlcXVlc3QgdG8gdGhlIFVFIEluc3RhbmNlXG4gICAgICovXG4gICAgU2VuZEF2ZXJhZ2VCaXRyYXRlUmVxdWVzdCgpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdBdmVyYWdlQml0cmF0ZVJlcXVlc3QnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIFN0YXJ0IFN0cmVhbWluZyBNZXNzYWdlIHRvIHRoZSBVRSBJbnN0YW5jZVxuICAgICAqL1xuICAgIFNlbmRTdGFydFN0cmVhbWluZygpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdTdGFydFN0cmVhbWluZycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgU3RvcCBTdHJlYW1pbmcgTWVzc2FnZSB0byB0aGUgVUUgSW5zdGFuY2VcbiAgICAgKi9cbiAgICBTZW5kU3RvcFN0cmVhbWluZygpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdTdG9wU3RyZWFtaW5nJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBSZXF1ZXN0IEluaXRpYWwgU2V0dGluZ3MgdG8gdGhlIFVFIEluc3RhbmNlXG4gICAgICovXG4gICAgU2VuZFJlcXVlc3RJbml0aWFsU2V0dGluZ3MoKSB7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignUmVxdWVzdEluaXRpYWxTZXR0aW5ncycpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRvU3RyZWFtZXJNZXNzYWdlc0NvbnRyb2xsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42JztcbmV4cG9ydCBjbGFzcyBCcm93c2VyVXRpbHMge1xuICAgIHN0YXRpYyBnZXRTdXBwb3J0ZWRWaWRlb0NvZGVjcygpIHtcbiAgICAgICAgY29uc3QgYnJvd3NlclN1cHBvcnRlZENvZGVjcyA9IFtdO1xuICAgICAgICAvLyBUcnkgZ2V0IHRoZSBpbmZvIG5lZWRlZCBmcm9tIHRoZSBSVENSdHBSZWNlaXZlci4gVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBvbiBjaHJvbWVcbiAgICAgICAgaWYgKCFSVENSdHBSZWNlaXZlci5nZXRDYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgICAgIExvZ2dlci5XYXJuaW5nKCdSVENSdHBSZWNlaXZlci5nZXRDYXBhYmlsaXRpZXMgQVBJIGlzIG5vdCBhdmFpbGFibGUgaW4geW91ciBicm93c2VyLCBkZWZhdWx0aW5nIHRvIGd1ZXNzIHRoYXQgd2Ugc3VwcG9ydCBILjI2NC4nKTtcbiAgICAgICAgICAgIGJyb3dzZXJTdXBwb3J0ZWRDb2RlY3MucHVzaCgnSDI2NCBsZXZlbC1hc3ltbWV0cnktYWxsb3dlZD0xO3BhY2tldGl6YXRpb24tbW9kZT0xO3Byb2ZpbGUtbGV2ZWwtaWQ9NDJlMDFmJyk7XG4gICAgICAgICAgICByZXR1cm4gYnJvd3NlclN1cHBvcnRlZENvZGVjcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaGVyID0gLyhWUFxcZHxIMjZcXGR8QVYxKS4qLztcbiAgICAgICAgY29uc3QgY2FwYWJpbGl0aWVzID0gUlRDUnRwUmVjZWl2ZXIuZ2V0Q2FwYWJpbGl0aWVzKCd2aWRlbycpO1xuICAgICAgICBpZiAoIWNhcGFiaWxpdGllcykge1xuICAgICAgICAgICAgYnJvd3NlclN1cHBvcnRlZENvZGVjcy5wdXNoKCdIMjY0IGxldmVsLWFzeW1tZXRyeS1hbGxvd2VkPTE7cGFja2V0aXphdGlvbi1tb2RlPTE7cHJvZmlsZS1sZXZlbC1pZD00MmUwMWYnKTtcbiAgICAgICAgICAgIHJldHVybiBicm93c2VyU3VwcG9ydGVkQ29kZWNzO1xuICAgICAgICB9XG4gICAgICAgIGNhcGFiaWxpdGllcy5jb2RlY3MuZm9yRWFjaCgoY29kZWMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0ciA9IGNvZGVjLm1pbWVUeXBlLnNwbGl0KCcvJylbMV0gKyAnICcgKyAoY29kZWMuc2RwRm10cExpbmUgfHwgJycpO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaGVyLmV4ZWMoc3RyKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJyb3dzZXJTdXBwb3J0ZWRDb2RlY3MucHVzaChzdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJyb3dzZXJTdXBwb3J0ZWRDb2RlY3M7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnJvd3NlclV0aWxzLmpzLm1hcCIsIi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gQUZLIGRpc2Nvbm5lY3QgaXMgYWJvdXQgdG8gaGFwcGVuLlxuICogQ2FuIGJlIGNhbmNlbGxlZCBieSBjYWxsaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBwcm92aWRlZCBhcyBwYXJ0IG9mIHRoZSBldmVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIEFma1dhcm5pbmdBY3RpdmF0ZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ2Fma1dhcm5pbmdBY3RpdmF0ZScpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gdGhlIEFGSyBkaXNjb25uZWN0IGNvdW50ZG93biBpcyB1cGRhdGVkLlxuICovXG5leHBvcnQgY2xhc3MgQWZrV2FybmluZ1VwZGF0ZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ2Fma1dhcm5pbmdVcGRhdGUnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIEFGSyB3YXJuaW5nIGlzIGRlYWN0aXZhdGVkLlxuICovXG5leHBvcnQgY2xhc3MgQWZrV2FybmluZ0RlYWN0aXZhdGVFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ2Fma1dhcm5pbmdEZWFjdGl2YXRlJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBBRksgY291bnRkb3duIHJlYWNoZXMgMCBhbmQgdGhlIHVzZXIgaXMgZGlzY29ubmVjdGVkLlxuICovXG5leHBvcnQgY2xhc3MgQWZrVGltZWRPdXRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ2Fma1RpbWVkT3V0Jyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB3ZSByZWNlaXZlIG5ldyB2aWRlbyBxdWFsaXR5IHZhbHVlLlxuICovXG5leHBvcnQgY2xhc3MgVmlkZW9FbmNvZGVyQXZnUVBFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCd2aWRlb0VuY29kZXJBdmdRUCcpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIGFmdGVyIGEgV2ViUnRjIGNvbm5lY3Rpb24gaGFzIGJlZW4gbmVnb3RpYXRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYlJ0Y1NkcEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignd2ViUnRjU2RwJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXIgdGhlIFNEUCBhbnN3ZXIgaXMgc2V0LlxuICovXG5leHBvcnQgY2xhc3MgV2ViUnRjU2RwQW5zd2VyRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignd2ViUnRjU2RwQW5zd2VyJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXIgdGhlIFNEUCBvZmZlciBpcyBzZXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJSdGNTZHBPZmZlckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ3dlYlJ0Y1NkcE9mZmVyJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBhdXRvIGNvbm5lY3RpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJSdGNBdXRvQ29ubmVjdEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignd2ViUnRjQXV0b0Nvbm5lY3QnKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHNlbmRpbmcgYSBXZWJSdGMgb2ZmZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJSdGNDb25uZWN0aW5nRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCd3ZWJSdGNDb25uZWN0aW5nJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBXZWJSdGMgY29ubmVjdGlvbiBoYXMgYmVlbiBlc3RhYmxpc2hlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYlJ0Y0Nvbm5lY3RlZEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignd2ViUnRjQ29ubmVjdGVkJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgaWYgV2ViUnRjIGNvbm5lY3Rpb24gaGFzIGZhaWxlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYlJ0Y0ZhaWxlZEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignd2ViUnRjRmFpbGVkJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgaWYgV2ViUnRjIGNvbm5lY3Rpb24gaXMgZGlzY29ubmVjdGVkLlxuICovXG5leHBvcnQgY2xhc3MgV2ViUnRjRGlzY29ubmVjdGVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignd2ViUnRjRGlzY29ubmVjdGVkJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBSVENEYXRhQ2hhbm5lbCBpcyBvcGVuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhQ2hhbm5lbE9wZW5FdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdkYXRhQ2hhbm5lbE9wZW4nKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIFJUQ0RhdGFDaGFubmVsIGlzIGNsb3NlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFDaGFubmVsQ2xvc2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdkYXRhQ2hhbm5lbENsb3NlJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgb24gUlRDRGF0YUNoYW5uZWwgZXJyb3JzLlxuICovXG5leHBvcnQgY2xhc3MgRGF0YUNoYW5uZWxFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ2RhdGFDaGFubmVsRXJyb3InKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHRoZSB2aWRlbyBzdHJlYW0gaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBWaWRlb0luaXRpYWxpemVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCd2aWRlb0luaXRpYWxpemVkJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB2aWRlbyBzdHJlYW0gbG9hZGluZyBzdGFydHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1Mb2FkaW5nRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW1Mb2FkaW5nJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB2aWRlbyBzdHJlYW0gbG9hZGluZyBoYXMgZmluaXNoZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1QcmVDb25uZWN0RXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW1Db25uZWN0Jyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB2aWRlbyBzdHJlYW0gaGFzIHN0b3BwZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1QcmVEaXNjb25uZWN0RXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW1EaXNjb25uZWN0Jyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB2aWRlbyBzdHJlYW0gaXMgcmVjb25uZWN0aW5nLlxuICovXG5leHBvcnQgY2xhc3MgU3RyZWFtUmVjb25uZWN0RXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW1SZWNvbm5lY3QnKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBpZiB0aGVyZSBhcmUgZXJyb3JzIGxvYWRpbmcgdGhlIHZpZGVvIHN0cmVhbS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBsYXlTdHJlYW1FcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ3BsYXlTdHJlYW1FcnJvcicpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIGJlZm9yZSB0cnlpbmcgdG8gc3RhcnQgdmlkZW8gcGxheWJhY2suXG4gKi9cbmV4cG9ydCBjbGFzcyBQbGF5U3RyZWFtRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdwbGF5U3RyZWFtJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgaWYgdGhlIGJyb3dzZXIgcmVqZWN0cyB2aWRlbyBwbGF5YmFjay4gQ2FuIGhhcHBlbiBmb3IgZXhhbXBsZSBpZlxuICogdmlkZW8gYXV0by1wbGF5IHdpdGhvdXQgdXNlciBpbnRlcmFjdGlvbiBpcyByZWZ1c2VkIGJ5IHRoZSBicm93c2VyLlxuICovXG5leHBvcnQgY2xhc3MgUGxheVN0cmVhbVJlamVjdGVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigncGxheVN0cmVhbVJlamVjdGVkJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiByZWNlaXZpbmcgYSBmdWxsIEZyZWV6ZUZyYW1lIGltYWdlIGZyb20gVUUuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2FkRnJlZXplRnJhbWVFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdsb2FkRnJlZXplRnJhbWUnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHJlY2VpdmluZyBVbmZyZWV6ZUZyYW1lIG1lc3NhZ2UgZnJvbSBVRSBhbmQgdmlkZW8gcGxheWJhY2sgaXMgYWJvdXQgdG8gYmUgcmVzdW1lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEhpZGVGcmVlemVGcmFtZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignaGlkZUZyZWV6ZUZyYW1lJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiByZWNlaXZpbmcgV2ViUlRDIHN0YXRpc3RpY3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGF0c1JlY2VpdmVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignc3RhdHNSZWNlaXZlZCcpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gc3RyZWFtZXIgbGlzdCBjaGFuZ2VzLlxuICovXG5leHBvcnQgY2xhc3MgU3RyZWFtZXJMaXN0TWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbWVyTGlzdE1lc3NhZ2UnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIGEgc3Vic2NyaWJlZCB0byBzdHJlYW1lcidzIGlkIGNoYW5nZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1lcklEQ2hhbmdlZE1lc3NhZ2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdTdHJlYW1lcklEQ2hhbmdlZE1lc3NhZ2UnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHJlY2VpdmluZyBsYXRlbmN5IHRlc3QgcmVzdWx0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIExhdGVuY3lUZXN0UmVzdWx0RXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignbGF0ZW5jeVRlc3RSZXN1bHQnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBldmVyeXRpbWUgbGF0ZW5jeSBpcyBjYWxjdWxhdGVkIHVzaW5nIHRoZSBXZWJSVEMgc3RhdHMgQVBJLlxuICovXG5leHBvcnQgY2xhc3MgTGF0ZW5jeUNhbGN1bGF0ZWRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdsYXRlbmN5Q2FsY3VsYXRlZCcpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gd2UgcmVjZWl2ZSB0aGUgXCJvblNjcmVlbktleWJvYXJkXCIgY29tbWFuZCBmcm9tIFVFLlxuICovXG5leHBvcnQgY2xhc3MgU2hvd09uU2NyZWVuS2V5Ym9hcmRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdzaG93T25TY3JlZW5LZXlib2FyZCcpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gcmVjZWl2aW5nIGRhdGEgY2hhbm5lbCBsYXRlbmN5IHRlc3QgcmVzcG9uc2UgZnJvbSBzZXJ2ZXIuXG4gKiBUaGlzIGV2ZW50IGlzIGhhbmRsZWQgYnkgRGF0YUNoYW5uZWxMYXRlbmN5VGVzdENvbnRyb2xsZXJcbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXNwb25zZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ2RhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXNwb25zZScpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gZGF0YSBjaGFubmVsIGxhdGVuY3kgdGVzdCByZXN1bHRzIGFyZSByZWFkeS5cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXN1bHRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCdkYXRhQ2hhbm5lbExhdGVuY3lUZXN0UmVzdWx0Jyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFN1YnNjcmliZUZhaWxlZEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ3N1YnNjcmliZUZhaWxlZCcpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gcmVjZWl2aW5nIGluaXRpYWwgc2V0dGluZ3MgZnJvbSBVRS5cbiAqL1xuZXhwb3J0IGNsYXNzIEluaXRpYWxTZXR0aW5nc0V2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ2luaXRpYWxTZXR0aW5ncycpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gUGl4ZWxTdHJlYW1pbmcgc2V0dGluZ3MgY2hhbmdlLlxuICovXG5leHBvcnQgY2xhc3MgU2V0dGluZ3NDaGFuZ2VkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcignc2V0dGluZ3NDaGFuZ2VkJyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBFdmVudCBlbWl0dGVkIHdoZW4gYW4gWFIgU2Vzc2lvbiBzdGFydHNcbiAqL1xuZXhwb3J0IGNsYXNzIFhyU2Vzc2lvblN0YXJ0ZWRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3hyU2Vzc2lvblN0YXJ0ZWQnKTtcbiAgICB9XG59XG4vKipcbiAqIEV2ZW50IGVtaXR0ZWQgd2hlbiBhbiBYUiBTZXNzaW9uIGVuZHNcbiAqL1xuZXhwb3J0IGNsYXNzIFhyU2Vzc2lvbkVuZGVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCd4clNlc3Npb25FbmRlZCcpO1xuICAgIH1cbn1cbi8qKlxuICogRXZlbnQgZW1pdHRlZCB3aGVuIGFuIFhSIEZyYW1lIGlzIGNvbXBsZXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBYckZyYW1lRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigneHJGcmFtZScpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gcmVjZWl2aW5nIGEgcGxheWVyIGNvdW50IGZyb20gdGhlIHNpZ25hbGxpbmcgc2VydmVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQbGF5ZXJDb3VudEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoJ3BsYXllckNvdW50Jyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB0aGUgd2ViUlRDIGNvbm5lY3Rpb25zIGlzIHJlbGF5ZWQgb3ZlciBUQ1AuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJSdGNUQ1BSZWxheURldGVjdGVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCd3ZWJSdGNUQ1BSZWxheURldGVjdGVkJyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFBpeGVsU3RyZWFtaW5nRXZlbnRFbWl0dGVyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGEgbmV3IGV2ZW50LlxuICAgICAqIEBwYXJhbSBlIGV2ZW50XG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBkaXNwYXRjaEV2ZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGhhbmRsZXIuXG4gICAgICogQHBhcmFtIHR5cGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXIuXG4gICAgICogQHBhcmFtIHR5cGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudEVtaXR0ZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42Jztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcG9wdWxhdGUgZmlsZSBpbmZvcm1hdGlvbiBmcm9tIGJ5dGUgYnVmZmVycy5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVVdGlsIHtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgYSBmaWxlcyBleHRlbnNpb24gd2hlbiByZWNlaXZlZCBvdmVyIGRhdGEgY2hhbm5lbFxuICAgICAqIEBwYXJhbSB2aWV3IC0gdGhlIGZpbGUgZXh0ZW5zaW9uIGRhdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0RXh0ZW5zaW9uRnJvbUJ5dGVzKHZpZXcsIGZpbGUpIHtcbiAgICAgICAgLy8gUmVzZXQgZmlsZSBpZiB3ZSBnb3QgYSBmaWxlIG1lc3NhZ2UgYW5kIHdlIGFyZSBub3QgXCJyZWNlaXZpbmdcIiBpdCB5ZXRcbiAgICAgICAgaWYgKCFmaWxlLnJlY2VpdmluZykge1xuICAgICAgICAgICAgZmlsZS5taW1ldHlwZSA9ICcnO1xuICAgICAgICAgICAgZmlsZS5leHRlbnNpb24gPSAnJztcbiAgICAgICAgICAgIGZpbGUucmVjZWl2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGZpbGUudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZpbGUuY2h1bmtzID0gMDtcbiAgICAgICAgICAgIGZpbGUuZGF0YSA9IFtdO1xuICAgICAgICAgICAgZmlsZS50aW1lc3RhbXBTdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ1JlY2VpdmVkIGZpcnN0IGNodW5rIG9mIGZpbGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHRlbnNpb25Bc1N0cmluZyA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTE2JykuZGVjb2RlKHZpZXcuc2xpY2UoMSkpO1xuICAgICAgICBMb2dnZXIuSW5mbyhleHRlbnNpb25Bc1N0cmluZyk7XG4gICAgICAgIGZpbGUuZXh0ZW5zaW9uID0gZXh0ZW5zaW9uQXNTdHJpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBhIGZpbGVzIG1pbWUgdHlwZSB3aGVuIHJlY2VpdmVkIG92ZXIgZGF0YSBjaGFubmVsXG4gICAgICogQHBhcmFtIHZpZXcgLSB0aGUgZmlsZSBtaW1lIHR5cGUgZGF0YVxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRNaW1lVHlwZUZyb21CeXRlcyh2aWV3LCBmaWxlKSB7XG4gICAgICAgIC8vIFJlc2V0IGZpbGUgaWYgd2UgZ290IGEgZmlsZSBtZXNzYWdlIGFuZCB3ZSBhcmUgbm90IFwicmVjZWl2aW5nXCIgaXQgeWV0XG4gICAgICAgIGlmICghZmlsZS5yZWNlaXZpbmcpIHtcbiAgICAgICAgICAgIGZpbGUubWltZXR5cGUgPSAnJztcbiAgICAgICAgICAgIGZpbGUuZXh0ZW5zaW9uID0gJyc7XG4gICAgICAgICAgICBmaWxlLnJlY2VpdmluZyA9IHRydWU7XG4gICAgICAgICAgICBmaWxlLnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICBmaWxlLmNodW5rcyA9IDA7XG4gICAgICAgICAgICBmaWxlLmRhdGEgPSBbXTtcbiAgICAgICAgICAgIGZpbGUudGltZXN0YW1wU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdSZWNlaXZlZCBmaXJzdCBjaHVuayBvZiBmaWxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWltZUFzU3RyaW5nID0gbmV3IFRleHREZWNvZGVyKCd1dGYtMTYnKS5kZWNvZGUodmlldy5zbGljZSgxKSk7XG4gICAgICAgIExvZ2dlci5JbmZvKG1pbWVBc1N0cmluZyk7XG4gICAgICAgIGZpbGUubWltZXR5cGUgPSBtaW1lQXNTdHJpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBhIGZpbGVzIGNvbnRlbnRzIHdoZW4gcmVjZWl2ZWQgb3ZlciBkYXRhIGNoYW5uZWxcbiAgICAgKiBAcGFyYW0gdmlldyAtIHRoZSBmaWxlIGNvbnRlbnRzIGRhdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0Q29udGVudHNGcm9tQnl0ZXModmlldywgZmlsZSkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IHJlY2VpdmVkIHRoZSBpbml0aWFsIHNldHVwIGluc3RydWN0aW9ucywgcmV0dXJuXG4gICAgICAgIGlmICghZmlsZS5yZWNlaXZpbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHR5cGVTaXplID0gMTtcbiAgICAgICAgY29uc3QgaW50U2l6ZSA9IDQ7XG4gICAgICAgIGNvbnN0IG1heE1lc3NhZ2VTaXplID0gMTYgKiAxMDI0O1xuICAgICAgICBjb25zdCBoZWFkZXJTaXplID0gdHlwZVNpemUgKyBpbnRTaXplO1xuICAgICAgICBjb25zdCBtYXhQYXlsb2FkU2l6ZSA9IG1heE1lc3NhZ2VTaXplIC0gaGVhZGVyU2l6ZTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRvdGFsIG51bWJlciBvZiBjaHVua3MgZnJvbSB0aGUgdG90YWwgZmlsZSBzaXplXG4gICAgICAgIGZpbGUuY2h1bmtzID0gTWF0aC5jZWlsKG5ldyBEYXRhVmlldyh2aWV3LnNsaWNlKHR5cGVTaXplLCBoZWFkZXJTaXplKS5idWZmZXIpLmdldEludDMyKDAsIHRydWUpIC8gbWF4UGF5bG9hZFNpemUpO1xuICAgICAgICAvLyBHZXQgdGhlIGZpbGUgcGFydCBvZiB0aGUgcGF5bG9hZFxuICAgICAgICBjb25zdCBmaWxlQnl0ZXMgPSB2aWV3LnNsaWNlKGhlYWRlclNpemUpO1xuICAgICAgICAvLyBBcHBlbmQgdG8gZXhpc3RpbmcgZGF0YSB0aGF0IGhvbGRzIHRoZSBmaWxlXG4gICAgICAgIGZpbGUuZGF0YS5wdXNoKGZpbGVCeXRlcyk7XG4gICAgICAgIC8vIFVuY29tbWVudCBmb3IgZGVidWdcbiAgICAgICAgTG9nZ2VyLkluZm8oYFJlY2VpdmVkIGZpbGUgY2h1bms6ICR7ZmlsZS5kYXRhLmxlbmd0aH0vJHtmaWxlLmNodW5rc31gKTtcbiAgICAgICAgaWYgKGZpbGUuZGF0YS5sZW5ndGggPT09IGZpbGUuY2h1bmtzKSB7XG4gICAgICAgICAgICBmaWxlLnJlY2VpdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgZmlsZS52YWxpZCA9IHRydWU7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnUmVjZWl2ZWQgY29tcGxldGUgZmlsZScpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmZXJEdXJhdGlvbiA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gZmlsZS50aW1lc3RhbXBTdGFydDtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZmVyQml0cmF0ZSA9IE1hdGgucm91bmQoKGZpbGUuY2h1bmtzICogbWF4TWVzc2FnZVNpemUpIC8gdHJhbnNmZXJEdXJhdGlvbik7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbyhgQXZlcmFnZSB0cmFuc2ZlciBiaXRyYXRlOiAke3RyYW5zZmVyQml0cmF0ZX1rYi9zIG92ZXIgJHt0cmFuc2ZlckR1cmF0aW9uIC8gMTAwMH0gc2Vjb25kc2ApO1xuICAgICAgICAgICAgLy8gRmlsZSByZWNvbnN0cnVjdGlvblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFeGFtcGxlIGNvZGUgdG8gcmVjb25zdHJ1Y3QgdGhlIGZpbGVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGlzIGNvZGUgcmVjb25zdHJ1Y3RzIHRoZSByZWNlaXZlZCBkYXRhIGludG8gdGhlIG9yaWdpbmFsIGZpbGUgYmFzZWQgb24gdGhlIG1pbWUgdHlwZSBhbmQgZXh0ZW5zaW9uIHByb3ZpZGVkIGFuZCB0aGVuIGRvd25sb2FkcyB0aGUgcmVjb25zdHJ1Y3RlZCBmaWxlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHJlY2VpdmVkID0gbmV3IEJsb2IoZmlsZS5kYXRhLCB7IHR5cGU6IGZpbGUubWltZXR5cGUgfSk7XG4gICAgICAgICAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBVUkwuY3JlYXRlT2JqZWN0VVJMKHJlY2VpdmVkKSk7XG4gICAgICAgICAgICBhLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBgdHJhbnNmZXIuJHtmaWxlLmV4dGVuc2lvbn1gKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGEpO1xuICAgICAgICAgICAgLy8gaWYgeW91IGFyZSBzbyBpbmNsaW5lZCB0byBtYWtlIGl0IGF1dG8tZG93bmxvYWQsIGRvIHNvbWV0aGluZyBsaWtlOiBhLmNsaWNrKCk7XG4gICAgICAgICAgICBhLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbGUuZGF0YS5sZW5ndGggPiBmaWxlLmNodW5rcykge1xuICAgICAgICAgICAgZmlsZS5yZWNlaXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihgUmVjZWl2ZWQgYmlnZ2VyIGZpbGUgdGhhbiBhZHZlcnRpc2VkOiAke2ZpbGUuZGF0YS5sZW5ndGh9LyR7ZmlsZS5jaHVua3N9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgdGVtcGxhdGUgZm9yIGEgZG93bmxvYWRlZCBmaWxlXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWxlVGVtcGxhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1pbWV0eXBlID0gJyc7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gJyc7XG4gICAgICAgIHRoaXMucmVjZWl2aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gMDtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWxlVXRpbC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBBIGNhc2UgaW5zZW5zaXRpdmUsIHBhcnRpYWwgaW1wbGVtZW50YXRpb24gb2YgVVJMU2VhcmNoUGFyYW1zXG4gKi9cbmV4cG9ydCBjbGFzcyBJVVJMU2VhcmNoUGFyYW1zIHtcbiAgICBjb25zdHJ1Y3RvcihzZWFyY2gpIHtcbiAgICAgICAgdGhpcy5fdXJsUGFyYW1zID0ge307XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKTtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIHVybFBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5fdXJsUGFyYW1zW25hbWUudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXMobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpIGluIHRoaXMuX3VybFBhcmFtcztcbiAgICB9XG4gICAgZ2V0KG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXJsUGFyYW1zW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SVVSTFNlYXJjaFBhcmFtcy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBDb252ZXJ0cyBjb29yZGluYXRlcyBmcm9tIGVsZW1lbnQgcmVsYXRpdmUgY29vcmRpbmF0ZXMgdG8gdmFsdWVzIG5vcm1hbGl6ZWQgd2l0aGluIHRoZSB2YWx1ZSByYW5nZSBvZiBhIHNob3J0IChhbmQgYmFjayBhZ2FpbilcbiAqL1xuZXhwb3J0IGNsYXNzIElucHV0Q29vcmRUcmFuc2xhdG9yIHtcbiAgICAvLyB3ZSBkb250IHVzZSBhIGNvbnN0cnVjdG9yIGhlcmUgYmVjYXVzZSB0aGUgb2JqZWN0IGlzIGNyZWF0ZWQgYW5kIHBhc3NlZCBhcm91bmQgdG8gdmFyaW91cyBsb2NhdGlvbnNcbiAgICAvLyBwb3NzaWJseSBiZWZvcmUgdGhpcyBtZXRob2QgaXMgY2FsbGVkLlxuICAgIHJlY29uZmlndXJlKHBsYXllclNpemUsIHZpZGVvU2l6ZSkge1xuICAgICAgICBjb25zdCBwbGF5ZXJBc3BlY3RSYXRpbyA9IHBsYXllclNpemUuaGVpZ2h0IC8gcGxheWVyU2l6ZS53aWR0aDtcbiAgICAgICAgY29uc3QgdmlkZW9Bc3BlY3RSYXRpbyA9IHZpZGVvU2l6ZS5oZWlnaHQgLyB2aWRlb1NpemUud2lkdGg7XG4gICAgICAgIHRoaXMucGxheWVySXNMYXJnZXIgPSBwbGF5ZXJBc3BlY3RSYXRpbyA+IHZpZGVvQXNwZWN0UmF0aW87XG4gICAgICAgIHRoaXMucGxheWVyU2l6ZSA9IHBsYXllclNpemU7XG4gICAgICAgIHRoaXMucmF0aW8gPSB0aGlzLnBsYXllcklzTGFyZ2VyXG4gICAgICAgICAgICA/IHBsYXllckFzcGVjdFJhdGlvIC8gdmlkZW9Bc3BlY3RSYXRpb1xuICAgICAgICAgICAgOiB2aWRlb0FzcGVjdFJhdGlvIC8gcGxheWVyQXNwZWN0UmF0aW87XG4gICAgfVxuICAgIHRyYW5zbGF0ZVVuc2lnbmVkKHgsIHkpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFggPSB0aGlzLnBsYXllcklzTGFyZ2VyXG4gICAgICAgICAgICA/IHggLyB0aGlzLnBsYXllclNpemUud2lkdGhcbiAgICAgICAgICAgIDogdGhpcy5yYXRpbyAqICh4IC8gdGhpcy5wbGF5ZXJTaXplLndpZHRoIC0gMC41KSArIDAuNTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFkgPSB0aGlzLnBsYXllcklzTGFyZ2VyXG4gICAgICAgICAgICA/IHRoaXMucmF0aW8gKiAoeSAvIHRoaXMucGxheWVyU2l6ZS5oZWlnaHQgLSAwLjUpICsgMC41XG4gICAgICAgICAgICA6IHkgLyB0aGlzLnBsYXllclNpemUuaGVpZ2h0O1xuICAgICAgICBpZiAobm9ybWFsaXplZFggPCAwLjAgfHwgbm9ybWFsaXplZFggPiAxLjAgfHwgbm9ybWFsaXplZFkgPCAwLjAgfHwgbm9ybWFsaXplZFkgPiAxLjApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGluUmFuZ2U6IGZhbHNlLCB4OiA2NTUzNSwgeTogNjU1MzUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGluUmFuZ2U6IHRydWUsIHg6IG5vcm1hbGl6ZWRYICogNjU1MzYsIHk6IG5vcm1hbGl6ZWRZICogNjU1MzYgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFuc2xhdGVTaWduZWQoeCwgeSkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkWCA9IHRoaXMucGxheWVySXNMYXJnZXJcbiAgICAgICAgICAgID8geCAvICgwLjUgKiB0aGlzLnBsYXllclNpemUud2lkdGgpXG4gICAgICAgICAgICA6ICh0aGlzLnJhdGlvICogeCkgLyAoMC41ICogdGhpcy5wbGF5ZXJTaXplLndpZHRoKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFkgPSB0aGlzLnBsYXllcklzTGFyZ2VyXG4gICAgICAgICAgICA/ICh0aGlzLnJhdGlvICogeSkgLyAoMC41ICogdGhpcy5wbGF5ZXJTaXplLmhlaWdodClcbiAgICAgICAgICAgIDogeSAvICgwLjUgKiB0aGlzLnBsYXllclNpemUuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHsgeDogbm9ybWFsaXplZFggKiAzMjc2NywgeTogbm9ybWFsaXplZFkgKiAzMjc2NyB9O1xuICAgIH1cbiAgICB1bnRyYW5zbGF0ZVVuc2lnbmVkKHgsIHkpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFggPSB0aGlzLnBsYXllcklzTGFyZ2VyID8geCAvIDY1NTM2IDogKHggLyA2NTUzNiAtIDAuNSkgLyB0aGlzLnJhdGlvICsgMC41O1xuICAgICAgICBjb25zdCBub3JtYWxpemVkWSA9IHRoaXMucGxheWVySXNMYXJnZXIgPyAoeSAvIDY1NTM2IC0gMC41KSAvIHRoaXMucmF0aW8gKyAwLjUgOiB5IC8gNjU1MzY7XG4gICAgICAgIHJldHVybiB7IHg6IG5vcm1hbGl6ZWRYICogdGhpcy5wbGF5ZXJTaXplLndpZHRoLCB5OiBub3JtYWxpemVkWSAqIHRoaXMucGxheWVyU2l6ZS5oZWlnaHQgfTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnB1dENvb3JkVHJhbnNsYXRvci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuZXhwb3J0IGNsYXNzIFJUQ1V0aWxzIHtcbiAgICBzdGF0aWMgaXNWaWRlb1RyYW5zY2VpdmVyKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhblRyYW5zY2VpdmVyUmVjZWl2ZVZpZGVvKHRyYW5zY2VpdmVyKSB8fCB0aGlzLmNhblRyYW5zY2VpdmVyU2VuZFZpZGVvKHRyYW5zY2VpdmVyKTtcbiAgICB9XG4gICAgc3RhdGljIGNhblRyYW5zY2VpdmVyUmVjZWl2ZVZpZGVvKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiAoISF0cmFuc2NlaXZlciAmJlxuICAgICAgICAgICAgKHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2JyB8fCB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdyZWN2b25seScpICYmXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlciAmJlxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09ICd2aWRlbycpO1xuICAgIH1cbiAgICBzdGF0aWMgY2FuVHJhbnNjZWl2ZXJTZW5kVmlkZW8odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuICghIXRyYW5zY2VpdmVyICYmXG4gICAgICAgICAgICAodHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnIHx8IHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3NlbmRvbmx5JykgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRlciAmJlxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrICYmXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2sua2luZCA9PT0gJ3ZpZGVvJyk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0F1ZGlvVHJhbnNjZWl2ZXIodHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuVHJhbnNjZWl2ZXJSZWNlaXZlQXVkaW8odHJhbnNjZWl2ZXIpIHx8IHRoaXMuY2FuVHJhbnNjZWl2ZXJTZW5kQXVkaW8odHJhbnNjZWl2ZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgY2FuVHJhbnNjZWl2ZXJSZWNlaXZlQXVkaW8odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuICghIXRyYW5zY2VpdmVyICYmXG4gICAgICAgICAgICAodHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnIHx8IHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3JlY3Zvbmx5JykgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY2VpdmVyICYmXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjayAmJlxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sua2luZCA9PT0gJ2F1ZGlvJyk7XG4gICAgfVxuICAgIHN0YXRpYyBjYW5UcmFuc2NlaXZlclNlbmRBdWRpbyh0cmFuc2NlaXZlcikge1xuICAgICAgICByZXR1cm4gKCEhdHJhbnNjZWl2ZXIgJiZcbiAgICAgICAgICAgICh0cmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdzZW5kcmVjdicgfHwgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZG9ubHknKSAmJlxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZGVyICYmXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2sgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRlci50cmFjay5raW5kID09PSAnYXVkaW8nKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SVENVdGlscy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdjb21tb24tdWU1LjYnO1xuLyoqXG4gKiBWaWRlbyBQbGF5ZXIgQ29udHJvbGxlciBoYW5kbGVzIHRoZSBjcmVhdGlvbiBvZiB0aGUgdmlkZW8gSFRNTCBlbGVtZW50IGFuZCBhbGwgaGFuZGxlcnNcbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2aWRlb0VsZW1lbnRQcm92aWRlciBWaWRlbyBQbGF5ZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2aWRlb0VsZW1lbnRQcm92aWRlcikge1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudFByb3ZpZGVyID0gdmlkZW9FbGVtZW50UHJvdmlkZXI7XG4gICAgICAgIHRoaXMuYXVkaW9FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQXVkaW8nKTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnRQcm92aWRlci5zZXRBdWRpb0VsZW1lbnQodGhpcy5hdWRpb0VsZW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gdGhlIFBlZXIgY29ubmVjdGlvbiBoYXMgYSB0cmFjayBldmVudFxuICAgICAqIEBwYXJhbSBydGNUcmFja0V2ZW50IC0gUlRDIFRyYWNrIEV2ZW50XG4gICAgICovXG4gICAgaGFuZGxlT25UcmFjayhydGNUcmFja0V2ZW50KSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCdoYW5kbGVPblRyYWNrICcgKyBKU09OLnN0cmluZ2lmeShydGNUcmFja0V2ZW50LnN0cmVhbXMpKTtcbiAgICAgICAgLy8gRG8gbm90IGFkZCB0aGUgdHJhY2sgaWYgdGhlIElEIGlzIGBwcm9iYXRvcmAgYXMgdGhpcyBpcyBzcGVjaWFsIHRyYWNrIGNyZWF0ZWQgYnkgbWVkaWFzb3VwIGZvciBiaXRyYXRlIHByb2JpbmcuXG4gICAgICAgIC8vIFJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9FcGljR2FtZXNFeHQvUGl4ZWxTdHJlYW1pbmdJbmZyYXN0cnVjdHVyZS9wdWxsLzg2IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIGlmIChydGNUcmFja0V2ZW50LnN0cmVhbXMubGVuZ3RoIDwgMSB8fCBydGNUcmFja0V2ZW50LnN0cmVhbXNbMF0uaWQgPT0gJ3Byb2JhdG9yJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZGVvRWxlbWVudCA9IHRoaXMudmlkZW9FbGVtZW50UHJvdmlkZXIuZ2V0VmlkZW9FbGVtZW50KCk7XG4gICAgICAgIGlmIChydGNUcmFja0V2ZW50LnRyYWNrKSB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnR290IHRyYWNrIC0gJyArXG4gICAgICAgICAgICAgICAgcnRjVHJhY2tFdmVudC50cmFjay5raW5kICtcbiAgICAgICAgICAgICAgICAnIGlkPScgK1xuICAgICAgICAgICAgICAgIHJ0Y1RyYWNrRXZlbnQudHJhY2suaWQgK1xuICAgICAgICAgICAgICAgICcgcmVhZHlTdGF0ZT0nICtcbiAgICAgICAgICAgICAgICBydGNUcmFja0V2ZW50LnRyYWNrLnJlYWR5U3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydGNUcmFja0V2ZW50LnRyYWNrLmtpbmQgPT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgdGhpcy5DcmVhdGVBdWRpb1RyYWNrKHJ0Y1RyYWNrRXZlbnQuc3RyZWFtc1swXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnRjVHJhY2tFdmVudC50cmFjay5raW5kID09ICd2aWRlbycgJiZcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zcmNPYmplY3QgIT09IHJ0Y1RyYWNrRXZlbnQuc3RyZWFtc1swXSkge1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNyY09iamVjdCA9IHJ0Y1RyYWNrRXZlbnQuc3RyZWFtc1swXTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdTZXQgdmlkZW8gc291cmNlIGZyb20gdmlkZW8gdHJhY2sgb250cmFjay4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBhdWRpbyBkZXZpY2Ugd2hlbiByZWNlaXZpbmcgYW4gUlRDVHJhY2tFdmVudCB3aXRoIHRoZSBraW5kIG9mIFwiYXVkaW9cIlxuICAgICAqIEBwYXJhbSBhdWRpb01lZGlhU3RyZWFtIC0gQXVkaW8gTWVkaWEgc3RyZWFtIHRyYWNrXG4gICAgICovXG4gICAgQ3JlYXRlQXVkaW9UcmFjayhhdWRpb01lZGlhU3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHZpZGVvRWxlbWVudCA9IHRoaXMudmlkZW9FbGVtZW50UHJvdmlkZXIuZ2V0VmlkZW9FbGVtZW50KCk7XG4gICAgICAgIC8vIGRvIG5vdGhpbmcgdGhlIHZpZGVvIGhhcyB0aGUgc2FtZSBtZWRpYSBzdHJlYW0gYXMgdGhlIGF1ZGlvIHRyYWNrIHdlIGhhdmUgaGVyZSAodGhleSBhcmUgbGlua2VkKVxuICAgICAgICBpZiAodmlkZW9FbGVtZW50LnNyY09iamVjdCA9PSBhdWRpb01lZGlhU3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gdmlkZW8gZWxlbWVudCBoYXMgc29tZSBvdGhlciBtZWRpYSBzdHJlYW0gdGhhdCBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYXVkaW8gdHJhY2tcbiAgICAgICAgZWxzZSBpZiAodmlkZW9FbGVtZW50LnNyY09iamVjdCAmJiB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ICE9PSBhdWRpb01lZGlhU3RyZWFtKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgYXVkaW8gZWxlbWVudFxuICAgICAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnQuc3JjT2JqZWN0ID0gYXVkaW9NZWRpYVN0cmVhbTtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdDcmVhdGVkIG5ldyBhdWRpbyBlbGVtZW50IHRvIHBsYXkgc2VwYXJhdGUgYXVkaW8gc3RyZWFtLicpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RyZWFtQ29udHJvbGxlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgRmxhZ3MgfSBmcm9tICcuLi9Db25maWcvQ29uZmlnJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42Jztcbi8qKlxuICogVGhlIHZpZGVvIHBsYXllciBodG1sIGVsZW1lbnRcbiAqL1xuZXhwb3J0IGNsYXNzIFZpZGVvUGxheWVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmlkZW9FbGVtZW50UGFyZW50IHRoZSBodG1sIGRpdiB0aGUgdGhlIHZpZGVvIHBsYXllciB3aWxsIGJlIGluamVjdGVkIGludG9cbiAgICAgKiBAcGFyYW0gY29uZmlnIHRoZSBhcHBsaWNhdGlvbnMgY29uZmlndXJhdGlvbi4gV2UncmUgaW50ZXJlc3RlZCBpbiB0aGUgc3RhcnRWaWRlb011dGVkIGZsYWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2aWRlb0VsZW1lbnRQYXJlbnQsIGNvbmZpZykge1xuICAgICAgICB0aGlzLmxhc3RUaW1lUmVzaXplZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5pZCA9ICdzdHJlYW1pbmdWaWRlbyc7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LmRpc2FibGVQaWN0dXJlSW5QaWN0dXJlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQucGxheXNJbmxpbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYWxsJztcbiAgICAgICAgdmlkZW9FbGVtZW50UGFyZW50LmFwcGVuZENoaWxkKHRoaXMudmlkZW9FbGVtZW50KTtcbiAgICAgICAgdGhpcy5vblJlc2l6ZVBsYXllckNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1Jlc29sdXRpb24gY2hhbmdlZCwgcmVzdHlsaW5nIHBsYXllciwgZGlkIHlvdSBmb3JnZXQgdG8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbj8nKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbk1hdGNoVmlld3BvcnRSZXNvbHV0aW9uQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmVzb2x1dGlvbiBjaGFuZ2VkIGFuZCBtYXRjaCB2aWV3cG9ydCByZXNvbHV0aW9uIGlzIHR1cm5lZCBvbiwgZGlkIHlvdSBmb3JnZXQgdG8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbj8nKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gc2V0IHBsYXkgZm9yIHZpZGVvIChhbmQgYXVkaW8pXG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50Lm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5hdWRpb0VsZW1lbnQgIT0gdW5kZWZpbmVkICYmIHRoaXMuYXVkaW9FbGVtZW50LnBhdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50LnBsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnZpZGVvRWxlbWVudC5wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5wbGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50Lm9ubG9hZGVkbWV0YWRhdGEgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uVmlkZW9Jbml0aWFsaXplZCgpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBzZXQgcmVzaXplIGV2ZW50cyB0byB0aGUgd2luZG93cyBpZiBpdCBpcyByZXNpemVkIG9yIGl0cyBvcmllbnRhdGlvbiBpcyBjaGFuZ2VkXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB0aGlzLnJlc2l6ZVBsYXllclN0eWxlKCksIHRydWUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCAoKSA9PiB0aGlzLm9uT3JpZW50YXRpb25DaGFuZ2UoKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnNyYyA9ICcnO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9FbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudC5zcmMgPSAnJztcbiAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50LnNyY09iamVjdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRBdWRpb0VsZW1lbnQoYXVkaW9FbGVtZW50KSB7XG4gICAgICAgIHRoaXMuYXVkaW9FbGVtZW50ID0gYXVkaW9FbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSB2aWRlbyBlbGVtZW50IHdpdGggYW55IGFwcGxpY2F0aW9uIGNvbmZpZyBhbmQgcGxheXMgdGhlIHZpZGVvIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIGZvciBpZiBwbGF5aW5nIHRoZSB2aWRlbyB3YXMgc3VjY2Vzc2Z1bCBvciBub3QuXG4gICAgICovXG4gICAgcGxheSgpIHtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQubXV0ZWQgPSB0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLlN0YXJ0VmlkZW9NdXRlZCk7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LmF1dG9wbGF5ID0gdGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5BdXRvUGxheVZpZGVvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9FbGVtZW50LnBsYXkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmlkZW8gZWxlbWVudCBpcyBwYXVzZWQuXG4gICAgICovXG4gICAgaXNQYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZGVvRWxlbWVudC5wYXVzZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIC0gd2hldGhlciB0aGUgdmlkZW8gZWxlbWVudCBpcyBwbGF5aW5nLlxuICAgICAqL1xuICAgIGlzVmlkZW9SZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9FbGVtZW50LnJlYWR5U3RhdGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZpZGVvRWxlbWVudC5yZWFkeVN0YXRlID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmlkZW8gZWxlbWVudCBoYXMgYSB2YWxpZCB2aWRlbyBzb3VyY2UgKHNyY09iamVjdCkuXG4gICAgICovXG4gICAgaGFzVmlkZW9Tb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZGVvRWxlbWVudC5zcmNPYmplY3QgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZpZGVvRWxlbWVudC5zcmNPYmplY3QgIT09IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBjb250ZXh0IG9mIHRoZSBodG1sIHZpZGVvIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyAtIHRoZSBjdXJyZW50IGNvbnRleHQgb2YgdGhlIHZpZGVvIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRWaWRlb0VsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZGVvRWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGNvbnRleHQgb2YgdGhlIGh0bWwgdmlkZW8gZWxlbWVudHMgcGFyZW50XG4gICAgICogQHJldHVybnMgLSB0aGUgY3VycmVudCBjb250ZXh0IG9mIHRoZSB2aWRlbyBlbGVtZW50cyBwYXJlbnRcbiAgICAgKi9cbiAgICBnZXRWaWRlb1BhcmVudEVsZW1lbnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMudmlkZW9FbGVtZW50LnBhcmVudEVsZW1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBWaWRlbyBFbGVtZW50cyBzcmMgb2JqZWN0IHRyYWNrcyB0byBlbmFibGVcbiAgICAgKiBAcGFyYW0gZW5hYmxlZCAtIEVuYWJsZSBUcmFja3Mgb24gdGhlIFNyYyBPYmplY3RcbiAgICAgKi9cbiAgICBzZXRWaWRlb0VuYWJsZWQoZW5hYmxlZCkge1xuICAgICAgICAvLyB0aGlzIGlzIGEgdGVtcG9yYXJ5IGhhY2sgdW50aWwgdHlwZSBzY3JpcHRzIHZpZGVvIGVsZW1lbnQgaXMgdXBkYXRlZCB0byByZWZsZWN0IHRoZSBuZWVkIGZvciB0cmFja3Mgb24gYSBodG1sIHZpZGVvIGVsZW1lbnRcbiAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50ID0gdGhpcy52aWRlb0VsZW1lbnQ7XG4gICAgICAgIHZpZGVvRWxlbWVudC5zcmNPYmplY3RcbiAgICAgICAgICAgIC5nZXRUcmFja3MoKVxuICAgICAgICAgICAgLmZvckVhY2goKHRyYWNrKSA9PiAodHJhY2suZW5hYmxlZCA9IGVuYWJsZWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gb3ZlcnJpZGUgZm9yIHdoZW4gdGhlIHZpZGVvIGhhcyBiZWVuIGluaXRpYWxpemVkIHdpdGggYSBzcmNPYmplY3RcbiAgICAgKi9cbiAgICBvblZpZGVvSW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIC8vIERlZmF1bHQgRnVuY3Rpb25hbGl0eTogRG8gTm90aGluZ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbiB0aGUgb3JpZW50YXRpb24gY2hhbmdlIG9mIGEgd2luZG93IGNsZWFyIHRoZSB0aW1lb3V0XG4gICAgICovXG4gICAgb25PcmllbnRhdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMub3JpZW50YXRpb25DaGFuZ2VUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbkNoYW5nZVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVBsYXllclN0eWxlKCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIHBsYXllciBzdHlsZSBiYXNlZCBvbiB0aGUgd2luZG93IGhlaWdodCBhbmQgd2lkdGhcbiAgICAgKiBAcmV0dXJucyAtIG5pbCBpZiByZXF1aXJlbWVudHMgYXJlIHNhdGlzZmllZFxuICAgICAqL1xuICAgIHJlc2l6ZVBsYXllclN0eWxlKCkge1xuICAgICAgICBjb25zdCB2aWRlb0VsZW1lbnRQYXJlbnQgPSB0aGlzLmdldFZpZGVvUGFyZW50RWxlbWVudCgpO1xuICAgICAgICBpZiAoIXZpZGVvRWxlbWVudFBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlVmlkZW9TdHJlYW1TaXplKCk7XG4gICAgICAgIGlmICh2aWRlb0VsZW1lbnRQYXJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmaXhlZC1zaXplJykpIHtcbiAgICAgICAgICAgIHRoaXMub25SZXNpemVQbGF5ZXJDYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnRyb2xzIGZvciByZXNpemluZyB0aGUgcGxheWVyXG4gICAgICAgIHRoaXMucmVzaXplUGxheWVyU3R5bGVUb0ZpbGxQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgIHRoaXMub25SZXNpemVQbGF5ZXJDYWxsYmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNpemVzIHRoZSBwbGF5ZXIgZWxlbWVudCB0byBmaWxsIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAqL1xuICAgIHJlc2l6ZVBsYXllclN0eWxlVG9GaWxsUGFyZW50RWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50UGFyZW50ID0gdGhpcy5nZXRWaWRlb1BhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgLy9WaWRlbyBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0IHNvIHNldCB2aWRlb0VsZW1lbnRQYXJlbnQgdG8gc2l6ZSBvZiBwYXJlbnQgZWxlbWVudFxuICAgICAgICBjb25zdCBzdHlsZVdpZHRoID0gJzEwMCUnO1xuICAgICAgICBjb25zdCBzdHlsZUhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgY29uc3Qgc3R5bGVUb3AgPSAwO1xuICAgICAgICBjb25zdCBzdHlsZUxlZnQgPSAwO1xuICAgICAgICB2aWRlb0VsZW1lbnRQYXJlbnQuc2V0QXR0cmlidXRlKCdzdHlsZScsICd0b3A6ICcgK1xuICAgICAgICAgICAgc3R5bGVUb3AgK1xuICAgICAgICAgICAgJ3B4OyBsZWZ0OiAnICtcbiAgICAgICAgICAgIHN0eWxlTGVmdCArXG4gICAgICAgICAgICAncHg7IHdpZHRoOiAnICtcbiAgICAgICAgICAgIHN0eWxlV2lkdGggK1xuICAgICAgICAgICAgJzsgaGVpZ2h0OiAnICtcbiAgICAgICAgICAgIHN0eWxlSGVpZ2h0ICtcbiAgICAgICAgICAgICc7IGN1cnNvcjogZGVmYXVsdDsnKTtcbiAgICB9XG4gICAgdXBkYXRlVmlkZW9TdHJlYW1TaXplKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuTWF0Y2hWaWV3cG9ydFJlc29sdXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIGlmIChub3cgLSB0aGlzLmxhc3RUaW1lUmVzaXplZCA+IDMwMCkge1xuICAgICAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50UGFyZW50ID0gdGhpcy5nZXRWaWRlb1BhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmICghdmlkZW9FbGVtZW50UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vbk1hdGNoVmlld3BvcnRSZXNvbHV0aW9uQ2FsbGJhY2sodmlkZW9FbGVtZW50UGFyZW50LmNsaWVudFdpZHRoLCB2aWRlb0VsZW1lbnRQYXJlbnQuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMubGFzdFRpbWVSZXNpemVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnUmVzaXppbmcgdG9vIG9mdGVuIC0gc2tpcHBpbmcnKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVvdXRIYW5kbGUpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0SGFuZGxlID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGVWaWRlb1N0cmVhbVNpemUoKSwgMTAwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpZGVvUGxheWVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBXZWJTb2NrZXRUcmFuc3BvcnQsIExvZ2dlciwgU2lnbmFsbGluZ1Byb3RvY29sLCBNZXNzYWdlcywgTWVzc2FnZUhlbHBlcnMsIEtlZXBhbGl2ZU1vbml0b3IgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2NvbW1vbi11ZTUuNic7XG5pbXBvcnQgeyBTdHJlYW1Db250cm9sbGVyIH0gZnJvbSAnLi4vVmlkZW9QbGF5ZXIvU3RyZWFtQ29udHJvbGxlcic7XG5pbXBvcnQgeyBGcmVlemVGcmFtZUNvbnRyb2xsZXIgfSBmcm9tICcuLi9GcmVlemVGcmFtZS9GcmVlemVGcmFtZUNvbnRyb2xsZXInO1xuaW1wb3J0IHsgQUZLQ29udHJvbGxlciB9IGZyb20gJy4uL0FGSy9BRktDb250cm9sbGVyJztcbmltcG9ydCB7IERhdGFDaGFubmVsQ29udHJvbGxlciB9IGZyb20gJy4uL0RhdGFDaGFubmVsL0RhdGFDaGFubmVsQ29udHJvbGxlcic7XG5pbXBvcnQgeyBQZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIgfSBmcm9tICcuLi9QZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIvUGVlckNvbm5lY3Rpb25Db250cm9sbGVyJztcbmltcG9ydCB7IEZsYWdzLCBDb250cm9sU2NoZW1lVHlwZSwgVGV4dFBhcmFtZXRlcnMsIE9wdGlvblBhcmFtZXRlcnMsIE51bWVyaWNQYXJhbWV0ZXJzIH0gZnJvbSAnLi4vQ29uZmlnL0NvbmZpZyc7XG5pbXBvcnQgeyBJbml0aWFsU2V0dGluZ3MgfSBmcm9tICcuLi9EYXRhQ2hhbm5lbC9Jbml0aWFsU2V0dGluZ3MnO1xuaW1wb3J0IHsgTGF0ZW5jeVRlc3RSZXN1bHRzIH0gZnJvbSAnLi4vRGF0YUNoYW5uZWwvTGF0ZW5jeVRlc3RSZXN1bHRzJztcbmltcG9ydCB7IEZpbGVUZW1wbGF0ZSwgRmlsZVV0aWwgfSBmcm9tICcuLi9VdGlsL0ZpbGVVdGlsJztcbmltcG9ydCB7IElucHV0Q2xhc3Nlc0ZhY3RvcnkgfSBmcm9tICcuLi9JbnB1dHMvSW5wdXRDbGFzc2VzRmFjdG9yeSc7XG5pbXBvcnQgeyBWaWRlb1BsYXllciB9IGZyb20gJy4uL1ZpZGVvUGxheWVyL1ZpZGVvUGxheWVyJztcbmltcG9ydCB7IFN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLCBNZXNzYWdlRGlyZWN0aW9uIH0gZnJvbSAnLi4vVWVJbnN0YW5jZU1lc3NhZ2UvU3RyZWFtTWVzc2FnZUNvbnRyb2xsZXInO1xuaW1wb3J0IHsgUmVzcG9uc2VDb250cm9sbGVyIH0gZnJvbSAnLi4vVWVJbnN0YW5jZU1lc3NhZ2UvUmVzcG9uc2VDb250cm9sbGVyJztcbmltcG9ydCB7IFNlbmRNZXNzYWdlQ29udHJvbGxlciB9IGZyb20gJy4uL1VlSW5zdGFuY2VNZXNzYWdlL1NlbmRNZXNzYWdlQ29udHJvbGxlcic7XG5pbXBvcnQgeyBUb1N0cmVhbWVyTWVzc2FnZXNDb250cm9sbGVyIH0gZnJvbSAnLi4vVWVJbnN0YW5jZU1lc3NhZ2UvVG9TdHJlYW1lck1lc3NhZ2VzQ29udHJvbGxlcic7XG5pbXBvcnQgeyBEYXRhQ2hhbm5lbFNlbmRlciB9IGZyb20gJy4uL0RhdGFDaGFubmVsL0RhdGFDaGFubmVsU2VuZGVyJztcbmltcG9ydCB7IElucHV0Q29vcmRUcmFuc2xhdG9yIH0gZnJvbSAnLi4vVXRpbC9JbnB1dENvb3JkVHJhbnNsYXRvcic7XG5pbXBvcnQgeyBEYXRhQ2hhbm5lbENsb3NlRXZlbnQsIERhdGFDaGFubmVsRXJyb3JFdmVudCwgRGF0YUNoYW5uZWxPcGVuRXZlbnQsIEhpZGVGcmVlemVGcmFtZUV2ZW50LCBMb2FkRnJlZXplRnJhbWVFdmVudCwgUGxheVN0cmVhbUVycm9yRXZlbnQsIFBsYXlTdHJlYW1FdmVudCwgUGxheVN0cmVhbVJlamVjdGVkRXZlbnQsIFNob3dPblNjcmVlbktleWJvYXJkRXZlbnQsIFN0cmVhbWVyTGlzdE1lc3NhZ2VFdmVudCwgU3RyZWFtZXJJRENoYW5nZWRNZXNzYWdlRXZlbnQgfSBmcm9tICcuLi9VdGlsL0V2ZW50RW1pdHRlcic7XG5pbXBvcnQgeyBJVVJMU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vVXRpbC9JVVJMU2VhcmNoUGFyYW1zJztcbmltcG9ydCB7IEJyb3dzZXJVdGlscyB9IGZyb20gJy4uL1V0aWwvQnJvd3NlclV0aWxzJztcbi8qKlxuICogRW50cnkgcG9pbnQgZm9yIHRoZSBXZWJSVEMgUGxheWVyXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJSdGNQbGF5ZXJDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSB0aGUgZnJvbnRlbmQgY29uZmlnIG9iamVjdFxuICAgICAqIEBwYXJhbSBwaXhlbFN0cmVhbWluZyAtIHRoZSBQaXhlbFN0cmVhbWluZyBvYmplY3RcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHBpeGVsU3RyZWFtaW5nKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkU2hvd1BsYXlPdmVybGF5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hdXRvSm9pblRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZyA9IHBpeGVsU3RyZWFtaW5nO1xuICAgICAgICB0aGlzLnJlc3BvbnNlQ29udHJvbGxlciA9IG5ldyBSZXNwb25zZUNvbnRyb2xsZXIoKTtcbiAgICAgICAgdGhpcy5maWxlID0gbmV3IEZpbGVUZW1wbGF0ZSgpO1xuICAgICAgICB0aGlzLnNkcENvbnN0cmFpbnRzID0ge1xuICAgICAgICAgICAgb2ZmZXJUb1JlY2VpdmVBdWRpbzogdHJ1ZSxcbiAgICAgICAgICAgIG9mZmVyVG9SZWNlaXZlVmlkZW86IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgLy8gc2V0IHVwIHRoZSBhZmsgbG9naWMgY2xhc3MgYW5kIGNvbm5lY3QgdXAgaXRzIG1ldGhvZCBmb3IgY2xvc2luZyB0aGUgc2lnbmFsaW5nIHNlcnZlclxuICAgICAgICB0aGlzLmFma0NvbnRyb2xsZXIgPSBuZXcgQUZLQ29udHJvbGxlcih0aGlzLmNvbmZpZywgdGhpcy5waXhlbFN0cmVhbWluZywgdGhpcy5vbkFma1RyaWdnZXJlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hZmtDb250cm9sbGVyLm9uQUZLVGltZWRPdXRDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VTaWduYWxpbmdTZXJ2ZXIoJ1lvdSBoYXZlIGJlZW4gZGlzY29ubmVjdGVkIGR1ZSB0byBpbmFjdGl2aXR5LicsIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mcmVlemVGcmFtZUNvbnRyb2xsZXIgPSBuZXcgRnJlZXplRnJhbWVDb250cm9sbGVyKHRoaXMucGl4ZWxTdHJlYW1pbmcudmlkZW9FbGVtZW50UGFyZW50KTtcbiAgICAgICAgdGhpcy52aWRlb1BsYXllciA9IG5ldyBWaWRlb1BsYXllcih0aGlzLnBpeGVsU3RyZWFtaW5nLnZpZGVvRWxlbWVudFBhcmVudCwgdGhpcy5jb25maWcpO1xuICAgICAgICB0aGlzLnZpZGVvUGxheWVyLm9uVmlkZW9Jbml0aWFsaXplZCA9ICgpID0+IHRoaXMuaGFuZGxlVmlkZW9Jbml0aWFsaXplZCgpO1xuICAgICAgICAvLyBXaGVuIGluIG1hdGNoIHZpZXdwb3J0IHJlc29sdXRpb24gbW9kZSwgd2hlbiB0aGUgYnJvd3NlciB2aWV3cG9ydCBpcyByZXNpemVkIHdlIHNlbmQgYSByZXNpemUgY29tbWFuZCBiYWNrIHRvIFVFLlxuICAgICAgICB0aGlzLnZpZGVvUGxheWVyLm9uTWF0Y2hWaWV3cG9ydFJlc29sdXRpb25DYWxsYmFjayA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgICdSZXNvbHV0aW9uLldpZHRoJzogd2lkdGgsXG4gICAgICAgICAgICAgICAgJ1Jlc29sdXRpb24uSGVpZ2h0JzogaGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdDb21tYW5kJykoW0pTT04uc3RyaW5naWZ5KGRlc2NyaXB0b3IpXSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEV2ZXJ5IHRpbWUgdmlkZW8gcGxheWVyIGlzIHJlc2l6ZWQgaW4gYnJvd3NlciB3ZSBuZWVkIHRvIHJlaW5pdGlhbGl6ZSB0aGUgbW91c2UgY29vcmRpbmF0ZSBjb252ZXJzaW9uIGFuZCBmcmVlemUgZnJhbWUgc2l6aW5nIGxvZ2ljLlxuICAgICAgICB0aGlzLnZpZGVvUGxheWVyLm9uUmVzaXplUGxheWVyQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFVwTW91c2VBbmRGcmVlemVGcmFtZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBuZXcgU3RyZWFtQ29udHJvbGxlcih0aGlzLnZpZGVvUGxheWVyKTtcbiAgICAgICAgdGhpcy5jb29yZGluYXRlQ29udmVydGVyID0gbmV3IElucHV0Q29vcmRUcmFuc2xhdG9yKCk7XG4gICAgICAgIHRoaXMuc2VuZHJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIgPSBuZXcgRGF0YUNoYW5uZWxDb250cm9sbGVyKCk7XG4gICAgICAgIHRoaXMucmVjdkRhdGFDaGFubmVsQ29udHJvbGxlciA9IG5ldyBEYXRhQ2hhbm5lbENvbnRyb2xsZXIoKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckRhdGFDaGFubmVsRXZlbnRFbWl0dGVycyh0aGlzLnNlbmRyZWN2RGF0YUNoYW5uZWxDb250cm9sbGVyKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckRhdGFDaGFubmVsRXZlbnRFbWl0dGVycyh0aGlzLnJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsU2VuZGVyID0gbmV3IERhdGFDaGFubmVsU2VuZGVyKHRoaXMuc2VuZHJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsU2VuZGVyLnJlc2V0QWZrV2FybmluZ1RpbWVyT25EYXRhU2VuZCA9ICgpID0+IHRoaXMuYWZrQ29udHJvbGxlci5yZXNldEFma1dhcm5pbmdUaW1lcigpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyID0gbmV3IFN0cmVhbU1lc3NhZ2VDb250cm9sbGVyKCk7XG4gICAgICAgIC8vIHNldCB1cCB3ZWJzb2NrZXQgbWV0aG9kc1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG5ldyBXZWJTb2NrZXRUcmFuc3BvcnQoY29uZmlnLndlYlNvY2tldFByb3RvY29scyk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSBuZXcgU2lnbmFsbGluZ1Byb3RvY29sKHRoaXMudHJhbnNwb3J0KTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC5hZGRMaXN0ZW5lcihNZXNzYWdlcy5jb25maWcudHlwZU5hbWUsIChtc2cpID0+IHRoaXMuaGFuZGxlT25Db25maWdNZXNzYWdlKG1zZykpO1xuICAgICAgICB0aGlzLnByb3RvY29sLmFkZExpc3RlbmVyKE1lc3NhZ2VzLnBpbmcudHlwZU5hbWUsIChtc2cpID0+IHRoaXMuaGFuZGxlUGluZ01lc3NhZ2UobXNnKSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wuYWRkTGlzdGVuZXIoTWVzc2FnZXMuc3RyZWFtZXJMaXN0LnR5cGVOYW1lLCAobXNnKSA9PiB0aGlzLmhhbmRsZVN0cmVhbWVyTGlzdE1lc3NhZ2UobXNnKSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wuYWRkTGlzdGVuZXIoTWVzc2FnZXMuc3Vic2NyaWJlRmFpbGVkLnR5cGVOYW1lLCAobXNnKSA9PiB0aGlzLmhhbmRsZVN1YnNjcmliZUZhaWxlZE1lc3NhZ2UobXNnKSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wuYWRkTGlzdGVuZXIoTWVzc2FnZXMuc3RyZWFtZXJJZENoYW5nZWQudHlwZU5hbWUsIChtc2cpID0+IHRoaXMuaGFuZGxlU3RyZWFtZXJJRENoYW5nZWRNZXNzYWdlKG1zZykpO1xuICAgICAgICB0aGlzLnByb3RvY29sLmFkZExpc3RlbmVyKE1lc3NhZ2VzLnBsYXllckNvdW50LnR5cGVOYW1lLCAobXNnKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwbGF5ZXJDb3VudE1lc3NhZ2UgPSBtc2c7XG4gICAgICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vblBsYXllckNvdW50KHBsYXllckNvdW50TWVzc2FnZS5jb3VudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3RvY29sLmFkZExpc3RlbmVyKE1lc3NhZ2VzLmFuc3dlci50eXBlTmFtZSwgKG1zZykgPT4gdGhpcy5oYW5kbGVXZWJSdGNBbnN3ZXIobXNnKSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wuYWRkTGlzdGVuZXIoTWVzc2FnZXMub2ZmZXIudHlwZU5hbWUsIChtc2cpID0+IHRoaXMuaGFuZGxlV2ViUnRjT2ZmZXIobXNnKSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wuYWRkTGlzdGVuZXIoTWVzc2FnZXMucGVlckRhdGFDaGFubmVscy50eXBlTmFtZSwgKG1zZykgPT4gdGhpcy5oYW5kbGVXZWJSdGNTRlVQZWVyRGF0YWNoYW5uZWxzKG1zZykpO1xuICAgICAgICB0aGlzLnByb3RvY29sLmFkZExpc3RlbmVyKE1lc3NhZ2VzLmljZUNhbmRpZGF0ZS50eXBlTmFtZSwgKG1zZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgaWNlQ2FuZGlkYXRlTWVzc2FnZSA9IG1zZztcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSWNlQ2FuZGlkYXRlKGljZUNhbmRpZGF0ZU1lc3NhZ2UuY2FuZGlkYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wudHJhbnNwb3J0LmFkZExpc3RlbmVyKCdvcGVuJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgQnJvd3NlclNlbmRPZmZlciA9IHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuQnJvd3NlclNlbmRPZmZlcik7XG4gICAgICAgICAgICBpZiAoIUJyb3dzZXJTZW5kT2ZmZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gTWVzc2FnZUhlbHBlcnMuY3JlYXRlTWVzc2FnZShNZXNzYWdlcy5saXN0U3RyZWFtZXJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RvY29sLnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0ID0gMDtcbiAgICAgICAgICAgIHRoaXMuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wudHJhbnNwb3J0LmFkZExpc3RlbmVyKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbnQgcmVhbGx5IG5lZWQgdG8gZG8gYW55dGhpbmcgaGVyZSBzaW5jZSB0aGUgY2xvc2UgZXZlbnQgc2hvdWxkIGZvbGxvdy5cbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihgR290IGEgdHJhbnNwb3J0IGVycm9yLmApO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC50cmFuc3BvcnQuYWRkTGlzdGVuZXIoJ2Nsb3NlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvLyB3aGVuIHdlIHJlZnJlc2ggdGhlIHBhZ2UgZHVyaW5nIGEgc3RyZWFtIHdlIGdldCB0aGUgZ29pbmcgYXdheSBjb2RlLlxuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGRvbid0IHdhbnQgdG8gcmVjb25uZWN0IHNpbmNlIHdlJ3JlIG5hdmlnYXRpbmcgYXdheS5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50L2NvZGVcbiAgICAgICAgICAgIC8vIGxpc3RzIGFsbCB0aGUgY29kZXMuXG4gICAgICAgICAgICBjb25zdCBDT0RFX0dPSU5HX0FXQVkgPSAxMDAxO1xuICAgICAgICAgICAgY29uc3QgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSB0aGlzLmNvbmZpZy5nZXROdW1lcmljU2V0dGluZ1ZhbHVlKE51bWVyaWNQYXJhbWV0ZXJzLk1heFJlY29ubmVjdEF0dGVtcHRzKTtcbiAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRzTGVmdCA9IHRoaXMucmVjb25uZWN0QXR0ZW1wdCA8IG1heFJlY29ubmVjdEF0dGVtcHRzO1xuICAgICAgICAgICAgY29uc3QgcmVjb25uZWN0RW5hYmxlZCA9IHRoaXMuZm9yY2VSZWNvbm5lY3QgfHwgKHRoaXMuZW5hYmxlQXV0b1JlY29ubmVjdCAmJiBtYXhSZWNvbm5lY3RBdHRlbXB0cyA+IDAgJiYgYXR0ZW1wdHNMZWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IHdpbGxUcnlSZWNvbm5lY3QgPSByZWNvbm5lY3RFbmFibGVkICYmIGV2ZW50LmNvZGUgIT0gQ09ERV9HT0lOR19BV0FZO1xuICAgICAgICAgICAgY29uc3QgYWxsb3dDbGlja1RvUmVjb25uZWN0ID0gIXdpbGxUcnlSZWNvbm5lY3Q7XG4gICAgICAgICAgICBjb25zdCBkaXNjb25uZWN0TWVzc2FnZSA9IHRoaXMuZGlzY29ubmVjdE1lc3NhZ2UgPyB0aGlzLmRpc2Nvbm5lY3RNZXNzYWdlIDogZXZlbnQucmVhc29uO1xuICAgICAgICAgICAgdGhpcy5mb3JjZVJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGxpc3Qgb2YgYWxsIHBvc3NpYmxlIGNvZGVjcyBvbiBkaXNjb25uZWN0IHNvIHRoYXQgaWYgdGhlIG5leHQgY29ubmVjdGlvbiBoYXMgXCJOZWdvdGlhdGVDb2RlY3NcIiBvblxuICAgICAgICAgICAgLy8gdGhlbiBhbGwgY29kZWNzIGNhbiBiZSBuZWdvdGlhdGVkXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5nZXRTZXR0aW5nT3B0aW9uKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkQ29kZWMpLm9wdGlvbnMgPVxuICAgICAgICAgICAgICAgIEJyb3dzZXJVdGlscy5nZXRTdXBwb3J0ZWRWaWRlb0NvZGVjcygpO1xuICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25EaXNjb25uZWN0KGRpc2Nvbm5lY3RNZXNzYWdlLCBhbGxvd0NsaWNrVG9SZWNvbm5lY3QpO1xuICAgICAgICAgICAgdGhpcy5hZmtDb250cm9sbGVyLnN0b3BBZmtXYXJuaW5nVGltZXIoKTtcbiAgICAgICAgICAgIC8vIHN0b3Agc2VuZGluZyBzdGF0cyBvbiBpbnRlcnZhbCBpZiB3ZSBoYXZlIGNsb3NlZCBvdXIgY29ubmVjdGlvblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHNUaW1lckhhbmRsZSAmJiB0aGlzLnN0YXRzVGltZXJIYW5kbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuc3RhdHNUaW1lckhhbmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXNldCB0aGUgc3RyZWFtIHF1YWxpdHkgaWNvbi5cbiAgICAgICAgICAgIHRoaXMuc2V0VmlkZW9FbmNvZGVyQXZnUVAoMCk7XG4gICAgICAgICAgICAvLyB1bnJlZ2lzdGVyIGFsbCBpbnB1dCBkZXZpY2UgZXZlbnQgaGFuZGxlcnMgb24gZGlzY29ubmVjdFxuICAgICAgICAgICAgdGhpcy5zZXRUb3VjaElucHV0RW5hYmxlZChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnNldE1vdXNlSW5wdXRFbmFibGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuc2V0S2V5Ym9hcmRJbnB1dEVuYWJsZWQoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5zZXRHYW1lUGFkSW5wdXRFbmFibGVkKGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh3aWxsVHJ5UmVjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gbmVlZCBhIHNtYWxsIGRlbGF5IGhlcmUgdG8gcHJldmVudCByZWNvbm5lY3Qgc3BhbW1pbmdcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0Kys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9SZWNvbm5lY3QoZXZlbnQucmVhc29uKTtcbiAgICAgICAgICAgICAgICB9LCAyMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHNldCB1cCB0aGUgZmluYWwgd2ViUnRjIHBsYXllciBjb250cm9sbGVyIG1ldGhvZHMgZnJvbSB3aXRoaW4gb3VyIGFwcGxpY2F0aW9uIHNvIGEgY29ubmVjdGlvbiBjYW4gYmUgYWN0aXZhdGVkXG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyID0gbmV3IFNlbmRNZXNzYWdlQ29udHJvbGxlcih0aGlzLmRhdGFDaGFubmVsU2VuZGVyLCB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyKTtcbiAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNDb250cm9sbGVyID0gbmV3IFRvU3RyZWFtZXJNZXNzYWdlc0NvbnRyb2xsZXIodGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucG9wdWxhdGVEZWZhdWx0UHJvdG9jb2woKTtcbiAgICAgICAgdGhpcy5pbnB1dENsYXNzZXNGYWN0b3J5ID0gbmV3IElucHV0Q2xhc3Nlc0ZhY3RvcnkodGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlciwgdGhpcy52aWRlb1BsYXllciwgdGhpcy5jb29yZGluYXRlQ29udmVydGVyKTtcbiAgICAgICAgdGhpcy5pc1VzaW5nU0ZVID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNVc2luZ1NWQyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUXVhbGl0eUNvbnRyb2xsZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmVmZXJyZWRDb2RlYyA9ICcnO1xuICAgICAgICB0aGlzLmVuYWJsZUF1dG9SZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICB0aGlzLmZvcmNlUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdCA9IDA7XG4gICAgICAgIHRoaXMuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25maWcuX2FkZE9uT3B0aW9uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihPcHRpb25QYXJhbWV0ZXJzLlN0cmVhbWVySWQsIChzdHJlYW1lcmlkKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtZXJpZCA9PT0gdW5kZWZpbmVkIHx8IHN0cmVhbWVyaWQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xvc2UgdGhlIGN1cnJlbnQgcGVlciBjb25uZWN0aW9uIGFuZCBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5wZWVyQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIuY3JlYXRlUGVlckNvbm5lY3Rpb24odGhpcy5wZWVyQ29uZmlnLCB0aGlzLnByZWZlcnJlZENvZGVjKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlZFN0cmVhbSA9IHN0cmVhbWVyaWQ7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gTWVzc2FnZUhlbHBlcnMuY3JlYXRlTWVzc2FnZShNZXNzYWdlcy5zdWJzY3JpYmUsIHsgc3RyZWFtZXJJZDogc3RyZWFtZXJpZCB9KTtcbiAgICAgICAgICAgIHRoaXMucHJvdG9jb2wuc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZy5fYWRkT25PcHRpb25TZXR0aW5nQ2hhbmdlZExpc3RlbmVyKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkUXVhbGl0eSwgKHByZWZlcnJlZFF1YWxpdHkpID0+IHtcbiAgICAgICAgICAgIGlmIChwcmVmZXJyZWRRdWFsaXR5ID09PSB1bmRlZmluZWQgfHwgcHJlZmVycmVkUXVhbGl0eSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVXNpbmdTVkMpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2VyIGlzIHVzaW5nIFNWQyBzbyBzZWxlY3RlZCBxdWFsaXR5IHdpbGwgYmUgb2YgdGhlIGZvcm0gU3hUeShoKS4gSnVzdCBleHRyYWN0IHRoZSB4IGFuZCB5IG51bWJlcnNcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZUhlbHBlcnMuY3JlYXRlTWVzc2FnZShNZXNzYWdlcy5sYXllclByZWZlcmVuY2UsIHtcbiAgICAgICAgICAgICAgICAgICAgc3BhdGlhbExheWVyOiArcHJlZmVycmVkUXVhbGl0eVsxXSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBvcmFsTGF5ZXI6ICtwcmVmZXJyZWRRdWFsaXR5WzNdIC0gMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlciBpcyBub3QgdXNpbmcgU1ZDIHNvIHRoZSBzZWxlY3RlZCBxdWFsaXR5IHdpbGwgYmUgZWl0aGVyIExvdywgTWVkaXVtIG9yIEhpZ2ggc28gd2UgZXh0cmFjdCB0aGUgYXBwcm9wcmlhdGUgc3BhdGlhbCBsYXllciBpbmRleFxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbFF1YWxpdGllcyA9IHRoaXMuY29uZmlnLmdldFNldHRpbmdPcHRpb24oT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRRdWFsaXR5KS5vcHRpb25zO1xuICAgICAgICAgICAgICAgIGNvbnN0IHF1YWxpdHlJbmRleCA9IGFsbFF1YWxpdGllcy5pbmRleE9mKHByZWZlcnJlZFF1YWxpdHkpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlSGVscGVycy5jcmVhdGVNZXNzYWdlKE1lc3NhZ2VzLmxheWVyUHJlZmVyZW5jZSwge1xuICAgICAgICAgICAgICAgICAgICBzcGF0aWFsTGF5ZXI6IHF1YWxpdHlJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdGVtcG9yYWxMYXllcjogMFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcm90b2NvbC5zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0VmlkZW9FbmNvZGVyQXZnUVAoLTEpO1xuICAgICAgICB0aGlzLnNpZ25hbGxpbmdVcmxCdWlsZGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsbGluZ1NlcnZlclVybCA9IHRoaXMuY29uZmlnLmdldFRleHRTZXR0aW5nVmFsdWUoVGV4dFBhcmFtZXRlcnMuU2lnbmFsbGluZ1NlcnZlclVybCk7XG4gICAgICAgICAgICByZXR1cm4gc2lnbmFsbGluZ1NlcnZlclVybDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIHZpZGVvIHBsYXllciBhbmQgbWFrZXMgc3VyZSByZXNvdXJjZXMgYXJlIGZyZWVkLiBUaGlzIGhlbHBzIHRvIHByZXZlbnQgdGhlIGlzc3VlIGluIGNocm9tZVxuICAgICAqIHdoZXJlIGl0IHJlZnVzZXMgdG8gbWFrZSBuZXcgdmlkZW8gcGxheWVycy5cbiAgICAgKi9cbiAgICBkZXN0cm95VmlkZW9QbGF5ZXIoKSB7XG4gICAgICAgIHRoaXMudmlkZW9QbGF5ZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkXG4gICAgICogQHBhcmFtIGV2ZW50IC0gTWVzc2FnZSBFdmVudFxuICAgICAqL1xuICAgIGhhbmRsZU9uTWVzc2FnZShldmVudCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkoZXZlbnQuZGF0YSk7XG4gICAgICAgIExvZ2dlci5JbmZvKCdNZXNzYWdlIGluY29taW5nOicgKyBtZXNzYWdlKTtcbiAgICAgICAgLy90cnkge1xuICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIuZnJvbVN0cmVhbWVyTWVzc2FnZXMuZ2V0KG1lc3NhZ2VbMF0pO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLmZyb21TdHJlYW1lckhhbmRsZXJzLmdldChtZXNzYWdlVHlwZSkoZXZlbnQuZGF0YSk7XG4gICAgICAgIC8vfSBjYXRjaCAoZSkge1xuICAgICAgICAvL0xvZ2dlci5FcnJvcihMb2dnZXIuR2V0U3RhY2tUcmFjZSgpLCBgQ3VzdG9tIGRhdGEgY2hhbm5lbCBtZXNzYWdlIHdpdGggbWVzc2FnZSB0eXBlIHRoYXQgaXMgdW5rbm93biB0byB0aGUgUGl4ZWwgU3RyZWFtaW5nIHByb3RvY29sLiBEb2VzIHlvdXIgUGl4ZWxTdHJlYW1pbmdQcm90b2NvbCBuZWVkIHVwZGF0aW5nPyBUaGUgbWVzc2FnZSB0eXBlIHdhczogJHttZXNzYWdlWzBdfWApO1xuICAgICAgICAvL31cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgbWVzc2FnZSBhbGwgaGFuZGxlcnNcbiAgICAgKi9cbiAgICByZWdpc3Rlck1lc3NhZ2VIYW5kbGVycygpIHtcbiAgICAgICAgLy8gRnJvbSBTdHJlYW1lclxuICAgICAgICAvLyBNZXNzYWdlIGV2ZW50cyBmcm9tIHRoZSBzdHJlYW1lciBoYXZlIGEgZGF0YSB0eXBlIG9mIEFycmF5QnVmZmVyIGFzIHdlIGZvcmNlIHRoaXMgdHlwZSBpbiB0aGUgRGF0YWNoYW5uZWxDb250cm9sbGVyXG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ1F1YWxpdHlDb250cm9sT3duZXJzaGlwJywgKGRhdGEpID0+IHRoaXMub25RdWFsaXR5Q29udHJvbE93bmVyc2hpcChkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ1Jlc3BvbnNlJywgKGRhdGEpID0+IHRoaXMucmVzcG9uc2VDb250cm9sbGVyLm9uUmVzcG9uc2UoZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsICdDb21tYW5kJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25Db21tYW5kKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCAnRnJlZXplRnJhbWUnLCAoZGF0YSkgPT4gdGhpcy5vbkZyZWV6ZUZyYW1lTWVzc2FnZShkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ1VuZnJlZXplRnJhbWUnLCAoKSA9PiB0aGlzLmludmFsaWRhdGVGcmVlemVGcmFtZUFuZEVuYWJsZVZpZGVvKCkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsICdWaWRlb0VuY29kZXJBdmdRUCcsIChkYXRhKSA9PiB0aGlzLmhhbmRsZVZpZGVvRW5jb2RlckF2Z1FQKGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCAnTGF0ZW5jeVRlc3QnLCAoZGF0YSkgPT4gdGhpcy5oYW5kbGVMYXRlbmN5VGVzdFJlc3VsdChkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ0RhdGFDaGFubmVsTGF0ZW5jeVRlc3QnLCAoZGF0YSkgPT4gdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbExhdGVuY3lUZXN0UmVzcG9uc2UoZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsICdJbml0aWFsU2V0dGluZ3MnLCAoZGF0YSkgPT4gdGhpcy5oYW5kbGVJbml0aWFsU2V0dGluZ3MoZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsICdGaWxlRXh0ZW5zaW9uJywgKGRhdGEpID0+IHRoaXMub25GaWxlRXh0ZW5zaW9uKGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCAnRmlsZU1pbWVUeXBlJywgKGRhdGEpID0+IHRoaXMub25GaWxlTWltZVR5cGUoZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsICdGaWxlQ29udGVudHMnLCAoZGF0YSkgPT4gdGhpcy5vbkZpbGVDb250ZW50cyhkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ1Rlc3RFY2hvJywgKCkgPT4ge1xuICAgICAgICAgICAgLyogRG8gbm90aGluZyAqL1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCAnSW5wdXRDb250cm9sT3duZXJzaGlwJywgKGRhdGEpID0+IHRoaXMub25JbnB1dENvbnRyb2xPd25lcnNoaXAoZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXIsICdHYW1lcGFkUmVzcG9uc2UnLCAoZGF0YSkgPT4gdGhpcy5vbkdhbWVwYWRSZXNwb25zZShkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciwgJ011bHRpcGxleGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgLyogRG8gbm90aGluZyBhcyB0aGlzIG1lc3NhZ2UgdHlwZSBpcyB1c2VkIG9ubHkgYnkgdGhlIFNGVSAqL1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCAnUHJvdG9jb2wnLCAoZGF0YSkgPT4gdGhpcy5vblByb3RvY29sTWVzc2FnZShkYXRhKSk7XG4gICAgICAgIC8vIFRvIFN0cmVhbWVyXG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdJRnJhbWVSZXF1ZXN0JywgKCkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdJRnJhbWVSZXF1ZXN0JykpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnUmVxdWVzdFF1YWxpdHlDb250cm9sJywgKCkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdSZXF1ZXN0UXVhbGl0eUNvbnRyb2wnKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdGcHNSZXF1ZXN0JywgKCkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdGcHNSZXF1ZXN0JykpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnQXZlcmFnZUJpdHJhdGVSZXF1ZXN0JywgKCkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdBdmVyYWdlQml0cmF0ZVJlcXVlc3QnKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdTdGFydFN0cmVhbWluZycsICgpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignU3RhcnRTdHJlYW1pbmcnKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdTdG9wU3RyZWFtaW5nJywgKCkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdTdG9wU3RyZWFtaW5nJykpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnTGF0ZW5jeVRlc3QnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdMYXRlbmN5VGVzdCcsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1JlcXVlc3RJbml0aWFsU2V0dGluZ3MnLCAoKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1JlcXVlc3RJbml0aWFsU2V0dGluZ3MnKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdUZXN0RWNobycsICgpID0+IHtcbiAgICAgICAgICAgIC8qIERvIG5vdGhpbmcgKi9cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdVSUludGVyYWN0aW9uJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignVUlJbnRlcmFjdGlvbicsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ0NvbW1hbmQnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdDb21tYW5kJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnVGV4dGJveEVudHJ5JywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignVGV4dGJveEVudHJ5JywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnS2V5RG93bicsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0tleURvd24nLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdLZXlVcCcsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0tleVVwJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnS2V5UHJlc3MnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdLZXlQcmVzcycsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ01vdXNlRW50ZXInLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdNb3VzZUVudGVyJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnTW91c2VMZWF2ZScsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ01vdXNlTGVhdmUnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdNb3VzZURvd24nLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdNb3VzZURvd24nLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdNb3VzZVVwJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignTW91c2VVcCcsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ01vdXNlTW92ZScsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ01vdXNlTW92ZScsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ01vdXNlV2hlZWwnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdNb3VzZVdoZWVsJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnTW91c2VEb3VibGUnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdNb3VzZURvdWJsZScsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1RvdWNoU3RhcnQnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdUb3VjaFN0YXJ0JywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnVG91Y2hFbmQnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdUb3VjaEVuZCcsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1RvdWNoTW92ZScsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1RvdWNoTW92ZScsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ0dhbWVwYWRDb25uZWN0ZWQnLCAoKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0dhbWVwYWRDb25uZWN0ZWQnKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdHYW1lcGFkQnV0dG9uUHJlc3NlZCcsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0dhbWVwYWRCdXR0b25QcmVzc2VkJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnR2FtZXBhZEJ1dHRvblJlbGVhc2VkJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignR2FtZXBhZEJ1dHRvblJlbGVhc2VkJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnR2FtZXBhZEFuYWxvZycsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ0dhbWVwYWRBbmFsb2cnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdHYW1lcGFkRGlzY29ubmVjdGVkJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignR2FtZXBhZERpc2Nvbm5lY3RlZCcsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1hSRXllVmlld3MnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdYUkV5ZVZpZXdzJywgZGF0YSkpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnWFJITURUcmFuc2Zvcm0nLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdYUkhNRFRyYW5zZm9ybScsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1hSQ29udHJvbGxlclRyYW5zZm9ybScsIChkYXRhKSA9PiB0aGlzLnNlbmRNZXNzYWdlQ29udHJvbGxlci5zZW5kTWVzc2FnZVRvU3RyZWFtZXIoJ1hSQ29udHJvbGxlclRyYW5zZm9ybScsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1hSU3lzdGVtJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignWFJTeXN0ZW0nLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdYUkJ1dHRvblRvdWNoZWQnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdYUkJ1dHRvblRvdWNoZWQnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdYUkJ1dHRvblRvdWNoUmVsZWFzZWQnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdYUkJ1dHRvblRvdWNoUmVsZWFzZWQnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdYUkJ1dHRvblByZXNzZWQnLCAoZGF0YSkgPT4gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKCdYUkJ1dHRvblByZXNzZWQnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdYUkJ1dHRvblJlbGVhc2VkJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignWFJCdXR0b25SZWxlYXNlZCcsIGRhdGEpKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lciwgJ1hSQW5hbG9nJywgKGRhdGEpID0+IHRoaXMuc2VuZE1lc3NhZ2VDb250cm9sbGVyLnNlbmRNZXNzYWdlVG9TdHJlYW1lcignWFJBbmFsb2cnLCBkYXRhKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsICdDaGFubmVsUmVsYXlTdGF0dXMnLCAoKSA9PiB7XG4gICAgICAgICAgICAvKiBEbyBub3RoaW5nIGFzIHRoaXMgbWVzc2FnZSB0eXBlIGlzIHVzZWQgb25seSBieSB0aGUgU0ZVICovXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoTWVzc2FnZURpcmVjdGlvbi5Ub1N0cmVhbWVyLCAnTXVsdGlwbGV4ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAvKiBEbyBub3RoaW5nIGFzIHRoaXMgbWVzc2FnZSB0eXBlIGlzIHVzZWQgb25seSBieSB0aGUgU0ZVICovXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZSB0aGUgbG9naWMgYXNzb2NpYXRlZCB3aXRoIGEgY29tbWFuZCBmcm9tIFVFXG4gICAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBvbkNvbW1hbmQobWVzc2FnZSkge1xuICAgICAgICBMb2dnZXIuSW5mbygnRGF0YUNoYW5uZWxSZWNlaXZlTWVzc2FnZVR5cGUuQ29tbWFuZCcpO1xuICAgICAgICBjb25zdCBjb21tYW5kQXNTdHJpbmcgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi0xNicpLmRlY29kZShtZXNzYWdlLnNsaWNlKDEpKTtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ0RhdGEgQ2hhbm5lbCBDb21tYW5kOiAnICsgY29tbWFuZEFzU3RyaW5nKTtcbiAgICAgICAgY29uc3QgY29tbWFuZCA9IEpTT04ucGFyc2UoY29tbWFuZEFzU3RyaW5nKTtcbiAgICAgICAgLy8gSGFuZGxlIFwib25TY3JlZW5LZXlib2FyZFwiIGV2ZW50XG4gICAgICAgIGlmIChjb21tYW5kLmNvbW1hbmQgPT09ICdvblNjcmVlbktleWJvYXJkJykge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVPblNjcmVlbktleWJvYXJkQ29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVPblNjcmVlbktleWJvYXJkQ29tbWFuZChjb21tYW5kKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHNob3dPblNjcmVlbktleWJvYXJkOiAoX2EgPSBjb21tYW5kLnNob3dPblNjcmVlbktleWJvYXJkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlLFxuICAgICAgICAgICAgeDogKF9iID0gY29tbWFuZC54KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwLFxuICAgICAgICAgICAgeTogKF9jID0gY29tbWFuZC55KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwLFxuICAgICAgICAgICAgY29udGVudHM6IChfZCA9IGNvbW1hbmQuY29udGVudHMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICcnXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuZGlzcGF0Y2hFdmVudChuZXcgU2hvd09uU2NyZWVuS2V5Ym9hcmRFdmVudChkYXRhKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSBwcm90b2NvbCBtZXNzYWdlIHJlY2VpdmVkIGZyb20gdGhlIHN0cmVhbWVyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgdGhlIG1lc3NhZ2UgZGF0YSBmcm9tIHRoZSBzdHJlYW1lclxuICAgICAqL1xuICAgIG9uUHJvdG9jb2xNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sU3RyaW5nID0gbmV3IFRleHREZWNvZGVyKCd1dGYtMTYnKS5kZWNvZGUobWVzc2FnZS5zbGljZSgxKSk7XG4gICAgICAgICAgICBjb25zdCBwcm90b2NvbEpTT04gPSBKU09OLnBhcnNlKHByb3RvY29sU3RyaW5nKTtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvY29sSlNPTiwgJ0RpcmVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKCdNYWxmb3JtZWQgcHJvdG9jb2wgcmVjZWl2ZWQuIEVuc3VyZSB0aGUgcHJvdG9jb2wgbWVzc2FnZSBjb250YWlucyBhIGRpcmVjdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gcHJvdG9jb2xKU09OLkRpcmVjdGlvbjtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm90b2NvbEpTT04uRGlyZWN0aW9uO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oYFJlY2VpdmVkIG5ldyAke2RpcmVjdGlvbiA9PSBNZXNzYWdlRGlyZWN0aW9uLkZyb21TdHJlYW1lciA/ICdGcm9tU3RyZWFtZXInIDogJ1RvU3RyZWFtZXInfSBwcm90b2NvbC4gVXBkYXRpbmcgZXhpc3RpbmcgcHJvdG9jb2wuLi5gKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb3RvY29sSlNPTikuZm9yRWFjaCgobWVzc2FnZVR5cGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gcHJvdG9jb2xKU09OW21lc3NhZ2VUeXBlXTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VEaXJlY3Rpb24uVG9TdHJlYW1lcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIG1lc3NhZ2UgY29udGFpbnMgYWxsIHRoZSByZWxldmFudCBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdpZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBUb1N0cmVhbWVyLT4ke21lc3NhZ2VUeXBlfSBwcm90b2NvbCBkZWZpbml0aW9uIHdhcyBtYWxmb3JtZWQgYXMgaXQgZGlkbid0IGNvbnRhaW4gYXQgbGVhc3QgYW4gaWRcXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZpbml0aW9uIHdhczogJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlLCBudWxsLCAyKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gaW4gYSBmb3JFYWNoIGlzIGVxdWl2YWxlbnQgdG8gYSBjb250aW51ZSBpbiBhIG5vcm1hbCBmb3IgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVFNS4xIGFuZCBVRTUuMiBkb24ndCBzZW5kIGEgc3RydWN0dXJlIGZvciB0aGVzZSBtZXNzYWdlIHR5cGVzLCBidXQgdGhleSBhY3R1YWxseSBkbyBoYXZlIGEgc3RydWN0dXJlIHNvIGlnbm9yZSB1cGRhdGluZyB0aGVtXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVR5cGUgPT09ICdVSUludGVyYWN0aW9uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VUeXBlID09PSAnQ29tbWFuZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlVHlwZSA9PT0gJ0xhdGVuY3lUZXN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQobWVzc2FnZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgcmVnaXN0ZXJlZCBhIGhhbmRsZXIgZm9yIHRoaXMgbWVzc2FnZSB0eXBlIHdlIGNhbiBhZGQgaXQgdG8gb3VyIHN1cHBvcnRlZCBtZXNzYWdlcy4gaWUgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlciguLi4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVyTWVzc2FnZXMuc2V0KG1lc3NhZ2VUeXBlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihgVGhlcmUgd2FzIG5vIHJlZ2lzdGVyZWQgaGFuZGxlciBmb3IgXCIke21lc3NhZ2VUeXBlfVwiIC0gdHJ5IGFkZGluZyBvbmUgdXNpbmcgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXIsIFwiJHttZXNzYWdlVHlwZX1cIiwgbXlIYW5kbGVyKWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZURpcmVjdGlvbi5Gcm9tU3RyZWFtZXI6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBtZXNzYWdlIGNvbnRhaW5zIGFsbCB0aGUgcmVsZXZhbnQgcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnaWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihgRnJvbVN0cmVhbWVyLT4ke21lc3NhZ2VUeXBlfSBwcm90b2NvbCBkZWZpbml0aW9uIHdhcyBtYWxmb3JtZWQgYXMgaXQgZGlkbid0IGNvbnRhaW4gYXQgbGVhc3QgYW4gaWRcXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZpbml0aW9uIHdhczogJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlLCBudWxsLCAyKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gaW4gYSBmb3JFYWNoIGlzIGVxdWl2YWxlbnQgdG8gYSBjb250aW51ZSBpbiBhIG5vcm1hbCBmb3IgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLmZyb21TdHJlYW1lckhhbmRsZXJzLmdldChtZXNzYWdlVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSByZWdpc3RlcmVkIGEgaGFuZGxlciBmb3IgdGhpcyBtZXNzYWdlIHR5cGUuIGllIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoLi4uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIuZnJvbVN0cmVhbWVyTWVzc2FnZXMuc2V0KG1lc3NhZ2UuaWQsIG1lc3NhZ2VUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihgVGhlcmUgd2FzIG5vIHJlZ2lzdGVyZWQgaGFuZGxlciBmb3IgXCIke21lc3NhZ2V9XCIgLSB0cnkgYWRkaW5nIG9uZSB1c2luZyByZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyLCBcIiR7bWVzc2FnZVR5cGV9XCIsIG15SGFuZGxlcilgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBVbmtub3duIGRpcmVjdGlvbjogJHtkaXJlY3Rpb259YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBPbmNlIHRoZSBwcm90b2NvbCBoYXMgYmVlbiByZWNlaXZlZCwgd2UgY2FuIHNlbmQgb3VyIGNvbnRyb2wgbWVzc2FnZXNcbiAgICAgICAgICAgIHRoaXMudG9TdHJlYW1lck1lc3NhZ2VzQ29udHJvbGxlci5TZW5kUmVxdWVzdEluaXRpYWxTZXR0aW5ncygpO1xuICAgICAgICAgICAgdGhpcy50b1N0cmVhbWVyTWVzc2FnZXNDb250cm9sbGVyLlNlbmRSZXF1ZXN0UXVhbGl0eUNvbnRyb2woKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhbiBpbnB1dCBjb250cm9sIG1lc3NhZ2Ugd2hlbiBpdCBpcyByZWNlaXZlZCBmcm9tIHRoZSBzdHJlYW1lclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBpbnB1dCBjb250cm9sIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBvbklucHV0Q29udHJvbE93bmVyc2hpcChtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ0RhdGFDaGFubmVsUmVjZWl2ZU1lc3NhZ2VUeXBlLklucHV0Q29udHJvbE93bmVyc2hpcCcpO1xuICAgICAgICBjb25zdCBpbnB1dENvbnRyb2xPd25lcnNoaXAgPSBuZXcgQm9vbGVhbih2aWV3WzFdKS52YWx1ZU9mKCk7XG4gICAgICAgIExvZ2dlci5JbmZvKGBSZWNlaXZlZCBpbnB1dCBjb250cm9sbGVyIG1lc3NhZ2UgLSB3aWxsIHlvdXIgaW5wdXQgY29udHJvbCB0aGUgc3RyZWFtOiAke2lucHV0Q29udHJvbE93bmVyc2hpcH1gKTtcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25JbnB1dENvbnRyb2xPd25lcnNoaXAoaW5wdXRDb250cm9sT3duZXJzaGlwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgICAqL1xuICAgIG9uR2FtZXBhZFJlc3BvbnNlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VTdHJpbmcgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi0xNicpLmRlY29kZShtZXNzYWdlLnNsaWNlKDEpKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VKU09OID0gSlNPTi5wYXJzZShyZXNwb25zZVN0cmluZyk7XG4gICAgICAgIHRoaXMuZ2FtZVBhZENvbnRyb2xsZXIub25HYW1lcGFkUmVzcG9uc2VSZWNlaXZlZChyZXNwb25zZUpTT04uY29udHJvbGxlcklkKTtcbiAgICB9XG4gICAgb25BZmtUcmlnZ2VyZWQoKSB7XG4gICAgICAgIHRoaXMuYWZrQ29udHJvbGxlci5vbkFma0NsaWNrKCk7XG4gICAgICAgIC8vIGlmIHRoZSBzdHJlYW0gaXMgcGF1c2VkIHBsYXkgaXQsIGlmIHdlIGNhblxuICAgICAgICBpZiAodGhpcy52aWRlb1BsYXllci5pc1BhdXNlZCgpICYmIHRoaXMudmlkZW9QbGF5ZXIuaGFzVmlkZW9Tb3VyY2UoKSkge1xuICAgICAgICAgICAgdGhpcy5wbGF5U3RyZWFtKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgd2Ugc2hvdWxkIHRpbWVvdXQgd2hlbiBhZmsuXG4gICAgICogQHBhcmFtIGFma0VuYWJsZWQgSWYgdHJ1ZSB3ZSB0aW1lb3V0IHdoZW4gaWRsZSBmb3Igc29tZSBnaXZlbiBhbW91bnQgb2YgdGltZS5cbiAgICAgKi9cbiAgICBzZXRBZmtFbmFibGVkKGFma0VuYWJsZWQpIHtcbiAgICAgICAgaWYgKGFma0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25BZmtUcmlnZ2VyZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWZrQ29udHJvbGxlci5zdG9wQWZrV2FybmluZ1RpbWVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbiB0byB0aGUgc2lnbmFsbGluZyBzZXJ2ZXIuIE1hbnVhbCB0cmlnZ2VyXG4gICAgICovXG4gICAgdHJ5UmVjb25uZWN0KG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5mb3JjZVJlY29ubmVjdCA9IHRydWU7XG4gICAgICAgIHRoaXMuZG9SZWNvbm5lY3QobWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIGFjdHVhbCByZWNvbm5lY3Qgd29yay4gVXNlZCBieSB0aGUgYXV0byByZWNvbm5lY3QgZmVhdHVyZSB0byBza2lwIHRoZSBtYW51YWwgZmxhZy5cbiAgICAgKi9cbiAgICBkb1JlY29ubmVjdChtZXNzYWdlKSB7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIHdlYlNvY2tldENvbnRyb2xsZXIgcmV0dXJuIGltbWVkaWF0ZWx5IG9yIHRoaXMgd2lsbCBub3Qgd29ya1xuICAgICAgICBpZiAoIXRoaXMucHJvdG9jb2wpIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdUaGlzIHBsYXllciBoYXMgbm8gcHJvdG9jb2wgY29ubmVjdGlvbi4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUmVjb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgdGhlIGNvbm5lY3Rpb24gaXMgb3BlbiwgZmlyc3QgY2xvc2UgaXQgYW5kIGZvcmNlIGEgcmVjb25uZWN0LlxuICAgICAgICBpZiAodGhpcy5wcm90b2NvbC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9yY2VSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RNZXNzYWdlID0gYCR7bWVzc2FnZX0gUmVjb25uZWN0aW5nLmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsb3NlU2lnbmFsaW5nU2VydmVyKG1lc3NhZ2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25XZWJSdGNBdXRvQ29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VG9TaWduYWxsaW5nU2VydmVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBmcmVlemUgZnJhbWUgaWYgaXQgaXMgcmVxdWlyZWQgb3RoZXJ3aXNlIHNob3dzIHRoZSBwbGF5IG92ZXJsYXlcbiAgICAgKi9cbiAgICBsb2FkRnJlZXplRnJhbWVPclNob3dQbGF5T3ZlcmxheSgpIHtcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBMb2FkRnJlZXplRnJhbWVFdmVudCh7XG4gICAgICAgICAgICBzaG91bGRTaG93UGxheU92ZXJsYXk6IHRoaXMuc2hvdWxkU2hvd1BsYXlPdmVybGF5LFxuICAgICAgICAgICAgaXNWYWxpZDogdGhpcy5mcmVlemVGcmFtZUNvbnRyb2xsZXIudmFsaWQsXG4gICAgICAgICAgICBqcGVnRGF0YTogdGhpcy5mcmVlemVGcmFtZUNvbnRyb2xsZXIuanBlZ1xuICAgICAgICB9KSk7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFNob3dQbGF5T3ZlcmxheSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ3Nob3dpbmcgcGxheSBvdmVybGF5Jyk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVBsYXllclN0eWxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnc2hvd2luZyBmcmVlemUgZnJhbWUnKTtcbiAgICAgICAgICAgIHRoaXMuZnJlZXplRnJhbWVDb250cm9sbGVyLnNob3dGcmVlemVGcmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWRlb1BsYXllci5zZXRWaWRlb0VuYWJsZWQoZmFsc2UpO1xuICAgICAgICB9LCB0aGlzLmZyZWV6ZUZyYW1lQ29udHJvbGxlci5mcmVlemVGcmFtZURlbGF5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgZnJlZXplIGZyYW1lIGFuZCBsb2FkIGl0XG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIGZyZWV6ZSBmcmFtZSBkYXRhIGluIGJ5dGVzXG4gICAgICovXG4gICAgb25GcmVlemVGcmFtZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBMb2dnZXIuSW5mbygnRGF0YUNoYW5uZWxSZWNlaXZlTWVzc2FnZVR5cGUuRnJlZXplRnJhbWUnKTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lQ29udHJvbGxlci5wcm9jZXNzRnJlZXplRnJhbWVNZXNzYWdlKHZpZXcsICgpID0+IHRoaXMubG9hZEZyZWV6ZUZyYW1lT3JTaG93UGxheU92ZXJsYXkoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0aGUgdmlkZW8gYWZ0ZXIgaGlkaW5nIGEgZnJlZXplIGZyYW1lXG4gICAgICovXG4gICAgaW52YWxpZGF0ZUZyZWV6ZUZyYW1lQW5kRW5hYmxlVmlkZW8oKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCdEYXRhQ2hhbm5lbFJlY2VpdmVNZXNzYWdlVHlwZS5GcmVlemVGcmFtZScpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuZGlzcGF0Y2hFdmVudChuZXcgSGlkZUZyZWV6ZUZyYW1lRXZlbnQoKSk7XG4gICAgICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lQ29udHJvbGxlci5oaWRlRnJlZXplRnJhbWUoKTtcbiAgICAgICAgfSwgdGhpcy5mcmVlemVGcmFtZUNvbnRyb2xsZXIuZnJlZXplRnJhbWVEZWxheSk7XG4gICAgICAgIGlmICh0aGlzLnZpZGVvUGxheWVyLmdldFZpZGVvRWxlbWVudCgpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvUGxheWVyLnNldFZpZGVvRW5hYmxlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwIGRhdGFjaGFubmVsIGRhdGEgZm9yIHByb2Nlc3NpbmcgZmlsZSBleHRlbnNpb25cbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgZmlsZSBleHRlbnNpb24gZGF0YVxuICAgICAqL1xuICAgIG9uRmlsZUV4dGVuc2lvbihkYXRhKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgRmlsZVV0aWwuc2V0RXh0ZW5zaW9uRnJvbUJ5dGVzKHZpZXcsIHRoaXMuZmlsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXAgZGF0YWNoYW5uZWwgZGF0YSBmb3IgcHJvY2Vzc2luZyB0aGUgZmlsZSBtaW1lIHR5cGVcbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgZmlsZSBtaW1lIHR5cGUgZGF0YVxuICAgICAqL1xuICAgIG9uRmlsZU1pbWVUeXBlKGRhdGEpIHtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICBGaWxlVXRpbC5zZXRNaW1lVHlwZUZyb21CeXRlcyh2aWV3LCB0aGlzLmZpbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwIGRhdGFjaGFubmVsIGRhdGEgZm9yIHByb2Nlc3NpbmcgdGhlIGZpbGUgY29udGVudHNcbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgZmlsZSBjb250ZW50cyBkYXRhXG4gICAgICovXG4gICAgb25GaWxlQ29udGVudHMoZGF0YSkge1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgIEZpbGVVdGlsLnNldENvbnRlbnRzRnJvbUJ5dGVzKHZpZXcsIHRoaXMuZmlsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBsYXlzIHRoZSBzdHJlYW0gYXVkaW8gYW5kIHZpZGVvIHNvdXJjZSBhbmQgc2V0cyB1cCBvdGhlciBwaWVjZXMgd2hpbGUgdGhlIHN0cmVhbSBzdGFydHNcbiAgICAgKi9cbiAgICBwbGF5U3RyZWFtKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlkZW9QbGF5ZXIuZ2V0VmlkZW9FbGVtZW50KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQ291bGQgbm90IHBsYXkgdmlkZW8gc3RyZWFtIGJlY2F1c2UgdGhlIHZpZGVvIHBsYXllciB3YXMgbm90IGluaXRpYWxpemVkIGNvcnJlY3RseS4nO1xuICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBQbGF5U3RyZWFtRXJyb3JFdmVudCh7IG1lc3NhZ2UgfSkpO1xuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gY2xvc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgIHRoaXMuY2xvc2VTaWduYWxpbmdTZXJ2ZXIoJ1N0cmVhbSBub3QgaW5pdGlhbGl6ZWQgY29ycmVjdGx5JywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy52aWRlb1BsYXllci5oYXNWaWRlb1NvdXJjZSgpKSB7XG4gICAgICAgICAgICBMb2dnZXIuV2FybmluZygnQ2Fubm90IHBsYXkgc3RyZWFtLCB0aGUgdmlkZW8gZWxlbWVudCBoYXMgbm8gc3JjT2JqZWN0IHRvIHBsYXkuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRUb3VjaElucHV0RW5hYmxlZCh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLlRvdWNoSW5wdXQpKTtcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBQbGF5U3RyZWFtRXZlbnQoKSk7XG4gICAgICAgIGlmICh0aGlzLnN0cmVhbUNvbnRyb2xsZXIuYXVkaW9FbGVtZW50LnNyY09iamVjdCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRNdXRlZCA9IHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuU3RhcnRWaWRlb011dGVkKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5hdWRpb0VsZW1lbnQubXV0ZWQgPSBzdGFydE11dGVkO1xuICAgICAgICAgICAgaWYgKHN0YXJ0TXV0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlWaWRlbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLmF1ZGlvRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAucGxheSgpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5VmlkZW8oKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKG9uUmVqZWN0ZWRSZWFzb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkluZm8ob25SZWplY3RlZFJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5JbmZvKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYXV0b3BsYXlpbmcgdmlkZW8gd2l0aG91dCBpbnRlcmFjdGlvbiAtIHRvIHJlc29sdmUgdGhpcyB3ZSBhcmUgZ29pbmcgdG8gc2hvdyB0aGUgcGxheSBidXR0b24gb3ZlcmxheS4nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBQbGF5U3RyZWFtUmVqZWN0ZWRFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IG9uUmVqZWN0ZWRSZWFzb25cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wbGF5VmlkZW8oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNob3VsZFNob3dQbGF5T3ZlcmxheSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lQ29udHJvbGxlci5zaG93RnJlZXplRnJhbWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGxheXMgdGhlIHZpZGVvIHN0cmVhbVxuICAgICAqL1xuICAgIHBsYXlWaWRlbygpIHtcbiAgICAgICAgLy8gaGFuZGxlIHBsYXkoKSB3aXRoIHByb21pc2UgYXMgaXQgaXMgYW4gYXN5bmNocm9ub3VzIGNhbGxcbiAgICAgICAgdGhpcy52aWRlb1BsYXllci5wbGF5KCkuY2F0Y2goKG9uUmVqZWN0ZWRSZWFzb24pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbUNvbnRyb2xsZXIuYXVkaW9FbGVtZW50LnNyY09iamVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5hdWRpb0VsZW1lbnQucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIExvZ2dlci5JbmZvKG9uUmVqZWN0ZWRSZWFzb24pO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ0Jyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhdXRvcGxheWluZyB2aWRlbyB3aXRob3V0IGludGVyYWN0aW9uIC0gdG8gcmVzb2x2ZSB0aGlzIHdlIGFyZSBnb2luZyB0byBzaG93IHRoZSBwbGF5IGJ1dHRvbiBvdmVybGF5LicpO1xuICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBQbGF5U3RyZWFtUmVqZWN0ZWRFdmVudCh7IHJlYXNvbjogb25SZWplY3RlZFJlYXNvbiB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdGhlIHZpZGVvIHRvIHBsYXkgYXV0b21hdGljYWxseSBpZiBlbmFibGVBdXRvcGxheSBpcyB0cnVlXG4gICAgICovXG4gICAgYXV0b1BsYXlWaWRlb09yU2V0VXBQbGF5T3ZlcmxheSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuQXV0b1BsYXlWaWRlbykpIHtcbiAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gcGxheSB0aGUgdmlkZW9cbiAgICAgICAgICAgIHRoaXMucGxheVN0cmVhbSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzaXplUGxheWVyU3R5bGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byB0aGUgU2lnbmFsaW5nIHNlcnZlclxuICAgICAqL1xuICAgIGNvbm5lY3RUb1NpZ25hbGxpbmdTZXJ2ZXIoKSB7XG4gICAgICAgIHRoaXMubG9jYWxseUNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuYWJsZUF1dG9SZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc2lnbmFsbGluZ1VybCA9IHRoaXMuc2lnbmFsbGluZ1VybEJ1aWxkZXIoKTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC5jb25uZWN0KHNpZ25hbGxpbmdVcmwpO1xuICAgICAgICBjb25zdCBrZWVwYWxpdmVEZWxheSA9IHRoaXMuY29uZmlnLmdldE51bWVyaWNTZXR0aW5nVmFsdWUoTnVtZXJpY1BhcmFtZXRlcnMuS2VlcGFsaXZlRGVsYXkpO1xuICAgICAgICBpZiAoa2VlcGFsaXZlRGVsYXkgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZSA9IG5ldyBLZWVwYWxpdmVNb25pdG9yKHRoaXMucHJvdG9jb2wsIGtlZXBhbGl2ZURlbGF5KTtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlLm9uVGltZW91dCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcGluZyBmYWlscyBqdXN0IGRpc2Nvbm5lY3RcbiAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoYFByb3RvY29sIHRpbWVvdXRgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RvY29sLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyB3aWxsIHN0YXJ0IHRoZSBoYW5kc2hha2UgdG8gdGhlIHNpZ25hbGxpbmcgc2VydmVyXG4gICAgICogQHBhcmFtIHBlZXJDb25maWcgIC0gUlRDIENvbmZpZ3VyYXRpb24gT3B0aW9ucyBmcm9tIHRoZSBTaWduYWxpbmcgc2VydmVyXG4gICAgICogQHJlbWFyayBSVEMgUGVlciBDb25uZWN0aW9uIG9uIEljZSBDYW5kaWRhdGUgZXZlbnQgaGF2ZSBpdCBoYW5kbGVkIGJ5IGhhbmRsZSBTZW5kIEljZSBDYW5kaWRhdGVcbiAgICAgKi9cbiAgICBzdGFydFNlc3Npb24ocGVlckNvbmZpZykge1xuICAgICAgICB0aGlzLnBlZXJDb25maWcgPSBwZWVyQ29uZmlnO1xuICAgICAgICAvLyBjaGVjayBmb3IgZm9yY2luZyB0dXJuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkZvcmNlVFVSTikpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBhIHR1cm4gc2VydmVyXG4gICAgICAgICAgICBjb25zdCBoYXNUdXJuU2VydmVyID0gdGhpcy5jaGVja1R1cm5TZXJ2ZXJBdmFpbGFiaWxpdHkocGVlckNvbmZpZyk7XG4gICAgICAgICAgICAvLyBjbG9zZSBhbmQgZXJyb3IgaWYgdHVybiBpcyBmb3JjZWQgYW5kIHRoZXJlIGlzIG5vIHR1cm4gc2VydmVyXG4gICAgICAgICAgICBpZiAoIWhhc1R1cm5TZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuSW5mbygnTm8gdHVybiBzZXJ2ZXIgd2FzIGZvdW5kIGluIHRoZSBQZWVyIENvbm5lY3Rpb24gT3B0aW9ucy4gVFVSTiBjYW5ub3QgYmUgZm9yY2VkLCBjbG9zaW5nIGNvbm5lY3Rpb24uIFBsZWFzZSB1c2UgU1RVTiBpbnN0ZWFkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVNpZ25hbGluZ1NlcnZlcignVFVSTiBjYW5ub3QgYmUgZm9yY2VkLCBjbG9zaW5nIGNvbm5lY3Rpb24uIFBsZWFzZSB1c2UgU1RVTiBpbnN0ZWFkLicsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHVwIHRoZSBwZWVyIGNvbm5lY3Rpb24gY29udHJvbGxlclxuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlciA9IG5ldyBQZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIodGhpcy5wZWVyQ29uZmlnLCB0aGlzLmNvbmZpZywgdGhpcy5wcmVmZXJyZWRDb2RlYyk7XG4gICAgICAgIC8vIHNldCB1cCBwZWVyIGNvbm5lY3Rpb24gY29udHJvbGxlciB2aWRlbyBzdGF0c1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5vblZpZGVvU3RhdHMgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVmlkZW9TdGF0cyhldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qIFNldCBldmVudCBoYW5kbGVyIGZvciBsYXRlbmN5IGluZm9ybWF0aW9uIGlzIGNhbGN1bGF0ZWQsIGhhbmRsZSB0aGUgZXZlbnQgYnkgcHJvcG9nYXRpbmcgdG8gdGhlIFBpeGVsU3RyZWFtaW5nIEFQSSAqL1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5vbkxhdGVuY3lDYWxjdWxhdGVkID0gKGxhdGVuY3lJbmZvKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbkxhdGVuY3lDYWxjdWxhdGVkKGxhdGVuY3lJbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyogV2hlbiBvdXIgUGVlckNvbm5lY3Rpb24gd2FudHMgdG8gc2VuZCBhbiBvZmZlciBjYWxsIG91ciBoYW5kbGVyICovXG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLm9uU2VuZFdlYlJUQ09mZmVyID0gKG9mZmVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNlbmRXZWJSVENPZmZlcihvZmZlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qIFNldCBldmVudCBoYW5kbGVyIGZvciB3aGVuIGxvY2FsIGRlc2NyaXB0aW9uIGlzIHNldCAqL1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5vblNldExvY2FsRGVzY3JpcHRpb24gPSAoc2RwKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2RwLnR5cGUgPT09ICdvZmZlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNlbmRXZWJSVENPZmZlcihzZHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2RwLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTZW5kV2ViUlRDQW5zd2VyKHNkcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoYFBlZXJDb25uZWN0aW9uQ29udHJvbGxlciBvblNldExvY2FsRGVzY3JpcHRpb24gd2FzIGNhbGxlZCB3aXRoIHVuZXhwZWN0ZWQgdHlwZSAke3NkcC50eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBFdmVudCBoYW5kbGVyIGZvciB3aGVuIFBlZXJDb25uZWN0aW9uJ3MgcmVtb3RlIGRlc2NyaXB0aW9uIGlzIHNldCAqL1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5vblNldFJlbW90ZURlc2NyaXB0aW9uID0gKHNkcCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNkcC50eXBlID09PSAnb2ZmZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25XZWJSdGNTZHBPZmZlcihzZHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2RwLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25XZWJSdGNTZHBBbnN3ZXIoc2RwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihgUGVlckNvbm5lY3Rpb25Db250cm9sbGVyIG9uU2V0UmVtb3RlRGVzY3JpcHRpb24gd2FzIGNhbGxlZCB3aXRoIHVuZXhwZWN0ZWQgdHlwZSAke3NkcC50eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBXaGVuIHRoZSBQZWVyIENvbm5lY3Rpb24gaWNlIGNhbmRpZGF0ZSBpcyBhZGRlZCBoYXZlIGl0IGhhbmRsZWQgKi9cbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIub25QZWVySWNlQ2FuZGlkYXRlID0gKHBlZXJDb25uZWN0aW9uSWNlRXZlbnQpID0+IHRoaXMuaGFuZGxlU2VuZEljZUNhbmRpZGF0ZShwZWVyQ29ubmVjdGlvbkljZUV2ZW50KTtcbiAgICAgICAgLyogV2hlbiB0aGUgUGVlciBDb25uZWN0aW9uIGhhcyBhIGRhdGEgY2hhbm5lbCBjcmVhdGVkIGZvciBpdCBieSB0aGUgYnJvd3NlciwgaGFuZGxlIGl0ICovXG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLm9uRGF0YUNoYW5uZWwgPSAoZGF0YWNoYW5uZWxFdmVudCkgPT4gdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbChkYXRhY2hhbm5lbEV2ZW50KTtcbiAgICAgICAgLy8gc2V0IHVwIHdlYlJ0YyB0ZXh0IG92ZXJsYXlzXG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLnNob3dUZXh0T3ZlcmxheUNvbm5lY3RpbmcgPSAoKSA9PiB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbldlYlJ0Y0Nvbm5lY3RpbmcoKTtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIuc2hvd1RleHRPdmVybGF5U2V0dXBGYWlsdXJlID0gKCkgPT4gdGhpcy5waXhlbFN0cmVhbWluZy5fb25XZWJSdGNGYWlsZWQoKTtcbiAgICAgICAgbGV0IHdlYlJ0Y0Nvbm5lY3RlZFNlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIub25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBCcm93c2VycyBlbWl0IFwiY29ubmVjdGVkXCIgd2hlbiBnZXR0aW5nIGZpcnN0IGNvbm5lY3Rpb24gYW5kIFwiY29tcGxldGVkXCIgd2hlbiBmaW5pc2hpbmdcbiAgICAgICAgICAgIC8vIGNhbmRpZGF0ZSBjaGVja2luZy4gSG93ZXZlciwgc29tZXRpbWVzIGJyb3dzZXJzIGNhbiBza2lwIFwiY29ubmVjdGVkXCIgYW5kIG9ubHkgZW1pdCBcImNvbXBsZXRlZFwiLlxuICAgICAgICAgICAgLy8gVGhlcmVmb3JlIG5lZWQgdG8gY2hlY2sgYm90aCBjYXNlcyBhbmQgZW1pdCBvbldlYlJ0Y0Nvbm5lY3RlZCBvbmx5IG9uY2Ugb24gdGhlIGZpcnN0IGhpdC5cbiAgICAgICAgICAgIGlmICghd2ViUnRjQ29ubmVjdGVkU2VudCAmJlxuICAgICAgICAgICAgICAgIFsnY29ubmVjdGVkJywgJ2NvbXBsZXRlZCddLmluY2x1ZGVzKHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLnBlZXJDb25uZWN0aW9uLmljZUNvbm5lY3Rpb25TdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbldlYlJ0Y0Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgICAgIHdlYlJ0Y0Nvbm5lY3RlZFNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBSVEMgUGVlciBDb25uZWN0aW9uIG9uIFRyYWNrIGV2ZW50IC0+IGhhbmRsZSBvbiB0cmFjayAqL1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5vblRyYWNrID0gKHRyYWNrRXZlbnQpID0+IHRoaXMuc3RyZWFtQ29udHJvbGxlci5oYW5kbGVPblRyYWNrKHRyYWNrRXZlbnQpO1xuICAgICAgICBjb25zdCBCcm93c2VyU2VuZE9mZmVyID0gdGhpcy5jb25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5Ccm93c2VyU2VuZE9mZmVyKTtcbiAgICAgICAgaWYgKEJyb3dzZXJTZW5kT2ZmZXIpIHtcbiAgICAgICAgICAgIC8vIElmIGJyb3dzZXIgaXMgc2VuZGluZyB0aGUgb2ZmZXIsIGNyZWF0ZSBhbiBvZmZlciBhbmQgc2VuZCBpdCB0byB0aGUgc3RyZWFtZXJcbiAgICAgICAgICAgIHRoaXMuc2VuZHJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIuY3JlYXRlRGF0YUNoYW5uZWwodGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIucGVlckNvbm5lY3Rpb24sICdjaXJydXMnLCB0aGlzLmRhdGFjaGFubmVsT3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNlbmRyZWN2RGF0YUNoYW5uZWxDb250cm9sbGVyLmhhbmRsZU9uTWVzc2FnZSA9IChldikgPT4gdGhpcy5oYW5kbGVPbk1lc3NhZ2UoZXYpO1xuICAgICAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIuY3JlYXRlT2ZmZXIodGhpcy5zZHBDb25zdHJhaW50cywgdGhpcy5jb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgcGVlciBjb25uZWN0aW9uIG9wdGlvbnMgZm9yIGEgdHVybiBzZXJ2ZXIgYW5kIHJldHVybnMgdHJ1ZSBvciBmYWxzZVxuICAgICAqL1xuICAgIGNoZWNrVHVyblNlcnZlckF2YWlsYWJpbGl0eShvcHRpb25zKSB7XG4gICAgICAgIC8vIGlmIGljZVNlcnZlcnMgaXMgZW1wdHkgcmV0dXJuIGZhbHNlIHRoaXMgc2hvdWxkIG5vdCBiZSB0aGUgZ2VuZXJhbCB1c2UgY2FzZSBidXQgaXMgaGVyZSBpbmNhc2VcbiAgICAgICAgaWYgKCFvcHRpb25zLmljZVNlcnZlcnMpIHtcbiAgICAgICAgICAgIExvZ2dlci5JbmZvKCdBIHR1cm4gc2V2ZXIgd2FzIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgaWNlIHNlcnZlcnMgdG8gY2hlY2sgZm9yIGEgdHVybiB1cmxcbiAgICAgICAgZm9yIChjb25zdCBpY2VTZXJ2ZXIgb2Ygb3B0aW9ucy5pY2VTZXJ2ZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVybCBvZiBpY2VTZXJ2ZXIudXJscykge1xuICAgICAgICAgICAgICAgIGlmICh1cmwuaW5jbHVkZXMoJ3R1cm4nKSkge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuSW5mbyhgQSB0dXJuIHNldmVyIHdhcyBmb3VuZCBhdCAke3VybH1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIExvZ2dlci5JbmZvKCdBIHR1cm4gc2V2ZXIgd2FzIG5vdCBmb3VuZCcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hlbiBhIENvbmZpZyBNZXNzYWdlIGlzIHJlY2VpdmVkIGNvbnRhaW5zIHRoZSBQZWVyIENvbm5lY3Rpb24gT3B0aW9ucyByZXF1aXJlZCAoU1RVTiBhbmQgVFVSTiBTZXJ2ZXIgSW5mbylcbiAgICAgKiBAcGFyYW0gbWVzc2FnZUNvbmZpZyAtIENvbmZpZyBNZXNzYWdlIHJlY2VpdmVkIGZyb20gdGhlIHNpZ25hbGluZyBzZXJ2ZXJcbiAgICAgKi9cbiAgICBoYW5kbGVPbkNvbmZpZ01lc3NhZ2UobWVzc2FnZUNvbmZpZykge1xuICAgICAgICB0aGlzLnJlc2l6ZVBsYXllclN0eWxlKCk7XG4gICAgICAgIC8vIFRlbGwgdGhlIFdlYlJ0Y0NvbnRyb2xsZXIgdG8gc3RhcnQgYSBzZXNzaW9uIHdpdGggdGhlIHBlZXIgb3B0aW9ucyBzZW50IGZyb20gdGhlIHNpZ25hbGluZyBzZXJ2ZXJcbiAgICAgICAgdGhpcy5zdGFydFNlc3Npb24obWVzc2FnZUNvbmZpZy5wZWVyQ29ubmVjdGlvbk9wdGlvbnMpO1xuICAgIH1cbiAgICBoYW5kbGVQaW5nTWVzc2FnZShwaW5nTWVzc2FnZSkge1xuICAgICAgICB0aGlzLnByb3RvY29sLnNlbmRNZXNzYWdlKE1lc3NhZ2VIZWxwZXJzLmNyZWF0ZU1lc3NhZ2UoTWVzc2FnZXMucG9uZywgeyB0aW1lOiBwaW5nTWVzc2FnZS50aW1lIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIHRoZSBzaWduYWxsaW5nIHNlcnZlciBnaXZlcyB1cyB0aGUgbGlzdCBvZiBzdHJlYW1lciBpZHMuXG4gICAgICovXG4gICAgaGFuZGxlU3RyZWFtZXJMaXN0TWVzc2FnZShtZXNzYWdlU3RyZWFtZXJMaXN0KSB7XG4gICAgICAgIExvZ2dlci5JbmZvKGBHb3Qgc3RyZWFtZXIgbGlzdCAke21lc3NhZ2VTdHJlYW1lckxpc3QuaWRzfWApO1xuICAgICAgICBsZXQgd2FudGVkU3RyZWFtZXJJZCA9ICcnO1xuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgc3RyZWFtZXIgaWQgb3B0aW9uXG4gICAgICAgIGNvbnN0IHN0cmVhbWVySURPcHRpb24gPSB0aGlzLmNvbmZpZy5nZXRTZXR0aW5nT3B0aW9uKE9wdGlvblBhcmFtZXRlcnMuU3RyZWFtZXJJZCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nU2VsZWN0aW9uID0gc3RyZWFtZXJJRE9wdGlvbi5zZWxlY3RlZC50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0IHRvIHNlbGVjdGVkIG9wdGlvbiBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgIHdhbnRlZFN0cmVhbWVySWQgPSBzdHJlYW1lcklET3B0aW9uLnNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgc3RyZWFtZXJzIHRvIHRoZSBVSVxuICAgICAgICBjb25zdCBzZXR0aW5nT3B0aW9ucyA9IFsuLi5tZXNzYWdlU3RyZWFtZXJMaXN0Lmlkc107IC8vIGNvcHkgdGhlIG9yaWdpbmFsIG1lc3NhZ2VTdHJlYW1lckxpc3QuaWRzXG4gICAgICAgIHNldHRpbmdPcHRpb25zLnVuc2hpZnQoJycpOyAvLyBhZGQgYW4gZW1wdHkgb3B0aW9uIGF0IHRoZSB0b3BcbiAgICAgICAgdGhpcy5jb25maWcuc2V0T3B0aW9uU2V0dGluZ09wdGlvbnMoT3B0aW9uUGFyYW1ldGVycy5TdHJlYW1lcklkLCBzZXR0aW5nT3B0aW9ucyk7XG4gICAgICAgIGxldCBhdXRvU2VsZWN0ZWRTdHJlYW1lcklkID0gJyc7XG4gICAgICAgIGNvbnN0IHdhaXRGb3JTdHJlYW1lciA9IHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuV2FpdEZvclN0cmVhbWVyKTtcbiAgICAgICAgY29uc3QgcmVjb25uZWN0TGltaXQgPSB0aGlzLmNvbmZpZy5nZXROdW1lcmljU2V0dGluZ1ZhbHVlKE51bWVyaWNQYXJhbWV0ZXJzLk1heFJlY29ubmVjdEF0dGVtcHRzKTtcbiAgICAgICAgY29uc3QgcmVjb25uZWN0RGVsYXkgPSB0aGlzLmNvbmZpZy5nZXROdW1lcmljU2V0dGluZ1ZhbHVlKE51bWVyaWNQYXJhbWV0ZXJzLlN0cmVhbWVyQXV0b0pvaW5JbnRlcnZhbCk7XG4gICAgICAgIC8vIGZpcnN0IHdlIGZpZ3VyZSBvdXQgYSB3YW50ZWQgc3RyZWFtZXIgaWQgdGhyb3VnaCB2YXJpb3VzIG1lYW5zXG4gICAgICAgIGNvbnN0IHVzZVVybFBhcmFtcyA9IHRoaXMuY29uZmlnLnVzZVVybFBhcmFtcztcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IElVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgICAgIGlmICh1c2VVcmxQYXJhbXMgJiYgdXJsUGFyYW1zLmhhcyhPcHRpb25QYXJhbWV0ZXJzLlN0cmVhbWVySWQpKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSd2ZSBzZXQgdGhlIHN0cmVhbWVyIGlkIG9uIHRoZSB1cmwgd2Ugb25seSB3YW50IHRoYXQgc3RyZWFtZXIgaWRcbiAgICAgICAgICAgIHdhbnRlZFN0cmVhbWVySWQgPSB1cmxQYXJhbXMuZ2V0KE9wdGlvblBhcmFtZXRlcnMuU3RyZWFtZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdWJzY3JpYmVkU3RyZWFtKSB7XG4gICAgICAgICAgICAvLyB3ZSB3ZXJlIHByZXZpb3VzbHkgc3Vic2NyaWJlZCB0byBhIHN0cmVhbWVyLCB3ZSB3YW50IHRoYXRcbiAgICAgICAgICAgIHdhbnRlZFN0cmVhbWVySWQgPSB0aGlzLnN1YnNjcmliZWRTdHJlYW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IGxldHMgc2VlIGlmIHdlIGNhbiBwaWNrIGl0LlxuICAgICAgICBpZiAod2FudGVkU3RyZWFtZXJJZCAmJiBtZXNzYWdlU3RyZWFtZXJMaXN0Lmlkcy5pbmNsdWRlcyh3YW50ZWRTdHJlYW1lcklkKSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHdhbnRlZCBzdHJlYW0gaXMgaW4gdGhlIGxpc3QuIHdlIHBpY2sgdGhhdFxuICAgICAgICAgICAgYXV0b1NlbGVjdGVkU3RyZWFtZXJJZCA9IHdhbnRlZFN0cmVhbWVySWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKCF3YW50ZWRTdHJlYW1lcklkIHx8ICF3YWl0Rm9yU3RyZWFtZXIpICYmIG1lc3NhZ2VTdHJlYW1lckxpc3QuaWRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIGlmIHdlJ3JlIG5vdCB3YWl0aW5nIGZvciB0aGUgd2FudGVkIHN0cmVhbWVyIGFuZCB0aGVyZSdzIG9ubHkgb25lIHN0cmVhbWVyLCBjb25uZWN0IHRvIGl0XG4gICAgICAgICAgICBhdXRvU2VsZWN0ZWRTdHJlYW1lcklkID0gbWVzc2FnZVN0cmVhbWVyTGlzdC5pZHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgZm91bmQgYSBzdHJlYW1lciBpZCB0byBhdXRvIHNlbGVjdCwgc2VsZWN0IGl0XG4gICAgICAgIGlmIChhdXRvU2VsZWN0ZWRTdHJlYW1lcklkKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHQgPSAwO1xuICAgICAgICAgICAgdGhpcy5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0T3B0aW9uU2V0dGluZ1ZhbHVlKE9wdGlvblBhcmFtZXRlcnMuU3RyZWFtZXJJZCwgYXV0b1NlbGVjdGVkU3RyZWFtZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBhdXRvIHNlbGVjdGVkIHN0cmVhbWVyLlxuICAgICAgICAgICAgLy8gaWYgd2UncmUgd2FpdGluZyBmb3IgYSBzdHJlYW1lciB0aGVuIHRyeSByZWNvbm5lY3RpbmdcbiAgICAgICAgICAgIGlmICh3YWl0Rm9yU3RyZWFtZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3RBdHRlbXB0IDwgcmVjb25uZWN0TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RpbGwgcmVjb25uZWN0cyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0Kys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNSZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdG9jb2wuc2VuZE1lc3NhZ2UoTWVzc2FnZUhlbHBlcnMuY3JlYXRlTWVzc2FnZShNZXNzYWdlcy5saXN0U3RyZWFtZXJzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHJlY29ubmVjdERlbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGV4aGF1c3RlZCBvdXIgcmVjb25uZWN0IGF0dGVtcHRzLCByZXR1cm4gdG8gbWFpbiBzY3JlZW5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZUF1dG9SZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlzcGF0Y2ggdGhpcyBldmVudCBmaW5hbGx5XG4gICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuZGlzcGF0Y2hFdmVudChuZXcgU3RyZWFtZXJMaXN0TWVzc2FnZUV2ZW50KHtcbiAgICAgICAgICAgIG1lc3NhZ2VTdHJlYW1lckxpc3QsXG4gICAgICAgICAgICBhdXRvU2VsZWN0ZWRTdHJlYW1lcklkLFxuICAgICAgICAgICAgd2FudGVkU3RyZWFtZXJJZFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGhhbmRsZVN1YnNjcmliZUZhaWxlZE1lc3NhZ2Uoc3Vic2NyaWJlRmFpbGVkTWVzc2FnZSkge1xuICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHQgPSAwO1xuICAgICAgICB0aGlzLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5hYmxlQXV0b1JlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vblN1YnNjcmliZUZhaWxlZChzdWJzY3JpYmVGYWlsZWRNZXNzYWdlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBoYW5kbGVTdHJlYW1lcklEQ2hhbmdlZE1lc3NhZ2Uoc3RyZWFtZXJJRENoYW5nZWRNZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG5ld0lEID0gc3RyZWFtZXJJRENoYW5nZWRNZXNzYWdlLm5ld0lEO1xuICAgICAgICAvLyBuZWVkIHRvIGVkaXQgdGhlIHNlbGVjdGVkIHN0cmVhbWVyIGluIHRoZSBzZXR0aW5ncyBsaXN0XG4gICAgICAgIGNvbnN0IHN0cmVhbWVyTGlzdE9wdGlvbnMgPSB0aGlzLmNvbmZpZy5nZXRTZXR0aW5nT3B0aW9uKE9wdGlvblBhcmFtZXRlcnMuU3RyZWFtZXJJZCk7XG4gICAgICAgIC8vIHRlbXBvcmFyaWx5IHByZXZlbnQgb25DaGFuZ2UgZnJvbSBmaXJpbmcgKGl0IHdvdWxkIHRyeSB0byBzdWJzY3JpYmUgdG8gdGhlIHN0cmVhbWVyIGFnYWluKVxuICAgICAgICBjb25zdCBvbGRPbkNoYW5nZSA9IHN0cmVhbWVyTGlzdE9wdGlvbnMub25DaGFuZ2U7XG4gICAgICAgIHN0cmVhbWVyTGlzdE9wdGlvbnMub25DaGFuZ2UgPSAoKSA9PiB7IH07XG4gICAgICAgIC8vIGNoYW5nZSB0aGUgc2VsZWN0ZWQgZW50cnkuXG4gICAgICAgIGNvbnN0IHN0cmVhbWVyTGlzdCA9IHN0cmVhbWVyTGlzdE9wdGlvbnMub3B0aW9ucztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJlYW1lckxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChzdHJlYW1lckxpc3RbaV0gPT0gdGhpcy5zdWJzY3JpYmVkU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtZXJMaXN0W2ldID0gbmV3SUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBsaXN0XG4gICAgICAgIHN0cmVhbWVyTGlzdE9wdGlvbnMub3B0aW9ucyA9IHN0cmVhbWVyTGlzdDtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzZWxlY3RlZCBlbnRyeVxuICAgICAgICBzdHJlYW1lckxpc3RPcHRpb25zLnNlbGVjdGVkID0gbmV3SUQ7XG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIG9sZCBjaGFuZ2Ugbm90aWZpZXIuXG4gICAgICAgIHN0cmVhbWVyTGlzdE9wdGlvbnMub25DaGFuZ2UgPSBvbGRPbkNoYW5nZTtcbiAgICAgICAgLy8gcmVtZW1iZXIgd2hpY2ggc3RyZWFtIHdlJ3JlIHN1YnNjcmliZSB0b1xuICAgICAgICB0aGlzLnN1YnNjcmliZWRTdHJlYW0gPSBzdHJlYW1lcklEQ2hhbmdlZE1lc3NhZ2UubmV3SUQ7XG4gICAgICAgIC8vIG5vdGlmeSBhbnkgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuZGlzcGF0Y2hFdmVudChuZXcgU3RyZWFtZXJJRENoYW5nZWRNZXNzYWdlRXZlbnQoe1xuICAgICAgICAgICAgbmV3SURcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIFJUQyBBbnN3ZXIgZnJvbSB0aGUgc2lnbmFsaW5nIHNlcnZlclxuICAgICAqIEBwYXJhbSBBbnN3ZXIgLSBBbnN3ZXIgU0RQIGZyb20gdGhlIHBlZXIuXG4gICAgICovXG4gICAgaGFuZGxlV2ViUnRjQW5zd2VyKEFuc3dlcikge1xuICAgICAgICBMb2dnZXIuSW5mbyhgR290IGFuc3dlciBzZHAgJHtBbnN3ZXIuc2RwfWApO1xuICAgICAgICBjb25zdCBzZHBBbnN3ZXIgPSB7XG4gICAgICAgICAgICBzZHA6IEFuc3dlci5zZHAsXG4gICAgICAgICAgICB0eXBlOiAnYW5zd2VyJ1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5yZWNlaXZlQW5zd2VyKHNkcEFuc3dlcik7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9zdFdlYnJ0Y05lZ290aWF0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgUlRDIG9mZmVyIGZyb20gYSBXZWJSVEMgcGVlciAocmVjZWl2ZWQgdGhyb3VnaCB0aGUgc2lnbmFsbGluZyBzZXJ2ZXIpLlxuICAgICAqIEBwYXJhbSBPZmZlciAtIE9mZmVyIFNEUCBmcm9tIHRoZSBwZWVyLlxuICAgICAqL1xuICAgIGhhbmRsZVdlYlJ0Y09mZmVyKE9mZmVyKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKGBHb3Qgb2ZmZXIgc2RwICR7T2ZmZXIuc2RwfWApO1xuICAgICAgICB0aGlzLmlzVXNpbmdTRlUgPSBPZmZlci5zZnUgPyBPZmZlci5zZnUgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1VzaW5nU1ZDID0gT2ZmZXIuc2NhbGFiaWxpdHlNb2RlID8gT2ZmZXIuc2NhbGFiaWxpdHlNb2RlICE9ICdMMVQxJyA6IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pc1VzaW5nU0ZVIHx8IHRoaXMuaXNVc2luZ1NWQykge1xuICAgICAgICAgICAgLy8gRGlzYWJsZSBuZWdvdGlhdGluZyB3aXRoIHRoZSBzZnUgYXMgdGhlIHNmdSBvbmx5IHN1cHBvcnRzIG9uZSBjb2RlYyBhdCBhIHRpbWVcbiAgICAgICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyLnByZWZlcnJlZENvZGVjID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URTogVGhlc2UgdHdvIHNldHRpbmdzIGNvbmZpZ3VyYXRpb25zIGFyZSBkb25lIG91dHNpZGUgb2YgYW4gaWYodGhpcy5pc1VzaW5nU0ZVKSBzbyB0aGF0IHVzZXJzXG4gICAgICAgIC8vIGNhbiBzd2l0Y2ggYmV0d2VlbiBhIGRlZmF1bHQgYW5kIFNGVSBzdHJlYW0gYW5kIGhhdmUgdGhlIHNldHRpbmdzIHJlY29uZmlndXJlIGFwcHJvcHJpYXRlbHlcbiAgICAgICAgY29uc3Qgc2NhbGFiaWxpdHlNb2RlID0gT2ZmZXIuc2NhbGFiaWxpdHlNb2RlID8gT2ZmZXIuc2NhbGFiaWxpdHlNb2RlIDogJ0wxVDEnO1xuICAgICAgICBsZXQgYXZhaWxhYmxlUXVhbGl0aWVzID0gWydEZWZhdWx0J107XG4gICAgICAgIGlmICh0aGlzLmlzVXNpbmdTRlUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1VzaW5nU1ZDKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlciBpcyB1c2luZyBhbiBTRlUgd2l0aG91dCBhbnkgdGVtcG9yYWwgc2NhbGFiaWxpdHkuIEp1c3Qgb2ZmZXIgZWFzaWx5IHJlYWRhYmxlIG5hbWVzXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlUXVhbGl0aWVzID0gWydMb3cnLCAnTWVkaXVtJywgJ0hpZ2gnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFVzZXIgaXMgdXNpbmcgU1ZDLiBHZW5lcmF0ZSBhbGwgYXZhaWxhYmxlIG9wdGlvbnMuXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlUXVhbGl0aWVzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4U3BhdGlhbExheWVycyA9ICtzY2FsYWJpbGl0eU1vZGVbMV07XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4VGVtcG9yYWxMYXllcnMgPSArc2NhbGFiaWxpdHlNb2RlWzNdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHMgPSAxOyBzIDw9IG1heFNwYXRpYWxMYXllcnM7IHMrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0ID0gMTsgdCA8PSBtYXhUZW1wb3JhbExheWVyczsgdCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVRdWFsaXRpZXMucHVzaChgUyR7c31UJHt0fWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcG9zc2libGUgdmlkZW8gcXVhbGl0eSBvcHRpb25zXG4gICAgICAgIHRoaXMuY29uZmlnLnNldE9wdGlvblNldHRpbmdPcHRpb25zKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkUXVhbGl0eSwgYXZhaWxhYmxlUXVhbGl0aWVzKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3RlZCB2aWRlbyBxdWFsaXR5IHdpdGggdGhlIGhpZ2hlc3QgcG9zc2libGUgcmVzb2x1dGlvblxuICAgICAgICB0aGlzLmNvbmZpZy5zZXRPcHRpb25TZXR0aW5nVmFsdWUoT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRRdWFsaXR5LCBhdmFpbGFibGVRdWFsaXRpZXMuc2xpY2UoLTEpWzBdKTtcbiAgICAgICAgY29uc3Qgc2RwT2ZmZXIgPSB7XG4gICAgICAgICAgICBzZHA6IE9mZmVyLnNkcCxcbiAgICAgICAgICAgIHR5cGU6ICdvZmZlcidcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIucmVjZWl2ZU9mZmVyKHNkcE9mZmVyLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9zdFdlYnJ0Y05lZ290aWF0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB3aGVuIHRoZSBTRlUgcHJvdmlkZXMgdGhlIHBlZXIgd2l0aCBpdHMgZGF0YSBjaGFubmVsc1xuICAgICAqIEBwYXJhbSBEYXRhQ2hhbm5lbHMgLSBUaGUgbWVzc2FnZSBmcm9tIHRoZSBTRlUgY29udGFpbmluZyB0aGUgZGF0YSBjaGFubmVscyBpZHNcbiAgICAgKi9cbiAgICBoYW5kbGVXZWJSdGNTRlVQZWVyRGF0YWNoYW5uZWxzKERhdGFDaGFubmVscykge1xuICAgICAgICBjb25zdCBTZW5kT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG9yZGVyZWQ6IHRydWUsXG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IERhdGFDaGFubmVscy5zZW5kU3RyZWFtSWRcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdW5pZGlyZWN0aW9uYWwgPSBEYXRhQ2hhbm5lbHMuc2VuZFN0cmVhbUlkICE9IERhdGFDaGFubmVscy5yZWN2U3RyZWFtSWQ7XG4gICAgICAgIHRoaXMuc2VuZHJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIuY3JlYXRlRGF0YUNoYW5uZWwodGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIucGVlckNvbm5lY3Rpb24sIHVuaWRpcmVjdGlvbmFsID8gJ3NlbmQtZGF0YWNoYW5uZWwnIDogJ2RhdGFjaGFubmVsJywgU2VuZE9wdGlvbnMpO1xuICAgICAgICBpZiAodW5pZGlyZWN0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IFJlY3ZPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG9yZGVyZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpZDogRGF0YUNoYW5uZWxzLnJlY3ZTdHJlYW1JZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucmVjdkRhdGFDaGFubmVsQ29udHJvbGxlci5jcmVhdGVEYXRhQ2hhbm5lbCh0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5wZWVyQ29ubmVjdGlvbiwgJ3JlY3YtZGF0YWNoYW5uZWwnLCBSZWN2T3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIuaGFuZGxlT25PcGVuID0gKCkgPT4gdGhpcy5wcm90b2NvbC5zZW5kTWVzc2FnZShNZXNzYWdlSGVscGVycy5jcmVhdGVNZXNzYWdlKE1lc3NhZ2VzLnBlZXJEYXRhQ2hhbm5lbHNSZWFkeSkpO1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgdW5pLWRpcmVjdGlvbmFsLCBvbmx5IHRoZSByZWN2IGRhdGEgY2hhbm5lbCBzaG91bGQgaGFuZGxlIGluY29taW5nIG1lc3NhZ2VzXG4gICAgICAgICAgICB0aGlzLnJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIuaGFuZGxlT25NZXNzYWdlID0gKGV2KSA9PiB0aGlzLmhhbmRsZU9uTWVzc2FnZShldik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlbHNlIG91ciBwcmltYXJ5IGRhdGFjaGFubmVsIGlzIHNlbmQvcmVjdiBzbyBpdCBjYW4gaGFuZGxlIGluY29taW5nIG1lc3NhZ2VzXG4gICAgICAgICAgICB0aGlzLnNlbmRyZWN2RGF0YUNoYW5uZWxDb250cm9sbGVyLmhhbmRsZU9uTWVzc2FnZSA9IChldikgPT4gdGhpcy5oYW5kbGVPbk1lc3NhZ2UoZXYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVBvc3RXZWJydGNOZWdvdGlhdGlvbigpIHtcbiAgICAgICAgLy8gc3RhcnQgdGhlIGFmayB3YXJuaW5nIHRpbWVyIGFzIFBTIGlzIG5vdyBydW5uaW5nXG4gICAgICAgIHRoaXMuYWZrQ29udHJvbGxlci5zdGFydEFma1dhcm5pbmdUaW1lcigpO1xuICAgICAgICAvLyBzaG93IHRoZSBvdmVybGF5IHRoYXQgd2UgaGF2ZSBuZWdvdGlhdGVkIGEgY29ubmVjdGlvblxuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbldlYlJ0Y1NkcCgpO1xuICAgICAgICBpZiAodGhpcy5zdGF0c1RpbWVySGFuZGxlICYmIHRoaXMuc3RhdHNUaW1lckhhbmRsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLnN0YXRzVGltZXJIYW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdHNUaW1lckhhbmRsZSA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB0aGlzLmdldFN0YXRzKCksIDEwMDApO1xuICAgICAgICAvKiAgKi9cbiAgICAgICAgdGhpcy5zZXRNb3VzZUlucHV0RW5hYmxlZCh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLk1vdXNlSW5wdXQpKTtcbiAgICAgICAgdGhpcy5zZXRLZXlib2FyZElucHV0RW5hYmxlZCh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLktleWJvYXJkSW5wdXQpKTtcbiAgICAgICAgdGhpcy5zZXRHYW1lUGFkSW5wdXRFbmFibGVkKHRoaXMuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuR2FtZXBhZElucHV0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIHdoZW4gYSByZW1vdGUgSUNFIGNhbmRpZGF0ZSBpcyByZWNlaXZlZC5cbiAgICAgKiBAcGFyYW0gaWNlQ2FuZGlkYXRlSW5pdCAtIEluaXRpYWxpemF0aW9uIGRhdGEgdXNlZCB0byBtYWtlIHRoZSBhY3R1YWwgSUNFIENhbmRpZGF0ZS5cbiAgICAgKi9cbiAgICBoYW5kbGVJY2VDYW5kaWRhdGUoaWNlQ2FuZGlkYXRlSW5pdCkge1xuICAgICAgICBMb2dnZXIuSW5mbyhgUmVtb3RlIElDRSBjYW5kaWRhdGUgaW5mb3JtYXRpb24gcmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoaWNlQ2FuZGlkYXRlSW5pdCl9YCk7XG4gICAgICAgIC8vIFdlIGFyZSB1c2luZyBcImJ1bmRsZVwiIHBvbGljeSBmb3IgbWVkaWEgbGluZXMgc28gd2UgcmVtb3ZlIHRoZSBzZHBNaWQgYW5kIHNkcE1MaW5lSW5kZXggYXR0cmlidXRlc1xuICAgICAgICAvLyBmcm9tIElDRSBjYW5kaWRhdGVzIGFzIHRoZXNlIGFyZSBsZWdhY3kgYXR0cmlidXRlcyBmb3Igd2hlbiBidW5kbGUgaXMgbm90IHVzZWQuXG4gICAgICAgIC8vIElmIHdlIGRvbid0IGRvIHRoaXMgdGhlIGJyb3dzZXIgbWF5IGJlIHVuYWJsZSB0byBmb3JtIGEgbWVkaWEgY29ubmVjdGlvblxuICAgICAgICAvLyBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgYXJlIGJyaXR0bGUgaWYgdGhlIGJ1bmRsZSBtYXN0ZXIgKGUuZy4gY29tbW9ubHkgbWlkPTApIGRvZXNuJ3QgZ2V0IGEgY2FuZGlkYXRlIGZpcnN0LlxuICAgICAgICBjb25zdCByZW1vdGVJY2VDYW5kaWRhdGUgPSBuZXcgUlRDSWNlQ2FuZGlkYXRlKHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZTogaWNlQ2FuZGlkYXRlSW5pdC5jYW5kaWRhdGUsXG4gICAgICAgICAgICBzZHBNaWQ6ICcnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5oYW5kbGVPbkljZShyZW1vdGVJY2VDYW5kaWRhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSBpY2UgQ2FuZGlkYXRlIHRvIHRoZSBzaWduYWxpbmcgc2VydmVyIHZpYSB3ZWJzb2NrZXRcbiAgICAgKiBAcGFyYW0gaWNlRXZlbnQgLSBSVEMgUGVlciBDb25uZWN0aW9uSWNlRXZlbnQpIHtcbiAgICAgKi9cbiAgICBoYW5kbGVTZW5kSWNlQ2FuZGlkYXRlKGljZUV2ZW50KSB7XG4gICAgICAgIGlmIChpY2VFdmVudC5jYW5kaWRhdGUgJiYgaWNlRXZlbnQuY2FuZGlkYXRlLmNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oYExvY2FsIElDRSBjYW5kaWRhdGUgZ2VuZXJhdGVkOiBgICsgSlNPTi5zdHJpbmdpZnkoaWNlRXZlbnQuY2FuZGlkYXRlKSk7XG4gICAgICAgICAgICB0aGlzLnByb3RvY29sLnNlbmRNZXNzYWdlKE1lc3NhZ2VIZWxwZXJzLmNyZWF0ZU1lc3NhZ2UoTWVzc2FnZXMuaWNlQ2FuZGlkYXRlLCB7IGNhbmRpZGF0ZTogaWNlRXZlbnQuY2FuZGlkYXRlIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSBpY2UgQ2FuZGlkYXRlIHRvIHRoZSBzaWduYWxpbmcgc2VydmVyIHZpYSB3ZWJzb2NrZXRcbiAgICAgKiBAcGFyYW0gaWNlRXZlbnQgLSBSVEMgUGVlciBDb25uZWN0aW9uSWNlRXZlbnQpIHtcbiAgICAgKi9cbiAgICBoYW5kbGVEYXRhQ2hhbm5lbChkYXRhY2hhbm5lbEV2ZW50KSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCdEYXRhIGNoYW5uZWwgY3JlYXRlZCBmb3IgdXMgYnkgYnJvd3NlciBhcyB3ZSBhcmUgYSByZWNlaXZpbmcgcGVlci4nKTtcbiAgICAgICAgdGhpcy5zZW5kcmVjdkRhdGFDaGFubmVsQ29udHJvbGxlci5kYXRhQ2hhbm5lbCA9IGRhdGFjaGFubmVsRXZlbnQuY2hhbm5lbDtcbiAgICAgICAgLy8gRGF0YSBjaGFubmVsIHdhcyBjcmVhdGVkIGZvciB1cywgc28gd2UganVzdCBuZWVkIHRvIHNldHVwIGl0cyBjYWxsYmFja3MgYW5kIGFycmF5IHR5cGVcbiAgICAgICAgdGhpcy5zZW5kcmVjdkRhdGFDaGFubmVsQ29udHJvbGxlci5zZXR1cERhdGFDaGFubmVsKCk7XG4gICAgICAgIHRoaXMuc2VuZHJlY3ZEYXRhQ2hhbm5lbENvbnRyb2xsZXIuaGFuZGxlT25NZXNzYWdlID0gKGV2KSA9PiB0aGlzLmhhbmRsZU9uTWVzc2FnZShldik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIFJUQyBPZmZlciBTZXNzaW9uIHRvIHRoZSBTaWduYWxpbmcgc2VydmVyIHZpYSB3ZWJzb2NrZXRcbiAgICAgKiBAcGFyYW0gb2ZmZXIgLSBSVEMgU2Vzc2lvbiBEZXNjcmlwdGlvblxuICAgICAqL1xuICAgIGhhbmRsZVNlbmRXZWJSVENPZmZlcihvZmZlcikge1xuICAgICAgICBpZiAob2ZmZXIudHlwZSAhPT0gJ29mZmVyJykge1xuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBoYW5kbGVTZW5kV2ViUlRDT2ZmZXIgd2FzIGNhbGxlZCB3aXRoIHR5cGUgJHtvZmZlci50eXBlfSAtIGl0IG9ubHkgZXhwZWN0cyBcIm9mZmVyXCJgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBMb2dnZXIuSW5mbygnU2VuZGluZyB0aGUgb2ZmZXIgdG8gdGhlIFNlcnZlcicpO1xuICAgICAgICBjb25zdCBleHRyYVBhcmFtcyA9IHtcbiAgICAgICAgICAgIHNkcDogb2ZmZXIuc2RwLFxuICAgICAgICAgICAgbWluQml0cmF0ZUJwczogMTAwMCAqIHRoaXMuY29uZmlnLmdldE51bWVyaWNTZXR0aW5nVmFsdWUoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWluQml0cmF0ZSksXG4gICAgICAgICAgICBtYXhCaXRyYXRlQnBzOiAxMDAwICogdGhpcy5jb25maWcuZ2V0TnVtZXJpY1NldHRpbmdWYWx1ZShOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNYXhCaXRyYXRlKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb3RvY29sLnNlbmRNZXNzYWdlKE1lc3NhZ2VIZWxwZXJzLmNyZWF0ZU1lc3NhZ2UoTWVzc2FnZXMub2ZmZXIsIGV4dHJhUGFyYW1zKSk7XG4gICAgICAgIC8vIFNlbmQgb2ZmZXIgYmFjayB0byBQaXhlbCBTdHJlYW1pbmcgbWFpbiBjbGFzcyBmb3IgZXZlbnQgZGlzcGF0Y2hcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25XZWJSdGNTZHBPZmZlcihvZmZlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIFJUQyBPZmZlciBTZXNzaW9uIHRvIHRoZSBTaWduYWxpbmcgc2VydmVyIHZpYSB3ZWJzb2NrZXRcbiAgICAgKiBAcGFyYW0gYW5zd2VyIC0gUlRDIFNlc3Npb24gRGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBoYW5kbGVTZW5kV2ViUlRDQW5zd2VyKGFuc3dlcikge1xuICAgICAgICBpZiAoYW5zd2VyLnR5cGUgIT09ICdhbnN3ZXInKSB7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoYGhhbmRsZVNlbmRXZWJSVENBbnN3ZXIgd2FzIGNhbGxlZCB3aXRoIHR5cGUgJHthbnN3ZXIudHlwZX0gLSBpdCBvbmx5IGV4cGVjdHMgXCJhbnN3ZXJcImApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIExvZ2dlci5JbmZvKCdTZW5kaW5nIHRoZSBhbnN3ZXIgdG8gdGhlIFNlcnZlcicpO1xuICAgICAgICBjb25zdCBleHRyYVBhcmFtcyA9IHtcbiAgICAgICAgICAgIHNkcDogYW5zd2VyLnNkcCxcbiAgICAgICAgICAgIG1pbkJpdHJhdGVCcHM6IDEwMDAgKiB0aGlzLmNvbmZpZy5nZXROdW1lcmljU2V0dGluZ1ZhbHVlKE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01pbkJpdHJhdGUpLFxuICAgICAgICAgICAgbWF4Qml0cmF0ZUJwczogMTAwMCAqIHRoaXMuY29uZmlnLmdldE51bWVyaWNTZXR0aW5nVmFsdWUoTnVtZXJpY1BhcmFtZXRlcnMuV2ViUlRDTWF4Qml0cmF0ZSlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm90b2NvbC5zZW5kTWVzc2FnZShNZXNzYWdlSGVscGVycy5jcmVhdGVNZXNzYWdlKE1lc3NhZ2VzLmFuc3dlciwgZXh0cmFQYXJhbXMpKTtcbiAgICAgICAgaWYgKHRoaXMuaXNVc2luZ1NGVSkge1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbC5zZW5kTWVzc2FnZShNZXNzYWdlSGVscGVycy5jcmVhdGVNZXNzYWdlKE1lc3NhZ2VzLmRhdGFDaGFubmVsUmVxdWVzdCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlbmQgYW5zd2VyIGJhY2sgdG8gUGl4ZWwgU3RyZWFtaW5nIG1haW4gY2xhc3MgZm9yIGV2ZW50IGRpc3BhdGNoXG4gICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuX29uV2ViUnRjU2RwQW5zd2VyKGFuc3dlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZnJlZXplIGZyYW1lIG92ZXJsYXkgdG8gdGhlIHBsYXllciBkaXZcbiAgICAgKi9cbiAgICBzZXRVcE1vdXNlQW5kRnJlZXplRnJhbWUoKSB7XG4gICAgICAgIC8vIENhbGN1bGF0aW5nIGFuZCBub3JtYWxpemluZyBwb3NpdGlvbnMgZGVwZW5kcyBvbiB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgcGxheWVyLlxuICAgICAgICBjb25zdCBwbGF5ZXJFbGVtZW50ID0gdGhpcy52aWRlb1BsYXllci5nZXRWaWRlb1BhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50ID0gdGhpcy52aWRlb1BsYXllci5nZXRWaWRlb0VsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5jb29yZGluYXRlQ29udmVydGVyLnJlY29uZmlndXJlKHsgd2lkdGg6IHBsYXllckVsZW1lbnQuY2xpZW50V2lkdGgsIGhlaWdodDogcGxheWVyRWxlbWVudC5jbGllbnRIZWlnaHQgfSwgeyB3aWR0aDogdmlkZW9FbGVtZW50LnZpZGVvV2lkdGgsIGhlaWdodDogdmlkZW9FbGVtZW50LnZpZGVvSGVpZ2h0IH0pO1xuICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lQ29udHJvbGxlci5mcmVlemVGcmFtZS5yZXNpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIENvbm5lY3Rpb24gdG8gdGhlIHNpZ25hbGluZyBzZXJ2ZXJcbiAgICAgKi9cbiAgICBjbG9zZVNpZ25hbGluZ1NlcnZlcihtZXNzYWdlLCBhbGxvd1JlY29ubmVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMubG9jYWxseUNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW5hYmxlQXV0b1JlY29ubmVjdCA9IGFsbG93UmVjb25uZWN0O1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgKF9hID0gdGhpcy5wcm90b2NvbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoMTAwMCwgbWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBwZWVyIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBjbG9zZVBlZXJDb25uZWN0aW9uKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgYWxsIGNvbm5lY3Rpb25zXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VTaWduYWxpbmdTZXJ2ZXIoJycsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jbG9zZVBlZXJDb25uZWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpcmVzIGEgVmlkZW8gU3RhdHMgRXZlbnQgaW4gdGhlIFJUQyBQZWVyIENvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBnZXRTdGF0cygpIHtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIuZ2VuZXJhdGVTdGF0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgTGF0ZW5jeSBUZXN0IFJlcXVlc3QgdG8gdGhlIFVFIEluc3RhbmNlXG4gICAgICovXG4gICAgc2VuZExhdGVuY3lUZXN0KCkge1xuICAgICAgICB0aGlzLmxhdGVuY3lTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0xhdGVuY3lUZXN0JykoW1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIFN0YXJ0VGltZTogdGhpcy5sYXRlbmN5U3RhcnRUaW1lXG4gICAgICAgICAgICB9KVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIERhdGEgQ2hhbm5lbCBMYXRlbmN5IFRlc3QgUmVxdWVzdCB0byB0aGUgVUUgSW5zdGFuY2VcbiAgICAgKi9cbiAgICBzZW5kRGF0YUNoYW5uZWxMYXRlbmN5VGVzdChkZXNjcmlwdG9yKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnRGF0YUNoYW5uZWxMYXRlbmN5VGVzdCcpKFtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGRlc2NyaXB0b3IpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSBNaW5RUCBlbmNvZGVyIHNldHRpbmcgdG8gdGhlIFVFIEluc3RhbmNlLlxuICAgICAqIEBwYXJhbSBtaW5RUCAtIFRoZSBsb3dlciBib3VuZCBmb3IgUVAgd2hlbiBlbmNvZGluZ1xuICAgICAqIHZhbGlkIHZhbHVlcyBhcmUgKDEtNTEpIHdoZXJlOlxuICAgICAqIDEgPSBCZXN0IHF1YWxpdHkgYnV0IGhpZ2hlc3QgYml0cmF0ZS5cbiAgICAgKiA1MSA9IFdvcnN0IHF1YWxpdHkgYnV0IGxvd2VzdCBiaXRyYXRlLlxuICAgICAqIEJ5IGRlZmF1bHQgdGhlIG1pblFQIGlzIDEgbWVhbmluZyB0aGUgZW5jb2RlciBpcyBmcmVlXG4gICAgICogdG8gYWltIGZvciB0aGUgYmVzdCBxdWFsaXR5IGl0IGNhbiBvbiB0aGUgZ2l2ZW4gbmV0d29yayBsaW5rLlxuICAgICAqL1xuICAgIHNlbmRFbmNvZGVyTWluUVAobWluUVApIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oYE1pblFQPSR7bWluUVB9XFxuYCk7XG4gICAgICAgIGlmIChtaW5RUCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0NvbW1hbmQnKShbXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAnRW5jb2Rlci5NaW5RUCc6IG1pblFQXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIE1heFFQIGVuY29kZXIgc2V0dGluZyB0byB0aGUgVUUgSW5zdGFuY2UuXG4gICAgICogQHBhcmFtIG1heFFQIC0gVGhlIHVwcGVyIGJvdW5kIGZvciBRUCB3aGVuIGVuY29kaW5nXG4gICAgICogdmFsaWQgdmFsdWVzIGFyZSAoMS01MSkgd2hlcmU6XG4gICAgICogMSA9IEJlc3QgcXVhbGl0eSBidXQgaGlnaGVzdCBiaXRyYXRlLlxuICAgICAqIDUxID0gV29yc3QgcXVhbGl0eSBidXQgbG93ZXN0IGJpdHJhdGUuXG4gICAgICogQnkgZGVmYXVsdCB0aGUgbWF4UVAgaXMgNTEgbWVhbmluZyB0aGUgZW5jb2RlciBpcyBmcmVlXG4gICAgICogdG8gZHJvcCBxdWFsaXR5IGFzIGxvdyBhcyBuZWVkZWQgb24gdGhlIGdpdmVuIG5ldHdvcmsgbGluay5cbiAgICAgKi9cbiAgICBzZW5kRW5jb2Rlck1heFFQKG1heFFQKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKGBNYXhRUD0ke21heFFQfVxcbmApO1xuICAgICAgICBpZiAobWF4UVAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdDb21tYW5kJykoW1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgJ0VuY29kZXIuTWF4UVAnOiBtYXhRUFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSBNaW5RdWFsaXR5IGVuY29kZXIgc2V0dGluZyB0byB0aGUgVUUgSW5zdGFuY2UuXG4gICAgICogQHBhcmFtIG1pblF1YWxpdHkgLSBUaGUgbG93ZXIgYm91bmQgZm9yIHF1YWxpdHkgd2hlbiBlbmNvZGluZ1xuICAgICAqIHZhbGlkIHZhbHVlcyBhcmUgKDAtMTAwKSB3aGVyZTpcbiAgICAgKiAwID0gV29yc3QgcXVhbGl0eS5cbiAgICAgKiAxMDAgPSBCZXN0IHF1YWxpdHkuXG4gICAgICovXG4gICAgc2VuZEVuY29kZXJNaW5RdWFsaXR5KG1pblF1YWxpdHkpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oYE1pblF1YWxpdHk9JHttaW5RdWFsaXR5fVxcbmApO1xuICAgICAgICBpZiAobWluUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0NvbW1hbmQnKShbXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAnRW5jb2Rlci5NaW5RdWFsaXR5JzogbWluUXVhbGl0eVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSBNYXhRdWFsaXR5IGVuY29kZXIgc2V0dGluZyB0byB0aGUgVUUgSW5zdGFuY2UuXG4gICAgICogQHBhcmFtIG1heFF1YWxpdHkgLSBUaGUgdXBwZXIgYm91bmQgZm9yIHF1YWxpdHkgd2hlbiBlbmNvZGluZ1xuICAgICAqIHZhbGlkIHZhbHVlcyBhcmUgKDAtMTAwKSB3aGVyZTpcbiAgICAgKiAwID0gV29yc3QgcXVhbGl0eS5cbiAgICAgKiAxMDAgPSBCZXN0IHF1YWxpdHkuXG4gICAgICovXG4gICAgc2VuZEVuY29kZXJNYXhRdWFsaXR5KG1heFF1YWxpdHkpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oYE1heFF1YWxpdHk9JHttYXhRdWFsaXR5fVxcbmApO1xuICAgICAgICBpZiAobWF4UXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0NvbW1hbmQnKShbXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAnRW5jb2Rlci5NYXhRdWFsaXR5JzogbWF4UXVhbGl0eVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSB7IFdlYlJUQy5NaW5CaXRyYXRlOiBTb21lTnVtYmVyIH19IGNvbW1hbmQgdG8gVUUgdG8gc2V0XG4gICAgICogdGhlIG1pbmltdW0gYml0cmF0ZSB0aGF0IHdlIGFsbG93IFdlYlJUQyB0byB1c2VcbiAgICAgKiAobm90ZSBzZXR0aW5nIHRoaXMgdG9vIGhpZ2ggaW4gcG9vciBuZXR3b3JrcyBjYW4gYmUgcHJvYmxlbWF0aWMpLlxuICAgICAqIEBwYXJhbSBtaW5CaXRyYXRlIC0gVGhlIG1pbmltdW0gYml0cmF0ZSB3ZSB3b3VsZCBsaWtlIFdlYlJUQyB0byBub3QgZmFsbCBiZWxvdy5cbiAgICAgKi9cbiAgICBzZW5kV2ViUlRDTWluQml0cmF0ZShtaW5CaXRyYXRlKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKGBXZWJSVEMgTWluIEJpdHJhdGU9JHttaW5CaXRyYXRlfWApO1xuICAgICAgICBpZiAobWluQml0cmF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0NvbW1hbmQnKShbXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAnV2ViUlRDLk1pbkJpdHJhdGUnOiBtaW5CaXRyYXRlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIHsgV2ViUlRDLk1heEJpdHJhdGU6IFNvbWVOdW1iZXIgfX0gY29tbWFuZCB0byBVRSB0byBzZXRcbiAgICAgKiB0aGUgbWluaW11bSBiaXRyYXRlIHRoYXQgd2UgYWxsb3cgV2ViUlRDIHRvIHVzZVxuICAgICAqIChub3RlIHNldHRpbmcgdGhpcyB0b28gbG93IGNvdWxkIHJlc3VsdCBpbiBibG9ja3kgdmlkZW8pLlxuICAgICAqIEBwYXJhbSBtaW5CaXRyYXRlIC0gVGhlIG1pbmltdW0gYml0cmF0ZSB3ZSB3b3VsZCBsaWtlIFdlYlJUQyB0byBub3QgZmFsbCBiZWxvdy5cbiAgICAgKi9cbiAgICBzZW5kV2ViUlRDTWF4Qml0cmF0ZShtYXhCaXRyYXRlKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKGBXZWJSVEMgTWF4IEJpdHJhdGU9JHttYXhCaXRyYXRlfWApO1xuICAgICAgICBpZiAobWF4Qml0cmF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0NvbW1hbmQnKShbXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAnV2ViUlRDLk1heEJpdHJhdGUnOiBtYXhCaXRyYXRlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIHsgV2ViUlRDLkZwczogU29tZU51bWJlciB9fSBVRSA1LjArXG4gICAgICogYW5kIHsgV2ViUlRDLk1heEZwcyB9IFVFIDQuMjcgY29tbWFuZCB0byBzZXRcbiAgICAgKiB0aGUgbWF4aW11bSBmcHMgd2Ugd291bGQgbGlrZSBXZWJSVEMgdG8gc3RyZWFtIGF0LlxuICAgICAqIEBwYXJhbSBmcHMgLSBUaGUgbWF4aW11bSBzdHJlYW0gZnBzLlxuICAgICAqL1xuICAgIHNlbmRXZWJSVENGcHMoZnBzKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKGBXZWJSVEMgRlBTPSR7ZnBzfWApO1xuICAgICAgICBpZiAoZnBzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnQ29tbWFuZCcpKFtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7ICdXZWJSVEMuRnBzJzogZnBzIH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIC8qIFRPRE86IFJlbW92ZSB3aGVuIFVFIDQuMjcgdW5zdXBwb3J0ZWQuICovXG4gICAgICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0NvbW1hbmQnKShbXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyAnV2ViUlRDLk1heEZwcyc6IGZwcyB9KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgdGhlIFVJIERlc2NyaXB0b3IgYHN0YXQgZnBzYCB0byB0aGUgVUUgSW5zdGFuY2VcbiAgICAgKi9cbiAgICBzZW5kU2hvd0ZwcygpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0gICBTZW5kaW5nIHNob3cgc3RhdCB0byBVRSAgIC0tLS0nKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdDb21tYW5kJykoW0pTT04uc3RyaW5naWZ5KHsgJ3N0YXQuZnBzJzogJycgfSldKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhbiBJZnJhbWUgcmVxdWVzdCB0byB0aGUgc3RyZWFtZXJcbiAgICAgKi9cbiAgICBzZW5kSWZyYW1lUmVxdWVzdCgpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0gICBTZW5kaW5nIFJlcXVlc3QgZm9yIGFuIElGcmFtZSAgLS0tLScpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0lGcmFtZVJlcXVlc3QnKSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgVUlJbnRlcmFjdGlvbiBtZXNzYWdlXG4gICAgICovXG4gICAgZW1pdFVJSW50ZXJhY3Rpb24oZGVzY3JpcHRvcikge1xuICAgICAgICBMb2dnZXIuSW5mbygnLS0tLSAgIFNlbmRpbmcgY3VzdG9tIFVJSW50ZXJhY3Rpb24gbWVzc2FnZSAgIC0tLS0nKTtcbiAgICAgICAgdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdVSUludGVyYWN0aW9uJykoW0pTT04uc3RyaW5naWZ5KGRlc2NyaXB0b3IpXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBDb21tYW5kIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBlbWl0Q29tbWFuZChkZXNjcmlwdG9yKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCctLS0tICAgU2VuZGluZyBjdXN0b20gQ29tbWFuZCBtZXNzYWdlICAgLS0tLScpO1xuICAgICAgICB0aGlzLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ0NvbW1hbmQnKShbSlNPTi5zdHJpbmdpZnkoZGVzY3JpcHRvcildKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIGNvbnNvbGUgY29tbWFuZCBtZXNzYWdlXG4gICAgICovXG4gICAgZW1pdENvbnNvbGVDb21tYW5kKGNvbW1hbmQpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJy0tLS0gICBTZW5kaW5nIGN1c3RvbSBDb21tYW5kOkNvbnNvbGVDb21tYW5kIG1lc3NhZ2UgICAtLS0tJyk7XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnQ29tbWFuZCcpKFtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBDb25zb2xlQ29tbWFuZDogY29tbWFuZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcmVxdWVzdCB0byB0aGUgVUUgSW5zdGFuY2UgdG8gaGF2ZSBvd25lcnNoaXAgb2YgUXVhbGl0eVxuICAgICAqL1xuICAgIHNlbmRSZXF1ZXN0UXVhbGl0eUNvbnRyb2xPd25lcnNoaXAoKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCctLS0tICAgU2VuZGluZyBSZXF1ZXN0IHRvIENvbnRyb2wgUXVhbGl0eSAgLS0tLScpO1xuICAgICAgICB0aGlzLnRvU3RyZWFtZXJNZXNzYWdlc0NvbnRyb2xsZXIuU2VuZFJlcXVlc3RRdWFsaXR5Q29udHJvbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgYFRleHRCb3hFbnRyeWAgbWVzc2FnZSBiYWNrIHRvIFVFLlxuICAgICAqIEBwYXJhbSBjb250ZW50cyBUaGUgbmV3IGNvbnRlbnRzIG9mIHRoZSBVRSBzaWRlIHRleHQgYm94LlxuICAgICAqL1xuICAgIHNlbmRUZXh0Ym94RW50cnkoY29udGVudHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBMb2dnZXIuSW5mbygnLS0tLSAgIFNlbmRpbmcgVGV4dGJveEVudHJ5IG1lc3NhZ2UgIC0tLS0nKTtcbiAgICAgICAgKF9hID0gdGhpcy5zdHJlYW1NZXNzYWdlQ29udHJvbGxlci50b1N0cmVhbWVySGFuZGxlcnMuZ2V0KCdUZXh0Ym94RW50cnknKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKFtjb250ZW50c10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gYSBMYXRlbmN5IFRlc3QgUmVzdWx0IGFyZSByZWNlaXZlZCBmcm9tIHRoZSBVRSBJbnN0YW5jZVxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gTGF0ZW5jeSBUZXN0IFRpbWluZ3NcbiAgICAgKi9cbiAgICBoYW5kbGVMYXRlbmN5VGVzdFJlc3VsdChtZXNzYWdlKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCdEYXRhQ2hhbm5lbFJlY2VpdmVNZXNzYWdlVHlwZS5sYXRlbmN5VGVzdCcpO1xuICAgICAgICBjb25zdCBsYXRlbmN5QXNTdHJpbmcgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi0xNicpLmRlY29kZShtZXNzYWdlLnNsaWNlKDEpKTtcbiAgICAgICAgY29uc3QgbGF0ZW5jeVRlc3RSZXN1bHRzID0gbmV3IExhdGVuY3lUZXN0UmVzdWx0cygpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGxhdGVuY3lUZXN0UmVzdWx0cywgSlNPTi5wYXJzZShsYXRlbmN5QXNTdHJpbmcpKTtcbiAgICAgICAgbGF0ZW5jeVRlc3RSZXN1bHRzLnByb2Nlc3NGaWVsZHMoKTtcbiAgICAgICAgbGF0ZW5jeVRlc3RSZXN1bHRzLnRlc3RTdGFydFRpbWVNcyA9IHRoaXMubGF0ZW5jeVN0YXJ0VGltZTtcbiAgICAgICAgbGF0ZW5jeVRlc3RSZXN1bHRzLmJyb3dzZXJSZWNlaXB0VGltZU1zID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGF0ZW5jeVRlc3RSZXN1bHRzLmxhdGVuY3lFeGNsdWRpbmdEZWNvZGUgPSB+fihsYXRlbmN5VGVzdFJlc3VsdHMuYnJvd3NlclJlY2VpcHRUaW1lTXMgLSBsYXRlbmN5VGVzdFJlc3VsdHMudGVzdFN0YXJ0VGltZU1zKTtcbiAgICAgICAgbGF0ZW5jeVRlc3RSZXN1bHRzLnRlc3REdXJhdGlvbiA9IH5+KGxhdGVuY3lUZXN0UmVzdWx0cy5UcmFuc21pc3Npb25UaW1lTXMgLSBsYXRlbmN5VGVzdFJlc3VsdHMuUmVjZWlwdFRpbWVNcyk7XG4gICAgICAgIGxhdGVuY3lUZXN0UmVzdWx0cy5uZXR3b3JrTGF0ZW5jeSA9IH5+KGxhdGVuY3lUZXN0UmVzdWx0cy5sYXRlbmN5RXhjbHVkaW5nRGVjb2RlIC0gbGF0ZW5jeVRlc3RSZXN1bHRzLnRlc3REdXJhdGlvbik7XG4gICAgICAgIGlmIChsYXRlbmN5VGVzdFJlc3VsdHMuZnJhbWVEaXNwbGF5RGVsdGFUaW1lTXMgJiYgbGF0ZW5jeVRlc3RSZXN1bHRzLmJyb3dzZXJSZWNlaXB0VGltZU1zKSB7XG4gICAgICAgICAgICBsYXRlbmN5VGVzdFJlc3VsdHMuZW5kVG9FbmRMYXRlbmN5ID0gfn4obGF0ZW5jeVRlc3RSZXN1bHRzLmZyYW1lRGlzcGxheURlbHRhVGltZU1zICtcbiAgICAgICAgICAgICAgICBsYXRlbmN5VGVzdFJlc3VsdHMubmV0d29ya0xhdGVuY3ksXG4gICAgICAgICAgICAgICAgK2xhdGVuY3lUZXN0UmVzdWx0cy5DYXB0dXJlVG9TZW5kTXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuX29uTGF0ZW5jeVRlc3RSZXN1bHQobGF0ZW5jeVRlc3RSZXN1bHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIGEgRGF0YSBDaGFubmVsIExhdGVuY3kgVGVzdCBSZXNwb25zZSBpcyByZWNlaXZlZCBmcm9tIHRoZSBVRSBJbnN0YW5jZVxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gRGF0YSBDaGFubmVsIExhdGVuY3kgVGVzdCBSZXNwb25zZVxuICAgICAqL1xuICAgIGhhbmRsZURhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXNwb25zZShtZXNzYWdlKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKCdEYXRhQ2hhbm5lbFJlY2VpdmVNZXNzYWdlVHlwZS5kYXRhQ2hhbm5lbExhdGVuY3lSZXNwb25zZScpO1xuICAgICAgICBjb25zdCByZXNwb25zZUFzU3RyaW5nID0gbmV3IFRleHREZWNvZGVyKCd1dGYtMTYnKS5kZWNvZGUobWVzc2FnZS5zbGljZSgxKSk7XG4gICAgICAgIGNvbnN0IGxhdGVuY3lUZXN0UmVzcG9uc2UgPSBKU09OLnBhcnNlKHJlc3BvbnNlQXNTdHJpbmcpO1xuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vbkRhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXNwb25zZShsYXRlbmN5VGVzdFJlc3BvbnNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIHRoZSBFbmNvZGVyIGFuZCBXZWIgUlRDIFNldHRpbmdzIGFyZSByZWNlaXZlZCBmcm9tIHRoZSBVRSBJbnN0YW5jZVxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gSW5pdGlhbCBFbmNvZGVyIGFuZCBXZWIgUlRDIFNldHRpbmdzXG4gICAgICovXG4gICAgaGFuZGxlSW5pdGlhbFNldHRpbmdzKG1lc3NhZ2UpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ0RhdGFDaGFubmVsUmVjZWl2ZU1lc3NhZ2VUeXBlLkluaXRpYWxTZXR0aW5ncycpO1xuICAgICAgICBjb25zdCBwYXlsb2FkQXNTdHJpbmcgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi0xNicpLmRlY29kZShtZXNzYWdlLnNsaWNlKDEpKTtcbiAgICAgICAgY29uc3QgcGFyc2VkSW5pdGlhbFNldHRpbmdzID0gSlNPTi5wYXJzZShwYXlsb2FkQXNTdHJpbmcpO1xuICAgICAgICBjb25zdCBpbml0aWFsU2V0dGluZ3MgPSBuZXcgSW5pdGlhbFNldHRpbmdzKCk7XG4gICAgICAgIGlmIChwYXJzZWRJbml0aWFsU2V0dGluZ3MuRW5jb2Rlcikge1xuICAgICAgICAgICAgaW5pdGlhbFNldHRpbmdzLkVuY29kZXJTZXR0aW5ncyA9IHBhcnNlZEluaXRpYWxTZXR0aW5ncy5FbmNvZGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWRJbml0aWFsU2V0dGluZ3MuV2ViUlRDKSB7XG4gICAgICAgICAgICBpbml0aWFsU2V0dGluZ3MuV2ViUlRDU2V0dGluZ3MgPSBwYXJzZWRJbml0aWFsU2V0dGluZ3MuV2ViUlRDO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWRJbml0aWFsU2V0dGluZ3MuUGl4ZWxTdHJlYW1pbmcpIHtcbiAgICAgICAgICAgIGluaXRpYWxTZXR0aW5ncy5QaXhlbFN0cmVhbWluZ1NldHRpbmdzID0gcGFyc2VkSW5pdGlhbFNldHRpbmdzLlBpeGVsU3RyZWFtaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWRJbml0aWFsU2V0dGluZ3MuQ29uZmlnT3B0aW9ucyAmJlxuICAgICAgICAgICAgcGFyc2VkSW5pdGlhbFNldHRpbmdzLkNvbmZpZ09wdGlvbnMuRGVmYXVsdFRvSG92ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb25maWcuc2V0RmxhZ0VuYWJsZWQoRmxhZ3MuSG92ZXJpbmdNb3VzZU1vZGUsICEhcGFyc2VkSW5pdGlhbFNldHRpbmdzLkNvbmZpZ09wdGlvbnMuRGVmYXVsdFRvSG92ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGluaXRpYWxTZXR0aW5ncy51ZUNvbXBhdGlibGUoKTtcbiAgICAgICAgTG9nZ2VyLkluZm8ocGF5bG9hZEFzU3RyaW5nKTtcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25Jbml0aWFsU2V0dGluZ3MoaW5pdGlhbFNldHRpbmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIHRoZSBRdWFudGl6YXRpb24gUGFyYW1ldGVyIGFyZSByZWNlaXZlZCBmcm9tIHRoZSBVRSBJbnN0YW5jZVxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gRW5jb2RlcnMgUXVhbnRpemF0aW9uIFBhcmFtZXRlclxuICAgICAqL1xuICAgIGhhbmRsZVZpZGVvRW5jb2RlckF2Z1FQKG1lc3NhZ2UpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ0RhdGFDaGFubmVsUmVjZWl2ZU1lc3NhZ2VUeXBlLlZpZGVvRW5jb2RlckF2Z1FQJyk7XG4gICAgICAgIGNvbnN0IEF2Z1FQID0gTnVtYmVyKG5ldyBUZXh0RGVjb2RlcigndXRmLTE2JykuZGVjb2RlKG1lc3NhZ2Uuc2xpY2UoMSkpKTtcbiAgICAgICAgdGhpcy5zZXRWaWRlb0VuY29kZXJBdmdRUChBdmdRUCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hlbiB0aGUgdmlkZW8gZWxlbWVudCBoYXMgYmVlbiBsb2FkZWQgd2l0aCBhIHNyY09iamVjdFxuICAgICAqL1xuICAgIGhhbmRsZVZpZGVvSW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmcuX29uVmlkZW9Jbml0aWFsaXplZCgpO1xuICAgICAgICAvLyBlaXRoZXIgYXV0b3BsYXkgdGhlIHZpZGVvIG9yIHNldCB1cCB0aGUgcGxheSBvdmVybGF5XG4gICAgICAgIHRoaXMuYXV0b1BsYXlWaWRlb09yU2V0VXBQbGF5T3ZlcmxheSgpO1xuICAgICAgICB0aGlzLnJlc2l6ZVBsYXllclN0eWxlKCk7XG4gICAgICAgIHRoaXMudmlkZW9QbGF5ZXIudXBkYXRlVmlkZW9TdHJlYW1TaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsYWcgc2V0IGlmIHRoZSB1c2VyIGhhcyBRdWFsaXR5IE93bmVyc2hpcFxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gRG9lcyB0aGUgY3VycmVudCBjbGllbnQgaGF2ZSBRdWFsaXR5IE93bmVyc2hpcFxuICAgICAqL1xuICAgIG9uUXVhbGl0eUNvbnRyb2xPd25lcnNoaXAobWVzc2FnZSkge1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSk7XG4gICAgICAgIExvZ2dlci5JbmZvKCdEYXRhQ2hhbm5lbFJlY2VpdmVNZXNzYWdlVHlwZS5RdWFsaXR5Q29udHJvbE93bmVyc2hpcCcpO1xuICAgICAgICB0aGlzLmlzUXVhbGl0eUNvbnRyb2xsZXIgPSBuZXcgQm9vbGVhbih2aWV3WzFdKS52YWx1ZU9mKCk7XG4gICAgICAgIExvZ2dlci5JbmZvKGBSZWNlaXZlZCBxdWFsaXR5IGNvbnRyb2xsZXIgbWVzc2FnZSwgd2lsbCBjb250cm9sIHF1YWxpdHk6ICR7dGhpcy5pc1F1YWxpdHlDb250cm9sbGVyfWApO1xuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nLl9vblF1YWxpdHlDb250cm9sT3duZXJzaGlwKHRoaXMuaXNRdWFsaXR5Q29udHJvbGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hlbiB0aGUgQWdncmVnYXRlZCBzdGF0cyBhcmUgQ29sbGVjdGVkXG4gICAgICogQHBhcmFtIHN0YXRzIC0gQWdncmVnYXRlZCBTdGF0c1xuICAgICAqL1xuICAgIGhhbmRsZVZpZGVvU3RhdHMoc3RhdHMpIHtcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25WaWRlb1N0YXRzKHN0YXRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gUmVzaXplIHRoZSBWaWRlbyBQbGF5ZXIgZWxlbWVudFxuICAgICAqL1xuICAgIHJlc2l6ZVBsYXllclN0eWxlKCkge1xuICAgICAgICB0aGlzLnZpZGVvUGxheWVyLnJlc2l6ZVBsYXllclN0eWxlKCk7XG4gICAgfVxuICAgIHNldFByZWZlcnJlZENvZGVjKGNvZGVjKSB7XG4gICAgICAgIHRoaXMucHJlZmVycmVkQ29kZWMgPSBjb2RlYztcbiAgICAgICAgaWYgKHRoaXMucGVlckNvbm5lY3Rpb25Db250cm9sbGVyKSB7XG4gICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uQ29udHJvbGxlci5wcmVmZXJyZWRDb2RlYyA9IGNvZGVjO1xuICAgICAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbkNvbnRyb2xsZXIudXBkYXRlQ29kZWNTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRWaWRlb0VuY29kZXJBdmdRUChhdmdRUCkge1xuICAgICAgICB0aGlzLnZpZGVvQXZnUXAgPSBhdmdRUDtcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZy5fb25WaWRlb0VuY29kZXJBdmdRUCh0aGlzLnZpZGVvQXZnUXApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBlbmFibGVzL2Rpc2FibGVzIGtleWJvYXJkIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIHNldEtleWJvYXJkSW5wdXRFbmFibGVkKGlzRW5hYmxlZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMua2V5Ym9hcmRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudW5yZWdpc3RlcigpO1xuICAgICAgICBpZiAoaXNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmtleWJvYXJkQ29udHJvbGxlciA9IHRoaXMuaW5wdXRDbGFzc2VzRmFjdG9yeS5yZWdpc3RlcktleUJvYXJkKHRoaXMuY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBlbmFibGVzL2Rpc2FibGVzIG1vdXNlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIHNldE1vdXNlSW5wdXRFbmFibGVkKGlzRW5hYmxlZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMubW91c2VDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudW5yZWdpc3RlcigpO1xuICAgICAgICBpZiAoaXNFbmFibGVkKSB7XG4gICAgICAgICAgICBjb25zdCBtb3VzZU1vZGUgPSB0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkhvdmVyaW5nTW91c2VNb2RlKVxuICAgICAgICAgICAgICAgID8gQ29udHJvbFNjaGVtZVR5cGUuSG92ZXJpbmdNb3VzZVxuICAgICAgICAgICAgICAgIDogQ29udHJvbFNjaGVtZVR5cGUuTG9ja2VkTW91c2U7XG4gICAgICAgICAgICB0aGlzLm1vdXNlQ29udHJvbGxlciA9IHRoaXMuaW5wdXRDbGFzc2VzRmFjdG9yeS5yZWdpc3Rlck1vdXNlKG1vdXNlTW9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogZW5hYmxlcy9kaXNhYmxlcyB0b3VjaCBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBzZXRUb3VjaElucHV0RW5hYmxlZChpc0VuYWJsZWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnRvdWNoQ29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVucmVnaXN0ZXIoKTtcbiAgICAgICAgaWYgKGlzRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50b3VjaENvbnRyb2xsZXIgPSB0aGlzLmlucHV0Q2xhc3Nlc0ZhY3RvcnkucmVnaXN0ZXJUb3VjaCh0aGlzLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkZha2VNb3VzZVdpdGhUb3VjaGVzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogZW5hYmxlcy9kaXNhYmxlcyBnYW1lIHBhZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBzZXRHYW1lUGFkSW5wdXRFbmFibGVkKGlzRW5hYmxlZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuZ2FtZVBhZENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bnJlZ2lzdGVyKCk7XG4gICAgICAgIGlmIChpc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2FtZVBhZENvbnRyb2xsZXIgPSB0aGlzLmlucHV0Q2xhc3Nlc0ZhY3RvcnkucmVnaXN0ZXJHYW1lUGFkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJEYXRhQ2hhbm5lbEV2ZW50RW1pdHRlcnMoZGF0YUNoYW5uZWwpIHtcbiAgICAgICAgZGF0YUNoYW5uZWwub25PcGVuID0gKGxhYmVsLCBldmVudCkgPT4gdGhpcy5waXhlbFN0cmVhbWluZy5kaXNwYXRjaEV2ZW50KG5ldyBEYXRhQ2hhbm5lbE9wZW5FdmVudCh7IGxhYmVsLCBldmVudCB9KSk7XG4gICAgICAgIGRhdGFDaGFubmVsLm9uQ2xvc2UgPSAobGFiZWwsIGV2ZW50KSA9PiB0aGlzLnBpeGVsU3RyZWFtaW5nLmRpc3BhdGNoRXZlbnQobmV3IERhdGFDaGFubmVsQ2xvc2VFdmVudCh7IGxhYmVsLCBldmVudCB9KSk7XG4gICAgICAgIGRhdGFDaGFubmVsLm9uRXJyb3IgPSAobGFiZWwsIGV2ZW50KSA9PiB0aGlzLnBpeGVsU3RyZWFtaW5nLmRpc3BhdGNoRXZlbnQobmV3IERhdGFDaGFubmVsRXJyb3JFdmVudCh7IGxhYmVsLCBldmVudCB9KSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIobmFtZSwgZGlyZWN0aW9uLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IE1lc3NhZ2VEaXJlY3Rpb24uRnJvbVN0cmVhbWVyICYmIHR5cGVvZiBoYW5kbGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgTG9nZ2VyLldhcm5pbmcoYFVuYWJsZSB0byByZWdpc3RlciBoYW5kbGVyIGZvciAke25hbWV9IGFzIG5vIGhhbmRsZXIgd2FzIHBhc3NlZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihkaXJlY3Rpb24sIG5hbWUsIChkYXRhKSA9PiB0eXBlb2YgaGFuZGxlciA9PT0gJ3VuZGVmaW5lZCcgJiYgZGlyZWN0aW9uID09PSBNZXNzYWdlRGlyZWN0aW9uLlRvU3RyZWFtZXJcbiAgICAgICAgICAgID8gdGhpcy5zZW5kTWVzc2FnZUNvbnRyb2xsZXIuc2VuZE1lc3NhZ2VUb1N0cmVhbWVyKG5hbWUsIGRhdGEpXG4gICAgICAgICAgICA6IGhhbmRsZXIoZGF0YSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdlYlJ0Y1BsYXllckNvbnRyb2xsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nY29tbW9uLXVlNS42JztcbmltcG9ydCB7IFhSR2FtZXBhZENvbnRyb2xsZXIgfSBmcm9tICcuLi9JbnB1dHMvWFJHYW1lcGFkQ29udHJvbGxlcic7XG5pbXBvcnQgeyBYckZyYW1lRXZlbnQgfSBmcm9tICcuLi9VdGlsL0V2ZW50RW1pdHRlcic7XG5pbXBvcnQgeyBGbGFncyB9IGZyb20gJy4uL0NvbmZpZy9Db25maWcnO1xuZXhwb3J0IGNsYXNzIFdlYlhSQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3Iod2ViUnRjUGxheWVyQ29udHJvbGxlcikge1xuICAgICAgICB0aGlzLnhyVmlld2VyUG9zZSA9IG51bGw7XG4gICAgICAgIC8vIFVzZWQgZm9yIGNvbXBhcmlzb25zIHRvIGVuc3VyZSB0d28gbnVtYmVycyBhcmUgY2xvc2UgZW5vdWdoLlxuICAgICAgICB0aGlzLkVQU0lMT04gPSAwLjAwMDAwMDE7XG4gICAgICAgIHRoaXMudmlkZW9UZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2VmlkZW9XaWR0aCA9IDA7XG4gICAgICAgIHRoaXMucHJldlZpZGVvSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5sZWZ0VmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMucmlnaHRWaWV3ID0gbnVsbDtcbiAgICAgICAgLy8gU3RvcmUgdGhlIEhNRCBkYXRhIHdlIGhhdmUgbGFzdCBzZW50IChub3QgYWxsIG9mIGl0IGlzIG5lZWRlZCBldmVyeSBmcmFtZSB1bmxlc3MgaXQgY2hhbmdlcylcbiAgICAgICAgdGhpcy5sYXN0U2VudExlZnRFeWVQcm9qID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VudFJpZ2h0RXllUHJvaiA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFNlbnRSZWxhdGl2ZUxlZnRFeWVQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RTZW50UmVsYXRpdmVSaWdodEV5ZVBvcyA9IG51bGw7XG4gICAgICAgIHRoaXMueHJTZXNzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy53ZWJSdGNDb250cm9sbGVyID0gd2ViUnRjUGxheWVyQ29udHJvbGxlcjtcbiAgICAgICAgdGhpcy54ckdhbWVwYWRDb250cm9sbGVyID0gbmV3IFhSR2FtZXBhZENvbnRyb2xsZXIodGhpcy53ZWJSdGNDb250cm9sbGVyLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyKTtcbiAgICAgICAgdGhpcy5vblNlc3Npb25FbmRlZCA9IG5ldyBFdmVudFRhcmdldCgpO1xuICAgICAgICB0aGlzLm9uU2Vzc2lvblN0YXJ0ZWQgPSBuZXcgRXZlbnRUYXJnZXQoKTtcbiAgICAgICAgdGhpcy5vbkZyYW1lID0gbmV3IEV2ZW50VGFyZ2V0KCk7XG4gICAgfVxuICAgIHhyQ2xpY2tlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnhyU2Vzc2lvbikge1xuICAgICAgICAgICAgaWYgKCFuYXZpZ2F0b3IueHIpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFhSLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hdmlnYXRvci54clxuICAgICAgICAgICAgICAgIC8qIFJlcXVlc3QgaW1tZXJzaXZlLXZyIHNlc3Npb24gd2l0aG91dCBhbnkgb3B0aW9uYWwgZmVhdHVyZXMuICovXG4gICAgICAgICAgICAgICAgLnJlcXVlc3RTZXNzaW9uKCdpbW1lcnNpdmUtdnInLCB7IG9wdGlvbmFsRmVhdHVyZXM6IFtdIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHNlc3Npb24pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uWHJTZXNzaW9uU3RhcnRlZChzZXNzaW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54clNlc3Npb24uZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25YclNlc3Npb25FbmRlZCgpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oJ1hSIFNlc3Npb24gZW5kZWQnKTtcbiAgICAgICAgdGhpcy54clNlc3Npb24gPSBudWxsO1xuICAgICAgICB0aGlzLm9uU2Vzc2lvbkVuZGVkLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCd4clNlc3Npb25FbmRlZCcpKTtcbiAgICB9XG4gICAgaW5pdEdMKCkge1xuICAgICAgICBpZiAodGhpcy5nbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLmdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIHtcbiAgICAgICAgICAgIHhyQ29tcGF0aWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IG91ciBjbGVhciBjb2xvclxuICAgICAgICB0aGlzLmdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMSk7XG4gICAgfVxuICAgIGluaXRTaGFkZXJzKCkge1xuICAgICAgICAvLyBzaGFkZXIgc291cmNlIGNvZGVcbiAgICAgICAgY29uc3QgdmVydGV4U2hhZGVyU291cmNlID0gYFxuICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xuICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkO1xuXG4gICAgICAgIC8vIHZhcnlpbmdzXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xuXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24ueCwgYV9wb3NpdGlvbi55LCAwLCAxKTtcbiAgICAgICAgICAgLy8gcGFzcyB0aGUgdGV4Q29vcmQgdG8gdGhlIGZyYWdtZW50IHNoYWRlclxuICAgICAgICAgICAvLyBUaGUgR1BVIHdpbGwgaW50ZXJwb2xhdGUgdGhpcyB2YWx1ZSBiZXR3ZWVuIHBvaW50cy5cbiAgICAgICAgICAgdl90ZXhDb29yZCA9IGFfdGV4Q29vcmQ7XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gICAgICAgIC8vIG91ciB0ZXh0dXJlXG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XG5cbiAgICAgICAgLy8gdGhlIHRleENvb3JkcyBwYXNzZWQgaW4gZnJvbSB0aGUgdmVydGV4IHNoYWRlci5cbiAgICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XG5cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgICAgLy8gc2V0dXAgdmVydGV4IHNoYWRlclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSB0aGlzLmdsLmNyZWF0ZVNoYWRlcih0aGlzLmdsLlZFUlRFWF9TSEFERVIpO1xuICAgICAgICB0aGlzLmdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNoYWRlclNvdXJjZSk7XG4gICAgICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgICAgICAvLyBzZXR1cCBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmdsLmNyZWF0ZVNoYWRlcih0aGlzLmdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgICAgIHRoaXMuZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgICAgIC8vIHNldHVwIEdMU0wgcHJvZ3JhbVxuICAgICAgICBjb25zdCBzaGFkZXJQcm9ncmFtID0gdGhpcy5nbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgICAgICAgdGhpcy5nbC5saW5rUHJvZ3JhbShzaGFkZXJQcm9ncmFtKTtcbiAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHNoYWRlclByb2dyYW0pO1xuICAgICAgICAvLyBsb29rIHVwIHdoZXJlIHZlcnRleCBkYXRhIG5lZWRzIHRvIGdvXG4gICAgICAgIHRoaXMucG9zaXRpb25Mb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgJ2FfcG9zaXRpb24nKTtcbiAgICAgICAgdGhpcy50ZXhjb29yZExvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbihzaGFkZXJQcm9ncmFtLCAnYV90ZXhDb29yZCcpO1xuICAgIH1cbiAgICB1cGRhdGVWaWRlb1RleHR1cmUoKSB7XG4gICAgICAgIGlmICghdGhpcy52aWRlb1RleHR1cmUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBvdXIgdGV4dHVyZSB0aGF0IHdlIHVzZSBpbiBvdXIgc2hhZGVyXG4gICAgICAgICAgICAvLyBhbmQgYmluZCBpdCBvbmNlIGJlY2F1c2Ugd2UgbmV2ZXIgdXNlIGFueSBvdGhlciB0ZXh0dXJlLlxuICAgICAgICAgICAgdGhpcy52aWRlb1RleHR1cmUgPSB0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLnZpZGVvVGV4dHVyZSk7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIHBhcmFtZXRlcnMgc28gd2UgY2FuIHJlbmRlciBhbnkgc2l6ZSBpbWFnZS5cbiAgICAgICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuZ2wuTElORUFSKTtcbiAgICAgICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLmdsLkxJTkVBUik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlkZW9IZWlnaHQgPSB0aGlzLndlYlJ0Y0NvbnRyb2xsZXIudmlkZW9QbGF5ZXIuZ2V0VmlkZW9FbGVtZW50KCkudmlkZW9IZWlnaHQ7XG4gICAgICAgIGNvbnN0IHZpZGVvV2lkdGggPSB0aGlzLndlYlJ0Y0NvbnRyb2xsZXIudmlkZW9QbGF5ZXIuZ2V0VmlkZW9FbGVtZW50KCkudmlkZW9XaWR0aDtcbiAgICAgICAgaWYgKHRoaXMucHJldlZpZGVvSGVpZ2h0ICE9IHZpZGVvSGVpZ2h0IHx8IHRoaXMucHJldlZpZGVvV2lkdGggIT0gdmlkZW9XaWR0aCkge1xuICAgICAgICAgICAgLy8gRG8gZnVsbCB1cGRhdGUgb2YgdGV4dHVyZSBpZiBkaW1lbnNpb25zIGRvIG5vdCBtYXRjaFxuICAgICAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB2aWRlb1dpZHRoLCB2aWRlb0hlaWdodCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsIHRoaXMud2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci5nZXRWaWRlb0VsZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBkaW1lbnNpb25zIG1hdGNoIGp1c3QgdXBkYXRlIHRoZSBzdWIgcmVnaW9uXG4gICAgICAgICAgICB0aGlzLmdsLnRleFN1YkltYWdlMkQodGhpcy5nbC5URVhUVVJFXzJELCAwLCAwLCAwLCB2aWRlb1dpZHRoLCB2aWRlb0hlaWdodCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsIHRoaXMud2ViUnRjQ29udHJvbGxlci52aWRlb1BsYXllci5nZXRWaWRlb0VsZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHByZXYgdmlkZW8gd2lkdGgvaGVpZ2h0XG4gICAgICAgIHRoaXMucHJldlZpZGVvSGVpZ2h0ID0gdmlkZW9IZWlnaHQ7XG4gICAgICAgIHRoaXMucHJldlZpZGVvV2lkdGggPSB2aWRlb1dpZHRoO1xuICAgIH1cbiAgICBpbml0QnVmZmVycygpIHtcbiAgICAgICAgLy8gQ3JlYXRlIG91dCBwb3NpdGlvbiBidWZmZXIgYW5kIGl0cyB2ZXJ0ZXggc2hhZGVyIGF0dHJpYnV0ZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBidWZmZXIgdG8gcHV0IHRoZSB0aGUgdmVydGljZXMgb2YgdGhlIHBsYW5lIHdlIHdpbGwgZHJhdyB0aGUgdmlkZW8gc3RyZWFtIG9udG9cbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25CdWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgLy8gQmluZCB0aGUgcG9zaXRpb24gYnVmZmVyXG4gICAgICAgICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMucG9zaXRpb25CdWZmZXIpO1xuICAgICAgICAgICAgLy8gRW5hYmxlIGBwb3NpdGlvbkxvY2F0aW9uYCB0byBiZSB1c2VkIGFzIHZlcnRleCBzaGFkZXIgYXR0cmlidXRlXG4gICAgICAgICAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMucG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICAgICAgICAvLyBOb3RlOiBwb3NpdGlvbnMgYXJlIHBhc3NlZCBpbiBjbGlwLXNwYWNlIGNvb3JkaW5hdGVzIFstMS4uMV0gc28gbm8gbmVlZCB0byBjb252ZXJ0IGluLXNoYWRlclxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICB0aGlzLmdsLmJ1ZmZlckRhdGEodGhpcy5nbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAgICAgICAgIC0xLjAsIDEuMCxcbiAgICAgICAgICAgICAgICAxLjAsIDEuMCxcbiAgICAgICAgICAgICAgICAtMS4wLCAtMS4wLFxuICAgICAgICAgICAgICAgIC0xLjAsIC0xLjAsXG4gICAgICAgICAgICAgICAgMS4wLCAxLjAsXG4gICAgICAgICAgICAgICAgMS4wLCAtMS4wXG4gICAgICAgICAgICBdKSwgdGhpcy5nbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgICAgICAvLyBUZWxsIHBvc2l0aW9uIGF0dHJpYnV0ZSBvZiB0aGUgdmVydGV4IHNoYWRlciBob3cgdG8gZ2V0IGRhdGEgb3V0IG9mIHRoZSBib3VuZCBidWZmZXIgKHRoZSBwb3NpdGlvbkJ1ZmZlcilcbiAgICAgICAgICAgIHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnBvc2l0aW9uTG9jYXRpb24sIDIgLypzaXplKi8sIHRoaXMuZ2wuRkxPQVQgLyp0eXBlKi8sIGZhbHNlIC8qbm9ybWFsaXplKi8sIDAgLypzdHJpZGUqLywgMCAvKm9mZnNldCovKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgb3VyIHRleHR1cmUgY29vcmRpbmF0ZSBidWZmZXJzIGZvciBhY2Nlc3Npbmcgb3VyIHRleHR1cmVcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy50ZXhjb29yZEJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICAvLyBCaW5kIHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGUgYnVmZmVyXG4gICAgICAgICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMudGV4Y29vcmRCdWZmZXIpO1xuICAgICAgICAgICAgLy8gRW5hYmxlIGB0ZXhjb29yZExvY2F0aW9uYCB0byBiZSB1c2VkIGFzIGEgdmVydGV4IHNoYWRlciBhdHRyaWJ1dGVcbiAgICAgICAgICAgIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy50ZXhjb29yZExvY2F0aW9uKTtcbiAgICAgICAgICAgIC8vIFRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIHRvIGFwcGx5IGZvciByZWN0YW5nbGUgd2UgYXJlIGRyYXdpbmdcbiAgICAgICAgICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbMC4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIDEuMCwgMC4wLCAxLjAsIDEuMCwgMC4wLCAxLjAsIDEuMF0pLCB0aGlzLmdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgICAgIC8vIFRlbGwgdGV4dHVyZSBjb29yZGluYXRlIGF0dHJpYnV0ZSBvZiB0aGUgdmVydGV4IHNoYWRlciBob3cgdG8gZ2V0IGRhdGEgb3V0IG9mIHRoZSBib3VuZCBidWZmZXIgKHRoZSB0ZXhjb29yZEJ1ZmZlcilcbiAgICAgICAgICAgIHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnRleGNvb3JkTG9jYXRpb24sIDIgLypzaXplKi8sIHRoaXMuZ2wuRkxPQVQgLyp0eXBlKi8sIGZhbHNlIC8qbm9ybWFsaXplKi8sIDAgLypzdHJpZGUqLywgMCAvKm9mZnNldCovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblhyU2Vzc2lvblN0YXJ0ZWQoc2Vzc2lvbikge1xuICAgICAgICBMb2dnZXIuSW5mbygnWFIgU2Vzc2lvbiBzdGFydGVkJyk7XG4gICAgICAgIHRoaXMueHJTZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy54clNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vblhyU2Vzc2lvbkVuZGVkKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJbml0aWFsaXphdGlvblxuICAgICAgICB0aGlzLmluaXRHTCgpO1xuICAgICAgICB0aGlzLmluaXRTaGFkZXJzKCk7XG4gICAgICAgIHRoaXMuaW5pdEJ1ZmZlcnMoKTtcbiAgICAgICAgc2Vzc2lvbi5yZXF1ZXN0UmVmZXJlbmNlU3BhY2UoJ2xvY2FsJykudGhlbigocmVmU3BhY2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMueHJSZWZTcGFjZSA9IHJlZlNwYWNlO1xuICAgICAgICAgICAgLy8gU2V0IHVwIG91ciBiYXNlIGxheWVyIChpLmUuIGEgcHJvamVjdGlvbiBsYXllciB0aGF0IGZpbGxzIHRoZSBlbnRpcmUgWFIgdmlld3BvcnQpLlxuICAgICAgICAgICAgdGhpcy54clNlc3Npb24udXBkYXRlUmVuZGVyU3RhdGUoe1xuICAgICAgICAgICAgICAgIGJhc2VMYXllcjogbmV3IFhSV2ViR0xMYXllcih0aGlzLnhyU2Vzc2lvbiwgdGhpcy5nbClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRhcmdldCBmcmFtZXJhdGUgdG8gOTAgZnBzIGlmIDkwIGZwcyBpcyBzdXBwb3J0ZWQgaW4gdGhpcyBYUiBkZXZpY2VcbiAgICAgICAgICAgIGlmICh0aGlzLnhyU2Vzc2lvbi5zdXBwb3J0ZWRGcmFtZVJhdGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmcmFtZVJhdGUgb2YgdGhpcy54clNlc3Npb24uc3VwcG9ydGVkRnJhbWVSYXRlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVSYXRlID09IDkwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnVwZGF0ZVRhcmdldEZyYW1lUmF0ZSg5MCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCaW5kaW5nIHRvIGVhY2ggbmV3IGZyYW1lIHRvIGdldCBsYXRlc3QgWFIgdXBkYXRlc1xuICAgICAgICAgICAgdGhpcy54clNlc3Npb24ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMub25YckZyYW1lLmJpbmQodGhpcykpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblNlc3Npb25TdGFydGVkLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCd4clNlc3Npb25TdGFydGVkJykpO1xuICAgIH1cbiAgICBhcmVBcnJheXNFcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGVsZW1lbnQsIGluZGV4KSA9PiBNYXRoLmFicyhlbGVtZW50IC0gYltpbmRleF0pIDw9IHRoaXMuRVBTSUxPTikpO1xuICAgIH1cbiAgICBhcmVQb2ludHNFcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5hYnMoYS54IC0gYi54KSA+PSB0aGlzLkVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEueSAtIGIueSkgPj0gdGhpcy5FUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhLnogLSBiLnopID49IHRoaXMuRVBTSUxPTik7XG4gICAgfVxuICAgIHNlbmRYUkRhdGFUb1VFKCkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0VmlldyA9PSBudWxsIHx8IHRoaXMucmlnaHRWaWV3ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBzZWxlY3RpdmVseSBzZW5kIGVpdGhlciB0aGUgYFhSRXllVmlld3NgIG9yIGBYUkhNRFRyYW5zZm9ybWBcbiAgICAgICAgLy8gbWVzc2FnZXMgb3ZlciB0aGUgZGF0YWNoYW5uZWwuIFRoZSByZWFzb24gZm9yIHRoaXMgc2VsZWN0aXZlIHNlbmRpbmcgaXMgdGhhdFxuICAgICAgICAvLyB0aGUgYFhSRXllVmlld3NgIGlzIGEgbXVjaCBsYXJnZXIgbWVzc2FnZSBhbmQgY2hhbmdlcyBpbmZyZXF1ZW50bHkgKGUuZy4gb25seSB3aGVuIHVzZXIgY2hhbmdlcyBoZWFkc2V0IElQRCkuXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgd2Ugb25seSBuZWVkIHRvIHNlbmQgaXQgb25jZSBvbiBzdGFydHVwIGFuZCB0aGVuIGFueSB0aW1lIGl0IGNoYW5nZXMuXG4gICAgICAgIC8vIFRoZSByZXN0IG9mIHRoZSB0aW1lIHdlIGNhbiBzZW5kIHRoZSBgWFJITURUcmFuc2Zvcm1gIG1lc3NhZ2UuXG4gICAgICAgIGxldCBzaG91bGRTZW5kRXllVmlld3MgPSB0aGlzLmxhc3RTZW50TGVmdEV5ZVByb2ogPT0gbnVsbCB8fFxuICAgICAgICAgICAgdGhpcy5sYXN0U2VudFJpZ2h0RXllUHJvaiA9PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLmxhc3RTZW50UmVsYXRpdmVMZWZ0RXllUG9zID09IG51bGwgfHxcbiAgICAgICAgICAgIHRoaXMubGFzdFNlbnRSZWxhdGl2ZVJpZ2h0RXllUG9zID09IG51bGw7XG4gICAgICAgIGNvbnN0IGxlZnRFeWVUcmFucyA9IHRoaXMubGVmdFZpZXcudHJhbnNmb3JtLm1hdHJpeDtcbiAgICAgICAgY29uc3QgbGVmdEV5ZVByb2ogPSB0aGlzLmxlZnRWaWV3LnByb2plY3Rpb25NYXRyaXg7XG4gICAgICAgIGNvbnN0IHJpZ2h0RXllVHJhbnMgPSB0aGlzLnJpZ2h0Vmlldy50cmFuc2Zvcm0ubWF0cml4O1xuICAgICAgICBjb25zdCByaWdodEV5ZVByb2ogPSB0aGlzLnJpZ2h0Vmlldy5wcm9qZWN0aW9uTWF0cml4O1xuICAgICAgICBjb25zdCBobWRUcmFucyA9IHRoaXMueHJWaWV3ZXJQb3NlLnRyYW5zZm9ybS5tYXRyaXg7XG4gICAgICAgIC8vIENoZWNrIGlmIHByb2plY3Rpb24gbWF0cmljZXMgaGF2ZSBjaGFuZ2VkXG4gICAgICAgIGlmICghc2hvdWxkU2VuZEV5ZVZpZXdzICYmIHRoaXMubGFzdFNlbnRMZWZ0RXllUHJvaiAhPSBudWxsICYmIHRoaXMubGFzdFNlbnRSaWdodEV5ZVByb2ogIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbGVmdEV5ZVByb2pVbmNoYW5nZWQgPSB0aGlzLmFyZUFycmF5c0VxdWFsKGxlZnRFeWVQcm9qLCB0aGlzLmxhc3RTZW50TGVmdEV5ZVByb2opO1xuICAgICAgICAgICAgY29uc3QgcmlnaHRFeWVQcm9qVW5jaGFuZ2VkID0gdGhpcy5hcmVBcnJheXNFcXVhbChyaWdodEV5ZVByb2osIHRoaXMubGFzdFNlbnRSaWdodEV5ZVByb2opO1xuICAgICAgICAgICAgc2hvdWxkU2VuZEV5ZVZpZXdzID0gbGVmdEV5ZVByb2pVbmNoYW5nZWQgPT0gZmFsc2UgfHwgcmlnaHRFeWVQcm9qVW5jaGFuZ2VkID09IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlZnRFeWVSZWxhdGl2ZVBvcyA9IG5ldyBET01Qb2ludFJlYWRPbmx5KHRoaXMubGVmdFZpZXcudHJhbnNmb3JtLnBvc2l0aW9uLnggLSB0aGlzLnhyVmlld2VyUG9zZS50cmFuc2Zvcm0ucG9zaXRpb24ueCwgdGhpcy5sZWZ0Vmlldy50cmFuc2Zvcm0ucG9zaXRpb24ueSAtIHRoaXMueHJWaWV3ZXJQb3NlLnRyYW5zZm9ybS5wb3NpdGlvbi55LCB0aGlzLmxlZnRWaWV3LnRyYW5zZm9ybS5wb3NpdGlvbi56IC0gdGhpcy54clZpZXdlclBvc2UudHJhbnNmb3JtLnBvc2l0aW9uLnosIDEuMCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0RXllUmVsYXRpdmVQb3MgPSBuZXcgRE9NUG9pbnRSZWFkT25seSh0aGlzLmxlZnRWaWV3LnRyYW5zZm9ybS5wb3NpdGlvbi54IC0gdGhpcy54clZpZXdlclBvc2UudHJhbnNmb3JtLnBvc2l0aW9uLngsIHRoaXMubGVmdFZpZXcudHJhbnNmb3JtLnBvc2l0aW9uLnkgLSB0aGlzLnhyVmlld2VyUG9zZS50cmFuc2Zvcm0ucG9zaXRpb24ueSwgdGhpcy5sZWZ0Vmlldy50cmFuc2Zvcm0ucG9zaXRpb24ueiAtIHRoaXMueHJWaWV3ZXJQb3NlLnRyYW5zZm9ybS5wb3NpdGlvbi56LCAxLjApO1xuICAgICAgICAvLyBDaGVjayBpZiByZWxhdGl2ZSBleWUgcG9zIGhhcyBjaGFuZ2VkIChlLmcgSVBEIGNoYW5nZWQpXG4gICAgICAgIGlmICghc2hvdWxkU2VuZEV5ZVZpZXdzICYmXG4gICAgICAgICAgICB0aGlzLmxhc3RTZW50UmVsYXRpdmVMZWZ0RXllUG9zICE9IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMubGFzdFNlbnRSZWxhdGl2ZVJpZ2h0RXllUG9zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRFeWVQb3NVbmNoYW5nZWQgPSB0aGlzLmFyZVBvaW50c0VxdWFsKGxlZnRFeWVSZWxhdGl2ZVBvcywgdGhpcy5sYXN0U2VudFJlbGF0aXZlTGVmdEV5ZVBvcyk7XG4gICAgICAgICAgICBjb25zdCByaWdodEV5ZVBvc1VuY2hhbmdlZCA9IHRoaXMuYXJlUG9pbnRzRXF1YWwocmlnaHRFeWVSZWxhdGl2ZVBvcywgdGhpcy5sYXN0U2VudFJlbGF0aXZlUmlnaHRFeWVQb3MpO1xuICAgICAgICAgICAgc2hvdWxkU2VuZEV5ZVZpZXdzID0gbGVmdEV5ZVBvc1VuY2hhbmdlZCA9PSBmYWxzZSB8fCByaWdodEV5ZVBvc1VuY2hhbmdlZCA9PSBmYWxzZTtcbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIGFyZSBub3QgY2hlY2tpbmcgaWYgRXllVmlldyByb3RhdGlvbiBjaGFuZ2VzIChhcyBmYXIgYXMgSSBrbm93IG5vIEhNRCBzdXBwb3J0cyBjaGFuZ2luZyB0aGlzIHZhbHVlIGF0IHJ1bnRpbWUpLlxuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRTZW5kRXllVmlld3MpIHtcbiAgICAgICAgICAgIC8vIHNlbmQgdHJhbnNmb3JtICg0eDQpIGFuZCBwcm9qZWN0aW9uIG1hdHJpeCAoNHg0KSBkYXRhIGZvciBlYWNoIGV5ZSAobGVmdCBmaXJzdCwgdGhlbiByaWdodClcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy53ZWJSdGNDb250cm9sbGVyLnN0cmVhbU1lc3NhZ2VDb250cm9sbGVyLnRvU3RyZWFtZXJIYW5kbGVycy5nZXQoJ1hSRXllVmlld3MnKShbXG4gICAgICAgICAgICAgICAgLy8gTGVmdCBleWUgNHg0IHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgICAgICAgICAgICBsZWZ0RXllVHJhbnNbMF0sIGxlZnRFeWVUcmFuc1s0XSwgbGVmdEV5ZVRyYW5zWzhdLCBsZWZ0RXllVHJhbnNbMTJdLFxuICAgICAgICAgICAgICAgIGxlZnRFeWVUcmFuc1sxXSwgbGVmdEV5ZVRyYW5zWzVdLCBsZWZ0RXllVHJhbnNbOV0sIGxlZnRFeWVUcmFuc1sxM10sXG4gICAgICAgICAgICAgICAgbGVmdEV5ZVRyYW5zWzJdLCBsZWZ0RXllVHJhbnNbNl0sIGxlZnRFeWVUcmFuc1sxMF0sIGxlZnRFeWVUcmFuc1sxNF0sXG4gICAgICAgICAgICAgICAgbGVmdEV5ZVRyYW5zWzNdLCBsZWZ0RXllVHJhbnNbN10sIGxlZnRFeWVUcmFuc1sxMV0sIGxlZnRFeWVUcmFuc1sxNV0sXG4gICAgICAgICAgICAgICAgLy8gTGVmdCBleWUgNHg0IHByb2plY3Rpb24gbWF0cml4XG4gICAgICAgICAgICAgICAgbGVmdEV5ZVByb2pbMF0sIGxlZnRFeWVQcm9qWzRdLCBsZWZ0RXllUHJvals4XSwgbGVmdEV5ZVByb2pbMTJdLFxuICAgICAgICAgICAgICAgIGxlZnRFeWVQcm9qWzFdLCBsZWZ0RXllUHJvals1XSwgbGVmdEV5ZVByb2pbOV0sIGxlZnRFeWVQcm9qWzEzXSxcbiAgICAgICAgICAgICAgICBsZWZ0RXllUHJvalsyXSwgbGVmdEV5ZVByb2pbNl0sIGxlZnRFeWVQcm9qWzEwXSwgbGVmdEV5ZVByb2pbMTRdLFxuICAgICAgICAgICAgICAgIGxlZnRFeWVQcm9qWzNdLCBsZWZ0RXllUHJvals3XSwgbGVmdEV5ZVByb2pbMTFdLCBsZWZ0RXllUHJvalsxNV0sXG4gICAgICAgICAgICAgICAgLy8gUmlnaHQgZXllIDR4NCB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICAgICAgICAgICAgcmlnaHRFeWVUcmFuc1swXSwgcmlnaHRFeWVUcmFuc1s0XSwgcmlnaHRFeWVUcmFuc1s4XSwgcmlnaHRFeWVUcmFuc1sxMl0sXG4gICAgICAgICAgICAgICAgcmlnaHRFeWVUcmFuc1sxXSwgcmlnaHRFeWVUcmFuc1s1XSwgcmlnaHRFeWVUcmFuc1s5XSwgcmlnaHRFeWVUcmFuc1sxM10sXG4gICAgICAgICAgICAgICAgcmlnaHRFeWVUcmFuc1syXSwgcmlnaHRFeWVUcmFuc1s2XSwgcmlnaHRFeWVUcmFuc1sxMF0sIHJpZ2h0RXllVHJhbnNbMTRdLFxuICAgICAgICAgICAgICAgIHJpZ2h0RXllVHJhbnNbM10sIHJpZ2h0RXllVHJhbnNbN10sIHJpZ2h0RXllVHJhbnNbMTFdLCByaWdodEV5ZVRyYW5zWzE1XSxcbiAgICAgICAgICAgICAgICAvLyByaWdodCBleWUgNHg0IHByb2plY3Rpb24gbWF0cml4XG4gICAgICAgICAgICAgICAgcmlnaHRFeWVQcm9qWzBdLCByaWdodEV5ZVByb2pbNF0sIHJpZ2h0RXllUHJvals4XSwgcmlnaHRFeWVQcm9qWzEyXSxcbiAgICAgICAgICAgICAgICByaWdodEV5ZVByb2pbMV0sIHJpZ2h0RXllUHJvals1XSwgcmlnaHRFeWVQcm9qWzldLCByaWdodEV5ZVByb2pbMTNdLFxuICAgICAgICAgICAgICAgIHJpZ2h0RXllUHJvalsyXSwgcmlnaHRFeWVQcm9qWzZdLCByaWdodEV5ZVByb2pbMTBdLCByaWdodEV5ZVByb2pbMTRdLFxuICAgICAgICAgICAgICAgIHJpZ2h0RXllUHJvalszXSwgcmlnaHRFeWVQcm9qWzddLCByaWdodEV5ZVByb2pbMTFdLCByaWdodEV5ZVByb2pbMTVdLFxuICAgICAgICAgICAgICAgIC8vIEhNRCA0eDQgdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbMF0sIGhtZFRyYW5zWzRdLCBobWRUcmFuc1s4XSwgaG1kVHJhbnNbMTJdLFxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzFdLCBobWRUcmFuc1s1XSwgaG1kVHJhbnNbOV0sIGhtZFRyYW5zWzEzXSxcbiAgICAgICAgICAgICAgICBobWRUcmFuc1syXSwgaG1kVHJhbnNbNl0sIGhtZFRyYW5zWzEwXSwgaG1kVHJhbnNbMTRdLFxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzNdLCBobWRUcmFuc1s3XSwgaG1kVHJhbnNbMTFdLCBobWRUcmFuc1sxNV0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFNlbnRMZWZ0RXllUHJvaiA9IGxlZnRFeWVQcm9qO1xuICAgICAgICAgICAgdGhpcy5sYXN0U2VudFJpZ2h0RXllUHJvaiA9IHJpZ2h0RXllUHJvajtcbiAgICAgICAgICAgIHRoaXMubGFzdFNlbnRSZWxhdGl2ZUxlZnRFeWVQb3MgPSBsZWZ0RXllUmVsYXRpdmVQb3M7XG4gICAgICAgICAgICB0aGlzLmxhc3RTZW50UmVsYXRpdmVSaWdodEV5ZVBvcyA9IHJpZ2h0RXllUmVsYXRpdmVQb3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBuZWVkIHRvIHRoZSBlbnRpcmUgZXllIHZpZXdzIGJlaW5nIHNlbnQganVzdCBzZW5kIHRoZSBITUQgdHJhbnNmb3JtXG4gICAgICAgICAgICB0aGlzLndlYlJ0Y0NvbnRyb2xsZXIuc3RyZWFtTWVzc2FnZUNvbnRyb2xsZXIudG9TdHJlYW1lckhhbmRsZXJzLmdldCgnWFJITURUcmFuc2Zvcm0nKShbXG4gICAgICAgICAgICAgICAgLy8gSE1EIDR4NCB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICBobWRUcmFuc1swXSxcbiAgICAgICAgICAgICAgICBobWRUcmFuc1s0XSxcbiAgICAgICAgICAgICAgICBobWRUcmFuc1s4XSxcbiAgICAgICAgICAgICAgICBobWRUcmFuc1sxMl0sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbMV0sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbNV0sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbOV0sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbMTNdLFxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzJdLFxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzZdLFxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzEwXSxcbiAgICAgICAgICAgICAgICBobWRUcmFuc1sxNF0sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbM10sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbN10sXG4gICAgICAgICAgICAgICAgaG1kVHJhbnNbMTFdLFxuICAgICAgICAgICAgICAgIGhtZFRyYW5zWzE1XVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25YckZyYW1lKHRpbWUsIGZyYW1lKSB7XG4gICAgICAgIHRoaXMueHJWaWV3ZXJQb3NlID0gZnJhbWUuZ2V0Vmlld2VyUG9zZSh0aGlzLnhyUmVmU3BhY2UpO1xuICAgICAgICBpZiAodGhpcy54clZpZXdlclBvc2UpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3MoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnRWaWV3ID09IG51bGwgfHwgdGhpcy5yaWdodFZpZXcgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VuZFhSRGF0YVRvVUUoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlkZW9UZXh0dXJlKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndlYlJ0Y0NvbnRyb2xsZXIuY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuWFJDb250cm9sbGVySW5wdXQpKSB7XG4gICAgICAgICAgICB0aGlzLnhyU2Vzc2lvbi5pbnB1dFNvdXJjZXMuZm9yRWFjaCgoc291cmNlLCBfaW5kZXgsIF9hcnJheSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMueHJHYW1lcGFkQ29udHJvbGxlci51cGRhdGVTdGF0dXMoc291cmNlLCBmcmFtZSwgdGhpcy54clJlZlNwYWNlKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueHJTZXNzaW9uLnJlcXVlc3RBbmltYXRpb25GcmFtZSgodGltZSwgZnJhbWUpID0+IHRoaXMub25YckZyYW1lKHRpbWUsIGZyYW1lKSk7XG4gICAgICAgIHRoaXMub25GcmFtZS5kaXNwYXRjaEV2ZW50KG5ldyBYckZyYW1lRXZlbnQoeyB0aW1lLCBmcmFtZSB9KSk7XG4gICAgfVxuICAgIHVwZGF0ZVZpZXdzKCkge1xuICAgICAgICBpZiAoIXRoaXMueHJWaWV3ZXJQb3NlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2aWV3IG9mIHRoaXMueHJWaWV3ZXJQb3NlLnZpZXdzKSB7XG4gICAgICAgICAgICBpZiAodmlldy5leWUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMubGVmdFZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmlldy5leWUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0VmlldyA9IHZpZXc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2wpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBCaW5kIHRoZSBmcmFtZWJ1ZmZlciB0byB0aGUgYmFzZSBsYXllcidzIGZyYW1lYnVmZmVyXG4gICAgICAgIGNvbnN0IGdsTGF5ZXIgPSB0aGlzLnhyU2Vzc2lvbi5yZW5kZXJTdGF0ZS5iYXNlTGF5ZXI7XG4gICAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIGdsTGF5ZXIuZnJhbWVidWZmZXIpO1xuICAgICAgICAvLyBTZXQgdGhlIHJlbGV2YW50IHBvcnRpb24gb2YgY2xpcCBzcGFjZVxuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIGdsTGF5ZXIuZnJhbWVidWZmZXJXaWR0aCwgZ2xMYXllci5mcmFtZWJ1ZmZlckhlaWdodCk7XG4gICAgICAgIC8vIERyYXcgdGhlIHJlY3RhbmdsZSB3ZSB3aWxsIHNob3cgdGhlIHZpZGVvIHN0cmVhbSB0ZXh0dXJlIG9uXG4gICAgICAgIHRoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLlRSSUFOR0xFUyAvKnByaW1pdGl2ZVR5cGUqLywgMCAvKm9mZnNldCovLCA2IC8qY291bnQqLyk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1Nlc3Npb25TdXBwb3J0ZWQobW9kZSkge1xuICAgICAgICBpZiAobG9jYXRpb24ucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgICAgICAgICBMb2dnZXIuSW5mbygnV2ViWFIgcmVxdWlyZXMgaHR0cHMsIGlmIHlvdSB3YW50IFdlYlhSIHVzZSBodHRwcy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmF2aWdhdG9yLnhyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLnhyLmlzU2Vzc2lvblN1cHBvcnRlZChtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XZWJYUkNvbnRyb2xsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IEZsYWdzLCBMb2dnZXIsIE9wdGlvblBhcmFtZXRlcnMgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2Zyb250ZW5kLXVlNS42JztcbmltcG9ydCB7IENvbm5lY3RPdmVybGF5IH0gZnJvbSAnLi4vT3ZlcmxheS9Db25uZWN0T3ZlcmxheSc7XG5pbXBvcnQgeyBEaXNjb25uZWN0T3ZlcmxheSB9IGZyb20gJy4uL092ZXJsYXkvRGlzY29ubmVjdE92ZXJsYXknO1xuaW1wb3J0IHsgUGxheU92ZXJsYXkgfSBmcm9tICcuLi9PdmVybGF5L1BsYXlPdmVybGF5JztcbmltcG9ydCB7IEluZm9PdmVybGF5IH0gZnJvbSAnLi4vT3ZlcmxheS9JbmZvT3ZlcmxheSc7XG5pbXBvcnQgeyBFcnJvck92ZXJsYXkgfSBmcm9tICcuLi9PdmVybGF5L0Vycm9yT3ZlcmxheSc7XG5pbXBvcnQgeyBBRktPdmVybGF5IH0gZnJvbSAnLi4vT3ZlcmxheS9BRktPdmVybGF5JztcbmltcG9ydCB7IENvbnRyb2xzIH0gZnJvbSAnLi4vVUkvQ29udHJvbHMnO1xuaW1wb3J0IHsgTGFiZWxsZWRCdXR0b24gfSBmcm9tICcuLi9VSS9MYWJlbGxlZEJ1dHRvbic7XG5pbXBvcnQgeyBTZXR0aW5nc1BhbmVsIH0gZnJvbSAnLi4vVUkvU2V0dGluZ3NQYW5lbCc7XG5pbXBvcnQgeyBTdGF0c1BhbmVsIH0gZnJvbSAnLi4vVUkvU3RhdHNQYW5lbCc7XG5pbXBvcnQgeyBWaWRlb1FwSW5kaWNhdG9yIH0gZnJvbSAnLi4vVUkvVmlkZW9RcEluZGljYXRvcic7XG5pbXBvcnQgeyBDb25maWdVSSB9IGZyb20gJy4uL0NvbmZpZy9Db25maWdVSSc7XG5pbXBvcnQgeyBFZGl0VGV4dE1vZGFsIH0gZnJvbSAnLi4vVUkvRWRpdFRleHRNb2RhbCc7XG5pbXBvcnQgeyBVSUVsZW1lbnRDcmVhdGlvbk1vZGUsIGlzUGFuZWxFbmFibGVkLCBFeHRyYUZsYWdzIH0gZnJvbSAnLi4vVUkvVUlDb25maWd1cmF0aW9uVHlwZXMnO1xuaW1wb3J0IHsgRnVsbFNjcmVlbkljb25FeHRlcm5hbCB9IGZyb20gJy4uL1VJL0Z1bGxzY3JlZW5JY29uJztcbi8qKlxuICogQW4gQXBwbGljYXRpb24gaXMgYSBjb21iaW5hdGlvbiBvZiBVSSBlbGVtZW50cyB0byBkaXNwbGF5IGFuZCBtYW5hZ2UgYSBXZWJSVEMgUGl4ZWwgU3RyZWFtaW5nXG4gKiBjb25uZWN0aW9uLiBJdCBpbmNsdWRlcyBmZWF0dXJlcyBmb3IgY29udHJvbGxpbmcgYSBzdHJlYW0gd2l0aCBtb3VzZSBhbmQga2V5Ym9hcmQsXG4gKiBtYW5hZ2luZyBjb25uZWN0aW9uIGVuZHBvaW50cywgYXMgd2VsbCBhcyBkaXNwbGF5aW5nIHN0YXRzIGFuZCBvdGhlciBpbmZvcm1hdGlvbiBhYm91dCBpdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEFwcGxpY2F0aW9uIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEluaXRpYWxpemF0aW9uIG9wdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZWRpdFRleHRNb2RhbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IG9wdGlvbnMuc3RyZWFtO1xuICAgICAgICAvLyBFeHBsaWNpdGx5IGNyZWF0ZSB1aSBmZWF0dXJlcyBub3cgc28gY3JlYXRpb24gdGltZSBpcyBrbm93blxuICAgICAgICB0aGlzLl91aUZlYXR1cmVFbGVtZW50ID0gdGhpcy5jcmVhdGVVSUZlYXR1cmVzRWxlbWVudCgpO1xuICAgICAgICAvLyBFeHBsaWNpdGx5IGNyZWF0ZSByb290IGVsZW1lbnQgbm93IHNvIGNyZWF0aW9uIHRpbWUgaXMga25vd25cbiAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSB0aGlzLmNyZWF0ZVJvb3RFbGVtZW50KHRoaXMuc3RyZWFtLCB0aGlzLl91aUZlYXR1cmVFbGVtZW50KTtcbiAgICAgICAgdGhpcy5vbkNvbG9yTW9kZUNoYW5nZWQgPSBvcHRpb25zLm9uQ29sb3JNb2RlQ2hhbmdlZDtcbiAgICAgICAgdGhpcy5jb25maWdVSSA9IG5ldyBDb25maWdVSSh0aGlzLnN0cmVhbS5jb25maWcpO1xuICAgICAgICB0aGlzLmNyZWF0ZU92ZXJsYXlzKCk7XG4gICAgICAgIGlmIChpc1BhbmVsRW5hYmxlZChvcHRpb25zLnN0YXRzUGFuZWxDb25maWcpKSB7XG4gICAgICAgICAgICAvLyBBZGQgc3RhdHMgcGFuZWxcbiAgICAgICAgICAgIHRoaXMuc3RhdHNQYW5lbCA9IG5ldyBTdGF0c1BhbmVsKG9wdGlvbnMuc3RhdHNQYW5lbENvbmZpZywgdGhpcy5zdHJlYW0uY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMudWlGZWF0dXJlc0VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zdGF0c1BhbmVsLnJvb3RFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQYW5lbEVuYWJsZWQob3B0aW9ucy5zZXR0aW5nc1BhbmVsQ29uZmlnKSkge1xuICAgICAgICAgICAgLy8gQWRkIHNldHRpbmdzIHBhbmVsXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzUGFuZWwgPSBuZXcgU2V0dGluZ3NQYW5lbCgpO1xuICAgICAgICAgICAgdGhpcy51aUZlYXR1cmVzRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNldHRpbmdzUGFuZWwucm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmVTZXR0aW5ncygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy52aWRlb1FwSW5kaWNhdG9yQ29uZmlnIHx8ICFvcHRpb25zLnZpZGVvUXBJbmRpY2F0b3JDb25maWcuZGlzYWJsZUluZGljYXRvcikge1xuICAgICAgICAgICAgLy8gQWRkIHRoZSB2aWRlbyBzdHJlYW0gUVAgaW5kaWNhdG9yXG4gICAgICAgICAgICB0aGlzLnZpZGVvUXBJbmRpY2F0b3IgPSBuZXcgVmlkZW9RcEluZGljYXRvcihvcHRpb25zLnZpZGVvUXBJbmRpY2F0b3JDb25maWcpO1xuICAgICAgICAgICAgdGhpcy51aUZlYXR1cmVzRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnZpZGVvUXBJbmRpY2F0b3Iucm9vdEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlQnV0dG9ucygpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyQ2FsbGJhY2tzKCk7XG4gICAgICAgIHRoaXMuc2hvd0Nvbm5lY3RPckF1dG9Db25uZWN0T3ZlcmxheXMoKTtcbiAgICAgICAgdGhpcy5zZXRDb2xvck1vZGUodGhpcy5jb25maWdVSS5pc0N1c3RvbUZsYWdFbmFibGVkKEV4dHJhRmxhZ3MuTGlnaHRNb2RlKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmNvbmZpZy5fYWRkT25TZXR0aW5nQ2hhbmdlZExpc3RlbmVyKEZsYWdzLkhpZGVVSSwgKGlzRW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdWlGZWF0dXJlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gaXNFbmFibGVkID8gJ2hpZGRlbicgOiAndmlzaWJsZSc7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5zdHJlYW0uY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuSGlkZVVJKSkge1xuICAgICAgICAgICAgdGhpcy5fdWlGZWF0dXJlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlT3ZlcmxheXMoKSB7XG4gICAgICAgIC8vIGJ1aWxkIGFsbCBvZiB0aGUgb3ZlcmxheXNcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0T3ZlcmxheSA9IG5ldyBEaXNjb25uZWN0T3ZlcmxheSh0aGlzLnN0cmVhbS52aWRlb0VsZW1lbnRQYXJlbnQpO1xuICAgICAgICB0aGlzLmNvbm5lY3RPdmVybGF5ID0gbmV3IENvbm5lY3RPdmVybGF5KHRoaXMuc3RyZWFtLnZpZGVvRWxlbWVudFBhcmVudCk7XG4gICAgICAgIHRoaXMucGxheU92ZXJsYXkgPSBuZXcgUGxheU92ZXJsYXkodGhpcy5zdHJlYW0udmlkZW9FbGVtZW50UGFyZW50KTtcbiAgICAgICAgdGhpcy5pbmZvT3ZlcmxheSA9IG5ldyBJbmZvT3ZlcmxheSh0aGlzLnN0cmVhbS52aWRlb0VsZW1lbnRQYXJlbnQpO1xuICAgICAgICB0aGlzLmVycm9yT3ZlcmxheSA9IG5ldyBFcnJvck92ZXJsYXkodGhpcy5zdHJlYW0udmlkZW9FbGVtZW50UGFyZW50KTtcbiAgICAgICAgdGhpcy5hZmtPdmVybGF5ID0gbmV3IEFGS092ZXJsYXkodGhpcy5zdHJlYW0udmlkZW9FbGVtZW50UGFyZW50KTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0T3ZlcmxheS5vbkFjdGlvbigoKSA9PiB0aGlzLnN0cmVhbS5yZWNvbm5lY3QoKSk7XG4gICAgICAgIC8vIEJ1aWxkIHRoZSB3ZWJSdGMgY29ubmVjdCBvdmVybGF5IEV2ZW50IExpc3RlbmVyIGFuZCBzaG93IHRoZSBjb25uZWN0IG92ZXJsYXlcbiAgICAgICAgdGhpcy5jb25uZWN0T3ZlcmxheS5vbkFjdGlvbigoKSA9PiB0aGlzLnN0cmVhbS5jb25uZWN0KCkpO1xuICAgICAgICAvLyBzZXQgdXAgdGhlIHBsYXkgb3ZlcmxheXMgYWN0aW9uXG4gICAgICAgIHRoaXMucGxheU92ZXJsYXkub25BY3Rpb24oKCkgPT4gdGhpcy5zdHJlYW0ucGxheSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHVwIGJ1dHRvbiBjbGljayBmdW5jdGlvbnMgYW5kIGJ1dHRvbiBmdW5jdGlvbmFsaXR5XG4gICAgICovXG4gICAgY3JlYXRlQnV0dG9ucygpIHtcbiAgICAgICAgY29uc3QgaXNJcGhvbmUgPSAvaVBob25lLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgICBjb25zdCBpc0lwYWQgPSAvaVBhZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSB8fFxuICAgICAgICAgICAgKC9NYWNpbnRvc2gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgJ29udG91Y2hlbmQnIGluIGRvY3VtZW50KTtcbiAgICAgICAgY29uc3QgaXNTYWZhcmkgPSBuYXZpZ2F0b3IudmVuZG9yICYmXG4gICAgICAgICAgICBuYXZpZ2F0b3IudmVuZG9yLmluZGV4T2YoJ0FwcGxlJykgPiAtMSAmJlxuICAgICAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJlxuICAgICAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDcmlPUycpID09IC0xICYmXG4gICAgICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Z4aU9TJykgPT0gLTE7XG4gICAgICAgIC8vIEluIHNvbWUgY2FzZXMgd2Ugd2FudCB0byBkaXNhYmxlIGZ1bGxzY3JlZW4gYnV0dG9uIGlmIGl0IGlzIG5vdCBleHBsaWNpdGx5IHJlcXVlc3RlZDpcbiAgICAgICAgLy8gSVBob25lIGRvZXMgbm90IHN1cHBvcnQgZnVsbHNjcmVlbiBBUEkgYXMgYXQgMjh0aCBKdWx5IDIwMjQgKHNlZTogaHR0cHM6Ly9jYW5pdXNlLmNvbS9mdWxsc2NyZWVuKSBzbyBpZlxuICAgICAgICAvLyB3ZSBhcmUgb24gSVBob25lIGFuZCB1c2VyIGhhcyBub3Qgc3BlY2lmaWVkIGV4cGxpY2l0bHkgY29uZmlndXJlZCBVSSBjb25maWcgZm9yXG4gICAgICAgIC8vIGZ1bGxzY3JlZW4gYnV0dG9uIHRoZW4gd2Ugc2hvdWxkIGRpc2FibGUgdGhpcyBidXR0b24gYXMgaXQgZG9lc24ndCB3b3JrLlxuICAgICAgICAvLyBBZGRpdGlvbmFsbHkgaVBhZCBvbiBub24tU2FmYXJpIGJyb3dzZXJzIGRvZXNuJ3QgcmVhbGx5IGFsbG93IHRvdWNoIGlucHV0cyBhbmQgZnVsbHNjcmVlbiB2aWRlbyBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICAvLyBJZiB5b3UgZG8gdGhpcyB0aGUgdmlkZW8gZ2V0cyBkcmFnZ2VkIG9mZiBiYWNrIHRvIG5vcm1hbCBub24tZnVsbHNjcmVlbiB2aWRlbyBhbmQgdGhlbiB0aGUgdmlkZW8gaXMgcGF1c2VkLlxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9FcGljR2FtZXNFeHQvUGl4ZWxTdHJlYW1pbmdJbmZyYXN0cnVjdHVyZS9pc3N1ZXMvMjE5XG4gICAgICAgIGNvbnN0IGRpc2FibGVGdWxsc2NyZWVuQnV0dG9uID0gaXNJcGhvbmUgfHwgKCFpc1NhZmFyaSAmJiBpc0lwYWQpO1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5mdWxsU2NyZWVuQ29udHJvbHNDb25maWcgPT09IHVuZGVmaW5lZCAmJiBkaXNhYmxlRnVsbHNjcmVlbkJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5mdWxsU2NyZWVuQ29udHJvbHNDb25maWcgPSB7IGNyZWF0aW9uTW9kZTogVUlFbGVtZW50Q3JlYXRpb25Nb2RlLkRpc2FibGUgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250cm9sc1VJQ29uZmlnID0ge1xuICAgICAgICAgICAgc3RhdHNCdXR0b25UeXBlOiB0aGlzLl9vcHRpb25zLnN0YXRzUGFuZWxDb25maWdcbiAgICAgICAgICAgICAgICA/IHRoaXMuX29wdGlvbnMuc3RhdHNQYW5lbENvbmZpZy52aXNpYmlsaXR5QnV0dG9uQ29uZmlnXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZXR0aW5nc0J1dHRvblR5cGU6IHRoaXMuX29wdGlvbnMuc2V0dGluZ3NQYW5lbENvbmZpZ1xuICAgICAgICAgICAgICAgID8gdGhpcy5fb3B0aW9ucy5zZXR0aW5nc1BhbmVsQ29uZmlnLnZpc2liaWxpdHlCdXR0b25Db25maWdcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZ1bGxzY3JlZW5CdXR0b25UeXBlOiB0aGlzLl9vcHRpb25zLmZ1bGxTY3JlZW5Db250cm9sc0NvbmZpZyxcbiAgICAgICAgICAgIHhySWNvblR5cGU6IHRoaXMuX29wdGlvbnMueHJDb250cm9sc0NvbmZpZyxcbiAgICAgICAgICAgIGhpZGVDb250cm9sc0luRnVsbHNjcmVlbjogdGhpcy5fb3B0aW9ucy5oaWRlQ29udHJvbHNJbkZ1bGxzY3JlZW5cbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2V0dXAgY29udHJvbHNcbiAgICAgICAgY29uc3QgY29udHJvbHMgPSBuZXcgQ29udHJvbHMoY29udHJvbHNVSUNvbmZpZyk7XG4gICAgICAgIHRoaXMudWlGZWF0dXJlc0VsZW1lbnQuYXBwZW5kQ2hpbGQoY29udHJvbHMucm9vdEVsZW1lbnQpO1xuICAgICAgICAvLyBXaGVuIHdlIGZ1bGxzY3JlZW4gd2Ugd2FudCB0aGlzIGVsZW1lbnQgdG8gYmUgdGhlIHJvb3RcbiAgICAgICAgY29uc3QgZnVsbFNjcmVlbkJ1dHRvbiA9IFxuICAgICAgICAvLyBEZXBlbmRpbmcgb24gaWYgd2UncmUgY3JlYXRpbmcgYW4gaW50ZXJuYWwgYnV0dG9uLCBvciB1c2luZyBhbiBleHRlcm5hbCBvbmVcbiAgICAgICAgISF0aGlzLl9vcHRpb25zLmZ1bGxTY3JlZW5Db250cm9sc0NvbmZpZyAmJlxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5mdWxsU2NyZWVuQ29udHJvbHNDb25maWcuY3JlYXRpb25Nb2RlID09PSBVSUVsZW1lbnRDcmVhdGlvbk1vZGUuVXNlQ3VzdG9tRWxlbWVudFxuICAgICAgICAgICAgPyAvLyBFaXRoZXIgY3JlYXRlIGEgZnVsbHNjcmVlbiBjbGFzcyBiYXNlZCBvbiB0aGUgZXh0ZXJuYWwgYnV0dG9uXG4gICAgICAgICAgICAgICAgbmV3IEZ1bGxTY3JlZW5JY29uRXh0ZXJuYWwodGhpcy5fb3B0aW9ucy5mdWxsU2NyZWVuQ29udHJvbHNDb25maWcuY3VzdG9tRWxlbWVudClcbiAgICAgICAgICAgIDogLy8gT3IgdXNlIHRoZSBvbmUgY3JlYXRlZCBieSB0aGUgQ29udHJvbHMgaW5pdGlhbGl6ZXIgZWFybGllclxuICAgICAgICAgICAgICAgIGNvbnRyb2xzLmZ1bGxzY3JlZW5JY29uO1xuICAgICAgICBpZiAoZnVsbFNjcmVlbkJ1dHRvbikge1xuICAgICAgICAgICAgZnVsbFNjcmVlbkJ1dHRvbi5mdWxsc2NyZWVuRWxlbWVudCA9IC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgICAgICAgICAgICAgPyB0aGlzLnN0cmVhbS52aWRlb0VsZW1lbnRQYXJlbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZpZGVvJylbMF1cbiAgICAgICAgICAgICAgICA6IHRoaXMucm9vdEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHNldHRpbmdzIGJ1dHRvbiB0byBjb250cm9sc1xuICAgICAgICBjb25zdCBzZXR0aW5nc0J1dHRvbiA9IGNvbnRyb2xzLnNldHRpbmdzSWNvblxuICAgICAgICAgICAgPyBjb250cm9scy5zZXR0aW5nc0ljb24ucm9vdEVsZW1lbnRcbiAgICAgICAgICAgIDogdGhpcy5fb3B0aW9ucy5zZXR0aW5nc1BhbmVsQ29uZmlnLnZpc2liaWxpdHlCdXR0b25Db25maWcuY3VzdG9tRWxlbWVudDtcbiAgICAgICAgaWYgKHNldHRpbmdzQnV0dG9uKVxuICAgICAgICAgICAgc2V0dGluZ3NCdXR0b24ub25jbGljayA9ICgpID0+IHRoaXMuc2V0dGluZ3NDbGlja2VkKCk7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzUGFuZWwpXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzUGFuZWwuc2V0dGluZ3NDbG9zZUJ1dHRvbi5vbmNsaWNrID0gKCkgPT4gdGhpcy5zZXR0aW5nc0NsaWNrZWQoKTtcbiAgICAgICAgLy8gQWRkIFdlYlhSIGJ1dHRvbiB0byBjb250cm9sc1xuICAgICAgICBjb25zdCB4ckJ1dHRvbiA9IGNvbnRyb2xzLnhySWNvblxuICAgICAgICAgICAgPyBjb250cm9scy54ckljb24ucm9vdEVsZW1lbnRcbiAgICAgICAgICAgIDogdGhpcy5fb3B0aW9ucy54ckNvbnRyb2xzQ29uZmlnLmNyZWF0aW9uTW9kZSA9PT0gVUlFbGVtZW50Q3JlYXRpb25Nb2RlLlVzZUN1c3RvbUVsZW1lbnRcbiAgICAgICAgICAgICAgICA/IHRoaXMuX29wdGlvbnMueHJDb250cm9sc0NvbmZpZy5jdXN0b21FbGVtZW50XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh4ckJ1dHRvbilcbiAgICAgICAgICAgIHhyQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB0aGlzLnN0cmVhbS50b2dnbGVYUigpO1xuICAgICAgICAvLyBzZXR1cCB0aGUgc3RhdHMvaW5mbyBidXR0b25cbiAgICAgICAgY29uc3Qgc3RhdHNCdXR0b24gPSBjb250cm9scy5zdGF0c0ljb25cbiAgICAgICAgICAgID8gY29udHJvbHMuc3RhdHNJY29uLnJvb3RFbGVtZW50XG4gICAgICAgICAgICA6IHRoaXMuX29wdGlvbnMuc3RhdHNQYW5lbENvbmZpZy52aXNpYmlsaXR5QnV0dG9uQ29uZmlnLmN1c3RvbUVsZW1lbnQ7XG4gICAgICAgIGlmIChzdGF0c0J1dHRvbilcbiAgICAgICAgICAgIHN0YXRzQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB0aGlzLnN0YXRzQ2xpY2tlZCgpO1xuICAgICAgICBpZiAodGhpcy5zdGF0c1BhbmVsKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRzUGFuZWwuc3RhdHNDbG9zZUJ1dHRvbi5vbmNsaWNrID0gKCkgPT4gdGhpcy5zdGF0c0NsaWNrZWQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgY29tbWFuZCBidXR0b25zIChpZiB3ZSBoYXZlIHNvbWV3aGVyZSB0byBhZGQgdGhlbSB0bylcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3NQYW5lbCkge1xuICAgICAgICAgICAgLy8gQWRkIGJ1dHRvbiBmb3IgdG9nZ2xlIGZwc1xuICAgICAgICAgICAgY29uc3Qgc2hvd0ZQU0J1dHRvbiA9IG5ldyBMYWJlbGxlZEJ1dHRvbignU2hvdyBGUFMnLCAnVG9nZ2xlJyk7XG4gICAgICAgICAgICBzaG93RlBTQnV0dG9uLmFkZE9uQ2xpY2tMaXN0ZW5lcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucmVxdWVzdFNob3dGcHMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQWRkIGJ1dHRvbiBmb3IgcmVzdGFydCBzdHJlYW1cbiAgICAgICAgICAgIGNvbnN0IHJlc3RhcnRTdHJlYW1CdXR0b24gPSBuZXcgTGFiZWxsZWRCdXR0b24oJ1Jlc3RhcnQgU3RyZWFtJywgJ1Jlc3RhcnQnKTtcbiAgICAgICAgICAgIHJlc3RhcnRTdHJlYW1CdXR0b24uYWRkT25DbGlja0xpc3RlbmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQWRkIGJ1dHRvbiBmb3IgcmVxdWVzdCBrZXlmcmFtZVxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEtleWZyYW1lQnV0dG9uID0gbmV3IExhYmVsbGVkQnV0dG9uKCdSZXF1ZXN0IGtleWZyYW1lJywgJ1JlcXVlc3QnKTtcbiAgICAgICAgICAgIHJlcXVlc3RLZXlmcmFtZUJ1dHRvbi5hZGRPbkNsaWNrTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnJlcXVlc3RJZnJhbWUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY29tbWFuZHNTZWN0aW9uRWxlbSA9IHRoaXMuY29uZmlnVUkuYnVpbGRTZWN0aW9uV2l0aEhlYWRpbmcodGhpcy5zZXR0aW5nc1BhbmVsLnNldHRpbmdzQ29udGVudEVsZW1lbnQsICdDb21tYW5kcycpO1xuICAgICAgICAgICAgY29tbWFuZHNTZWN0aW9uRWxlbS5hcHBlbmRDaGlsZChzaG93RlBTQnV0dG9uLnJvb3RFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbW1hbmRzU2VjdGlvbkVsZW0uYXBwZW5kQ2hpbGQocmVxdWVzdEtleWZyYW1lQnV0dG9uLnJvb3RFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbW1hbmRzU2VjdGlvbkVsZW0uYXBwZW5kQ2hpbGQocmVzdGFydFN0cmVhbUJ1dHRvbi5yb290RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIHRoZSBzZXR0aW5ncyB3aXRoIG9uIGNoYW5nZSBsaXN0ZW5lcnMgYW5kIGFueSBhZGRpdGlvbmFsIHBlciBleHBlcmllbmNlIHNldHRpbmdzLlxuICAgICAqL1xuICAgIGNvbmZpZ3VyZVNldHRpbmdzKCkge1xuICAgICAgICAvLyBUaGlzIGJ1aWxkcyBhbGwgdGhlIHNldHRpbmdzIHNlY3Rpb25zIGFuZCBmbGFncyB1bmRlciB0aGlzIGBzZXR0aW5nc0NvbnRlbnRgIGVsZW1lbnQuXG4gICAgICAgIHRoaXMuY29uZmlnVUkucG9wdWxhdGVTZXR0aW5nc0VsZW1lbnQodGhpcy5zZXR0aW5nc1BhbmVsLnNldHRpbmdzQ29udGVudEVsZW1lbnQsIHRoaXMuX29wdGlvbnMuc2V0dGluZ3NQYW5lbENvbmZpZyk7XG4gICAgICAgIHRoaXMuY29uZmlnVUkuYWRkQ3VzdG9tRmxhZ09uU2V0dGluZ0NoYW5nZWRMaXN0ZW5lcihFeHRyYUZsYWdzLkxpZ2h0TW9kZSwgKGlzTGlnaHRNb2RlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ1VJLnNldEN1c3RvbUZsYWdMYWJlbChFeHRyYUZsYWdzLkxpZ2h0TW9kZSwgYENvbG9yIFNjaGVtZTogJHtpc0xpZ2h0TW9kZSA/ICdMaWdodCcgOiAnRGFyayd9IE1vZGVgKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29sb3JNb2RlKGlzTGlnaHRNb2RlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyQ2FsbGJhY2tzKCkge1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdhZmtXYXJuaW5nQWN0aXZhdGUnLCAoeyBkYXRhOiB7IGNvdW50RG93biwgZGlzbWlzc0FmayB9IH0pID0+IHRoaXMuc2hvd0Fma092ZXJsYXkoY291bnREb3duLCBkaXNtaXNzQWZrKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2Fma1dhcm5pbmdVcGRhdGUnLCAoeyBkYXRhOiB7IGNvdW50RG93biB9IH0pID0+IHRoaXMuYWZrT3ZlcmxheS51cGRhdGVDb3VudGRvd24oY291bnREb3duKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2Fma1dhcm5pbmdEZWFjdGl2YXRlJywgKCkgPT4gdGhpcy5hZmtPdmVybGF5LmhpZGUoKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2Fma1RpbWVkT3V0JywgKCkgPT4gdGhpcy5hZmtPdmVybGF5LmhpZGUoKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ3ZpZGVvRW5jb2RlckF2Z1FQJywgKHsgZGF0YTogeyBhdmdRUCB9IH0pID0+IHRoaXMub25WaWRlb0VuY29kZXJBdmdRUChhdmdRUCkpO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCd3ZWJSdGNTZHAnLCAoKSA9PiB0aGlzLm9uV2ViUnRjU2RwKCkpO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCd3ZWJSdGNBdXRvQ29ubmVjdCcsICgpID0+IHRoaXMub25XZWJSdGNBdXRvQ29ubmVjdCgpKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignd2ViUnRjQ29ubmVjdGluZycsICgpID0+IHRoaXMub25XZWJSdGNDb25uZWN0aW5nKCkpO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCd3ZWJSdGNDb25uZWN0ZWQnLCAoKSA9PiB0aGlzLm9uV2ViUnRjQ29ubmVjdGVkKCkpO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCd3ZWJSdGNGYWlsZWQnLCAoKSA9PiB0aGlzLm9uV2ViUnRjRmFpbGVkKCkpO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCd3ZWJSdGNEaXNjb25uZWN0ZWQnLCAoeyBkYXRhOiB7IGV2ZW50U3RyaW5nLCBhbGxvd0NsaWNrVG9SZWNvbm5lY3QgfSB9KSA9PiB0aGlzLm9uRGlzY29ubmVjdChldmVudFN0cmluZywgYWxsb3dDbGlja1RvUmVjb25uZWN0KSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ3ZpZGVvSW5pdGlhbGl6ZWQnLCAoKSA9PiB0aGlzLm9uVmlkZW9Jbml0aWFsaXplZCgpKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignc3RyZWFtTG9hZGluZycsICgpID0+IHRoaXMub25TdHJlYW1Mb2FkaW5nKCkpO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdwbGF5U3RyZWFtRXJyb3InLCAoeyBkYXRhOiB7IG1lc3NhZ2UgfSB9KSA9PiB0aGlzLm9uUGxheVN0cmVhbUVycm9yKG1lc3NhZ2UpKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcigncGxheVN0cmVhbScsICgpID0+IHRoaXMub25QbGF5U3RyZWFtKCkpO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdwbGF5U3RyZWFtUmVqZWN0ZWQnLCAoeyBkYXRhOiB7IHJlYXNvbiB9IH0pID0+IHRoaXMub25QbGF5U3RyZWFtUmVqZWN0ZWQocmVhc29uKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRGcmVlemVGcmFtZScsICh7IGRhdGE6IHsgc2hvdWxkU2hvd1BsYXlPdmVybGF5IH0gfSkgPT4gdGhpcy5vbkxvYWRGcmVlemVGcmFtZShzaG91bGRTaG93UGxheU92ZXJsYXkpKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignc3RhdHNSZWNlaXZlZCcsICh7IGRhdGE6IHsgYWdncmVnYXRlZFN0YXRzIH0gfSkgPT4gdGhpcy5vblN0YXRzUmVjZWl2ZWQoYWdncmVnYXRlZFN0YXRzKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2xhdGVuY3lDYWxjdWxhdGVkJywgKHsgZGF0YTogeyBsYXRlbmN5SW5mbyB9IH0pID0+IHRoaXMub25MYXRlbmN5VXBkYXRlKGxhdGVuY3lJbmZvKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2xhdGVuY3lUZXN0UmVzdWx0JywgKHsgZGF0YTogeyBsYXRlbmN5VGltaW5ncyB9IH0pID0+IHRoaXMub25MYXRlbmN5VGVzdFJlc3VsdHMobGF0ZW5jeVRpbWluZ3MpKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignZGF0YUNoYW5uZWxMYXRlbmN5VGVzdFJlc3VsdCcsICh7IGRhdGE6IHsgcmVzdWx0IH0gfSkgPT4gdGhpcy5vbkRhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXN1bHRzKHJlc3VsdCkpO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdzdHJlYW1lckxpc3RNZXNzYWdlJywgKHsgZGF0YTogeyBtZXNzYWdlU3RyZWFtZXJMaXN0LCBhdXRvU2VsZWN0ZWRTdHJlYW1lcklkLCB3YW50ZWRTdHJlYW1lcklkIH0gfSkgPT4gdGhpcy5oYW5kbGVTdHJlYW1lckxpc3RNZXNzYWdlKG1lc3NhZ2VTdHJlYW1lckxpc3QsIGF1dG9TZWxlY3RlZFN0cmVhbWVySWQsIHdhbnRlZFN0cmVhbWVySWQpKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignc3Vic2NyaWJlRmFpbGVkJywgKHsgZGF0YTogeyBtZXNzYWdlIH0gfSkgPT4gdGhpcy5oYW5kbGVTdWJzY3JpYmVGYWlsZWRNZXNzYWdlKG1lc3NhZ2UpKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignc2V0dGluZ3NDaGFuZ2VkJywgKGV2ZW50KSA9PiB0aGlzLm9uU2V0dGluZ3NDaGFuZ2VkKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXllckNvdW50JywgKHsgZGF0YTogeyBjb3VudCB9IH0pID0+IHRoaXMub25QbGF5ZXJDb3VudChjb3VudCkpO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCd3ZWJSdGNUQ1BSZWxheURldGVjdGVkJywgKCkgPT4gTG9nZ2VyLldhcm5pbmcoYFN0cmVhbSBxdWFpbHR5IGRlZ3JhZGVkIGR1ZSB0byBuZXR3b3JrIGVudmlyb21lbnQsIHN0cmVhbSBpcyByZWxheWVkIG92ZXIgVENQLmApKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignc2hvd09uU2NyZWVuS2V5Ym9hcmQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIE9ubHkgc2hvdyB0aGUgZWRpdCB0ZXh0IG1vZGFsIGlmIHRoZSBmbGFnIGlzIGVuYWJsZWRcbiAgICAgICAgICAgIGlmICghdGhpcy5zdHJlYW0uY29uZmlnLmlzRmxhZ0VuYWJsZWQoRmxhZ3MuVXNlTW9kYWxGb3JUZXh0SW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXZ0RGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBpZiAoZXZ0RGF0YS5zaG93T25TY3JlZW5LZXlib2FyZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0VkaXRUZXh0TW9kYWwoZXZ0RGF0YS5jb250ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByb290RWxlbWVudCBvZiB0aGUgYXBwbGljYXRpb24sIHZpZGVvIHN0cmVhbSBhbmQgYWxsIFVJIGFyZSBjaGlsZHJlbiBvZiB0aGlzIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0IHJvb3RFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IHRoaXMuY3JlYXRlUm9vdEVsZW1lbnQodGhpcy5zdHJlYW0sIHRoaXMudWlGZWF0dXJlc0VsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290RWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgcm9vdCBlbGVtZW50IGZvciB0aGUgUGl4ZWwgU3RyZWFtaW5nIFVJLlxuICAgICAqIE5vdGU6IFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgdGhlIFBpeGVsIFN0cmVhbWluZyBvYmplY3QgaXMgY3JlYXRlZC5cbiAgICAgKiBAcGFyYW0gcGl4ZWxzdHJlYW1pbmcgLSBUaGUgUGl4ZWwgU3RyZWFtaW5nIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gdWlGZWF0dXJlc0VsZW0gLSBUaGUgZWxlbWVudCBob2xkaW5nIGFsbCB0aGUgY3VzdG9tIFVJIGZlYXR1cmVzLlxuICAgICAqIEByZXR1cm5zIEEgZGl2IHdpdGggdGhlIGlkICNwbGF5ZXJVSSBwb3B1bGF0ZWQgd2l0aCB2aWRlb0VsZW1lbnRQYXJlbnQgYW5kIHVpRmVhdHVyZUVsZW1lbnQuXG4gICAgICovXG4gICAgY3JlYXRlUm9vdEVsZW1lbnQocGl4ZWxzdHJlYW1pbmcsIHVpRmVhdHVyZXNFbGVtKSB7XG4gICAgICAgIGNvbnN0IGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZWxlbS5pZCA9ICdwbGF5ZXJVSSc7XG4gICAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZCgnbm9zZWxlY3QnKTtcbiAgICAgICAgaWYgKHBpeGVsc3RyZWFtaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNyZWF0ZSByb290IGVsZW1lbnQgcHJvcGVybHkgLSBwaXhlbHN0cmVhbWluZyBvYmplY3Qgd2FzIHVuZGVmaW5lZC4gQXJlIHlvdSBjYWxsaW5nIHRoaXMgdG9vIGVhcmx5PycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwaXhlbHN0cmVhbWluZy52aWRlb0VsZW1lbnRQYXJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY3JlYXRlIHJvb3QgZWxlbWVudCBwcm9wZXJseSAtIHZpZGVvRWxlbWVudFBhcmVudCBvYmplY3Qgd2FzIHVuZGVmaW5lZC4gQXJlIHlvdSBjYWxsaW5nIHRoaXMgdG9vIGVhcmx5PycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1aUZlYXR1cmVzRWxlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjcmVhdGUgcm9vdCBlbGVtZW50IHByb3Blcmx5IC0gdWlGZWF0dXJlc0VsZW1lbnQgb2JqZWN0IHdhcyB1bmRlZmluZWQuIEFyZSB5b3UgY2FsbGluZyB0aGlzIHRvbyBlYXJseT8nKTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtLmFwcGVuZENoaWxkKHBpeGVsc3RyZWFtaW5nLnZpZGVvRWxlbWVudFBhcmVudCk7XG4gICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQodWlGZWF0dXJlc0VsZW0pO1xuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZWxlbWVudCB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgVUkgZmVhdHVyZXMsIGxpa2UgdGhlIHN0YXRzIGFuZCBzZXR0aW5ncyBwYW5lbHMuXG4gICAgICovXG4gICAgZ2V0IHVpRmVhdHVyZXNFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3VpRmVhdHVyZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3VpRmVhdHVyZUVsZW1lbnQgPSB0aGlzLmNyZWF0ZVVJRmVhdHVyZXNFbGVtZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VpRmVhdHVyZUVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIFVJIGZlYXR1cmVzIGVsZW1lbnQgZm9yIGhvbGRpbmcgYWxsIHRoZSBjdXN0b20gVUkgZmVhdHVyZXMuXG4gICAgICogQHJldHVybnMgQSBkaXYgd2l0aCB0aGUgaWQgI3VpRmVhdHVyZXMuXG4gICAgICovXG4gICAgY3JlYXRlVUlGZWF0dXJlc0VsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZWxlbS5pZCA9ICd1aUZlYXR1cmVzJztcbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBkaXNjb25uZWN0IG92ZXJsYXlcbiAgICAgKiBAcGFyYW0gdXBkYXRlVGV4dCAtIHRoZSB0ZXh0IHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gdGhlIG92ZXJsYXlcbiAgICAgKi9cbiAgICBzaG93RGlzY29ubmVjdE92ZXJsYXkodXBkYXRlVGV4dCkge1xuICAgICAgICB0aGlzLmhpZGVDdXJyZW50T3ZlcmxheSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZURpc2Nvbm5lY3RPdmVybGF5KHVwZGF0ZVRleHQpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RPdmVybGF5LnNob3coKTtcbiAgICAgICAgdGhpcy5jdXJyZW50T3ZlcmxheSA9IHRoaXMuZGlzY29ubmVjdE92ZXJsYXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZGlzY29ubmVjdCBvdmVybGF5cyBzcGFuIHRleHRcbiAgICAgKiBAcGFyYW0gdXBkYXRlVGV4dCAtIHRoZSBuZXcgY291bnRkb3duIG51bWJlclxuICAgICAqL1xuICAgIHVwZGF0ZURpc2Nvbm5lY3RPdmVybGF5KHVwZGF0ZVRleHQpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0T3ZlcmxheS51cGRhdGUodXBkYXRlVGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyB0aGUgZGlzY29ubmVjdCBvdmVybGF5cyBhY3Rpb25cbiAgICAgKi9cbiAgICBvbkRpc2Nvbm5lY3Rpb25BY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdE92ZXJsYXkuYWN0aXZhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIGN1cnJlbnQgb3ZlcmxheVxuICAgICAqL1xuICAgIGhpZGVDdXJyZW50T3ZlcmxheSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE92ZXJsYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50T3ZlcmxheS5oaWRlKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRPdmVybGF5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgY29ubmVjdCBvdmVybGF5XG4gICAgICovXG4gICAgc2hvd0Nvbm5lY3RPdmVybGF5KCkge1xuICAgICAgICB0aGlzLmhpZGVDdXJyZW50T3ZlcmxheSgpO1xuICAgICAgICB0aGlzLmNvbm5lY3RPdmVybGF5LnNob3coKTtcbiAgICAgICAgdGhpcy5jdXJyZW50T3ZlcmxheSA9IHRoaXMuY29ubmVjdE92ZXJsYXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBwbGF5IG92ZXJsYXlcbiAgICAgKi9cbiAgICBzaG93UGxheU92ZXJsYXkoKSB7XG4gICAgICAgIHRoaXMuaGlkZUN1cnJlbnRPdmVybGF5KCk7XG4gICAgICAgIHRoaXMucGxheU92ZXJsYXkuc2hvdygpO1xuICAgICAgICB0aGlzLmN1cnJlbnRPdmVybGF5ID0gdGhpcy5wbGF5T3ZlcmxheTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIHRleHQgb3ZlcmxheVxuICAgICAqIEBwYXJhbSB0ZXh0IC0gdGhlIHRleHQgdGhhdCB3aWxsIGJlIHNob3duIGluIHRoZSBvdmVybGF5XG4gICAgICovXG4gICAgc2hvd1RleHRPdmVybGF5KHRleHQpIHtcbiAgICAgICAgdGhpcy5oaWRlQ3VycmVudE92ZXJsYXkoKTtcbiAgICAgICAgdGhpcy5pbmZvT3ZlcmxheS51cGRhdGUodGV4dCk7XG4gICAgICAgIHRoaXMuaW5mb092ZXJsYXkuc2hvdygpO1xuICAgICAgICB0aGlzLmN1cnJlbnRPdmVybGF5ID0gdGhpcy5pbmZvT3ZlcmxheTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIGVycm9yIG92ZXJsYXlcbiAgICAgKiBAcGFyYW0gdGV4dCAtIHRoZSB0ZXh0IHRoYXQgd2lsbCBiZSBzaG93biBpbiB0aGUgb3ZlcmxheVxuICAgICAqL1xuICAgIHNob3dFcnJvck92ZXJsYXkodGV4dCkge1xuICAgICAgICB0aGlzLmhpZGVDdXJyZW50T3ZlcmxheSgpO1xuICAgICAgICB0aGlzLmVycm9yT3ZlcmxheS51cGRhdGUodGV4dCk7XG4gICAgICAgIHRoaXMuZXJyb3JPdmVybGF5LnNob3coKTtcbiAgICAgICAgdGhpcy5jdXJyZW50T3ZlcmxheSA9IHRoaXMuZXJyb3JPdmVybGF5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyBvciBoaWRlcyB0aGUgc2V0dGluZ3MgcGFuZWwgaWYgY2xpY2tlZFxuICAgICAqL1xuICAgIHNldHRpbmdzQ2xpY2tlZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnN0YXRzUGFuZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oaWRlKCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NQYW5lbC50b2dnbGVWaXNpYmlsaXR5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIG9yIGhpZGVzIHRoZSBzdGF0cyBwYW5lbCBpZiBjbGlja2VkXG4gICAgICovXG4gICAgc3RhdHNDbGlja2VkKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuc2V0dGluZ3NQYW5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhpZGUoKTtcbiAgICAgICAgdGhpcy5zdGF0c1BhbmVsLnRvZ2dsZVZpc2liaWxpdHkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIHRoZSBjb25uZWN0IG92ZXJsYXlzIGFjdGlvblxuICAgICAqL1xuICAgIG9uQ29ubmVjdEFjdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0T3ZlcmxheS5hY3RpdmF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIHBsYXkgb3ZlcmxheXMgYWN0aW9uXG4gICAgICovXG4gICAgb25QbGF5QWN0aW9uKCkge1xuICAgICAgICB0aGlzLnBsYXlPdmVybGF5LmFjdGl2YXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBhZmsgb3ZlcmxheVxuICAgICAqIEBwYXJhbSBjb3VudERvd24gLSB0aGUgY291bnRkb3duIG51bWJlciBmb3IgdGhlIGFmayBjb3VudGRvd25cbiAgICAgKi9cbiAgICBzaG93QWZrT3ZlcmxheShjb3VudERvd24sIGRpc21pc3NBZmspIHtcbiAgICAgICAgdGhpcy5oaWRlQ3VycmVudE92ZXJsYXkoKTtcbiAgICAgICAgdGhpcy5hZmtPdmVybGF5LnVwZGF0ZUNvdW50ZG93bihjb3VudERvd24pO1xuICAgICAgICB0aGlzLmFma092ZXJsYXkub25BY3Rpb24oKCkgPT4gZGlzbWlzc0FmaygpKTtcbiAgICAgICAgdGhpcy5hZmtPdmVybGF5LnNob3coKTtcbiAgICAgICAgdGhpcy5jdXJyZW50T3ZlcmxheSA9IHRoaXMuYWZrT3ZlcmxheTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgQ29ubmVjdCBPdmVybGF5IG9yIGF1dG8gY29ubmVjdFxuICAgICAqL1xuICAgIHNob3dDb25uZWN0T3JBdXRvQ29ubmVjdE92ZXJsYXlzKCkge1xuICAgICAgICAvLyBzZXQgdXAgaWYgdGhlIGF1dG8gcGxheSB3aWxsIGJlIHVzZWQgb3IgcmVndWxhciBjbGljayB0byBzdGFydFxuICAgICAgICBpZiAoIXRoaXMuc3RyZWFtLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkF1dG9Db25uZWN0KSkge1xuICAgICAgICAgICAgdGhpcy5zaG93Q29ubmVjdE92ZXJsYXkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSB3ZWJSdGNBdXRvQ29ubmVjdCBPdmVybGF5IGFuZCBjb25uZWN0XG4gICAgICovXG4gICAgb25XZWJSdGNBdXRvQ29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5zaG93VGV4dE92ZXJsYXkoJ0F1dG8gQ29ubmVjdGluZyBOb3cnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHVwIGZ1bmN0aW9uYWxpdHkgdG8gaGFwcGVuIHdoZW4gcmVjZWl2aW5nIGEgd2ViUlRDIGFuc3dlclxuICAgICAqL1xuICAgIG9uV2ViUnRjU2RwKCkge1xuICAgICAgICB0aGlzLnNob3dUZXh0T3ZlcmxheSgnV2ViUlRDIENvbm5lY3Rpb24gTmVnb3RpYXRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIHRleHQgb3ZlcmxheSB0byBhbGVydCB0aGUgdXNlciB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBsb2FkaW5nXG4gICAgICovXG4gICAgb25TdHJlYW1Mb2FkaW5nKCkge1xuICAgICAgICAvLyBidWlsZCB0aGUgc3Bpbm5lciBzcGFuXG4gICAgICAgIGNvbnN0IHNwaW5uZXJTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBzcGlubmVyU3Bhbi5jbGFzc05hbWUgPSAndmlzdWFsbHktaGlkZGVuJztcbiAgICAgICAgc3Bpbm5lclNwYW4uaW5uZXJIVE1MID0gJ0xvYWRpbmcuLi4nO1xuICAgICAgICAvLyBidWlsZCB0aGUgc3Bpbm5lciBkaXZcbiAgICAgICAgY29uc3Qgc3Bpbm5lckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzcGlubmVyRGl2LmlkID0gJ2xvYWRpbmctc3Bpbm5lcic7XG4gICAgICAgIHNwaW5uZXJEaXYuY2xhc3NOYW1lID0gJ3NwaW5uZXItYm9yZGVyIG1zLTInO1xuICAgICAgICBzcGlubmVyRGl2LnNldEF0dHJpYnV0ZSgncm9sZScsICdzdGF0dXMnKTtcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBzcGlubmVyIHRvIHRoZSBlbGVtZW50XG4gICAgICAgIHNwaW5uZXJEaXYuYXBwZW5kQ2hpbGQoc3Bpbm5lclNwYW4pO1xuICAgICAgICB0aGlzLnNob3dUZXh0T3ZlcmxheSgnTG9hZGluZyBTdHJlYW0gJyArIHNwaW5uZXJEaXYub3V0ZXJIVE1MKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB0aGUgdmlkZW8gaXMgZGlzY29ubmVjdGVkIC0gZGlzcGxheXMgdGhlIGVycm9yIG92ZXJsYXkgYW5kIHJlc2V0cyB0aGUgYnV0dG9ucyBzdHJlYW0gdG9vbHMgdXBvbiBkaXNjb25uZWN0XG4gICAgICogQHBhcmFtIGV2ZW50U3RyaW5nIC0gdGhlIGV2ZW50IHRleHQgdGhhdCB3aWxsIGJlIHNob3duIGluIHRoZSBvdmVybGF5XG4gICAgICogQHBhcmFtIGFsbG93Q2xpY2tUb1JlY29ubmVjdCAtIHRydWUgaWYgd2Ugd2FudCB0byBhbGxvdyB0aGUgdXNlciB0byBjbGljayB0byByZWNvbm5lY3QuIE90aGVyd2lzZSBpdCdzIGp1c3QgYSBtZXNzYWdlLlxuICAgICAqL1xuICAgIG9uRGlzY29ubmVjdChldmVudFN0cmluZywgYWxsb3dDbGlja1RvUmVjb25uZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgb3ZlcmxheU1lc3NhZ2UgPSAnRGlzY29ubmVjdGVkJyArIChldmVudFN0cmluZyA/IGA6ICR7ZXZlbnRTdHJpbmd9YCA6ICcuJyk7XG4gICAgICAgIGlmIChhbGxvd0NsaWNrVG9SZWNvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0Rpc2Nvbm5lY3RPdmVybGF5KGAke292ZXJsYXlNZXNzYWdlfSBDbGljayBUbyBSZXN0YXJ0LmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93RXJyb3JPdmVybGF5KG92ZXJsYXlNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkaXNhYmxlIHN0YXJ0aW5nIGEgbGF0ZW5jeSBjaGVja3NcbiAgICAgICAgKF9hID0gdGhpcy5zdGF0c1BhbmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25EaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd2hlbiBXZWIgUnRjIGlzIGNvbm5lY3RpbmdcbiAgICAgKi9cbiAgICBvbldlYlJ0Y0Nvbm5lY3RpbmcoKSB7XG4gICAgICAgIHRoaXMuc2hvd1RleHRPdmVybGF5KCdTdGFydGluZyBjb25uZWN0aW9uIHRvIHNlcnZlciwgcGxlYXNlIHdhaXQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIFdlYiBSdGMgaGFzIGNvbm5lY3RlZFxuICAgICAqL1xuICAgIG9uV2ViUnRjQ29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnNob3dUZXh0T3ZlcmxheSgnV2ViUlRDIGNvbm5lY3RlZCwgd2FpdGluZyBmb3IgdmlkZW8nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIFdlYiBSdGMgZmFpbHMgdG8gY29ubmVjdFxuICAgICAqL1xuICAgIG9uV2ViUnRjRmFpbGVkKCkge1xuICAgICAgICB0aGlzLnNob3dFcnJvck92ZXJsYXkoJ1VuYWJsZSB0byBzZXR1cCB2aWRlbycpO1xuICAgIH1cbiAgICBvbkxvYWRGcmVlemVGcmFtZShzaG91bGRTaG93UGxheU92ZXJsYXkpIHtcbiAgICAgICAgaWYgKHNob3VsZFNob3dQbGF5T3ZlcmxheSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJ3Nob3dpbmcgcGxheSBvdmVybGF5Jyk7XG4gICAgICAgICAgICB0aGlzLnNob3dQbGF5T3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uUGxheVN0cmVhbSgpIHtcbiAgICAgICAgdGhpcy5oaWRlQ3VycmVudE92ZXJsYXkoKTtcbiAgICB9XG4gICAgb25QbGF5U3RyZWFtRXJyb3IobWVzc2FnZSkge1xuICAgICAgICB0aGlzLnNob3dFcnJvck92ZXJsYXkobWVzc2FnZSk7XG4gICAgfVxuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbiAgICBvblBsYXlTdHJlYW1SZWplY3RlZChvblJlamVjdGVkUmVhc29uKSB7XG4gICAgICAgIHRoaXMuc2hvd1BsYXlPdmVybGF5KCk7XG4gICAgfVxuICAgIG9uVmlkZW9Jbml0aWFsaXplZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuc3RyZWFtLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLkF1dG9QbGF5VmlkZW8pKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dQbGF5T3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuc3RhdHNQYW5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uVmlkZW9Jbml0aWFsaXplZCh0aGlzLnN0cmVhbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB1cCBmdW5jdGlvbmFsaXR5IHRvIGhhcHBlbiB3aGVuIGNhbGN1bGF0aW5nIHRoZSBhdmVyYWdlIHZpZGVvIGVuY29kZXIgcXBcbiAgICAgKiBAcGFyYW0gUVAgLSB0aGUgcXVhbGl0eSBudW1iZXIgb2YgdGhlIHN0cmVhbVxuICAgICAqL1xuICAgIG9uVmlkZW9FbmNvZGVyQXZnUVAoUVApIHtcbiAgICAgICAgLy8gVXBkYXRlIGludGVybmFsIFFQIGluZGljYXRvciBpZiBvbmUgaXMgcHJlc2VudFxuICAgICAgICBpZiAodGhpcy52aWRlb1FwSW5kaWNhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvUXBJbmRpY2F0b3IudXBkYXRlUXBUb29sdGlwKFFQKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkluaXRpYWxTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChzZXR0aW5ncy5QaXhlbFN0cmVhbWluZ1NldHRpbmdzKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnN0YXRzUGFuZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25maWd1cmUoc2V0dGluZ3MuUGl4ZWxTdHJlYW1pbmdTZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25TdGF0c1JlY2VpdmVkKGFnZ3JlZ2F0ZWRTdGF0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIEdyYWIgYWxsIHN0YXRzIHdlIGNhbiBvZmYgdGhlIGFnZ3JlZ2F0ZWQgc3RhdHNcbiAgICAgICAgKF9hID0gdGhpcy5zdGF0c1BhbmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFuZGxlU3RhdHMoYWdncmVnYXRlZFN0YXRzKTtcbiAgICB9XG4gICAgb25MYXRlbmN5VXBkYXRlKGxhdGVuY3lJbmZvKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5zdGF0c1BhbmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFuZGxlTGF0ZW5jeUluZm8obGF0ZW5jeUluZm8pO1xuICAgIH1cbiAgICBvbkxhdGVuY3lUZXN0UmVzdWx0cyhsYXRlbmN5VGltaW5ncykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuc3RhdHNQYW5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhdGVuY3lUZXN0LmhhbmRsZVRlc3RSZXN1bHQobGF0ZW5jeVRpbWluZ3MpO1xuICAgIH1cbiAgICBvbkRhdGFDaGFubmVsTGF0ZW5jeVRlc3RSZXN1bHRzKHJlc3VsdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuc3RhdHNQYW5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGFDaGFubmVsTGF0ZW5jeVRlc3QuaGFuZGxlVGVzdFJlc3VsdChyZXN1bHQpO1xuICAgIH1cbiAgICBvblBsYXllckNvdW50KHBsYXllckNvdW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5zdGF0c1BhbmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFuZGxlUGxheWVyQ291bnQocGxheWVyQ291bnQpO1xuICAgIH1cbiAgICBoYW5kbGVTdHJlYW1lckxpc3RNZXNzYWdlKG1lc3NhZ2VTdHJlYW1pbmdMaXN0LCBhdXRvU2VsZWN0ZWRTdHJlYW1lcklkLCB3YW50ZWRTdHJlYW1lcklkKSB7XG4gICAgICAgIGNvbnN0IHdhaXRGb3JTdHJlYW1lciA9IHRoaXMuc3RyZWFtLmNvbmZpZy5pc0ZsYWdFbmFibGVkKEZsYWdzLldhaXRGb3JTdHJlYW1lcik7XG4gICAgICAgIGNvbnN0IGlzUmVjb25uZWN0aW5nID0gdGhpcy5zdHJlYW0uaXNSZWNvbm5lY3RpbmcoKTtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBsZXQgYWxsb3dSZXN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFhdXRvU2VsZWN0ZWRTdHJlYW1lcklkKSB7XG4gICAgICAgICAgICBpZiAod2FpdEZvclN0cmVhbWVyICYmIHdhbnRlZFN0cmVhbWVySWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBXYWl0aW5nIGZvciAke3dhbnRlZFN0cmVhbWVySWR9IHRvIGJlY29tZSBhdmFpbGFibGUuYDtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dSZXN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEdhdmUgdXAgd2FpdGluZyBmb3IgJHt3YW50ZWRTdHJlYW1lcklkfSB0byBiZWNvbWUgYXZhaWxhYmxlLiBDbGljayB0byB0cnkgYWdhaW5gO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVN0cmVhbWluZ0xpc3QuaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYCBvciBzZWxlY3QgYSBzdHJlYW1lciBmcm9tIHRoZSBzZXR0aW5ncyBtZW51LmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWxsb3dSZXN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlU3RyZWFtaW5nTGlzdC5pZHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBXYWl0aW5nIGZvciBhIHN0cmVhbWVyIHRvIGJlY29tZSBhdmFpbGFibGUuYDtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dSZXN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE5vIHN0cmVhbWVycyBhdmFpbGFibGUuIENsaWNrIHRvIHRyeSBhZ2Fpbi5gO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1Jlc3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTXVsdGlwbGUgc3RyZWFtZXJzIGF2YWlsYWJsZS4gU2VsZWN0IG9uZSBmcm9tIHRoZSBzZXR0aW5ncyBtZW51LmA7XG4gICAgICAgICAgICAgICAgYWxsb3dSZXN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxsb3dSZXN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RGlzY29ubmVjdE92ZXJsYXkobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dUZXh0T3ZlcmxheShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVTdWJzY3JpYmVGYWlsZWRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5zaG93RGlzY29ubmVjdE92ZXJsYXkoYFN1YnNjcmliZSBmYWlsZWQ6IFwiJHttZXNzYWdlfVwiIENsaWNrIHRvIHRyeSBhZ2FpbmApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgbGlnaHQvZGFyayBjb2xvciBtb2RlXG4gICAgICogQHBhcmFtIGlzTGlnaHRNb2RlIC0gc2hvdWxkIHdlIHVzZSBhIGxpZ2h0IG9yIGRhcmsgY29sb3Igc2NoZW1lXG4gICAgICovXG4gICAgc2V0Q29sb3JNb2RlKGlzTGlnaHRNb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLm9uQ29sb3JNb2RlQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5vbkNvbG9yTW9kZUNoYW5nZWQoaXNMaWdodE1vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNob3dFZGl0VGV4dE1vZGFsKHVlVGV4dGJveENvbnRlbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBtb2RhbFxuICAgICAgICAoX2EgPSB0aGlzLmVkaXRUZXh0TW9kYWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yb290RWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgLy8gTWFrZSBhIG5ldyBtb2RhbCBmb3IgZWRpdGluZyB0aGUgVUUgdGV4dGJveCBvbiB0aGUgYnJvd3NlciBzaWRlXG4gICAgICAgIHRoaXMuZWRpdFRleHRNb2RhbCA9IG5ldyBFZGl0VGV4dE1vZGFsKCk7XG4gICAgICAgIC8vIEFkZCBpdCB0byB0aGUgcm9vdCBvZiB0aGUgUGl4ZWwgU3RyZWFtaW5nIGFwcGxpY2F0aW9uXG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQuYXBwZW5kKHRoaXMuZWRpdFRleHRNb2RhbC5yb290RWxlbWVudCk7XG4gICAgICAgIC8vIEFkZCB0aGUgdGV4dCBjb250ZW50IGZyb20gVUUgc2lkZSBhbmQgc3VtbW9uIG9uLXNjcmVlbiBrZXlib2FyZFxuICAgICAgICB0aGlzLmVkaXRUZXh0TW9kYWwuc2hvd01vZGFsKHVlVGV4dGJveENvbnRlbnRzKTtcbiAgICAgICAgLy8gQmluZCB0byB0aGUgY29uZmlybSBldmVudFxuICAgICAgICB0aGlzLmVkaXRUZXh0TW9kYWwuZXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIoJ2VkaXRDb25maXJtZWQnLCAoZXZ0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlZGl0VGV4dEV2ZW50ID0gZXZ0O1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0uc2VuZFRleHRib3hFbnRyeShlZGl0VGV4dEV2ZW50LmNvbmZpcm1lZFRleHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25TZXR0aW5nc0NoYW5nZWQoZXZlbnQpIHtcbiAgICAgICAgLy8gUGFzcyB0aGUgZXZlbnQgZGlyZWN0bHkgb250byB0aGUgY29uZmlnVUkuIFRoaXMgd2lsbCBkbyB0aGluZ3MgbGlrZSB1cGRhdGluZyB0aGUgcG9zc2libGUgdmFsdWVzXG4gICAgICAgIC8vIGFzIHdlbGwgYXMgdGhlIHNlbGVjdGVkIHZhbHVlXG4gICAgICAgIHRoaXMuY29uZmlnVUkub25TZXR0aW5nc0NoYW5nZWQoZXZlbnQpO1xuICAgICAgICBjb25zdCB7IFxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4gICAgICAgIGRhdGE6IHsgaWQsIHRhcmdldCwgdHlwZSB9IH0gPSBldmVudDtcbiAgICAgICAgLy8gRXhwbGljaXRseSBoYW5kbGUgc3BlY2lmaWMgc2V0dGluZyBiZWhhdmlvdXJcbiAgICAgICAgaWYgKGlkID09IE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkUXVhbGl0eSkge1xuICAgICAgICAgICAgY29uc3QgcHJlZmVycmVkUXVhbGl0eU9wdGlvbiA9IHRoaXMuc3RyZWFtLmNvbmZpZy5nZXRTZXR0aW5nT3B0aW9uKE9wdGlvblBhcmFtZXRlcnMuUHJlZmVycmVkUXVhbGl0eSk7XG4gICAgICAgICAgICBpZiAoWy4uLnByZWZlcnJlZFF1YWxpdHlPcHRpb24ub3B0aW9uc10uaW5jbHVkZXMoJ0RlZmF1bHQnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnVUkuZGlzYWJsZVNldHRpbmcoT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRRdWFsaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnVUkuZW5hYmxlU2V0dGluZyhPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZFF1YWxpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwbGljYXRpb24uanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IFRleHRQYXJhbWV0ZXJzLCBPcHRpb25QYXJhbWV0ZXJzLCBGbGFncywgTnVtZXJpY1BhcmFtZXRlcnMsIFNldHRpbmdGbGFnLCBMb2dnZXIsIGlzRmxhZ0lkLCBpc051bWVyaWNJZCwgaXNUZXh0SWQsIGlzT3B0aW9uSWQgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2Zyb250ZW5kLXVlNS42JztcbmltcG9ydCB7IFNldHRpbmdVSUZsYWcgfSBmcm9tICcuL1NldHRpbmdVSUZsYWcnO1xuaW1wb3J0IHsgU2V0dGluZ1VJTnVtYmVyIH0gZnJvbSAnLi9TZXR0aW5nVUlOdW1iZXInO1xuaW1wb3J0IHsgU2V0dGluZ1VJVGV4dCB9IGZyb20gJy4vU2V0dGluZ1VJVGV4dCc7XG5pbXBvcnQgeyBTZXR0aW5nVUlPcHRpb24gfSBmcm9tICcuL1NldHRpbmdVSU9wdGlvbic7XG5pbXBvcnQgeyBFeHRyYUZsYWdzLCBpc1NlY3Rpb25FbmFibGVkLCBpc1NldHRpbmdFbmFibGVkLCBTZXR0aW5nc1NlY3Rpb25zIH0gZnJvbSAnLi4vVUkvVUlDb25maWd1cmF0aW9uVHlwZXMnO1xuZXhwb3J0IGNsYXNzIENvbmZpZ1VJIHtcbiAgICAvLyAtLS0tLS0tLS0tLS0gU2V0dGluZ3MgLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5jdXN0b21GbGFncyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyogQSBtYXAgb2YgZmxhZ3MgdGhhdCBjYW4gYmUgdG9nZ2xlZCAtIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0IGluIHRoZSBhcHBsaWNhdGlvbiAtIGUuZy4gVXNlIE1pYz8gKi9cbiAgICAgICAgdGhpcy5mbGFnc1VpID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiBBIG1hcCBvZiBudW1lcmljYWwgc2V0dGluZ3MgLSBvcHRpb25zIHRoYXQgY2FuIGJlIGluIHRoZSBhcHBsaWNhdGlvbiAtIGUuZy4gTWluQml0cmF0ZSAqL1xuICAgICAgICB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzVWkgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qIEEgbWFwIG9mIHRleHQgc2V0dGluZ3MgLSBlLmcuIHNpZ25hbGxpbmcgc2VydmVyIHVybCAqL1xuICAgICAgICB0aGlzLnRleHRQYXJhbWV0ZXJzVWkgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qIEEgbWFwIG9mIGVudW0gYmFzZWQgc2V0dGluZ3MgLSBlLmcuIHByZWZlcnJlZCBjb2RlYyAqL1xuICAgICAgICB0aGlzLm9wdGlvblBhcmFtZXRlcnNVaSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDdXN0b21VSVNldHRpbmdzKGNvbmZpZy51c2VVcmxQYXJhbXMpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyU2V0dGluZ3NVSUNvbXBvbmVudHMoY29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGN1c3RvbSBVSSBzZXR0aW5ncyB0aGF0IGFyZSBub3QgcHJvdmlkZWQgYnkgdGhlIFBpeGVsIFN0cmVhbWluZyBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGNyZWF0ZUN1c3RvbVVJU2V0dGluZ3ModXNlVXJsUGFyYW1zKSB7XG4gICAgICAgIHRoaXMuY3VzdG9tRmxhZ3Muc2V0KEV4dHJhRmxhZ3MuTGlnaHRNb2RlLCBuZXcgU2V0dGluZ0ZsYWcoRXh0cmFGbGFncy5MaWdodE1vZGUsICdDb2xvciBTY2hlbWU6IERhcmsgTW9kZScsICdQYWdlIHN0eWxpbmcgd2lsbCBiZSBlaXRoZXIgbGlnaHQgb3IgZGFyaycsIGZhbHNlIC8qaWYgd2FudCB0byB1c2Ugc3lzdGVtIHByZWY6ICh3aW5kb3cubWF0Y2hNZWRpYSAmJiB3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtY29sb3Itc2NoZW1lOiBsaWdodCknKS5tYXRjaGVzKSovLCB1c2VVcmxQYXJhbXMsIChpc0xpZ2h0TW9kZSwgc2V0dGluZykgPT4ge1xuICAgICAgICAgICAgc2V0dGluZy5sYWJlbCA9IGBDb2xvciBTY2hlbWU6ICR7aXNMaWdodE1vZGUgPyAnTGlnaHQnIDogJ0RhcmsnfSBNb2RlYDtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIFVJIHdyYXBwZXIgY29tcG9uZW50cyBmb3IgZWFjaCBzZXR0aW5nIGVsZW1lbnQgaW4gY29uZmlnLlxuICAgICAqIEBwYXJhbSBjb25maWcgLVxuICAgICAqL1xuICAgIHJlZ2lzdGVyU2V0dGluZ3NVSUNvbXBvbmVudHMoY29uZmlnKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2V0dGluZyBvZiBjb25maWcuZ2V0RmxhZ3MoKSkge1xuICAgICAgICAgICAgdGhpcy5mbGFnc1VpLnNldChzZXR0aW5nLmlkLCBuZXcgU2V0dGluZ1VJRmxhZyhzZXR0aW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzZXR0aW5nIG9mIEFycmF5LmZyb20odGhpcy5jdXN0b21GbGFncy52YWx1ZXMoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3NVaS5zZXQoc2V0dGluZy5pZCwgbmV3IFNldHRpbmdVSUZsYWcoc2V0dGluZykpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc2V0dGluZyBvZiBjb25maWcuZ2V0VGV4dFNldHRpbmdzKCkpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dFBhcmFtZXRlcnNVaS5zZXQoc2V0dGluZy5pZCwgbmV3IFNldHRpbmdVSVRleHQoc2V0dGluZykpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc2V0dGluZyBvZiBjb25maWcuZ2V0TnVtZXJpY1NldHRpbmdzKCkpIHtcbiAgICAgICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnNVaS5zZXQoc2V0dGluZy5pZCwgbmV3IFNldHRpbmdVSU51bWJlcihzZXR0aW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzZXR0aW5nIG9mIGNvbmZpZy5nZXRPcHRpb25TZXR0aW5ncygpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvblBhcmFtZXRlcnNVaS5zZXQoc2V0dGluZy5pZCwgbmV3IFNldHRpbmdVSU9wdGlvbihzZXR0aW5nKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZSBET00gZWxlbWVudHMgZm9yIGEgc2V0dGluZ3Mgc2VjdGlvbiB3aXRoIGEgaGVhZGluZy5cbiAgICAgKiBAcGFyYW0gc2V0dGluZ3NFbGVtIC0gVGhlIHBhcmVudCBjb250YWluZXIgZm9yIG91ciBET00gZWxlbWVudHMuXG4gICAgICogQHBhcmFtIHNlY3Rpb25IZWFkaW5nIC0gVGhlIGhlYWRpbmcgZWxlbWVudCB0byBnbyBpbnRvIHRoZSBzZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSBjb25zdHJ1Y3RlZCBET00gZWxlbWVudCBmb3IgdGhlIHNlY3Rpb24uXG4gICAgICovXG4gICAgYnVpbGRTZWN0aW9uV2l0aEhlYWRpbmcoc2V0dGluZ3NFbGVtLCBzZWN0aW9uSGVhZGluZykge1xuICAgICAgICAvLyBtYWtlIHNlY3Rpb24gZWxlbWVudFxuICAgICAgICBjb25zdCBzZWN0aW9uRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlY3Rpb24nKTtcbiAgICAgICAgc2VjdGlvbkVsZW0uY2xhc3NMaXN0LmFkZCgnc2V0dGluZ3NDb250YWluZXInKTtcbiAgICAgICAgLy8gbWFrZSBzZWN0aW9uIGhlYWRpbmdcbiAgICAgICAgY29uc3QgcHNTZXR0aW5nc0hlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwc1NldHRpbmdzSGVhZGVyLmNsYXNzTGlzdC5hZGQoJ3NldHRpbmdzSGVhZGVyJyk7XG4gICAgICAgIHBzU2V0dGluZ3NIZWFkZXIuY2xhc3NMaXN0LmFkZCgnc2V0dGluZ3MtdGV4dCcpO1xuICAgICAgICBwc1NldHRpbmdzSGVhZGVyLnRleHRDb250ZW50ID0gc2VjdGlvbkhlYWRpbmc7XG4gICAgICAgIC8vIGFkZCBzZWN0aW9uIGFuZCBoZWFkaW5nIHRvIHBhcmVudCBzZXR0aW5ncyBlbGVtZW50XG4gICAgICAgIHNlY3Rpb25FbGVtLmFwcGVuZENoaWxkKHBzU2V0dGluZ3NIZWFkZXIpO1xuICAgICAgICBzZXR0aW5nc0VsZW0uYXBwZW5kQ2hpbGQoc2VjdGlvbkVsZW0pO1xuICAgICAgICByZXR1cm4gc2VjdGlvbkVsZW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHVwIGZsYWdzIHdpdGggdGhlaXIgZGVmYXVsdCB2YWx1ZXMgYW5kIGFkZCB0aGVtIHRvIHRoZSBgQ29uZmlnLmZsYWdzYCBtYXAuXG4gICAgICogQHBhcmFtIHNldHRpbmdzRWxlbSAtIC0gVGhlIGVsZW1lbnQgdGhhdCBjb250YWlucyBhbGwgdGhlIGluZGl2aWR1YWwgc2V0dGluZ3Mgc2VjdGlvbnMsIGZsYWdzLCBhbmQgc28gb24uXG4gICAgICovXG4gICAgcG9wdWxhdGVTZXR0aW5nc0VsZW1lbnQoc2V0dGluZ3NFbGVtLCBzZXR0aW5nc0NvbmZpZykge1xuICAgICAgICBpZiAoaXNTZWN0aW9uRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgU2V0dGluZ3NTZWN0aW9ucy5QaXhlbFN0cmVhbWluZykpIHtcbiAgICAgICAgICAgIC8qIFNldHVwIGFsbCBQaXhlbCBTdHJlYW1pbmcgc3BlY2lmaWMgc2V0dGluZ3MgKi9cbiAgICAgICAgICAgIGNvbnN0IHBzU2V0dGluZ3NTZWN0aW9uID0gdGhpcy5idWlsZFNlY3Rpb25XaXRoSGVhZGluZyhzZXR0aW5nc0VsZW0sIFNldHRpbmdzU2VjdGlvbnMuUGl4ZWxTdHJlYW1pbmcpO1xuICAgICAgICAgICAgLy8gbWFrZSBzZXR0aW5ncyBzaG93IHVwIGluIERPTVxuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIFRleHRQYXJhbWV0ZXJzLlNpZ25hbGxpbmdTZXJ2ZXJVcmwpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ1RleHQocHNTZXR0aW5nc1NlY3Rpb24sIHRoaXMudGV4dFBhcmFtZXRlcnNVaS5nZXQoVGV4dFBhcmFtZXRlcnMuU2lnbmFsbGluZ1NlcnZlclVybCkpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIEZsYWdzLkJyb3dzZXJTZW5kT2ZmZXIpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ0ZsYWcocHNTZXR0aW5nc1NlY3Rpb24sIHRoaXMuZmxhZ3NVaS5nZXQoRmxhZ3MuQnJvd3NlclNlbmRPZmZlcikpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIE9wdGlvblBhcmFtZXRlcnMuU3RyZWFtZXJJZCkpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nT3B0aW9uKHBzU2V0dGluZ3NTZWN0aW9uLCB0aGlzLm9wdGlvblBhcmFtZXRlcnNVaS5nZXQoT3B0aW9uUGFyYW1ldGVycy5TdHJlYW1lcklkKSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgRmxhZ3MuQXV0b0Nvbm5lY3QpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ0ZsYWcocHNTZXR0aW5nc1NlY3Rpb24sIHRoaXMuZmxhZ3NVaS5nZXQoRmxhZ3MuQXV0b0Nvbm5lY3QpKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBGbGFncy5BdXRvUGxheVZpZGVvKSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdGbGFnKHBzU2V0dGluZ3NTZWN0aW9uLCB0aGlzLmZsYWdzVWkuZ2V0KEZsYWdzLkF1dG9QbGF5VmlkZW8pKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBGbGFncy5Vc2VNaWMpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ0ZsYWcocHNTZXR0aW5nc1NlY3Rpb24sIHRoaXMuZmxhZ3NVaS5nZXQoRmxhZ3MuVXNlTWljKSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgRmxhZ3MuVXNlQ2FtZXJhKSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdGbGFnKHBzU2V0dGluZ3NTZWN0aW9uLCB0aGlzLmZsYWdzVWkuZ2V0KEZsYWdzLlVzZUNhbWVyYSkpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIEZsYWdzLlN0YXJ0VmlkZW9NdXRlZCkpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nRmxhZyhwc1NldHRpbmdzU2VjdGlvbiwgdGhpcy5mbGFnc1VpLmdldChGbGFncy5TdGFydFZpZGVvTXV0ZWQpKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBGbGFncy5Jc1F1YWxpdHlDb250cm9sbGVyKSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdGbGFnKHBzU2V0dGluZ3NTZWN0aW9uLCB0aGlzLmZsYWdzVWkuZ2V0KEZsYWdzLklzUXVhbGl0eUNvbnRyb2xsZXIpKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBGbGFncy5Gb3JjZU1vbm9BdWRpbykpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nRmxhZyhwc1NldHRpbmdzU2VjdGlvbiwgdGhpcy5mbGFnc1VpLmdldChGbGFncy5Gb3JjZU1vbm9BdWRpbykpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIEZsYWdzLkZvcmNlVFVSTikpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nRmxhZyhwc1NldHRpbmdzU2VjdGlvbiwgdGhpcy5mbGFnc1VpLmdldChGbGFncy5Gb3JjZVRVUk4pKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBGbGFncy5TdXBwcmVzc0Jyb3dzZXJLZXlzKSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdGbGFnKHBzU2V0dGluZ3NTZWN0aW9uLCB0aGlzLmZsYWdzVWkuZ2V0KEZsYWdzLlN1cHByZXNzQnJvd3NlcktleXMpKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBGbGFncy5BRktEZXRlY3Rpb24pKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ0ZsYWcocHNTZXR0aW5nc1NlY3Rpb24sIHRoaXMuZmxhZ3NVaS5nZXQoRmxhZ3MuQUZLRGV0ZWN0aW9uKSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgRmxhZ3MuV2FpdEZvclN0cmVhbWVyKSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdGbGFnKHBzU2V0dGluZ3NTZWN0aW9uLCB0aGlzLmZsYWdzVWkuZ2V0KEZsYWdzLldhaXRGb3JTdHJlYW1lcikpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIE51bWVyaWNQYXJhbWV0ZXJzLkFGS1RpbWVvdXRTZWNzKSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdOdW1lcmljKHBzU2V0dGluZ3NTZWN0aW9uLCB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzVWkuZ2V0KE51bWVyaWNQYXJhbWV0ZXJzLkFGS1RpbWVvdXRTZWNzKSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgTnVtZXJpY1BhcmFtZXRlcnMuQUZLQ291bnRkb3duU2VjcykpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nTnVtZXJpYyhwc1NldHRpbmdzU2VjdGlvbiwgdGhpcy5udW1lcmljUGFyYW1ldGVyc1VpLmdldChOdW1lcmljUGFyYW1ldGVycy5BRktDb3VudGRvd25TZWNzKSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgTnVtZXJpY1BhcmFtZXRlcnMuTWF4UmVjb25uZWN0QXR0ZW1wdHMpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ051bWVyaWMocHNTZXR0aW5nc1NlY3Rpb24sIHRoaXMubnVtZXJpY1BhcmFtZXRlcnNVaS5nZXQoTnVtZXJpY1BhcmFtZXRlcnMuTWF4UmVjb25uZWN0QXR0ZW1wdHMpKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBOdW1lcmljUGFyYW1ldGVycy5TdHJlYW1lckF1dG9Kb2luSW50ZXJ2YWwpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ051bWVyaWMocHNTZXR0aW5nc1NlY3Rpb24sIHRoaXMubnVtZXJpY1BhcmFtZXRlcnNVaS5nZXQoTnVtZXJpY1BhcmFtZXRlcnMuU3RyZWFtZXJBdXRvSm9pbkludGVydmFsKSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgTnVtZXJpY1BhcmFtZXRlcnMuS2VlcGFsaXZlRGVsYXkpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ051bWVyaWMocHNTZXR0aW5nc1NlY3Rpb24sIHRoaXMubnVtZXJpY1BhcmFtZXRlcnNVaS5nZXQoTnVtZXJpY1BhcmFtZXRlcnMuS2VlcGFsaXZlRGVsYXkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTZWN0aW9uRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgU2V0dGluZ3NTZWN0aW9ucy5VSSkpIHtcbiAgICAgICAgICAgIC8qIFNldHVwIGFsbCB2aWV3L3VpIHJlbGF0ZWQgc2V0dGluZ3MgdW5kZXIgdGhpcyBzZWN0aW9uICovXG4gICAgICAgICAgICBjb25zdCB2aWV3U2V0dGluZ3NTZWN0aW9uID0gdGhpcy5idWlsZFNlY3Rpb25XaXRoSGVhZGluZyhzZXR0aW5nc0VsZW0sIFNldHRpbmdzU2VjdGlvbnMuVUkpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIEZsYWdzLk1hdGNoVmlld3BvcnRSZXNvbHV0aW9uKSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdGbGFnKHZpZXdTZXR0aW5nc1NlY3Rpb24sIHRoaXMuZmxhZ3NVaS5nZXQoRmxhZ3MuTWF0Y2hWaWV3cG9ydFJlc29sdXRpb24pKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBGbGFncy5Ib3ZlcmluZ01vdXNlTW9kZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nRmxhZyh2aWV3U2V0dGluZ3NTZWN0aW9uLCB0aGlzLmZsYWdzVWkuZ2V0KEZsYWdzLkhvdmVyaW5nTW91c2VNb2RlKSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgRXh0cmFGbGFncy5MaWdodE1vZGUpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ0ZsYWcodmlld1NldHRpbmdzU2VjdGlvbiwgdGhpcy5mbGFnc1VpLmdldChFeHRyYUZsYWdzLkxpZ2h0TW9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NlY3Rpb25FbmFibGVkKHNldHRpbmdzQ29uZmlnLCBTZXR0aW5nc1NlY3Rpb25zLklucHV0KSkge1xuICAgICAgICAgICAgLyogU2V0dXAgYWxsIGVuY29kZXIgcmVsYXRlZCBzZXR0aW5ncyB1bmRlciB0aGlzIHNlY3Rpb24gKi9cbiAgICAgICAgICAgIGNvbnN0IGlucHV0U2V0dGluZ3NTZWN0aW9uID0gdGhpcy5idWlsZFNlY3Rpb25XaXRoSGVhZGluZyhzZXR0aW5nc0VsZW0sIFNldHRpbmdzU2VjdGlvbnMuSW5wdXQpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIEZsYWdzLktleWJvYXJkSW5wdXQpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ0ZsYWcoaW5wdXRTZXR0aW5nc1NlY3Rpb24sIHRoaXMuZmxhZ3NVaS5nZXQoRmxhZ3MuS2V5Ym9hcmRJbnB1dCkpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIEZsYWdzLk1vdXNlSW5wdXQpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ0ZsYWcoaW5wdXRTZXR0aW5nc1NlY3Rpb24sIHRoaXMuZmxhZ3NVaS5nZXQoRmxhZ3MuTW91c2VJbnB1dCkpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIEZsYWdzLkZha2VNb3VzZVdpdGhUb3VjaGVzKSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdGbGFnKGlucHV0U2V0dGluZ3NTZWN0aW9uLCB0aGlzLmZsYWdzVWkuZ2V0KEZsYWdzLkZha2VNb3VzZVdpdGhUb3VjaGVzKSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgRmxhZ3MuVG91Y2hJbnB1dCkpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nRmxhZyhpbnB1dFNldHRpbmdzU2VjdGlvbiwgdGhpcy5mbGFnc1VpLmdldChGbGFncy5Ub3VjaElucHV0KSk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgRmxhZ3MuR2FtZXBhZElucHV0KSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdGbGFnKGlucHV0U2V0dGluZ3NTZWN0aW9uLCB0aGlzLmZsYWdzVWkuZ2V0KEZsYWdzLkdhbWVwYWRJbnB1dCkpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIEZsYWdzLlhSQ29udHJvbGxlcklucHV0KSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdGbGFnKGlucHV0U2V0dGluZ3NTZWN0aW9uLCB0aGlzLmZsYWdzVWkuZ2V0KEZsYWdzLlhSQ29udHJvbGxlcklucHV0KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2VjdGlvbkVuYWJsZWQoc2V0dGluZ3NDb25maWcsIFNldHRpbmdzU2VjdGlvbnMuRW5jb2RlcikpIHtcbiAgICAgICAgICAgIC8qIFNldHVwIGFsbCBlbmNvZGVyIHJlbGF0ZWQgc2V0dGluZ3MgdW5kZXIgdGhpcyBzZWN0aW9uICovXG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyU2V0dGluZ3NTZWN0aW9uID0gdGhpcy5idWlsZFNlY3Rpb25XaXRoSGVhZGluZyhzZXR0aW5nc0VsZW0sIFNldHRpbmdzU2VjdGlvbnMuRW5jb2Rlcik7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1pbikpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nTnVtZXJpYyhlbmNvZGVyU2V0dGluZ3NTZWN0aW9uLCB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzVWkuZ2V0KE51bWVyaWNQYXJhbWV0ZXJzLkNvbXBhdFF1YWxpdHlNaW4pKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBOdW1lcmljUGFyYW1ldGVycy5Db21wYXRRdWFsaXR5TWF4KSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdOdW1lcmljKGVuY29kZXJTZXR0aW5nc1NlY3Rpb24sIHRoaXMubnVtZXJpY1BhcmFtZXRlcnNVaS5nZXQoTnVtZXJpY1BhcmFtZXRlcnMuQ29tcGF0UXVhbGl0eU1heCkpO1xuICAgICAgICAgICAgY29uc3QgcHJlZmVycmVkQ29kZWNPcHRpb24gPSB0aGlzLm9wdGlvblBhcmFtZXRlcnNVaS5nZXQoT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRDb2RlYyk7XG4gICAgICAgICAgICBpZiAoaXNTZXR0aW5nRW5hYmxlZChzZXR0aW5nc0NvbmZpZywgT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRDb2RlYykpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTZXR0aW5nT3B0aW9uKGVuY29kZXJTZXR0aW5nc1NlY3Rpb24sIHRoaXMub3B0aW9uUGFyYW1ldGVyc1VpLmdldChPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZENvZGVjKSk7XG4gICAgICAgICAgICBpZiAocHJlZmVycmVkQ29kZWNPcHRpb24gJiZcbiAgICAgICAgICAgICAgICBbLi4ucHJlZmVycmVkQ29kZWNPcHRpb24uc2VsZWN0b3Iub3B0aW9uc11cbiAgICAgICAgICAgICAgICAgICAgLm1hcCgobykgPT4gby52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgLmluY2x1ZGVzKCdPbmx5IGF2YWlsYWJsZSBvbiBDaHJvbWUnKSkge1xuICAgICAgICAgICAgICAgIHByZWZlcnJlZENvZGVjT3B0aW9uLmRpc2FibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBPcHRpb25QYXJhbWV0ZXJzLlByZWZlcnJlZFF1YWxpdHkpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ09wdGlvbihlbmNvZGVyU2V0dGluZ3NTZWN0aW9uLCB0aGlzLm9wdGlvblBhcmFtZXRlcnNVaS5nZXQoT3B0aW9uUGFyYW1ldGVycy5QcmVmZXJyZWRRdWFsaXR5KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2VjdGlvbkVuYWJsZWQoc2V0dGluZ3NDb25maWcsIFNldHRpbmdzU2VjdGlvbnMuV2ViUlRDKSkge1xuICAgICAgICAgICAgLyogU2V0dXAgYWxsIHdlYnJ0YyByZWxhdGVkIHNldHRpbmdzIHVuZGVyIHRoaXMgc2VjdGlvbiAqL1xuICAgICAgICAgICAgY29uc3Qgd2VicnRjU2V0dGluZ3NTZWN0aW9uID0gdGhpcy5idWlsZFNlY3Rpb25XaXRoSGVhZGluZyhzZXR0aW5nc0VsZW0sIFNldHRpbmdzU2VjdGlvbnMuV2ViUlRDKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBOdW1lcmljUGFyYW1ldGVycy5XZWJSVENGUFMpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ051bWVyaWMod2VicnRjU2V0dGluZ3NTZWN0aW9uLCB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzVWkuZ2V0KE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ0ZQUykpO1xuICAgICAgICAgICAgaWYgKGlzU2V0dGluZ0VuYWJsZWQoc2V0dGluZ3NDb25maWcsIE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01pbkJpdHJhdGUpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2V0dGluZ051bWVyaWMod2VicnRjU2V0dGluZ3NTZWN0aW9uLCB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzVWkuZ2V0KE51bWVyaWNQYXJhbWV0ZXJzLldlYlJUQ01pbkJpdHJhdGUpKTtcbiAgICAgICAgICAgIGlmIChpc1NldHRpbmdFbmFibGVkKHNldHRpbmdzQ29uZmlnLCBOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNYXhCaXRyYXRlKSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNldHRpbmdOdW1lcmljKHdlYnJ0Y1NldHRpbmdzU2VjdGlvbiwgdGhpcy5udW1lcmljUGFyYW1ldGVyc1VpLmdldChOdW1lcmljUGFyYW1ldGVycy5XZWJSVENNYXhCaXRyYXRlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgU2V0dGluZ1RleHQgZWxlbWVudCB0byBhIHBhcnRpY3VsYXIgc2V0dGluZ3Mgc2VjdGlvbiBpbiB0aGUgRE9NIGFuZCByZWdpc3RlcnMgdGhhdCB0ZXh0IGluIHRoZSB0ZXh0IHNldHRpbmdzIG1hcC5cbiAgICAgKiBAcGFyYW0gc2V0dGluZ3NTZWN0aW9uIC0gVGhlIHNldHRpbmdzIHNlY3Rpb24gSFRNTCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSBzZXR0aW5nVGV4dCAtIFRoZSB0ZXh0dWFsIHNldHRpbmdzIG9iamVjdC5cbiAgICAgKi9cbiAgICBhZGRTZXR0aW5nVGV4dChzZXR0aW5nc1NlY3Rpb24sIHNldHRpbmdUZXh0KSB7XG4gICAgICAgIGlmIChzZXR0aW5nVGV4dCkge1xuICAgICAgICAgICAgc2V0dGluZ3NTZWN0aW9uLmFwcGVuZENoaWxkKHNldHRpbmdUZXh0LnJvb3RFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMudGV4dFBhcmFtZXRlcnNVaS5zZXQoc2V0dGluZ1RleHQuc2V0dGluZy5pZCwgc2V0dGluZ1RleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIFNldHRpbmdGbGFnIGVsZW1lbnQgdG8gYSBwYXJ0aWN1bGFyIHNldHRpbmdzIHNlY3Rpb24gaW4gdGhlIERPTSBhbmQgcmVnaXN0ZXJzIHRoYXQgZmxhZyBpbiB0aGUgQ29uZmlnLmZsYWcgbWFwLlxuICAgICAqIEBwYXJhbSBzZXR0aW5nc1NlY3Rpb24gLSBUaGUgc2V0dGluZ3Mgc2VjdGlvbiBIVE1MIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHNldHRpbmdGbGFnIC0gVGhlIHNldHRpbmdzIGZsYWcgb2JqZWN0LlxuICAgICAqL1xuICAgIGFkZFNldHRpbmdGbGFnKHNldHRpbmdzU2VjdGlvbiwgc2V0dGluZ0ZsYWcpIHtcbiAgICAgICAgaWYgKHNldHRpbmdGbGFnKSB7XG4gICAgICAgICAgICBzZXR0aW5nc1NlY3Rpb24uYXBwZW5kQ2hpbGQoc2V0dGluZ0ZsYWcucm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5mbGFnc1VpLnNldChzZXR0aW5nRmxhZy5zZXR0aW5nLmlkLCBzZXR0aW5nRmxhZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbnVtZXJpYyBzZXR0aW5nIGVsZW1lbnQgdG8gYSBwYXJ0aWN1bGFyIHNldHRpbmdzIHNlY3Rpb24gaW4gdGhlIERPTSBhbmQgcmVnaXN0ZXJzIHRoYXQgZmxhZyBpbiB0aGUgQ29uZmlnLm51bWVyaWNQYXJhbWV0ZXJzIG1hcC5cbiAgICAgKiBAcGFyYW0gc2V0dGluZ3NTZWN0aW9uIC0gVGhlIHNldHRpbmdzIHNlY3Rpb24gSFRNTCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSBzZXR0aW5nRmxhZyAtIFRoZSBzZXR0aW5ncyBmbGFnIG9iamVjdC5cbiAgICAgKi9cbiAgICBhZGRTZXR0aW5nTnVtZXJpYyhzZXR0aW5nc1NlY3Rpb24sIHNldHRpbmcpIHtcbiAgICAgICAgaWYgKHNldHRpbmcpIHtcbiAgICAgICAgICAgIHNldHRpbmdzU2VjdGlvbi5hcHBlbmRDaGlsZChzZXR0aW5nLnJvb3RFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMubnVtZXJpY1BhcmFtZXRlcnNVaS5zZXQoc2V0dGluZy5zZXR0aW5nLmlkLCBzZXR0aW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZW51bSBiYXNlZCBzZXR0aW5ncyBlbGVtZW50IHRvIGEgcGFydGljdWxhciBzZXR0aW5ncyBzZWN0aW9uIGluIHRoZSBET00gYW5kIHJlZ2lzdGVycyB0aGF0IGZsYWcgaW4gdGhlIENvbmZpZy5lbnVtUGFyYW1ldGVycyBtYXAuXG4gICAgICogQHBhcmFtIHNldHRpbmdzU2VjdGlvbiAtIFRoZSBzZXR0aW5ncyBzZWN0aW9uIEhUTUwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gc2V0dGluZ0ZsYWcgLSBUaGUgc2V0dGluZ3MgZmxhZyBvYmplY3QuXG4gICAgICovXG4gICAgYWRkU2V0dGluZ09wdGlvbihzZXR0aW5nc1NlY3Rpb24sIHNldHRpbmcpIHtcbiAgICAgICAgaWYgKHNldHRpbmcpIHtcbiAgICAgICAgICAgIHNldHRpbmdzU2VjdGlvbi5hcHBlbmRDaGlsZChzZXR0aW5nLnJvb3RFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uUGFyYW1ldGVyc1VpLnNldChzZXR0aW5nLnNldHRpbmcuaWQsIHNldHRpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uU2V0dGluZ3NDaGFuZ2VkKHsgZGF0YTogeyBpZCwgdGFyZ2V0LCB0eXBlIH0gfSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2ZsYWcnKSB7XG4gICAgICAgICAgICBjb25zdCBfaWQgPSBpZDtcbiAgICAgICAgICAgIGNvbnN0IF90YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nID0gdGhpcy5mbGFnc1VpLmdldChfaWQpO1xuICAgICAgICAgICAgaWYgKHNldHRpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZy5mbGFnICE9PSBfdGFyZ2V0LmZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZy5mbGFnID0gX3RhcmdldC5mbGFnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZy5sYWJlbCAhPT0gX3RhcmdldC5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nLmxhYmVsID0gX3RhcmdldC5sYWJlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IF9pZCA9IGlkO1xuICAgICAgICAgICAgY29uc3QgX3RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmcgPSB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzVWkuZ2V0KF9pZCk7XG4gICAgICAgICAgICBpZiAoc2V0dGluZykge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nLm51bWJlciAhPT0gX3RhcmdldC5udW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZy5udW1iZXIgPSBfdGFyZ2V0Lm51bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmcubGFiZWwgIT09IF90YXJnZXQubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZy5sYWJlbCA9IF90YXJnZXQubGFiZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgY29uc3QgX2lkID0gaWQ7XG4gICAgICAgICAgICBjb25zdCBfdGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZyA9IHRoaXMudGV4dFBhcmFtZXRlcnNVaS5nZXQoX2lkKTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmcudGV4dCAhPT0gX3RhcmdldC50ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmcudGV4dCA9IF90YXJnZXQudGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmcubGFiZWwgIT09IF90YXJnZXQubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZy5sYWJlbCA9IF90YXJnZXQubGFiZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdvcHRpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBfaWQgPSBpZDtcbiAgICAgICAgICAgIGNvbnN0IF90YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nID0gdGhpcy5vcHRpb25QYXJhbWV0ZXJzVWkuZ2V0KF9pZCk7XG4gICAgICAgICAgICBpZiAoc2V0dGluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVpT3B0aW9ucyA9IHNldHRpbmcub3B0aW9ucztcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRPcHRpb25zID0gX3RhcmdldC5vcHRpb25zO1xuICAgICAgICAgICAgICAgIGlmICh1aU9wdGlvbnMubGVuZ3RoICE9PSB0YXJnZXRPcHRpb25zLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICAgICAhdWlPcHRpb25zLmV2ZXJ5KCh2YWx1ZSkgPT4gdGFyZ2V0T3B0aW9ucy5pbmNsdWRlcyh2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmcub3B0aW9ucyA9IF90YXJnZXQub3B0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmcuc2VsZWN0ZWQgIT09IF90YXJnZXQuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZy5zZWxlY3RlZCA9IF90YXJnZXQuc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nLmxhYmVsICE9PSBfdGFyZ2V0LmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmcubGFiZWwgPSBfdGFyZ2V0LmxhYmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjYWxsYmFjayB0byBmaXJlIHdoZW4gdGhlIGZsYWcgaXMgdG9nZ2xlZC5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGZsYWcuXG4gICAgICogQHBhcmFtIG9uQ2hhbmdlTGlzdGVuZXIgLSBUaGUgY2FsbGJhY2sgdG8gZmlyZSB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIGFkZEN1c3RvbUZsYWdPblNldHRpbmdDaGFuZ2VkTGlzdGVuZXIoaWQsIG9uQ2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tRmxhZ3MuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5jdXN0b21GbGFncy5nZXQoaWQpLm9uQ2hhbmdlID0gb25DaGFuZ2VMaXN0ZW5lcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxhYmVsIGZvciB0aGUgZmxhZy5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGZsYWcuXG4gICAgICogQHBhcmFtIGxhYmVsIC0gVGhlIG5ldyBsYWJlbCB0byB1c2UgZm9yIHRoZSBmbGFnLlxuICAgICAqL1xuICAgIHNldEN1c3RvbUZsYWdMYWJlbChpZCwgbGFiZWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1c3RvbUZsYWdzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIExvZ2dlci5XYXJuaW5nKGBDYW5ub3Qgc2V0IGxhYmVsIGZvciBmbGFnIGNhbGxlZCAke2lkfSAtIGl0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBDb25maWcuZmxhZ3MgbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXN0b21GbGFncy5nZXQoaWQpLmxhYmVsID0gbGFiZWw7XG4gICAgICAgICAgICB0aGlzLmZsYWdzVWkuZ2V0KGlkKS5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGNvbmZpZ3VyYXRpb24gZmxhZyB3aGljaCBoYXMgdGhlIGdpdmVuIGlkLlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSB1bmlxdWUgaWQgZm9yIHRoZSBmbGFnLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGZsYWcgaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBpc0N1c3RvbUZsYWdFbmFibGVkKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1c3RvbUZsYWdzLmdldChpZCkuZmxhZztcbiAgICB9XG4gICAgZGlzYWJsZVNldHRpbmcoaWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBpZiAoaXNGbGFnSWQoaWQpKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmZsYWdzVWkuZ2V0KGlkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2FibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc051bWVyaWNJZChpZCkpIHtcbiAgICAgICAgICAgIChfYiA9IHRoaXMubnVtZXJpY1BhcmFtZXRlcnNVaS5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzYWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVGV4dElkKGlkKSkge1xuICAgICAgICAgICAgKF9jID0gdGhpcy50ZXh0UGFyYW1ldGVyc1VpLmdldChpZCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kaXNhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPcHRpb25JZChpZCkpIHtcbiAgICAgICAgICAgIChfZCA9IHRoaXMub3B0aW9uUGFyYW1ldGVyc1VpLmdldChpZCkpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5kaXNhYmxlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5hYmxlU2V0dGluZyhpZCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmIChpc0ZsYWdJZChpZCkpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuZmxhZ3NVaS5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5hYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOdW1lcmljSWQoaWQpKSB7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLm51bWVyaWNQYXJhbWV0ZXJzVWkuZ2V0KGlkKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVuYWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVGV4dElkKGlkKSkge1xuICAgICAgICAgICAgKF9jID0gdGhpcy50ZXh0UGFyYW1ldGVyc1VpLmdldChpZCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5lbmFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09wdGlvbklkKGlkKSkge1xuICAgICAgICAgICAgKF9kID0gdGhpcy5vcHRpb25QYXJhbWV0ZXJzVWkuZ2V0KGlkKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmVuYWJsZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29uZmlnVUkuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYSBzZXR0aW5nIHRoYXQgaGFzIGEgdGV4dCBsYWJlbCwgYW4gYXJiaXRyYXJ5IHNldHRpbmcgdmFsdWUgaXQgc3RvcmVzLCBhbiBhIEhUTUwgZWxlbWVudCB0aGF0IHJlcHJlc2VudHMgdGhpcyBzZXR0aW5nLlxuICovXG5leHBvcnQgY2xhc3MgU2V0dGluZ1VJQmFzZSB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZykge1xuICAgICAgICB0aGlzLl9zZXR0aW5nID0gc2V0dGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIHNldHRpbmcgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGdldCBzZXR0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgUmV0dXJuIG9yIGNyZWF0ZXMgYSBIVE1MIGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIHRoaXMgc2V0dGluZyBpbiB0aGUgRE9NLlxuICAgICAqL1xuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2V0dGluZ1VJQmFzZS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgU2V0dGluZ1VJQmFzZSB9IGZyb20gJy4vU2V0dGluZ1VJQmFzZSc7XG5leHBvcnQgY2xhc3MgU2V0dGluZ1VJRmxhZyBleHRlbmRzIFNldHRpbmdVSUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmcpIHtcbiAgICAgICAgc3VwZXIoc2V0dGluZyk7XG4gICAgICAgIHRoaXMubGFiZWwgPSBzZXR0aW5nLmxhYmVsO1xuICAgICAgICB0aGlzLmZsYWcgPSBzZXR0aW5nLmZsYWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBzZXR0aW5nIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBnZXQgc2V0dGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmc7XG4gICAgfVxuICAgIGdldCBzZXR0aW5nc1RleHRFbGVtKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3NldHRpbmdzVGV4dEVsZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzVGV4dEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzVGV4dEVsZW0uaW5uZXJUZXh0ID0gdGhpcy5zZXR0aW5nLl9sYWJlbDtcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzVGV4dEVsZW0udGl0bGUgPSB0aGlzLnNldHRpbmcuZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzVGV4dEVsZW07XG4gICAgfVxuICAgIGdldCBjaGVja2JveCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja2JveCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tib3gudHlwZSA9ICdjaGVja2JveCc7XG4gICAgICAgICAgICAvLyBCbG9jayBrZXlwcmVzcy91cC9kb3duIHByb3BvZ2F0aW9uIGZyb20gdGV4dCBmaWVsZCB0eXBpbmcgZ29pbmcgdG8gVUVcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja2JveDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgUmV0dXJuIG9yIGNyZWF0ZXMgYSBIVE1MIGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIHRoaXMgc2V0dGluZyBpbiB0aGUgRE9NLlxuICAgICAqL1xuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIHJvb3QgZGl2IHdpdGggXCJzZXR0aW5nXCIgY3NzIGNsYXNzXG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuaWQgPSB0aGlzLnNldHRpbmcuaWQ7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzZXR0aW5nJyk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgZGl2IGVsZW1lbnQgdG8gY29udGFpbiBvdXIgc2V0dGluZydzIHRleHRcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc2V0dGluZ3NUZXh0RWxlbSk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgbGFiZWwgZWxlbWVudCB0byB3cmFwIG91dCBpbnB1dCB0eXBlXG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgd3JhcHBlckxhYmVsLmNsYXNzTGlzdC5hZGQoJ3RnbC1zd2l0Y2gnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHdyYXBwZXJMYWJlbCk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgaW5wdXQgdHlwZT1jaGVja2JveFxuICAgICAgICAgICAgdGhpcy5jaGVja2JveC50aXRsZSA9IHRoaXMuc2V0dGluZy5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tib3guY2xhc3NMaXN0LmFkZCgndGdsJyk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrYm94LmNsYXNzTGlzdC5hZGQoJ3RnbC1mbGF0Jyk7XG4gICAgICAgICAgICBjb25zdCBzbGlkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHNsaWRlci5jbGFzc0xpc3QuYWRkKCd0Z2wtc2xpZGVyJyk7XG4gICAgICAgICAgICB3cmFwcGVyTGFiZWwuYXBwZW5kQ2hpbGQodGhpcy5jaGVja2JveCk7XG4gICAgICAgICAgICB3cmFwcGVyTGFiZWwuYXBwZW5kQ2hpbGQoc2xpZGVyKTtcbiAgICAgICAgICAgIC8vIHNldHVwIG9uIGNoYW5nZSBmcm9tIGNoZWNrYm94XG4gICAgICAgICAgICB0aGlzLmNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5nLmZsYWcgIT09IHRoaXMuY2hlY2tib3guY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmcuZmxhZyA9IHRoaXMuY2hlY2tib3guY2hlY2tlZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nLnVwZGF0ZVVSTFBhcmFtcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290RWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzZXR0aW5nJ3Mgc3RvcmVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSBpblZhbHVlIC0gVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHNldHRpbmcuXG4gICAgICovXG4gICAgc2V0IGZsYWcoaW5WYWx1ZSkge1xuICAgICAgICB0aGlzLmNoZWNrYm94LmNoZWNrZWQgPSBpblZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdmFsdWVcbiAgICAgKi9cbiAgICBnZXQgZmxhZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tib3guY2hlY2tlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsYWJlbCB0ZXh0IGZvciB0aGUgc2V0dGluZy5cbiAgICAgKiBAcGFyYW0gbGFiZWwgLSBzZXR0aW5nIGxhYmVsLlxuICAgICAqL1xuICAgIHNldCBsYWJlbChpbkxhYmVsKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NUZXh0RWxlbS5pbm5lclRleHQgPSBpbkxhYmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgbGFiZWxcbiAgICAgKi9cbiAgICBnZXQgbGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzVGV4dEVsZW0uaW5uZXJUZXh0O1xuICAgIH1cbiAgICBkaXNhYmxlKCkge1xuICAgICAgICB0aGlzLmNoZWNrYm94LmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZW5hYmxlKCkge1xuICAgICAgICB0aGlzLmNoZWNrYm94LmRpc2FibGVkID0gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2V0dGluZ1VJRmxhZy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdmcm9udGVuZC11ZTUuNic7XG5pbXBvcnQgeyBTZXR0aW5nVUlCYXNlIH0gZnJvbSAnLi9TZXR0aW5nVUlCYXNlJztcbi8qKlxuICogQSBudW1iZXIgc3Bpbm5lciB3aXRoIGEgdGV4dCBsYWJlbCBiZXNpZGUgaXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXR0aW5nVUlOdW1iZXIgZXh0ZW5kcyBTZXR0aW5nVUlCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5nKSB7XG4gICAgICAgIHN1cGVyKHNldHRpbmcpO1xuICAgICAgICB0aGlzLmxhYmVsID0gdGhpcy5zZXR0aW5nLmxhYmVsO1xuICAgICAgICB0aGlzLm51bWJlciA9IHRoaXMuc2V0dGluZy5udW1iZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBzZXR0aW5nIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBnZXQgc2V0dGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmc7XG4gICAgfVxuICAgIGdldCBzZXR0aW5nc1RleHRFbGVtKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3NldHRpbmdzVGV4dEVsZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzVGV4dEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NUZXh0RWxlbS5pbm5lclRleHQgPSB0aGlzLnNldHRpbmcubGFiZWw7XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5nc1RleHRFbGVtLnRpdGxlID0gdGhpcy5zZXR0aW5nLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5nc1RleHRFbGVtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEhUTUxJbnB1dEVsZW1lbnQgZm9yIHRoZSBidXR0b24uXG4gICAgICovXG4gICAgZ2V0IHNwaW5uZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3Bpbm5lcikge1xuICAgICAgICAgICAgdGhpcy5fc3Bpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICB0aGlzLl9zcGlubmVyLnR5cGUgPSAnbnVtYmVyJztcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmcubWluICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlubmVyLm1pbiA9IHRoaXMuc2V0dGluZy5taW4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmcubWF4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlubmVyLm1heCA9IHRoaXMuc2V0dGluZy5tYXgudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NwaW5uZXIudmFsdWUgPSB0aGlzLnNldHRpbmcubnVtYmVyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLl9zcGlubmVyLnRpdGxlID0gdGhpcy5zZXR0aW5nLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgdGhpcy5fc3Bpbm5lci5jbGFzc0xpc3QuYWRkKCdmb3JtLWNvbnRyb2wnKTtcbiAgICAgICAgICAgIC8vIEJsb2NrIGtleXByZXNzL3VwL2Rvd24gcHJvcG9nYXRpb24gZnJvbSB0ZXh0IGZpZWxkIHR5cGluZyBnb2luZyB0byBVRVxuICAgICAgICAgICAgdGhpcy5zcGlubmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3Bpbm5lci5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNwaW5uZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NwaW5uZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFJldHVybiBvciBjcmVhdGVzIGEgSFRNTCBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyB0aGlzIHNldHRpbmcgaW4gdGhlIERPTS5cbiAgICAgKi9cbiAgICBnZXQgcm9vdEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSByb290IGRpdiB3aXRoIFwic2V0dGluZ1wiIGNzcyBjbGFzc1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3NldHRpbmcnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2Zvcm0tZ3JvdXAnKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBkaXYgZWxlbWVudCB0byBjb250YWluIG91ciBzZXR0aW5nJ3MgdGV4dFxuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zZXR0aW5nc1RleHRFbGVtKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBsYWJlbCBlbGVtZW50IHRvIHdyYXAgb3V0IGlucHV0IHR5cGVcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc3Bpbm5lcik7XG4gICAgICAgICAgICAvLyBzZXR1cCBvbmNoYW5nZVxuICAgICAgICAgICAgdGhpcy5zcGlubmVyLm9uY2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXRFbGVtID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gTnVtYmVyLnBhcnNlRmxvYXQoaW5wdXRFbGVtLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHBhcnNlZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuV2FybmluZyhgQ291bGQgbm90IHBhcnNlIHZhbHVlIGNoYW5nZSBpbnRvIGEgdmFsaWQgbnVtYmVyIC0gdmFsdWUgd2FzICR7aW5wdXRFbGVtLnZhbHVlfSwgcmVzZXR0aW5nIHZhbHVlIHRvICR7dGhpcy5zZXR0aW5nLm1pbn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZy5udW1iZXIgIT09IHRoaXMuc2V0dGluZy5taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZy5udW1iZXIgPSB0aGlzLnNldHRpbmcubWluO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5nLm51bWJlciAhPT0gcGFyc2VkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZy5udW1iZXIgPSBwYXJzZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZy51cGRhdGVVUkxQYXJhbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RFbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG51bWJlciBpbiB0aGUgc3Bpbm5lciAod2lsbCBiZSBjbGFtcGVkIHdpdGhpbiByYW5nZSkuXG4gICAgICovXG4gICAgc2V0IG51bWJlcihuZXdOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5zcGlubmVyLnZhbHVlID0gdGhpcy5zZXR0aW5nLmNsYW1wKG5ld051bWJlcikudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlXG4gICAgICovXG4gICAgZ2V0IG51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuICt0aGlzLnNwaW5uZXIudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbGFiZWwgdGV4dCBmb3IgdGhlIHNldHRpbmcuXG4gICAgICogQHBhcmFtIGxhYmVsIC0gc2V0dGluZyBsYWJlbC5cbiAgICAgKi9cbiAgICBzZXQgbGFiZWwoaW5MYWJlbCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzVGV4dEVsZW0uaW5uZXJUZXh0ID0gaW5MYWJlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGxhYmVsXG4gICAgICovXG4gICAgZ2V0IGxhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc1RleHRFbGVtLmlubmVyVGV4dDtcbiAgICB9XG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgdGhpcy5zcGlubmVyLmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZW5hYmxlKCkge1xuICAgICAgICB0aGlzLnNwaW5uZXIuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXR0aW5nVUlOdW1iZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IFNldHRpbmdVSUJhc2UgfSBmcm9tICcuL1NldHRpbmdVSUJhc2UnO1xuZXhwb3J0IGNsYXNzIFNldHRpbmdVSU9wdGlvbiBleHRlbmRzIFNldHRpbmdVSUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmcpIHtcbiAgICAgICAgc3VwZXIoc2V0dGluZyk7XG4gICAgICAgIHRoaXMubGFiZWwgPSB0aGlzLnNldHRpbmcubGFiZWw7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuc2V0dGluZy5vcHRpb25zO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5zZXR0aW5nLnNlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgc2V0dGluZyBjb21wb25lbnQuXG4gICAgICovXG4gICAgZ2V0IHNldHRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5nO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0b3IoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Rvci5jbGFzc0xpc3QuYWRkKCdmb3JtLWNvbnRyb2wnKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdG9yLmNsYXNzTGlzdC5hZGQoJ3NldHRpbmdzLW9wdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RvcjtcbiAgICB9XG4gICAgZ2V0IHNldHRpbmdzVGV4dEVsZW0oKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2V0dGluZ3NUZXh0RWxlbSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NUZXh0RWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NUZXh0RWxlbS5pbm5lclRleHQgPSB0aGlzLnNldHRpbmcubGFiZWw7XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5nc1RleHRFbGVtLnRpdGxlID0gdGhpcy5zZXR0aW5nLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5nc1RleHRFbGVtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxhYmVsIHRleHQgZm9yIHRoZSBzZXR0aW5nLlxuICAgICAqIEBwYXJhbSBsYWJlbCAtIHNldHRpbmcgbGFiZWwuXG4gICAgICovXG4gICAgc2V0IGxhYmVsKGluTGFiZWwpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5nc1RleHRFbGVtLmlubmVyVGV4dCA9IGluTGFiZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBsYWJlbFxuICAgICAqL1xuICAgIGdldCBsYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3NUZXh0RWxlbS5pbm5lclRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFJldHVybiBvciBjcmVhdGVzIGEgSFRNTCBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyB0aGlzIHNldHRpbmcgaW4gdGhlIERPTS5cbiAgICAgKi9cbiAgICBnZXQgcm9vdEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSByb290IGRpdiB3aXRoIFwic2V0dGluZ1wiIGNzcyBjbGFzc1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmlkID0gdGhpcy5zZXR0aW5nLmlkO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2V0dGluZycpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZm9ybS1ncm91cCcpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIGRpdiBlbGVtZW50IHRvIGNvbnRhaW4gb3VyIHNldHRpbmcncyB0ZXh0XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNldHRpbmdzVGV4dEVsZW0pO1xuICAgICAgICAgICAgLy8gY3JlYXRlIGxhYmVsIGVsZW1lbnQgdG8gd3JhcCBvdXQgaW5wdXQgdHlwZVxuICAgICAgICAgICAgY29uc3Qgd3JhcHBlckxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHdyYXBwZXJMYWJlbCk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgc2VsZWN0IGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IudGl0bGUgPSB0aGlzLnNldHRpbmcuZGVzY3JpcHRpb247XG4gICAgICAgICAgICB3cmFwcGVyTGFiZWwuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3Rvcik7XG4gICAgICAgICAgICAvLyBzZXR1cCBvbiBjaGFuZ2UgZnJvbSBzZWxlY3RvclxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rvci5vbmNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5nLnNlbGVjdGVkICE9PSB0aGlzLnNlbGVjdG9yLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZy5zZWxlY3RlZCA9IHRoaXMuc2VsZWN0b3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZy51cGRhdGVVUkxQYXJhbXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQmxvY2sga2V5cHJlc3MvdXAvZG93biBwcm9wb2dhdGlvbiBmcm9tIHRleHQgZmllbGQgdHlwaW5nIGdvaW5nIHRvIFVFXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gICAgfVxuICAgIHNldCBvcHRpb25zKHZhbHVlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zZWxlY3Rvci5vcHRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yLnJlbW92ZShpKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgICAgb3B0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBvcHQuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yLmFwcGVuZENoaWxkKG9wdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLnNlbGVjdG9yLm9wdGlvbnNdLm1hcCgobykgPT4gby52YWx1ZSk7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZCh2YWx1ZSkge1xuICAgICAgICAvLyBBIHVzZXIgbWF5IG5vdCBzcGVjaWZ5IHRoZSBmdWxsIHBvc3NpYmxlIHZhbHVlIHNvIHdlIGluc3RlYWQgdXNlIHRoZSBjbG9zZXN0IG1hdGNoLlxuICAgICAgICAvLyBlZyA/eHh4PUgyNjQgd291bGQgc2VsZWN0ICdIMjY0IGxldmVsLWFzeW1tZXRyeS1hbGxvd2VkPTE7cGFja2V0aXphdGlvbi1tb2RlPTE7cHJvZmlsZS1sZXZlbC1pZD00MjAwMWYnXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkTGlzdCA9IHRoaXMub3B0aW9ucy5maWx0ZXIoKG9wdGlvbikgPT4gb3B0aW9uLmluZGV4T2YodmFsdWUpICE9PSAtMSk7XG4gICAgICAgIGlmIChmaWx0ZXJlZExpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yLnZhbHVlID0gZmlsdGVyZWRMaXN0WzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3IudmFsdWU7XG4gICAgfVxuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IuZGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBlbmFibGUoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXR0aW5nVUlPcHRpb24uanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IFNldHRpbmdVSUJhc2UgfSBmcm9tICcuL1NldHRpbmdVSUJhc2UnO1xuZXhwb3J0IGNsYXNzIFNldHRpbmdVSVRleHQgZXh0ZW5kcyBTZXR0aW5nVUlCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5nKSB7XG4gICAgICAgIHN1cGVyKHNldHRpbmcpO1xuICAgICAgICB0aGlzLmxhYmVsID0gdGhpcy5zZXR0aW5nLmxhYmVsO1xuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnNldHRpbmcudGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIHNldHRpbmcgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGdldCBzZXR0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZztcbiAgICB9XG4gICAgZ2V0IHNldHRpbmdzVGV4dEVsZW0oKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2V0dGluZ3NUZXh0RWxlbSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NUZXh0RWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NUZXh0RWxlbS5pbm5lclRleHQgPSB0aGlzLnNldHRpbmcubGFiZWw7XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5nc1RleHRFbGVtLnRpdGxlID0gdGhpcy5zZXR0aW5nLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5nc1RleHRFbGVtO1xuICAgIH1cbiAgICBnZXQgdGV4dGJveCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0Ym94KSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0Ym94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHRib3guY2xhc3NMaXN0LmFkZCgnZm9ybS1jb250cm9sJyk7XG4gICAgICAgICAgICB0aGlzLl90ZXh0Ym94LnR5cGUgPSAndGV4dGJveCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRib3g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFJldHVybiBvciBjcmVhdGVzIGEgSFRNTCBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyB0aGlzIHNldHRpbmcgaW4gdGhlIERPTS5cbiAgICAgKi9cbiAgICBnZXQgcm9vdEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSByb290IGRpdiB3aXRoIFwic2V0dGluZ1wiIGNzcyBjbGFzc1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmlkID0gdGhpcy5zZXR0aW5nLmlkO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2V0dGluZycpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIGRpdiBlbGVtZW50IHRvIGNvbnRhaW4gb3VyIHNldHRpbmcncyB0ZXh0XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNldHRpbmdzVGV4dEVsZW0pO1xuICAgICAgICAgICAgLy8gY3JlYXRlIGxhYmVsIGVsZW1lbnQgdG8gd3JhcCBvdXQgaW5wdXQgdHlwZVxuICAgICAgICAgICAgY29uc3Qgd3JhcHBlckxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHdyYXBwZXJMYWJlbCk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgaW5wdXQgdHlwZT1jaGVja2JveFxuICAgICAgICAgICAgdGhpcy50ZXh0Ym94LnRpdGxlID0gdGhpcy5zZXR0aW5nLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgd3JhcHBlckxhYmVsLmFwcGVuZENoaWxkKHRoaXMudGV4dGJveCk7XG4gICAgICAgICAgICAvLyBzZXR1cCBvbiBjaGFuZ2UgZnJvbSBjaGVja2JveFxuICAgICAgICAgICAgdGhpcy50ZXh0Ym94LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZy50ZXh0ICE9PSB0aGlzLnRleHRib3gudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nLnRleHQgPSB0aGlzLnRleHRib3gudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZy51cGRhdGVVUkxQYXJhbXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEJsb2NrIGtleXByZXNzL3VwL2Rvd24gcHJvcG9nYXRpb24gZnJvbSB0ZXh0IGZpZWxkIHR5cGluZyBnb2luZyB0byBVRVxuICAgICAgICAgICAgdGhpcy50ZXh0Ym94LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudGV4dGJveC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRleHRib3guYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RFbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHNldHRpbmcncyBzdG9yZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIGluVmFsdWUgLSBUaGUgbmV3IHZhbHVlIGZvciB0aGUgc2V0dGluZy5cbiAgICAgKi9cbiAgICBzZXQgdGV4dChpblZhbHVlKSB7XG4gICAgICAgIHRoaXMudGV4dGJveC52YWx1ZSA9IGluVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB2YWx1ZVxuICAgICAqL1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0Ym94LnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxhYmVsIHRleHQgZm9yIHRoZSBzZXR0aW5nLlxuICAgICAqIEBwYXJhbSBsYWJlbCAtIHNldHRpbmcgbGFiZWwuXG4gICAgICovXG4gICAgc2V0IGxhYmVsKGluTGFiZWwpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5nc1RleHRFbGVtLmlubmVyVGV4dCA9IGluTGFiZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBsYWJlbFxuICAgICAqL1xuICAgIGdldCBsYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3NUZXh0RWxlbS5pbm5lclRleHQ7XG4gICAgfVxuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIHRoaXMudGV4dGJveC5kaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgdGhpcy50ZXh0Ym94LmRpc2FibGVkID0gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2V0dGluZ1VJVGV4dC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgQWN0aW9uT3ZlcmxheSB9IGZyb20gJy4vQWN0aW9uT3ZlcmxheSc7XG4vKipcbiAqIFNob3cgYW4gb3ZlcmxheSBmb3Igd2hlbiB0aGUgc2Vzc2lvbiBpcyB1bmF0dGVuZGVkLCBpdCBiZWdpbnMgYSBjb3VudGRvd24gdGltZXIsIHdoaWNoIHdoZW4gZWxhcHNlZCB3aWxsIGRpc2Nvbm5lY3QgdGhlIHN0cmVhbS5cbiAqL1xuZXhwb3J0IGNsYXNzIEFGS092ZXJsYXkgZXh0ZW5kcyBBY3Rpb25PdmVybGF5IHtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCByb290IGVsZW1lbnQgb2YgdGhpcyBvdmVybGF5LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSb290RWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgYWZrT3ZlcmxheUh0bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYWZrT3ZlcmxheUh0bWwuaWQgPSAnYWZrT3ZlcmxheSc7XG4gICAgICAgIGFma092ZXJsYXlIdG1sLmNsYXNzTmFtZSA9ICdjbGlja2FibGVTdGF0ZSc7XG4gICAgICAgIHJldHVybiBhZmtPdmVybGF5SHRtbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgY29udGVudCBlbGVtZW50IG9mIHRoaXMgb3ZlcmxheSwgd2hpY2ggY29udGFpbiBzb21lIHRleHQgZm9yIGFuIGFmayBjb3VudCBkb3duLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVDb250ZW50RWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgYWZrT3ZlcmxheUh0bWxJbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBhZmtPdmVybGF5SHRtbElubmVyLmlkID0gJ2Fma092ZXJsYXlJbm5lcic7XG4gICAgICAgIGFma092ZXJsYXlIdG1sSW5uZXIuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICc8Y2VudGVyPk5vIGFjdGl2aXR5IGRldGVjdGVkPGJyPkRpc2Nvbm5lY3RpbmcgaW4gPHNwYW4gaWQ9XCJhZmtDb3VudERvd25OdW1iZXJcIj48L3NwYW4+IHNlY29uZHM8YnI+Q2xpY2sgdG8gY29udGludWU8YnI+PC9jZW50ZXI+JztcbiAgICAgICAgcmV0dXJuIGFma092ZXJsYXlIdG1sSW5uZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiBBZmsgb3ZlcmxheVxuICAgICAqIEBwYXJhbSBwYXJlbnRFbGVtZW50IC0gdGhlIGVsZW1lbnQgdGhpcyBvdmVybGF5IHdpbGwgYmUgaW5zZXJ0ZWQgaW50b1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJvb3REaXYpIHtcbiAgICAgICAgc3VwZXIocm9vdERpdiwgQUZLT3ZlcmxheS5jcmVhdGVSb290RWxlbWVudCgpLCBBRktPdmVybGF5LmNyZWF0ZUNvbnRlbnRFbGVtZW50KCkpO1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBjb3VudCBkb3duIHNwYW5zIG51bWJlciBmb3IgdGhlIG92ZXJsYXlcbiAgICAgKiBAcGFyYW0gY291bnRkb3duIC0gdGhlIGNvdW50IGRvd24gbnVtYmVyIHRvIGJlIGluc2VydGVkIGludG8gdGhlIHNwYW4gZm9yIHVwZGF0aW5nXG4gICAgICovXG4gICAgdXBkYXRlQ291bnRkb3duKGNvdW50ZG93bikge1xuICAgICAgICB0aGlzLnRleHRFbGVtZW50LmlubmVySFRNTCA9IGA8Y2VudGVyPk5vIGFjdGl2aXR5IGRldGVjdGVkPGJyPkRpc2Nvbm5lY3RpbmcgaW4gPHNwYW4gaWQ9XCJhZmtDb3VudERvd25OdW1iZXJcIj4ke2NvdW50ZG93bn08L3NwYW4+IHNlY29uZHM8YnI+Q2xpY2sgdG8gY29udGludWU8YnI+PC9jZW50ZXI+YDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BRktPdmVybGF5LmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2Zyb250ZW5kLXVlNS42JztcbmltcG9ydCB7IE92ZXJsYXlCYXNlIH0gZnJvbSAnLi9CYXNlT3ZlcmxheSc7XG4vKipcbiAqIENsYXNzIGZvciB0aGUgYmFzZSBhY3Rpb24gb3ZlcmxheSBzdHJ1Y3R1cmVcbiAqL1xuZXhwb3J0IGNsYXNzIEFjdGlvbk92ZXJsYXkgZXh0ZW5kcyBPdmVybGF5QmFzZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGFuIGFjdGlvbiBvdmVybGF5XG4gICAgICogQHBhcmFtIHJvb3REaXYgLSB0aGUgcm9vdCBlbGVtZW50IHRoaXMgb3ZlcmxheSB3aWxsIGJlIGluc2VydGVkIGludG9cbiAgICAgKiBAcGFyYW0gcm9vdEVsZW1lbnQgLSB0aGUgcm9vdCBlbGVtZW50IHRoYXQgaXMgdGhlIG92ZXJsYXlcbiAgICAgKiBAcGFyYW0gY29udGVudEVsZW1lbnQgLSBhbiBlbGVtZW50IHRoYXQgY29udGFpbnMgdGV4dCBmb3IgdGhlIGFjdGlvbiBvdmVybGF5XG4gICAgICovXG4gICAgY29uc3RydWN0b3Iocm9vdERpdiwgcm9vdEVsZW1lbnQsIGNvbnRlbnRFbGVtZW50KSB7XG4gICAgICAgIHN1cGVyKHJvb3REaXYsIHJvb3RFbGVtZW50LCBjb250ZW50RWxlbWVudCk7XG4gICAgICAgIHRoaXMub25BY3Rpb25DYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIC8qIGRvIG5vdGhpbmcgKi8gTG9nZ2VyLkluZm8oJ0RpZCB5b3UgZm9yZ2V0IHRvIHNldCB0aGUgb25BY3Rpb24gY2FsbGJhY2sgaW4geW91ciBvdmVybGF5PycpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHRleHQgb3ZlcmxheXMgaW5uZXIgdGV4dFxuICAgICAqIEBwYXJhbSB0ZXh0IC0gdGhlIHVwZGF0ZSB0ZXh0IHRvIGJlIGluc2VydGVkIGludG8gdGhlIG92ZXJsYXlcbiAgICAgKi9cbiAgICB1cGRhdGUodGV4dCkge1xuICAgICAgICBpZiAodGV4dCAhPSBudWxsIHx8IHRleHQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnRleHRFbGVtZW50LmlubmVySFRNTCA9IHRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgbWV0aG9kIGFzIGFuIGV2ZW50IGVtaXR0ZXIgY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0gY2FsbEJhY2sgLSB0aGUgbWV0aG9kIHRoYXQgaXMgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWRcbiAgICAgKi9cbiAgICBvbkFjdGlvbihjYWxsQmFjaykge1xuICAgICAgICB0aGlzLm9uQWN0aW9uQ2FsbGJhY2sgPSBjYWxsQmFjaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGUgYW4gZXZlbnQgdGhhdCBpcyBhdHRhY2hlZCB0byB0aGUgZXZlbnQgZW1pdHRlclxuICAgICAqL1xuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICB0aGlzLm9uQWN0aW9uQ2FsbGJhY2soKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY3Rpb25PdmVybGF5LmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIENsYXNzIGZvciB0aGUgYmFzZSBvdmVybGF5IHN0cnVjdHVyZVxuICovXG5leHBvcnQgY2xhc3MgT3ZlcmxheUJhc2Uge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiBvdmVybGF5XG4gICAgICogQHBhcmFtIHJvb3REaXYgLSB0aGUgcm9vdCBlbGVtZW50IHRoaXMgb3ZlcmxheSB3aWxsIGJlIGluc2VydGVkIGludG9cbiAgICAgKiBAcGFyYW0gcm9vdEVsZW1lbnQgLSB0aGUgcm9vdCBlbGVtZW50IHRoYXQgaXMgdGhlIG92ZXJsYXlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihyb290RGl2LCByb290RWxlbWVudCwgdGV4dEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5yb290RGl2ID0gcm9vdERpdjtcbiAgICAgICAgdGhpcy5yb290RWxlbWVudCA9IHJvb3RFbGVtZW50O1xuICAgICAgICB0aGlzLnRleHRFbGVtZW50ID0gdGV4dEVsZW1lbnQ7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy50ZXh0RWxlbWVudCk7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB0aGlzLnJvb3REaXYuYXBwZW5kQ2hpbGQodGhpcy5yb290RWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIG92ZXJsYXlcbiAgICAgKi9cbiAgICBzaG93KCkge1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlblN0YXRlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGUgdGhlIG92ZXJsYXlcbiAgICAgKi9cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2hpZGRlblN0YXRlJyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZU92ZXJsYXkuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IEFjdGlvbk92ZXJsYXkgfSBmcm9tICcuL0FjdGlvbk92ZXJsYXknO1xuLyoqXG4gKiBPdmVybGF5IHNob3duIGR1cmluZyBjb25uZWN0aW9uLCBoYXMgYSBidXR0b24gdGhhdCBjYW4gYmUgY2xpY2tlZCB0byBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25uZWN0T3ZlcmxheSBleHRlbmRzIEFjdGlvbk92ZXJsYXkge1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHJvb3QgZWxlbWVudCBvZiB0aGlzIG92ZXJsYXkuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVJvb3RFbGVtZW50KCkge1xuICAgICAgICBjb25zdCBjb25uZWN0RWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb25uZWN0RWxlbS5pZCA9ICdjb25uZWN0T3ZlcmxheSc7XG4gICAgICAgIGNvbm5lY3RFbGVtLmNsYXNzTmFtZSA9ICdjbGlja2FibGVTdGF0ZSc7XG4gICAgICAgIHJldHVybiBjb25uZWN0RWxlbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgY29udGVudCBlbGVtZW50IG9mIHRoaXMgb3ZlcmxheSwgd2hpY2ggY29udGFpbiB3aGF0ZXZlciBjb250ZW50IHRoaXMgZWxlbWVudCBjb250YWlucywgbGlrZSB0ZXh0IG9yIGEgYnV0dG9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVDb250ZW50RWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdENvbnRlbnRFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbm5lY3RDb250ZW50RWxlbS5pZCA9ICdjb25uZWN0QnV0dG9uJztcbiAgICAgICAgY29ubmVjdENvbnRlbnRFbGVtLmlubmVySFRNTCA9ICdDbGljayB0byBzdGFydCc7XG4gICAgICAgIHJldHVybiBjb25uZWN0Q29udGVudEVsZW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIGNvbm5lY3Qgb3ZlcmxheSB3aXRoIGEgY29ubmVjdGlvbiBidXR0b24uXG4gICAgICogQHBhcmFtIHBhcmVudEVsZW0gLSB0aGUgcGFyZW50IGVsZW1lbnQgdGhpcyBvdmVybGF5IHdpbGwgYmUgaW5zZXJ0ZWQgaW50by5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRFbGVtKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudEVsZW0sIENvbm5lY3RPdmVybGF5LmNyZWF0ZVJvb3RFbGVtZW50KCksIENvbm5lY3RPdmVybGF5LmNyZWF0ZUNvbnRlbnRFbGVtZW50KCkpO1xuICAgICAgICAvLyBhZGQgdGhlIG5ldyBldmVudCBsaXN0ZW5lclxuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25uZWN0T3ZlcmxheS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgQWN0aW9uT3ZlcmxheSB9IGZyb20gJy4vQWN0aW9uT3ZlcmxheSc7XG4vKipcbiAqIE92ZXJsYXkgc2hvd24gZHVyaW5nIGRpc2Nvbm5lY3Rpb24sIGhhcyBhIHJlY29ubmVjdGlvbiBlbGVtZW50IHRoYXQgY2FuIGJlIGNsaWNrZWQgdG8gcmVjb25uZWN0LlxuICovXG5leHBvcnQgY2xhc3MgRGlzY29ubmVjdE92ZXJsYXkgZXh0ZW5kcyBBY3Rpb25PdmVybGF5IHtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCByb290IGVsZW1lbnQgb2YgdGhpcyBvdmVybGF5LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSb290RWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgZGlzY29ubmVjdE92ZXJsYXlIdG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRpc2Nvbm5lY3RPdmVybGF5SHRtbC5pZCA9ICdkaXNjb25uZWN0T3ZlcmxheSc7XG4gICAgICAgIGRpc2Nvbm5lY3RPdmVybGF5SHRtbC5jbGFzc05hbWUgPSAnY2xpY2thYmxlU3RhdGUnO1xuICAgICAgICByZXR1cm4gZGlzY29ubmVjdE92ZXJsYXlIdG1sO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBjb250ZW50IGVsZW1lbnQgb2YgdGhpcyBvdmVybGF5LCB3aGljaCBjb250YWluIHdoYXRldmVyIGNvbnRlbnQgdGhpcyBlbGVtZW50IGNvbnRhaW5zLCBsaWtlIHRleHQgb3IgYSBidXR0b24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUNvbnRlbnRFbGVtZW50KCkge1xuICAgICAgICAvLyBidWlsZCB0aGUgaW5uZXIgaHRtbCBjb250YWluZXJcbiAgICAgICAgY29uc3QgZGlzY29ubmVjdE92ZXJsYXlIdG1sQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRpc2Nvbm5lY3RPdmVybGF5SHRtbENvbnRhaW5lci5pZCA9ICdkaXNjb25uZWN0QnV0dG9uJztcbiAgICAgICAgZGlzY29ubmVjdE92ZXJsYXlIdG1sQ29udGFpbmVyLmlubmVySFRNTCA9ICdDbGljayBUbyBSZXN0YXJ0JztcbiAgICAgICAgcmV0dXJuIGRpc2Nvbm5lY3RPdmVybGF5SHRtbENvbnRhaW5lcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgZGlzY29ubmVjdCBvdmVybGF5IHdpdGggYSByZXRyeSBjb25uZWN0aW9uIGljb24uXG4gICAgICogQHBhcmFtIHBhcmVudEVsZW0gLSB0aGUgcGFyZW50IGVsZW1lbnQgdGhpcyBvdmVybGF5IHdpbGwgYmUgaW5zZXJ0ZWQgaW50by5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRFbGVtKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudEVsZW0sIERpc2Nvbm5lY3RPdmVybGF5LmNyZWF0ZVJvb3RFbGVtZW50KCksIERpc2Nvbm5lY3RPdmVybGF5LmNyZWF0ZUNvbnRlbnRFbGVtZW50KCkpO1xuICAgICAgICAvLyBhZGQgdGhlIG5ldyBldmVudCBsaXN0ZW5lclxuICAgICAgICB0aGlzLnJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaXNjb25uZWN0T3ZlcmxheS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgVGV4dE92ZXJsYXkgfSBmcm9tICcuL1RleHRPdmVybGF5Jztcbi8qKlxuICogR2VuZXJpYyBvdmVybGF5IHVzZWQgdG8gc2hvdyB0ZXh0dWFsIGVycm9yIGluZm8gdG8gdGhlIHVzZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvck92ZXJsYXkgZXh0ZW5kcyBUZXh0T3ZlcmxheSB7XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgcm9vdCBlbGVtZW50IG9mIHRoaXMgb3ZlcmxheS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUm9vdEVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IGVycm9yT3ZlcmxheUh0bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZXJyb3JPdmVybGF5SHRtbC5pZCA9ICdlcnJvck92ZXJsYXknO1xuICAgICAgICBlcnJvck92ZXJsYXlIdG1sLmNsYXNzTmFtZSA9ICd0ZXh0RGlzcGxheVN0YXRlJztcbiAgICAgICAgcmV0dXJuIGVycm9yT3ZlcmxheUh0bWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGNvbnRlbnQgZWxlbWVudCBvZiB0aGlzIG92ZXJsYXksIHdoaWNoIGNvbnRhaW4gd2hhdGV2ZXIgY29udGVudCB0aGlzIGVsZW1lbnQgY29udGFpbnMsIGxpa2UgdGV4dCBvciBhIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQ29udGVudEVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IGVycm9yT3ZlcmxheUh0bWxJbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBlcnJvck92ZXJsYXlIdG1sSW5uZXIuaWQgPSAnZXJyb3JPdmVybGF5SW5uZXInO1xuICAgICAgICByZXR1cm4gZXJyb3JPdmVybGF5SHRtbElubmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBjb25uZWN0IG92ZXJsYXkgd2l0aCBhIGNvbm5lY3Rpb24gYnV0dG9uLlxuICAgICAqIEBwYXJhbSBwYXJlbnRFbGVtIC0gdGhlIHBhcmVudCBlbGVtZW50IHRoaXMgb3ZlcmxheSB3aWxsIGJlIGluc2VydGVkIGludG8uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyZW50RWxlbSkge1xuICAgICAgICBzdXBlcihwYXJlbnRFbGVtLCBFcnJvck92ZXJsYXkuY3JlYXRlUm9vdEVsZW1lbnQoKSwgRXJyb3JPdmVybGF5LmNyZWF0ZUNvbnRlbnRFbGVtZW50KCkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVycm9yT3ZlcmxheS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuaW1wb3J0IHsgVGV4dE92ZXJsYXkgfSBmcm9tICcuL1RleHRPdmVybGF5Jztcbi8qKlxuICogR2VuZXJpYyBvdmVybGF5IHVzZWQgdG8gc2hvdyB0ZXh0dWFsIGluZm8gdG8gdGhlIHVzZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmZvT3ZlcmxheSBleHRlbmRzIFRleHRPdmVybGF5IHtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCByb290IGVsZW1lbnQgb2YgdGhpcyBvdmVybGF5LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSb290RWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgaW5mb092ZXJsYXlIdG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGluZm9PdmVybGF5SHRtbC5pZCA9ICdpbmZvT3ZlcmxheSc7XG4gICAgICAgIGluZm9PdmVybGF5SHRtbC5jbGFzc05hbWUgPSAndGV4dERpc3BsYXlTdGF0ZSc7XG4gICAgICAgIHJldHVybiBpbmZvT3ZlcmxheUh0bWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGNvbnRlbnQgZWxlbWVudCBvZiB0aGlzIG92ZXJsYXksIHdoaWNoIGNvbnRhaW4gd2hhdGV2ZXIgY29udGVudCB0aGlzIGVsZW1lbnQgY29udGFpbnMsIGxpa2UgdGV4dCBvciBhIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQ29udGVudEVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IGluZm9PdmVybGF5SHRtbElubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGluZm9PdmVybGF5SHRtbElubmVyLmlkID0gJ21lc3NhZ2VPdmVybGF5SW5uZXInO1xuICAgICAgICByZXR1cm4gaW5mb092ZXJsYXlIdG1sSW5uZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIGNvbm5lY3Qgb3ZlcmxheSB3aXRoIGEgY29ubmVjdGlvbiBidXR0b24uXG4gICAgICogQHBhcmFtIHBhcmVudEVsZW0gLSB0aGUgcGFyZW50IGVsZW1lbnQgdGhpcyBvdmVybGF5IHdpbGwgYmUgaW5zZXJ0ZWQgaW50by5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRFbGVtKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudEVsZW0sIEluZm9PdmVybGF5LmNyZWF0ZVJvb3RFbGVtZW50KCksIEluZm9PdmVybGF5LmNyZWF0ZUNvbnRlbnRFbGVtZW50KCkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUluZm9PdmVybGF5LmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBBY3Rpb25PdmVybGF5IH0gZnJvbSAnLi9BY3Rpb25PdmVybGF5Jztcbi8qKlxuICogT3ZlcmxheSBzaG93biB3aGVuIHN0cmVhbSBpcyByZWFkeSB0byBwbGF5LlxuICovXG5leHBvcnQgY2xhc3MgUGxheU92ZXJsYXkgZXh0ZW5kcyBBY3Rpb25PdmVybGF5IHtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCByb290IGVsZW1lbnQgb2YgdGhpcyBvdmVybGF5LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSb290RWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgcGxheUVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcGxheUVsZW0uaWQgPSAncGxheU92ZXJsYXknO1xuICAgICAgICBwbGF5RWxlbS5jbGFzc05hbWUgPSAnY2xpY2thYmxlU3RhdGUnO1xuICAgICAgICByZXR1cm4gcGxheUVsZW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGNvbnRlbnQgZWxlbWVudCBvZiB0aGlzIG92ZXJsYXksIHdoaWNoIGNvbnRhaW4gd2hhdGV2ZXIgY29udGVudCB0aGlzIGVsZW1lbnQgY29udGFpbnMsIGxpa2UgdGV4dCBvciBhIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQ29udGVudEVsZW1lbnQoKSB7XG4gICAgICAgIC8vIHRvZG86IGNoYW5nZSB0aGlzIHRvIGFuIHN2Z1xuICAgICAgICBjb25zdCBwbGF5T3ZlcmxheUh0bWxJbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICBwbGF5T3ZlcmxheUh0bWxJbm5lci5pZCA9ICdwbGF5QnV0dG9uJztcbiAgICAgICAgcGxheU92ZXJsYXlIdG1sSW5uZXIuc3JjID1cbiAgICAgICAgICAgICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVBFQUFBRDVDQVlBQUFEMm1OTmtBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQVpkRVZZZEZOdlpuUjNZWEpsQUhCaGFXNTBMbTVsZENBMExqQXVNakh4SUdtVkFBQVNna2xFUVZSNFh1MmRDN0JkVlgySHFVQ0NJUkFTQ1BqQUZJUVJFQlJCQlNSWWJGT3Q4bElyRlVXUkZxWFdzVDV3Ykl0VXFGV3MwS3FJTVBLb1lFV3BSUzA2S0RqUzFCZVZGa1ZRYkN3K3dDZmlBd0doQ0tXUDlQdVp0VTI0dVRlNTl6ejIyWS92bS9uR2tYdHo3amxycjkrc2RmWmVhLzAzV2IxNjlRdHhHVzYyaVlpMEQ4TDdOYndZajhFZGNkUHlJeEZwQTRUMlAvRi84VWE4Q0kvR2hQblh5cStJU0pNaHJBbHh4WDloUnVZTDhTaDhTUGsxRVdrcUJIWGRFRmZjZzZ2dzNmaHMzS2I4dW9nMERRSTZYWWdyOHJPdllzSjhPTTR2LzB4RW1rSUo2b2I0UDh6SWZBTmVnQ3ZRTUlzMEJRSzVzUkJYSk15L3dJek01K0J5WEZCZVJrUW1CVUdjYllqWDVTNU1tTS9BQTNDTDhuSWlVamNFY0pBUVY5eUJYOGEvd1NlaXo1aEY2b2JnRFJQaWtHZk1DZk9YOERUY3U3eTBpTlFCb1JzMnhCWC9nM2Rpd3Z3bTNLbjhDUkVaSjRSdFZDR3VxTUtjdTlrbjR4SjA5WmZJdUNCZ293NXh5SjNzVExOekF5d3J3RjZKMjZOaEZoazFCR3NjSVY2WGhQbHV2QTZQeHgzS254YVJVVUNveGgzaWlvUTV6NW4vQlkvRkplVXRpTWd3RUthNlFseVJNTitIbjhIbjRaYmxyWWpJSUJDaXVrTWM4cDI1V3M2Wk1EK3p2QjBSbVNzRWFCSWhua3JldzVWNEVIckNpTWhjS0FGcUN2K05sK0ordUJDOW15MnlNUWhLazBKY2tlL003OEdzeTA2WUgxVGVyb2hNaFlBME1jUVZQOE56OFVEY0NsMmJMVElWZ3RIa0VGZDhEOC9FL1hGcmRHUVdxU0FRYlFoeHlLT3BtL0IwM0FjOU1rZ2tFSWEyaExnaU43OFM1bFB4MGJnSXZRRW0vWVVBdEMzRUZRbnp6ZmdudURjNnpaWitRc2R2YTRqWDVTdjRhdHdYSFptbFg5RGh1eERpa0MyUW44ZFhZVWJtUmVVamluUWJPbnRYUWx5UlRSYWZ3bGRnd3J4VithZ2kzWVJPM3JVUVYvd2NWK0xMOERIb3laelNUZWpjWFExeFJjNy91aHl6bDNrdjNMeDhkSkZ1UUtmdWVvaERuakZuWlA0by9qN20wWlFINEVzM29EUDNJY1FWMmY2WU1GK0NPWmpnVWVpWjJkSnU2TVI5Q3ZHNjNJTHZ4NHpNQ2ZPODBpUWk3WUxPMjljUVYzd2IzNHNwc3I0cnVtQkUyZ1dkdHU4aERsbjk5UzFNWGVZWDRNNmxlVVNhRHgzV0VLOGxSZFlUNWxSL3pQbGZuc3dwelllT2FvalhKNGNTZkIzUHcrZmd0dWcwVzVvSm5kTVFUMC91WkdlYVhaVnlmVFp1VjVwTnBEblFNUTN4eHNrME85VWZ6OFpEY2R2U2ZDS1RodzVwaUdkUDJpb0Y0OTZKVDBjM1djamtLUjFUNWtZV2pDVE03OERmUWhlTXlPU2dBeHJpd2NoMzVsUi92QWJQd09Yb3pTK3BIenFlSVI2T2FsMTJ3dngyZkJ5NnlVTHFndzVuaUVkRHdweVIrVnBNa2ZYc21ISXBwNHdmT3BvaEhqMjM0UmZ3Rk53RG5XYkwrS0NER2VMeGtKSDVwM2cxdmc1M0swMHVNbHJvWElaNHZHVEJTTUo4RmVaa3ptV2w2VVZHQTUzS0VOZkQvWml5TkNteW52Ty9GcGRMSURJY2RDWkRYQzhabWZPZCtkL3dKZWpaWHpJY2RDSkRYRDk1eHB3amRuUCtWNzR6SDRXdS9wTEJvUE1ZNHNtU01OK0ZLYkorQkJwbW1SdDBHa1BjREJMbXUvRmplQWk2bEZObUI1M0ZFRGVIVExQemFDb2o4MGR3QmZxTVdUWU1uY1FRTjVlc0FQc3c3bGN1bDhqNjBFRU1jZlBKRGJEM1lVN2wzS3hjT3BFMTBDa01jVHZJVkR2Zm1jL0UzWEVMdFBxakdPS1draFZncCtHZW1ERDd2Ym5QMEFFTWNYdEprZlUzNEdOeEFUb3k5eEV1dkNGdVA2dndKTXlPcVlYbDBrcGY0S0liNG01UW5jeVpUUmFwWkdHWSt3SVgyeEIzaTN2eE9zd21pMTNRYVhiWDRRSWI0bTZTWTNhL2lNZGg3bVliNXE3Q2hUWEUzYVhhYUxFU3E3ck1XNVpMTDEyQmkycUkrOEU5ZURrbXpMdWhZZTRLWEV4RDNCOHlNdCtPbCtLTDBDTHJYWUNMYUlqN1I4SjhLMTZDUjZQTE9kc01GODhROTVmc21Qb1JYb3pQeGR6TmR2VlgyK0NpR1dMSnphK0VPWFdaajhTZDBBUHcyd0lYeXhCTHFQWXkzNExuWThLOERBMXowK0VpR1dLWlNnSjlJNzRMVTJSOVIzU2EzVlM0T0laWVpxSmF5bmtXcHNqNncwdTNrU2JCaFRIRXNqSHV3eHN3cFZ3UHc2V2wrMGdUNElJWVlwa05tV0tucjF5UHFmNTRLRzVWdXBGTWtuSmhSR1pMd3B6Vlg2bisrRFo4R3JwamFwSndBUXl4REVMQ25CMVRxV1R4MS9nVWRHU2VCRFM4SVpaQlNaQmp6djc2UFA0VkhvU0d1VTVvY0VNc295QmhUc0c0Vkg5OEl4NkE4MHMzazNGQ1F4dGlHU1ZaTVBJVC9Dd216UHVoejVqSENRMXNpR1VjWkNsbnd2eHBQQVgzTEYxT1JnMk5hNGhsWEdTS25RVWpDZk5uOFBYNENOeTBkRDhaQlRTb0laWnhrekJYSS9QbjhBVE11bXpEUEFwb1NFTXNkWkV3NXp2ekR6SFQ3SmRqd3V6Wlg4TkFBeHBpbVFTWlppZk1uOFRqOGFHbFM4cGNvZkVNc1V5S2pNdzVsVE9uakh3Y2MyVFFrdEkxWmJiUWFJWllKazNDbkUwV0dabXZ3T2VoKzVobkM0MWxpS1VwVkNOend2d0pQQnk5K2JVeGFDUkRMRTBqWWI0ZlUvMHgwK3lEOGNHbHk4cFVhQnhETEUwa1FhN0NmQ2ZtTUw4RDBTTjJwMEtqR0dKcE9nbHp0V2draC9rOUNUMWl0NExHTU1UU0ZoTG1MQnJKM2V4emNKL1NqZnNORFdHSXBZMGswRC9BTS9HUnBUdjNFeHJBRUV1YnFWYUFuWTVMc1g5M3MvblFobGk2UUxVRjhuV1lJM2JuWVQrV2MvSkJEYkYwaGVxTzlqZndsZmhJbkkvZERqTWYwQkJMRjBtWXI4TnNza2lOcVMyd20ySG1neGxpNlRKNXpwd2pnLzRRZDhidUxScmhReGxpNlFNNVpqZEhCaDJIK2M3Y25VVWpmQmhETEgwaFUreTdjQ1UrSDdPWGVWNkpRbnZoUXhoaTZSc0pjMGJteS9CWitNc2JZQ1VTN1lNM2I0aWxyeVRNMlFMNVFVekJ1SHhuYnQ4MG16ZHRpRVZXcjc0Tkw4S1VjazJSOWZhTXpMeFpReXl5aG96TVdjcDVJZjR1SnN6TlA1eUFOMm1JUlI1SVZuL2RqT2ZoRWRqc3cveDRjNFpZWkhyeWpQa21QQnNQd1llVjJEUUwzcGdoRnBtWlRMRnpaRkRDbkxyTXo4RHRzVGtiTFhnemhsaGs0eVRNMmN1OENyTmpLaU56d2p6NU9sTzhDVU1zTWpjUzVxekxmZ3VteVByMkpVNlRnVGRnaUVVR295cXlucnJNdjQyVE9UT2JQMnlJUlFZbjArd3M1YndhVThyMU4zSHJFcTk2NEE4YVlwSGhTWmp2d0JTTVM1Z1B3bnJXWmZPSERMSEk2TWd6NWh5eG00SnhmNGtINEhqRHpCOHd4Q0tqSjJIT05QdWY4Yzl4SHh6UFhtWmUyQkNMaklkTXNXTXFXZndUbm9pUHdkR096THlnSVJZWlB3bHpWV1BxdGJnWGptYkJDQzlraUVYcUk4K1lzOG5pY253TjdsYWlPRGk4aUNFV3FaZU15bG1YblRDbllGeE81dHl4UkhMdThJOE5zY2hrU0ppekx2djdtSkg1cGJnWTU3WmppbjlnaUVVbVN6VXlmdzlUWlAxWTNMWkVkT1B3eTRaWXBCa2t6S24rK0IzOEtCNkYyNVdvemd5L1pJaEZta1hDbkxPL3Zvc2Z3cHd5c3FoRWRuMzRvU0VXYVNZSjh5OHcwK3dQNEdHNC9vSVIvcU1oRm1rMlZaZ3p6VTZZczJOcTdUNW0vbzhoRm1rSENYTzJQeWJNRitPKytDQkRMTkl1RXVTc3k4NTM1bHZ4WkVNczBqNnFXc3paSmJYVUVJdTBpMXZ3clpocUZadjVuVmlrUFdUcWZBNW1GOVFERCtmalB4aGlrZWFSNzc3eGRyd0FuMUFpdXo3ODBCQ0xOSXZzZE1xQkFxa050UnczWEJlS1h6REVJcE1ubzI3Q2V6ZGVpay9HQlNXbUc0WmZOTVFpa3lQaHpYcnBWR1hNNlI4cmNHN2xWZmtIaGxpa2ZoTGU3RnpLbzZLVitIdTQ1bTd6WE9FZkdtS1Jlc2tlNG9UM2szZ01ibG5pT0JpOGdDRVdxWWVNdkQvR0svRjQzS0hFY0RoNElVTXNNbDV5dytwSG1MT29YNGFESDhVekhieWdJUllaRC9uZW01SDNLandCZDhMUlYxSGtSUTJ4eUdqSjNlYWNOWjFpYXlmaHIrUDQ2aG56NG9aWVpEUmsycHp3cGg3VFgrQ3VPUDc2eGZ3UlF5d3lITmxWVklYM1ZIeDhpVmM5OEFjTnNjamdaSkZHeXBxK0dmZkh3WjcxRGdOLzFCQ0x6SjJmNDcvaVd6QmxUSWQ3MWpzTS9IRkRMREk3Y3JmNUhyd0czNFlIWTcwRnhhZUROMkdJUlRaTXdwdmpjSzdGZCtCVGNmTGhyZUROR0dLUm1jbkllejIrRXcvRmhUaTNNaXZqaGpka2lFWFdKMGZFZmhYUHdtZmk0aEtaNXNHYk04UWlhOG42NWxYNExremxoWWVWcURRWDNxUWhGbG56clBjLzhGek10c0JsMkt4cDgwendSZzJ4OUowY3huNGVwb0JabGtqVy82eDNHSGpEaGxqNlNKWkk1Z1RKOStEek1lSGR2TVNpWGZER0RiSDBpV3BiWU1xZ0pMeTdZTHRHM3Fud0FReXg5SVZzQzd3RVg0Qzc0L2gyRnRVSkg4UVFTOWZKVVRnNVFmSTQzQVBubGU3ZkRmaEFobGk2U281Ly9SaStHQlBleWExdkhpZDhNRU1zWFNNSDBYMENYNEo3NGNMUzNic0pIOUFRUzFmSVRhdnM2ZjFWZUxFZHozcUhnUTlwaUtYdFpITkMxamZuRUxwZlRwdXgrK0d0NE1NYVlta3JtVFovR1YrTENXKzNwODB6d1FjM3hOSTJza1R5QnN3aGRIdGljN1lGVGdJYXdCQkxtN2dSVDhISDRkYlluMm56VE5BSWhsamFRQ3JrdndrVDN0eXdHdjhwa20yQnhqREUwbFJ5b2tiT3Nqb0RVeUUvTjZ3TTcxUm9GRU1zVFNQaHZSUGZqWS9HQmVpMGVTWm9IRU1zVGVKMi9BRHVnKzNjVlZRM05KUWhsaWFRa2ZjZjhTbm9xRHNYYURCRExKTWlqNHJ1eGN2d2FlaklPd2cwbkNHV3Vzbnl5SVQzQ2p3TSs3bElZMVRRZ0laWTZpQTNxekx5Wm1kUlNuMGVpYzA5UWJKTjBKQ0dXTVpKd3B1Ujl3NzhFcjRRdTdrbGNGTFFvSVpZeGtYcTlPWnVjMm9XWlhOQ3Y1ZEhqZ3NhMWhETHFLbkNtMnFCMlp6dzBOTGRaQnpRd0laWVJrV216VC9EaFBkRTNLVjBNeGtuTkxRaGxtSEo5OTZFTndYSHNqa2hxNnhjSGxrWE5MWWhsa0ZKZUhQREtodnlzemtoNFczMzhhOXRoRVkzeERKWDhxZ29HeE1TM3RUcGZTek9MMTFLNm9iR044UXlXeExlTEkvTXREbWxQdmRIcDgyVGhvdGdpR1UyWk9TdHdyc0NYU0xaRkxnWWhsZzJ4RjJZYzZ6T3hxZWpDeldhQmhmRkVNdDBwTWoyVnpCMWVnL0JKYVhMU05QZzRoaGlxY2pkNWl6VVNJWDhsUHA4Rmk0dFhVV2FDaGZKRUV0SWhmd1UyYjRRVTJSN08zUmZieHZnUWhuaWZwT0QxNytKQ1c5S2ZTNUY3emkzQ1M2WUllNG5PWGo5Vy9oM2VBdyt2SFFKYVJ0Y1BFUGNML0tzOTJhOENJL0ZYZEZwYzV2aEFocmkvdkI5L0h2OEEzd1V1a1N5QzNBaERYSDMrU24rQXg2UHFaRHZFc2t1d1FVMXhOMmtPZ29uSjBpbTFHYzJKMnhSTHJ0MENTNnNJZTRXMWM2aWoyTkczbFJPbUZjdXQzUVJMckFoN2c0Sjc1WDRSN2czR3Q0K3dJVTJ4TzBuMCtaUDRhc3dCY2RjMzl3bnVPQ0d1TDNrV2UvbjhEVzRMeTRxbDFYNkJCZmVFTGVUTCtBSitBVGNCbjNXMjFlNCtJYTRQZVNPODlmd1QvR0p1QWhkSXRsMzZBU0d1UGxrWjlHMzhmV1lvM0F5OGhwZVdRT2R3UkEzbHh3QmV4TytHVlBxMDdJbnNqNTBERVBjVExLKytlMlljNndXbzk5NVpYcm9ISWE0V2R5S09RcG5PV2JhdkdtNVZDTFRReWN4eE0wZ3AwaWVqMC9HM0xBeXZESTc2Q3lHZUhKVXgrRzhIdzlFd3l0emgwNWppQ2RERHFLN0hBL0FoZWgzWGhrTU9vOGhycGUwOTZmeGQ5RDl2REk4cFZQSitMa1hQNHZQUWFmTU1qcm9VSVo0Zk9RN2I5WTNYNFU1eDhvaTJ6SjY2RmlHZVBSa2VXUk9rZndpSG9lZTNTempndzVtaUVkRFJ0MTREK2J3OVpmakRxV1pSY1lISGMwUUQwOTFGRTZPZ1AwejlPQjFxUTg2bXlFZW5LeHRUbmd6OHI0QkhYbWxmdWg0aG5qdUpMd3A5WmxxZ2FmaDdxVTVSZXFIRG1pSVowK216VmtlZVFPK0ZSOWZtbEZrY3RBUkRmSHNTSjNlZjhkcVo1R0gwRWt6b0RNYTRwbkozZWEwVDA3VE9BZXp2bmxCYVRxUlpsQTZxVHlRaERkcm0xZmhCWGd3R2w1cEpuUk9RN3lXNmpsdnd2dGVmQVp1WHBwS3BKbVVUaXRycDgwcDlabjF6UTh1VFNUU2JPaXNmUTl4cHMycGtKL3dQaGUzSzAwajBnN290SDBOOGYzNGRYd2ZIbzBXMlpaMlF1ZnRZNGl6UERLbmFid0lINEVlL3lydGhRN2NseEJubGRVUDhCSjhNU2E4N3V1VjlrTkg3bnFJYzRaVnd2c2hmQ2t1UThNcjNZRU8zZFVRWjRua0QvSERtRktmZTVTUExOSXQ2TnhkREhIQyt4RjhCYWJzaVNPdmRCYzZlSmRDZkJ0ZWhnbHZpbXo3ckZlNkR4MjlDeUhPUW8wcjhOV1lPcjBXMlpiK1FJZHZhNGl6UkRMUGVsZGk2dlNtMU9mQzhyRkUrZ01kdjQwaHpudStHbE1oZnovY0VqME9SL29KbmI5TkljNTd2UVpQeENlaEk2OUlDVWJUeWRuTjErTEptUEF1S1c5ZlJBaEVrME9jWjczWFl3NmhPd2c5djFsa0tnU2pxU0hPNW9SVDhUZHdLYnErV1dRNkNFZVRRcHc3emxtb2NUcW1UbS9PYjdib21NaUdJQ1JOQ0hHbXpUL0JzekNsUGpQeXVzcEtaRFlRbGttSCtNZjR0N2djdDBlbnpTSnpnZEJNS3NRSjcwWDRWSFRrRlJrVXdsTjNpRk01NFlONEtHNkxIa1FuTWd5RXFLNFE1MW52cFpqd1p1UTF2Q0tqZ0REVkVlSXI4WEJNZUwzYkxESktDTlc0UXB5Ujl6bzhBcmRCYjFpSmpBUENOZW9RSjd5cEZuZ3N6a2MzSm9pTUUwSTJxaERuV1c4S2p2MHh1akZCcEM0STNEQWh6Z3FySEVTWFVwL1owL3VROHJJaVVoY0ViNUFRSjd6MzRUZndKTnk1dkp5STFBMEJuRzJJRTl5WXNpZmZ3VGZpenVoM1hwRkpRZ2huRStKODMwMTR2NHVwa0w4citxaElwQWtReGcyRk9PSE56ek50UGhmM1JFZGVrU1pSUWpxVlRKdHpndVNOZUQ0ZVdINWRSSm9HQVowYTRydnhtM2docmtDbnpTSk5ocEJXSWM3L3BscGd3cHVkUlo3ZExOSUdDT3Z0SmJ3WDQyRzR1UHhJUk5vQW9VMmQzaU54VWZsUEl0SWFOdG5rL3dFR0JvTWRwRUNHSEFBQUFBQkpSVTVFcmtKZ2dnPT0nO1xuICAgICAgICBwbGF5T3ZlcmxheUh0bWxJbm5lci5hbHQgPSAnU3RhcnQgU3RyZWFtaW5nJztcbiAgICAgICAgcmV0dXJuIHBsYXlPdmVybGF5SHRtbElubmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBjb25uZWN0IG92ZXJsYXkgd2l0aCBhIGNvbm5lY3Rpb24gYnV0dG9uLlxuICAgICAqIEBwYXJhbSBwYXJlbnRFbGVtIC0gdGhlIHBhcmVudCBlbGVtZW50IHRoaXMgb3ZlcmxheSB3aWxsIGJlIGluc2VydGVkIGludG8uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyZW50RWxlbSkge1xuICAgICAgICBzdXBlcihwYXJlbnRFbGVtLCBQbGF5T3ZlcmxheS5jcmVhdGVSb290RWxlbWVudCgpLCBQbGF5T3ZlcmxheS5jcmVhdGVDb250ZW50RWxlbWVudCgpKTtcbiAgICAgICAgLy8gYWRkIHRoZSBuZXcgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgdGhpcy5yb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGxheU92ZXJsYXkuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IE92ZXJsYXlCYXNlIH0gZnJvbSAnLi9CYXNlT3ZlcmxheSc7XG4vKipcbiAqIENsYXNzIGZvciB0aGUgdGV4dCBvdmVybGF5IGJhc2VcbiAqL1xuZXhwb3J0IGNsYXNzIFRleHRPdmVybGF5IGV4dGVuZHMgT3ZlcmxheUJhc2Uge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHRleHQgb3ZlcmxheVxuICAgICAqIEBwYXJhbSByb290RGl2IC0gdGhlIHJvb3QgZWxlbWVudCB0aGlzIG92ZXJsYXkgd2lsbCBiZSBpbnNlcnRlZCBpbnRvXG4gICAgICogQHBhcmFtIHJvb3RFbGVtZW50IC0gdGhlIHJvb3QgZWxlbWVudCB0aGF0IGlzIHRoZSBvdmVybGF5XG4gICAgICogQHBhcmFtIHRleHRFbGVtZW50IC0gYW4gZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRleHQgZm9yIHRoZSBhY3Rpb24gb3ZlcmxheVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJvb3REaXYsIHJvb3RFbGVtZW50LCB0ZXh0RWxlbWVudCkge1xuICAgICAgICBzdXBlcihyb290RGl2LCByb290RWxlbWVudCwgdGV4dEVsZW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHRleHQgb3ZlcmxheXMgaW5uZXIgdGV4dFxuICAgICAqIEBwYXJhbSB0ZXh0IC0gdGhlIHVwZGF0ZSB0ZXh0IHRvIGJlIGluc2VydGVkIGludG8gdGhlIG92ZXJsYXlcbiAgICAgKi9cbiAgICB1cGRhdGUodGV4dCkge1xuICAgICAgICBpZiAodGV4dCAhPSBudWxsIHx8IHRleHQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnRleHRFbGVtZW50LmlubmVySFRNTCA9IHRleHQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0T3ZlcmxheS5qcy5tYXAiLCIvKiBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLiAqL1xuaW1wb3J0IGpzcyBmcm9tICdqc3MnO1xuaW1wb3J0IGdsb2JhbCBmcm9tICdqc3MtcGx1Z2luLWdsb2JhbCc7XG5pbXBvcnQgY2FtZWxDYXNlIGZyb20gJ2pzcy1wbHVnaW4tY2FtZWwtY2FzZSc7XG5leHBvcnQgY2xhc3MgUGl4ZWxTdHJlYW1pbmdBcHBsaWNhdGlvblN0eWxlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdExpZ2h0TW9kZVBhbGV0dGUgPSB7XG4gICAgICAgICAgICAnLS1jb2xvcjAnOiAnI2UyZTBkZDgwJyxcbiAgICAgICAgICAgICctLWNvbG9yMSc6ICcjRkZGRkZGJyxcbiAgICAgICAgICAgICctLWNvbG9yMic6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICctLWNvbG9yMyc6ICcjMDU4NWZlJyxcbiAgICAgICAgICAgICctLWNvbG9yNCc6ICcjMzViMzUwJyxcbiAgICAgICAgICAgICctLWNvbG9yNSc6ICcjZmZhYjAwJyxcbiAgICAgICAgICAgICctLWNvbG9yNic6ICcjZTFlMmRkJyxcbiAgICAgICAgICAgICctLWNvbG9yNyc6ICcjYzNjNGJmJ1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlZmF1bHREYXJrTW9kZVBhbGV0dGUgPSB7XG4gICAgICAgICAgICAnLS1jb2xvcjAnOiAnIzFkMWYyMmUwJyxcbiAgICAgICAgICAgICctLWNvbG9yMSc6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICctLWNvbG9yMic6ICcjRkZGRkZGJyxcbiAgICAgICAgICAgICctLWNvbG9yMyc6ICcjMDU4NWZlJyxcbiAgICAgICAgICAgICctLWNvbG9yNCc6ICcjMzViMzUwJyxcbiAgICAgICAgICAgICctLWNvbG9yNSc6ICcjZmZhYjAwJyxcbiAgICAgICAgICAgICctLWNvbG9yNic6ICcjMWUxZDIyJyxcbiAgICAgICAgICAgICctLWNvbG9yNyc6ICcjM2MzYjQwJ1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlZmF1bHRTdHlsZXMgPSB7XG4gICAgICAgICAgICAnOnJvb3QnOiB7XG4gICAgICAgICAgICAgICAgJy0tY29sb3IwJzogJyMxZDFmMjJlMCcsXG4gICAgICAgICAgICAgICAgJy0tY29sb3IxJzogJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgICctLWNvbG9yMic6ICcjRkZGRkZGJyxcbiAgICAgICAgICAgICAgICAnLS1jb2xvcjMnOiAnIzA1ODVmZScsXG4gICAgICAgICAgICAgICAgJy0tY29sb3I0JzogJyMzNWIzNTAnLFxuICAgICAgICAgICAgICAgICctLWNvbG9yNSc6ICcjZmZhYjAwJyxcbiAgICAgICAgICAgICAgICAnLS1jb2xvcjYnOiAnIzFlMWQyMicsXG4gICAgICAgICAgICAgICAgJy0tY29sb3I3JzogJyMzYzNiNDAnLFxuICAgICAgICAgICAgICAgICctLWNvbG9yOCc6ICcjNDEwMDhjJyxcbiAgICAgICAgICAgICAgICAnLS1jb2xvcjknOiAnIzNlMDA3MCcsXG4gICAgICAgICAgICAgICAgJy0tY29sb3IxMCc6ICcjMmUwMDUyJyxcbiAgICAgICAgICAgICAgICAnLS1jb2xvcjExJzogJ3JnYmEoNjUsMCwxMzksMSknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5ub3NlbGVjdCc6IHtcbiAgICAgICAgICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI3BsYXllclVJJzoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI3ZpZGVvRWxlbWVudFBhcmVudCc6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3ZhcigtLWNvbG9yMSknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyN1aUZlYXR1cmVzJzoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgekluZGV4OiAnMzAnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAndmFyKC0tY29sb3IyKScsXG4gICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcuVWlUb29sIC50b29sdGlwdGV4dCc6IHtcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAndmFyKC0tY29sb3IyKScsXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICcxNXB4JyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMHB4IDEwcHgnLFxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IFwiJ01vbnRzZXJyYXQnLCBzYW5zLXNlcmlmXCIsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjc1cmVtJyxcbiAgICAgICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiAnMC43NXB4JyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICB0b3A6ICcwJyxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDI1JSknLFxuICAgICAgICAgICAgICAgIGxlZnQ6ICcxMjUlJyxcbiAgICAgICAgICAgICAgICB6SW5kZXg6ICcyMCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLlVpVG9vbDpob3ZlciAudG9vbHRpcHRleHQnOiB7XG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogJ3Zpc2libGUnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3ZhcigtLWNvbG9yNyknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyNjb25uZWN0aW9uIC50b29sdGlwdGV4dCc6IHtcbiAgICAgICAgICAgICAgICB0b3A6ICcxMjUlJyxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC0yNSUpJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiAnMCcsXG4gICAgICAgICAgICAgICAgekluZGV4OiAnMjAnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc1cHggMTBweCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI2Nvbm5lY3Rpb24nOiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgYm90dG9tOiAnOCUnLFxuICAgICAgICAgICAgICAgIGxlZnQ6ICc1JScsXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogXCInTWljaHJvbWEnLCBzYW5zLXNlcmlmXCIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnM3JlbScsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICczcmVtJyxcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnYWxsJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjc2V0dGluZ3MtcGFuZWwgLnRvb2x0aXB0ZXh0Jzoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgdG9wOiAnMTI1JScsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKScsXG4gICAgICAgICAgICAgICAgbGVmdDogJzAnLFxuICAgICAgICAgICAgICAgIHpJbmRleDogJzIwJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnNXB4IDEwcHgnLFxuICAgICAgICAgICAgICAgIGJvcmRlcjogJzNweCBzb2xpZCB2YXIoLS1jb2xvcjMpJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogJ21heC1jb250ZW50JyxcbiAgICAgICAgICAgICAgICBmYWxsYmFja3M6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICdtYXgtY29udGVudCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnM3B4IHNvbGlkIHZhcigtLWNvbG9yMyknXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc1cHggMTBweCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgekluZGV4OiAnMjAnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6ICcwJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC01MCUpJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6ICcxMjUlJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyNjb250cm9scyc6IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICB0b3A6ICczJScsXG4gICAgICAgICAgICAgICAgbGVmdDogJzIlJyxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBcIidNaWNocm9tYScsIHNhbnMtc2VyaWZcIixcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnYWxsJyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyNjb250cm9scz4qJzoge1xuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogJzAuNXJlbScsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNTAlJyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJzJyZW0nLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6ICcxLjc1cmVtJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMC41cmVtJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjY29udHJvbHMgI2FkZGl0aW9uYWxpbmZvJzoge1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogXCInTW9udHNlcnJhdCcsIHNhbnMtc2VyaWZcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjZnVsbHNjcmVlbi1idG4nOiB7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzAuNnJlbSAhaW1wb3J0YW50J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjbWluaW1pemVJY29uJzoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjc2V0dGluZ3NCdG4sICNzdGF0c0J0bic6IHtcbiAgICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjdWlGZWF0dXJlcyBidXR0b24nOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndmFyKC0tY29sb3I3KScsXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkIHZhcigtLWNvbG9yNyknLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAndmFyKC0tY29sb3IyKScsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICczcmVtJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICczcmVtJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMC41cmVtJyxcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyN1aUZlYXR1cmVzIGJ1dHRvbjpob3Zlcic6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd2YXIoLS1jb2xvcjMpJyxcbiAgICAgICAgICAgICAgICBib3JkZXI6ICczcHggc29saWQgdmFyKC0tY29sb3IzKScsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJzAuMjVzIGVhc2UnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAnMC41NXJlbScsXG4gICAgICAgICAgICAgICAgcGFkZGluZ1RvcDogJzAuNTVyZW0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyN1aUZlYXR1cmVzIGJ1dHRvbjphY3RpdmUnOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyOiAnM3B4IHNvbGlkIHZhcigtLWNvbG9yMyknLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3ZhcigtLWNvbG9yNyknLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAnMC41NXJlbScsXG4gICAgICAgICAgICAgICAgcGFkZGluZ1RvcDogJzAuNTVyZW0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5idG4tZmxhdCc6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAgICAgY29sb3I6ICd2YXIoLS1jb2xvcjIpJyxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBcIidNb250c2VycmF0J1wiLFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICAgICAgICBib3JkZXI6ICczcHggc29saWQgdmFyKC0tY29sb3IzKScsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnMXJlbScsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjc1cmVtJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogJzAuNXJlbScsXG4gICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiAnMC41cmVtJyxcbiAgICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5idG4tZmxhdDpob3Zlcic6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd2YXIoLS1jb2xvcjMpJyxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnZWFzZSAwLjNzJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcuYnRuLWZsYXQ6ZGlzYWJsZWQnOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ3ZhcigtLWNvbG9yNyknLFxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAndmFyKC0tY29sb3IzKScsXG4gICAgICAgICAgICAgICAgY29sb3I6ICd2YXIoLS1jb2xvcjMpJyxcbiAgICAgICAgICAgICAgICBjdXJzb3I6ICdkZWZhdWx0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcuYnRuLWZsYXQ6YWN0aXZlJzoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcuYnRuLWZsYXQ6Zm9jdXMnOiB7XG4gICAgICAgICAgICAgICAgb3V0bGluZTogJ25vbmUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyN1aUZlYXR1cmVzIGltZyc6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5wYW5lbC13cmFwJzoge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIHRvcDogJzAnLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogJzAnLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAnMCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6ICcyMHZ3JyxcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogJzkwdncnLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMTAwJSknLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICcuM3MgZWFzZS1vdXQnLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdhbGwnLFxuICAgICAgICAgICAgICAgIG92ZXJmbG93WTogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIG92ZXJmbG93WDogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndmFyKC0tY29sb3IwKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLnBhbmVsLXdyYXAtdmlzaWJsZSc6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDAlKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLnBhbmVsJzoge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93WTogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcxZW0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyNzZXR0aW5nc0hlYWRpbmcsICNzdGF0c0hlYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICcyZW0nLFxuICAgICAgICAgICAgICAgIG1hcmdpbkJsb2NrU3RhcnQ6ICcwLjY3ZW0nLFxuICAgICAgICAgICAgICAgIG1hcmdpbkJsb2NrRW5kOiAnMC42N2VtJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5JbmxpbmVTdGFydDogJzBweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luSW5saW5lRW5kOiAnMHB4JyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMCAwIDAgMnJlbSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI3NldHRpbmdzQ2xvc2UsICNzdGF0c0Nsb3NlJzoge1xuICAgICAgICAgICAgICAgIG1hcmdpbjogJzAuNXJlbScsXG4gICAgICAgICAgICAgICAgcGFkZGluZ1RvcDogJzAuNXJlbScsXG4gICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogJzAuNXJlbScsXG4gICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiAnMC41cmVtJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzJlbScsXG4gICAgICAgICAgICAgICAgZmxvYXQ6ICdyaWdodCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI3NldHRpbmdzQ2xvc2U6YWZ0ZXIsICNzdGF0c0Nsb3NlOmFmdGVyJzoge1xuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAnMC41cmVtJyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnXCJcXFxcMDBkN1wiJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjc2V0dGluZ3NDbG9zZTpob3ZlciwgI3N0YXRzQ2xvc2U6aG92ZXInOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICd2YXIoLS1jb2xvcjMpJyxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnZWFzZSAwLjNzJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjc2V0dGluZ3NDb250ZW50LCAjc3RhdHNDb250ZW50Jzoge1xuICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICcycmVtJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogJzJyZW0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5zZXR0aW5nJzoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAncm93JyxcbiAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ3NwYWNlLWJldHdlZW4nLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcwLjE1cmVtIDEwcHggMC4xNXJlbSAxMHB4J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcuc2V0dGluZ3MtdGV4dCc6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3ZhcigtLWNvbG9yMiknLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5zZXR0aW5ncy1vcHRpb24nOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6ICdlbGxpcHNpcycsXG4gICAgICAgICAgICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI2Nvbm5lY3RPdmVybGF5LCAjcGxheU92ZXJsYXksICNpbmZvT3ZlcmxheSwgI2Vycm9yT3ZlcmxheSwgI2Fma092ZXJsYXksICNkaXNjb25uZWN0T3ZlcmxheSc6IHtcbiAgICAgICAgICAgICAgICB6SW5kZXg6ICczMCcsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgY29sb3I6ICd2YXIoLS1jb2xvcjIpJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzEuOGVtJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3ZhcigtLWNvbG9yMSknLFxuICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICB0ZXh0VHJhbnNmb3JtOiAndXBwZXJjYXNlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcuY2xpY2thYmxlU3RhdGUnOiB7XG4gICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcudGV4dERpc3BsYXlTdGF0ZSc6IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLmhpZGRlblN0YXRlJzoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjcGxheUJ1dHRvbiwgI2Nvbm5lY3RCdXR0b24nOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICAgICAgICAgICAgekluZGV4OiAnMzAnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ltZyNwbGF5QnV0dG9uJzoge1xuICAgICAgICAgICAgICAgIG1heFdpZHRoOiAnMjQxcHgnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjdWlJbnRlcmFjdGlvbic6IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjVUlJbnRlcmFjdGlvbkJ1dHRvbkJvdW5kYXJ5Jzoge1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcycHgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyNVSUludGVyYWN0aW9uQnV0dG9uJzoge1xuICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5idG4tb3ZlcmxheSc6IHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcudGdsLXN3aXRjaCc6IHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcudGdsLXN3aXRjaCAudGdsJzoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcudGdsLCAudGdsOmFmdGVyLCAudGdsOmJlZm9yZSwgLnRnbCAqLCAudGdsICo6YWZ0ZXIsIC50Z2wgKjpiZWZvcmUsIC50Z2wrLnRnbC1zbGlkZXInOiB7XG4gICAgICAgICAgICAgICAgJy13ZWJraXQtYm94LXNpemluZyc6ICdib3JkZXItYm94JyxcbiAgICAgICAgICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcudGdsOjotbW96LXNlbGVjdGlvbiwgLnRnbDphZnRlcjo6LW1vei1zZWxlY3Rpb24sIC50Z2w6YmVmb3JlOjotbW96LXNlbGVjdGlvbiwgLnRnbCAqOjotbW96LXNlbGVjdGlvbiwgLnRnbCAqOmFmdGVyOjotbW96LXNlbGVjdGlvbiwgLnRnbCAqOmJlZm9yZTo6LW1vei1zZWxlY3Rpb24sIC50Z2wrLnRnbC1zbGlkZXI6Oi1tb3otc2VsZWN0aW9uJzoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICdub25lJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcudGdsOjpzZWxlY3Rpb24sIC50Z2w6YWZ0ZXI6OnNlbGVjdGlvbiwgLnRnbDpiZWZvcmU6OnNlbGVjdGlvbiwgLnRnbCAqOjpzZWxlY3Rpb24sIC50Z2wgKjphZnRlcjo6c2VsZWN0aW9uLCAudGdsICo6YmVmb3JlOjpzZWxlY3Rpb24sIC50Z2wrLnRnbC1zbGlkZXI6OnNlbGVjdGlvbic6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLnRnbC1zbGlkZXInOiB7fSxcbiAgICAgICAgICAgICcudGdsKy50Z2wtc2xpZGVyJzoge1xuICAgICAgICAgICAgICAgIG91dGxpbmU6ICcwJyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnNDBweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMThweCcsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAgICAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy50Z2wrLnRnbC1zbGlkZXI6YWZ0ZXIsIC50Z2wrLnRnbC1zbGlkZXI6YmVmb3JlJzoge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgY29udGVudDogJ1wiXCInLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnNTAlJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcudGdsKy50Z2wtc2xpZGVyOmFmdGVyJzoge1xuICAgICAgICAgICAgICAgIGxlZnQ6ICcwJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcudGdsKy50Z2wtc2xpZGVyOmJlZm9yZSc6IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLnRnbC1mbGF0Ky50Z2wtc2xpZGVyJzoge1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcycHgnLFxuICAgICAgICAgICAgICAgICctd2Via2l0LXRyYW5zaXRpb24nOiAnYWxsIC4ycyBlYXNlJyxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnYWxsIC4ycyBlYXNlJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAndmFyKC0tY29sb3I2KScsXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAnM3B4IHNvbGlkIHZhcigtLWNvbG9yNyknLFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzJlbSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLnRnbC1mbGF0Ky50Z2wtc2xpZGVyOmFmdGVyJzoge1xuICAgICAgICAgICAgICAgICctd2Via2l0LXRyYW5zaXRpb24nOiAnYWxsIC4ycyBlYXNlJyxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnYWxsIC4ycyBlYXNlJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAndmFyKC0tY29sb3I3KScsXG4gICAgICAgICAgICAgICAgY29udGVudDogJ1wiXCInLFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzFlbSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLnRnbC1mbGF0OmNoZWNrZWQrLnRnbC1zbGlkZXInOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyOiAnM3B4IHNvbGlkIHZhcigtLWNvbG9yMyknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy50Z2wtZmxhdDpjaGVja2VkKy50Z2wtc2xpZGVyOmFmdGVyJzoge1xuICAgICAgICAgICAgICAgIGxlZnQ6ICc1MCUnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICd2YXIoLS1jb2xvcjMpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcuYnRuLWFwcGx5Jzoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jayAhaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAnYXV0bycsXG4gICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogJzQwJSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLmZvcm0tY29udHJvbCc6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd2YXIoLS1jb2xvcjcpJyxcbiAgICAgICAgICAgICAgICBib3JkZXI6ICcycHggc29saWQgdmFyKC0tY29sb3I3KScsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3ZhcigtLWNvbG9yMiknLFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ3JpZ2h0JyxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiAnaW5oZXJpdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLmZvcm0tY29udHJvbDpob3Zlcic6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ3ZhcigtLWNvbG9yNyknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5mb3JtLWdyb3VwJzoge1xuICAgICAgICAgICAgICAgIHBhZGRpbmdUb3A6ICc0cHgnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdncmlkJyxcbiAgICAgICAgICAgICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiAnODAlIDIwJScsXG4gICAgICAgICAgICAgICAgcm93R2FwOiAnNHB4JyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nUmlnaHQ6ICcxMHB4JyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogJzEwcHgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5mb3JtLWdyb3VwIGxhYmVsJzoge1xuICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5zZXR0aW5nc0NvbnRhaW5lcic6IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiAnMXB4IHNvbGlkIHZhcigtLWNvbG9yNyknLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdUb3A6ICcxMHB4JyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAnMTBweCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLnNldHRpbmdzQ29udGFpbmVyPiA6Zmlyc3QtY2hpbGQnOiB7XG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAnNHB4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206ICc0cHgnLFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ3NwYWNlLWJldHdlZW4nLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAncm93JyxcbiAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiAnYmFzZWxpbmUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5jb2xsYXBzZSc6IHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogJzUlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcjc3RyZWFtVG9vbHMnOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6ICc1cHgnLFxuICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6ICc1cHgnLFxuICAgICAgICAgICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICB0b3A6ICcwJyxcbiAgICAgICAgICAgICAgICByaWdodDogJzIlJyxcbiAgICAgICAgICAgICAgICB6SW5kZXg6ICcxMDAnLFxuICAgICAgICAgICAgICAgIGJvcmRlcjogJzRweCBzb2xpZCB2YXIoLS1jb2xvdXI4KScsXG4gICAgICAgICAgICAgICAgYm9yZGVyVG9wV2lkdGg6ICcwcHgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5zZXR0aW5nc0hlYWRlcic6IHtcbiAgICAgICAgICAgICAgICBmb250U3R5bGU6ICdpdGFsaWMnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyNzdHJlYW1Ub29sc0hlYWRlcic6IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgZmxleERpcmVjdGlvbjogJ3JvdycsXG4gICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206ICcxcHggc29saWQgdmFyKC0tY29sb3VyOCknLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3ZhcigtLWNvbG9yNyknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5zdHJlYW1Ub29scyc6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd2YXIoLS1jb2xvcjIpJyxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiAndmFyKC0tYnV0dG9uRm9udCknLFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdsaWdodGVyJyxcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3ZhcigtLWNvbG9yNyknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5zdHJlYW1Ub29scy1zaG93bj4jc3RyZWFtVG9vbHNTZXR0aW5ncywgLnN0cmVhbVRvb2xzLXNob3duPiNzdHJlYW1Ub29sc1N0YXRzJzoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI3N0cmVhbVRvb2xzVG9nZ2xlJzoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI3F1YWxpdHlTdGF0dXMnOiB7XG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICczN3B4JyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nUmlnaHQ6ICc0cHgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJy5zdmdJY29uJzoge1xuICAgICAgICAgICAgICAgIGZpbGw6ICd2YXIoLS1jb2xvcjIpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcubW9kYWwnOiB7XG4gICAgICAgICAgICAgICAgbWluV2lkdGg6ICcxMDB2dycsXG4gICAgICAgICAgICAgICAgbWluSGVpZ2h0OiAnMTAwdmgnLFxuICAgICAgICAgICAgICAgIGxlZnQ6ICcwJyxcbiAgICAgICAgICAgICAgICB0b3A6ICcwJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAndmFyKC0tY29sb3IyKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLmlubmVyTW9kYWwnOiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICc1MDBweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMzAwcHgnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3ZhcigtLWNvbG9yMCknLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ3NwYWNlLWJldHdlZW4nLFxuICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzAuNzVlbSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLm1vZGFsQnRuQ29udGFpbmVyJzoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAncm93JyxcbiAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ3NwYWNlLWFyb3VuZCcsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nVG9wOiAnMWVtJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAnMWVtJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcubW9kYWxUZXh0QXJlYSc6IHtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICB3aWR0aDogJzk1JScsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgcmVzaXplOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICcxcmVtJyxcbiAgICAgICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQgdmFyKC0tY29sb3IyKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLm1vZGFsVGV4dEFyZWE6Zm9jdXMtdmlzaWJsZSc6IHtcbiAgICAgICAgICAgICAgICBvdXRsaW5lOiAnbm9uZSAhaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQgdmFyKC0tY29sb3IzKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnLm1vZGFsIC5idG4tZmxhdCc6IHtcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzEuMHJlbSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgeyBjdXN0b21TdHlsZXMsIGxpZ2h0TW9kZVBhbGV0dGUsIGRhcmtNb2RlUGFsZXR0ZSwganNzSW5zZXJ0aW9uUG9pbnQgfSA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xuICAgICAgICAvLyBPbmUgdGltZSBzZXR1cCB3aXRoIGRlZmF1bHQgcGx1Z2lucyBhbmQgc2V0dGluZ3MuXG4gICAgICAgIGNvbnN0IGpzc09wdGlvbnMgPSB7XG4gICAgICAgICAgICAvLyBKU1MgaGFzIG1hbnkgaW50ZXJlc3RpbmcgcGx1Z2lucyB3ZSBtYXkgd2lzaCB0byB0dXJuIG9uXG4gICAgICAgICAgICAvL3BsdWdpbnM6IFtmdW5jdGlvbnMoKSwgdGVtcGxhdGUoKSwgZ2xvYmFsKCksIGV4dGVuZCgpLCBuZXN0ZWQoKSwgY29tcG9zZSgpLCBjYW1lbENhc2UoKSwgZGVmYXVsdFVuaXQob3B0aW9ucy5kZWZhdWx0VW5pdCksIGV4cGFuZCgpLCB2ZW5kb3JQcmVmaXhlcigpLCBwcm9wc1NvcnQoKV1cbiAgICAgICAgICAgIHBsdWdpbnM6IFtnbG9iYWwoKSwgY2FtZWxDYXNlKCldLFxuICAgICAgICAgICAgaW5zZXJ0aW9uUG9pbnQ6IGpzc0luc2VydGlvblBvaW50XG4gICAgICAgIH07XG4gICAgICAgIGpzcy5zZXR1cChqc3NPcHRpb25zKTtcbiAgICAgICAgdGhpcy5jdXN0b21TdHlsZXMgPSBjdXN0b21TdHlsZXM7XG4gICAgICAgIHRoaXMubGlnaHRNb2RlUGFsZXR0ZSA9IGxpZ2h0TW9kZVBhbGV0dGUgIT09IG51bGwgJiYgbGlnaHRNb2RlUGFsZXR0ZSAhPT0gdm9pZCAwID8gbGlnaHRNb2RlUGFsZXR0ZSA6IHRoaXMuZGVmYXVsdExpZ2h0TW9kZVBhbGV0dGU7XG4gICAgICAgIHRoaXMuZGFya01vZGVQYWxldHRlID0gZGFya01vZGVQYWxldHRlICE9PSBudWxsICYmIGRhcmtNb2RlUGFsZXR0ZSAhPT0gdm9pZCAwID8gZGFya01vZGVQYWxldHRlIDogdGhpcy5kZWZhdWx0RGFya01vZGVQYWxldHRlO1xuICAgIH1cbiAgICBhcHBseVN0eWxlU2hlZXQoKSB7XG4gICAgICAgIC8vIFRvZG86IHJlZmFjdG9yIGNvZGViYXNlIHRvIHVzZSBqc3MgYXQgYSBjb21wb25lbnQgbGV2ZWwsIGNsYXNzZXMgY2FuIGJlIGdyYWJiZWQgbGlrZSBzbzpcbiAgICAgICAgLy9jb25zdCB7cGl4ZWxTdHJlYW1pbmdDbGFzc2VzfSA9IGpzcy5jcmVhdGVTdHlsZVNoZWV0KHN0eWxlcykuYXR0YWNoKCk7XG4gICAgICAgIC8vIGF0dGFjaCBnZW5lcmF0ZWQgc3R5bGUgc2hlZXQgdG8gcGFnZVxuICAgICAgICBqc3MuY3JlYXRlU3R5bGVTaGVldCh7XG4gICAgICAgICAgICAnQGdsb2JhbCc6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0U3R5bGVzKSwgdGhpcy5jdXN0b21TdHlsZXMpXG4gICAgICAgIH0pLmF0dGFjaCgpO1xuICAgIH1cbiAgICBhcHBseVBhbGV0dGUocGFsZXR0ZSkge1xuICAgICAgICBjb25zdCByb290RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJzpyb290Jyk7XG4gICAgICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCctLWNvbG9yMCcsIHBhbGV0dGVbJy0tY29sb3IwJ10pO1xuICAgICAgICByb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1jb2xvcjEnLCBwYWxldHRlWyctLWNvbG9yMSddKTtcbiAgICAgICAgcm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJy0tY29sb3IyJywgcGFsZXR0ZVsnLS1jb2xvcjInXSk7XG4gICAgICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCctLWNvbG9yMycsIHBhbGV0dGVbJy0tY29sb3IzJ10pO1xuICAgICAgICByb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1jb2xvcjQnLCBwYWxldHRlWyctLWNvbG9yNCddKTtcbiAgICAgICAgcm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJy0tY29sb3I1JywgcGFsZXR0ZVsnLS1jb2xvcjUnXSk7XG4gICAgICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCctLWNvbG9yNicsIHBhbGV0dGVbJy0tY29sb3I2J10pO1xuICAgICAgICByb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1jb2xvcjcnLCBwYWxldHRlWyctLWNvbG9yNyddKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBwbGF5ZXJzIGNvbG9yIHZhcmlhYmxlc1xuICAgICAqIEBwYXJhbSBpc0xpZ2h0TW9kZSAtIHNob3VsZCB3ZSB1c2UgYSBsaWdodCBvciBkYXJrIGNvbG9yIHNjaGVtZVxuICAgICAqL1xuICAgIHNldENvbG9yTW9kZShpc0xpZ2h0TW9kZSkge1xuICAgICAgICBpZiAoaXNMaWdodE1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlQYWxldHRlKHRoaXMubGlnaHRNb2RlUGFsZXR0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5UGFsZXR0ZSh0aGlzLmRhcmtNb2RlUGFsZXR0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QaXhlbFN0cmVhbWluZ0FwcGxpY2F0aW9uU3R5bGVzLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBGdWxsU2NyZWVuSWNvbiB9IGZyb20gJy4vRnVsbHNjcmVlbkljb24nO1xuaW1wb3J0IHsgU2V0dGluZ3NJY29uIH0gZnJvbSAnLi9TZXR0aW5nc0ljb24nO1xuaW1wb3J0IHsgU3RhdHNJY29uIH0gZnJvbSAnLi9TdGF0c0ljb24nO1xuaW1wb3J0IHsgWFJJY29uIH0gZnJvbSAnLi9YUkljb24nO1xuaW1wb3J0IHsgV2ViWFJDb250cm9sbGVyIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdmcm9udGVuZC11ZTUuNic7XG5pbXBvcnQgeyBVSUVsZW1lbnRDcmVhdGlvbk1vZGUgfSBmcm9tICcuLi9VSS9VSUNvbmZpZ3VyYXRpb25UeXBlcyc7XG4vLyBJZiB0aGVyZSBpc24ndCBhIHR5cGUgcHJvdmlkZWQsIGRlZmF1bHQgYmVoYXZpb3VyIGlzIHRvIGNyZWF0ZSB0aGUgZWxlbWVudC5cbmZ1bmN0aW9uIHNob3VsZENyZWF0ZUJ1dHRvbih0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgPT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHR5cGUuY3JlYXRpb25Nb2RlID09PSBVSUVsZW1lbnRDcmVhdGlvbk1vZGUuQ3JlYXRlRGVmYXVsdEVsZW1lbnQ7XG59XG4vKipcbiAqIEVsZW1lbnQgY29udGFpbmluZyB2YXJpb3VzIGNvbnRyb2xzIGxpa2Ugc3RhdHMsIHNldHRpbmdzLCBmdWxsc2NyZWVuLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJvbHMge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCB0aGUgY29udHJvbHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIGlmICghY29uZmlnIHx8IHNob3VsZENyZWF0ZUJ1dHRvbihjb25maWcuc3RhdHNCdXR0b25UeXBlKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0c0ljb24gPSBuZXcgU3RhdHNJY29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25maWcgfHwgc2hvdWxkQ3JlYXRlQnV0dG9uKGNvbmZpZy5zZXR0aW5nc0J1dHRvblR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzSWNvbiA9IG5ldyBTZXR0aW5nc0ljb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbmZpZyB8fCBzaG91bGRDcmVhdGVCdXR0b24oY29uZmlnLmZ1bGxzY3JlZW5CdXR0b25UeXBlKSkge1xuICAgICAgICAgICAgdGhpcy5mdWxsc2NyZWVuSWNvbiA9IG5ldyBGdWxsU2NyZWVuSWNvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29uZmlnIHx8IHNob3VsZENyZWF0ZUJ1dHRvbihjb25maWcueHJJY29uVHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMueHJJY29uID0gbmV3IFhSSWNvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZWxlbWVudCBjb250YWluaW5nIHRoZSBjb250cm9scy5cbiAgICAgKi9cbiAgICBnZXQgcm9vdEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5pZCA9ICdjb250cm9scyc7XG4gICAgICAgICAgICBpZiAodGhpcy5mdWxsc2NyZWVuSWNvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuZnVsbHNjcmVlbkljb24ucm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3NJY29uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zZXR0aW5nc0ljb24ucm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHNJY29uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zdGF0c0ljb24ucm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMueHJJY29uKSB7XG4gICAgICAgICAgICAgICAgdm9pZCBXZWJYUkNvbnRyb2xsZXIuaXNTZXNzaW9uU3VwcG9ydGVkKCdpbW1lcnNpdmUtdnInKS50aGVuKChzdXBwb3J0ZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy54ckljb24ucm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgdGhpcy5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290RWxlbWVudDtcbiAgICB9XG4gICAgaGFuZGxlRnVsbHNjcmVlbkNoYW5nZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBpc0luRnVsbHNjcmVlbiA9ICEhZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQ7XG4gICAgICAgIGlmIChpc0luRnVsbHNjcmVlbiAmJiAoKF9hID0gdGhpcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oaWRlQ29udHJvbHNJbkZ1bGxzY3JlZW4pKSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29udHJvbHMuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nZnJvbnRlbmQtdWU1LjYnO1xuaW1wb3J0IHsgU3RhdHNTZWN0aW9ucyB9IGZyb20gJy4vVUlDb25maWd1cmF0aW9uVHlwZXMnO1xuLyoqXG4gKiBEYXRhQ2hhbm5lbCBMYXRlbmN5IHRlc3QgVUkgZWxlbWVudHMgYW5kIHJlc3VsdHMgaGFuZGxpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhQ2hhbm5lbExhdGVuY3lUZXN0IHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ1dHRvbiBjb250YWluaW5nIHRoZSBzdGF0cyBpY29uLlxuICAgICAqL1xuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWN0aW9uJyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzZXR0aW5nc0NvbnRhaW5lcicpO1xuICAgICAgICAgICAgLy8gbWFrZSBoZWFkaW5nXG4gICAgICAgICAgICBjb25zdCBoZWFkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBoZWFkaW5nLmlkID0gJ2RhdGFDaGFubmVsTGF0ZW5jeVRlc3RIZWFkZXInO1xuICAgICAgICAgICAgaGVhZGluZy5jbGFzc0xpc3QuYWRkKCdzZXR0aW5ncy10ZXh0Jyk7XG4gICAgICAgICAgICBoZWFkaW5nLmNsYXNzTGlzdC5hZGQoJ3NldHRpbmdzSGVhZGVyJyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5hcHBlbmRDaGlsZChoZWFkaW5nKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRpbmdUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBoZWFkaW5nVGV4dC5pbm5lckhUTUwgPSBTdGF0c1NlY3Rpb25zLkRhdGFDaGFubmVsTGF0ZW5jeVRlc3Q7XG4gICAgICAgICAgICBoZWFkaW5nLmFwcGVuZENoaWxkKGhlYWRpbmdUZXh0KTtcbiAgICAgICAgICAgIGhlYWRpbmcuYXBwZW5kQ2hpbGQodGhpcy5sYXRlbmN5VGVzdEJ1dHRvbik7XG4gICAgICAgICAgICAvLyBtYWtlIHRlc3QgcmVzdWx0cyBlbGVtZW50XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzUGFyZW50RWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgcmVzdWx0c1BhcmVudEVsZW0uaWQgPSAnZGF0YUNoYW5uZWxMYXRlbmN5VGVzdENvbnRhaW5lcic7XG4gICAgICAgICAgICByZXN1bHRzUGFyZW50RWxlbS5jbGFzc0xpc3QuYWRkKCdkLW5vbmUnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHJlc3VsdHNQYXJlbnRFbGVtKTtcbiAgICAgICAgICAgIHJlc3VsdHNQYXJlbnRFbGVtLmFwcGVuZENoaWxkKHRoaXMubGF0ZW5jeVRlc3RSZXN1bHRzRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RFbGVtZW50O1xuICAgIH1cbiAgICBnZXQgbGF0ZW5jeVRlc3RSZXN1bHRzRWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sYXRlbmN5VGVzdFJlc3VsdHNFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdFJlc3VsdHNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdFJlc3VsdHNFbGVtZW50LmlkID0gJ2RhdGFDaGFubmVsTGF0ZW5jeVN0YXRzUmVzdWx0cyc7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdFJlc3VsdHNFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ1N0YXRzUmVzdWx0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhdGVuY3lUZXN0UmVzdWx0c0VsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBsYXRlbmN5VGVzdEJ1dHRvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24udHlwZSA9ICdidXR0b24nO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24udmFsdWUgPSAnUnVuIFRlc3QnO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24uaWQgPSAnYnRuLXN0YXJ0LWRhdGEtY2hhbm5lbC1sYXRlbmN5LXRlc3QnO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24uY2xhc3NMaXN0LmFkZCgnc3RyZWFtVG9vbHMtYnV0dG9uJyk7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdidG4tZmxhdCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9wdWxhdGUgdGhlIFVJIGJhc2VkIG9uIHRoZSBsYXRlbmN5IHRlc3QncyByZXN1bHRzLlxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBUaGUgbGF0ZW5jeSB0ZXN0IHJlc3VsdHMuXG4gICAgICovXG4gICAgaGFuZGxlVGVzdFJlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgTG9nZ2VyLkluZm8oSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayB3ZSBoYXZlIHJlc3VsdHMsIE5hTiB3b3VsZCBtZWFuIHRoYXQgVUUgdmVyc2lvbiB3ZSB0YWxrIHRvIGRvZXNuJ3Qgc3VwcG9ydCBvdXIgdGVzdFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzTmFOKHJlc3VsdC5kYXRhQ2hhbm5lbFJ0dCkpIHtcbiAgICAgICAgICAgIHRoaXMubGF0ZW5jeVRlc3RSZXN1bHRzRWxlbWVudC5pbm5lckhUTUwgPSAnPGRpdj5Ob3Qgc3VwcG9ydGVkPC9kaXY+JztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGF0ZW5jeVN0YXRzSW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGxhdGVuY3lTdGF0c0lubmVySFRNTCArPSAnPGRpdj5EYXRhIGNoYW5uZWwgUlRUIChtcyk6ICcgKyByZXN1bHQuZGF0YUNoYW5uZWxSdHQgKyAnPC9kaXY+JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlcGFyYXRlIHBhdGggdGltZSBkaXNjb3Zlcnkgd29ya3Mgb25seSB3aGVuIFVFIGFuZCBQbGF5ZXIgY2xvY2tzIGhhdmUgYmVlbiBzeW5jaHJvbml6ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocmVzdWx0LnBsYXllclRvU3RyZWFtZXJUaW1lID49IDAgJiYgcmVzdWx0LnN0cmVhbWVyVG9QbGF5ZXJUaW1lID49IDApIHtcbiAgICAgICAgICAgIGxhdGVuY3lTdGF0c0lubmVySFRNTCArPVxuICAgICAgICAgICAgICAgICc8ZGl2PlBsYXllciB0byBTdHJlYW1lciBwYXRoIChtcyk6ICcgKyByZXN1bHQucGxheWVyVG9TdHJlYW1lclRpbWUgKyAnPC9kaXY+JztcbiAgICAgICAgICAgIGxhdGVuY3lTdGF0c0lubmVySFRNTCArPVxuICAgICAgICAgICAgICAgICc8ZGl2PlN0cmVhbWVyIHRvIFBsYXllciBwYXRoIChtcyk6ICcgKyByZXN1bHQuc3RyZWFtZXJUb1BsYXllclRpbWUgKyAnPC9kaXY+JztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhdGVuY3lUZXN0UmVzdWx0c0VsZW1lbnQuaW5uZXJIVE1MID0gbGF0ZW5jeVN0YXRzSW5uZXJIVE1MO1xuICAgICAgICAvL3NldHVwIGJ1dHRvbiB0byBkb3dubG9hZCB0aGUgZGV0YWlsZWQgcmVzdWx0c1xuICAgICAgICBjb25zdCBkb3dubG9hZEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGRvd25sb2FkQnV0dG9uLnR5cGUgPSAnYnV0dG9uJztcbiAgICAgICAgZG93bmxvYWRCdXR0b24udmFsdWUgPSAnRG93bmxvYWQnO1xuICAgICAgICBkb3dubG9hZEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdzdHJlYW1Ub29scy1idXR0b24nKTtcbiAgICAgICAgZG93bmxvYWRCdXR0b24uY2xhc3NMaXN0LmFkZCgnYnRuLWZsYXQnKTtcbiAgICAgICAgZG93bmxvYWRCdXR0b24ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBuZXcgQmxvYihbcmVzdWx0LmV4cG9ydExhdGVuY3lBc0NTVigpXSwgeyB0eXBlOiAndGV4dC9wbGFpbicgfSk7XG4gICAgICAgICAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcbiAgICAgICAgICAgIGEuaHJlZiA9IHVybDtcbiAgICAgICAgICAgIGEuZG93bmxvYWQgPSAnZGF0YV9jaGFubmVsX2xhdGVuY3lfdGVzdF9yZXN1bHRzLmNzdic7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO1xuICAgICAgICAgICAgYS5jbGljaygpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGF0ZW5jeVRlc3RSZXN1bHRzRWxlbWVudC5hcHBlbmRDaGlsZChkb3dubG9hZEJ1dHRvbik7XG4gICAgfVxuICAgIGhhbmRsZVRlc3RTdGFydCgpIHtcbiAgICAgICAgdGhpcy5sYXRlbmN5VGVzdFJlc3VsdHNFbGVtZW50LmlubmVySFRNTCA9ICc8ZGl2PlRlc3QgaW4gcHJvZ3Jlc3M8L2Rpdj4nO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFDaGFubmVsTGF0ZW5jeVRlc3QuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIEV2ZW50IGZpcmVkIHdoZW4gXCJDb25maXJtXCIgYnV0dG9uIGlzIGNsaWNrZWRcbmV4cG9ydCBjbGFzcyBFZGl0Q29uZmlybWVkRXZlbnQgZXh0ZW5kcyBDdXN0b21FdmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlybWVkVGV4dCkge1xuICAgICAgICBzdXBlcignZWRpdENvbmZpcm1lZCcsIHtcbiAgICAgICAgICAgIGRldGFpbDogY29uZmlybWVkVGV4dCxcbiAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpcm1lZFRleHQgPSBjb25maXJtZWRUZXh0O1xuICAgIH1cbn1cbi8qKlxuICogQSBtb2RhbCB0aGF0IGlzIHNob3duIHdoZW4gYSBVRSB3aWRnZXQgaXMgdG91Y2hlZCBvbiBtb2JpbGUuXG4gKiBvclxuICogQSBoaWRkZW4gKG9mZnNjcmVlbikgaW5wdXQgZmllbGQgdGhhdCBpcyBzaG93biBvbiBub24tdG91Y2ggZGV2aWNlcyAoZS5nLiBEZXNrdG9wKVxuICogd2hlbiBhIFVFIHdpZGdldCBpcyBjbGlja2VkLiBUaGUgaGlkZGVuIHRleHQgZmllbGQgaXMgdXNlZCBzbyBub24tbGF0aW4gY2hhcmFjdGVyXG4gKiBpbnB1dCBjYW4gYmUgY29tcG9zZWQgdXNpbmcgSU1FIGFzc2lzdGFuY2UgKHdoaWNoIHJlcXVpcmVzIGFuIGlucHV0IGZpZWxkKS5cbiAqXG4gKiBUaGUgcmVhc29uIHRoaXMgbW9kYWwgaXMgcmVxdWlyZWQgaXMgdGhhdCBvbiBtb2JpbGUgdHlwaW5nIHVzZXNcbiAqIGFuIG9uLXNjcmVlbiBrZXlib2FyZCwgd2hpY2ggcmVxdWlyZXMgYSB2YWxpZCBpbnB1dCB0ZXh0IGFyZWEvaW5wdXRcbiAqIHRvIGJlIGZvY3VzZWQgdG8gc3VtbW9uIGl0LiBUaGVyZWZvcmUgd2Ugc2hvdyB0aGlzIG1vZGFsIHdoaWNoIGhhc1xuICogdGhlIGNvbnRlbnRzIG9mIHRoZSBVRSB3aWRnZXQsIHBvcHVsYXRlIGl0cyB0ZXh0IGFyZWEgd2l0aCB0aGUgY29udGVudHNcbiAqIG9mIHRoZSBVRSB3aWRnZXQsIHRoZW4gZm9jdXMgdGhlIHRleHQgYXJlYSB0byBmaW5hbGx5IHN1bW1vbiB0aGUgbmF0aXZlXG4gKiBvbi1zY3JlZW4ga2V5Ym9hcmQuXG4gKlxuICogVGhlIG1vZGFsIGFsc28gY29udGFpbnM6XG4gKiAxKSBBIGNhbmNlbCBidXR0b24gLSB0aGlzIGNsb3NlcyB0aGUgbW9kYWxcbiAqIDIpIEEgY29uZmlybSBidXR0b24gLSB0aGlzIHN1Ym1pdHMgdGhlIGVkaXQgYmFjayB0byB0aGUgVUUgc2lkZVxuICovXG5leHBvcnQgY2xhc3MgRWRpdFRleHRNb2RhbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gdGhpcy5yb290RWxlbWVudDtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50VGFyZ2V0KCk7XG4gICAgfVxuICAgIC8vIEJpbmQgdG8gdGhpcyBpZiB5b3Ugd2FudCB0byBoYW5kbGUgZWRpdCBjb25maXJtZWRcbiAgICBnZXQgZXZlbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzO1xuICAgIH1cbiAgICBzaG93TW9kYWwoZXhpc3RpbmdUZXh0QXJlYUNvbnRlbnRzKSB7XG4gICAgICAgIGlmIChleGlzdGluZ1RleHRBcmVhQ29udGVudHMpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgbnVsbCB0ZXJtaW5hdG9ycyBmcm9tIHRoZSBzdHJpbmdcbiAgICAgICAgICAgIGV4aXN0aW5nVGV4dEFyZWFDb250ZW50cyA9IGV4aXN0aW5nVGV4dEFyZWFDb250ZW50cy5yZXBsYWNlKC9cXDAvZywgJycpO1xuICAgICAgICAgICAgdGhpcy50ZXh0QXJlYS52YWx1ZSA9IGV4aXN0aW5nVGV4dEFyZWFDb250ZW50cztcbiAgICAgICAgfVxuICAgICAgICAvLyBCcmluZyBmb2N1cyB0byB0aGUgdGV4dCBhcmVhLlxuICAgICAgICAvLyBUaGlzIHdpbGwgbWFrZSB0aGUgb24tc2NyZWVuIGtleWJvYXJkIHNob3cgaWYgd2UgYXJlXG4gICAgICAgIC8vIGEgZGV2aWNlIHRoYXQgaGFzIGEgbmF0aXZlIG9uLXNjcmVlbiBrZXlib2FyZC5cbiAgICAgICAgLy8gSWYgd2UgYXJlIG9uIGEgbm9uLXRvdWNoIGRldmljZSB0aGlzIHdpbGwgZ2l2ZSBJTUUgYSB2YWxpZFxuICAgICAgICAvLyBpbnB1dCBmaWVsZCB0byB3b3JrIHdpdGguXG4gICAgICAgIHRoaXMudGV4dEFyZWEuZm9jdXMoKTtcbiAgICAgICAgLy8gUHV0IGN1cnNvciB0byB0aGUgZW5kIG9mIHRoZSB0ZXh0YXJlYVxuICAgICAgICB0aGlzLnRleHRBcmVhLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy50ZXh0QXJlYS52YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcm9vdCBlbGVtZW50IHRoYXQgY29udGFpbnMgZWl0aGVyIHRoZSBtb2RhbCAobW9iaWxlKSBvciBoaWRkZW4gdGV4dCBpbnB1dCAoZGVza3RvcClcbiAgICAgKi9cbiAgICBnZXQgcm9vdEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdtb2RhbCcpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5pbm5lck1vZGFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBpbm5lck1vZGFsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lubmVyTW9kYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2lubmVyTW9kYWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX2lubmVyTW9kYWwuY2xhc3NMaXN0LmFkZCgnaW5uZXJNb2RhbCcpO1xuICAgICAgICAgICAgdGhpcy5faW5uZXJNb2RhbC5hcHBlbmRDaGlsZCh0aGlzLmVkaXRUZXh0SGVhZGluZyk7XG4gICAgICAgICAgICB0aGlzLl9pbm5lck1vZGFsLmFwcGVuZENoaWxkKHRoaXMudGV4dEFyZWEpO1xuICAgICAgICAgICAgdGhpcy5faW5uZXJNb2RhbC5hcHBlbmRDaGlsZCh0aGlzLm1vZGFsQnRuQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXJNb2RhbDtcbiAgICB9XG4gICAgZ2V0IGVkaXRUZXh0SGVhZGluZygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9lZGl0VGV4dEhlYWRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2VkaXRUZXh0SGVhZGluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gyJyk7XG4gICAgICAgICAgICB0aGlzLl9lZGl0VGV4dEhlYWRpbmcuaW5uZXJUZXh0ID0gJ0VkaXQgVGV4dCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VkaXRUZXh0SGVhZGluZztcbiAgICB9XG4gICAgZ2V0IHRleHRBcmVhKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHRBcmVhKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0QXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgICAgICAgICB0aGlzLl90ZXh0QXJlYS5jbGFzc0xpc3QuYWRkKCdmb3JtLWNvbnRyb2wnKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHRBcmVhLmNsYXNzTGlzdC5hZGQoJ21vZGFsVGV4dEFyZWEnKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHRBcmVhLnRpdGxlID0gJ0VkaXQgVGV4dCBBcmVhJztcbiAgICAgICAgICAgIHRoaXMuX3RleHRBcmVhLnBsYWNlaG9sZGVyID0gJ1VFIHRleHQgd2lkZ2V0IHZhbHVlIGhlcmUuLi4nO1xuICAgICAgICAgICAgLy8gV2hlbiBrZXlib2FyZCBpcyB0eXBlZCBpbnRvIHdlIHdhbnQgdG8gZW5zdXJlIGtleXMgYXJlIG5vdCBzZW50IGJhY2sgdG8gVUUgdW50aWwgd2UgY29uZmlybS5cbiAgICAgICAgICAgIHRoaXMudGV4dEFyZWEuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50ZXh0QXJlYS5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRleHRBcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50ZXh0QXJlYS5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRBcmVhO1xuICAgIH1cbiAgICBnZXQgbW9kYWxCdG5Db250YWluZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbW9kYWxCdG5Db250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX21vZGFsQnRuQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9tb2RhbEJ0bkNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdtb2RhbEJ0bkNvbnRhaW5lcicpO1xuICAgICAgICAgICAgdGhpcy5fbW9kYWxCdG5Db250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jYW5jZWxCdG4pO1xuICAgICAgICAgICAgdGhpcy5fbW9kYWxCdG5Db250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jb25maXJtQnRuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbW9kYWxCdG5Db250YWluZXI7XG4gICAgfVxuICAgIGdldCBjYW5jZWxCdG4oKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FuY2VsQnRuKSB7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbEJ0bi5jbGFzc0xpc3QuYWRkKCdidG4tZmxhdCcpO1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsQnRuLmlubmVyVGV4dCA9ICdDYW5jZWwnO1xuICAgICAgICAgICAgLy8gV2hlbiBjYW5jZWwgaXMgY2xpY2tlZCwgcmVtb3ZlIHRoaXMgbW9kYWwgZnJvbSB0aGUgRE9NXG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3RFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgY2xpY2svdGFwIGRvZXMgbm90IGdvIGJhY2sgdG8gVUVcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5jZWxCdG47XG4gICAgfVxuICAgIGdldCBjb25maXJtQnRuKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpcm1CdG4pIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpcm1CdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpcm1CdG4uY2xhc3NMaXN0LmFkZCgnYnRuLWZsYXQnKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpcm1CdG4uaW5uZXJUZXh0ID0gJ0NvbmZpcm0nO1xuICAgICAgICAgICAgLy8gV2hlbiBjb25maXJtIGlzIGNsaWNrZWQsIHJlbW92ZSBmcm9tIERPTSBhbmQgc2VuZCB0aGUgY29udGVudHMgb2YgdGV4dGFyZWEgdG8gVUVcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpcm1CdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KG5ldyBFZGl0Q29uZmlybWVkRXZlbnQodGhpcy50ZXh0QXJlYS52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdEVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBjbGljay90YXAgZG9lcyBub3QgZ28gYmFjayB0byBVRVxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpcm1CdG47XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RWRpdFRleHRNb2RhbC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbiBlbGVtZW50IChpLmUuIGJ1dHRvbikgdGhhdCwgd2hlbiBjbGlja2VkLCB3aWxsIHRvZ2dsZSBmdWxsc2NyZWVuIG9mIGEgZ2l2ZW4gZWxlbWVudC5cbiAqIENhbiBiZSBpbml0aWFsaXplZCB3aXRoIGFueSBIVE1MRWxlbWVudCwgaWYgaXQgaXMgc2V0IGFzIHJvb3RFbGVtZW50IGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bGxTY3JlZW5JY29uQmFzZSB7XG4gICAgZ2V0IHJvb3RFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gICAgfVxuICAgIHNldCByb290RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQub25jbGljayA9ICgpID0+IHRoaXMudG9nZ2xlRnVsbHNjcmVlbigpO1xuICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmlzRnVsbHNjcmVlbiA9IGZhbHNlO1xuICAgICAgICAvLyBzZXQgdXAgdGhlIGZ1bGwgc2NyZWVuIGV2ZW50c1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgKCkgPT4gdGhpcy5vbkZ1bGxzY3JlZW5DaGFuZ2UoKSwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3pmdWxsc2NyZWVuY2hhbmdlJywgKCkgPT4gdGhpcy5vbkZ1bGxzY3JlZW5DaGFuZ2UoKSwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgKCkgPT4gdGhpcy5vbkZ1bGxzY3JlZW5DaGFuZ2UoKSwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdNU0Z1bGxzY3JlZW5DaGFuZ2UnLCAoKSA9PiB0aGlzLm9uRnVsbHNjcmVlbkNoYW5nZSgpLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBkb2N1bWVudCBvciBmdWxsc2NyZWVuRWxlbWVudCBmdWxsc2NyZWVuLlxuICAgICAqL1xuICAgIHRvZ2dsZUZ1bGxzY3JlZW4oKSB7XG4gICAgICAgIC8vIGlmIGFscmVhZHkgZnVsbCBzY3JlZW47IGV4aXRcbiAgICAgICAgLy8gZWxzZSBnbyBmdWxsc2NyZWVuXG4gICAgICAgIGlmIChkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCB8fFxuICAgICAgICAgICAgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQgfHxcbiAgICAgICAgICAgIGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8XG4gICAgICAgICAgICBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbikge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvY3VtZW50Lm1zRXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5mdWxsc2NyZWVuRWxlbWVudDtcbiAgICAgICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxlbWVudC5tb3pSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubW96UmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbGVtZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnQud2Via2l0RW50ZXJGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC53ZWJraXRFbnRlckZ1bGxzY3JlZW4oKTsgLy9mb3IgaXBob25lIHRoaXMgY29kZSB3b3JrZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uRnVsbHNjcmVlbkNoYW5nZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBmdWxsc2NyZWVuIGJ1dHRvbiBvbiBjaGFuZ2VcbiAgICAgKi9cbiAgICBvbkZ1bGxzY3JlZW5DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuaXNGdWxsc2NyZWVuID1cbiAgICAgICAgICAgIGRvY3VtZW50LndlYmtpdElzRnVsbFNjcmVlbiB8fFxuICAgICAgICAgICAgICAgIGRvY3VtZW50Lm1vekZ1bGxTY3JlZW4gfHxcbiAgICAgICAgICAgICAgICAoZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudCAmJiBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50ICE9PSBudWxsKSB8fFxuICAgICAgICAgICAgICAgIChkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCAmJiBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCAhPT0gbnVsbCk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBGdWxsU2NyZWVuSWNvbkJhc2UgdGhhdCB1c2VzIGFuIGV4dGVybmFsbHlcbiAqIHByb3ZpZGVkIEhUTUxFbGVtZW50IGZvciB0b2dnbGluZyBmdWxsIHNjcmVlbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bGxTY3JlZW5JY29uRXh0ZXJuYWwgZXh0ZW5kcyBGdWxsU2NyZWVuSWNvbkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGV4dGVybmFsQnV0dG9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQgPSBleHRlcm5hbEJ1dHRvbjtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IGZ1bGxzY3JlZW4gaWNvbiB0aGF0IGNvbnRhaW5zIGEgYnV0dG9uIGFuZCBzdmdzIGZvciBlYWNoIHN0YXRlLlxuICovXG5leHBvcnQgY2xhc3MgRnVsbFNjcmVlbkljb24gZXh0ZW5kcyBGdWxsU2NyZWVuSWNvbkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBjb25zdCBjcmVhdGVkQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGNyZWF0ZWRCdXR0b24udHlwZSA9ICdidXR0b24nO1xuICAgICAgICBjcmVhdGVkQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ1VpVG9vbCcpO1xuICAgICAgICBjcmVhdGVkQnV0dG9uLmlkID0gJ2Z1bGxzY3JlZW4tYnRuJztcbiAgICAgICAgY3JlYXRlZEJ1dHRvbi5hcHBlbmRDaGlsZCh0aGlzLm1heGltaXplSWNvbik7XG4gICAgICAgIGNyZWF0ZWRCdXR0b24uYXBwZW5kQ2hpbGQodGhpcy5taW5pbWl6ZUljb24pO1xuICAgICAgICBjcmVhdGVkQnV0dG9uLmFwcGVuZENoaWxkKHRoaXMudG9vbHRpcFRleHQpO1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50ID0gY3JlYXRlZEJ1dHRvbjtcbiAgICB9XG4gICAgZ2V0IHRvb2x0aXBUZXh0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rvb2x0aXBUZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBUZXh0LmNsYXNzTGlzdC5hZGQoJ3Rvb2x0aXB0ZXh0Jyk7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwVGV4dC5pbm5lckhUTUwgPSAnRnVsbHNjcmVlbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rvb2x0aXBUZXh0O1xuICAgIH1cbiAgICBnZXQgbWF4aW1pemVJY29uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX21heGltaXplSWNvbikge1xuICAgICAgICAgICAgdGhpcy5fbWF4aW1pemVJY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgICAgICAgICAgIHRoaXMuX21heGltaXplSWNvbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaWQnLCAnbWF4aW1pemVJY29uJyk7XG4gICAgICAgICAgICB0aGlzLl9tYXhpbWl6ZUljb24uc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gnLCAnMHB4Jyk7XG4gICAgICAgICAgICB0aGlzLl9tYXhpbWl6ZUljb24uc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLCAnMHB4Jyk7XG4gICAgICAgICAgICB0aGlzLl9tYXhpbWl6ZUljb24uc2V0QXR0cmlidXRlTlMobnVsbCwgJ3ZpZXdCb3gnLCAnMCAwIDM4NC45NyAzODQuOTcnKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBzdmcgZ3JvdXAgZm9yIHRoZSBwYXRoc1xuICAgICAgICAgICAgY29uc3Qgc3ZnR3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2cnKTtcbiAgICAgICAgICAgIHN2Z0dyb3VwLmNsYXNzTGlzdC5hZGQoJ3N2Z0ljb24nKTtcbiAgICAgICAgICAgIHRoaXMuX21heGltaXplSWNvbi5hcHBlbmRDaGlsZChzdmdHcm91cCk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgcGF0aHMgZm9yIHRoZSBpY29uIGl0c2VsZiwgb25lIGZvciBlYWNoIGNvcm5lclxuICAgICAgICAgICAgY29uc3QgcGF0aDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3BhdGgnKTtcbiAgICAgICAgICAgIHBhdGgxLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ00zODQuOTcsMTIuMDNjMC02LjcxMy01LjMxNy0xMi4wMy0xMi4wMy0xMi4wM0gyNjQuODQ3Yy02LjgzMywwLTExLjkyMiw1LjM5LTExLjkzNCwxMi4yMjNjMCw2LjgyMSw1LjEwMSwxMS44MzgsMTEuOTM0LDExLjgzOGg5Ni4wNjJsLTAuMTkzLDk2LjUxOWMwLDYuODMzLDUuMTk3LDEyLjAzLDEyLjAzLDEyLjAzYzYuODMzLTAuMDEyLDEyLjAzLTUuMTk3LDEyLjAzLTEyLjAzbDAuMTkzLTEwOC4zNjljMC0wLjAzNi0wLjAxMi0wLjA2LTAuMDEyLTAuMDg0QzM4NC45NTgsMTIuMDksMzg0Ljk3LDEyLjA2NiwzODQuOTcsMTIuMDN6Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXRoMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncGF0aCcpO1xuICAgICAgICAgICAgcGF0aDIuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCAnTTEyMC40OTYsMEgxMi40MDNjLTAuMDM2LDAtMC4wNiwwLjAxMi0wLjA5NiwwLjAxMkMxMi4yODMsMC4wMTIsMTIuMjQ3LDAsMTIuMjIzLDBDNS41MSwwLDAuMTkyLDUuMzE3LDAuMTkyLDEyLjAzTDAsMTIwLjM5OWMwLDYuODMzLDUuMzksMTEuOTM0LDEyLjIyMywxMS45MzRjNi44MjEsMCwxMS44MzgtNS4xMDEsMTEuODM4LTExLjkzNGwwLjE5Mi05Ni4zMzloOTYuMjQyYzYuODMzLDAsMTIuMDMtNS4xOTcsMTIuMDMtMTIuMDNDMTMyLjUxNCw1LjE5NywxMjcuMzE3LDAsMTIwLjQ5NiwweicpO1xuICAgICAgICAgICAgY29uc3QgcGF0aDMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3BhdGgnKTtcbiAgICAgICAgICAgIHBhdGgzLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ00xMjAuMTIzLDM2MC45MDlIMjQuMDYxdi05Ni4yNDJjMC02LjgzMy01LjE5Ny0xMi4wMy0xMi4wMy0xMi4wM1MwLDI1Ny44MzMsMCwyNjQuNjY3djEwOC4wOTJjMCwwLjAzNiwwLjAxMiwwLjA2LDAuMDEyLDAuMDg0YzAsMC4wMzYtMC4wMTIsMC4wNi0wLjAxMiwwLjA5NmMwLDYuNzEzLDUuMzE3LDEyLjAzLDEyLjAzLDEyLjAzaDEwOC4wOTJjNi44MzMsMCwxMS45MjItNS4zOSwxMS45MzQtMTIuMjIzQzEzMi4wNTcsMzY1LjkyNiwxMjYuOTU2LDM2MC45MDksMTIwLjEyMywzNjAuOTA5eicpO1xuICAgICAgICAgICAgY29uc3QgcGF0aDQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3BhdGgnKTtcbiAgICAgICAgICAgIHBhdGg0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ00zNzIuNzQ3LDI1Mi45MTNjLTYuODMzLDAtMTEuODUsNS4xMDEtMTEuODM4LDExLjkzNHY5Ni4wNjJoLTk2LjI0MmMtNi44MzMsMC0xMi4wMyw1LjE5Ny0xMi4wMywxMi4wM3M1LjE5NywxMi4wMywxMi4wMywxMi4wM2gxMDguMDkyYzAuMDM2LDAsMC4wNi0wLjAxMiwwLjA4NC0wLjAxMmMwLjAzNi0wLjAxMiwwLjA2LDAuMDEyLDAuMDk2LDAuMDEyYzYuNzEzLDAsMTIuMDMtNS4zMTcsMTIuMDMtMTIuMDNWMjY0Ljg0N0MzODQuOTcsMjU4LjAxNCwzNzkuNTgsMjUyLjkxMywzNzIuNzQ3LDI1Mi45MTN6Jyk7XG4gICAgICAgICAgICBzdmdHcm91cC5hcHBlbmRDaGlsZChwYXRoMSk7XG4gICAgICAgICAgICBzdmdHcm91cC5hcHBlbmRDaGlsZChwYXRoMik7XG4gICAgICAgICAgICBzdmdHcm91cC5hcHBlbmRDaGlsZChwYXRoMyk7XG4gICAgICAgICAgICBzdmdHcm91cC5hcHBlbmRDaGlsZChwYXRoNCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21heGltaXplSWNvbjtcbiAgICB9XG4gICAgZ2V0IG1pbmltaXplSWNvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9taW5pbWl6ZUljb24pIHtcbiAgICAgICAgICAgIHRoaXMuX21pbmltaXplSWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG4gICAgICAgICAgICB0aGlzLl9taW5pbWl6ZUljb24uc2V0QXR0cmlidXRlTlMobnVsbCwgJ2lkJywgJ21pbmltaXplSWNvbicpO1xuICAgICAgICAgICAgdGhpcy5fbWluaW1pemVJY29uLnNldEF0dHJpYnV0ZU5TKG51bGwsICd4JywgJzBweCcpO1xuICAgICAgICAgICAgdGhpcy5fbWluaW1pemVJY29uLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5JywgJzBweCcpO1xuICAgICAgICAgICAgdGhpcy5fbWluaW1pemVJY29uLnNldEF0dHJpYnV0ZU5TKG51bGwsICd2aWV3Qm94JywgJzAgMCAzODUuMzMxIDM4NS4zMzEnKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBzdmcgZ3JvdXAgZm9yIHRoZSBwYXRoc1xuICAgICAgICAgICAgY29uc3Qgc3ZnR3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2cnKTtcbiAgICAgICAgICAgIHN2Z0dyb3VwLmNsYXNzTGlzdC5hZGQoJ3N2Z0ljb24nKTtcbiAgICAgICAgICAgIHRoaXMuX21pbmltaXplSWNvbi5hcHBlbmRDaGlsZChzdmdHcm91cCk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgcGF0aHMgZm9yIHRoZSBpY29uIGl0c2VsZiwgb25lIGZvciBlYWNoIGNvcm5lclxuICAgICAgICAgICAgY29uc3QgcGF0aDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3BhdGgnKTtcbiAgICAgICAgICAgIHBhdGgxLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ00yNjQuOTQzLDE1Ni42NjVoMTA4LjI3M2M2LjgzMywwLDExLjkzNC01LjM5LDExLjkzNC0xMi4yMTFjMC02LjgzMy01LjEwMS0xMS44NS0xMS45MzQtMTEuODM4aC05Ni4yNDJWMzYuMTgxYzAtNi44MzMtNS4xOTctMTIuMDMtMTIuMDMtMTIuMDNzLTEyLjAzLDUuMTk3LTEyLjAzLDEyLjAzdjEwOC4yNzNjMCwwLjAzNiwwLjAxMiwwLjA2LDAuMDEyLDAuMDg0YzAsMC4wMzYtMC4wMTIsMC4wNi0wLjAxMiwwLjA5NkMyNTIuOTEzLDE1MS4zNDcsMjU4LjIzLDE1Ni42NzcsMjY0Ljk0MywxNTYuNjY1eicpO1xuICAgICAgICAgICAgY29uc3QgcGF0aDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3BhdGgnKTtcbiAgICAgICAgICAgIHBhdGgyLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ00xMjAuMjkxLDI0LjI0N2MtNi44MjEsMC0xMS44MzgsNS4xMTMtMTEuODM4LDExLjkzNHY5Ni4yNDJIMTIuMDNjLTYuODMzLDAtMTIuMDMsNS4xOTctMTIuMDMsMTIuMDNjMCw2LjgzMyw1LjE5NywxMi4wMywxMi4wMywxMi4wM2gxMDguMjczYzAuMDM2LDAsMC4wNi0wLjAxMiwwLjA4NC0wLjAxMmMwLjAzNiwwLDAuMDYsMC4wMTIsMC4wOTYsMC4wMTJjNi43MTMsMCwxMi4wMy01LjMxNywxMi4wMy0xMi4wM1YzNi4xODFDMTMyLjUxNCwyOS4zNiwxMjcuMTI0LDI0LjI1OSwxMjAuMjkxLDI0LjI0N3onKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGgzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdwYXRoJyk7XG4gICAgICAgICAgICBwYXRoMy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsICdNMTIwLjM4NywyMjguNjY2SDEyLjExNWMtNi44MzMsMC4wMTItMTEuOTM0LDUuMzktMTEuOTM0LDEyLjIyM2MwLDYuODMzLDUuMTAxLDExLjg1LDExLjkzNCwxMS44MzhoOTYuMjQydjk2LjQyM2MwLDYuODMzLDUuMTk3LDEyLjAzLDEyLjAzLDEyLjAzYzYuODMzLDAsMTIuMDMtNS4xOTcsMTIuMDMtMTIuMDNWMjQwLjg3N2MwLTAuMDM2LTAuMDEyLTAuMDYtMC4wMTItMC4wODRjMC0wLjAzNiwwLjAxMi0wLjA2LDAuMDEyLTAuMDk2QzEzMi40MTgsMjMzLjk4MywxMjcuMSwyMjguNjY2LDEyMC4zODcsMjI4LjY2NnonKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGg0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdwYXRoJyk7XG4gICAgICAgICAgICBwYXRoNC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsICdNMzczLjMsMjI4LjY2NkgyNjUuMDI4Yy0wLjAzNiwwLTAuMDYsMC4wMTItMC4wODQsMC4wMTJjLTAuMDM2LDAtMC4wNi0wLjAxMi0wLjA5Ni0wLjAxMmMtNi43MTMsMC0xMi4wMyw1LjMxNy0xMi4wMywxMi4wM3YxMDguMjczYzAsNi44MzMsNS4zOSwxMS45MjIsMTIuMjIzLDExLjkzNGM2LjgyMSwwLjAxMiwxMS44MzgtNS4xMDEsMTEuODM4LTExLjkyMnYtOTYuMjQySDM3My4zYzYuODMzLDAsMTIuMDMtNS4xOTcsMTIuMDMtMTIuMDNTMzgwLjEzNCwyMjguNjc4LDM3My4zLDIyOC42NjZ6Jyk7XG4gICAgICAgICAgICBzdmdHcm91cC5hcHBlbmRDaGlsZChwYXRoMSk7XG4gICAgICAgICAgICBzdmdHcm91cC5hcHBlbmRDaGlsZChwYXRoMik7XG4gICAgICAgICAgICBzdmdHcm91cC5hcHBlbmRDaGlsZChwYXRoMyk7XG4gICAgICAgICAgICBzdmdHcm91cC5hcHBlbmRDaGlsZChwYXRoNCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21pbmltaXplSWNvbjtcbiAgICB9XG4gICAgb25GdWxsc2NyZWVuQ2hhbmdlKCkge1xuICAgICAgICBzdXBlci5vbkZ1bGxzY3JlZW5DaGFuZ2UoKTtcbiAgICAgICAgY29uc3QgbWluaW1pemUgPSB0aGlzLm1pbmltaXplSWNvbjtcbiAgICAgICAgY29uc3QgbWF4aW1pemUgPSB0aGlzLm1heGltaXplSWNvbjtcbiAgICAgICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICBtaW5pbWl6ZS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgICAgICAvL2lvcyBkaXNhcHBlYXJpbmcgc3ZnIGZpeFxuICAgICAgICAgICAgbWluaW1pemUuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCAwKSc7XG4gICAgICAgICAgICBtYXhpbWl6ZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWluaW1pemUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIG1heGltaXplLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcbiAgICAgICAgICAgIC8vaW9zIGRpc2FwcGVhcmluZyBzdmcgZml4XG4gICAgICAgICAgICBtYXhpbWl6ZS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKDAsIDApJztcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZ1bGxzY3JlZW5JY29uLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIEEgYnV0dG9uIHdpdGggYSB0ZXh0IGxhYmVsIGJlc2lkZSBpdC5cbiAqL1xuZXhwb3J0IGNsYXNzIExhYmVsbGVkQnV0dG9uIHtcbiAgICBjb25zdHJ1Y3RvcihsYWJlbCwgYnV0dG9uVGV4dCkge1xuICAgICAgICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xuICAgICAgICB0aGlzLl9idXR0b25UZXh0ID0gYnV0dG9uVGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgY2xpY2sgbGlzdGVuZXIgdG8gdGhlIGJ1dHRvbiBlbGVtZW50LlxuICAgICAqL1xuICAgIGFkZE9uQ2xpY2tMaXN0ZW5lcihvbkNsaWNrRnVuYykge1xuICAgICAgICB0aGlzLmJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2tGdW5jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBIVE1MSW5wdXRFbGVtZW50IGZvciB0aGUgYnV0dG9uLlxuICAgICAqL1xuICAgIGdldCBidXR0b24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fYnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLl9idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgdGhpcy5fYnV0dG9uLnR5cGUgPSAnYnV0dG9uJztcbiAgICAgICAgICAgIHRoaXMuX2J1dHRvbi52YWx1ZSA9IHRoaXMuX2J1dHRvblRleHQ7XG4gICAgICAgICAgICB0aGlzLl9idXR0b24uY2xhc3NMaXN0LmFkZCgnb3ZlcmxheS1idXR0b24nKTtcbiAgICAgICAgICAgIHRoaXMuX2J1dHRvbi5jbGFzc0xpc3QuYWRkKCdidG4tZmxhdCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9idXR0b247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFJldHVybiBvciBjcmVhdGVzIGEgSFRNTCBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyB0aGlzIHNldHRpbmcgaW4gdGhlIERPTS5cbiAgICAgKi9cbiAgICBnZXQgcm9vdEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSByb290IGRpdiB3aXRoIFwic2V0dGluZ1wiIGNzcyBjbGFzc1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3NldHRpbmcnKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBkaXYgZWxlbWVudCB0byBjb250YWluIG91ciBzZXR0aW5nJ3MgdGV4dFxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NUZXh0RWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgc2V0dGluZ3NUZXh0RWxlbS5pbm5lclRleHQgPSB0aGlzLl9sYWJlbDtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHNldHRpbmdzVGV4dEVsZW0pO1xuICAgICAgICAgICAgLy8gY3JlYXRlIGxhYmVsIGVsZW1lbnQgdG8gd3JhcCBvdXQgaW5wdXQgdHlwZVxuICAgICAgICAgICAgY29uc3Qgd3JhcHBlckxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgICAgIHdyYXBwZXJMYWJlbC5jbGFzc0xpc3QuYWRkKCdidG4tb3ZlcmxheScpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQod3JhcHBlckxhYmVsKTtcbiAgICAgICAgICAgIHdyYXBwZXJMYWJlbC5hcHBlbmRDaGlsZCh0aGlzLmJ1dHRvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RFbGVtZW50O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxhYmVsbGVkQnV0dG9uLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2Zyb250ZW5kLXVlNS42JztcbmltcG9ydCB7IFN0YXRzU2VjdGlvbnMgfSBmcm9tICcuL1VJQ29uZmlndXJhdGlvblR5cGVzJztcbi8qKlxuICogTGF0ZW5jeSB0ZXN0IFVJIGVsZW1lbnRzIGFuZCByZXN1bHRzIGhhbmRsaW5nLlxuICovXG5leHBvcnQgY2xhc3MgTGF0ZW5jeVRlc3Qge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGhlIGJ1dHRvbiBjb250YWluaW5nIHRoZSBzdGF0cyBpY29uLlxuICAgICAqL1xuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWN0aW9uJyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzZXR0aW5nc0NvbnRhaW5lcicpO1xuICAgICAgICAgICAgLy8gbWFrZSBoZWFkaW5nXG4gICAgICAgICAgICBjb25zdCBoZWFkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBoZWFkaW5nLmlkID0gJ2xhdGVuY3lUZXN0SGVhZGVyJztcbiAgICAgICAgICAgIGhlYWRpbmcuY2xhc3NMaXN0LmFkZCgnc2V0dGluZ3MtdGV4dCcpO1xuICAgICAgICAgICAgaGVhZGluZy5jbGFzc0xpc3QuYWRkKCdzZXR0aW5nc0hlYWRlcicpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQoaGVhZGluZyk7XG4gICAgICAgICAgICBjb25zdCBoZWFkaW5nVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaGVhZGluZ1RleHQuaW5uZXJIVE1MID0gU3RhdHNTZWN0aW9ucy5MYXRlbmN5VGVzdDtcbiAgICAgICAgICAgIGhlYWRpbmcuYXBwZW5kQ2hpbGQoaGVhZGluZ1RleHQpO1xuICAgICAgICAgICAgaGVhZGluZy5hcHBlbmRDaGlsZCh0aGlzLmxhdGVuY3lUZXN0QnV0dG9uKTtcbiAgICAgICAgICAgIC8vIG1ha2UgdGVzdCByZXN1bHRzIGVsZW1lbnRcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHNQYXJlbnRFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICByZXN1bHRzUGFyZW50RWxlbS5pZCA9ICdsYXRlbmN5VGVzdENvbnRhaW5lcic7XG4gICAgICAgICAgICByZXN1bHRzUGFyZW50RWxlbS5jbGFzc0xpc3QuYWRkKCdkLW5vbmUnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHJlc3VsdHNQYXJlbnRFbGVtKTtcbiAgICAgICAgICAgIHJlc3VsdHNQYXJlbnRFbGVtLmFwcGVuZENoaWxkKHRoaXMubGF0ZW5jeVRlc3RSZXN1bHRzRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RFbGVtZW50O1xuICAgIH1cbiAgICBnZXQgbGF0ZW5jeVRlc3RSZXN1bHRzRWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sYXRlbmN5VGVzdFJlc3VsdHNFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdFJlc3VsdHNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdFJlc3VsdHNFbGVtZW50LmlkID0gJ2xhdGVuY3lTdGF0c1Jlc3VsdHMnO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RSZXN1bHRzRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdTdGF0c1Jlc3VsdCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXRlbmN5VGVzdFJlc3VsdHNFbGVtZW50O1xuICAgIH1cbiAgICBnZXQgbGF0ZW5jeVRlc3RCdXR0b24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lUZXN0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lUZXN0QnV0dG9uLnR5cGUgPSAnYnV0dG9uJztcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lUZXN0QnV0dG9uLnZhbHVlID0gJ1J1biBUZXN0JztcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lUZXN0QnV0dG9uLmlkID0gJ2J0bi1zdGFydC1sYXRlbmN5LXRlc3QnO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24uY2xhc3NMaXN0LmFkZCgnc3RyZWFtVG9vbHMtYnV0dG9uJyk7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdidG4tZmxhdCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9wdWxhdGUgdGhlIFVJIGJhc2VkIG9uIHRoZSBsYXRlbmN5IHRlc3QncyByZXN1bHRzLlxuICAgICAqIEBwYXJhbSBsYXRlbmN5VGltaW5ncyAtIFRoZSBsYXRlbmN5IHRlc3QgcmVzdWx0cy5cbiAgICAgKi9cbiAgICBoYW5kbGVUZXN0UmVzdWx0KGxhdGVuY3lUaW1pbmdzKSB7XG4gICAgICAgIExvZ2dlci5JbmZvKEpTT04uc3RyaW5naWZ5KGxhdGVuY3lUaW1pbmdzKSk7XG4gICAgICAgIGxldCBsYXRlbmN5U3RhdHNJbm5lckhUTUwgPSAnJztcbiAgICAgICAgaWYgKGxhdGVuY3lUaW1pbmdzLm5ldHdvcmtMYXRlbmN5ICE9PSB1bmRlZmluZWQgJiYgbGF0ZW5jeVRpbWluZ3MubmV0d29ya0xhdGVuY3kgPiAwKSB7XG4gICAgICAgICAgICBsYXRlbmN5U3RhdHNJbm5lckhUTUwgKz0gJzxkaXY+TmV0IGxhdGVuY3kgUlRUIChtcyk6ICcgKyBsYXRlbmN5VGltaW5ncy5uZXR3b3JrTGF0ZW5jeSArICc8L2Rpdj4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXRlbmN5VGltaW5ncy5FbmNvZGVNcyAhPT0gdW5kZWZpbmVkICYmIGxhdGVuY3lUaW1pbmdzLkVuY29kZU1zID4gMCkge1xuICAgICAgICAgICAgbGF0ZW5jeVN0YXRzSW5uZXJIVE1MICs9ICc8ZGl2PlVFIEVuY29kZSAobXMpOiAnICsgbGF0ZW5jeVRpbWluZ3MuRW5jb2RlTXMgKyAnPC9kaXY+JztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF0ZW5jeVRpbWluZ3MuQ2FwdHVyZVRvU2VuZE1zICE9PSB1bmRlZmluZWQgJiYgbGF0ZW5jeVRpbWluZ3MuQ2FwdHVyZVRvU2VuZE1zID4gMCkge1xuICAgICAgICAgICAgbGF0ZW5jeVN0YXRzSW5uZXJIVE1MICs9ICc8ZGl2PlVFIENhcHR1cmUgKG1zKTogJyArIGxhdGVuY3lUaW1pbmdzLkNhcHR1cmVUb1NlbmRNcyArICc8L2Rpdj4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXRlbmN5VGltaW5ncy5icm93c2VyU2VuZExhdGVuY3kgIT09IHVuZGVmaW5lZCAmJiBsYXRlbmN5VGltaW5ncy5icm93c2VyU2VuZExhdGVuY3kgPiAwKSB7XG4gICAgICAgICAgICBsYXRlbmN5U3RhdHNJbm5lckhUTUwgKz1cbiAgICAgICAgICAgICAgICAnPGRpdj5Ccm93c2VyIHNlbmQgbGF0ZW5jeSAobXMpOiAnICsgbGF0ZW5jeVRpbWluZ3MuYnJvd3NlclNlbmRMYXRlbmN5ICsgJzwvZGl2Pic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhdGVuY3lUaW1pbmdzLmZyYW1lRGlzcGxheURlbHRhVGltZU1zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGxhdGVuY3lUaW1pbmdzLmJyb3dzZXJSZWNlaXB0VGltZU1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhdGVuY3lTdGF0c0lubmVySFRNTCArPVxuICAgICAgICAgICAgICAgIGxhdGVuY3lUaW1pbmdzLmZyYW1lRGlzcGxheURlbHRhVGltZU1zICYmIGxhdGVuY3lUaW1pbmdzLmJyb3dzZXJSZWNlaXB0VGltZU1zXG4gICAgICAgICAgICAgICAgICAgID8gJzxkaXY+QnJvd3NlciByZWNlaXZlIGxhdGVuY3kgKG1zKTogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRlbmN5VGltaW5ncy5mcmFtZURpc3BsYXlEZWx0YVRpbWVNcyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+J1xuICAgICAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXRlbmN5VGltaW5ncy5sYXRlbmN5RXhjbHVkaW5nRGVjb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhdGVuY3lTdGF0c0lubmVySFRNTCArPVxuICAgICAgICAgICAgICAgICc8ZGl2PlRvdGFsIGxhdGVuY3kgKGV4Y2x1ZGluZyBicm93c2VyKSAobXMpOiAnICtcbiAgICAgICAgICAgICAgICAgICAgbGF0ZW5jeVRpbWluZ3MubGF0ZW5jeUV4Y2x1ZGluZ0RlY29kZSArXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXRlbmN5VGltaW5ncy5lbmRUb0VuZExhdGVuY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGF0ZW5jeVN0YXRzSW5uZXJIVE1MICs9IGxhdGVuY3lUaW1pbmdzLmVuZFRvRW5kTGF0ZW5jeVxuICAgICAgICAgICAgICAgID8gJzxkaXY+VG90YWwgbGF0ZW5jeSAobXMpOiAnICsgbGF0ZW5jeVRpbWluZ3MuZW5kVG9FbmRMYXRlbmN5ICsgJzwvZGl2PidcbiAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF0ZW5jeVRlc3RSZXN1bHRzRWxlbWVudC5pbm5lckhUTUwgPSBsYXRlbmN5U3RhdHNJbm5lckhUTUw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGF0ZW5jeVRlc3QuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExvZ2dlciwgU2V0dGluZ051bWJlciB9IGZyb20gJ0BlcGljZ2FtZXMtcHMvbGliLXBpeGVsc3RyZWFtaW5nZnJvbnRlbmQtdWU1LjYnO1xuaW1wb3J0IHsgU2V0dGluZ1VJTnVtYmVyIH0gZnJvbSAnLi4vQ29uZmlnL1NldHRpbmdVSU51bWJlcic7XG4vKipcbiAqIFNlc3Npb24gdGVzdCBVSSBlbGVtZW50cyBhbmQgcmVzdWx0cyBoYW5kbGluZy5cbiAqIENyZWF0ZXMgYSBidXR0b24gdG8gc3RhcnQgdGhlIHRlc3QgYW5kIGNvbGxlY3RzIHN0YXRzIGFuZCBsYXRlbmN5IGluZm8gZHVyaW5nIHRoZSB0ZXN0LlxuICogQWZ0ZXIgdGhlIHRlc3QgaXMgZmluaXNoZWQsIGl0IGdlbmVyYXRlcyBDU1YgZmlsZXMgZm9yIHN0YXRzIGFuZCBsYXRlbmN5IGluZm8uXG4gKiBUaGUgdGVzdCBydW5zIGZvciBhIHNwZWNpZmllZCB0aW1lIGZyYW1lLCB3aGljaCBjYW4gYmUgc2V0IGluIHRoZSBVSS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNlc3Npb25UZXN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pc0NvbGxlY3RpbmdTdGF0cyA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlIHRoZSBlbGVtZW50cyBmb3IgdGhlIHNlc3Npb24gdGVzdDogZS5nLiBidXR0b24gYW5kIHRlc3QgdGltZSBpbnB1dC5cbiAgICAgKi9cbiAgICBnZXQgcm9vdEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VjdGlvbicpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2V0dGluZ3NDb250YWluZXInKTtcbiAgICAgICAgICAgIC8vIG1ha2UgaGVhZGluZ1xuICAgICAgICAgICAgY29uc3QgaGVhZGluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaGVhZGluZy5pZCA9ICdsYXRlbmN5VGVzdEhlYWRlcic7XG4gICAgICAgICAgICBoZWFkaW5nLmNsYXNzTGlzdC5hZGQoJ3NldHRpbmdzLXRleHQnKTtcbiAgICAgICAgICAgIGhlYWRpbmcuY2xhc3NMaXN0LmFkZCgnc2V0dGluZ3NIZWFkZXInKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKGhlYWRpbmcpO1xuICAgICAgICAgICAgY29uc3QgaGVhZGluZ1RleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGhlYWRpbmdUZXh0LmlubmVySFRNTCA9ICdTZXNzaW9uIFRlc3QnO1xuICAgICAgICAgICAgaGVhZGluZy5hcHBlbmRDaGlsZChoZWFkaW5nVGV4dCk7XG4gICAgICAgICAgICAvLyBtYWtlIHRlc3QgcmVzdWx0cyBlbGVtZW50XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzUGFyZW50RWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgcmVzdWx0c1BhcmVudEVsZW0uaWQgPSAnbGF0ZW5jeVRlc3RDb250YWluZXInO1xuICAgICAgICAgICAgcmVzdWx0c1BhcmVudEVsZW0uY2xhc3NMaXN0LmFkZCgnZC1ub25lJyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5hcHBlbmRDaGlsZChyZXN1bHRzUGFyZW50RWxlbSk7XG4gICAgICAgICAgICB0aGlzLl90ZXN0VGltZUZyYW1lU2V0dGluZyA9IG5ldyBTZXR0aW5nTnVtYmVyKCdUZXN0VGltZUZyYW1lJywgJ1Rlc3QgVGltZSBGcmFtZScsICdIb3cgbG9uZyB0aGUgdGVzdCBydW5zIGZvciAoc2Vjb25kcyknLCAwIC8qbWluKi8sIDM2MDAgLyptYXgqLywgNjAgLypkZWZhdWx0Ki8sIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RUaW1lRnJhbWVTZXR0aW5nID0gbmV3IFNldHRpbmdVSU51bWJlcih0aGlzLl90ZXN0VGltZUZyYW1lU2V0dGluZyk7XG4gICAgICAgICAgICByZXN1bHRzUGFyZW50RWxlbS5hcHBlbmRDaGlsZCh0ZXN0VGltZUZyYW1lU2V0dGluZy5yb290RWxlbWVudCk7XG4gICAgICAgICAgICByZXN1bHRzUGFyZW50RWxlbS5hcHBlbmRDaGlsZCh0aGlzLmxhdGVuY3lUZXN0QnV0dG9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBsYXRlbmN5VGVzdEJ1dHRvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24udHlwZSA9ICdidXR0b24nO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24udmFsdWUgPSAnUnVuIFRlc3QnO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24uaWQgPSAnYnRuLXN0YXJ0LWxhdGVuY3ktdGVzdCc7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdzdHJlYW1Ub29scy1idXR0b24nKTtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lUZXN0QnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2J0bi1mbGF0Jyk7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZW5jeVJlY29yZHMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ29sbGVjdGluZ1N0YXRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXRlbmN5VGVzdEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24udmFsdWUgPSAnUnVubmluZy4uLic7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkluZm8oYFN0YXJ0aW5nIHNlc3Npb24gdGVzdC4gRHVyYXRpb246IFske3RoaXMuX3Rlc3RUaW1lRnJhbWVTZXR0aW5nLm51bWJlcn1dYCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Db2xsZWN0aW5nRmluaXNoZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b24udmFsdWUgPSAnUnVuIFRlc3QnO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMuX3Rlc3RUaW1lRnJhbWVTZXR0aW5nLm51bWJlciAqIDEwMDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbGF0ZW5jeVRlc3RCdXR0b247XG4gICAgfVxuICAgIGhhbmRsZVN0YXRzKHN0YXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0NvbGxlY3RpbmdTdGF0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXRzQ29weSA9IHN0cnVjdHVyZWRDbG9uZShzdGF0cyk7XG4gICAgICAgIHRoaXMucmVjb3Jkcy5wdXNoKHN0YXRzQ29weSk7XG4gICAgfVxuICAgIGhhbmRsZUxhdGVuY3lJbmZvKGxhdGVuY3lJbmZvKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0NvbGxlY3RpbmdTdGF0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhdGVuY3lJbmZvQ29weSA9IHN0cnVjdHVyZWRDbG9uZShsYXRlbmN5SW5mbyk7XG4gICAgICAgIHRoaXMubGF0ZW5jeVJlY29yZHMucHVzaChsYXRlbmN5SW5mb0NvcHkpO1xuICAgIH1cbiAgICBvbkNvbGxlY3RpbmdGaW5pc2hlZCgpIHtcbiAgICAgICAgdGhpcy5pc0NvbGxlY3RpbmdTdGF0cyA9IGZhbHNlO1xuICAgICAgICBMb2dnZXIuSW5mbyhgRmluaXNoZWQgc2Vzc2lvbiB0ZXN0YCk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVTdGF0c0NzdigpO1xuICAgICAgICB0aGlzLmdlbmVyYXRlTGF0ZW5jeUNzdigpO1xuICAgIH1cbiAgICBnZW5lcmF0ZVN0YXRzQ3N2KCkge1xuICAgICAgICBjb25zdCBjc3ZIZWFkZXIgPSBbXTtcbiAgICAgICAgdGhpcy5yZWNvcmRzLmZvckVhY2goKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIGluIHJlY29yZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHJlY29yZFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb2JqLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJheVZhbCA9IG9ialtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBhcnJheVZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3ZIZWFkZXIuaW5kZXhPZihgJHtpfS4ke2p9LiR7a31gKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3N2SGVhZGVyLnB1c2goYCR7aX0uJHtqfS4ke2t9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGogaW4gb2JqLmtleXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFwVmFsID0gb2JqLmdldChqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBtYXBWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3N2SGVhZGVyLmluZGV4T2YoYCR7aX0uJHtqfS4ke2t9YCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzdkhlYWRlci5wdXNoKGAke2l9LiR7an0uJHtrfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBqIGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzdkhlYWRlci5pbmRleE9mKGAke2l9LiR7an1gKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3ZIZWFkZXIucHVzaChgJHtpfS4ke2p9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgY3N2Qm9keSA9ICcnO1xuICAgICAgICB0aGlzLnJlY29yZHMuZm9yRWFjaCgocmVjb3JkKSA9PiB7XG4gICAgICAgICAgICBjc3ZIZWFkZXIuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjc3ZCb2R5ICs9IGBcIiR7ZmllbGQuc3BsaXQoJy4nKS5yZWR1Y2UoKG8sIGspID0+IG9ba10sIHJlY29yZCl9XCIsYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgY3N2Qm9keSArPSBgXCJcIixgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3N2Qm9keSArPSBgXFxuYDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBuZXcgQmxvYihbYCR7Y3N2SGVhZGVyLmpvaW4oJywnKX1cXG4ke2NzdkJvZHl9YF0sIHsgdHlwZTogJ3RleHQvcGxhaW4nIH0pO1xuICAgICAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuICAgICAgICBhLmhyZWYgPSB1cmw7XG4gICAgICAgIGEuZG93bmxvYWQgPSAnc3RhdHMuY3N2JztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTtcbiAgICAgICAgYS5jbGljaygpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYSk7XG4gICAgICAgICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG4gICAgZ2VuZXJhdGVMYXRlbmN5Q3N2KCkge1xuICAgICAgICBjb25zdCBjc3ZIZWFkZXIgPSBbXTtcbiAgICAgICAgdGhpcy5sYXRlbmN5UmVjb3Jkcy5mb3JFYWNoKChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBpbiByZWNvcmQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSByZWNvcmRbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaiBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3ZIZWFkZXIuaW5kZXhPZihgJHtpfS4ke2p9YCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3N2SGVhZGVyLnB1c2goYCR7aX0uJHtqfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNzdkhlYWRlci5pbmRleE9mKGAke2l9YCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNzdkhlYWRlci5wdXNoKGAke2l9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGNzdkJvZHkgPSAnJztcbiAgICAgICAgdGhpcy5sYXRlbmN5UmVjb3Jkcy5mb3JFYWNoKChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgIGNzdkhlYWRlci5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNzdkJvZHkgKz0gYFwiJHtmaWVsZC5zcGxpdCgnLicpLnJlZHVjZSgobywgaykgPT4gb1trXSwgcmVjb3JkKX1cIixgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICBjc3ZCb2R5ICs9IGBcIlwiLGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjc3ZCb2R5ICs9IGBcXG5gO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmlsZSA9IG5ldyBCbG9iKFtgJHtjc3ZIZWFkZXIuam9pbignLCcpfVxcbiR7Y3N2Qm9keX1gXSwgeyB0eXBlOiAndGV4dC9wbGFpbicgfSk7XG4gICAgICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XG4gICAgICAgIGEuaHJlZiA9IHVybDtcbiAgICAgICAgYS5kb3dubG9hZCA9ICdsYXRlbmN5LmNzdic7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7XG4gICAgICAgIGEuY2xpY2soKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGEpO1xuICAgICAgICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2Vzc2lvblRlc3QuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogU2V0dGluZ3MgaWNvbiB0aGF0IGNhbiBiZSBjbGlja2VkLlxuICovXG5leHBvcnQgY2xhc3MgU2V0dGluZ3NJY29uIHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRoZSBidXR0b24gY29udGFpbmluZyB0aGUgc2V0dGluZ3MgaWNvbi5cbiAgICAgKi9cbiAgICBnZXQgcm9vdEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC50eXBlID0gJ2J1dHRvbic7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdVaVRvb2wnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmlkID0gJ3NldHRpbmdzQnRuJztcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc2V0dGluZ3NJY29uKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudG9vbHRpcFRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290RWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IHRvb2x0aXBUZXh0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rvb2x0aXBUZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBUZXh0LmNsYXNzTGlzdC5hZGQoJ3Rvb2x0aXB0ZXh0Jyk7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwVGV4dC5pbm5lckhUTUwgPSAnU2V0dGluZ3MnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90b29sdGlwVGV4dDtcbiAgICB9XG4gICAgZ2V0IHNldHRpbmdzSWNvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zZXR0aW5nc0ljb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzSWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5nc0ljb24uc2V0QXR0cmlidXRlTlMobnVsbCwgJ2lkJywgJ3NldHRpbmdzSWNvbicpO1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NJY29uLnNldEF0dHJpYnV0ZU5TKG51bGwsICd4JywgJzBweCcpO1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NJY29uLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5JywgJzBweCcpO1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NJY29uLnNldEF0dHJpYnV0ZU5TKG51bGwsICd2aWV3Qm94JywgJzAgMCA0NzguNzAzIDQ3OC43MDMnKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBzdmcgZ3JvdXAgZm9yIHRoZSBwYXRoc1xuICAgICAgICAgICAgY29uc3Qgc3ZnR3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2cnKTtcbiAgICAgICAgICAgIHN2Z0dyb3VwLmNsYXNzTGlzdC5hZGQoJ3N2Z0ljb24nKTtcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzSWNvbi5hcHBlbmRDaGlsZChzdmdHcm91cCk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgcGF0aHMgZm9yIHRoZSBpY29uIGl0c2VsZiwgdGhlIGlubmVyIGFuZCBvdXQgcGF0aCBvZiBhIGNvZ1xuICAgICAgICAgICAgY29uc3QgcGF0aDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3BhdGgnKTtcbiAgICAgICAgICAgIHBhdGgxLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ000NTQuMiwxODkuMTAxbC0zMy42LTUuN2MtMy41LTExLjMtOC0yMi4yLTEzLjUtMzIuNmwxOS44LTI3LjdjOC40LTExLjgsNy4xLTI3LjktMy4yLTM4LjFsLTI5LjgtMjkuOFxcXG5cdFx0XHRjLTUuNi01LjYtMTMtOC43LTIwLjktOC43Yy02LjIsMC0xMi4xLDEuOS0xNy4xLDUuNWwtMjcuOCwxOS44Yy0xMC44LTUuNy0yMi4xLTEwLjQtMzMuOC0xMy45bC01LjYtMzMuMlxcXG5cdFx0XHRjLTIuNC0xNC4zLTE0LjctMjQuNy0yOS4yLTI0LjdoLTQyLjFjLTE0LjUsMC0yNi44LDEwLjQtMjkuMiwyNC43bC01LjgsMzRjLTExLjIsMy41LTIyLjEsOC4xLTMyLjUsMTMuN2wtMjcuNS0xOS44XFxcblx0XHRcdGMtNS0zLjYtMTEtNS41LTE3LjItNS41Yy03LjksMC0xNS40LDMuMS0yMC45LDguN2wtMjkuOSwyOS44Yy0xMC4yLDEwLjItMTEuNiwyNi4zLTMuMiwzOC4xbDIwLDI4LjFcXFxuXHRcdFx0Yy01LjUsMTAuNS05LjksMjEuNC0xMy4zLDMyLjdsLTMzLjIsNS42Yy0xNC4zLDIuNC0yNC43LDE0LjctMjQuNywyOS4ydjQyLjFjMCwxNC41LDEwLjQsMjYuOCwyNC43LDI5LjJsMzQsNS44XFxcblx0XHRcdGMzLjUsMTEuMiw4LjEsMjIuMSwxMy43LDMyLjVsLTE5LjcsMjcuNGMtOC40LDExLjgtNy4xLDI3LjksMy4yLDM4LjFsMjkuOCwyOS44YzUuNiw1LjYsMTMsOC43LDIwLjksOC43YzYuMiwwLDEyLjEtMS45LDE3LjEtNS41XFxcblx0XHRcdGwyOC4xLTIwYzEwLjEsNS4zLDIwLjcsOS42LDMxLjYsMTNsNS42LDMzLjZjMi40LDE0LjMsMTQuNywyNC43LDI5LjIsMjQuN2g0Mi4yYzE0LjUsMCwyNi44LTEwLjQsMjkuMi0yNC43bDUuNy0zMy42XFxcblx0XHRcdGMxMS4zLTMuNSwyMi4yLTgsMzIuNi0xMy41bDI3LjcsMTkuOGM1LDMuNiwxMSw1LjUsMTcuMiw1LjVsMCwwYzcuOSwwLDE1LjMtMy4xLDIwLjktOC43bDI5LjgtMjkuOGMxMC4yLTEwLjIsMTEuNi0yNi4zLDMuMi0zOC4xXFxcblx0XHRcdGwtMTkuOC0yNy44YzUuNS0xMC41LDEwLjEtMjEuNCwxMy41LTMyLjZsMzMuNi01LjZjMTQuMy0yLjQsMjQuNy0xNC43LDI0LjctMjkuMnYtNDIuMVxcXG5cdFx0XHRDNDc4LjksMjAzLjgwMSw0NjguNSwxOTEuNTAxLDQ1NC4yLDE4OS4xMDF6IE00NTEuOSwyNjAuNDAxYzAsMS4zLTAuOSwyLjQtMi4yLDIuNmwtNDIsN2MtNS4zLDAuOS05LjUsNC44LTEwLjgsOS45XFxcblx0XHRcdGMtMy44LDE0LjctOS42LDI4LjgtMTcuNCw0MS45Yy0yLjcsNC42LTIuNSwxMC4zLDAuNiwxNC43bDI0LjcsMzQuOGMwLjcsMSwwLjYsMi41LTAuMywzLjRsLTI5LjgsMjkuOGMtMC43LDAuNy0xLjQsMC44LTEuOSwwLjhcXFxuXHRcdFx0Yy0wLjYsMC0xLjEtMC4yLTEuNS0wLjVsLTM0LjctMjQuN2MtNC4zLTMuMS0xMC4xLTMuMy0xNC43LTAuNmMtMTMuMSw3LjgtMjcuMiwxMy42LTQxLjksMTcuNGMtNS4yLDEuMy05LjEsNS42LTkuOSwxMC44bC03LjEsNDJcXFxuXHRcdFx0Yy0wLjIsMS4zLTEuMywyLjItMi42LDIuMmgtNDIuMWMtMS4zLDAtMi40LTAuOS0yLjYtMi4ybC03LTQyYy0wLjktNS4zLTQuOC05LjUtOS45LTEwLjhjLTE0LjMtMy43LTI4LjEtOS40LTQxLTE2LjhcXFxuXHRcdFx0Yy0yLjEtMS4yLTQuNS0xLjgtNi44LTEuOGMtMi43LDAtNS41LDAuOC03LjgsMi41bC0zNSwyNC45Yy0wLjUsMC4zLTEsMC41LTEuNSwwLjVjLTAuNCwwLTEuMi0wLjEtMS45LTAuOGwtMjkuOC0yOS44XFxcblx0XHRcdGMtMC45LTAuOS0xLTIuMy0wLjMtMy40bDI0LjYtMzQuNWMzLjEtNC40LDMuMy0xMC4yLDAuNi0xNC44Yy03LjgtMTMtMTMuOC0yNy4xLTE3LjYtNDEuOGMtMS40LTUuMS01LjYtOS0xMC44LTkuOWwtNDIuMy03LjJcXFxuXHRcdFx0Yy0xLjMtMC4yLTIuMi0xLjMtMi4yLTIuNnYtNDIuMWMwLTEuMywwLjktMi40LDIuMi0yLjZsNDEuNy03YzUuMy0wLjksOS42LTQuOCwxMC45LTEwYzMuNy0xNC43LDkuNC0yOC45LDE3LjEtNDJcXFxuXHRcdFx0YzIuNy00LjYsMi40LTEwLjMtMC43LTE0LjZsLTI0LjktMzVjLTAuNy0xLTAuNi0yLjUsMC4zLTMuNGwyOS44LTI5LjhjMC43LTAuNywxLjQtMC44LDEuOS0wLjhjMC42LDAsMS4xLDAuMiwxLjUsMC41bDM0LjUsMjQuNlxcXG5cdFx0XHRjNC40LDMuMSwxMC4yLDMuMywxNC44LDAuNmMxMy03LjgsMjcuMS0xMy44LDQxLjgtMTcuNmM1LjEtMS40LDktNS42LDkuOS0xMC44bDcuMi00Mi4zYzAuMi0xLjMsMS4zLTIuMiwyLjYtMi4yaDQyLjFcXFxuXHRcdFx0YzEuMywwLDIuNCwwLjksMi42LDIuMmw3LDQxLjdjMC45LDUuMyw0LjgsOS42LDEwLDEwLjljMTUuMSwzLjgsMjkuNSw5LjcsNDIuOSwxNy42YzQuNiwyLjcsMTAuMywyLjUsMTQuNy0wLjZsMzQuNS0yNC44XFxcblx0XHRcdGMwLjUtMC4zLDEtMC41LDEuNS0wLjVjMC40LDAsMS4yLDAuMSwxLjksMC44bDI5LjgsMjkuOGMwLjksMC45LDEsMi4zLDAuMywzLjRsLTI0LjcsMzQuN2MtMy4xLDQuMy0zLjMsMTAuMS0wLjYsMTQuN1xcXG5cdFx0XHRjNy44LDEzLjEsMTMuNiwyNy4yLDE3LjQsNDEuOWMxLjMsNS4yLDUuNiw5LjEsMTAuOCw5LjlsNDIsNy4xYzEuMywwLjIsMi4yLDEuMywyLjIsMi42djQyLjFINDUxLjl6Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXRoMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncGF0aCcpO1xuICAgICAgICAgICAgcGF0aDIuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCAnTTIzOS40LDEzNi4wMDFjLTU3LDAtMTAzLjMsNDYuMy0xMDMuMywxMDMuM3M0Ni4zLDEwMy4zLDEwMy4zLDEwMy4zczEwMy4zLTQ2LjMsMTAzLjMtMTAzLjNTMjk2LjQsMTM2LjAwMSwyMzkuNCwxMzYuMDAxeiBNMjM5LjQsMzE1LjYwMWMtNDIuMSwwLTc2LjMtMzQuMi03Ni4zLTc2LjNzMzQuMi03Ni4zLDc2LjMtNzYuM3M3Ni4zLDM0LjIsNzYuMyw3Ni4zUzI4MS41LDMxNS42MDEsMjM5LjQsMzE1LjYwMXonKTtcbiAgICAgICAgICAgIHN2Z0dyb3VwLmFwcGVuZENoaWxkKHBhdGgxKTtcbiAgICAgICAgICAgIHN2Z0dyb3VwLmFwcGVuZENoaWxkKHBhdGgyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3NJY29uO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNldHRpbmdzSWNvbi5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBBIFVJIGNvbXBvbmVudCBjb250YWluaW5nIGFsbCB0aGUgc2V0dGluZ3MgZm9yIHRoZSBhcHBsaWNhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFNldHRpbmdzUGFuZWwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFJldHVybiBvciBjcmVhdGVzIGEgSFRNTCBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyB0aGlzIHNldHRpbmcgaW4gdGhlIERPTS5cbiAgICAgKi9cbiAgICBnZXQgcm9vdEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5pZCA9ICdzZXR0aW5ncy1wYW5lbCc7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdwYW5lbC13cmFwJyk7XG4gICAgICAgICAgICBjb25zdCBwYW5lbEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHBhbmVsRWxlbS5jbGFzc0xpc3QuYWRkKCdwYW5lbCcpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQocGFuZWxFbGVtKTtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzSGVhZGluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgc2V0dGluZ3NIZWFkaW5nLmlkID0gJ3NldHRpbmdzSGVhZGluZyc7XG4gICAgICAgICAgICBzZXR0aW5nc0hlYWRpbmcudGV4dENvbnRlbnQgPSAnU2V0dGluZ3MnO1xuICAgICAgICAgICAgcGFuZWxFbGVtLmFwcGVuZENoaWxkKHNldHRpbmdzSGVhZGluZyk7XG4gICAgICAgICAgICBwYW5lbEVsZW0uYXBwZW5kQ2hpbGQodGhpcy5zZXR0aW5nc0Nsb3NlQnV0dG9uKTtcbiAgICAgICAgICAgIHBhbmVsRWxlbS5hcHBlbmRDaGlsZCh0aGlzLnNldHRpbmdzQ29udGVudEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290RWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IHNldHRpbmdzQ29udGVudEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2V0dGluZ3NDb250ZW50RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NDb250ZW50RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NDb250ZW50RWxlbWVudC5pZCA9ICdzZXR0aW5nc0NvbnRlbnQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5nc0NvbnRlbnRFbGVtZW50O1xuICAgIH1cbiAgICBnZXQgc2V0dGluZ3NDbG9zZUJ1dHRvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zZXR0aW5nc0Nsb3NlQnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5nc0Nsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5nc0Nsb3NlQnV0dG9uLmlkID0gJ3NldHRpbmdzQ2xvc2UnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5nc0Nsb3NlQnV0dG9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHNldHRpbmdzIHBhbmVsLlxuICAgICAqL1xuICAgIHNob3coKSB7XG4gICAgICAgIGlmICghdGhpcy5yb290RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3BhbmVsLXdyYXAtdmlzaWJsZScpKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3BhbmVsLXdyYXAtdmlzaWJsZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgc2V0dGluZ3MgcGFuZWwuXG4gICAgICovXG4gICAgdG9nZ2xlVmlzaWJpbGl0eSgpIHtcbiAgICAgICAgdGhpcy5yb290RWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCdwYW5lbC13cmFwLXZpc2libGUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSBzZXR0aW5ncyBwYW5lbC5cbiAgICAgKi9cbiAgICBoaWRlKCkge1xuICAgICAgICBpZiAodGhpcy5yb290RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3BhbmVsLXdyYXAtdmlzaWJsZScpKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3BhbmVsLXdyYXAtdmlzaWJsZScpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2V0dGluZ3NQYW5lbC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLyoqXG4gKiBTdGF0cyBpY29uIHRoYXQgY2FuIGJlIGNsaWNrZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGF0c0ljb24ge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGhlIGJ1dHRvbiBjb250YWluaW5nIHRoZSBzdGF0cyBpY29uLlxuICAgICAqL1xuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnR5cGUgPSAnYnV0dG9uJztcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ1VpVG9vbCcpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuaWQgPSAnc3RhdHNCdG4nO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zdGF0c0ljb24pO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy50b29sdGlwVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RFbGVtZW50O1xuICAgIH1cbiAgICBnZXQgdG9vbHRpcFRleHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9vbHRpcFRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFRleHQuY2xhc3NMaXN0LmFkZCgndG9vbHRpcHRleHQnKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBUZXh0LmlubmVySFRNTCA9ICdJbmZvcm1hdGlvbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rvb2x0aXBUZXh0O1xuICAgIH1cbiAgICBnZXQgc3RhdHNJY29uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXRzSWNvbikge1xuICAgICAgICAgICAgdGhpcy5fc3RhdHNJY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRzSWNvbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaWQnLCAnc3RhdHNJY29uJyk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0c0ljb24uc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gnLCAnMHB4Jyk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0c0ljb24uc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLCAnMHB4Jyk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0c0ljb24uc2V0QXR0cmlidXRlTlMobnVsbCwgJ3ZpZXdCb3gnLCAnMCAwIDMzMCAzMzAnKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBzdmcgZ3JvdXAgZm9yIHRoZSBwYXRoc1xuICAgICAgICAgICAgY29uc3Qgc3ZnR3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2cnKTtcbiAgICAgICAgICAgIHN2Z0dyb3VwLmNsYXNzTGlzdC5hZGQoJ3N2Z0ljb24nKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRzSWNvbi5hcHBlbmRDaGlsZChzdmdHcm91cCk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgcGF0aHMgZm9yIHRoZSBpY29uIGl0c2VsZiwgdGhlIGlubmVyIGFuZCBvdXQgcGF0aCBvZiBhIGNvZ1xuICAgICAgICAgICAgY29uc3QgcGF0aDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3BhdGgnKTtcbiAgICAgICAgICAgIHBhdGgxLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ00xNjUsMC4wMDhDNzQuMDE5LDAuMDA4LDAsNzQuMDI0LDAsMTY0Ljk5OWMwLDkwLjk3Nyw3NC4wMTksMTY0Ljk5MiwxNjUsMTY0Ljk5MnMxNjUtNzQuMDE1LDE2NS0xNjQuOTkyQzMzMCw3NC4wMjQsMjU1Ljk4MSwwLjAwOCwxNjUsMC4wMDh6IE0xNjUsMjk5Ljk5MmMtNzQuNDM5LDAtMTM1LTYwLjU1Ny0xMzUtMTM0Ljk5MlM5MC41NjEsMzAuMDA4LDE2NSwzMC4wMDhzMTM1LDYwLjU1NywxMzUsMTM0Ljk5MUMzMDAsMjM5LjQzNiwyMzkuNDM5LDI5OS45OTIsMTY1LDI5OS45OTJ6Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXRoMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncGF0aCcpO1xuICAgICAgICAgICAgcGF0aDIuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCAnTTE2NSwxMzAuMDA4Yy04LjI4NCwwLTE1LDYuNzE2LTE1LDE1djk5Ljk4M2MwLDguMjg0LDYuNzE2LDE1LDE1LDE1czE1LTYuNzE2LDE1LTE1di05OS45ODNDMTgwLDEzNi43MjUsMTczLjI4NCwxMzAuMDA4LDE2NSwxMzAuMDA4eicpO1xuICAgICAgICAgICAgY29uc3QgcGF0aDMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3BhdGgnKTtcbiAgICAgICAgICAgIHBhdGgzLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ00xNjUsNzAuMDExYy0zLjk1LDAtNy44MTEsMS42LTEwLjYxLDQuMzljLTIuNzksMi43OS00LjM5LDYuNjYtNC4zOSwxMC42MXMxLjYsNy44MSw0LjM5LDEwLjYxYzIuNzksMi43OSw2LjY2LDQuMzksMTAuNjEsNC4zOXM3LjgxLTEuNiwxMC42MDktNC4zOWMyLjc5LTIuOCw0LjM5MS02LjY2LDQuMzkxLTEwLjYxcy0xLjYwMS03LjgyLTQuMzkxLTEwLjYxQzE3Mi44MSw3MS42MSwxNjguOTUsNzAuMDExLDE2NSw3MC4wMTF6Jyk7XG4gICAgICAgICAgICBzdmdHcm91cC5hcHBlbmRDaGlsZChwYXRoMSk7XG4gICAgICAgICAgICBzdmdHcm91cC5hcHBlbmRDaGlsZChwYXRoMik7XG4gICAgICAgICAgICBzdmdHcm91cC5hcHBlbmRDaGlsZChwYXRoMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRzSWNvbjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGF0c0ljb24uanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmltcG9ydCB7IExhdGVuY3lUZXN0IH0gZnJvbSAnLi9MYXRlbmN5VGVzdCc7XG5pbXBvcnQgeyBMb2dnZXIsIEZsYWdzIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdmcm9udGVuZC11ZTUuNic7XG5pbXBvcnQgeyBNYXRoVXRpbHMgfSBmcm9tICcuLi9VdGlsL01hdGhVdGlscyc7XG5pbXBvcnQgeyBEYXRhQ2hhbm5lbExhdGVuY3lUZXN0IH0gZnJvbSAnLi9EYXRhQ2hhbm5lbExhdGVuY3lUZXN0JztcbmltcG9ydCB7IFNlc3Npb25UZXN0IH0gZnJvbSAnLi9TZXNzaW9uVGVzdCc7XG5pbXBvcnQgeyBpc1NlY3Rpb25FbmFibGVkLCBTdGF0c1NlY3Rpb25zIH0gZnJvbSAnLi9VSUNvbmZpZ3VyYXRpb25UeXBlcyc7XG4vKipcbiAqIEEgc3RhdCBzdHJ1Y3R1cmUsIGFuIGlkLCB0aGUgc3RhdCBzdHJpbmcsIGFuZCB0aGUgZWxlbWVudCB3aGVyZSBpdCBpcyByZW5kZXJlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXQge1xufVxuLyoqXG4gKiBBIFVJIGNvbXBvbmVudCBjb250YWluaW5nIGFsbCB0aGUgc3RhdHMgZm9yIHRoZSBhcHBsaWNhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXRzUGFuZWwge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc3RyZWFtQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvblRlc3QgPSBudWxsO1xuICAgICAgICAvKiBBIG1hcCBzdGF0cyB3ZSBhcmUgc3RvcmluZy9yZW5kZXJpbmcgKi9cbiAgICAgICAgdGhpcy5zdGF0c01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvLyBPbmx5IGNyZWF0ZSB0aGUgc2Vzc2lvbiB0ZXN0IGNsYXNzL3VpLWVsZW1lbnRzIGlmIHRoZSA/TGF0ZW5jeUNTViBmbGFnIGlzIGVuYWJsZWQuXG4gICAgICAgIHRoaXMuc2Vzc2lvblRlc3QgPSBzdHJlYW1Db25maWcuaXNGbGFnRW5hYmxlZChGbGFncy5MYXRlbmN5Q1NWKSA/IG5ldyBTZXNzaW9uVGVzdCgpIDogbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlbmN5VGVzdCA9IG5ldyBMYXRlbmN5VGVzdCgpO1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsTGF0ZW5jeVRlc3QgPSBuZXcgRGF0YUNoYW5uZWxMYXRlbmN5VGVzdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBSZXR1cm4gb3IgY3JlYXRlcyBhIEhUTUwgZWxlbWVudCB0aGF0IHJlcHJlc2VudHMgdGhpcyBzZXR0aW5nIGluIHRoZSBET00uXG4gICAgICovXG4gICAgZ2V0IHJvb3RFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuaWQgPSAnc3RhdHMtcGFuZWwnO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgncGFuZWwtd3JhcCcpO1xuICAgICAgICAgICAgY29uc3QgcGFuZWxFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBwYW5lbEVsZW0uY2xhc3NMaXN0LmFkZCgncGFuZWwnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHBhbmVsRWxlbSk7XG4gICAgICAgICAgICBjb25zdCBzdGF0c0hlYWRpbmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHN0YXRzSGVhZGluZy5pZCA9ICdzdGF0c0hlYWRpbmcnO1xuICAgICAgICAgICAgc3RhdHNIZWFkaW5nLnRleHRDb250ZW50ID0gJ0luZm9ybWF0aW9uJztcbiAgICAgICAgICAgIHBhbmVsRWxlbS5hcHBlbmRDaGlsZChzdGF0c0hlYWRpbmcpO1xuICAgICAgICAgICAgcGFuZWxFbGVtLmFwcGVuZENoaWxkKHRoaXMuc3RhdHNDbG9zZUJ1dHRvbik7XG4gICAgICAgICAgICBwYW5lbEVsZW0uYXBwZW5kQ2hpbGQodGhpcy5zdGF0c0NvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBzdGF0c0NvbnRlbnRFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXRzQ29udGVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRzQ29udGVudEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRzQ29udGVudEVsZW1lbnQuaWQgPSAnc3RhdHNDb250ZW50JztcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbVRvb2xTdGF0cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgc3RyZWFtVG9vbFN0YXRzLmlkID0gJ3N0cmVhbVRvb2xzU3RhdHMnO1xuICAgICAgICAgICAgc3RyZWFtVG9vbFN0YXRzLmNsYXNzTGlzdC5hZGQoJ2NvbnRhaW5lcicpO1xuICAgICAgICAgICAgY29uc3QgY29udHJvbFN0YXRzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBjb250cm9sU3RhdHMuaWQgPSAnQ29udHJvbFN0YXRzJztcbiAgICAgICAgICAgIGNvbnRyb2xTdGF0cy5jbGFzc0xpc3QuYWRkKCdyb3cnKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRpc3RpY3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWN0aW9uJyk7XG4gICAgICAgICAgICBzdGF0aXN0aWNzLmlkID0gJ3N0YXRpc3RpY3MnO1xuICAgICAgICAgICAgc3RhdGlzdGljcy5jbGFzc0xpc3QuYWRkKCdzZXR0aW5nc0NvbnRhaW5lcicpO1xuICAgICAgICAgICAgY29uc3QgbGF0ZW5jeVN0YXRzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VjdGlvbicpO1xuICAgICAgICAgICAgbGF0ZW5jeVN0YXRzLmlkID0gJ2xhdGVuY3lTdGF0cyc7XG4gICAgICAgICAgICBsYXRlbmN5U3RhdHMuY2xhc3NMaXN0LmFkZCgnc2V0dGluZ3NDb250YWluZXInKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRpc3RpY3NIZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHN0YXRpc3RpY3NIZWFkZXIuaWQgPSAnc3RhdGlzdGljc0hlYWRlcic7XG4gICAgICAgICAgICBzdGF0aXN0aWNzSGVhZGVyLmNsYXNzTGlzdC5hZGQoJ3NldHRpbmdzLXRleHQnKTtcbiAgICAgICAgICAgIHN0YXRpc3RpY3NIZWFkZXIuY2xhc3NMaXN0LmFkZCgnc2V0dGluZ3NIZWFkZXInKTtcbiAgICAgICAgICAgIGNvbnN0IGxhdGVuY3lTdGF0c0hlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbGF0ZW5jeVN0YXRzSGVhZGVyLmlkID0gJ2xhdGVuY3lTdGF0c0hlYWRlcic7XG4gICAgICAgICAgICBsYXRlbmN5U3RhdHNIZWFkZXIuY2xhc3NMaXN0LmFkZCgnc2V0dGluZ3MtdGV4dCcpO1xuICAgICAgICAgICAgbGF0ZW5jeVN0YXRzSGVhZGVyLmNsYXNzTGlzdC5hZGQoJ3NldHRpbmdzSGVhZGVyJyk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0c0NvbnRlbnRFbGVtZW50LmFwcGVuZENoaWxkKHN0cmVhbVRvb2xTdGF0cyk7XG4gICAgICAgICAgICBzdHJlYW1Ub29sU3RhdHMuYXBwZW5kQ2hpbGQoY29udHJvbFN0YXRzKTtcbiAgICAgICAgICAgIC8vIEFkZCBzZXNzc2lvbiB0ZXN0IHRvIHRoZSBVSSBpZiA/TGF0ZW5jeUNTViBmbGFnIGlzIGVuYWJsZWQgYW5kIGNvbmZpZyBhbGxvd3MgaXQuXG4gICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uVGVzdCAmJiBpc1NlY3Rpb25FbmFibGVkKHRoaXMuX2NvbmZpZywgU3RhdHNTZWN0aW9ucy5TZXNzaW9uVGVzdCkpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sU3RhdHMuYXBwZW5kQ2hpbGQodGhpcy5zZXNzaW9uVGVzdC5yb290RWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sU3RhdHMuYXBwZW5kQ2hpbGQoc3RhdGlzdGljcyk7XG4gICAgICAgICAgICBjb250cm9sU3RhdHMuYXBwZW5kQ2hpbGQobGF0ZW5jeVN0YXRzKTtcbiAgICAgICAgICAgIHN0YXRpc3RpY3MuYXBwZW5kQ2hpbGQoc3RhdGlzdGljc0hlYWRlcik7XG4gICAgICAgICAgICBsYXRlbmN5U3RhdHMuYXBwZW5kQ2hpbGQobGF0ZW5jeVN0YXRzSGVhZGVyKTtcbiAgICAgICAgICAgIGlmIChpc1NlY3Rpb25FbmFibGVkKHRoaXMuX2NvbmZpZywgU3RhdHNTZWN0aW9ucy5TZXNzaW9uU3RhdHMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvblN0YXRzVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIHNlc3Npb25TdGF0c1RleHQuaW5uZXJIVE1MID0gU3RhdHNTZWN0aW9ucy5TZXNzaW9uU3RhdHM7XG4gICAgICAgICAgICAgICAgc3RhdGlzdGljc0hlYWRlci5hcHBlbmRDaGlsZChzZXNzaW9uU3RhdHNUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRpc3RpY3MuYXBwZW5kQ2hpbGQodGhpcy5zdGF0aXN0aWNzQ29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChpc1NlY3Rpb25FbmFibGVkKHRoaXMuX2NvbmZpZywgU3RhdHNTZWN0aW9ucy5MYXRlbmN5U3RhdHMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGF0ZW5jeVN0YXRzVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGxhdGVuY3lTdGF0c1RleHQuaW5uZXJIVE1MID0gU3RhdHNTZWN0aW9ucy5MYXRlbmN5U3RhdHM7XG4gICAgICAgICAgICAgICAgbGF0ZW5jeVN0YXRzSGVhZGVyLmFwcGVuZENoaWxkKGxhdGVuY3lTdGF0c1RleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF0ZW5jeVN0YXRzLmFwcGVuZENoaWxkKHRoaXMubGF0ZW5jeVN0YXRzQ29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChpc1NlY3Rpb25FbmFibGVkKHRoaXMuX2NvbmZpZywgU3RhdHNTZWN0aW9ucy5MYXRlbmN5VGVzdCkpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sU3RhdHMuYXBwZW5kQ2hpbGQodGhpcy5sYXRlbmN5VGVzdC5yb290RWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTZWN0aW9uRW5hYmxlZCh0aGlzLl9jb25maWcsIFN0YXRzU2VjdGlvbnMuRGF0YUNoYW5uZWxMYXRlbmN5VGVzdCkpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sU3RhdHMuYXBwZW5kQ2hpbGQodGhpcy5kYXRhQ2hhbm5lbExhdGVuY3lUZXN0LnJvb3RFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHNDb250ZW50RWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IHN0YXRpc3RpY3NDb250YWluZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3RhdGlzdGljc0NvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGlzdGljc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGlzdGljc0NvbnRhaW5lci5pZCA9ICdzdGF0aXN0aWNzQ29udGFpbmVyJztcbiAgICAgICAgICAgIHRoaXMuX3N0YXRpc3RpY3NDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZC1ub25lJyk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0aXN0aWNzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuc3RhdHNSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0aXN0aWNzQ29udGFpbmVyO1xuICAgIH1cbiAgICBnZXQgbGF0ZW5jeVN0YXRzQ29udGFpbmVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xhdGVuY3lTdGF0c0NvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeVN0YXRzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5U3RhdHNDb250YWluZXIuaWQgPSAnbGF0ZW5jeVN0YXRzQ29udGFpbmVyJztcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lTdGF0c0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdkLW5vbmUnKTtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lTdGF0c0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmxhdGVuY3lSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXRlbmN5U3RhdHNDb250YWluZXI7XG4gICAgfVxuICAgIGdldCBzdGF0c1Jlc3VsdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0c1Jlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdHNSZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRzUmVzdWx0LmlkID0gJ3N0YXRpc3RpY3NSZXN1bHQnO1xuICAgICAgICAgICAgdGhpcy5fc3RhdHNSZXN1bHQuY2xhc3NMaXN0LmFkZCgnU3RhdHNSZXN1bHQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHNSZXN1bHQ7XG4gICAgfVxuICAgIGdldCBsYXRlbmN5UmVzdWx0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xhdGVuY3lSZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lSZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lSZXN1bHQuaWQgPSAnbGF0ZW5jeVJlc3VsdCc7XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5UmVzdWx0LmNsYXNzTGlzdC5hZGQoJ1N0YXRzUmVzdWx0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhdGVuY3lSZXN1bHQ7XG4gICAgfVxuICAgIGdldCBzdGF0c0Nsb3NlQnV0dG9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXRzQ2xvc2VCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRzQ2xvc2VCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRzQ2xvc2VCdXR0b24uaWQgPSAnc3RhdHNDbG9zZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRzQ2xvc2VCdXR0b247XG4gICAgfVxuICAgIG9uRGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5sYXRlbmN5VGVzdC5sYXRlbmN5VGVzdEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsTGF0ZW5jeVRlc3QubGF0ZW5jeVRlc3RCdXR0b24ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vZG8gbm90aGluZ1xuICAgICAgICB9O1xuICAgIH1cbiAgICBvblZpZGVvSW5pdGlhbGl6ZWQoc3RyZWFtKSB7XG4gICAgICAgIC8vIHN0YXJ0aW5nIGEgbGF0ZW5jeSBjaGVja1xuICAgICAgICB0aGlzLmxhdGVuY3lUZXN0LmxhdGVuY3lUZXN0QnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBzdHJlYW0ucmVxdWVzdExhdGVuY3lUZXN0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWxMYXRlbmN5VGVzdC5sYXRlbmN5VGVzdEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRlZCA9IHN0cmVhbS5yZXF1ZXN0RGF0YUNoYW5uZWxMYXRlbmN5VGVzdCh7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDEwMDAsXG4gICAgICAgICAgICAgICAgcnBzOiAxMCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0U2l6ZTogMjAwLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlU2l6ZTogMjAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbExhdGVuY3lUZXN0LmhhbmRsZVRlc3RTdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25maWd1cmUoc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLkRpc2FibGVMYXRlbmN5VGVzdCkge1xuICAgICAgICAgICAgdGhpcy5sYXRlbmN5VGVzdC5sYXRlbmN5VGVzdEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmxhdGVuY3lUZXN0LmxhdGVuY3lUZXN0QnV0dG9uLnRpdGxlID0gJ0Rpc2FibGVkIGJ5IC1QaXhlbFN0cmVhbWluZ0Rpc2FibGVMYXRlbmN5VGVzdGVyPXRydWUnO1xuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbExhdGVuY3lUZXN0LmxhdGVuY3lUZXN0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5uZWxMYXRlbmN5VGVzdC5sYXRlbmN5VGVzdEJ1dHRvbi50aXRsZSA9XG4gICAgICAgICAgICAgICAgJ0Rpc2FibGVkIGJ5IC1QaXhlbFN0cmVhbWluZ0Rpc2FibGVMYXRlbmN5VGVzdGVyPXRydWUnO1xuICAgICAgICAgICAgTG9nZ2VyLkluZm8oJy1QaXhlbFN0cmVhbWluZ0Rpc2FibGVMYXRlbmN5VGVzdGVyPXRydWUsIHJlcXVlc3RpbmcgbGF0ZW5jeSByZXBvcnQgZnJvbSB0aGUgdGhlIGJyb3dzZXIgdG8gVUUgaXMgZGlzYWJsZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyBzdGF0cyBwYW5lbC5cbiAgICAgKi9cbiAgICBzaG93KCkge1xuICAgICAgICBpZiAoIXRoaXMucm9vdEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYW5lbC13cmFwLXZpc2libGUnKSkge1xuICAgICAgICAgICAgdGhpcy5yb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdwYW5lbC13cmFwLXZpc2libGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHN0YXRzIHBhbmVsLlxuICAgICAqL1xuICAgIHRvZ2dsZVZpc2liaWxpdHkoKSB7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSgncGFuZWwtd3JhcC12aXNpYmxlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGUgdGhlIHN0YXRzIHBhbmVsLlxuICAgICAqL1xuICAgIGhpZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygncGFuZWwtd3JhcC12aXNpYmxlJykpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgncGFuZWwtd3JhcC12aXNpYmxlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlUGxheWVyQ291bnQocGxheWVyQ291bnQpIHtcbiAgICAgICAgdGhpcy5hZGRPclVwZGF0ZVNlc3Npb25TdGF0KCdQbGF5ZXJDb3VudFN0YXQnLCAnUGxheWVycycsIHBsYXllckNvdW50LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgc3RhdHMgY29taW5nIGluIGZyb20gYnJvd3Nlci9VRVxuICAgICAqIEBwYXJhbSBzdGF0cyAtIHRoZSBzdGF0cyBzdHJ1Y3R1cmVcbiAgICAgKi9cbiAgICBoYW5kbGVTdGF0cyhzdGF0cykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIC8vIGZvcm1hdCBudW1iZXJpbmcgYmFzZWQgb24gdGhlIGJyb3dzZXIgbGFuZ3VhZ2VcbiAgICAgICAgY29uc3QgbnVtYmVyRm9ybWF0ID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2UsIHtcbiAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvblRlc3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvblRlc3QuaGFuZGxlU3RhdHMoc3RhdHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluYm91bmQgZGF0YVxuICAgICAgICBjb25zdCBpbmJvdW5kRGF0YSA9IE1hdGhVdGlscy5mb3JtYXRCeXRlcyhzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5ieXRlc1JlY2VpdmVkLCAyKTtcbiAgICAgICAgdGhpcy5hZGRPclVwZGF0ZVNlc3Npb25TdGF0KCdJbmJvdW5kRGF0YVN0YXQnLCAnUmVjZWl2ZWQnLCBpbmJvdW5kRGF0YSk7XG4gICAgICAgIC8vIFBhY2tldHMgbG9zdFxuICAgICAgICBjb25zdCBwYWNrZXRzTG9zdFN0YXQgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMsICdwYWNrZXRzTG9zdCcpXG4gICAgICAgICAgICA/IG51bWJlckZvcm1hdC5mb3JtYXQoc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMucGFja2V0c0xvc3QpXG4gICAgICAgICAgICA6ICdDaHJvbWUgb25seSc7XG4gICAgICAgIHRoaXMuYWRkT3JVcGRhdGVTZXNzaW9uU3RhdCgnUGFja2V0c0xvc3RTdGF0JywgJ1BhY2tldHMgTG9zdCcsIHBhY2tldHNMb3N0U3RhdCk7XG4gICAgICAgIC8vIEJpdHJhdGVcbiAgICAgICAgaWYgKHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmJpdHJhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JVcGRhdGVTZXNzaW9uU3RhdCgnVmlkZW9CaXRyYXRlU3RhdCcsICdWaWRlbyBCaXRyYXRlIChrYnBzKScsIHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmJpdHJhdGUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRzLmluYm91bmRBdWRpb1N0YXRzLmJpdHJhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JVcGRhdGVTZXNzaW9uU3RhdCgnQXVkaW9CaXRyYXRlU3RhdCcsICdBdWRpbyBCaXRyYXRlIChrYnBzKScsIHN0YXRzLmluYm91bmRBdWRpb1N0YXRzLmJpdHJhdGUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmlkZW8gcmVzb2x1dGlvblxuICAgICAgICBjb25zdCByZXNTdGF0ID0gc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuZnJhbWVXaWR0aCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZVdpZHRoID4gMCAmJlxuICAgICAgICAgICAgc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuZnJhbWVIZWlnaHQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuZnJhbWVIZWlnaHQgPiAwXG4gICAgICAgICAgICA/IHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lV2lkdGggKyAneCcgKyBzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZUhlaWdodFxuICAgICAgICAgICAgOiAnQ2hyb21lIG9ubHknO1xuICAgICAgICB0aGlzLmFkZE9yVXBkYXRlU2Vzc2lvblN0YXQoJ1ZpZGVvUmVzU3RhdCcsICdWaWRlbyByZXNvbHV0aW9uJywgcmVzU3RhdCk7XG4gICAgICAgIC8vIEZyYW1lcyBkZWNvZGVkXG4gICAgICAgIGlmIChzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZXNEZWNvZGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lc0RlY29kZWQgPSBudW1iZXJGb3JtYXQuZm9ybWF0KHN0YXRzLmluYm91bmRWaWRlb1N0YXRzLmZyYW1lc0RlY29kZWQpO1xuICAgICAgICAgICAgdGhpcy5hZGRPclVwZGF0ZVNlc3Npb25TdGF0KCdGcmFtZXNEZWNvZGVkU3RhdCcsICdGcmFtZXMgRGVjb2RlZCcsIGZyYW1lc0RlY29kZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZyYW1lcmF0ZVxuICAgICAgICBpZiAoc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuZnJhbWVzUGVyU2Vjb25kKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yVXBkYXRlU2Vzc2lvblN0YXQoJ0ZyYW1lcmF0ZVN0YXQnLCAnRnJhbWVyYXRlJywgc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuZnJhbWVzUGVyU2Vjb25kLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZyYW1lcyBkcm9wcGVkXG4gICAgICAgIGlmIChzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZXNEcm9wcGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JVcGRhdGVTZXNzaW9uU3RhdCgnRnJhbWVzRHJvcHBlZFN0YXQnLCAnRnJhbWVzIGRyb3BwZWQnLCBzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5mcmFtZXNEcm9wcGVkLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0cy5pbmJvdW5kVmlkZW9TdGF0cy5jb2RlY0lkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yVXBkYXRlU2Vzc2lvblN0YXQoJ1ZpZGVvQ29kZWNTdGF0JywgJ1ZpZGVvIGNvZGVjJywgXG4gICAgICAgICAgICAvLyBTcGxpdCB0aGUgY29kZWMgdG8gcmVtb3ZlIHRoZSBGbXRwIGxpbmVcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHN0YXRzLmNvZGVjcy5nZXQoc3RhdHMuaW5ib3VuZFZpZGVvU3RhdHMuY29kZWNJZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5taW1lVHlwZS5yZXBsYWNlKCd2aWRlby8nLCAnJykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHMuaW5ib3VuZEF1ZGlvU3RhdHMuY29kZWNJZCkge1xuICAgICAgICAgICAgdGhpcy5hZGRPclVwZGF0ZVNlc3Npb25TdGF0KCdBdWRpb0NvZGVjU3RhdCcsICdBdWRpbyBjb2RlYycsIFxuICAgICAgICAgICAgLy8gU3BsaXQgdGhlIGNvZGVjIHRvIHJlbW92ZSB0aGUgRm10cCBsaW5lXG4gICAgICAgICAgICAoX2QgPSAoX2MgPSBzdGF0cy5jb2RlY3MuZ2V0KHN0YXRzLmluYm91bmRBdWRpb1N0YXRzLmNvZGVjSWQpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubWltZVR5cGUucmVwbGFjZSgnYXVkaW8vJywgJycpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgdGhlIGFjdGl2ZSBjYW5kaWRhdGUgcGFpciByZXR1cm4gYSBuZXcgQ2FuZGlkYXRlIHBhaXIgc3RhdCBpZiBnZXRBY3RpdmVDYW5kaWRhdGUgaXMgbnVsbFxuICAgICAgICBjb25zdCBhY3RpdmVDYW5kaWRhdGVQYWlyID0gc3RhdHMuZ2V0QWN0aXZlQ2FuZGlkYXRlUGFpcigpO1xuICAgICAgICBpZiAoYWN0aXZlQ2FuZGlkYXRlUGFpcikge1xuICAgICAgICAgICAgLy8gUlRUXG4gICAgICAgICAgICBjb25zdCBuZXRSVFQgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYWN0aXZlQ2FuZGlkYXRlUGFpciwgJ2N1cnJlbnRSb3VuZFRyaXBUaW1lJykgJiZcbiAgICAgICAgICAgICAgICBzdGF0cy5pc051bWJlcihhY3RpdmVDYW5kaWRhdGVQYWlyLmN1cnJlbnRSb3VuZFRyaXBUaW1lKVxuICAgICAgICAgICAgICAgID8gTWF0aC5jZWlsKGFjdGl2ZUNhbmRpZGF0ZVBhaXIuY3VycmVudFJvdW5kVHJpcFRpbWUgKiAxMDAwKS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgOiBcIkNhbid0IGNhbGN1bGF0ZVwiO1xuICAgICAgICAgICAgdGhpcy5hZGRPclVwZGF0ZVNlc3Npb25TdGF0KCdSVFRTdGF0JywgJ05ldCBSVFQgKG1zKScsIG5ldFJUVCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRPclVwZGF0ZVNlc3Npb25TdGF0KCdEdXJhdGlvblN0YXQnLCAnRHVyYXRpb24nLCBzdGF0cy5zZXNzaW9uU3RhdHMucnVuVGltZSk7XG4gICAgICAgIHRoaXMuYWRkT3JVcGRhdGVTZXNzaW9uU3RhdCgnQ29udHJvbHNJbnB1dFN0YXQnLCAnQ29udHJvbHMgc3RyZWFtIGlucHV0Jywgc3RhdHMuc2Vzc2lvblN0YXRzLmNvbnRyb2xzU3RyZWFtSW5wdXQpO1xuICAgICAgICAvLyBRUFxuICAgICAgICBpZiAoc3RhdHMuc2Vzc2lvblN0YXRzLnZpZGVvRW5jb2RlckF2Z1FQICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFOdW1iZXIuaXNOYU4oc3RhdHMuc2Vzc2lvblN0YXRzLnZpZGVvRW5jb2RlckF2Z1FQKSkge1xuICAgICAgICAgICAgdGhpcy5hZGRPclVwZGF0ZVNlc3Npb25TdGF0KCdRUFN0YXQnLCAnVmlkZW8gcXVhbnRpemF0aW9uIHBhcmFtZXRlcicsIHN0YXRzLnNlc3Npb25TdGF0cy52aWRlb0VuY29kZXJBdmdRUC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBMb2dnZXIuSW5mbyhgLS0tLS0tLS0tIFN0YXRzIC0tLS0tLS0tLVxcbiAke0pTT04uc3RyaW5naWZ5KHN0YXRzKX1cXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1gKTtcbiAgICB9XG4gICAgaGFuZGxlTGF0ZW5jeUluZm8obGF0ZW5jeUluZm8pIHtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvblRlc3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvblRlc3QuaGFuZGxlTGF0ZW5jeUluZm8obGF0ZW5jeUluZm8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXRlbmN5SW5mby5mcmFtZVRpbWluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBFbmNvZGVyIGxhdGVuY3lcbiAgICAgICAgICAgIGlmIChsYXRlbmN5SW5mby5mcmFtZVRpbWluZy5lbmNvZGVyTGF0ZW5jeU1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE9yVXBkYXRlTGF0ZW5jeVN0YXQoJ0VuY29kZUxhdGVuY3knLCAnRW5jb2RlIGxhdGVuY3kgKG1zKScsIE1hdGguY2VpbChsYXRlbmN5SW5mby5mcmFtZVRpbWluZy5lbmNvZGVyTGF0ZW5jeU1zKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhY2tldGl6ZXIgbGF0ZW5jeVxuICAgICAgICAgICAgaWYgKGxhdGVuY3lJbmZvLmZyYW1lVGltaW5nLnBhY2tldGl6ZUxhdGVuY3lNcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRPclVwZGF0ZUxhdGVuY3lTdGF0KCdQYWNrZXRpemVyTGF0ZW5jeScsICdQYWNrZXRpemVyIGxhdGVuY3kgKG1zKScsIE1hdGguY2VpbChsYXRlbmN5SW5mby5mcmFtZVRpbWluZy5wYWNrZXRpemVMYXRlbmN5TXMpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFjZXIgbGF0ZW5jeVxuICAgICAgICAgICAgaWYgKGxhdGVuY3lJbmZvLmZyYW1lVGltaW5nLnBhY2VyTGF0ZW5jeU1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE9yVXBkYXRlTGF0ZW5jeVN0YXQoJ1BhY2VyTGF0ZW5jeScsICdQYWNlciBsYXRlbmN5IChtcyknLCBNYXRoLmNlaWwobGF0ZW5jeUluZm8uZnJhbWVUaW1pbmcucGFjZXJMYXRlbmN5TXMpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2VuZGVyIGxhdGVuY3kgY2FsY3VsYXRlZCB1c2luZyB0aW1pbmcgc3RhdHNcbiAgICAgICAgICAgIGlmIChsYXRlbmN5SW5mby5mcmFtZVRpbWluZy5jYXB0dXJlVG9TZW5kTGF0ZW5jeU1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE9yVXBkYXRlTGF0ZW5jeVN0YXQoJ1ZpZGVvVGltaW5nQ2FwdHVyZVRvU2VuZCcsICdQb3N0LWNhcHR1cmUgdG8gc2VuZCBsYXRlbmN5IChtcyknLCBNYXRoLmNlaWwobGF0ZW5jeUluZm8uZnJhbWVUaW1pbmcuY2FwdHVyZVRvU2VuZExhdGVuY3lNcykudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhdGVuY3lJbmZvLnNlbmRlckxhdGVuY3lNcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yVXBkYXRlTGF0ZW5jeVN0YXQoJ0Fic0NhcHR1cmVUaW1lVG9TZW5kTGF0ZW5jeScsICdQb3N0LWNhcHR1cmUgKGFicy1jdCkgdG8gc2VuZCBsYXRlbmN5IChtcyknLCBNYXRoLmNlaWwobGF0ZW5jeUluZm8uc2VuZGVyTGF0ZW5jeU1zKS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF0ZW5jeUluZm8uYXZlcmFnZUFzc2VtYmx5RGVsYXlNcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yVXBkYXRlTGF0ZW5jeVN0YXQoJ0F2Z0Fzc2VtYmx5RGVsYXknLCAnQXNzZW1ibHkgZGVsYXkgKG1zKScsIE1hdGguY2VpbChsYXRlbmN5SW5mby5hdmVyYWdlQXNzZW1ibHlEZWxheU1zKS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF0ZW5jeUluZm8uYXZlcmFnZURlY29kZUxhdGVuY3lNcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yVXBkYXRlTGF0ZW5jeVN0YXQoJ0F2Z0RlY29kZURlbGF5JywgJ0RlY29kZSB0aW1lIChtcyknLCBNYXRoLmNlaWwobGF0ZW5jeUluZm8uYXZlcmFnZURlY29kZUxhdGVuY3lNcykudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhdGVuY3lJbmZvLmF2ZXJhZ2VKaXR0ZXJCdWZmZXJEZWxheU1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JVcGRhdGVMYXRlbmN5U3RhdCgnQXZnSml0dGVyQnVmZmVyRGVsYXknLCAnSml0dGVyIGJ1ZmZlciAobXMpJywgTWF0aC5jZWlsKGxhdGVuY3lJbmZvLmF2ZXJhZ2VKaXR0ZXJCdWZmZXJEZWxheU1zKS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF0ZW5jeUluZm8uYXZlcmFnZVByb2Nlc3NpbmdEZWxheU1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JVcGRhdGVMYXRlbmN5U3RhdCgnQXZnUHJvY2Vzc2luZ0RlbGF5JywgJ1Byb2Nlc3NpbmcgZGVsYXkgKG1zKScsIE1hdGguY2VpbChsYXRlbmN5SW5mby5hdmVyYWdlUHJvY2Vzc2luZ0RlbGF5TXMpLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXRlbmN5SW5mby5hdmVyYWdlRTJFTGF0ZW5jeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yVXBkYXRlTGF0ZW5jeVN0YXQoJ0F2Z0UyRUxhdGVuY3knLCAnVG90YWwgbGF0ZW5jeSAobXMpJywgTWF0aC5jZWlsKGxhdGVuY3lJbmZvLmF2ZXJhZ2VFMkVMYXRlbmN5KS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IHN0YXQgdG8gdGhlIHN0YXRzIHJlc3VsdHMgaW4gdGhlIERPTSBvciB1cGRhdGVzIGFuIGV4aXRpbmcgc3RhdC5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIHN0YXQgdG8gYWRkL3VwZGF0ZS5cbiAgICAgKiBAcGFyYW0gc3RhdCAtIFRoZSBjb250ZW50cyBvZiB0aGUgc3RhdC5cbiAgICAgKi9cbiAgICBhZGRPclVwZGF0ZVNlc3Npb25TdGF0KGlkLCBzdGF0TGFiZWwsIHN0YXQpIHtcbiAgICAgICAgdGhpcy5hZGRPclVwZGF0ZVN0YXQoU3RhdHNTZWN0aW9ucy5TZXNzaW9uU3RhdHMsIGlkLCBzdGF0TGFiZWwsIHN0YXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IHN0YXQgdG8gdGhlIGxhdGVuY3kgcmVzdWx0cyBpbiB0aGUgRE9NIG9yIHVwZGF0ZXMgYW4gZXhpdGluZyBzdGF0LlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgc3RhdCB0byBhZGQvdXBkYXRlLlxuICAgICAqIEBwYXJhbSBzdGF0IC0gVGhlIGNvbnRlbnRzIG9mIHRoZSBzdGF0LlxuICAgICAqL1xuICAgIGFkZE9yVXBkYXRlTGF0ZW5jeVN0YXQoaWQsIHN0YXRMYWJlbCwgc3RhdCkge1xuICAgICAgICB0aGlzLmFkZE9yVXBkYXRlU3RhdChTdGF0c1NlY3Rpb25zLkxhdGVuY3lTdGF0cywgaWQsIHN0YXRMYWJlbCwgc3RhdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgc3RhdCB0byB0aGUgc3RhdHMgcmVzdWx0cyBpbiB0aGUgRE9NIG9yIHVwZGF0ZXMgYW4gZXhpdGluZyBzdGF0LlxuICAgICAqIEBwYXJhbSBzZWN0aW9uSWQgLSBUaGUgc2VjdGlvbiB0byBhZGQgdGhpcyBzdGF0IHRvby5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIHN0YXQgdG8gYWRkL3VwZGF0ZS5cbiAgICAgKiBAcGFyYW0gc3RhdCAtIFRoZSBjb250ZW50cyBvZiB0aGUgc3RhdC5cbiAgICAgKi9cbiAgICBhZGRPclVwZGF0ZVN0YXQoc2VjdGlvbklkLCBpZCwgc3RhdExhYmVsLCBzdGF0KSB7XG4gICAgICAgIGlmIChzZWN0aW9uSWQgPT09IFN0YXRzU2VjdGlvbnMuU2Vzc2lvblN0YXRzICYmXG4gICAgICAgICAgICAhaXNTZWN0aW9uRW5hYmxlZCh0aGlzLl9jb25maWcsIFN0YXRzU2VjdGlvbnMuU2Vzc2lvblN0YXRzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWN0aW9uSWQgPT09IFN0YXRzU2VjdGlvbnMuTGF0ZW5jeVN0YXRzICYmXG4gICAgICAgICAgICAhaXNTZWN0aW9uRW5hYmxlZCh0aGlzLl9jb25maWcsIFN0YXRzU2VjdGlvbnMuTGF0ZW5jeVN0YXRzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgc3VwcG9ydCBzZXNzaW9uIG9yIGxhdGVuY3kgc3RhdHMgYmVpbmcgdXBkYXRlZCBpbiB0aGlzIGZ1bmN0aW9uIGN1cnJlbnRseVxuICAgICAgICBpZiAoc2VjdGlvbklkICE9PSBTdGF0c1NlY3Rpb25zLlNlc3Npb25TdGF0cyAmJiBzZWN0aW9uSWQgIT09IFN0YXRzU2VjdGlvbnMuTGF0ZW5jeVN0YXRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50RWxlbSA9IHNlY3Rpb25JZCA9PT0gU3RhdHNTZWN0aW9ucy5TZXNzaW9uU3RhdHMgPyB0aGlzLnN0YXRzUmVzdWx0IDogdGhpcy5sYXRlbmN5UmVzdWx0O1xuICAgICAgICBjb25zdCBzdGF0SFRNTCA9IGAke3N0YXRMYWJlbH06ICR7c3RhdH1gO1xuICAgICAgICBpZiAoIXRoaXMuc3RhdHNNYXAuaGFzKGlkKSkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBzdGF0XG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ID0gbmV3IFN0YXQoKTtcbiAgICAgICAgICAgIG5ld1N0YXQuaWQgPSBpZDtcbiAgICAgICAgICAgIG5ld1N0YXQuc3RhdCA9IHN0YXQ7XG4gICAgICAgICAgICBuZXdTdGF0LnRpdGxlID0gc3RhdExhYmVsO1xuICAgICAgICAgICAgbmV3U3RhdC5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBuZXdTdGF0LmVsZW1lbnQuaW5uZXJIVE1MID0gc3RhdEhUTUw7XG4gICAgICAgICAgICAvLyBhZGQgdGhlIHN0YXQgdG8gdGhlIGRvbVxuICAgICAgICAgICAgcGFyZW50RWxlbS5hcHBlbmRDaGlsZChuZXdTdGF0LmVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5zdGF0c01hcC5zZXQoaWQsIG5ld1N0YXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgZXhpc3Rpbmcgc3RhdFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zdGF0c01hcC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5lbGVtZW50LmlubmVySFRNTCA9IHN0YXRIVE1MO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhdHNQYW5lbC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgRXBpYyBHYW1lcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuZXhwb3J0IGNsYXNzIEV4dHJhRmxhZ3Mge1xufVxuRXh0cmFGbGFncy5MaWdodE1vZGUgPSAnTGlnaHRNb2RlJztcbi8qKlxuICogQWxsIHRoZSBVSSBzZWN0aW9ucyBhY3Jvc3MgYWxsIHRoZSBwYW5lbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXR0aW5nc1NlY3Rpb25zIHtcbn1cblNldHRpbmdzU2VjdGlvbnMuUGl4ZWxTdHJlYW1pbmcgPSAnUGl4ZWwgU3RyZWFtaW5nJztcblNldHRpbmdzU2VjdGlvbnMuVUkgPSAnVUknO1xuU2V0dGluZ3NTZWN0aW9ucy5JbnB1dCA9ICdJbnB1dCc7XG5TZXR0aW5nc1NlY3Rpb25zLkVuY29kZXIgPSAnRW5jb2Rlcic7XG5TZXR0aW5nc1NlY3Rpb25zLldlYlJUQyA9ICdXZWJSVEMnO1xuU2V0dGluZ3NTZWN0aW9ucy5Db21tYW5kcyA9ICdDb21tYW5kcyc7XG5leHBvcnQgY2xhc3MgU3RhdHNTZWN0aW9ucyB7XG59XG5TdGF0c1NlY3Rpb25zLlNlc3Npb25TdGF0cyA9ICdTZXNzaW9uIFN0YXRzJztcblN0YXRzU2VjdGlvbnMuTGF0ZW5jeVN0YXRzID0gJ0xhdGVuY3kgU3RhdHMnO1xuU3RhdHNTZWN0aW9ucy5MYXRlbmN5VGVzdCA9ICdMYXRlbmN5IFRlc3QnO1xuU3RhdHNTZWN0aW9ucy5EYXRhQ2hhbm5lbExhdGVuY3lUZXN0ID0gJ0RhdGEgQ2hhbm5lbCBMYXRlbmN5IFRlc3QnO1xuU3RhdHNTZWN0aW9ucy5TZXNzaW9uVGVzdCA9ICdTZXNzaW9uIFRlc3QnO1xuLyoqIFdoZXRoZXIgYSBzdHJlYW0gVUkgZWxlbWVudCBpcyBpbnRlcm5hbGx5IG1hZGUsIGV4dGVybmFsbHkgcHJvdmlkZWQsIG9yIGRpc2FibGVkLiAqL1xuZXhwb3J0IHZhciBVSUVsZW1lbnRDcmVhdGlvbk1vZGU7XG4oZnVuY3Rpb24gKFVJRWxlbWVudENyZWF0aW9uTW9kZSkge1xuICAgIFVJRWxlbWVudENyZWF0aW9uTW9kZVtVSUVsZW1lbnRDcmVhdGlvbk1vZGVbXCJDcmVhdGVEZWZhdWx0RWxlbWVudFwiXSA9IDBdID0gXCJDcmVhdGVEZWZhdWx0RWxlbWVudFwiO1xuICAgIFVJRWxlbWVudENyZWF0aW9uTW9kZVtVSUVsZW1lbnRDcmVhdGlvbk1vZGVbXCJVc2VDdXN0b21FbGVtZW50XCJdID0gMV0gPSBcIlVzZUN1c3RvbUVsZW1lbnRcIjtcbiAgICBVSUVsZW1lbnRDcmVhdGlvbk1vZGVbVUlFbGVtZW50Q3JlYXRpb25Nb2RlW1wiRGlzYWJsZVwiXSA9IDJdID0gXCJEaXNhYmxlXCI7XG59KShVSUVsZW1lbnRDcmVhdGlvbk1vZGUgfHwgKFVJRWxlbWVudENyZWF0aW9uTW9kZSA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gaXNQYW5lbEVuYWJsZWQoY29uZmlnKSB7XG4gICAgcmV0dXJuICFjb25maWcgfHwgKCEhY29uZmlnICYmIGNvbmZpZy5pc0VuYWJsZWQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU2VjdGlvbkVuYWJsZWQoY29uZmlnLCBzZWN0aW9uKSB7XG4gICAgcmV0dXJuICghY29uZmlnIHx8XG4gICAgICAgICghIWNvbmZpZyAmJlxuICAgICAgICAgICAgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLnNlY3Rpb25WaXNpYmlsaXR5LCBzZWN0aW9uKSB8fFxuICAgICAgICAgICAgICAgIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLnNlY3Rpb25WaXNpYmlsaXR5LCBzZWN0aW9uKSAmJlxuICAgICAgICAgICAgICAgICAgICBjb25maWcuc2VjdGlvblZpc2liaWxpdHlbc2VjdGlvbl0pKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU2V0dGluZ0VuYWJsZWQoY29uZmlnLCBzZXR0aW5nKSB7XG4gICAgcmV0dXJuICghY29uZmlnIHx8XG4gICAgICAgICghIWNvbmZpZyAmJlxuICAgICAgICAgICAgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLnNldHRpbmdWaXNpYmlsaXR5LCBzZXR0aW5nKSB8fFxuICAgICAgICAgICAgICAgIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLnNldHRpbmdWaXNpYmlsaXR5LCBzZXR0aW5nKSAmJlxuICAgICAgICAgICAgICAgICAgICBjb25maWcuc2V0dGluZ1Zpc2liaWxpdHlbc2V0dGluZ10pKSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VUlDb25maWd1cmF0aW9uVHlwZXMuanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8qKlxuICogQSBVSSBlbGVtZW50IHNob3dpbmcgdGhlIFFQIChxdWFudGl6YXRpb24gcGFyYW1ldGVyKSBvZiB0aGUgdmlkZW8gc3RyZWFtIGF0IHRoZSBsYXN0IGVuY29kZWQgZnJhbWUgKHdlbGwsIGxhc3QgdHJhbnNtaXR0ZWQgUVAgcmVhbGx5KS5cbiAqIEEgYmxvY2tpZXIgZW5jb2Rpbmcgd2lsbCBoYXZlIGEgaGlnaGVyIFFQIGFuZCB0aGlzIHdpbGwgbWFrZSB0aGUgaW5kaWNhdG9yIHR1cm4gbW9yZSByZWQuXG4gKiBBIG5vbi1ibG9ja3kgc3RyZWFtIHdpbGwgaGF2ZSBhIGxvd2VyIFFQIGFuZCB0aGlzIHdpbGwgbWFrZSB0aGUgaW5kaWNhdG9yIHR1cm4gbW9yZSBncmVlbi5cbiAqIFRoZSBRUCBpbmRpY2F0b3IgaXMgcmVwcmVzZW50ZWQgdmlzdWFsbHkgdXNpbmcgYSBXaUZpIGljb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBWaWRlb1FwSW5kaWNhdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy52aWRlb0VuY29kZXJBdmdRUCA9IC0xO1xuICAgICAgICAvLyBub24gaHRtbCBlbGVtZW50c1xuICAgICAgICB0aGlzLnN0YXRzVGV4dCA9ICcnO1xuICAgICAgICB0aGlzLmNvbG9yID0gJyc7XG4gICAgICAgIC8vIHFwIGNvbG9yc1xuICAgICAgICB0aGlzLm9yYW5nZVFQID0gMjY7XG4gICAgICAgIHRoaXMucmVkUVAgPSAzNTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcm9vdCBlbGVtZW50IG9mIHRoZSBRUCBpbmRpY2F0b3IuXG4gICAgICovXG4gICAgZ2V0IHJvb3RFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByb290IGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgc3ZnIGZvciB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmlkID0gJ2Nvbm5lY3Rpb24nO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnVWlUb29sJyk7XG4gICAgICAgICAgICAvLyBhZGQgc3ZnIGljb24gZm9yIHRoZSBjb25uZWN0aW9uIHN0cmVuZ3RoXG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnF1YWxpdHlTdGF0dXMpO1xuICAgICAgICAgICAgLy8gYWRkIHRoZSB0ZXh0IHVuZGVybmVhdGggdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMucXVhbGl0eVRleHQpO1xuICAgICAgICAgICAgLy8gc2V0IGNvbG9ycyB0byBub3QgY29ubmVjdGVkIGluaXRpYWxseVxuICAgICAgICAgICAgdGhpcy51cGRhdGVRcFRvb2x0aXAoLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290RWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0ZXh0IHRoYXQgZGlzcGxheXMgdW5kZXIgdGhlIGljb24uXG4gICAgICovXG4gICAgZ2V0IHF1YWxpdHlUZXh0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3F1YWxpdHlUZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl9xdWFsaXR5VGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHRoaXMuX3F1YWxpdHlUZXh0LmlkID0gJ3F1YWxpdHlUZXh0JztcbiAgICAgICAgICAgIHRoaXMuX3F1YWxpdHlUZXh0LmNsYXNzTGlzdC5hZGQoJ3Rvb2x0aXB0ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1YWxpdHlUZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGljb24uXG4gICAgICovXG4gICAgZ2V0IHF1YWxpdHlTdGF0dXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcXVhbGl0eVN0YXR1cykge1xuICAgICAgICAgICAgdGhpcy5fcXVhbGl0eVN0YXR1cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG4gICAgICAgICAgICB0aGlzLl9xdWFsaXR5U3RhdHVzLnNldEF0dHJpYnV0ZU5TKG51bGwsICdpZCcsICdjb25uZWN0aW9uU3RyZW5ndGgnKTtcbiAgICAgICAgICAgIHRoaXMuX3F1YWxpdHlTdGF0dXMuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gnLCAnMHB4Jyk7XG4gICAgICAgICAgICB0aGlzLl9xdWFsaXR5U3RhdHVzLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5JywgJzBweCcpO1xuICAgICAgICAgICAgdGhpcy5fcXVhbGl0eVN0YXR1cy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndmlld0JveCcsICcwIDAgNDk0LjQ1IDQ5NC40NScpO1xuICAgICAgICAgICAgLy8gYnVpbGQgd2lmaSBpY29uXG4gICAgICAgICAgICB0aGlzLnF1YWxpdHlTdGF0dXMuYXBwZW5kQ2hpbGQodGhpcy5kb3QpO1xuICAgICAgICAgICAgdGhpcy5xdWFsaXR5U3RhdHVzLmFwcGVuZENoaWxkKHRoaXMubWlkZGxlKTtcbiAgICAgICAgICAgIHRoaXMucXVhbGl0eVN0YXR1cy5hcHBlbmRDaGlsZCh0aGlzLm91dGVyKTtcbiAgICAgICAgICAgIHRoaXMucXVhbGl0eVN0YXR1cy5hcHBlbmRDaGlsZCh0aGlzLmlubmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcXVhbGl0eVN0YXR1cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkb3QgYXQgdGhlIGJvdHRvbSBvZiB0aGUgd2lmaSBpY29uLlxuICAgICAqL1xuICAgIGdldCBkb3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZG90KSB7XG4gICAgICAgICAgICB0aGlzLl9kb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2NpcmNsZScpO1xuICAgICAgICAgICAgdGhpcy5fZG90LnNldEF0dHJpYnV0ZU5TKG51bGwsICdpZCcsICdkb3QnKTtcbiAgICAgICAgICAgIHRoaXMuX2RvdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY3gnLCAnMjQ3LjEyNScpO1xuICAgICAgICAgICAgdGhpcy5fZG90LnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeScsICczOTguOTI1Jyk7XG4gICAgICAgICAgICB0aGlzLl9kb3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ3InLCAnMzUuMycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kb3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb3V0ZXIgYXJjIG9mIHRoZSB3aWZpIGljb24uXG4gICAgICovXG4gICAgZ2V0IG91dGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX291dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9vdXRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncGF0aCcpO1xuICAgICAgICAgICAgdGhpcy5fb3V0ZXIuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2lkJywgJ291dGVyJyk7XG4gICAgICAgICAgICB0aGlzLl9vdXRlci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsICdNNDY3LjkyNSwyMDQuNjI1Yy02LjgsMC0xMy41LTIuNi0xOC43LTcuOGMtMTExLjUtMTExLjQtMjkyLjctMTExLjQtNDA0LjEsMGMtMTAuMywxMC4zLTI3LjEsMTAuMy0zNy40LDBzLTEwLjMtMjcuMSwwLTM3LjRjNjQtNjQsMTQ5LTk5LjIsMjM5LjUtOTkuMnMxNzUuNSwzNS4yLDIzOS41LDk5LjJjMTAuMywxMC4zLDEwLjMsMjcuMSwwLDM3LjRDNDgxLjQyNSwyMDIuMDI1LDQ3NC42MjUsMjA0LjYyNSw0NjcuOTI1LDIwNC42MjV6Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX291dGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1pZGRsZSBhcmMgb2YgdGhlIHdpZmkgaWNvbi5cbiAgICAgKi9cbiAgICBnZXQgbWlkZGxlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX21pZGRsZSkge1xuICAgICAgICAgICAgdGhpcy5fbWlkZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdwYXRoJyk7XG4gICAgICAgICAgICB0aGlzLl9taWRkbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2lkJywgJ21pZGRsZScpO1xuICAgICAgICAgICAgdGhpcy5fbWlkZGxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ00zOTUuMjI1LDI3Ny4zMjVjLTYuOCwwLTEzLjUtMi42LTE4LjctNy44Yy03MS40LTcxLjMtMTg3LjQtNzEuMy0yNTguOCwwYy0xMC4zLDEwLjMtMjcuMSwxMC4zLTM3LjQsMHMtMTAuMy0yNy4xLDAtMzcuNGM5Mi05MiwyNDEuNi05MiwzMzMuNiwwYzEwLjMsMTAuMywxMC4zLDI3LjEsMCwzNy40QzQwOC43MjUsMjc0LjcyNSw0MDEuOTI1LDI3Ny4zMjUsMzk1LjIyNSwyNzcuMzI1eicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9taWRkbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5uZXIgYXJjIG9mIHRoZSB3aWZpIGljb24uXG4gICAgICovXG4gICAgZ2V0IGlubmVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lubmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9pbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncGF0aCcpO1xuICAgICAgICAgICAgdGhpcy5faW5uZXIuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2lkJywgJ2lubmVyJyk7XG4gICAgICAgICAgICB0aGlzLl9pbm5lci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsICdNMzIzLjYyNSwzNDguODI1Yy02LjgsMC0xMy41LTIuNi0xOC43LTcuOGMtMTUuNC0xNS40LTM2LTIzLjktNTcuOC0yMy45cy00Mi40LDguNS01Ny44LDIzLjljLTEwLjMsMTAuMy0yNy4xLDEwLjMtMzcuNCwwYy0xMC4zLTEwLjMtMTAuMy0yNy4xLDAtMzcuNGMyNS40LTI1LjQsNTkuMi0zOS40LDk1LjItMzkuNHM2OS44LDE0LDk1LjIsMzkuNWMxMC4zLDEwLjMsMTAuMywyNy4xLDAsMzcuNEMzMzcuMjI1LDM0Ni4yMjUsMzMwLjQyNSwzNDguODI1LDMyMy42MjUsMzQ4LjgyNXonKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gc2V0IHRoZSBzcGVlZCBvZiB0aGUgc3RhdHVzIGxpZ2h0LlxuICAgICAqIEBwYXJhbSBzcGVlZCAtIFNldCB0aGUgc3BlZWQgb2YgdGhlIGJsaW5rLCBoaWdoZXIgbnVtYmVycyBtYWtlIHRoZSBzdGF0dXMgbGlnaHQgYmxpbmsgZmFzdGVyLlxuICAgICAqL1xuICAgIGJsaW5rVmlkZW9RdWFsaXR5U3RhdHVzKHNwZWVkKSB7XG4gICAgICAgIGxldCBpdGVyYXRpb24gPSBzcGVlZDtcbiAgICAgICAgbGV0IG9wYWNpdHkgPSAxO1xuICAgICAgICBjb25zdCB0aWNrSUQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBvcGFjaXR5IC09IDAuMTtcbiAgICAgICAgICAgIHRoaXMucXVhbGl0eVRleHQuc3R5bGUub3BhY2l0eSA9IFN0cmluZyhNYXRoLmFicygob3BhY2l0eSAtIDAuNSkgKiAyKSk7XG4gICAgICAgICAgICBpZiAob3BhY2l0eSA8PSAwLjEpIHtcbiAgICAgICAgICAgICAgICBpZiAoLS1pdGVyYXRpb24gPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRpY2tJRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMCAvIHNwZWVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdXBkYXRlcyB0aGUgUVAgdG9vbHRpcCBieSBjb252ZXJ0aW5nIHRoZSBWaWRlbyBFbmNvZGVyIFFQIHRvIGEgY29sb3IgbGlnaHRcbiAgICAgKiBAcGFyYW0gUVAgLSBUaGUgdmlkZW8gZW5jb2RlciBRUCBudW1iZXIgbmVlZGVkIHRvIGZpbmQgdGhlIGF2ZXJhZ2VcbiAgICAgKi9cbiAgICB1cGRhdGVRcFRvb2x0aXAoUVApIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnZpZGVvRW5jb2RlckF2Z1FQID0gUVA7XG4gICAgICAgIGlmIChRUCA+IHRoaXMucmVkUVApIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSAncmVkJztcbiAgICAgICAgICAgIHRoaXMuYmxpbmtWaWRlb1F1YWxpdHlTdGF0dXMoMik7XG4gICAgICAgICAgICB0aGlzLnN0YXRzVGV4dCA9IGA8ZGl2IHN0eWxlPVwiY29sb3I6ICR7dGhpcy5jb2xvcn1cIj5Qb29yIGVuY29kaW5nIHF1YWxpdHk8L2Rpdj5gO1xuICAgICAgICAgICAgdGhpcy5vdXRlci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICcjM2MzYjQwJyk7XG4gICAgICAgICAgICB0aGlzLm1pZGRsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICcjM2MzYjQwJyk7XG4gICAgICAgICAgICB0aGlzLmlubmVyLnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgdGhpcy5jb2xvcik7XG4gICAgICAgICAgICB0aGlzLmRvdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsIHRoaXMuY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFFQID4gdGhpcy5vcmFuZ2VRUCkge1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9ICdvcmFuZ2UnO1xuICAgICAgICAgICAgdGhpcy5ibGlua1ZpZGVvUXVhbGl0eVN0YXR1cygxKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHNUZXh0ID0gYDxkaXYgc3R5bGU9XCJjb2xvcjogJHt0aGlzLmNvbG9yfVwiPkJsb2NreSBlbmNvZGluZyBxdWFsaXR5PC9kaXY+YDtcbiAgICAgICAgICAgIHRoaXMub3V0ZXIuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAnIzNjM2I0MCcpO1xuICAgICAgICAgICAgdGhpcy5taWRkbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCB0aGlzLmNvbG9yKTtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCB0aGlzLmNvbG9yKTtcbiAgICAgICAgICAgIHRoaXMuZG90LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgdGhpcy5jb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUVAgPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9ICcjYjBiMGIwJztcbiAgICAgICAgICAgIHRoaXMub3V0ZXIuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAnIzNjM2I0MCcpO1xuICAgICAgICAgICAgdGhpcy5taWRkbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAnIzNjM2I0MCcpO1xuICAgICAgICAgICAgdGhpcy5pbm5lci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICcjM2MzYjQwJyk7XG4gICAgICAgICAgICB0aGlzLmRvdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICcjM2MzYjQwJyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRzVGV4dCA9IGA8ZGl2IHN0eWxlPVwiY29sb3I6ICR7dGhpcy5jb2xvcn1cIj5Ob3QgY29ubmVjdGVkPC9kaXY+YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSAnbGltZSc7XG4gICAgICAgICAgICB0aGlzLnF1YWxpdHlTdGF0dXMuc3R5bGUub3BhY2l0eSA9ICgoX2EgPSB0aGlzLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhpZGVXaGVuR29vZCkgPT0gdHJ1ZSA/ICcwJyA6ICcxJztcbiAgICAgICAgICAgIHRoaXMuc3RhdHNUZXh0ID0gYDxkaXYgc3R5bGU9XCJjb2xvcjogJHt0aGlzLmNvbG9yfVwiPkNsZWFyIGVuY29kaW5nIHF1YWxpdHk8L2Rpdj5gO1xuICAgICAgICAgICAgdGhpcy5vdXRlci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsIHRoaXMuY29sb3IpO1xuICAgICAgICAgICAgdGhpcy5taWRkbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCB0aGlzLmNvbG9yKTtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCB0aGlzLmNvbG9yKTtcbiAgICAgICAgICAgIHRoaXMuZG90LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgdGhpcy5jb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWFsaXR5VGV4dC5pbm5lckhUTUwgPSB0aGlzLnN0YXRzVGV4dDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWRlb1FwSW5kaWNhdG9yLmpzLm1hcCIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vKipcbiAqIFhSIGljb24gdGhhdCBjYW4gYmUgY2xpY2tlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFhSSWNvbiB7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0aGUgYnV0dG9uIGNvbnRhaW5pbmcgdGhlIFhSIGljb24uXG4gICAgICovXG4gICAgZ2V0IHJvb3RFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQudHlwZSA9ICdidXR0b24nO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnVWlUb29sJyk7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5pZCA9ICd4ckJ0bic7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnhySWNvbik7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnRvb2x0aXBUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCB0b29sdGlwVGV4dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b29sdGlwVGV4dCkge1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwVGV4dC5jbGFzc0xpc3QuYWRkKCd0b29sdGlwdGV4dCcpO1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFRleHQuaW5uZXJIVE1MID0gJ1hSJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdG9vbHRpcFRleHQ7XG4gICAgfVxuICAgIGdldCB4ckljb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5feHJJY29uKSB7XG4gICAgICAgICAgICB0aGlzLl94ckljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3N2ZycpO1xuICAgICAgICAgICAgdGhpcy5feHJJY29uLnNldEF0dHJpYnV0ZU5TKG51bGwsICdpZCcsICd4ckljb24nKTtcbiAgICAgICAgICAgIHRoaXMuX3hySWNvbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsICcwcHgnKTtcbiAgICAgICAgICAgIHRoaXMuX3hySWNvbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneScsICcwcHgnKTtcbiAgICAgICAgICAgIHRoaXMuX3hySWNvbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndmlld0JveCcsICcwIDAgMTAwIDEwMCcpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIHN2ZyBncm91cCBmb3IgdGhlIHBhdGhzXG4gICAgICAgICAgICBjb25zdCBzdmdHcm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnZycpO1xuICAgICAgICAgICAgc3ZnR3JvdXAuY2xhc3NMaXN0LmFkZCgnc3ZnSWNvbicpO1xuICAgICAgICAgICAgdGhpcy5feHJJY29uLmFwcGVuZENoaWxkKHN2Z0dyb3VwKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBwYXRocyBmb3IgdGhlIGljb24gaXRzZWxmLCB0aGUgcGF0aCBvZiB0aGUgeHIgaGVhZHNldFxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncGF0aCcpO1xuICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsICdNMjkgNDFjLTUgMC05IDQtOSA5czQgOSA5IDkgOS00IDktOS00LTktOS05em0wIDE0Yy0yLjggMC01LTIuMi01LTVzMi4yLTUgNS01IDUgMi4yIDUgNS0yLjIgNS01IDV6bTQyLTE0Yy01IDAtOSA0LTkgOXM0IDkgOSA5IDktNCA5LTktNC05LTktOXptMCAxNGMtMi44IDAtNS0yLjItNS01czIuMi01IDUtNSA1IDIuMiA1IDUtMi4yIDUtNSA1em0xMi0zMUgxN2MtNi42IDAtMTIgNS40LTEyIDEydjI4YzAgNi42IDUuNCAxMiAxMiAxMmgxNC41YzMuNSAwIDYuOC0xLjUgOS00LjFsMy41LTRjMS41LTEuNyAzLjctMi43IDYtMi43czQuNSAxIDYgMi43bDMuNSA0YzIuMyAyLjYgNS42IDQuMSA5IDQuMUg4M2M2LjYgMCAxMi01LjQgMTItMTJWMzZjMC02LjYtNS40LTEyLTEyLTEyem04IDQwYzAgNC40LTMuNiA4LTggOEg2OC41Yy0yLjMgMC00LjUtMS02LTIuN2wtMy41LTRjLTIuMy0yLjYtNS42LTQuMS05LTQuMS0zLjUgMC02LjggMS41LTkgNC4xbC0zLjUgNEMzNiA3MSAzMy44IDcyIDMxLjUgNzJIMTdjLTQuNCAwLTgtMy42LTgtOFYzNmMwLTQuNCAzLjYtOCA4LThoNjZjNC40IDAgOCAzLjYgOCA4djI4eicpO1xuICAgICAgICAgICAgc3ZnR3JvdXAuYXBwZW5kQ2hpbGQocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3hySWNvbjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1YUkljb24uanMubWFwIiwiLy8gQ29weXJpZ2h0IEVwaWMgR2FtZXMsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmV4cG9ydCBjbGFzcyBNYXRoVXRpbHMge1xuICAgIC8qKlxuICAgICAqIGZvcm1hdHMgQnl0ZXMgY29taW5nIGluIGZvciB2aWRlbyBzdGF0c1xuICAgICAqIEBwYXJhbSBieXRlcyAtIG51bWJlciB0byBjb252ZXJ0XG4gICAgICogQHBhcmFtIGRlY2ltYWxzIC0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gICAgICovXG4gICAgc3RhdGljIGZvcm1hdEJ5dGVzKGJ5dGVzLCBkZWNpbWFscykge1xuICAgICAgICBpZiAoYnl0ZXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnMCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmFjdG9yID0gMTAyNDtcbiAgICAgICAgY29uc3QgZG0gPSBkZWNpbWFscyA8IDAgPyAwIDogZGVjaW1hbHM7XG4gICAgICAgIGNvbnN0IHNpemVzID0gWydCeXRlcycsICdLaUInLCAnTWlCJywgJ0dpQicsICdUaUInLCAnUGlCJywgJ0VpQicsICdaaUInLCAnWWlCJ107XG4gICAgICAgIGNvbnN0IGkgPSBNYXRoLmZsb29yKE1hdGgubG9nKGJ5dGVzKSAvIE1hdGgubG9nKGZhY3RvcikpO1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCgoYnl0ZXMgLyBNYXRoLnBvdyhmYWN0b3IsIGkpKS50b0ZpeGVkKGRtKSkgKyAnICcgKyBzaXplc1tpXTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXRoVXRpbHMuanMubWFwIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8vIENvcHlyaWdodCBFcGljIEdhbWVzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbmltcG9ydCB7IENvbmZpZywgRmxhZ3MsIFBpeGVsU3RyZWFtaW5nLCBMb2dnZXIsIExvZ0xldmVsIH0gZnJvbSAnQGVwaWNnYW1lcy1wcy9saWItcGl4ZWxzdHJlYW1pbmdmcm9udGVuZC11ZTUuNic7XG5pbXBvcnQge1xuICAgIEFwcGxpY2F0aW9uLFxuICAgIFBpeGVsU3RyZWFtaW5nQXBwbGljYXRpb25TdHlsZVxufSBmcm9tICdAZXBpY2dhbWVzLXBzL2xpYi1waXhlbHN0cmVhbWluZ2Zyb250ZW5kLXVpLXVlNS42JztcbmNvbnN0IFBpeGVsU3RyZWFtaW5nQXBwbGljYXRpb25TdHlsZXMgPSBuZXcgUGl4ZWxTdHJlYW1pbmdBcHBsaWNhdGlvblN0eWxlKCk7XG5QaXhlbFN0cmVhbWluZ0FwcGxpY2F0aW9uU3R5bGVzLmFwcGx5U3R5bGVTaGVldCgpO1xuXG5leHBvcnQgY2xhc3MgUGl4ZWxTdHJlYW1pbmdGcmFtZSB7XG4gICAgZWxlbWVudDogSFRNTEVsZW1lbnQ7XG4gICAgcGl4ZWxTdHJlYW1pbmdBcHA6IEFwcGxpY2F0aW9uO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQsIHBpeGVsU3RyZWFtaW5nQXBwOiBBcHBsaWNhdGlvbikge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnBpeGVsU3RyZWFtaW5nQXBwID0gcGl4ZWxTdHJlYW1pbmdBcHA7XG4gICAgfVxufVxuXG4vLyBUaGlzIGlzIHRoZSBlbnRyeXBvaW50IHRvIHRoZSBzdHJlc3MgdGVzdCwgYWxsIHNldHVwIGhhcHBlbnMgaGVyZVxuZXhwb3J0IGNsYXNzIFN0cmVzc1Rlc3RlciB7XG4gICAgcGxheTogYm9vbGVhbjtcbiAgICBtYXhQZWVyczogbnVtYmVyO1xuICAgIHRvdGFsU3RyZWFtczogbnVtYmVyO1xuICAgIHN0cmVhbUNyZWF0aW9uSW50ZXJ2YWxNczogbnVtYmVyO1xuICAgIHN0cmVhbURlbGV0aW9uSW50ZXJ2YWxNczogbnVtYmVyO1xuICAgIHBpeGVsU3RyZWFtaW5nRnJhbWVzOiBBcnJheTxQaXhlbFN0cmVhbWluZ0ZyYW1lPjtcbiAgICBjcmVhdGlvbkludGVydmFsSGFuZGxlOiBudW1iZXI7XG4gICAgZGVsZXRpb25JbnRlcnZhbEhhbmRsZTogbnVtYmVyO1xuICAgIHN0cmVhbXNDb250YWluZXI6IEhUTUxFbGVtZW50O1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucGxheSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1heFBlZXJzID0gMztcbiAgICAgICAgdGhpcy50b3RhbFN0cmVhbXMgPSAwO1xuICAgICAgICB0aGlzLnN0cmVhbUNyZWF0aW9uSW50ZXJ2YWxNcyA9IDEwMDA7XG4gICAgICAgIHRoaXMuc3RyZWFtRGVsZXRpb25JbnRlcnZhbE1zID0gNDAwMDtcbiAgICAgICAgdGhpcy5waXhlbFN0cmVhbWluZ0ZyYW1lcyA9IFtdO1xuICAgICAgICB0aGlzLmNyZWF0aW9uSW50ZXJ2YWxIYW5kbGUgPSBudWxsO1xuICAgICAgICB0aGlzLmRlbGV0aW9uSW50ZXJ2YWxIYW5kbGUgPSBudWxsO1xuICAgICAgICAvLyBHZXQgYSBjb250YWluZXIgdG8gcHV0IHRoZSBcIlBpeGVsIFN0cmVhbWluZ1wiIHBhZ2VzIGluLlxuICAgICAgICB0aGlzLnN0cmVhbXNDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RyZWFtc0NvbnRhaW5lcicpO1xuICAgICAgICBMb2dnZXIuSW5pdExvZ2dpbmcoTG9nTGV2ZWwuV2FybmluZywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgc3RhcnRTdHJlc3NUZXN0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnNldHVwTnVtUGVlcnNTbGlkZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydFN0cmVhbUNyZWF0aW9uKCk7XG4gICAgICAgIHRoaXMuc3RhcnRTdHJlYW1EZWxldGlvbigpO1xuICAgICAgICB0aGlzLnNldHVwUGxheVBhdXNlKCk7XG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NyZWF0aW9uSW50ZXJ2YWxJbnB1dCcpLm9uY2hhbmdlID0gKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NyZWF0aW9uSW50ZXJ2YWxJbnB1dCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IE51bWJlci5wYXJzZUludChpbnB1dEVsZW0udmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocGFyc2VkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1DcmVhdGlvbkludGVydmFsTXMgPSBwYXJzZWRWYWx1ZSAqIDEwMDAuMDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3RyZWFtQ3JlYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGVsZXRpb25JbnRlcnZhbElucHV0Jykub25jaGFuZ2UgPSAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dEVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGVsZXRpb25JbnRlcnZhbElucHV0JykgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gTnVtYmVyLnBhcnNlSW50KGlucHV0RWxlbS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihwYXJzZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbURlbGV0aW9uSW50ZXJ2YWxNcyA9IHBhcnNlZFZhbHVlICogMTAwMC4wO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTdHJlYW1EZWxldGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGNyZWF0aW9uSW50ZXJ2YWxJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjcmVhdGlvbkludGVydmFsSW5wdXQnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICBjcmVhdGlvbkludGVydmFsSW5wdXQudmFsdWUgPSAodGhpcy5zdHJlYW1DcmVhdGlvbkludGVydmFsTXMgLyAxMDAwLjApLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgY29uc3QgZGVsZXRpb25JbnRlcnZhbElucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RlbGV0aW9uSW50ZXJ2YWxJbnB1dCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgIGRlbGV0aW9uSW50ZXJ2YWxJbnB1dC52YWx1ZSA9ICh0aGlzLnN0cmVhbURlbGV0aW9uSW50ZXJ2YWxNcyAvIDEwMDAuMCkudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldHVwTnVtUGVlcnNTbGlkZXIoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG5QZWVyc1NsaWRlcjogSFRNTElucHV0RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduUGVlcnNTbGlkZXInKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICBuUGVlcnNTbGlkZXIudmFsdWUgPSB0aGlzLm1heFBlZXJzLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgY29uc3QgblBlZXJzTGFiZWw6IEhUTUxFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25QZWVyTGFiZWwnKTtcbiAgICAgICAgblBlZXJzTGFiZWwuaW5uZXJIVE1MID0gdGhpcy5tYXhQZWVycy50b1N0cmluZygpO1xuXG4gICAgICAgIG5QZWVyc1NsaWRlci5vbmNoYW5nZSA9IChldmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0RWxlbSA9IGV2ZW50LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBOdW1iZXIucGFyc2VJbnQoaW5wdXRFbGVtLnZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocGFyc2VkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhQZWVycyA9IHBhcnNlZFZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5QZWVyc0xhYmVsOiBIVE1MRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduUGVlckxhYmVsJyk7XG4gICAgICAgICAgICAgICAgblBlZXJzTGFiZWwuaW5uZXJIVE1MID0gdGhpcy5tYXhQZWVycy50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhcnRTdHJlYW1DcmVhdGlvbigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuY3JlYXRpb25JbnRlcnZhbEhhbmRsZSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNyZWF0aW9uSW50ZXJ2YWxIYW5kbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jcmVhdGlvbkludGVydmFsSGFuZGxlID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBsYXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJOUGVlcnMgPSB0aGlzLnBpeGVsU3RyZWFtaW5nRnJhbWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoY3VyTlBlZXJzID49IHRoaXMubWF4UGVlcnMpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1heFBlZXJzVG9DcmVhdGUgPSB0aGlzLm1heFBlZXJzIC0gY3VyTlBlZXJzO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5QZWVyc1RvQ3JlYXRlID0gTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiBtYXhQZWVyc1RvQ3JlYXRlKTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgblBlZXJzVG9DcmVhdGU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwc0ZyYW1lID0gdGhpcy5jcmVhdGVQaXhlbFN0cmVhbWluZ0ZyYW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLnBpeGVsU3RyZWFtaW5nRnJhbWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcHNGcmFtZS5lbGVtZW50LmlkID0gYFBpeGVsU3RyZWFtaW5nRnJhbWVfJHtuICsgMX1gO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbXNDb250YWluZXIuYXBwZW5kKHBzRnJhbWUuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGl4ZWxTdHJlYW1pbmdGcmFtZXMucHVzaChwc0ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3RhbFN0cmVhbXMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUb3RhbFN0cmVhbXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuc3RyZWFtQ3JlYXRpb25JbnRlcnZhbE1zKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXJ0U3RyZWFtRGVsZXRpb24oKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmRlbGV0aW9uSW50ZXJ2YWxIYW5kbGUpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5kZWxldGlvbkludGVydmFsSGFuZGxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVsZXRpb25JbnRlcnZhbEhhbmRsZSA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGxheSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBjdXJOUGVlcnMgPSB0aGlzLnBpeGVsU3RyZWFtaW5nRnJhbWVzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChjdXJOUGVlcnMgPT09IDApIHJldHVybjtcblxuICAgICAgICAgICAgY29uc3QgblBlZXJzVG9EZWxldGUgPSBNYXRoLmNlaWwoTWF0aC5yYW5kb20oKSAqIGN1ck5QZWVycyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5QZWVyc1RvRGVsZXRlOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwc0ZyYW1lID0gdGhpcy5waXhlbFN0cmVhbWluZ0ZyYW1lcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBIVE1MIGVsZW1lbnQgZnJvbSBET01cbiAgICAgICAgICAgICAgICBwc0ZyYW1lLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwc0ZyYW1lLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIC8vIERpc2Nvbm5lY3QgUGl4ZWwgU3RyZWFtaW5nIGFwcGxpY2F0aW9uIHNvIHdlIGRvbid0IGhhdmUgb3JwaGFuZWQgV2ViUlRDL1dlYlNvY2tldC9QZWVyQ29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgICBwc0ZyYW1lLnBpeGVsU3RyZWFtaW5nQXBwLnN0cmVhbS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgcHNGcmFtZT8ucGl4ZWxTdHJlYW1pbmdBcHAuc3RyZWFtLndlYlJ0Y0NvbnRyb2xsZXIuZGVzdHJveVZpZGVvUGxheWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuc3RyZWFtRGVsZXRpb25JbnRlcnZhbE1zKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldHVwUGxheVBhdXNlKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBwbGF5UGF1c2VCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGxheVBhdXNlJyk7XG4gICAgICAgIHBsYXlQYXVzZUJ0bi5pbm5lckhUTUwgPSB0aGlzLnBsYXkgPyAnUGF1c2UnIDogJ1BsYXknO1xuXG4gICAgICAgIHBsYXlQYXVzZUJ0bi5vbmNsaWNrID0gKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbGF5ID0gIXRoaXMucGxheTtcbiAgICAgICAgICAgIHBsYXlQYXVzZUJ0bi5pbm5lckhUTUwgPSB0aGlzLnBsYXkgPyAnUGF1c2UnIDogJ1BsYXknO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlUGl4ZWxTdHJlYW1pbmdGcmFtZSgpOiBQaXhlbFN0cmVhbWluZ0ZyYW1lIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtRnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICBjb25zdCBjb25maWcgPSBuZXcgQ29uZmlnKCk7XG4gICAgICAgIGNvbmZpZy5zZXRGbGFnRW5hYmxlZChGbGFncy5BdXRvQ29ubmVjdCwgdHJ1ZSk7XG4gICAgICAgIGNvbmZpZy5zZXRGbGFnRW5hYmxlZChGbGFncy5BdXRvUGxheVZpZGVvLCB0cnVlKTtcbiAgICAgICAgY29uZmlnLnNldEZsYWdFbmFibGVkKEZsYWdzLlN0YXJ0VmlkZW9NdXRlZCwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgTmF0aXZlIERPTSBkZWxlZ2F0ZSBpbnN0YW5jZSB0aGF0IGltcGxlbWVudHMgdGhlIERlbGVnYXRlIGludGVyZmFjZSBjbGFzc1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgUGl4ZWxTdHJlYW1pbmcoY29uZmlnKTtcbiAgICAgICAgY29uc3QgYXBwbGljYXRpb24gPSBuZXcgQXBwbGljYXRpb24oe1xuICAgICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgICAgb25Db2xvck1vZGVDaGFuZ2VkOiAoaXNMaWdodE1vZGU6IGFueSkgPT5cbiAgICAgICAgICAgICAgICBQaXhlbFN0cmVhbWluZ0FwcGxpY2F0aW9uU3R5bGVzLnNldENvbG9yTW9kZShpc0xpZ2h0TW9kZSlcbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbUZyYW1lLmFwcGVuZENoaWxkKGFwcGxpY2F0aW9uLnJvb3RFbGVtZW50KTtcblxuICAgICAgICByZXR1cm4gbmV3IFBpeGVsU3RyZWFtaW5nRnJhbWUoc3RyZWFtRnJhbWUsIGFwcGxpY2F0aW9uKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVRvdGFsU3RyZWFtcygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgblN0cmVhbXNMYWJlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduU3RyZWFtc0xhYmVsJyk7XG4gICAgICAgIG5TdHJlYW1zTGFiZWwuaW5uZXJIVE1MID0gdGhpcy50b3RhbFN0cmVhbXMudG9TdHJpbmcoKTtcbiAgICB9XG59XG5cbmNvbnN0IHRlc3RlciA9IG5ldyBTdHJlc3NUZXN0ZXIoKTtcbnRlc3Rlci5zdGFydFN0cmVzc1Rlc3QoKTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9